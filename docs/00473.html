<html>
<head>
<title>Simulating Bird Flock Behavior in Python Using Boids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Boids模拟Python中的鸟群行为</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/boids-simulating-birds-flock-behavior-in-python-9fff99375118?source=collection_archive---------0-----------------------#2019-05-28">https://betterprogramming.pub/boids-simulating-birds-flock-behavior-in-python-9fff99375118?source=collection_archive---------0-----------------------#2019-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2805" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">群体智能带来的编码乐趣</h2></div><p id="c0dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://github.com/roholazandie/boids" rel="noopener ugc nofollow" target="_blank">见GitHub回购本</a></p><p id="dfc8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许你已经被一群逆着夕阳飞翔的鸟儿的迷人流动迷住了。数百甚至数千只鸟一起飞翔，形成无尽的形状，就好像它们是一个整体，这是一个令人难以置信的景象。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/3958d9e64ba5d665f33d0eb78c70aaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NY7lov3Kokm3i9ZL7fs9vw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">鸟群</p></figure><p id="b704" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对许多人来说，这是一个浪漫的场景，但今天不是诗歌或浪漫的日子。相反，我打算用Python实现类似的东西，向理解复杂系统迈出一小步。用诺贝尔奖得主物理学家理查德·p·费曼的话说:</p><blockquote class="lv"><p id="195f" class="lw lx it bd ly lz ma mb mc md me ld dk translated"><em class="mf">我不能创造的东西我不懂。</em></p></blockquote><p id="3de4" class="pw-post-body-paragraph ki kj it kk b kl mg ju kn ko mh jx kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">让我们开始欢乐吧！</p><h1 id="31ac" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">群体智能</h1><p id="ebd9" class="pw-post-body-paragraph ki kj it kk b kl nd ju kn ko ne jx kq kr nf kt ku kv ng kx ky kz nh lb lc ld im bi translated">我不会深入研究群体智能，但我会尝试总结它的要点。简而言之，对自然的经典理解是有限的主体相互作用——例如，几个粒子相互施加作用力——对于任何超过十几个粒子和数百个相互作用的复杂系统来说，这都不是一个好的模型。经典系统是有意义的，因为它们遵循我们所知的“常识”。现实的经典图景建立在几个假设之上，在这里我将列举出其中最相关的几个:</p><ol class=""><li id="e5cd" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated">一个复杂的系统应该有复杂的规则来管理</li><li id="20b8" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">一个复杂的系统需要一个管理者(或创造者)来创造、维护和引导它。</li></ol><p id="ca43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些规则对于真实的系统(复杂的)来说根本不成立，这就是故事有趣的地方！</p><p id="73ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，复杂系统可以遵循一套非常简单且有限的规则。但是这些系统如何表现出复杂的行为呢？答案是通过一种被称为<a class="ae le" href="https://en.wikipedia.org/wiki/Emergence" rel="noopener ugc nofollow" target="_blank">的机制出现</a>。</p><p id="5d50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，复杂系统不需要创造者——它们是<a class="ae le" href="https://en.wikipedia.org/wiki/Self-organization" rel="noopener ugc nofollow" target="_blank">自组织的</a>！被浪费鸟群就是一个例子。很长一段时间，鸟类的群集行为是一个谜。有些人甚至认为，用当前的科学无法轻易解释群集现象。然而，随后的仔细研究表明，这实际上非常简单。</p><p id="7dde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">克雷格·雷诺兹介绍了一个名为<a class="ae le" href="https://en.wikipedia.org/wiki/Boids" rel="noopener ugc nofollow" target="_blank"> boids </a>的系统，该系统可以模拟类似鸟类的群集行为。他的人工生命模型遵循三个简单的规则:</p><ul class=""><li id="7f49" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nw no np nq bi translated"><strong class="kk iu">分离</strong>:转向以避免拥挤当地的絮凝物</li><li id="3578" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nw no np nq bi translated"><strong class="kk iu">对准</strong>:转向当地队友的平均航向</li><li id="dd55" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nw no np nq bi translated"><strong class="kk iu">凝聚力</strong>:转向向本地群体的平均位置(重心)移动</li></ul><p id="6004" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有上述规则，你才能看到涌现的复杂性几乎是无中生有的。</p><h1 id="d574" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">用Python实现</h1><p id="3f5b" class="pw-post-body-paragraph ki kj it kk b kl nd ju kn ko ne jx kq kr nf kt ku kv ng kx ky kz nh lb lc ld im bi translated">因为我们想看到结果，我们必须使用一个可以处理图形的库。我使用的库是<a class="ae le" href="https://github.com/p5py/p5" rel="noopener ugc nofollow" target="_blank">P5</a>——一个基于<a class="ae le" href="https://p5js.org/" rel="noopener ugc nofollow" target="_blank">原始js库</a>的python库。您也可以使用其他库。Youtube上有一个很好的教程<a class="ae le" href="https://www.youtube.com/watch?v=mhjuuHl6qHM" rel="noopener ugc nofollow" target="_blank">,我会试着遵循它并用Python实现。</a></p><p id="0f32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要安装<code class="fe nx ny nz oa b">p5</code>:</p><pre class="lg lh li lj gt ob oa oc od aw oe bi"><span id="160e" class="of mm it oa b gy og oh l oi oj">pip install p5</span></pre><p id="9849" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们需要创建一些“boids”作为我们的鸟。我们将这些称为boids而不是birds，因为birds只是一种可能的模型——它们可以是鱼或任何其他群集模式。为此，我们创建了一个类:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="dae6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很明显，我们需要为每个boid设置一个位置，所以我们创建了另一个名为main.py的文件，并将图形处理放在那里。在p5中，我们有两个重要的函数:<code class="fe nx ny nz oa b">setup</code>准备画布并在开始时只运行一次，函数<code class="fe nx ny nz oa b">draw</code>循环运行并负责创建最终动画的更改:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="bc56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您运行上面的代码，您应该会看到一个定义了大小和颜色的空白画布。在<code class="fe nx ny nz oa b">draw</code>中，我们每次都做同样的事情:用定义的rgb颜色绘制画布。还没有动画。</p><p id="261f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们想在画布上创建许多静态的boids。我在上面的类中添加了函数<code class="fe nx ny nz oa b">show</code>:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="bc0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nx ny nz oa b">stroke</code>功能决定笔画的颜色，而<code class="fe nx ny nz oa b">circle</code>功能在定义的位置以定义的半径创建一个圆。</p><p id="14d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们回到main.py来创建30个具有随机位置的boids:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="13a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<em class="om"> random.rand </em>生成随机数。我们现在有了类似于这个图的东西:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi on"><img src="../Images/2a8172c4327b60ce1c8abb0216b46607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lKCZEb846OSLDhfG0Hu2hg.png"/></div></div></figure><p id="381c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们想让这些点移动，我们需要定义它们的速度和加速度。如果你记得高中物理，你会知道速度和加速度是矢量对象。好消息是您不需要定义Vector类，因为<code class="fe nx ny nz oa b">p5</code>已经实现了它，以及它的所有方法和属性:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="dec4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个更新值的函数:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="c3d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们需要将它添加到main.py中:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="38b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一步的输出将会是许多随机飞来飞去然后消失的机器人:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/064fd642e343876655ab31d90021adbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Cjp_W30BP-Ykl-sTkVUVQw.gif"/></div></figure><p id="e87f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们如何把它们保存在盒子里？我们必须把盒子变成整个世界，所以每当一个机器人离开盒子，它就会在对面重新出现。为此，我们必须向boids.py添加另一个函数:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="2fe3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">添加该函数后，输出如下:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/053a817e6e29eaa0528fcb25bdedc4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*AaudOFa4bOZMWmqk1DJcCA.gif"/></div></figure><p id="bcee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以看到boids开始缓慢，然后他们有点疯狂。我们想要更流畅的动作。要做到这一点，我们必须将向量标准化，并为它们创建一个<code class="fe nx ny nz oa b">max_speed</code>限制。在下面的代码片段中，我们将<code class="fe nx ny nz oa b">max_speed</code>设置为5:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="0a9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是结果:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/ae8d69200e9bc68ec23225a05ad52248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6TzS4aU4ySlxKyvZphZB1g.gif"/></div></figure><p id="205e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个看起来不错！现在是时候给鸟群添加行为了，而不是让它们随机漂浮。</p><p id="5340" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从力学中知道，改变速度的东西叫做力，力等于加速度乘以质量。我们可以用加速度来代替力。另一方面，我们已经说过每个boid只是看到它周围的局部boid。为了对齐，我们查看局部boids并计算它们的平均方向(这是速度向量的一部分),然后跟随它。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/37ab4ddf57e9b731bc835276a10cfc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/1*vcc16ijg_e8lMOTRIhhm9w.gif"/></div></figure><p id="212c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上图中绿色的boid是当前的<em class="om"/><em class="om">boid。</em>当前boid的<em class="om"> </em>方向用绿色向量表示，但是局部絮凝物的平均方向用来自它的蓝色线表示。我们必须施加一个力，从当前的方向，朝着期望的方向。该向量由红色箭头表示，是其他两个向量的减法:</p><blockquote class="oq or os"><p id="94e4" class="ki kj om kk b kl km ju kn ko kp jx kq ot ks kt ku ou kw kx ky ov la lb lc ld im bi translated">转向= avg_vec —自身速度</p></blockquote><p id="2988" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">算法如下:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="45d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，在所有boid的循环中，我们只在某个距离寻找boid——这个距离我们称之为<code class="fe nx ny nz oa b">perception</code>(这里等于100)。这是有道理的，因为在现实世界中，鸟类只会看到当地的鸟群，并根据当地的信息来驾驶。如果boid是单独的，我们也必须小心，以确保它不做任何事情(总计&gt; 0)。然后我们归一化向量，因为我们只需要方向，然后乘以max_speed。最后，我们做减法。</p><p id="eb86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还创建了另一个函数，<code class="fe nx ny nz oa b">apply_behaviour,</code>，它负责在我们进行的过程中应用每一个规则:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="e134" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将其添加到main.py中的draw函数中:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9f11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从现在开始，我们不再改变main.py中的任何内容。结果是:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/556e8a09c832ec46854c3c11df18d0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8h9QqAyD1ok-wa9GUWlMCw.gif"/></div></figure><p id="e209" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前为止看起来很棒！但是我们还有更多事情要做。</p><p id="acea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">凝聚力意味着转向当地群体的中心。我们这样做是为了迫使机器人彼此贴紧而不分开。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/4cda2c9ffeff32eccb7855087951d4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/1*Au6eWj6jETcbVAbQWJR1-g.gif"/></div></figure><p id="4e6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须设法迫使当前的boid(绿色的那个)朝向局部boid的质心——如绿点所示。因为所有物体的质量相同，所以质心等于它们的平均位置。找到<code class="fe nx ny nz oa b">center_of_mass</code>后，我们从中减去位置。换句话说:</p><p id="d81a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="om"> vec_to_com =质心—自身位置</em></p><p id="2d87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="om">转向= vec_to_com —自身速度</em></p><p id="f5ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该功能类似于对齐:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9ba0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在上面的代码中执行了两次归一化——一次是针对朝向质心的向量，另一次是针对转向。同样，我们这样做是因为我们想要方向，幅度的控制应该由另一个参数来完成(这里是<code class="fe nx ny nz oa b">max_speed</code>和<code class="fe nx ny nz oa b">max_force</code>)。</p><p id="1047" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们将内聚力函数添加到<code class="fe nx ny nz oa b">apply_behaviour</code>函数中，但是我们希望看到它没有对齐规则:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="699c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将“最大作用力”设置为1，将“最大速度”设置为10，就会发生这种情况:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/0c00779901b0f51787809093141406ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6VUKWDXTYnxih9dHja2a2A.gif"/></div></figure><p id="2f6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，机器人试图彼此靠近，这正是我们所期待的。</p><p id="1b8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在到了最后一条规则:分离。分离是必要的，这样我们的机器人就不会撞在一起。每个boid应该看到他们自己的本地flockmates，如果他们太接近。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5b9b29295671657328ea02269d713cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/1*e8AAGeLm9x0i6kkO4_Yenw.gif"/></div></figure><p id="dbf2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有一个微妙之处:我们希望boid更多地避开更近的boid，而不是它们视野范围内的远处boid(圆圈)。越近的人施加的力越大。我们需要使用距离反比定律:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d9c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，在主循环中，我们跟踪距离，并将<code class="fe nx ny nz oa b">diff</code>向量——逃跑的方向——除以到特定絮凝物的距离。如果我们加上这条规则，我们就有:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/e752438c909fcf0f63340c0c00b1df74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*A58pk1lwJlMBtJ9qI9-gug.gif"/></div></figure><p id="9f06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以看到每个boid都渴望尽可能远离所有其他人——好像他们不喜欢社交！</p><p id="856e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在整篇文章中，我交替使用了力和加速度。现在我们可以利用力的叠加定律同时施加所有的加速度:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/c164c51c900e280c77156d69233310ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/1*sSvtwzurosHc4u1rnkrPKw.gif"/></div></figure><p id="ebfc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们只用向量加法:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="03d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是应用所有这些规则的最终结果:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b24b8a9edac5d7cbd9b4cb3ea5e6ba8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*9PSXWGTzahizTAPpk8DGqQ.gif"/></div></figure><p id="2892" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我要找的东西！有几件事要提一下。这完全是真实世界鸟类的行为。这是一个人工生命作品，试图模拟现实世界的现象，并展示真实系统如何遵循简单的规则，却表现出复杂的行为。boids向我们展示了复杂性可以从自组织过程中产生。</p><p id="b3f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种编程中有一些不同之处:你不能决定显示什么样的模式。当然，您可以调整参数来查看不同类别的行为，但最终系统会产生独特的模式。<strong class="kk iu"> <em class="om">这是规则和随机性的相互作用。</em>T11】</strong></p><h1 id="a86c" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">一个技术细节</h1><p id="bdb4" class="pw-post-body-paragraph ki kj it kk b kl nd ju kn ko ne jx kq kr nf kt ku kv ng kx ky kz nh lb lc ld im bi translated">如果你运行这些代码，你会发现当boids的数量超过50个时(取决于你的硬件)，速度会非常慢。原因很明显，代码是低效的，并且具有O(n)的复杂度，这对于计算机科学算法来说是非常慢的。你大概意识到了，没有必要让每个boid去检查所有其他boid，所以可以通过划分空间来优化算法。这在本质上类似于优化knn算法的问题。你可以在这里找到一些补救措施。</p><p id="2287" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我试图使用<a class="ae le" href="https://github.com/ray-project/ray" rel="noopener ugc nofollow" target="_blank"> Ray </a>库来并行化规则，但这并没有产生巨大的差异。你可以在<a class="ae le" href="https://github.com/roholazandie/boids" rel="noopener ugc nofollow" target="_blank">我的GitHub回购</a>里看到。如果你发现任何解决方案，使速度大幅度提高，发送一个推送请求给我！</p></div></div>    
</body>
</html>