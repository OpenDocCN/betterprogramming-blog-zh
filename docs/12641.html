<html>
<head>
<title>Understanding Hexagonal Architecture With a Spring Boot Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring Boot实现理解六边形架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hexagonal-architecture-with-spring-boot-74e93030eba3?source=collection_archive---------0-----------------------#2022-06-19">https://betterprogramming.pub/hexagonal-architecture-with-spring-boot-74e93030eba3?source=collection_archive---------0-----------------------#2022-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9395" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个使用Spring Boot详细说明应用程序不同层的例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6dd62e9e7276a14466011cec9433b4b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OEPZo1ohCyQHkTBU"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">唐尼·姜在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e5a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">六角形建筑是由阿利斯泰尔·考克伯恩在2005年提出的。</p><p id="edda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种架构背后的主要思想是在设计软件应用程序时将领域逻辑与外部组件隔离开来。</p><p id="ad5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过端口和适配器可以从外部访问域逻辑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/6cf43b26d9bc646a70d7889ca544e383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*N7tlxqOLXiPLy_yrb0q7-Q.png"/></div></figure><p id="6da7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">端口只是一个由适配器实现的接口。有两种类型的端口:输入和输出。我们在领域层实现第一个，而基础设施模块将包含第二个的实现。</p><p id="8e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种方法，您将拥有定义良好的接口来在域层内外进行通信，而不依赖于实现细节。</p><h1 id="a3b0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">示例</strong></h1><p id="4704" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们考虑一个简单的Product REST服务来理解这个架构。产品服务的资源有:</p><ul class=""><li id="b025" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">创造产品</li><li id="835e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">通过Id获取产品</li></ul><p id="918c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始创建三层:<code class="fe ne nf ng nh b">application</code>、<code class="fe ne nf ng nh b">infrastructure</code>和<code class="fe ne nf ng nh b">domain</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/76e6c4fd2317b857f1876eb926d455f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*qQQ9xIP4KW-X4hptC2dEyA.png"/></div></figure><h2 id="daef" class="nj lu iq bd lv nk nl dn lz nm nn dp md lf no np mf lj nq nr mh ln ns nt mj nu bi translated"><strong class="ak"> <em class="nv">申请</em> </strong></h2><p id="c2e9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">应用层将包含端口，这些端口是允许入站或出站流量的接口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/a0d5365a347e044cb7bca256fda84c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*6W4PW9WUEMldisaGtwreOw.png"/></div></figure><p id="a1aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe ne nf ng nh b">input</code>包中创建了用例，定义了用户希望在应用程序中做什么。在我们的示例中，创建新产品并通过Id获取它们。</p><p id="4d25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，我们使用<code class="fe ne nf ng nh b">output</code>包来连接一些外部组件。</p><p id="9267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的示例中，<code class="fe ne nf ng nh b">ProductOutputPort</code>将从数据库中获取数据，而<code class="fe ne nf ng nh b">ProductEventPublisher</code>将在创建产品时发布一个事件。</p><h2 id="1aa5" class="nj lu iq bd lv nk nl dn lz nm nn dp md lf no np mf lj nq nr mh ln ns nt mj nu bi translated"><strong class="ak"> <em class="nv">基础设施</em> </strong></h2><p id="06c4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">基础设施层通过适配器表示六边形体系结构的外部。</p><p id="4e17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">适配器仅通过使用入站和出站端口与核心应用程序进行交互。</p><p id="eab4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将<code class="fe ne nf ng nh b">infrastructure.adapters</code>包分成三个新包:</p><ol class=""><li id="a219" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr nx mw mx my bi translated"><code class="fe ne nf ng nh b">config</code>:包含应用程序的beans</li><li id="06a5" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nx mw mx my bi translated"><code class="fe ne nf ng nh b">input</code>:通过调用相应的用例(输入端口)来驱动应用程序</li><li id="3347" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nx mw mx my bi translated"><code class="fe ne nf ng nh b">output</code>:它提供了输出端口的实现，如数据库或消息队列</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/6e38c43811cd205c247529ab567f40f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*galtyFUakPRvVu5tsvAv4A.png"/></div></figure><h2 id="8996" class="nj lu iq bd lv nk nl dn lz nm nn dp md lf no np mf lj nq nr mh ln ns nt mj nu bi translated"><strong class="ak"> <em class="nv">域</em> </strong></h2><p id="30a1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">领域层是系统的中心。它处理业务逻辑并代表应用程序核心。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/28ae727b40695d6c6c6266be45baf740.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*xiUZYTci3-7pTSWoDItLkg.png"/></div></figure><p id="515a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">域层与应用程序和基础设施层完全分离，因此其他层的变化不会影响到<code class="fe ne nf ng nh b">Product</code>域对象，除非业务需求发生了变化。</p><p id="f199" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">ProductService</code>是域内的关键组件，因为它实现输入端口，并使用输出适配器实现的输出接口将结果返回给输入适配器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="08a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">域异常在这一层抛出，在基础设施层进行管理(<code class="fe ne nf ng nh b">CustomizedExceptionAdapter</code>)。</p><h1 id="0e5e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">结论</strong></h1><p id="9f10" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在本文中，我们通过一个实例看到了如何将与我们的应用程序相关的逻辑分成三个特定的层:<code class="fe ne nf ng nh b">domain</code>、<code class="fe ne nf ng nh b">application</code>和<code class="fe ne nf ng nh b">infrastructure</code>。</p><p id="8496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我推荐使用一个映射库，比如<code class="fe ne nf ng nh b">MapStruct</code>，在不同层之间转换对象。</p><p id="9b36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有两个六边形架构是相同的，因为您可以找到不同的层名称和构建应用程序的方式。所有可能的解决方案都应该使应用程序更容易测试，这才是真正的目标。</p><p id="6f88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子的代码可以在<a class="ae kv" href="https://github.com/rbailen/Hexagonal-Architecture" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt oj nh ok ol aw om bi"><span id="4c4b" class="nj lu iq nh b gy on oo l op oq"><strong class="nh ir">Want to Connect?</strong></span><span id="9f53" class="nj lu iq nh b gy or oo l op oq">Connect with me on <a class="ae kv" href="https://www.linkedin.com/in/ramonbailensanchez" rel="noopener ugc nofollow" target="_blank">LinkedIn</a> or follow me on <a class="ae kv" href="https://twitter.com/ramromanoficial" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>