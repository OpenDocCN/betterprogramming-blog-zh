<html>
<head>
<title>My DOM Component Manifesto</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的DOM组件宣言</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2020-028-the-dom-component-manifesto-5627cb033c93?source=collection_archive---------10-----------------------#2020-10-26">https://betterprogramming.pub/2020-028-the-dom-component-manifesto-5627cb033c93?source=collection_archive---------10-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a089" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">拥抱标准比追逐框架更好</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5af30318762a5d153c0cd5ecf0b5e926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSaB3RSzUPtfKQa5Xn3YwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="d9a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">似乎每次开发人员发现一个好的编码模式，他们都想把它变成一个框架。对他们有好处。他们发现了一些有用的东西，并希望与他人分享。但是<em class="lu">我已经</em>找到了对我有用的东西，而且<em class="lu">你也可能</em>找到了。所以我们不需要他们的框架，因为它解决了他们的问题，而不是我们的问题。</p><p id="5b4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，我们需要的仅仅是一个产生好结果的一致的方法。</p><p id="90a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，为了保持一致性，我选择为我构建的所有DOM组件遵循一个标准模式，以获得那些好的结果。虽然将这种模式转变成一个框架很有诱惑力，但我有意抵制了这种冲动。那被证明是一个好决定。</p><p id="9012" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，每个DOM组件都有相同的初始化模式，对基于事件的通信的相同依赖，以及许多相同的函数名。但这是模式的终点，也是组件的独特之处的起点。开发人员不应该与一个框架作战，编写代码的唯一目的是绕过一些未解释的限制，而是应该被给予以任何有意义的方式适应我的模式——或者你的模式——的自由。</p><p id="aec1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以对我来说，框架过时了，模式流行了。但是是哪种模式呢？</p><p id="691e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">答案就在我们身边。简单来说，就是拥抱已经开发出来并免费提供给我们的语言、协议和开放标准，它们就像闪闪发光的宝藏一样摆在我们面前。</p><p id="18d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我对DOM组件的理念是接受由万维网联盟(W3C)、Ecma国际和互联网工程任务组(IETF)开发的标准。这些审议机构如此努力地为我们提供了一种方法来标记、设计、编写和交付一套不同硬件设备上的优秀网络体验。</p><p id="28f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个由五部分组成的理念包括隔离、分离、模块化、配置和最佳实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f6b2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><em class="mu"> 1。隔离</em></h1><p id="98aa" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">DOM组件的<em class="lu">存在理由</em>。这就是暗影DOM的用武之地。它在宿主文档和组件实例之间建立了防火墙。一个不能影响另一个。另外，一个非常重要的推论是，我的组件不会导致你的组件失败。</p><p id="cf7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">隔离还意味着已定义组件的每个实例都有自己的名称空间。因此，元素标识符和CSS类名可以简单明了，没有前缀或实例限定符。</p><p id="a932" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像<code class="fe na nb nc nd b">#xyzFrame001</code>这样的标识符可以缩短为<code class="fe na nb nc nd b">#frame</code>。更好的是，锚元素的CSS选择器，比如<code class="fe na nb nc nd b">a.specialLink {...}</code>，可以减少到只有<code class="fe na nb nc nd b">a {...}</code>，在很多情况下完全不需要类名。</p><p id="8eff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最重要的是，隔离消除了大量难以追踪的错误，混杂CSS似乎很容易传播这些错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6ca1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><em class="mu"> 2。分离</em></h1><p id="5b41" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">如关注点分离。这是过去二十年中最重要的软件开发咒语之一。它帮助我们取得了现在的成功。这些年来，一体化语言的使用已经减少，而用于标记、样式和脚本的独立语言的使用已经增加。可悲的是，一些全新的框架似乎忘记了这条黄金法则。</p><p id="d92f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了从优秀的工具中获益，比如语法突出显示、林挺、检查、剖析和符合性检查，我们编写的代码应该将每种语言放在自己的文件中。</p><p id="61b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法隐藏的好处是缓存。HTML模板被加载一次并被浏览器缓存，CSS声明被加载一次并被浏览器缓存，JavaScript模块被加载一次并被浏览器缓存——所有这些都是自动的，不需要我们做任何努力。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="068b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><em class="mu"> 3。模块化</em></h1><p id="3b1a" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">圣杯。JavaScript终于发展起来了，它给了我们一个将变量排除在全局范围之外的好方法。现在每个主流浏览器都支持ESNext模块，所以现在是时候拥抱模块的简单性和安全性了。</p><p id="7985" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得注意的是，这意味着没有运输或垫片，没有货单或包装开销，也没有捆扎机或分离器或装载机。这意味着我们可以简单地编写脚本并将它们直接部署到服务器上。我们可以重新发现<em class="lu">解释</em> JavaScript的乐趣。</p><p id="6d22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为浏览器只在需要的时候加载脚本，我们不需要做任何特殊的事情来获得即时、按需加载的好处。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8172" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><em class="mu"> 4。定制</em></h1><p id="23f5" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">替代设置中的用法。组件应该被设计成适应明显不同的值。组件应该允许消费者将他们自己的装饰性品牌应用到他们的视觉界面上。</p><p id="8013" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DOM标准为我们提供了三种向组件消费者公开这种定制的方式:使用开槽元素、HTML属性和CSS变量。这些是HTML和CSS语言所固有的，所以它们使用相同的语法，遵循与我们已经学过的一样的惯用表达。不像<em class="lu">道具</em>，它们看起来和感觉上都像真的一样，因为它们就是真的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be61" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.最佳实践</h1><p id="34d7" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">让一切变得更美好的指南和护栏。请记住，我们的集体成功是艰苦战斗的结果。最佳实践是所有帮助我们赢得这些战斗的策略和安全规则的精华。以下是适用于DOM组件的内容:</p><ul class=""><li id="54fb" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated">使用现代的HTTP/2服务器来消除延迟，并在一个连续的会话中将组件文件从服务器移动到浏览器。</li><li id="45e8" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">从传统的传输器/捆束器/分离器/加载器生命周期中迁移出来。采用更新的ESNext方法进行异步、模块化、可缓存的交付。</li><li id="f147" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">接受浏览器脚本基于对象模型的现实。在脚本中使用类和对象实例。毕竟，整个DOM证明了面向对象编程是可行的。</li><li id="b95f" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">停止追逐<code class="fe na nb nc nd b">undefined</code>错误。用已声明的类替换匿名对象，这些类具有明确定义的形状和正确的构造函数初始化。</li><li id="219f" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">使用事件而不是回调。记住，20世纪80年代最大的突破是事件驱动编程。它支持我们所有的鼠标和窗口行为。它是原始的非阻塞编码模式。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5e5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="761f" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">这个宣言的催化剂是这些<a class="ae ns" href="https://domcomponents.com/components.blue" rel="noopener ugc nofollow" target="_blank">开源DOM组件</a>。要更深入地探究其背后的哲学，请参见<a class="ae ns" href="https://medium.com/better-programming/2020-007-the-facets-of-w3c-web-components-e76798ab7b29" rel="noopener">Web组件的7个方面</a>。</p><p id="cf54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我的宣言。五个清晰的想法解决了我所有的DOM组件问题。没有半年一次的大修来升级到最新的突破性变化框架。不再追逐闪亮的新事物。全部基于标准。一切面向未来。</p></div></div>    
</body>
</html>