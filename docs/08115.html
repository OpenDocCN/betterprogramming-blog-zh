<html>
<head>
<title>12 Examples To Understand Python User-Defined Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python用户定义函数的12个例子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-user-defined-functions-65f8662e2528?source=collection_archive---------0-----------------------#2021-03-28">https://betterprogramming.pub/python-user-defined-functions-65f8662e2528?source=collection_archive---------0-----------------------#2021-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="69f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从语法、文档、参数和自变量到局部和全局变量的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6e790e6363ebf48069c20bbdd7c6cd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bblmTgDqAGJc24yT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@writecodenow?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Boitumelo Phetla </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你好，欢迎来到我的Python用户定义函数指南。本文将涵盖Python用户定义函数的基础知识、您必须掌握的语法，以及帮助您巩固新获得的知识的示例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="682e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="da68" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">简单来说，函数接受输入，执行计算，并产生输出。Python有用户自定义函数、匿名函数和内置函数，比如<code class="fe mz na nb nc b">print()</code>函数。我敢肯定，你们都会把<code class="fe mz na nb nc b">print()</code>函数看作是通向精彩编程世界的入门代码。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8a5a" class="nh md it nc b gy ni nj l nk nl">print("Hello World")<br/>&gt;&gt;&gt; Hello World</span></pre><p id="b8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，今天我们将把重点放在用户自定义函数上。在编程中，你最终会到达一个点，在那里你会一遍又一遍地重复同样的代码。这既耗时又不必要的重复。在编程中，这个有个缩写:DRY(不要重复自己)！为了避免这种情况，您可以定义自己的函数。这将有助于使你的代码有条理，可管理，可重用。这个想法是，你可以在必要的时候调用(使用)你的函数，而不是为不同的输入反复编写相同的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/ee9abecbaa566e6cb88fccad48643aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlfBOy2sUViYJPB5wvunuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.flickr.com/photos/foggodavid/5998340587" rel="noopener ugc nofollow" target="_blank">flickr.com</a></p></figure><p id="9807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法是定义代码的一组规则(在这里是您的函数)。</p><h2 id="25ba" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">第一行(表头)</h2><ul class=""><li id="6cee" class="ny nz it lb b lc mu lf mv li oa lm ob lq oc lu od oe of og bi translated">关键词<code class="fe mz na nb nc b">def</code></li><li id="f582" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">函数名(保持相关性—链接到<a class="ae ky" href="https://www.python.org/dev/peps/pep-0008/#:~:text=Use%20the%20function%20naming%20rules,invoke%20Python's%20name%20mangling%20rules." rel="noopener ugc nofollow" target="_blank">命名约定</a>)</li><li id="7149" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">圆括号<code class="fe mz na nb nc b">()</code>，可以包含也可以不包含参数和自变量</li><li id="d20f" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">和一个冒号<code class="fe mz na nb nc b">:</code></li></ul><h2 id="71cb" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">函数/语句块(体)</h2><ul class=""><li id="fd41" class="ny nz it lb b lc mu lf mv li oa lm ob lq oc lu od oe of og bi translated">功能块的下面几行包括该功能应该做什么。所有这些行都必须缩进(按Tab)。</li><li id="6c57" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">函数的第一条语句可以是可选语句、函数的文档字符串或docstring。可以用<code class="fe mz na nb nc b">help(function_name)</code>或<code class="fe mz na nb nc b">print(function_name.__doc__)</code>调用。我将在下面详细介绍。</li><li id="cfa1" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">语句<code class="fe mz na nb nc b">return [expression/value]</code>退出一个函数，向用户返回一个值或表达式。不带参数的return语句与<code class="fe mz na nb nc b">return None</code>相同。</li><li id="e6ba" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">如果不使用return语句，函数将不返回值(void函数)。这方面的一个例子是<code class="fe mz na nb nc b">print()</code>函数。它只是在你的屏幕上打印输出；但是，没有赋值，也不能被其他函数调用。当赋给一个变量时，该变量将没有值。</li></ul><h2 id="df26" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">调用/使用该功能</h2><ul class=""><li id="dcab" class="ny nz it lb b lc mu lf mv li oa lm ob lq oc lu od oe of og bi translated">要调用函数，只需在没有缩进的新行上键入函数名，后跟括号(以及所需的任何参数)。</li></ul><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7845" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu"># Example 1</strong></span><span id="70bf" class="nh md it nc b gy om nj l nk nl"><strong class="nc iu">def</strong> function_name(Parameters / Arguments):<br/>        "function_docstring"<br/>         function / computations<br/>         <strong class="nc iu">return</strong> expression / value </span><span id="15c2" class="nh md it nc b gy om nj l nk nl">function_name(Parameters / Arguments)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c5df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">文档字符串</h1><p id="98a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在编程世界中，为了更好地阅读，编写代码文档是标准的做法。这可以是以<a class="ae ky" href="https://www.python.org/dev/peps/pep-0008/#comments" rel="noopener ugc nofollow" target="_blank">注释</a>或<a class="ae ky" href="https://www.python.org/dev/peps/pep-0008/#documentation-strings" rel="noopener ugc nofollow" target="_blank">文档字符串</a>的形式。<strong class="lb iu"> </strong>(点击链接了解更多关于Python约定的信息。)重要的是将你的代码文档化，让第三方用户能够理解，例如在工作项目或开源协作中。注释和文档字符串也将使单个项目更容易回忆起来。</p><p id="d390" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么什么是docstring呢？docstring是一个字符串文字，用于描述函数做什么，而不是如何使用它。使用该函数的第三方用户可以读取docstring，以便更好地掌握参数、条件、返回的内容以及可能出现的任何错误。对于简单的函数，Docstrings可以是一行，对于更深入的函数，可以是多行。按照惯例，文档字符串用三重引号括起来，并缩进到紧接函数名的那一行。</p><h2 id="4dfb" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">一行程序</h2><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="94e6" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu"># Example 2</strong></span><span id="dc3e" class="nh md it nc b gy om nj l nk nl"><strong class="nc iu">def</strong> squared_number(x):<br/>       """ Argument passed into x returns x squared """<br/>       <strong class="nc iu">return</strong> x*x</span></pre><h2 id="868c" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">多衬里</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5f22" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参数和自变量</h1><p id="73aa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">形参和实参本质上是一样的东西。参数是函数括号中列出的变量名，而实参是调用(使用)函数时通过参数传递的值。参数可以是变量、值或对象。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8318" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu"># Example 4</strong></span><span id="ea98" class="nh md it nc b gy om nj l nk nl"><strong class="nc iu">def</strong> summation(a,b):<br/>      """ return a - b """<br/>      <strong class="nc iu">return</strong> a - b</span></pre><p id="b1eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些参数分别命名为<code class="fe mz na nb nc b">a</code>和<code class="fe mz na nb nc b">b</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5417" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">print</strong>(summation(3,6))<br/>&gt;&gt;&gt; -3</span></pre><p id="113a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们调用函数时，实参通过这些参数传递。<code class="fe mz na nb nc b">3</code>通过参数<code class="fe mz na nb nc b">a</code>传递，<code class="fe mz na nb nc b">6</code>通过<code class="fe mz na nb nc b">b</code>传递。这些参数称为位置参数，必须在正确的位置调用。</p><p id="a0f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>如果您为固定位置参数调用了错误数量的参数，该函数将返回一个错误。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="40f1" class="nh md it nc b gy ni nj l nk nl">print(summation(6))</span><span id="abad" class="nh md it nc b gy om nj l nk nl">&gt;&gt;&gt;TypeError: summation() missing 1 required positional argument:'b'</span></pre><p id="93a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">争论有多种形式。到目前为止，我们只看到了固定的位置参数。还有另外三种常用的论证形式。它们是默认参数、关键字参数和任意参数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c86d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">默认参数</h1><p id="30b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，函数参数可以有默认值。简单地说，如果一个值对于80%或更多的使用是合理的，那么它需要是一个默认值。这使得调用函数更加简洁，同时仍然允许配置。定义函数时，可以使用Python中的赋值运算符(<code class="fe mz na nb nc b">=</code>)为参数赋值默认值。如果调用没有参数值的函数，将使用其默认值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d6e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，首先只使用强制的<code class="fe mz na nb nc b">name</code>参数调用函数。如果没有调用名字，函数将返回一个错误。然而，<code class="fe mz na nb nc b">msg</code>参数被留空，导致函数打印默认值“早安”对该函数的第二次调用提供了强制的<code class="fe mz na nb nc b">name</code>参数和一个用于<code class="fe mz na nb nc b">msg</code>参数的新值(导致默认值被覆盖)。</p><p id="0614" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>任何数量的参数都可以有一个默认值，但是一旦使用了一个，后面的每个参数也必须有一个默认值；否则该函数将返回一个错误。简而言之，任何固定位置参数都必须放在默认参数之前。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="23ea" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">def</strong> greet(msg = "Good morning!", name):</span><span id="ba8d" class="nh md it nc b gy om nj l nk nl">&gt;&gt;&gt;SyntaxError: non-default argument follows default argument</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2786" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关键字参数</h1><p id="0a24" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">关键字参数有助于使您的函数调用更加明确，因为它清楚地表明了每个参数所代表的内容。关键字参数的另一个积极属性是，它们可以在不适当的位置被调用，从而提高代码的可读性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个调用验证了上面提出的观点:关键字参数允许简洁清晰的可读性，并且能够在位置之外调用。从视觉上看，您可以更好地理解作为参数传递的度量。</p><p id="049b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个调用重申了固定位置参数必须在任何关键字参数/默认参数之前调用的事实。定义和调用函数时，同样的规则也适用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b8c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">武断的论点</h1><p id="385a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以用任意数量的参数定义一个函数。换句话说，参数的数量不需要固定。这可以通过解包操作实现。</p><p id="6426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解包运算符是从可迭代对象中解包值的运算符。单星号操作符<code class="fe mz na nb nc b">*</code>可以用于任何iterable，而双星号操作符<code class="fe mz na nb nc b">**</code>只能用于关键字参数(字典)。</p><h2 id="e2a0" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><strong class="ak"> *args </strong></h2><p id="0667" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你不知道在运行时之前你将通过一个函数传递多少个参数，会发生什么？你可以写一个列表并通过你的函数传递它，但是这可能不太方便。这就是<code class="fe mz na nb nc b">*args</code>真正有用的地方，因为它允许传递不同数量的位置参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="63bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传递给函数的位置参数将被解包到一个名为<code class="fe mz na nb nc b">args</code>的iterable对象中，它是一个元组。元组支持切片和迭代。然而，元组是不可变的。因此，您不能修改对象中的值。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="728e" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">def</strong> karate_roster(*names):<br/>      <strong class="nc iu">pass</strong></span></pre><p id="1165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量<code class="fe mz na nb nc b">args</code> <strong class="lb iu"> </strong>只是一个名字，可以更改，尽管使用<code class="fe mz na nb nc b">args</code>作为命名协议是Python的惯例。</p><p id="ae44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>函数体中的<code class="fe mz na nb nc b">pass</code> <strong class="lb iu"> </strong>语句是用作未来代码的占位符。拥有一个空的主体通常会返回一个错误，从而终止程序执行。</p><h2 id="0097" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><strong class="ak">* *夸脱</strong></h2><p id="38ed" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">**kwargs</code>的工作方式和<code class="fe mz na nb nc b">*args</code>一样，但是它不接受位置参数，而是接受关键字参数。这些关键字将被解压缩到一个可迭代的字典对象中。记住这一点，内置的字典方法，比如<code class="fe mz na nb nc b">item()</code>，可以应用于对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="b82f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数解包使用<code class="fe mz na nb nc b">**kwargs </code>操作符创建的dictionary对象。然后，它使用<code class="fe mz na nb nc b">item()</code>方法检查每个字典条目。如果关键字(孩子的名字)已经存在于字典中，它将孩子的值(出勤频率)加1。如果是孩子的第一次，将为他们创建一个值为1的新密钥。</p><p id="0d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个关于<code class="fe mz na nb nc b">**kwargs </code>如何提高代码可读性、可重用性和效率的例子。教师不必根据有多少孩子来上课而编辑或创建新的函数，教师可以简单地预计不同数量的学生，调用他的函数并使用<code class="fe mz na nb nc b">**kwargs</code>解包。</p><p id="8ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量<code class="fe mz na nb nc b">kwargs</code> <strong class="lb iu"> </strong>只是一个名字，可以更改，尽管使用<code class="fe mz na nb nc b">kwargs</code>作为命名协议是Python的惯例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7a82" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">命令</h1><p id="a36e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">记住必须定义或传递参数的顺序很重要:</p><ol class=""><li id="4173" class="ny nz it lb b lc ld lf lg li op lm oq lq or lu os oe of og bi translated">位置参数</li><li id="2c91" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu os oe of og bi translated">默认值、关键字和<code class="fe mz na nb nc b">*args</code>参数</li><li id="a39f" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu os oe of og bi translated"><code class="fe mz na nb nc b">**kwargs</code>论据</li></ol><p id="b8fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误地传递或定义它们将导致引发错误。以下示例显示了正确和不正确的参数顺序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ca70" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">全局和局部变量</h1><p id="0c77" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">理解局部变量和全局变量的概念以及它们如何与函数交互是很重要的。</p><ul class=""><li id="a410" class="ny nz it lb b lc ld lf lg li op lm oq lq or lu od oe of og bi translated">局部变量是在函数内部声明的。局部变量在函数开始执行时创建，在函数终止时丢失(永久)。</li><li id="9210" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">全局变量在函数外部声明。全局变量在执行开始时创建，在程序结束时丢失。它们也可以在函数中访问(在块内部)。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8c4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子演示了全局变量和局部变量。在函数外部，我们有一个值为<code class="fe mz na nb nc b">3</code>的变量<code class="fe mz na nb nc b">x</code>。在我们的函数中，有一个值为<code class="fe mz na nb nc b">5</code>的变量<code class="fe mz na nb nc b">x</code>。这是两个不相关的对象，互不影响。</p><p id="ff31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦函数被执行，本地<code class="fe mz na nb nc b">x</code>变量将永远丢失。然而，全局变量<code class="fe mz na nb nc b">x</code>将继续保持其值，直到程序停止运行。</p><p id="d7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果希望在函数中重新分配全局变量，可以使用关键字<code class="fe mz na nb nc b">global</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="f49d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在结束之前，我认为了解可变对象及其被局部修改的能力是很方便的。在函数(局部)内修改可变对象，如字典或列表，会对函数(全局)外的对象产生直接影响。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="e37e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不适用于不可变的对象，因为不可变的对象不能被修改或改变。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我的Python用户定义函数指南。我希望你发现它信息丰富和有用。在接下来的几周里，我将继续撰写关于内置函数和匿名函数的文章。保持快乐和健康，皮托尼斯塔。</p></div></div>    
</body>
</html>