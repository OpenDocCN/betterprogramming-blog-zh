<html>
<head>
<title>Why Are Kotlin Synthetics Deprecated and What Are the Alternatives?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Kotlin合成纤维被弃用，有什么替代品？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-are-kotlin-synthetics-deprecated-and-what-are-the-alternatives-5c2b087dda1c?source=collection_archive---------1-----------------------#2020-12-16">https://betterprogramming.pub/why-are-kotlin-synthetics-deprecated-and-what-are-the-alternatives-5c2b087dda1c?source=collection_archive---------1-----------------------#2020-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="724e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">比较使用哪一个:数据绑定与视图绑定、Kotlin合成与findViewById</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/df200881bee02d81c08ec48bc507e9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXX8o8hZLmmS_AHYIff3Wg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@louis993546?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">路易·蔡</a>在<a class="ae kv" href="https://unsplash.com/s/photos/kotlin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="da85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近Android宣布，随着Kotlin 1.4.20的推出，他们的<a class="ae kv" href="https://plugins.gradle.org/plugin/org.jetbrains.kotlin.android.extensions" rel="noopener ugc nofollow" target="_blank">Android Kotlin Extensions Gradle插件</a>将被弃用，并将不再在未来的kot Lin版本中发布。</p><p id="4bee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Android Kotlin扩展插件带来了两个非常酷的功能:</p><ul class=""><li id="0716" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">合成</strong>让你用<code class="fe mb mc md me b">kotlinx.android.synthetic</code>绑定替换对<code class="fe mb mc md me b">findViewById</code>的调用。</li><li id="1e2c" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><strong class="ky ir"> Parcelize </strong>允许您移除样板文件，并通过<code class="fe mb mc md me b">@Parcelize</code>注释轻松创建<a class="ae kv" href="https://developer.android.com/reference/android/os/Parcelable" rel="noopener ugc nofollow" target="_blank"> Parcelables </a>。</li></ul><p id="d1d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着这个插件的弃用，我们将不再能够使用这些功能。不要担心Parcelize，因为它现在将作为一个独立的插件发布:kotlin-parcelize。但这绝对会是科特林合成材料的末日。</p><p id="be91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，全球各地的Android开发人员都怀着沉重的心情向Kotlin人工合成品说再见。但首先，让我们了解一下当初为什么要引入Kotlin Synthetics，为什么它现在被弃用，以及除了它我们还有哪些选择。</p><blockquote class="mk"><p id="a1f2" class="ml mm iq bd mn mo mp mq mr ms mt lr dk translated">“需要是发明之母”</p></blockquote></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="2e45" class="nb nc iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">历史记录findViewById</h1><p id="3764" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">之前，为了获得视图的id，我们依赖于<code class="fe mb mc md me b">findViewById</code>。<br/>这种方法看起来非常简单，但是开发人员面临着许多问题。</p><p id="2c75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数的工作方式是遍历视图层次结构，查找具有您指定的ID的小部件。一旦找到它，它就返回视图，如果不存在，它就返回<code class="fe mb mc md me b">null</code>。让我们讨论一下这种方法的一些问题:</p><ol class=""><li id="3635" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ny ly lz ma bi translated">通过看上面的工作原理，我们可以说这种方法成本很高。开发人员会在运行时用尽它，尤其是在列表视图适配器的早期实现中，这使得他们的代码性能很差。</li><li id="16b4" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated">如果你的视图不在布局中，你将在运行时得到<code class="fe mb mc md me b">NullPointerException </code>，即，非空安全。</li><li id="e0d8" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated">在Android API 26之前，它返回了<a class="ae kv" href="https://developer.android.com/reference/android/view/View" rel="noopener ugc nofollow" target="_blank">视图</a>(父类)，你必须手动类型转换，一个错误的转换会导致<code class="fe mb mc md me b">ClassCastException</code>，即不类型安全。</li><li id="2e75" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated">很多样板代码。您必须为所有视图编写相同的方法，对它们进行类型转换，然后将它们赋给一个变量。</li></ol><p id="eae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后像<a class="ae kv" href="https://jakewharton.github.io/butterknife/" rel="noopener ugc nofollow" target="_blank"> Butter Knife </a>这样的库出现了，使这种方法变得更简单。Butter Knife部分改善了样板代码的问题，但仍然没有解决类型安全和空安全的问题。此外，它使用了注释处理，这确实稍微降低了构建时间。(注:黄油刀现已弃用。)</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="884a" class="nb nc iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">科特林合成救援</h1><p id="ee93" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">随着2017年发布的<a class="ae kv" href="https://plugins.gradle.org/plugin/org.jetbrains.kotlin.android.extensions" rel="noopener ugc nofollow" target="_blank">Android kot Lin Extensions Gradle插件</a>，Kotlin Synthetics问世。对于每个布局文件，Kotlin Synthetics都会创建一个包含您的视图的自动生成类，就这么简单。<br/>你只需要在你的Gradle文件中导入这个插件，你就可以直接引用视图引用变量了。</p><p id="f150" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它只在内部调用<code class="fe mb mc md me b">findViewById</code>一次，然后缓存它。</p><p id="5241" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是如此方便和有趣的使用，那么为什么它被否决</p><p id="b5eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来分析一下。</p><h2 id="17ce" class="nz nc iq bd nd oa ob dn nh oc od dp nl lf oe of nn lj og oh np ln oi oj nr ok bi translated">赞成的意见</h2><ol class=""><li id="d8d4" class="ls lt iq ky b kz nt lc nu lf ol lj om ln on lr ny ly lz ma bi translated">没有样板代码——只需在你的Gradle文件中配置一次，就可以了。Kotlin合成将自动生成一个类供您使用。</li><li id="9ecf" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated">类型安全-所有视图都是从其已知类型的布局文件中选取的。</li></ol><h2 id="62e1" class="nz nc iq bd nd oa ob dn nh oc od dp nl lf oe of nn lj og oh np ln oi oj nr ok bi translated">骗局</h2><ol class=""><li id="a6e0" class="ls lt iq ky b kz nt lc nu lf ol lj om ln on lr ny ly lz ma bi translated">部分空安全-它通常是空安全的，因为所有视图必须存在于布局文件中才能生成。但是，如果您有多个基于配置的布局文件，其中一些视图在一些布局文件中存在，而在一些布局文件中缺失，该怎么办呢？在这里，您必须手动检查是否为空。</li><li id="155f" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated">污染名称空间——在不同的布局中可以有相同的视图ID，并且可以意外地导入其他布局的视图，这将在运行时抛出<code class="fe mb mc md me b">NullPointerException</code>。</li><li id="1230" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated">仅限Kotlin——kot Lin合成材料只能与kot Lin一起使用。Java不支持它们。仍然有一些项目是用Java编写的，可能还没有完全迁移到Kotlin，因此Kotlin Synthetics可能不是在您的项目中获取ViewIds的一致方式。</li></ol><p id="a72a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这些问题，科特林合成现在被否决。<br/>但是用什么代替呢？我们是否应该回到以前的<code class="fe mb mc md me b">findViewById</code>方法，或者有其他一些推荐的方法来达到同样的目的？</p><p id="3c46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们找出一些推荐的方法。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="78d2" class="nb nc iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">数据绑定</h1><p id="c20d" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">如<a class="ae kv" href="https://developer.android.com/topic/libraries/data-binding" rel="noopener ugc nofollow" target="_blank">文档</a>中所述，“数据绑定库是一个支持库，它允许您使用声明性格式而非编程方式将布局中的UI组件绑定到应用程序中的数据源。”</p><p id="b44e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，将您的应用配置为使用数据绑定，并在应用模块的<code class="fe mb mc md me b">build.gradle</code>文件中启用<code class="fe mb mc md me b">dataBinding</code>构建选项。</p><pre class="kg kh ki kj gt oo me op oq aw or bi"><span id="2959" class="nz nc iq me b gy os ot l ou ov">android {<br/>    ...<br/>    buildFeatures {<br/>        dataBinding true<br/>    }<br/>}</span></pre><p id="f05b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在布局中启用数据绑定，您必须在布局中手动添加<code class="fe mb mc md me b">&lt;layout&gt;</code>标签。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="32f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Android Studio会自动为你的布局生成带有<code class="fe mb mc md me b">Binding</code>后缀的类。比如你的布局文件名是<code class="fe mb mc md me b">activity_main.xml</code>，那么Android会生成一个名为<code class="fe mb mc md me b">ActivityMainBinding.</code>的类</p><p id="8b69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据绑定非常强大，它支持以下内容:</p><ul class=""><li id="8ee1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">将表达式与布局绑定</li><li id="a653" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">使用可观察的数据对象</li><li id="950d" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">绑定适配器</li><li id="1d7f" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">双向绑定</li></ul><h2 id="30f9" class="nz nc iq bd nd oa ob dn nh oc od dp nl lf oe of nn lj og oh np ln oi oj nr ok bi translated">赞成的意见</h2><ol class=""><li id="0c1d" class="ls lt iq ky b kz nt lc nu lf ol lj om ln on lr ny ly lz ma bi translated">零安全—它是零安全的。即使我们有基于配置的多个布局，并且很少有视图在其他配置布局中出现/缺失，该视图也会被标注为<code class="fe mb mc md me b">@ Nullable</code>。</li><li id="ee3c" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated">类型安全-因为所有视图都是从已知类型的布局文件中选取的。</li><li id="7203" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated"><strong class="ky ir">支持Kotlin和Java </strong></li></ol><h2 id="e503" class="nz nc iq bd nd oa ob dn nh oc od dp nl lf oe of nn lj og oh np ln oi oj nr ok bi translated">骗局</h2><ol class=""><li id="2647" class="ls lt iq ky b kz nt lc nu lf ol lj om ln on lr ny ly lz ma bi translated">样板代码——每个布局文件都需要您手动添加<code class="fe mb mc md me b">&lt;layout&gt;</code>标签，以便它支持数据绑定。</li><li id="91f2" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated">增加构建时间—数据绑定会增加构建时间，因为它必须生成带有视图的类文件，而且还要生成带有getter、setter和求值表达式的类文件。</li></ol></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="1649" class="nb nc iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">视图绑定</h1><p id="537d" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">简单地说，视图绑定是数据绑定的一个非常简单的版本/子集。<br/>两者的区别在于视图绑定只针对视图引用，不针对UI与数据源的绑定。</p><p id="5976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，配置您的应用程序以使用数据绑定，并在应用程序模块的<code class="fe mb mc md me b">build.gradle</code>文件中启用<code class="fe mb mc md me b">viewBinding</code>构建选项。</p><pre class="kg kh ki kj gt oo me op oq aw or bi"><span id="4666" class="nz nc iq me b gy os ot l ou ov">android {<br/>    ...<br/>    buildFeatures {<br/>        viewBinding true<br/>    }<br/>}</span></pre><p id="5fe8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于视图绑定，您不必在布局文件中声明任何内容。默认情况下，所有布局文件都会生成一个带有<code class="fe mb mc md me b">Binding</code>后缀的类文件供您使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="3ede" class="nb nc iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">视图绑定的优势</h1><ul class=""><li id="87f6" class="ls lt iq ky b kz nt lc nu lf ol lj om ln on lr lx ly lz ma bi translated">空安全—与数据绑定相同</li><li id="067d" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">类型安全—与数据绑定相同</li><li id="0928" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">没有样板代码——与数据绑定不同，默认情况下，所有布局都可以生成没有任何标签的绑定类。</li><li id="bddb" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">对构建时间没有影响—与数据绑定不同，对构建时间没有负面影响。</li><li id="d341" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">支持Kotlin和Java。</li></ul></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="68f0" class="nb nc iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">结论</h1><p id="ef7e" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">视图绑定和数据绑定应该是推荐的方法。<br/>对于更简单的用户案例，使用视图绑定而不是Kotlin Synthetics，如果你生活在岩石下并且仍然使用<code class="fe mb mc md me b">findViewById</code>，那么是时候迁移了。</p><p id="f788" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想从数据绑定开始，并对它的好处感到惊讶，那么是时候迁移到数据绑定了。</p><p id="b8d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您可以同时使用视图绑定和数据绑定。<br/>所有带有<code class="fe mb mc md me b">&lt;layout&gt;</code>标签的布局文件将使用数据绑定，而其他布局将使用视图绑定。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="718b" class="nb nc iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">参考</h1><ol class=""><li id="6254" class="ls lt iq ky b kz nt lc nu lf ol lj om ln on lr ny ly lz ma bi translated"><a class="ae kv" href="https://android-developers.googleblog.com/2020/11/the-future-of-kotlin-android-extensions.html" rel="noopener ugc nofollow" target="_blank"> Android Kotlin Gradle扩展插件被弃用</a></li><li id="b3c5" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated"><a class="ae kv" href="https://developer.android.com/topic/libraries/view-binding" rel="noopener ugc nofollow" target="_blank">了解更多关于视图绑定的信息</a></li><li id="baa8" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated"><a class="ae kv" href="https://developer.android.com/topic/libraries/data-binding" rel="noopener ugc nofollow" target="_blank">了解有关数据绑定的更多信息</a></li><li id="27e9" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated"><a class="ae kv" href="https://developer.android.com/topic/libraries/view-binding/migration" rel="noopener ugc nofollow" target="_blank">从Kotlin Synthetics迁移到View Binding </a></li><li id="2d45" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ny ly lz ma bi translated"><a class="ae kv" href="https://developer.android.com/studio/preview/features/#agp-4-0-0" rel="noopener ugc nofollow" target="_blank">Android Studio预览版中的新功能</a></li></ol></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="a84a" class="nb nc iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">离别赠言</h1><p id="d14c" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">欢迎评论，让我知道你的建议。一定要提出你希望我在接下来的文章中涉及的主题。</p><p id="610d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已！谢谢大家！</p></div></div>    
</body>
</html>