<html>
<head>
<title>Add Dark Mode Support to Your App in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中为您的应用程序添加黑暗模式支持</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/add-dark-mode-support-to-your-app-in-swift-21d7e4d54440?source=collection_archive---------10-----------------------#2019-11-05">https://betterprogramming.pub/add-dark-mode-support-to-your-app-in-swift-21d7e4d54440?source=collection_archive---------10-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="796f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">测试并有效地将黑暗模式支持添加到您的应用程序的提示</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9a79d7856d4c55e8712bb5bb7df32d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QQ2EJjd6bB3c0ia5.png"/></div></div></figure><p id="b7ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">黑暗模式是在iOS 13中引入的，并在2019年WWDC上宣布。它为iOS添加了一个更黑暗的主题，并允许你为你的应用程序做同样的事情。这是给你的用户的一个很好的补充，这样他们就可以体验你的应用程序的深色设计。</p><p id="30ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将与您分享我在我们为WeTransfer 应用程序的<a class="ae lq" href="https://collect.bywetransfer.com" rel="noopener ugc nofollow" target="_blank"> Collect添加黑暗模式支持后的体验。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8cf3" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">退出并禁用黑暗模式</h1><p id="77a1" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在我们开始采用黑暗界面风格之前，我想告诉你如何选择退出。当您开始使用Xcode 11构建应用程序时，您会注意到默认情况下启用了较暗的外观。</p><p id="5119" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你没有时间添加对黑暗模式的支持，你可以简单地通过添加<code class="fe mv mw mx my b">UIUserInterfaceStyle</code>到你的<code class="fe mv mw mx my b">Info.plist</code>并设置为<code class="fe mv mw mx my b">Light</code>来禁用它。</p><h2 id="f136" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">覆盖每个视图控制器的黑暗模式</h2><p id="07f0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">您可以使用以下代码覆盖每个视图控制器的用户界面样式，并将其设置为亮或暗:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="0613" class="mz lz it my b gy np nq l nr ns">class ViewController: UIViewController {<br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        overrideUserInterfaceStyle = .dark<br/>    }<br/>}</span></pre><h2 id="eaab" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">覆盖每个视图的黑暗模式</h2><p id="f7c3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">您可以对单个<code class="fe mv mw mx my b">UIView</code>实例做同样的事情:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="f02c" class="mz lz it my b gy np nq l nr ns">let view = UIView()<br/>view.overrideUserInterfaceStyle = .dark</span></pre><h2 id="8787" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">覆盖每个窗口的黑暗模式</h2><p id="9f21" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果您想以编程方式禁用黑暗模式，则覆盖每个窗口的用户界面样式会很方便:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="3436" class="mz lz it my b gy np nq l nr ns">UIApplication.shared.windows.forEach { window in<br/>    window.overrideUserInterfaceStyle = .dark<br/>}</span></pre><p id="97ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们在这里使用的是windows数组，因为从iOS 13开始，共享的<code class="fe mv mw mx my b">UIApplication</code>上的<code class="fe mv mw mx my b">keyWindow</code>属性已被弃用。现在不鼓励使用它，因为应用程序支持多个场景，每个场景都有一个附加的窗口。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6966" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">启用黑暗模式进行测试</h1><p id="f879" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果你开始在你的应用程序中实现更暗的外观，有一个好的测试方法是很重要的。有多种方法可以启用和切换外观模式，每种方法都有自己的优点。</p><h2 id="1f12" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">在模拟器中启用黑暗模式</h2><p id="1b38" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">导航到模拟器上设置应用程序中的开发者页面，打开黑暗外观开关:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6edc0f57f77c3d24f15e26da34fc2a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*Sqjf3hplTk1J3esf.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">在模拟器上启用黑暗模式</p></figure><h2 id="29d7" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">在设备上启用黑暗模式</h2><p id="bd05" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在设备上，您可以通过导航到“设置”应用程序中的“显示与亮度”页面来启用黑暗模式。然而，在开发过程中，为控制中心添加一个选项来快速在黑暗和光明模式之间切换要容易得多:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/ecfc5a283155e6538f9077861151da46.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/1*TJtgUenJn8ij5JzFA8OPTg.gif"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">从控制中心快速切换黑暗和光明模式</p></figure><h2 id="49e2" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">从调试菜单切换黑暗模式</h2><p id="0357" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在模拟器打开的情况下使用Xcode时，您可能想要使用环境覆盖窗口。这允许您在调试时快速切换外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/6018ea674c2a74d4224b41e9f2f675e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/0*J5_FFip4JCGFAk56.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">“环境覆盖”窗口允许更改界面样式</p></figure><p id="b14f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oa">注意:如果您没有看到此选项，您可能正在iOS 12或更低版本的设备上运行。</em></p><h2 id="0b6c" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">在故事板中启用黑暗模式</h2><p id="25c7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在故事板内部处理视图时，将故事板内部的外观设置为暗会很有用。您可以在底部的设备选项旁边找到此选项:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/f7fc856d2102c7f5ff890ba1c8deda27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SQDQwbIvWhPPdAp2.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">将故事板的外观更新为黑色</p></figure><h2 id="e145" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">在视图、视图控制器和窗口中覆盖黑暗模式</h2><p id="5173" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">上一节介绍了使用<code class="fe mv mw mx my b">Info.plist</code>在整个应用程序中启用和禁用灯光模式，或者禁用每个视图、视图控制器或窗口的灯光模式。如果你想暂时强制使用黑暗模式进行测试，这是一个很好的方法。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b1cb" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">调整深色模式的颜色</h1><p id="1ab4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">随着iOS 13上的黑暗模式，苹果引入了自适应和语义颜色。这些颜色会根据几个因素自动调整，比如它们是否在模态演示中。</p><h2 id="0c6b" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">自适应颜色解释</h2><p id="e4ff" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">自适应颜色会自动适应当前外观。自适应颜色为不同的界面样式返回不同的值，并且还会受到呈现样式的影响，比如表单中的模态呈现样式。</p><h2 id="24d2" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">语义颜色解释</h2><p id="b20d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">语义颜色描述他们的意图，也是适应性的。一个例子是应该用于标签的语义颜色。很简单，不是吗？</p><p id="caaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您将它们用于预期目的时，它们将正确渲染当前外观。<code class="fe mv mw mx my b">label</code>示例会自动将文本颜色改为黑色(亮模式)和白色(暗模式)。</p><p id="33f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最好探索所有可用的颜色，并利用你真正需要的颜色。</p><h2 id="4ffc" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">探索适应性和语义色彩</h2><p id="12cc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果可能的话，如果你能在你的项目中实现语义和自适应颜色，采用深色模式会容易得多。为此，我强烈推荐由<a class="ae lq" href="https://twitter.com/aaronbrethorst" rel="noopener ugc nofollow" target="_blank"> Aaron Brethorst </a>开发的<a class="ae lq" href="https://github.com/aaronbrethorst/SemanticUI" rel="noopener ugc nofollow" target="_blank"> SemanticUI </a>应用程序，它可以让你看到两种外观中所有可用颜色的概览。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/0a47a458ee1c3ec249479730c7dcf99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eI1nYYuRfGzqs866.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">Aaron Brethorst开发的SemanticUI应用程序有助于探索语义和适应性色彩</p></figure><h2 id="4fbc" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">支持iOS 12及更低版本，带有语义色彩</h2><p id="a6f5" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一旦你开始使用语义颜色，你就会意识到它们只支持iOS 13及以上版本。为了解决这个问题，我们可以利用<code class="fe mv mw mx my b">UIColor.init(dynamicProvider: @escaping (UITraitCollection) -&gt; UIColor)</code>方法创建我们自己的定制UIColor包装器。这允许你为iOS 12和更低版本返回不同的颜色。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="622e" class="mz lz it my b gy np nq l nr ns">public enum DefaultStyle {<br/><br/>    public enum Colors {<br/><br/>        public static let label: UIColor = {<br/>            if #available(iOS 13.0, *) {<br/>                return UIColor.label<br/>            } else {<br/>                return .black<br/>            }<br/>        }()<br/>    }<br/>}<br/><br/>public let Style = DefaultStyle.self<br/><br/>let label = UILabel()<br/>label.textColor = Style.Colors.label</span></pre><p id="00d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法的另一个好处是，您可以定义自己的自定义样式对象。这允许主题化，但也使整个应用程序的颜色更加一致。</p><h2 id="0eeb" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">创建自定义语义颜色</h2><p id="b917" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">可以使用前面解释的<code class="fe mv mw mx my b">UIColor.init(dynamicProvider: @escaping (UITraitCollection) -&gt; UIColor)</code>方法创建自定义语义颜色。</p><p id="89a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，你的应用程序有自己相同的色调。可能这种颜色在亮模式下效果很好，但在暗模式下效果不太好。为此，您可以根据当前的界面样式返回不同的颜色。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="a1c9" class="mz lz it my b gy np nq l nr ns">public static var tint: UIColor = {<br/>    if #available(iOS 13, *) {<br/>        return UIColor { (UITraitCollection: UITraitCollection) -&gt; UIColor in<br/>            if UITraitCollection.userInterfaceStyle == .dark {<br/>                /// Return the color for Dark Mode<br/>                return Colors.osloGray<br/>            } else {<br/>                /// Return the color for Light Mode<br/>                return Colors.dataRock<br/>            }<br/>        }<br/>    } else {<br/>        /// Return a fallback color for iOS 12 and lower.<br/>        return Colors.dataRock<br/>    }<br/>}()</span></pre><p id="e17c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">黑暗模式可以通过使用当前特征集合上的<code class="fe mv mw mx my b">userInterfaceStyle</code>属性来检测。当它被设置为<code class="fe mv mw mx my b">dark</code>时，你知道当前的外观被设置为黑色。</p><h2 id="5864" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">深色模式下边框颜色不会动态更新</h2><p id="2bf3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当您将自适应颜色用于CALayers时，您会注意到在应用程序中实时切换外观时，颜色不会更新。你可以用<code class="fe mv mw mx my b">traitCollectionDidChange(_:)</code>的方法解决这个问题。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="1ec2" class="mz lz it my b gy np nq l nr ns">override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {<br/>    super.traitCollectionDidChange(previousTraitCollection)<br/>    /// Border color is not automatically catched by trait collection changes. Therefore, update it here.<br/>    layer.borderColor = Style.Colors.separator.cgColor<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1012" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">为黑暗模式更新资产和图像</h1><p id="a079" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">更新完所有颜色后，就该更新应用程序中的资源了。</p><p id="536c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最简单的方法是使用图像资产目录。您可以为每个外观添加一个额外的图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/1bf933d9e921399c45e9c1011071c3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0IOLaBIlsL9SqyzL.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">为图像资源添加额外的外观</p></figure><p id="f054" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也使你的图像自适应，并根据当前的界面风格相应地调整图像。</p><h2 id="c063" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">将淡色应用于图像和图标</h2><p id="dcfb" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为每次出场增加额外的资产并不总是最好的选择。最终，它增加了你的应用程序的大小。</p><p id="bab5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个好的替代方法是寻找可以使用浅色的图像。这尤其适用于工具栏和标签栏中使用的图标。</p><p id="d786" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，您需要将资源渲染为模板:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/65210958c06810ca882b3a08ba62c869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PNMTeLFewDuUoVIL.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">将要渲染的图像设置为模板</p></figure><p id="4ff1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在代码中做同样的事情:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="9d1e" class="mz lz it my b gy np nq l nr ns">let iconImage = UIImage()<br/>let imageView = UIImageView()<br/>imageView.image = iconImage.withRenderingMode(.alwaysTemplate)</span></pre><p id="3a39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，您可以简单地设置图像视图色调颜色，使图标根据当前外观调整其颜色:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="b004" class="mz lz it my b gy np nq l nr ns">imageView.tintColor = Style.Colors.tint</span></pre><h2 id="e6b9" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">反转颜色作为图像的解决方案</h2><p id="3fd4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">反转颜色是节省应用程序大小的另一种方法。这并不总是适用于每个映像，但它可以是一个防止您向捆绑包中添加其他资产的解决方案。</p><p id="1caf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以通过使用下面的<code class="fe mv mw mx my b">UIImage</code>扩展来完成这项工作:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="2207" class="mz lz it my b gy np nq l nr ns">extension UIImage {<br/>    /// Inverts the colors from the current image. Black turns white, white turns black etc.<br/>    func invertedColors() -&gt; UIImage? {<br/>        guard let ciImage = CIImage(image: self) ?? ciImage, let filter = CIFilter(name: "CIColorInvert") else { return nil }<br/>        filter.setValue(ciImage, forKey: kCIInputImageKey)<br/><br/>        guard let outputImage = filter.outputImage else { return nil }<br/>        return UIImage(ciImage: outputImage)<br/>    }<br/>}</span></pre><p id="283f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当外观更新时，您需要手动更新您的图像，因此建议使用此方法:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="8d83" class="mz lz it my b gy np nq l nr ns">// MARK: - Dark Mode Support<br/>private func updateImageForCurrentTraitCollection() {<br/>    if traitCollection.userInterfaceStyle == .dark {<br/>        imageView.image = originalImage?.invertedColors()<br/>    } else {<br/>        imageView.image = originalImage<br/>    }<br/>}<br/><br/>override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {<br/>    super.traitCollectionDidChange(previousTraitCollection)<br/>    updateImageForCurrentTraitCollection()<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="fcdc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="586d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们讨论了很多在你的应用中适应黑暗模式的技巧。我们还解释了使用语义和适应性颜色的好处。希望这能帮助你更有效地实现黑暗模式！</p><p id="64f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您忙于处理资产时，您可能也想直接<a class="ae lq" href="https://www.avanderlee.com/optimization/unused-images-clean-up/" rel="noopener ugc nofollow" target="_blank">清理您未使用的资产</a>！如果你想继续提高你的Xcode知识，请查看<a class="ae lq" href="https://www.avanderlee.com/category/swift/" rel="noopener ugc nofollow" target="_blank"> Xcode类别页面</a>。</p><p id="ae8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">谢谢</p></div></div>    
</body>
</html>