<html>
<head>
<title>An Online MySQL Paging Incident That Took All Night to Fix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个在线MySQL分页事件花了一整夜才修复</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-online-mysql-paging-incident-that-took-all-night-to-fix-805cc868dbb2?source=collection_archive---------5-----------------------#2022-05-03">https://betterprogramming.pub/an-online-mysql-paging-incident-that-took-all-night-to-fix-805cc868dbb2?source=collection_archive---------5-----------------------#2022-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">MySQL分页事故，经验分享</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ae3f0004fcf2f12806d887eda6d37cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9Tk_iG61llqM2hyX4-xSQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@fempreneurstyledstock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莱昂·温特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/desk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ed8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天给大家分享一个生产事故，一个MySQL分页导致的线上事故。</p><p id="a2e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一天晚上十点半，下班后我正开心地坐在回家的地铁上，想着如何安排周末的生活。</p><p id="2e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">突然电话响了，一看是我们一个运维同事，我就紧张了。本周版本已经发布。这时候打电话一般是在线问题。</p><p id="0456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">果然沟通情况是一个查询数据的在线界面被骂疯了，不理智，这个操作直接导致在线MySQL集群变慢。</p><p id="43ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，这个问题很严重。赶回家后，我打开电脑，和同事一起在Pinpoint上翻出缓慢的查询日志。</p><p id="47b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到一个非常奇怪的查询，如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c95c" class="ma mb it lw b gy mc md l me mf">POST  domain/v1.0/module/method?order=condition&amp;orderType=desc&amp;offset=1800000&amp;limit=500</span></pre><p id="cae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">domain, module, method</code>是别名，代表接口的域、模块和实例方法名。下面的offset和limit表示分页操作的偏移量和每页的页数。</p><p id="7fc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说同事在翻页(1800000/500+1=3601)。经过对日志的初步搜索，我发现有8000多个这样的电话。</p><p id="578e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太奇怪了。我们页面的单页数量根本不是500，而是每页25。这绝对不是在功能页面上人为的翻页操作，而是数据被刷了。(描述下，我们的生产环境数据有1亿+)。</p><p id="90d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">详细对比日志发现，很多分页时间重叠，对方应该是多线程调用。</p><p id="5326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过对认证令牌的分析，基本定位到该请求来自正在进行该操作的名为ApiAutotest的客户端程序，还定位到生成认证令牌的账户来自一个QA同事。</p><p id="bf8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">马上给同事打电话，沟通，处理。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="5708" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其实对于我们的MySQL查询语句来说，整体效率还是可以的。有一些连接表查询优化，也有简单的查询内容。</p><p id="2d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有针对关键条件字段和排序字段的索引。问题就在于他一页一页的分页去查询，然后越往后找到页数，扫描的数据越多，就会越慢。</p><p id="9c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们查前几页的时候发现速度很快，比如<code class="fe mg mh mi lw b">limit 200, 25</code>，瞬间就出来了。但是越往前走速度会越慢，特别是一百万条记录之后就会卡死，那么这是什么原理呢？</p><p id="ade9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先看看当我们把页面翻到后面时，SQL查询是什么样子的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cb4d" class="ma mb it lw b gy mc md l me mf">select * from t_name where c_name1='xxx' order by c_name2 limit 2000000,25;</span></pre><p id="4ac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个查询的缓慢实际上是由限制后面的大偏移量造成的。</p><p id="8f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如上面的限制是2000000，25，相当于数据库扫描出2000025条数据，然后丢弃之前的20000000条数据，将剩下的25条数据返回给用户。这种方法显然不合理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/3c7c2aca34f106714450d0f4bd1214e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ff0cr-ES_6OtKLnIZBrFA.png"/></div></div></figure><p id="48b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在确认了这个问题:当偏移量非常大的时候，会导致MySQL扫描很多不需要的行，然后把它们扔掉。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="1e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，既然你明白了问题的原理，那我们就试着解决它吧。涉及到数据敏感性，我们在这里模拟一下这种情况，构造一些数据进行测试。</p><h2 id="e601" class="ma mb it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated"><strong class="ak">步骤1 —创建两个表格，</strong> <code class="fe mg mh mi lw b"><strong class="ak">employee</strong></code> <strong class="ak">和</strong> <code class="fe mg mh mi lw b"><strong class="ak">department</strong></code></h2><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c20a" class="ma mb it lw b gy mc md l me mf">/* department table */<br/>drop table if EXISTS dep;<br/>create table dep(<br/>    id int unsigned primary key auto_increment,<br/>    depno mediumint unsigned not null default 0,<br/>    depname varchar(20) not null default "",<br/>    memo varchar(200) not null default ""<br/>);<br/><br/>/* employee table */<br/>drop table if EXISTS emp;<br/>create table emp(<br/>    id int unsigned primary key auto_increment,<br/>    empno mediumint unsigned not null default 0,<br/>    empname varchar(20) not null default "",<br/>    job varchar(9) not null default "",<br/>    mgr mediumint unsigned not null default 0,<br/>    hiredate datetime not null,<br/>    sal decimal(7,2) not null,<br/>    comn decimal(7,2) not null,<br/>    depno mediumint unsigned not null default 0<br/>);</span></pre><h2 id="ed68" class="ma mb it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated"><strong class="ak">步骤2 —创建两个函数</strong></h2><p id="1acd" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">生成随机字符串和随机数的函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d60e" class="ma mb it lw b gy mc md l me mf">/* A function that generates random strings */<br/>DELIMITER $ <br/>drop FUNCTION if EXISTS rand_string;<br/>CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)<br/>BEGIN<br/>    DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmlopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';<br/>    DECLARE return_str VARCHAR(255) DEFAULT '';<br/>    DECLARE i INT DEFAULT 0;<br/>    WHILE i &lt; n DO<br/>    SET return_str = CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));<br/>    SET i = i+1;<br/>    END WHILE;<br/>    RETURN return_str;<br/>END $<br/>DELIMITER;<br/><br/><br/>/* A function to generate random department numbers */<br/>DELIMITER $ <br/>drop FUNCTION if EXISTS rand_num;<br/>CREATE FUNCTION rand_num() RETURNS INT(5)<br/>BEGIN<br/>    DECLARE i INT DEFAULT 0;<br/>    SET i = FLOOR(100+RAND()*10);<br/>    RETURN i;<br/>END $<br/>DELIMITER;</span></pre><h2 id="360b" class="ma mb it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated"><strong class="ak">步骤3 —编写一个存储过程来模拟500万个员工数据</strong></h2><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dc13" class="ma mb it lw b gy mc md l me mf">/*Create a stored procedure: insert data into the emp table*/<br/> DELIMITER $<br/> drop PROCEDURE if EXISTS insert_emp;<br/> CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))<br/> BEGIN<br/>     DECLARE i INT DEFAULT 0;<br/>     /*set autocommit =0 Set autocommit to 0 to turn off the default commit*/<br/>     SET autocommit = 0;<br/>     REPEAT<br/>     SET i = i + 1;<br/>     INSERT INTO emp(empno,empname,job,mgr,hiredate,sal,comn,depno) VALUES ((START+i),rand_string(6),'SALEMAN',0001,now(),2000,400,rand_num());<br/>     UNTIL i = max_num<br/>     END REPEAT;<br/>     COMMIT;<br/> END $<br/> DELIMITER;<br/> /*Insert 5 million pieces of data*/<br/> call insert_emp(0,5000000);</span></pre><h2 id="7908" class="ma mb it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated"><strong class="ak">步骤4 —编写一个存储过程来模拟120个部门数据。</strong></h2><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f9b1" class="ma mb it lw b gy mc md l me mf">/*Create a stored procedure: insert data into the dep table*/<br/> DELIMITER $<br/> drop PROCEDURE if EXISTS insert_dept;<br/> CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))<br/> BEGIN<br/>     DECLARE i INT DEFAULT 0;<br/>     SET autocommit = 0;<br/>     REPEAT<br/>     SET i = i+1;<br/>     INSERT  INTO dep( depno,depname,memo) VALUES((START+i),rand_string(10),rand_string(8));<br/>     UNTIL i = max_num<br/>     END REPEAT;<br/>     COMMIT;<br/> END $<br/> DELIMITER;<br/> /*Insert 120 pieces of data*/<br/> call insert_dept(1,120);</span></pre><h2 id="1fd3" class="ma mb it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated"><strong class="ak">第五步——建立关键字段索引</strong></h2><p id="1e9d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这里，在运行数据之后构建索引。建立索引需要很长时间，但是运行数据会更快。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0e8a" class="ma mb it lw b gy mc md l me mf">/*Build index of key fields: sort, condition*/<br/>CREATE INDEX idx_emp_id ON emp(id);<br/>CREATE INDEX idx_emp_depno ON emp(depno);<br/>CREATE INDEX idx_dep_depno ON dep(depno);</span></pre><p id="588d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始测试吧。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="5206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="99ed" class="ma mb it lw b gy mc md l me mf">/*Offset is 100, take 25*/<br/>SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/>from emp a left join dep b on a.depno = b.depno order by a.id desc limit 100,25;<br/>/*Offset is4800000, take 25*/<br/>SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/>from emp a left join dep b on a.depno = b.depno order by a.id desc limit 4800000,25;</span></pre><p id="1fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dca5" class="ma mb it lw b gy mc md l me mf">[SQL]<br/>SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/>from emp a left join dep b on a.depno = b.depno order by a.id desc limit 100,25;<br/>affected row: 0<br/>time: 0.001s</span><span id="6c96" class="ma mb it lw b gy nn md l me mf">[SQL]<br/>SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/>from emp a left join dep b on a.depno = b.depno order by a.id desc limit 4800000,25;<br/>affected row: 0<br/>time: 12.275s</span></pre><p id="559e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为扫描的数据很多，这显然不是一个数量级的耗时。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="6827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始解决这个问题。</p><h2 id="110d" class="ma mb it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated"><strong class="ak"> 1。使用索引覆盖+子查询优化。</strong></h2><p id="d598" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">因为我们有了主键id，并在其上建立了索引，所以可以先在索引树中找到起始位置的id值，然后根据找到的id值查询行数据。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c925" class="ma mb it lw b gy mc md l me mf">/*The subquery gets the id of the position offset by 100, and then takes 25 from this position*/<br/> SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/> from emp a left join dep b on a.depno = b.depno<br/> where a.id &gt;= (select id from emp order by id limit 100,1)<br/> order by a.id limit 25;<br/><br/> /*The subquery obtains the id of the position offset by 4800000, and takes 25 from this position*/<br/> SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/> from emp a left join dep b on a.depno = b.depno<br/> where a.id &gt;= (select id from emp order by id limit 4800000,1)<br/> order by a.id limit 25;</span></pre><p id="d822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行效率相比之前有了很大的提升。以下是结果。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="55c1" class="ma mb it lw b gy mc md l me mf">[SQL]<br/> SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/> from emp a left join dep b on a.depno = b.depno<br/> where a.id &gt;= (select id from emp order by id limit 100,1)<br/> order by a.id limit 25;<br/> affected row: 0<br/> time: 0.106s<br/><br/> [SQL]<br/> SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/> from emp a left join dep b on a.depno = b.depno<br/> where a.id &gt;= (select id from emp order by id limit 4800000,1)<br/> order by a.id limit 25;<br/> affected row: 0<br/> time: 1.541s</span></pre><h2 id="703a" class="ma mb it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated"><strong class="ak"> 2。开始位置重新定义</strong></h2><p id="b292" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">记住最后一次查找结果的主键位置，避免使用偏移量:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7818" class="ma mb it lw b gy mc md l me mf">/*Remember that the id of the last piece of data in the last paging is 100, here we just skip 100 and start scanning the table from 101*/<br/> SELECT a.id,a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/> from emp a left join dep b on a.depno = b.depno<br/> where a.id &gt; 100 order by a.id limit 25;<br/><br/> /*Remember that the id of the last piece of data in the last paging is 4800000, here we just skip 4800000 and start scanning the table from 4800001*/<br/> SELECT a.id,a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/> from emp a left join dep b on a.depno = b.depno<br/> where a.id &gt; 4800000<br/> order by a.id limit 25;</span></pre><p id="2ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3a61" class="ma mb it lw b gy mc md l me mf">[SQL]<br/>SELECT a.id,a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/>from emp a left join dep b on a.depno = b.depno<br/>where a.id &gt; 100 order by a.id limit 25;<br/>affected row: 0<br/>time: 0.001s<br/><br/>[SQL]<br/>SELECT a.id,a.empno,a.empname,a.job,a.sal,b.depno,b.depname<br/>from emp a left join dep b on a.depno = b.depno<br/>where a.id &gt; 4800000<br/>order by a.id limit 25;<br/>affected row: 0<br/>time: 0.001s</span></pre><p id="130b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的效率是最好的。无论如何分页，耗时基本相同，因为执行完条件后，只扫描了25条数据。</p><p id="2fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但有个问题，它只适合逐页分页以便能记住上一页的最后一个id。如果用户跳到分页，就有问题了。</p><p id="a216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如用户刚看完第25页，马上跳到第35页，数据就会出错。</p><h2 id="89be" class="ma mb it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated"><strong class="ak"> 3。降级策略</strong></h2><p id="85c7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">配置极限偏移量和最大采集次数。如果超过最大值，将返回空数据。</p><p id="0b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为他认为超过这个值就不是分页，而是刷数据。如果确认要查找数据，就要输入适当的条件缩小范围，而不是一页一页的查找。</p><p id="6b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这和我同事的想法大致相同:如果请求时偏移量大于某个值，会先返回一个4xx的错误。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="467d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那天晚上，我们应用了上面的第三个方案来限制offset的电流，如果超过了某个值，就会返回一个空值。</p><p id="c4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二天，使用第一个和第二个解决方案进一步优化了程序和数据库脚本。</p><p id="684a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">做任何应该考虑极端情况的功能都是合理的，设计能力应该覆盖极端边界测试。</p><p id="b741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，目前的一些限制和降级也要考虑。</p><p id="a7e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如多线程工具调用，短时间内8000次调用，可以使用计数服务判断并反馈用户调用过于频繁，直接中断。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="bd83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读这篇文章。如果你在这篇文章中发现任何错误，请告诉我。</p></div></div>    
</body>
</html>