<html>
<head>
<title>Algorithms 101: How to Use Merge Sort and Quicksort in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:如何在JavaScript中使用合并排序和快速排序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/algorithms-101-how-to-use-merge-sort-and-quicksort-in-javascript-6d8908562fe0?source=collection_archive---------8-----------------------#2020-12-04">https://betterprogramming.pub/algorithms-101-how-to-use-merge-sort-and-quicksort-in-javascript-6d8908562fe0?source=collection_archive---------8-----------------------#2020-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="16d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">合并排序和快速排序是JavaScript程序中常见的分治算法。请继续阅读，我们将讨论如何使用它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3b3f49a40f2a53e1e298f470cf8c403f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSwrHyWYah18gRAaQ0_aLQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="392d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">本文由Jerry Ejonavi撰写。</em></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="2e37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编程中的排序涉及到将元素以一定的顺序放入一个列表或数组中。高效排序对于优化其他要求输入数据在排序列表中的算法非常重要。</p><p id="bf16" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然作为一名软件开发人员，您可能不需要在日常工作中实现排序算法，但了解其中一些算法的内部工作方式是很重要的。这些对于编写面试代码很常见，可以让你成为一个更高效的开发人员。</p><p id="b385" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在今天的文章中，我们将探讨两个最流行的排序算法，合并排序和快速排序。这些对于你的计算机科学和代码优化的基础是必不可少的。</p><p id="bccd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">今天，我们将学习:</strong></p><ul class=""><li id="4a01" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated"><a class="ae mi" href="https://dev.to/educative/algorithms-101-how-to-use-merge-sort-and-quicksort-in-javascript-13p5#intro" rel="noopener ugc nofollow" target="_blank">排序算法介绍</a></li><li id="a34a" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><a class="ae mi" href="https://dev.to/educative/algorithms-101-how-to-use-merge-sort-and-quicksort-in-javascript-13p5#merge" rel="noopener ugc nofollow" target="_blank">合并排序算法</a></li><li id="2765" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><a class="ae mi" href="https://dev.to/educative/algorithms-101-how-to-use-merge-sort-and-quicksort-in-javascript-13p5#quick" rel="noopener ugc nofollow" target="_blank">快速排序算法</a></li><li id="a79f" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><a class="ae mi" href="https://dev.to/educative/algorithms-101-how-to-use-merge-sort-and-quicksort-in-javascript-13p5#next" rel="noopener ugc nofollow" target="_blank">接下来学什么</a></li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bed0" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">排序算法简介</h1><p id="bc66" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">排序算法是一种用于根据特定要求对列表或数组中的项目进行重新排序的算法。例如，排序算法可以从最小到最大组织一组项目。</p><p id="8aba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">高效的排序算法对于优化其他算法(如搜索和压缩算法)的效率非常重要。</p><p id="2944" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">排序算法由一系列指令组成。它们接受一个数组或列表作为输入，执行操作，并输出一个排序后的数组。</p><p id="901c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有许多流行的排序算法。九个最受欢迎的是:</p><ul class=""><li id="4a1e" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated">冒泡排序</li><li id="b5cd" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">插入排序</li><li id="65d8" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">合并排序</li><li id="8c6b" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">快速排序</li><li id="e8a9" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">选择排序</li><li id="854e" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">计数排序</li><li id="1cf9" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">桶排序</li><li id="4d23" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">基数排序</li><li id="3478" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">堆排序</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bce8" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">合并排序算法</h1><p id="98b0" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">合并排序是一种高效、通用、基于比较的排序算法。它的工作方式是递归地将数组分成相等的两半，排序，然后合并排序后的两半。</p><p id="8629" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">取一个数组<code class="fe nl nm nn no b">[10, -1, 2, 5, 0, 6, 4, -5]</code>。下面是合并排序将如何处理它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/342ffb63be3a886a1af22c26965d3448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OF0PrQcp03kFx74S.png"/></div></div></figure><p id="ac6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">合并排序和快速排序实现就是分治算法的例子。概括地说，分治算法有以下几个部分:</p><ul class=""><li id="d65e" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated">划分:把问题分成子问题</li><li id="bd87" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><strong class="kx ir">征服:</strong>递归地处理子问题，直到每个问题都被解决</li><li id="804d" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><strong class="kx ir">合并:</strong>合并已解决的子问题，给出原始问题的解决方案</li></ul><p id="db23" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">合并排序可以用于各种问题。合并排序的三个最常见的应用是在O(nLogn)时间内对链表进行排序，解决反转计数问题，以及外部排序。</p><h2 id="9f4b" class="nq mp iq bd mq nr ns dn mu nt nu dp my le nv nw na li nx ny nc lm nz oa ne ob bi translated">用JavaScript实现</h2><p id="c701" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">下面是JavaScript中合并排序算法的代码实现。该算法由两个函数组成:</p><ul class=""><li id="86fb" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated"><code class="fe nl nm nn no b">mergeSort()</code>函数，负责对数组进行分区</li><li id="5c28" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><code class="fe nl nm nn no b">merge</code>函数，它合并了独立的数组</li></ul><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="02a5" class="nq mp iq no b gy og oh l oi oj">function mergeSort(array) {<br/>  if (array.length === 1) {<br/>    return array;<br/>  }<br/>  const middle = Math.floor(array.length / 2);<br/>  const left = array.slice(0, middle);<br/>  const right = array.slice(middle);<br/>  return merge(<br/>     mergeSort(left),<br/>     mergeSort(right)<br/>  );<br/>}</span><span id="9815" class="nq mp iq no b gy ok oh l oi oj">function merge(left, right) {<br/> let result = [];<br/> let leftIndex = 0;<br/> let rightIndex = 0;</span><span id="7200" class="nq mp iq no b gy ok oh l oi oj"> while (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) {<br/>   if (left[leftIndex] &lt; right[rightIndex]) {<br/>      result.push(left[leftIndex]);<br/>      leftIndex++;<br/>   } else {<br/>      result.push(right[rightIndex]);<br/>      rightIndex++;<br/>   }<br/> }</span><span id="fbe9" class="nq mp iq no b gy ok oh l oi oj"> return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));<br/>}</span></pre><p id="af3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们试着分析一下正在发生的事情:</p><ol class=""><li id="5c90" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq ol mf mg mh bi translated">如果数组只有一个元素，我们返回数组并终止。(基本情况)</li><li id="db06" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq ol mf mg mh bi translated">否则，我们将数组分成长度尽可能相等的两半。(除)</li><li id="4dbe" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq ol mf mg mh bi translated">通过递归，我们使用<code class="fe nl nm nn no b">mergeSort()</code>函数对两个数组进行排序。(征服)</li><li id="49bd" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq ol mf mg mh bi translated">最后，我们合并两个排序后的数组并返回结果。(联合收割机)</li></ol><p id="744d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以我们上面使用的数组为例。让我们看看如何在JavaScript代码中实现合并排序。</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="a6aa" class="nq mp iq no b gy og oh l oi oj">function mergeSort (unsortedArray) {<br/>  if (unsortedArray.length &lt;= 1) {<br/>    return unsortedArray;<br/>  }<br/>  // In order to divide the array in half, we need to find middle<br/>  const middle = Math.floor(unsortedArray.length / 2);</span><span id="2d63" class="nq mp iq no b gy ok oh l oi oj">  const left = unsortedArray.slice(0, middle);<br/>  const right = unsortedArray.slice(middle);</span><span id="9ddf" class="nq mp iq no b gy ok oh l oi oj">  // Use recursion to combine the left and right<br/>  return merge(<br/>    mergeSort(left), mergeSort(right)<br/>  );<br/>}</span></pre><h2 id="260a" class="nq mp iq bd mq nr ns dn mu nt nu dp my le nv nw na li nx ny nc lm nz oa ne ob bi translated">时间和空间复杂性</h2><p id="81d4" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">归并排序的时间复杂度保证为O(nlogn)时间，比其他几种排序算法的平均运行时间和最坏运行时间都要快得多。归并排序是一种空间复杂度为O(n)的稳定排序。</p><ul class=""><li id="1b5b" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated"><strong class="kx ir">辅助空间:</strong> O(n)</li><li id="b1c6" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><strong class="kx ir">算法范例:</strong>分治</li><li id="8655" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><strong class="kx ir">整理到位:</strong>否</li><li id="5757" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><strong class="kx ir">稳定:</strong>是</li></ul><h2 id="d5a8" class="nq mp iq bd mq nr ns dn mu nt nu dp my le nv nw na li nx ny nc lm nz oa ne ob bi translated">与其他排序算法的比较</h2><p id="fe58" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">实际上，合并排序比快速排序稍慢。它也不像快速排序的就地实现那样节省空间。由于内存分配的不同，合并排序通常比快速排序更适合链表。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a273" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">快速排序算法</h1><p id="4ec9" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">像合并排序一样，快速排序也是一种分治算法，但它的工作方式略有不同。</p><p id="5a6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快速排序首先从数组中选择一个主元元素，然后根据其他元素是小于还是大于主元将它们划分为两个子数组。然后对子数组进行递归排序。</p><p id="23ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快速排序算法不使用任何额外的空间，因为排序是就地完成的。</p><p id="1ea1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该算法可以通过多种方式选择枢纽元素。</p><ul class=""><li id="0aeb" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated">选择第一个元素作为枢轴</li><li id="6294" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">选择最后一个元素作为轴心</li><li id="b10b" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">选取一个随机元素作为轴心</li><li id="501c" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">选择中间点作为轴心</li></ul><h2 id="1417" class="nq mp iq bd mq nr ns dn mu nt nu dp my le nv nw na li nx ny nc lm nz oa ne ob bi translated">用JavaScript实现</h2><p id="9ec9" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">下面的关键过程是我们的配分函数，它选择我们的枢纽。在这个实现中，这是使用Hoare分区方案来完成的，该方案通过初始化从数组末端开始的两个索引来工作。指数彼此相向移动，直到发现反转。</p><p id="f5a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">反转是一对元素——一个大于或等于轴心，一个小于或等于轴心——它们相对于彼此的顺序是错误的。然后交换反转的值，并重复该过程。</p><p id="0c4d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">选择一个好的支点是快速实现快速排序的关键。在实践中，快速排序算法使用一个随机化的枢纽，其预期时间复杂度为O(n log n)。</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="df22" class="nq mp iq no b gy og oh l oi oj">function partitionHoare(array, left, right) {<br/>  const pivot = Math.floor(Math.random() * (right - left + 1) + left);<br/>  while (left &lt;= right) {<br/>    while (array[left] &lt; array[pivot]) { <br/>       left++;<br/>    } <br/>    while (array[right] &gt; array[pivot]) {<br/>      right--;<br/>    }<br/>    if (left &lt;= right) {<br/>      [array[left], array[right]] = [array[right], array[left]];<br/>    }<br/>  }<br/>  return left;<br/>}</span><span id="234e" class="nq mp iq no b gy ok oh l oi oj">function quicksort(array, left, right) {<br/>  left = left || 0;<br/>  right = right || array.length - 1;<br/>  const pivot = partitionHoare(array, left, right);</span><span id="2c56" class="nq mp iq no b gy ok oh l oi oj">  if (left &lt; pivot - 1) {<br/>     quicksort(array, left, pivot - 1);<br/>  }<br/>  if (right &gt; pivot) {<br/>     quicksort(array, pivot, right);<br/>  }<br/>  return array;<br/>}</span></pre><h2 id="c303" class="nq mp iq bd mq nr ns dn mu nt nu dp my le nv nw na li nx ny nc lm nz oa ne ob bi translated">时间复杂度</h2><p id="63af" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">快速排序算法的时间复杂度为O(n log n)。在最坏的情况下，这变成O(n2)。快速排序使用的空间取决于使用的版本。</p><p id="f2af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快速排序的就地版本即使在最坏的情况下也具有O(log n)的空间复杂度，而平均情况下的空间复杂度是O(n)O(n)。</p><ul class=""><li id="3574" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated"><strong class="kx ir">算法范式:</strong>分而治之</li><li id="4cb1" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><strong class="kx ir">整理到位:</strong>是</li><li id="cbe0" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated"><strong class="kx ir">稳定:</strong>默认不稳定</li></ul><h2 id="3532" class="nq mp iq bd mq nr ns dn mu nt nu dp my le nv nw na li nx ny nc lm nz oa ne ob bi translated">与其他排序算法的比较</h2><p id="40fa" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">虽然快速排序的平均运行时间和最佳情况下的运行时间与其他算法(如合并排序)的运行时间相等，但一个实现良好的快速排序将比其他排序算法具有更低的常数因子。</p><p id="2f75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实际上，快速排序通常比合并排序更快。</p><p id="7162" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一般来说，快速排序是一种就地排序(也就是说，它不需要任何额外的存储)。合并排序需要O(N)额外存储，其中N表示数组大小，这可能相当大。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b45c" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">接下来学什么</h1><p id="d031" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">排序是许多复杂编程解决方案的基础。虽然这看起来是一个简单的概念，但对于高效快速的排序算法来说，这是非常重要的。</p><p id="b596" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实际上，排序算法的效率或速度有时可能取决于被排序的数据集的类型。接下来，您应该研究以下算法:</p><ul class=""><li id="9748" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated">插入排序</li><li id="1a91" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">冒泡排序</li><li id="e950" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">选择排序</li><li id="d3f2" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">堆排序</li><li id="7b57" class="lz ma iq kx b ky mj lb mk le ml li mm lm mn lq me mf mg mh bi translated">桶排序</li></ul><p id="d01c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快乐学习！</p></div></div>    
</body>
</html>