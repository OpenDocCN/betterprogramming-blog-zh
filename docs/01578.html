<html>
<head>
<title>Learn Lazy Loading Through a Simple Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过一个简单的例子学习延迟加载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-lazy-loading-through-a-simple-example-b2c318aa0624?source=collection_archive---------5-----------------------#2019-09-25">https://betterprogramming.pub/learn-lazy-loading-through-a-simple-example-b2c318aa0624?source=collection_archive---------5-----------------------#2019-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="995e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们只在用户向下滚动后加载第二个沉重的CSS文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0469aaa662fd2bb5aa03bbd457bdc32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIeSke0xle0FTZ4fy1l9qQ.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="73eb" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">说到优化网站以获得更好的性能，懒加载是我们不能忽视的一个概念。但是在开始之前，我们先来了解一些性能提升的背景。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="7fe5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">网站优化的三大支柱</h1><p id="db3c" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">网站优化是一个庞大的概念，包括优化前端，后端，和网络。</p><p id="5335" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">优化这三个支柱中的每一个都是非常重要的，如果我们想让我们的网站在性能方面做得更好，我们在优化它们时应用的每一个概念都是非常重要的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/0af3f48516b93616fa2e6d90bc9d31b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*H3KGy6PN4wmOqSk5s7XmOg.png"/></div></figure><p id="a4ec" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">前端性能可以通过各种技术来提高，如优化代码、最小化文件、缩小CSS、丑化JS、缩小图像、延迟加载、缓存等。</p><p id="2a6c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">所以你可能已经猜到，在优化前端以获得更好的性能时，延迟加载是一个重要的概念。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="4731" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">我和你之间的秘密</h1><p id="994b" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">好吧，我要告诉你一个小秘密，我能指望你会保守这个秘密吗，就在我和你之间？</p><p id="38af" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">酷，我相信你！所以，我没有为我的新博客找到灵感，昨天，我的一个朋友(他在一家远程创业公司工作)问我:</p><p id="4272" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">“嘿Madhav，我的老板希望我在为他们的网站获取数据时应用延迟加载，我谷歌了延迟加载的定义，但没有理解它，你能以外行的术语解释给我听吗？”</p><p id="e0a4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">惰性加载，作为一个概念，非常容易理解，但是它可以根据你的用例以不同的方式实现。所以，我向他解释了这个概念，在这之间，我有一个顿悟的时刻。</p><p id="1ca9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我想，为什么不写一个关于它的博客，以便更多正在与这个概念作斗争的人可以得到帮助？</p><p id="3b61" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">很抱歉突然写下这个故事，但我希望你明白我想说的。</p><p id="0fbf" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我在这里想表达的是，如果你在谷歌上搜索后仍然不理解一个概念，为什么不去尝试一下呢？我也许可以用更简单的术语来解释，这样你就能理解这个概念，我也可以为我的新博客出个主意！</p><p id="614f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">所以，是的，如果你觉得我可以帮助你，伸出手，我很乐意帮助(除非答案可以很容易地在谷歌上找到，如果是这样的话，谷歌一下！)</p><p id="bd46" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">好了，马达夫，你让我厌烦了，现在回到正题！</p><p id="0396" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">啊，不好意思，给你。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="8351" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">延迟加载的概念</h1><p id="ff8f" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">暂时，忘掉你在大学时塞进去的那些大定义，试着去理解这个概念。(别担心，我们也会回到定义上来。)</p><p id="2f82" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们举个例子，假设你在做一个聊天应用(就像Whatsapp一样)，想法很简单；用户可以进行任意数量的对话(取决于他们有多少联系人)。</p><p id="5595" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">因此，每当他们打开应用程序，他们的对话就会加载每个对话中的最新消息，并显示在列表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/f70b1ad4a1d3a4d1f5178ca8f82c0927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHY7Yr3mPwzDYnAKUg6H7Q.png"/></div></div></figure><p id="8060" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">事情很简单，对吗？我们所要做的就是将完整的对话列表存储在数据库中，一旦用户打开应用程序，我们就获取该对话列表。</p><p id="a03f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">生活没那么容易吧？如果用户是一个巨大的名人呢？如果他们有成千上万的联系人，并且和他们都有联系呢？</p><p id="baeb" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在这种情况下，只要他们打开应用程序，整个对话列表就会从数据库中提取出来，这显然非常大，需要很长时间才能加载。用户对此很恼火，卸载了我们的app，使用了更好的应用。</p><p id="5104" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这是一个相当严重的问题，我们能做什么？</p><p id="32db" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">好问题。我料到你会问这个问题，想一想，我们如何解决这个问题？(显然，答案是:“通过使用延迟加载”，但我需要考虑我们如何在这个场景中应用它。)</p><p id="6640" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">好吧，我给你五分钟时间考虑，同时，我去喝杯茶。(是的，我不太喜欢咖啡。)</p><p id="1724" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">解决方法很简单，因为加载整个会话列表需要很多时间，所以我们不会加载整个会话列表。</p><p id="d2c6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">是的，就是这样，这就是懒惰装载背后的整个概念。一旦用户打开我们的应用程序，我们将只加载我们需要的东西。不多不少。</p><p id="af7d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">因此，在这种情况下，我们将加载，比方说，用户屏幕上可以显示的聊天项目的三倍(取决于它们的屏幕大小)，并呈现它。</p><p id="f32c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">一旦呈现出来，我们将再次请求加载更多的项目，一旦它们被加载，我们将请求更多的项目，以此类推，直到所有的项目都被加载。</p><p id="a234" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在，由于我们不是一次请求所有的对话，而是只请求10-12个项目(例如)，用户将很快得到响应，他们可以开始与应用程序进行交互。现在他们不用等那么久了，对吗？</p><p id="d9ac" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">哇，马达夫，这太简单了！</p><p id="8602" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我知道，我是一个好老师。</p><p id="9a8a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">哈哈，开个玩笑。既然我们已经理解了它的意思，让我们也来看看它的定义。</p><p id="54ba" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">惰性加载是计算机编程中常用的一种设计模式，它将对象的初始化推迟到需要它的时候。</p><p id="dba8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我希望这个定义现在看起来也很简单，因为你知道这个概念。这个定义基本上是说，我们只在实际需要的时候才加载资源。</p><p id="2cd1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">唷，马达夫，这很简单，但我想看到它的实际应用，帮我一下。</p><p id="1a05" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">是的，是的，冷静下来，我们会谈到它，但首先，让我们快速看看为什么我们需要惰性加载。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="f46d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">为什么偷懒装？</h1><p id="1682" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">让我们假设你正在加载用户当前看不到的东西，用户可能永远也看不到它，你不知所措，</p><ol class=""><li id="d3d6" class="mz na it ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">您正在浪费宝贵的时间，这些时间本可以用来只呈现当前显示给用户的数据。他们可能会对缓慢的加载感到恼火，甚至离开网站或卸载应用程序。</li><li id="ca1b" class="mz na it ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">你在浪费宝贵的数据。我同意现在很多人有无限的数据，但应用程序必须为所有用户优化，假设某个特定的用户群正在使用有限的数据计划，加载他们可能永远不会看到的东西将是浪费他们的钱。</li><li id="a951" class="mz na it ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">处理能力的浪费，我同意它可能相对较小，但是，为什么要浪费它呢？</li><li id="6d7e" class="mz na it ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">在网站或web应用程序的情况下，CSS是渲染阻塞的，直到CSSOM被完全创建，渲染树才会被创建，所以只加载真正需要的。</li></ol><p id="a3e4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在我想你真的明白了它的重要性，所以让我们转到这个博客的最后也是最有趣的部分。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="3d62" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">编码时间到了</h1><p id="8c9d" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">现在，我们已经从理论上理解了延迟加载的概念，让我们试着实现它，看看它实际上是如何工作的。</p><p id="735c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">耶，我太兴奋了，在那个巨大的理论之后，我们终于要编码了。</p><p id="f29f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">因此，为了了解事情是如何工作的，我们将创建一个非常简单的网站，它将有两个部分。</p><p id="50ff" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">一个主要部分(高度:110vh)，它将在网站加载时对用户可见，另一个次要部分(高度:110vh)，只有当用户向下滚动时才可见。</p><p id="4047" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在这个例子中，我们将为它们中的每一个提供两个单独的样式表，并且只在用户开始向下滚动时才加载第二个样式表。</p><p id="c74c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">请注意，这只是一个例子，在现实世界中，我们不会为用户滚动时必须显示的内容创建两个单独的样式表。</p><p id="fd73" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为什么？因为，如果出现网络连接错误，用户就无法获得第二个样式表，第二部分的内容就会以非常糟糕的方式出现。</p><p id="8598" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">但是，我们可以使用相同的原理来延迟加载图像，或者延迟加载页面加载后用户不直接交互的数据，这些数据必须从服务器获取(就像我们在开始时看到的聊天应用程序示例中的对话列表一样)。)</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="041c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">第一部分。编码我们的HTML</h1><p id="1757" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">正如我们所讨论的，我们将添加两个部分，一个包含类<code class="fe nn no np nq b">primary</code>，另一个包含类<code class="fe nn no np nq b">secondary</code>，我们只需要添加到第一个样式表的链接。</p><p id="136f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr kv l"/></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">Gist网址:<a class="ae nw" href="https://gist.github.com/MadhavBahlMD/4a8f8d77d7bb29fa089b9bf52b865540" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/MadhavBahlMD/4a 8 f 8d 77d 7 bb 29 fa 089 b 9 BF 52 b 865540</a></p></figure><p id="fa17" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如你所见，我们这里有两个部分，每个部分的高度为100vh，每个部分内部有一个内部div，其内容将居中。</p><p id="96e3" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">另外，在<code class="fe nn no np nq b">&lt;head&gt;</code>中，您可能已经注意到我们只包含了<code class="fe nn no np nq b">style1.css</code>文件。当用户向下滚动时，我们将动态获取<code class="fe nn no np nq b">style2.css</code>。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="ce8e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">第二部分。让我们添加第一个样式表</h1><p id="7290" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">这个样式表将使<code class="fe nn no np nq b">primary</code>部分的高度<code class="fe nn no np nq b">110vh</code>和背景颜色<code class="fe nn no np nq b">ff80ab</code>。</p><p id="65d6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">此外，我们必须将内部div垂直和水平居中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr kv l"/></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">Gist网址:<a class="ae nw" href="https://gist.github.com/MadhavBahlMD/ecb00b01aafa72b2f2c49afe8aadce1e" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/MadhavBahlMD/ECB 00 b 01 aafa 72 B2 F2 c 49 AFE 8 aad ce1 e</a></p></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="c88e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">第三部分。添加第二个样式表</h1><p id="a595" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">这将类似于<code class="fe nn no np nq b">style1.css</code>，但背景颜色<code class="fe nn no np nq b">d1c4e9</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr kv l"/></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">Gist网址:<a class="ae nw" href="https://gist.github.com/MadhavBahlMD/2e10ffe7159144590276fb4848e63147" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/MadhavBahlMD/2e 10 FFE 7159144590276 FB 4848 e 63147</a></p></figure><p id="88ca" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">好了，现在我知道你们所有人会问我为什么我没有给secondary部分的内部div相同的类，<code class="fe nn no np nq b">primary-inner</code>，尽管它们有相同的风格。</p><p id="8dfc" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这只是因为我想为每个示例演示两个完全不同的样式表，当然，在现实世界的场景中，我们会尽可能地重用代码。</p><p id="56a0" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">好了，现在是展示时间了，我们最后要添加负责动态加载第二个样式表的JS。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1edc" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">第四部分。添加脚本</h1><p id="6e81" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">这是主要部分。想法是懒惰地加载“最初不可见”的内容，我们开始吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr kv l"/></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">Gist网址:<a class="ae nw" href="https://gist.github.com/MadhavBahlMD/e5c2de2d705650ae047c2b23255c5d4b" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/MadhavBahlMD/e 5 C2 de 2d 705650 AE 047 C2 b 23255 C5 D4 b</a></p></figure><p id="97bb" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">因此，如果我们仔细阅读代码，很容易理解我们基本上是在用户向下滚动后动态添加新的样式表。</p><p id="ff9d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了检测向下滚动，我们使用了<code class="fe nn no np nq b">window.onscroll</code>事件，并确保调用只进行一次，我们维护了一个标志变量<code class="fe nn no np nq b">scrollFlag</code>，它在第一次调用<code class="fe nn no np nq b">onscroll</code>时被设置。</p><p id="aa08" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了加载样式表，我们创建了一个函数来检查是否支持direct <code class="fe nn no np nq b">document.createStylesheet</code>方法。如果是，那么我们使用它，否则，我们创建链接标签并把它附加到<code class="fe nn no np nq b">&lt;head&gt;</code>标签中。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="c3e9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">就这样，让我们看看它的实际效果</h1><p id="40c8" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">所以，我们完成了代码。现在，要查看它的运行情况，请在web浏览器中打开<code class="fe nn no np nq b">index.html</code>,检查element，并转到networks选项卡。</p><p id="4909" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在这里，您会注意到只调用了<code class="fe nn no np nq b">style1</code>样式表，一旦您向下滚动，<code class="fe nn no np nq b">style2</code>样式表也会被调用。</p><p id="fc2c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">给你:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/7189670c5d6c569566c6d8fdc9550bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OjqAM4RdGlztPuGBd69RMg.gif"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">注意我们滚动后“style2.css”是如何加载的</p></figure><p id="16f5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">所以，差不多就是这样！希望这篇博客对你有所帮助。</p></div></div>    
</body>
</html>