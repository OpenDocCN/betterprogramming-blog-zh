<html>
<head>
<title>5 Common Anti-Patterns in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的5种常见反模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-common-anti-patterns-in-python-a9d6443fabe4?source=collection_archive---------0-----------------------#2021-04-16">https://betterprogramming.pub/5-common-anti-patterns-in-python-a9d6443fabe4?source=collection_archive---------0-----------------------#2021-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c20a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当输入量很大时，避免使用列表理解</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8d68f83389b2cf99485428f675fbda5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l7BaaD2ktldFDP2d"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kz"><p id="7caf" class="la lb it bd lc ld le lf lg lh li lj dk translated">“光有代码是不够的。”罗伯特·马丁</p></blockquote><p id="64b1" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated">Python是2021年最受欢迎的语言之一。</p><p id="a931" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">简单的语法使它成为新手程序员的流行选择。</p><p id="24b5" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">由于动态性和灵活性，Python开发人员有时很容易编写出错误的、低效的代码。</p><p id="5976" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">本文将向读者介绍Python中常见的反模式，并提出一些修复方法，这些方法将带来更好的开发实践。</p><h1 id="9690" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">1.对可迭代对象使用map()和filter()</h1><p id="503a" class="pw-post-body-paragraph lk ll it lm b ln nc ju lp lq nd jx ls lt ne lv lw lx nf lz ma mb ng md me lj im bi translated">内置的<code class="fe nh ni nj nk b">map</code>和<code class="fe nh ni nj nk b">filter</code>通过<a class="ae ky" href="https://www.geeksforgeeks.org/functional-programming-paradigm" rel="noopener ugc nofollow" target="_blank">函数式编程</a>的原理帮助我们转换Python中的可迭代对象。</p><p id="8ea3" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">这两种方法都接受函数和iterable作为参数，并返回相应的对象。</p><p id="bf34" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">通过将这个对象作为参数传递给Python中内置的<code class="fe nh ni nj nk b">list</code>构造函数，可以将它转换成一个列表。</p><p id="556c" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">我们经常使用<code class="fe nh ni nj nk b">lambda</code>函数作为<code class="fe nh ni nj nk b">map</code>、<code class="fe nh ni nj nk b">filter</code>函数的参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0c3f" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">代码看起来相当笨拙和不清楚。获得相同结果的更好方法是使用<a class="ae ky" href="https://www.w3schools.com/python/python_lists_comprehension.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="lm iu">列表理解</strong> </a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4b11" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">lambda函数的缺乏使得列表的理解更加易读和简洁。</p><h1 id="39e6" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">2.大量输入时使用列表理解</h1><p id="71ce" class="pw-post-body-paragraph lk ll it lm b ln nc ju lp lq nd jx ls lt ne lv lw lx nf lz ma mb ng md me lj im bi translated">列表理解对于编写清晰、简洁的代码来说是非常棒的。</p><p id="b01b" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">然而，列表理解总是创建iterable中每个值的列表。当输入非常大时，这会导致内存问题；它会导致你的机器崩溃。</p><p id="318f" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated"><strong class="lm iu"> G </strong></p><p id="3880" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">要创建它们，你所要做的就是用<code class="fe nh ni nj nk b">()</code>括号替换列表理解中的<code class="fe nh ni nj nk b">[]</code>括号。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/a553532727ec8e34f3eaaeef4466b591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P25IfcBcUmeDwXohGySP9A.png"/></div></div></figure><p id="b344" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">生成器表达式不是创建一个全新的列表，而是创建一个迭代器。</p><p id="c9ca" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">这个<strong class="lm iu">降低了创建</strong>的速度，而<strong class="lm iu">优化了内存分配</strong>。您可以通过使用<code class="fe nh ni nj nk b">next</code>函数或循环访问生成器表达式的每个后续元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d3a2" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated"><strong class="lm iu">注意:</strong> <br/>生成器表达式是有状态的，所以在试图重用它们时要小心。如果打算多次使用迭代器，可能需要重新创建它。</p><p id="7e85" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">阅读Brett Slatkin的“<a class="ae ky" href="http://effectivepython.com" rel="noopener ugc nofollow" target="_blank">有效的Python: 90种编写更好的Python(第二版)</a>的具体方法”中的第31项，以便很好地了解如何做到这一点。</p><h1 id="7127" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">3.不使用range()的情况</h1><p id="8b73" class="pw-post-body-paragraph lk ll it lm b ln nc ju lp lq nd jx ls lt ne lv lw lx nf lz ma mb ng md me lj im bi translated"><code class="fe nh ni nj nk b">range</code>函数对于整数的迭代很有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7873" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">当迭代列表等可迭代的数据结构时，您可以完全依赖for循环语法来访问每一项。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b5fa" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">然而，当想要访问索引和元素时，我们可以在列表长度上使用<code class="fe nh ni nj nk b">range</code>方法，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="dc0e" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">代码看起来不可读，因为您必须调用列表上的<code class="fe nh ni nj nk b">len</code>，然后使用<code class="fe nh ni nj nk b">range</code>包装输出。为了使它更加Pythonic化，我们必须提高代码的可读性。</p><p id="7b1b" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">更好的方法是调用list对象上的<code class="fe nh ni nj nk b">enumerate</code>函数。这将创建一个生成器，生成列表项的索引和值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f4f2" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">这个看起来是不是干净多了？</p><h1 id="1ff3" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">4.缺少字典键的问题是</h1><p id="fe5b" class="pw-post-body-paragraph lk ll it lm b ln nc ju lp lq nd jx ls lt ne lv lw lx nf lz ma mb ng md me lj im bi translated">字典具有快速访问、赋值、插入和删除的能力，这使得它成为一种非常流行的数据结构。</p><p id="305b" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">当<strong class="lm iu">试图访问字典</strong>中不存在的键时，新手开发者经常会遇到问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/cb153bcda2b5febbac48b096185bcc3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJWoV9J2rleWVbLK2wwaYg.png"/></div></div></figure><p id="ec1c" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">处理这种情况的一种方法是检查字典中是否存在该键，下面的代码可以帮助您:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7ed2" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">另一种实现方法是使用try/except块，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4a6b" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">上面的代码确实实现了我们的目标，但是我们可以通过使用字典方法<code class="fe nh ni nj nk b">get</code>来进一步改进它。</p><p id="8dfe" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">您可以使用<code class="fe nh ni nj nk b">get</code>方法来获取相应键的值，而不是使用方括号<code class="fe nh ni nj nk b">[]</code>来访问字典的键。</p><p id="cd67" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">另外，如果键不存在，<code class="fe nh ni nj nk b">get</code>方法返回<code class="fe nh ni nj nk b">None</code>，这是有利的，而不是抛出一个<code class="fe nh ni nj nk b">KeyError</code>。如果没有键而没有<code class="fe nh ni nj nk b">None</code>，您也可以向<code class="fe nh ni nj nk b">get</code>方法传递一个参数来获得一个默认值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="a526" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">5.惰性关键字和位置参数设计</h1><p id="c7ce" class="pw-post-body-paragraph lk ll it lm b ln nc ju lp lq nd jx ls lt ne lv lw lx nf lz ma mb ng md me lj im bi translated">Python函数能够接受<strong class="lm iu">位置</strong>和<strong class="lm iu">关键字</strong>参数。</p><blockquote class="np nq nr"><p id="8248" class="lk ll ns lm b ln mf ju lp lq mg jx ls nt mh lv lw nu mi lz ma nv mj md me lj im bi translated">位置参数是后面没有等号(=)和默认值的名称。</p><p id="89a1" class="lk ll ns lm b ln mf ju lp lq mg jx ls nt mh lv lw nu mi lz ma nv mj md me lj im bi translated">关键字参数后跟一个等号和一个给出其默认值的表达式。</p></blockquote><p id="408f" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">由于这种设计，python函数的创建和重用非常灵活。</p><p id="13b5" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">然而，定义函数时糟糕的设计选择会导致代码中难以修复的错误。</p><p id="71a3" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">让我们以计算<a class="ae ky" href="https://www.investopedia.com/terms/c/compoundinterest.asp" rel="noopener ugc nofollow" target="_blank">复利</a>的函数为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7602" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">调用函数时出现的一个问题是，末尾的两个布尔参数<code class="fe nh ni nj nk b">compounded_monthly</code>和<code class="fe nh ni nj nk b">to_string</code>很容易混淆。这可能会导致难以跟踪的问题。</p><p id="387e" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">我们可以通过如下方式更改函数定义来提高可读性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2360" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">通过将两个布尔参数指定为关键字参数，函数调用方可以显式指定他们想要设置的布尔值，这些值将覆盖默认值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="476e" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">然而，这仍然会导致问题的主要原因是关键字参数是可选的，因此，没有什么会强制调用者使用它们作为关键字参数。</p><p id="7f9b" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">因此，仍然可以使用旧方法调用该函数:</p><p id="223d" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated"><code class="fe nh ni nj nk b">calculate_compound_interest(100, 5, 2, False, False)</code></p><p id="1570" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">解决此问题的方法是仅在定义函数时将布尔参数强制为关键字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1adc" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">我们看到,<code class="fe nh ni nj nk b">*</code>符号表示位置参数的结束和只有关键字的参数的开始。</p><p id="cbf8" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">现在这样称呼它:</p><p id="468e" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated"><code class="fe nh ni nj nk b">calculate_compound_interest(100, 5, 2, False, False)</code></p><p id="9c04" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">将导致一个错误:</p><pre class="kj kk kl km gt nw nk nx ny aw nz bi"><span id="46ff" class="oa ml it nk b gy ob oc l od oe">---------------------------------------------------------------------------<br/>TypeError                                 Traceback (most recent call last)<br/>&lt;ipython-input-32-faf75d2ad121&gt; in &lt;module&gt;<br/>----&gt; 1 print(calculate_compound_interest(1000, 5, 2, False, False))</span><span id="f8d3" class="oa ml it nk b gy of oc l od oe">TypeError: calculate_compound_interest() takes 3 positional arguments but 5 were given</span></pre><p id="8ea7" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">但是，关键字参数及其默认行为仍将保持不变，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a593" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">然而，还有一个问题。</p><p id="2fcf" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">假设调用者决定对前三个必需的参数(<code class="fe nh ni nj nk b">principal</code>、<code class="fe nh ni nj nk b"> rate</code>、<code class="fe nh ni nj nk b"> time_in_years</code>)混合使用位置和关键字。</p><p id="b655" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">如果这三个参数的函数参数名称被更改，我们将看到Python解释器报错。它会显示如下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="kj kk kl km gt nw nk nx ny aw nz bi"><span id="8cd0" class="oa ml it nk b gy ob oc l od oe">---------------------------------------------------------------------------<br/>TypeError                                 Traceback (most recent call last)<br/>&lt;ipython-input-36-42e7ec842cd5&gt; in &lt;module&gt;<br/>----&gt; 1 calculate_compound_interest(principal=1000, rate=5, time_in_years=2)</span><span id="c4c4" class="oa ml it nk b gy of oc l od oe">TypeError: calculate_compound_interest() got an unexpected keyword argument 'principal'</span><span id="6153" class="oa ml it nk b gy of oc l od oe">---------------------------------------------------------------------------<br/>TypeError                                 Traceback (most recent call last)<br/>&lt;ipython-input-37-1bc57c40980f&gt; in &lt;module&gt;<br/>----&gt; 1 calculate_compound_interest(1000, 5, time_in_years=2)</span><span id="6bf3" class="oa ml it nk b gy of oc l od oe">TypeError: calculate_compound_interest() got an unexpected keyword argument 'time_in_years'</span></pre><p id="1116" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">因为我们没有考虑调用者显式使用位置参数，所以我们的代码会中断。</p><p id="9acc" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">Python 3.8中引入了一个解决方案，我们可以使用<code class="fe nh ni nj nk b">/</code>参数重新定义函数，该参数指示了位置唯一参数的结束位置。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9535" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">现在像这样调用函数会产生正确的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="85a4" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">但是，如果这样叫:</p><pre class="kj kk kl km gt nw nk nx ny aw nz bi"><span id="2572" class="oa ml it nk b gy ob oc l od oe">calculate_compound_interest(p=1000, r=5, t_in_y=2)</span></pre><p id="7dc8" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">然后显示相应的错误:</p><pre class="kj kk kl km gt nw nk nx ny aw nz bi"><span id="bda1" class="oa ml it nk b gy ob oc l od oe">---------------------------------------------------------------------------<br/>TypeError                                 Traceback (most recent call last)<br/>&lt;ipython-input-21-883e876a7e8b&gt; in &lt;module&gt;<br/>----&gt; 1 calculate_compound_interest(p=1000, r=5, t_in_y=2)<br/>      2</span><span id="813e" class="oa ml it nk b gy of oc l od oe">TypeError: calculate_compound_interest() got some positional-only arguments passed as keyword arguments: 'p, r, t_in_y'</span></pre></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="b226" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">我希望这篇文章能帮助你们提高用Python开发的工程技能！😃</p><p id="b824" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">我将在下面列出一些资源，您可以在这些资源中找到更多这样的反模式示例以及如何使用它们。</p><p id="cc67" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">下次见！✋</p><h1 id="963c" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">资源:</h1><div class="on oo gp gr op oq"><a href="https://effectivepython.com/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">有效的Python书籍:第二版</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">《有效的Python:第二版》中的每一章都包含了一系列广泛但相关的内容。随意在…之间跳来跳去</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">effectivepython.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://www.oreilly.com/library/view/fluent-python/9781491946237/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">流畅的Python</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">Python的简单性让您很快变得高效，但这通常意味着您没有使用它必须的一切…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">www.oreilly.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://realpython.com/products/python-tricks-book/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">Python技巧:书-真正的Python</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">我知道有一个很有才华的Python web开发人员——我称他为“Mark”。马克是一个自学成才的程序员，初出茅庐…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">realpython.com</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe ks oq"/></div></div></a></div></div></div>    
</body>
</html>