<html>
<head>
<title>SwiftUI’s New App Lifecycle and Replacements for AppDelegate and SceneDelegate in iOS 14</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI的新应用生命周期以及iOS 14中对AppDelegate和SceneDelegate的替换</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftuis-new-app-lifecycle-and-replacements-for-appdelegate-and-scenedelegate-in-ios-14-c9cf4a2367a9?source=collection_archive---------2-----------------------#2020-07-01">https://betterprogramming.pub/swiftuis-new-app-lifecycle-and-replacements-for-appdelegate-and-scenedelegate-in-ios-14-c9cf4a2367a9?source=collection_archive---------2-----------------------#2020-07-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="bfba" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">全新的属性包装器和函数构建器减少了样板代码</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/957ff2bab7a6cecdb6c9f54db061b845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BvaEbttDJt10ie2d"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="48f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在WWDC 2020期间，SwiftUI获得了自己的应用生命周期，以摆脱UIKit的AppDelegate和SceneDelegate。为此，iOS 14现在提供了一个<code class="fe lw lx ly lz b">App</code>协议、一个<code class="fe lw lx ly lz b">SceneBuilder</code>、<code class="fe lw lx ly lz b">scenePhase</code>枚举器和一个新的属性包装器<code class="fe lw lx ly lz b">UIApplicationDelegateAdaptor</code>。在我们看它们是什么之前，让我们快速地复习一下<code class="fe lw lx ly lz b">SceneDelegate</code>。</p><p id="9136" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS 13中引入SceneDelegate主要是为了解决iPadOS上的多窗口支持。它带来了从窗口概念到场景的转变，并允许我们将责任从AppDelegate转移。</p><p id="b29c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从iOS 14开始，当你在Xcode 12或更高版本的项目中创建新的SwiftUI应用时，你会得到一个选项，在<em class="ma"> SwiftUI应用生命周期</em>和<em class="ma"> UIKit应用委托</em>之间进行选择。虽然后者将生成相同的旧的<code class="fe lw lx ly lz b">AppDelegate</code>和<code class="fe lw lx ly lz b">SceneDelegate</code>样板代码，其中<code class="fe lw lx ly lz b">UIHostingController</code>用于嵌入SwiftUI视图，但前者将用一个新的起点迎接您，纯粹是为了SwiftUI。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="04e5" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">SwiftUI App协议:一个新的起点</h1><pre class="kk kl km kn gu na lz nb nc aw nd bi"><span id="0f0f" class="ne mj iu lz b gz nf ng l nh ni"><a class="ae kz" href="http://twitter.com/main" rel="noopener ugc nofollow" target="_blank">@main</a><br/>struct ProjectName: App {<br/>    var body: some Scene {<br/>        WindowGroup {<br/>            ContentView()<br/>        }<br/>    }<br/>}</span></pre><p id="84cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然上面这段代码很短，但是在引擎盖下有很多自动发生的事情。首先，该结构通过将<code class="fe lw lx ly lz b">Scenes </code>和<code class="fe lw lx ly lz b">Views</code>统一在一个地方，提供了SwiftUI应用程序层次结构的鸟瞰图。代码中需要注意的几个重要事项是:</p><ul class=""><li id="4377" class="nj nk iu lc b ld le lg lh lj nl ln nm lr nn lv no np nq nr bi translated"><code class="fe lw lx ly lz b">@main</code>属性是Swift 5.3中引入的，它表明上述结构是我们SwiftUI应用程序的起点。</li><li id="c9ec" class="nj nk iu lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated">通过遵守<code class="fe lw lx ly lz b">App</code>协议，我们需要实现一个<code class="fe lw lx ly lz b">SceneBuilder</code>，它本质上是一个函数构建器，用于组成一个或多个场景。因为我们在上面的例子中只使用了一个场景，所以我们实现了computed属性<code class="fe lw lx ly lz b">body</code>。另外，<code class="fe lw lx ly lz b">App</code>协议负责触发启动SwiftUI应用程序的<code class="fe lw lx ly lz b">main()</code>方法。</li><li id="3056" class="nj nk iu lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated">上例中的容器场景包装了我们的SwiftUI视图。在iPadOS或macOS上运行上述应用程序可以创建多个<code class="fe lw lx ly lz b">WindowGroup</code>场景，因为它们支持这些功能。</li></ul><p id="67a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了<code class="fe lw lx ly lz b">WindowGroup</code>，你还可以为基于文档的应用程序使用<code class="fe lw lx ly lz b">DocumentGroup</code>场景类型，或者为macOS或watchOS使用<code class="fe lw lx ly lz b">Settings</code>和<code class="fe lw lx ly lz b">WKNotificationScene</code>。</p><p id="5c1f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你也可以在<code class="fe lw lx ly lz b">WindowGroup</code>场景上设置命令修改器，为场景添加快捷键。为此，我们需要利用新的<code class="fe lw lx ly lz b">CommandsBuilder</code>对使用<code class="fe lw lx ly lz b">Commands</code>协议的<code class="fe lw lx ly lz b">CommandMenu</code>进行分组。</p><p id="3dc2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在合成复杂场景时，将computed属性设置为<code class="fe lw lx ly lz b">@SceneBuilder</code>非常重要。例如，下面给出的例子为macOS平台创建了一个首选菜单场景。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nx"><img src="../Images/689a06081c355c360d651251bda61a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27m7pksRuJ99shpoNQg4pQ.png"/></div></div></figure></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="c82b" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">如何听SceneDelegate生命周期方法？</h1><p id="7d95" class="pw-post-body-paragraph la lb iu lc b ld ny jv lf lg nz jy li lj oa ll lm ln ob lp lq lr oc lt lu lv in bi translated">尽管样板代码减少了，但人们可能想知道如何收听场景的生命周期更新——正如我们在<code class="fe lw lx ly lz b">SceneDelegate</code>中所做的。很高兴，我们有一个<code class="fe lw lx ly lz b">scenePhase</code>枚举器来保存场景的当前状态。我们可以使用它作为一个<code class="fe lw lx ly lz b">Environment</code>属性包装器和一个<code class="fe lw lx ly lz b">onChange</code>修改器来监听我们场景的状态变化，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="a058" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">如何将AppDelegate与SwiftUI App协议一起使用</h1><p id="43fb" class="pw-post-body-paragraph la lb iu lc b ld ny jv lf lg nz jy li lj oa ll lm ln ob lp lq lr oc lt lu lv in bi translated"><code class="fe lw lx ly lz b">AppDelegate</code>类是我们应用程序的重要组成部分。无论是处理通知还是配置Firebase，它都以其不同的生命周期方法发挥着关键作用。</p><p id="0f3b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了挂钩<code class="fe lw lx ly lz b">AppDelegate</code>功能，我们需要将UIKit(为了符合<code class="fe lw lx ly lz b">UIApplicationDelegate</code>)带回到目前为止的纯SwiftUI应用程序中。SwiftUI提供了一个新的属性包装器<code class="fe lw lx ly lz b">UIApplicationDelegateAdaptor</code>，通过它我们可以在SwiftUI结构中注入<code class="fe lw lx ly lz b">AppDelegate</code>实例:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="9ac7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，我们可以使用<code class="fe lw lx ly lz b">WKExtensionDelegateAdaptor</code>属性包装器来提供watchOS的委托。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="6e99" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">结论</h1><p id="11ff" class="pw-post-body-paragraph la lb iu lc b ld ny jv lf lg nz jy li lj oa ll lm ln ob lp lq lr oc lt lu lv in bi translated">我们看到了一个新的属性包装器，用于将AppDelegate注入到SwiftUI结构中，还看到了一个新的函数生成器——<code class="fe lw lx ly lz b">SceneBuilder</code>——用于合成场景。</p><p id="6292" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">新的SwiftUI应用生命周期有助于快速启动SwiftUI开发。您可以利用新的<code class="fe lw lx ly lz b">@SceneStorage</code>属性包装器在应用程序的多个场景中进行状态恢复。</p><p id="975c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">记住SceneDelegates在iOS 14和最新的SwiftUI迭代中都没有被弃用。苹果只带来了一个新的应用生命周期，用于构建不依赖于UIKit的原生SwiftUI应用。</p><p id="144d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读。</p></div></div>    
</body>
</html>