<html>
<head>
<title>Unit Testing React-Redux Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试React-Redux挂钩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-react-redux-hooks-ce7d69e1e834?source=collection_archive---------2-----------------------#2019-11-22">https://betterprogramming.pub/unit-testing-react-redux-hooks-ce7d69e1e834?source=collection_archive---------2-----------------------#2019-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c303" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">测试使用useDispatch和useSelector的功能组件可能略有不同。以下是测试它们的方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/706eab17a6ebc341daeecb426eedd0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1gbe_LitatLiVM_WUDvmw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">李·坎贝尔在<a class="ae ky" href="https://unsplash.com/s/photos/web-design?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试使用<code class="fe lv lw lx ly b">useDispatch</code>和<code class="fe lv lw lx ly b">useSelector</code>钩子的功能组件可能与常规的连接组件测试略有不同。本文演示了一种测试组件的简单方法，这种方法适用于两种类型的组件(使用这些钩子的组件或<code class="fe lv lw lx ly b">connected</code>组件)。</p><p id="cd8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为学习的最好方法是创建一个小项目，我们将创建一个小的web应用程序。它将有一个“计数的数量”文本显示在顶部和一个按钮，当点击时增加计数的数量。这篇教程的完整源代码可以在这里找到:<a class="ae ky" href="https://github.com/AngSin/counter-app-tested" rel="noopener ugc nofollow" target="_blank">https://github.com/AngSin/counter-app-tested</a>。</p><p id="f939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先让我们使用create-react-app来设置我们的项目。如果没有create-react-app，可以使用:<code class="fe lv lw lx ly b">npm i -g create-react-app</code>下载。安装完成后，使用<code class="fe lv lw lx ly b">create-react-app &lt;PROJECT_NAME&gt;</code>初始化一个新项目。</p><p id="85ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后要加redux: <code class="fe lv lw lx ly b">yarn add redux react-redux</code>。</p><p id="6ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<code class="fe lv lw lx ly b">enzyme</code>作为我们的测试库:<br/> <code class="fe lv lw lx ly b">yarn add -D enzyme enzyme-adapter-react-16</code>进行测试。</p><p id="baec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是该项目的基本框架文件:</p><p id="8923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引</strong></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0427" class="md me it ly b gy mf mg l mh mi">// index.js<br/>import React from ‘react’;<br/>import ReactDOM from ‘react-dom’;<br/>import { Provider } from ‘react-redux’;</span><span id="7a6e" class="md me it ly b gy mj mg l mh mi">import <strong class="ly iu"><em class="mk">store </em></strong>from ‘./store’;<br/>import Component from ‘./Component’;<br/>import ‘./index.css’;</span><span id="6166" class="md me it ly b gy mj mg l mh mi">ReactDOM.render(<br/> &lt;Provider store={<strong class="ly iu"><em class="mk">store</em></strong>}&gt;&lt;Component /&gt;&lt;/Provider&gt;,<br/> <strong class="ly iu"><em class="mk">document</em></strong>.getElementById(‘root’)<br/>);</span></pre><p id="ab96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">组件</strong></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c769" class="md me it ly b gy mf mg l mh mi">// Component.js<br/>import React from 'react';<br/>import { <strong class="ly iu"><em class="mk">useDispatch</em></strong>, <strong class="ly iu"><em class="mk">useSelector </em></strong>} from "react-redux";<br/><br/>import './Component.css';<br/>import { addCount } from './actions';<br/><br/>const Component = () =&gt; {<br/>  const count = <strong class="ly iu"><em class="mk">useSelector</em></strong>(state =&gt; state.count);<br/>  const dispatch = <strong class="ly iu"><em class="mk">useDispatch</em></strong>();<br/>  const handleClick = () =&gt; dispatch(addCount());<br/><br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h3&gt;<br/>        Count: {count}<br/>      &lt;/h3&gt;<br/>    &lt;button onClick={handleClick}&gt;<br/>      Increase count<br/>    &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default Component;</span></pre><p id="445b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">动作</strong></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9bc9" class="md me it ly b gy mf mg l mh mi">// actions.js<br/>export const <strong class="ly iu"><em class="mk">ADD_COUNT_TYPE </em></strong>= 'ADD_COUNT_TYPE';<br/><br/>export const addCount = () =&gt; ({<br/>  type: <strong class="ly iu"><em class="mk">ADD_COUNT_TYPE<br/></em></strong>});</span></pre><p id="c3c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">减速器:</strong></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3a84" class="md me it ly b gy mf mg l mh mi">// reducer.js<br/>import { <strong class="ly iu"><em class="mk">ADD_COUNT_TYPE </em></strong>} from './actions';<br/><br/>const initialState = {<br/>  count: 0,<br/>};<br/><br/>export default(state = initialState, action) =&gt; {<br/>  switch(action.type) {<br/>    case <strong class="ly iu"><em class="mk">ADD_COUNT_TYPE</em></strong>:<br/>      return {...state, count: state.count + 1};<br/>    default:<br/>      return state;<br/>  }<br/>};</span></pre><p id="89b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了创建一个与create-react-app的测试脚本一起工作的测试套件，让我们创建一个遵循<code class="fe lv lw lx ly b">test.js</code>命名约定的测试文件。我给我的取名<code class="fe lv lw lx ly b">Component.test.js</code>。因为我们使用的是enzyme，所以我们也必须在测试文件中配置enzyme:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4ca1" class="md me it ly b gy mf mg l mh mi">// Component.test.js<br/>import Enzyme, { mount } from 'enzyme';<br/>import EnzymeAdapter from 'enzyme-adapter-react-16';</span><span id="2384" class="md me it ly b gy mj mg l mh mi">Enzyme.configure({ adapter: new EnzymeAdapter() });</span></pre><p id="f9af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常这段代码会放在一个<code class="fe lv lw lx ly b">testSetup.js</code>文件中，但是因为我想让它成为一个准系统项目，所以我没有遵循很多react文件夹结构惯例。</p><p id="16fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用<code class="fe lv lw lx ly b">enzyme</code>的<code class="fe lv lw lx ly b">shallow</code>或<code class="fe lv lw lx ly b">mount</code>函数将我们的组件呈现给测试dom，但是由于在这种情况下，我们的组件依赖于redux存储，我们还必须将它包装在由<code class="fe lv lw lx ly b">react-redux</code>导出的<code class="fe lv lw lx ly b">Provider</code> HOC中。由于本教程的目的是全面测试我们的组件，包括redux端，我们必须为redux <code class="fe lv lw lx ly b">&lt;Provider /&gt;</code>创建一个模拟存储，其初始状态满足我们的redux的结构。一旦完成，我们就可以使用<code class="fe lv lw lx ly b">mount</code>来呈现我们的组件。现在，我们可以检查并验证计数是否正确显示，当单击按钮时，它也会更新显示的计数。我们的文件应该如下所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cb24" class="md me it ly b gy mf mg l mh mi">// Component.test.js<br/>import React from 'react';<br/>import Enzyme, { mount } from 'enzyme';<br/>import EnzymeAdapter from 'enzyme-adapter-react-16';<br/>import { Provider } from 'react-redux';<br/>import { <strong class="ly iu"><em class="mk">createStore </em></strong>} from 'redux';<br/><br/>import Component from './Component';<br/>import reducer from './reducer';<br/><br/>Enzyme.configure({ adapter: new EnzymeAdapter() });</span><span id="5058" class="md me it ly b gy mj mg l mh mi">describe('&lt;Component /&gt; unit test', () =&gt; {<br/>  const mockStore = <strong class="ly iu"><em class="mk">createStore</em></strong>(reducer, {count: 0});<br/>  const getWrapper = () =&gt; mount(<br/>    &lt;Provider store={mockStore}&gt;<br/>      &lt;Component/&gt;<br/>    &lt;/Provider&gt;<br/>  );<br/><br/>  it('should add to count and display the correct # of counts', () =&gt; {<br/>    const wrapper = getWrapper();<br/>    expect(wrapper.find('h3').text()).toEqual('Count: 0');<br/>    wrapper.find('button').simulate('click');<br/>    expect(wrapper.find('h3').text()).toEqual('Count: 1');<br/>  });<br/>});</span></pre><p id="1c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的组件现在已经被正确测试了。这通常是测试组件的最佳方式，通过模拟动作，而不是检查组件属性/状态或检查某些功能是否被触发。然而，让我们更进一步。</p><p id="68df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在点击按钮时，我们向服务器发出HTTP调用来更新评论中的赞数，会怎么样？在这种情况下，仅仅检查UI是不够的。我们必须检查相应的动作是否被分派，这将负责发出异步请求。在这个例子中，我们没有发出异步请求，而是调度一个动作来更新计数。我们可以编写一个测试来确保动作被调度。我们的文件现在看起来像这样:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e96b" class="md me it ly b gy mf mg l mh mi">// Component.test.js<br/>import React from 'react';<br/>import Enzyme, { mount } from 'enzyme';<br/>import EnzymeAdapter from 'enzyme-adapter-react-16';<br/>import { Provider } from 'react-redux';<br/>import { <strong class="ly iu"><em class="mk">createStore </em></strong>} from 'redux';<br/><br/>import Component from './Component';<br/>import { addCount } from './actions';<br/>import reducer from './reducer';<br/><br/>Enzyme.configure({ adapter: new EnzymeAdapter() });<br/><br/>describe('&lt;Component /&gt; unit test', () =&gt; {<br/>  const getWrapper = (mockStore = <strong class="ly iu"><em class="mk">createStore</em></strong>(reducer, { count: 0 })) =&gt; mount(<br/>    &lt;Provider store={mockStore}&gt;<br/>      &lt;Component/&gt;<br/>    &lt;/Provider&gt;<br/>  );<br/><br/>  it('should add to count and display the correct # of counts', () =&gt; {<br/>    const wrapper = getWrapper();<br/>    expect(wrapper.find('h3').text()).toEqual('Count: 0');<br/>    wrapper.find('button').simulate('click');<br/>    expect(wrapper.find('h3').text()).toEqual('Count: 1');<br/>  });<br/><br/>  it('should dispatch the correct action on button click', () =&gt; {<br/>    const mockStore = <strong class="ly iu"><em class="mk">createStore</em></strong>(reducer, { count: 0 });<br/>    mockStore.dispatch = jest.fn();<br/><br/>    const wrapper = getWrapper(mockStore);<br/>    wrapper.find('button').simulate('click');<br/>    expect(mockStore.dispatch).toHaveBeenCalledWith(addCount());<br/>  });<br/>});</span></pre><p id="0fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里做什么？我们不是在describe块的开头初始化<code class="fe lv lw lx ly b">mockStore</code>，而是将它作为参数传递给<code class="fe lv lw lx ly b">getWrapper</code>函数。这允许我们引用<code class="fe lv lw lx ly b">mockStore</code>对象并检查它的方法<code class="fe lv lw lx ly b">dispatch</code>是否被调用。此外，如果应用程序很复杂，我们还可以检查是否不仅调度了某个操作，而且该操作是正确的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="de76" class="md me it ly b gy mf mg l mh mi">expect(mockStore.dispatch).toHaveBeenCalledWith(addCount());</span></pre><p id="68b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，在我们的例子中，第二个测试是多余的，因为它的唯一目的是更新UI。然而，如果不是更新UI，而是产生副作用，例如调用HTTP/HTTPS API，那么第二个测试将非常有用。</p><p id="2258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望您发现这篇文章很有用，可以用它来更好地测试您的组件。如果你遇到任何问题，你可以在下面留下评论或者在源代码回购中提出问题:<a class="ae ky" href="https://github.com/AngSin/counter-app-tested" rel="noopener ugc nofollow" target="_blank">https://github.com/AngSin/counter-app-tested</a>。如果你是一个自学成才的程序员，你可能也会发现<a class="ae ky" href="https://medium.com/makingofamillionaire/how-i-got-a-90k-job-tc-as-a-self-taught-web-developer-with-1-5-years-of-experience-in-germany-465d5281f7fa" rel="noopener">这篇文章</a>很有用。</p></div></div>    
</body>
</html>