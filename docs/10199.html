<html>
<head>
<title>Meet Microsoft Snippet — an Android Library for Measuring Code Execution Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">认识微软片段——一个用于测量代码执行时间的Android库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/microsoft-snippet-a-new-open-source-library-for-measuring-code-execution-duration-for-android-30e8bf21457c?source=collection_archive---------1-----------------------#2021-12-11">https://betterprogramming.pub/microsoft-snippet-a-new-open-source-library-for-measuring-code-execution-duration-for-android-30e8bf21457c?source=collection_archive---------1-----------------------#2021-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb4d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提高应用程序的性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7d393d03659e2dfc90b189f2dd1fab07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQgpp3B9guLyg4YgZYf9RQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安德里克·朗菲尔德在<a class="ae kv" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e8cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们编写Android应用程序时，我们必须考虑性能。性能改进的先决条件是测量。所以我试着探索我们已经有的选择。以下是我的要求，</p><ol class=""><li id="f423" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">一个可以给出一段代码的执行持续时间的工具，这段代码的范围从多个方法到多个文件。</li><li id="3a45" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一个可以剥离样板代码的工具，我们必须编写样板代码来进行测量和记录。</li><li id="afb7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一旦您添加了所有的代码来进行度量，由于显而易见的原因，您不能将代码签入到您的存储库中。这会使代码库变脏。</li></ol><p id="e289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我找到了几个解决方案:</p><ol class=""><li id="d56f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir"> Hugo </strong> —这是一个由Jake Wharton编写的小库，它可以测量执行一个由库注释的方法所花费的时间。但是有一个限制，你只能测量方法。如果我的用例从一个方法的中间开始，在一个不同的方法中结束，可能在同一个或不同的类文件中。基于用例的度量在这里是不可能的。</li><li id="cd12" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> Android profiler </strong> —这并不代表用户将要经历的实际执行时间，这会降低整个应用程序的速度。此外，问题是，当android studio和模拟器已经在运行时，它需要大量的工作，并且会降低系统的速度。它会发出大量我的用例不需要的数据。</li><li id="102e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> TimeLogger类</strong>——Android提供了一个TimeLogger类，它具有我一直在寻找的某种功能，但并不完全，它也被弃用了。所以我放弃了这个想法。</li><li id="065a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">自行测量</strong> —需要添加大量代码来记录开始时间和结束时间，然后我们还必须删除这些代码。这将使代码库变得肮脏，并让审查者感到愤怒。</li></ol><p id="1196" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以最终我想到了建造一个可以:</p><ol class=""><li id="8aeb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">减少进行测量所需的样板代码，并登录到控制台。</li><li id="7524" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在不影响代码质量的情况下交付生产。</li><li id="ac74" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">用度量来标记用例，并用收集的数据来构建可以检测回归的门。[ gates是一种框架，它将历史数据考虑在内，这些数据随着时间的推移分布在不同的提交中，并试图检测回归。当我们有锁定时钟频率的根设备时，它们工作得最好。]</li><li id="a313" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在测量的开始和结束标记之间深入探讨。</li><li id="8b4d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">有人可以扩展功能并以他们想要的方式使用收集的数据，而不仅仅是登录logcat。</li></ol><p id="e9aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过3周的头脑风暴和编码<strong class="ky ir">片段</strong>诞生了。</p><blockquote class="mg mh mi"><p id="c444" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">它提供了一个干净的API来解决我们的问题。你可以在这里找到它。它不仅测量执行时间，还记录所有周围的执行上下文，如类、方法、行、线程等，而我们不需要做任何额外的事情。</p></blockquote><div class="mn mo gp gr mp mq"><a href="https://github.com/microsoft/snippet-timekeeper" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">GitHub-Microsoft/snippet-timer:一个测量代码执行时间的android库。不需要…</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">一个测量代码执行时间的android库。无需删除测量代码，自动变为无效…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne kp mq"/></div></div></a></div><p id="0721" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要将代码片段添加到您的项目中，请将以下代码添加到应用程序级别<code class="fe nf ng nh ni b">build.gradle</code>:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="a1ef" class="nn no iq ni b gy np nq l nr ns">allprojects <strong class="ni ir">{<br/>    </strong>repositories <strong class="ni ir">{<br/>        </strong>maven <strong class="ni ir">{ </strong>url 'https://jitpack.io' <strong class="ni ir">}<br/>    }<br/>}</strong></span></pre><p id="8f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且，向您的项目级<code class="fe nf ng nh ni b">build.gradle</code>添加下面的代码，并用您想要的版本的标签替换version(v1.0)。您可以在存储库的release部分找到release标签。</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="9f32" class="nn no iq ni b gy np nq l nr ns">dependencies <strong class="ni ir">{<br/>    </strong>implementation 'com.github.microsoft:snippet-timekeeper:v1.0'<br/><strong class="ni ir">}</strong></span></pre><p id="c92c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置起来超级简单。如果您希望您的库只在调试版本中进行测量，那么在<code class="fe nf ng nh ni b">Snippet.install(executionPath)</code> <em class="mj">中安装一个<code class="fe nf ng nh ni b">MeasuredExecutionPath</code>的实例。</em>所有其他构建类型(除非指定)将使用默认的<code class="fe nf ng nh ni b">ReleaseExecutionPath</code>，即无操作路径。建议尽快这样做，以确保您可以在早期执行中使用Snippet。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0bd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过上面的设置，您的库代码将不会在发布版本中运行。一切都将在调试和发布版本库成为无操作。</p><p id="f80d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在到了我们进行测量的部分。</p><p id="cb46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设你有一个需要测量的序列代码，你可以直接把它作为一个lambda传递，如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Snippet.capture的演示(闭包)</p></figure><p id="e46c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要这样做，度量就会捕获调用的上下文，并将所有细节打印在logcat上。</p><p id="0dc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我想测量应用程序的启动时间，直到<code class="fe nf ng nh ni b">onStart()</code>回调触发——我必须在应用程序类中开始测量，并且必须在活动类中结束测量。通过我们上面讨论的lambda方法是不可能的。所以我们有一个叫做<code class="fe nf ng nh ni b">LogToken</code>的东西来处理这个问题(稍后会详细介绍)。</p><p id="0f3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以标记测量，标记需要是唯一的。</p><ol class=""><li id="24a0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">只要用标签开始测量，</li><li id="7c45" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">从代码库中任何位置找到标签，并结束测量。</li></ol><p id="a2e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看实际情况。我们从第12行开始测量。然后我们将找到标签并结束测量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在应用程序类中开始基于标签的测量</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">结束活动类中基于标签的测量</p></figure><p id="fb7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果您正在思考如果在热启动情况下没有发生测量<code class="fe nf ng nh ni b">Snippet.startCapture(tag)</code>调用会发生什么，并且当活动启动时它调用<code class="fe nf ng nh ni b">Snippet.find(tag).endCapture()</code>。会崩溃吗？它会显示垃圾数据吗？</p><p id="5fae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案是否定的。</p><p id="ca4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Snippet明白在Android中，这些事情可能会发生，即使在正确的用户场景下，<code class="fe nf ng nh ni b">end()</code>也可以被调用而<code class="fe nf ng nh ni b">start()</code>不会被调用。这就是为什么它在内部使所有这样的调用无效。它不会做任何事情。</p><p id="5b20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种基于标记的API还可以用来标记您的业务用例，如登录、用户数据同步等，您可以扩展MeasuredExecutionPath来将这些数据记录到文件或数据库中，并可以从中构建性能门来检测回归。如果一个新的代码将被添加到那个路径中，你会知道的。请检查repo并查看如何扩展ExecutionPath。</p><h1 id="f5ca" class="nv no iq bd nw nx ny nz oa ob oc od oe jw of jx og jz oh ka oi kc oj kd ok ol bi translated">日志令牌</h1><p id="a499" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">当我们有时进行度量时，代码并不像在处理回调函数时那样是连续的，在回调函数中我们有嵌套的回调函数。我们不能把所有东西都当作lambda来传递。</p><p id="9a44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当您调用<code class="fe nf ng nh ni b">Snippet.startCapture()</code>时，它会返回一个表示测量值的日志令牌。当您想要结束测量时，可以在其上调用<code class="fe nf ng nh ni b">endCapture</code>方法。</p><p id="9990" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API也在内部处理日志标记。<code class="fe nf ng nh ni b">LogToken</code>很有用，因为在多线程的情况下，标签不会工作，因为每个标签都与一个日志标记相关联。如果您正在启动n个并行操作，您需要使用单独的日志标记来跟踪每个操作。这时，您需要直接使用日志标记。</p><p id="a4a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的例子并不完美，但足以展示API是如何工作的。</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="b70e" class="nn no iq ni b gy np nq l nr ns">override fun loadNewsFeed() {<br/>   <strong class="ni ir"> val token = Snippet.startCapture()</strong><br/>    disposables.add(repository.getNewsFeedSingle()<br/>        .compose(schedulerProvider.ioToMainSingleScheduler())<br/><br/>        .doOnSubscribe <strong class="ni ir">{ </strong>liveNewsFeed.<em class="mj">value </em>= NewsFeedActivityViewModel.Response(<em class="mj">LOADING</em>,null) <strong class="ni ir">}<br/>        </strong>.doOnError <strong class="ni ir">{ </strong>liveNewsFeed.<em class="mj">value </em>= NewsFeedActivityViewModel.Response(<em class="mj">ERROR</em>, null) <strong class="ni ir">}<br/><br/>        </strong>.map <strong class="ni ir">{ </strong>feedListFromRepo <strong class="ni ir">-&gt; </strong>mapNewsFeedToUIState(feedListFromRepo) <strong class="ni ir">}<br/>        </strong>.subscribe <strong class="ni ir">{ </strong>listOfFeeds, throwable <strong class="ni ir">-&gt;<br/>            </strong>if (listOfFeeds != null) {<br/>                liveNewsFeed.<em class="mj">value </em>= NewsFeedActivityViewModel.Response(<em class="mj">SUCCESS</em>, listOfFeeds)<br/>               <strong class="ni ir"> token.endCapture();</strong><br/>            }<br/>            if (throwable != null) {<br/>                Timber.e("Not able to load feeds. Possible Cause: $throwable")<br/>            }<br/>        <strong class="ni ir">}</strong>)<br/>}</span></pre><h1 id="f775" class="nv no iq bd nw nx ny nz oa ob oc od oe jw of jx og jz oh ka oi kc oj kd ok ol bi translated">执行路径</h1><p id="8991" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">如果您需要在Snippet的基础上进行定制工作，您可以扩展该功能。它在存储库自述文件中用一个示例进行了详细演示。</p><h1 id="4f74" class="nv no iq bd nw nx ny nz oa ob oc od oe jw of jx og jz oh ka oi kc oj kd ok ol bi translated">分裂</h1><p id="c222" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">有时，我们还需要深入了解在<code class="fe nf ng nh ni b">start()</code>和<code class="fe nf ng nh ni b">end()</code>捕获之间发生了什么。</p><p id="62a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为该代码片段具有可以测量捕获中的小部分的分割。只需获得日志令牌并在其上调用<code class="fe nf ng nh ni b">addSplit()</code>。它将测量从上次调用<code class="fe nf ng nh ni b">addSplit()</code>到现在所经过的时间。</p><p id="fde5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe nf ng nh ni b">endCapture()</code>结束计算后，它还会显示一个分割汇总，以显示测量值的鸟瞰图，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/71bddf70a45ffa910459337971192810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*apc9yTgTdPPZhWpN5k7SuA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拆分摘要。</p></figure><p id="26cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Snippet中还有其他的特性，但是我们会在其他的帖子中讨论。</p></div></div>    
</body>
</html>