<html>
<head>
<title>Why Are JavaScript Arrow Functions Useful?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript箭头函数为什么有用？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-javascript-arrow-functions-are-useful-aa023bad403a?source=collection_archive---------8-----------------------#2020-02-26">https://betterprogramming.pub/why-javascript-arrow-functions-are-useful-aa023bad403a?source=collection_archive---------8-----------------------#2020-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们应该什么时候使用它们？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b908e74dda70dab100147c0c9ee1108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A58tj0JoKxrmNf_NUN1OtA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@steinart?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Steinar Engeland </a>在<a class="ae ky" href="https://unsplash.com/s/photos/arrow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="db57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从ES6开始，有两种类型的通用函数。一个是用<code class="fe lv lw lx ly b">function</code>关键字声明的传统函数。另一个是ES6引入的较新的箭头功能。</p><p id="3683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看看为什么箭头函数是有用的，以及何时应该使用它们。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6a07" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">定义箭头函数</h1><p id="196e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">箭头函数是带有粗箭头的函数。例如，我们可以将它们声明如下:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ea93" class="nh mh it ly b gy ni nj l nk nl">const fn = () =&gt; 'foo';</span></pre><p id="1b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将定义<code class="fe lv lw lx ly b">fn</code>函数并返回字符串<code class="fe lv lw lx ly b">'foo'</code>。</p><p id="b41d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多行函数可以写成如下形式:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c72a" class="nh mh it ly b gy ni nj l nk nl">const add = (a, b) =&gt; {<br/>  return a + b;<br/>}</span></pre><p id="1e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将两个数相加。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1620" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">句法糖</h1><p id="faad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">箭头函数的语法没有传统函数那么冗长。从上面的第一个例子可以看出，我们可以在一行中定义函数。如果函数只有一行，返回是隐式的。</p><p id="aab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们不必一直写<code class="fe lv lw lx ly b">function</code>关键字来声明函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3e62" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们不必担心‘这个’</h1><p id="e1d5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">它没有自己的<code class="fe lv lw lx ly b">this</code>。这意味着我们不用担心它里面的<code class="fe lv lw lx ly b">this</code>的值。</p><p id="bcb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在大多数情况下是件好事，除非我们想写类方法或构造函数方法。在所有其他情况下，如果我们使用箭头函数而不是函数，我们真的不在乎<code class="fe lv lw lx ly b">this</code>。</p><p id="1bea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样对于传统函数，如果我们想在内部函数中访问外部函数内部的<code class="fe lv lw lx ly b">this</code>的值，我们必须如下访问该值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1e46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们想从<code class="fe lv lw lx ly b">foobar</code>函数中访问<code class="fe lv lw lx ly b">this.bar</code>。我们必须写下来:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="cd0d" class="nh mh it ly b gy ni nj l nk nl">var that = this;</span></pre><p id="4ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而在<code class="fe lv lw lx ly b">foobar</code>函数中，我们写道:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="20cc" class="nh mh it ly b gy ni nj l nk nl">console.log(that.bar);</span></pre><p id="1d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种痛苦，很容易忘记。</p><p id="d91f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用箭头函数，我们可以删除两行，写出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这要好得多，因为我们需要编写更少的代码，并且我们不必担心arrow函数中<code class="fe lv lw lx ly b">this</code>的值。</p><p id="b9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们不能使用<code class="fe lv lw lx ly b">bind</code>、<code class="fe lv lw lx ly b">apply</code>或<code class="fe lv lw lx ly b">call</code>来改变箭头函数中<code class="fe lv lw lx ly b">this</code>的值，因为<code class="fe lv lw lx ly b">this</code>不能在箭头函数中改变。</p><p id="e338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于不使用<code class="fe lv lw lx ly b">this</code>的函数来说，这是一个很好的特性，因为消除了很多混淆。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/76e8a6b81e866fb9eccaea8b93439c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zpoqpB3D0KrIGzJ9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@agmakonts?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adam Grabek </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e831" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">提升和函数声明与表达式</h1><p id="cd9c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在JavaScript中有两种方法定义传统函数。</p><p id="d5b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个是函数声明，一个是函数表达式。函数声明在任何代码运行之前加载，而函数表达式在JavaScript解释器加载代码时加载。</p><p id="937e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个函数声明的示例:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8c31" class="nh mh it ly b gy ni nj l nk nl">function foo() {<br/>  return 1;<br/>}</span></pre><p id="9441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个函数表达式的示例:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="448c" class="nh mh it ly b gy ni nj l nk nl">const foo = function() {<br/>  return 1;<br/>}</span></pre><p id="ae8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为函数声明是在其他任何东西运行之前加载的，所以可以在代码文件的任何部分用函数声明引用它们。这叫做<em class="np">吊装</em>。</p><p id="4e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在定义函数的代码运行之前，函数表达式不可用。</p><p id="75d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种差异经常被忽视，很容易引起混淆。我们可以通过使用箭头函数来消除这种混乱，因为我们不必担心提升、函数声明和函数表达式。</p><p id="acd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于箭头函数，我们只能像上面那样定义函数，而且在声明之前它是不可用的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="63dd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参数对象</h1><p id="0ac7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">箭头函数没有自己的<code class="fe lv lw lx ly b">arguments</code>对象。<code class="fe lv lw lx ly b">arguments</code>对象是一个类似数组的对象，拥有我们传递给函数调用的所有参数。</p><p id="e3d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">arguments</code>是一个类似数组的对象，所以它有索引、访问其条目的括号符号和<code class="fe lv lw lx ly b">length</code>属性。而且，我们可以用<code class="fe lv lw lx ly b">for</code>循环遍历这些条目，但是除此之外，它一点也不像数组。</p><p id="ce38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个混乱的来源，因为它有点像数组，但不是真正的数组。对于箭头函数，我们可以使用rest参数来代替，这确实给了我们一个数组。</p><p id="d8c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="60b8" class="nh mh it ly b gy ni nj l nk nl">const foo = (...args) =&gt; {<br/>  return args;<br/>}</span></pre><p id="4b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么当我们如下调用<code class="fe lv lw lx ly b">foo</code>时:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a319" class="nh mh it ly b gy ni nj l nk nl">foo(1, 2, 3, 4, 5)</span></pre><p id="fd14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="04c0" class="nh mh it ly b gy ni nj l nk nl">[1, 2, 3, 4, 5]</span></pre><p id="acf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个实数组，所以我们可以使用数组方法和扩展操作符。这比在arrow函数和rest操作符出现之前，我们不得不使用令人困惑的<code class="fe lv lw lx ly b">arguments</code>对象来获取动态参数值要好得多。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="472e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="f400" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">正如我们所见，箭头函数非常有用，除了作为类方法或构造函数方法使用。通过<code class="fe lv lw lx ly b">this</code>、提升、函数声明与表达式等等，消除了许多混淆。</p><p id="ae6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，从语法上来说，它要干净得多，因为我们不必使用<code class="fe lv lw lx ly b">function</code>关键字来声明函数，并且return隐含在一行函数中。</p><p id="bbc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们不必再对<code class="fe lv lw lx ly b">arguments</code>对象感到困惑，因为<code class="fe lv lw lx ly b">arguments</code>不会绑定到箭头函数。</p></div></div>    
</body>
</html>