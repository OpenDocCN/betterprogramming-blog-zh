<html>
<head>
<title>Build Better Serverless APIs By Going Storage First</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从存储开始，构建更好的无服务器API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-better-serverless-apis-by-going-storage-first-597784f8f399?source=collection_archive---------6-----------------------#2022-03-24">https://betterprogramming.pub/build-better-serverless-apis-by-going-storage-first-597784f8f399?source=collection_archive---------6-----------------------#2022-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8c79" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">谈到API设计，Serverless提供了许多选项。存储优先是一种正在改变游戏规则的异步模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fa25069947780acebc834b217b046c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHfcrjxwpdJPzMa9y0kZHA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@melodi2?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Lia Trevarthen </a>在<a class="ae ky" href="https://unsplash.com/s/photos/storage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，我的团队进行了一场激烈的辩论。他们在谈论VTL 专用于原料药的<a class="ae ky" href="https://www.andmore.dev/blog/build-serverless-api-with-no-lambda/" rel="noopener ugc nofollow" target="_blank">用法。</a></p><p id="f291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">争论的一方认为它能使你的API获得最快的响应时间。另一方认为，如果集成中出现错误，几乎不可能排除故障。数据丢失了，您被迫依赖于<a class="ae ky" href="https://www.alexdebrie.com/posts/api-gateway-access-logs/" rel="noopener ugc nofollow" target="_blank"> API网关日志</a>(这有点像寻宝一样的设置)。</p><p id="3c1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双方都提出了很好的论点。但总得有个折中的办法。您希望尽可能低的API延迟，但是您绝对不希望丢失任何数据。</p><p id="a1d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息，<em class="lv">有妥协</em>。</p><p id="6ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.twitter.com/edjgeek" rel="noopener ugc nofollow" target="_blank">埃里克·约翰逊</a>多年来一直是<em class="lv">存储优先</em>模式的倡导者。<a class="ae ky" href="https://www.youtube.com/watch?v=eyjxZK-YHIk" rel="noopener ugc nofollow" target="_blank">存储优先</a>指的是一组无服务器设计模式，在运行计算之前将您的数据放在某个地方。这样，如果出现问题，您可以重试或发送到死信队列，以便将来进行手动处理。</p><p id="7719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2022年是<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/and-the-2022-word-of-the-year-for-programmers-is-3605dc1bd698">异步</a>年。通过在我们的应用程序中采用异步架构和模式，我们正把注意力放在开发更快、更可靠、等幂的API上。通过首先进行存储，我们朝着这个方向迈出了一大步。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ff04" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">从直接扑救开始</h1><p id="5c0f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">存储优先模式的第一步是将传入数据保存到一个持久位置。有了AWS，有<a class="ae ky" href="https://aws.amazon.com/blogs/compute/building-storage-first-applications-with-http-apis-service-integrations/" rel="noopener ugc nofollow" target="_blank">许多选项可以从</a>中选择。你可以直接去DynamoDB，亚马逊Kinesis，SQS，甚至EventBridge。这些服务中的每一个都可以保留一个传入事件的记录，因此如果出现问题，您可以重放它。</p><p id="04c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们今天的例子是直接保存到DynamoDB。该保存将触发一个<a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html" rel="noopener ugc nofollow" target="_blank">流</a>，该流将启动一个步进功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/c3c0bf1be14c54f3f79812cee07aa78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eMr4ZF2pyMNflkQN.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nb">使用DynamoDB的存储优先工作流</em></p></figure><p id="b776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过访问DynamoDB，我们知道我们的数据不会丢失。它通过直接从API网关代理到Dynamo，直接进入存储。不幸的是，这确实使用了VTL，但只是一点点。一旦HTTP APIs支持与Dynamo的直接集成，那将彻底消除VTL。</p><p id="972f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依靠流，我们为自己提供了一个缓冲。我们可以通过<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-dynamodb-api" rel="noopener ugc nofollow" target="_blank">事件源映射</a>控制批处理大小、等待时间以及如何处理错误，这允许我们微调高吞吐量端点所需的任何节流。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5e64" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">用作业处理数据</h1><p id="1b3f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">作业是一种简单的说法<em class="lv">异步流程</em>。它在后台运行，进行一些处理，并在完成时返回一个结果。</p><p id="9a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们想要为我们的API所做的。当我们直接保存到Dynamo时，我们希望保存工作参数。DynamoDB流将识别一个新作业，并将其发送给Step函数。</p><p id="01a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不喜欢只提供理论而不实践。所以我修改了我的<a class="ae ky" href="https://github.com/allenheltondev/gopher-holes-unlimited" rel="noopener ugc nofollow" target="_blank"> Gopher Holes Unlimited应用程序</a>来展示如何设置和处理作业的细节。</p><p id="5f1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个repo中，当我们将一个gopher添加到系统中时，我们创建一个作业来添加gopher，在相同的位置搜索gopher漏洞，并自动链接它们。</p><p id="e650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作业应该代表创建或处理数据的工作。不是数据本身。如果我查找某个作业的详细信息，我希望看到作业状态、元数据(如作业的创建时间)、输入和最终结果(成功/失败)。</p><p id="28ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们挑选新任务的状态机必须知道如何处理不同状态下的任务，以解决等幂问题。从<a class="ae ky" href="https://github.com/allenheltondev/gopher-holes-unlimited/blob/master/state-machines/add-gopher/add-gopher.asl.json" rel="noopener ugc nofollow" target="_blank"> add-gopher状态机</a>中取出以下流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/4e657f09305005d51094e6201873cb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9FjmsFQGftz6q4hb.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nb">通过Step函数直接sdk集成处理作业</em></p></figure><p id="cd11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过首先保存我们的工作信息，我们立即提供了获取工作状态的能力。在等待DynamoDB流处理新输入时，我们将作业细节保存在一个<code class="fe nd ne nf ng b">Pending</code>状态。</p><p id="8f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态机完全了解各种作业状态，并知道如何做出相应的响应和更新。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c93e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">在API中返回正确的数据</h1><p id="e68c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">通过首先移动存储，您承诺将API响应返回给调用者，而不处理他们的数据。您可以运行的唯一一种验证是通过您的<a class="ae ky" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank">开放API规范</a>进行的<a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html" rel="noopener ugc nofollow" target="_blank">模式验证</a>。</p><p id="9920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们将原始输入保存为一个新的作业，我们就可以返回一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202" rel="noopener ugc nofollow" target="_blank"> 202 Accepted </a>状态代码以及下面的有效负载来通知调用者作业已经保存，并给他们一个检查进度的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/4fb87a86195a2316efc1d0f41454b97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ONvaPdRh_ICHDiQM.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nb">来自我们存储第一端点的有效负载和响应</em></p></figure><p id="c9f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应提供了一个作业标识符，我们也将其用作gopher标识符。它还提供了到一个端点的链接，该端点可以获取我们的作业状态。</p><p id="19a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用者可以使用该端点来轮询和获取我们长期运行的作业的状态。这类似于AWS SDK如何处理大型API调用，如<a class="ae ky" href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-rekognition/classes/starttextdetectioncommand.html" rel="noopener ugc nofollow" target="_blank"> StartTextDetection </a>和<a class="ae ky" href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-rekognition/classes/gettextdetectioncommand.html" rel="noopener ugc nofollow" target="_blank"> GetTextDetection </a>命令。</p><p id="ea14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们调用响应中的链接，我们可以获得关于我们刚刚排队的作业状态的即时反馈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/eb0633dfc0a3b388cc1769de60cfcf51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5Gmp9pz9fU3P_ekB.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nb">我们刚刚排队的作业的挂起状态</em></p></figure><p id="7516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦作业完成，终端用户将能够调用<code class="fe nd ne nf ng b">GET gopher</code>端点来加载通过这个异步过程创建的gopher的详细信息。</p><p id="7a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这项工作中，我们需要进行两种状态更新:<strong class="lb iu">工作状态</strong>和<strong class="lb iu">工作进度</strong>。</p><p id="603e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">作业状态</em>更新是作业当前所处生命周期的高级表示。这些状态包括<em class="lv">未决</em>、<em class="lv">进行中</em>、<em class="lv">失败</em>和<em class="lv">成功</em>。状态机负责在处理过程中更新<em class="lv">作业状态</em>。</p><p id="11d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于长时间运行的作业，通知用户正在进行某项操作是非常有用的。没有人喜欢坐着等待，希望工作完成。为此，我们通过在WebSocket教程中创建的<a class="ae ky" href="https://github.com/allenheltondev/serverless-websockets" rel="noopener ugc nofollow" target="_blank"> WebSocket微服务</a>提供推送通知。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/9510edd31330187b3e43c40d9056e347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wOwyJMd1f-3F0WYW.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nb">带有推送通知的工作流程图</em></p></figure><p id="3a92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过提供推送通知，我们让用户知道正在发生的事情。随着流程的完成，他们可以在粒度级别上一窥究竟。您所需要做的就是在状态机中包含一个EventBridge推送通知。你可以在上图中看到，我们在处理<code class="fe nd ne nf ng b">add-gopher</code>作业时向用户发送了三种不同的推送。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1304" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="0ca1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">无服务器API的存储优先方法有几个移动部分:</p><ul class=""><li id="5522" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">直接保存到持久存储服务(如DynamoDB、SQS、EventBridge或Kinesis)</li><li id="030b" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">工作创造和工作流程管理</li><li id="8f88" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">API更新以返回一个<em class="lv">已接受的</em>状态代码和<em class="lv">发现</em>链接</li><li id="717b" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">状态更新</li></ul><p id="7c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从表面上看，这比做所有事情的同步lambda调用开销要大得多。从表面上看，这是正确的。但是存储优先和异步有很多好处。</p><ul class=""><li id="c2c7" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">更快的响应时间</li><li id="fc00" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">用户未被阻止等待响应</li><li id="3fb5" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">作业完成后，用户会立即收到通知</li><li id="0328" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">云成本下降是因为你不用为长时间运行的lambda函数付费</li><li id="c009" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">数据可追溯性飙升，因为你总是有数据的记录</li></ul><p id="f97f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建产品代码时，这是显而易见的。如果你正在建立一个<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/4-reasons-you-should-never-use-proof-of-concepts-in-production-ca54432e52b9">快速和肮脏的概念验证</a>，权衡你的选择。看着它更快地工作可能比看着它“正确”地工作更有成效。</p><p id="1695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储优先正在席卷无服务器世界。随着我们作为一个社区的成熟，可观察性和可追溯性越来越成为一等公民，需要在你的设计中提前考虑。从一开始就保存数据有助于确保您永远不会丢失那些无用的数据。</p><p id="a800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>