<html>
<head>
<title>Build Your Own Blog App With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI构建您自己的博客应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-own-blog-app-with-swiftui-3ee8196ecb84?source=collection_archive---------3-----------------------#2021-09-14">https://betterprogramming.pub/build-your-own-blog-app-with-swiftui-3ee8196ecb84?source=collection_archive---------3-----------------------#2021-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f4e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用SwiftUI和Contentful快速创建一个简单的博客应用程序，并提供可靠的内容管理系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6725f2da14355a5d83e8953adf46c709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E25Uu4nSfCB3jQUome0U2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="5621" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常情况下，新技术给应用程序开发领域带来了更多的复杂性，使得外部受众更难理解编码。</p><p id="cdfc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用SwiftUI，情况通常相反——该框架使得从零开始快速构建全面的应用程序或使用编码迭代设计思想变得难以置信的容易。</p><p id="33e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了展示在复杂的项目中使用SwiftUI是多么简单，我构建并开源了一个博客应用程序，它使用内容管理系统来交付帖子，并支持许多设计功能，如黑暗模式和辅助功能。</p><h1 id="a6ff" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">先决条件</h1><p id="7225" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了启动项目，需要采取以下步骤:</p><ul class=""><li id="c72e" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">下载Xcode 12+。</li><li id="5f4c" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">创建新的SwiftUI项目。</li><li id="f74d" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">在项目设置中选择14.0或更高版本的iOS部署目标。</li></ul><h2 id="57dc" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">GitHub知识库</h2><p id="95f2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">您可以通过从GitHub下载完成的项目来跟进。</p><h1 id="560f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">为内容管理设置内容</h1><p id="3dbb" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">第一步是在内容管理系统(CMS)上建立您的模型。这个模型将定义一旦你建立了应用程序，它到底会发布什么。在我们的例子中，由于我们正在创建一个博客应用程序，我们需要为一篇博客文章创建一个模型——标题、副标题、文本等。</p><p id="ffb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于CMS，我们将使用<a class="ae nr" href="https://www.contentful.com" rel="noopener ugc nofollow" target="_blank"> Contentful </a>，因为它有一个慷慨的免费层，并且特别与Swift和SwiftUI集成良好。</p><p id="bfb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建帐户后的第一步是为我们的博客文章创建内容模型。为此，转到内容模型→添加内容类型，并为模型选择一个名称。我们将使用API标识符为SwiftBlog的swiftBlog。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/31333662bf29e2d1e9e9f5929cc28315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjRfUyQVzhzy530pbpsfKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="b995" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是向内容模型添加所有必需的字段:添加字段→选择类型和名称→创建。下面您可以找到我们将使用的所有字段的列表，但是可以根据您的需要随意定制。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/8bb05bea5151fedf9e245b628c70fad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Ws6X8TEsIcYKoYsCgPfnA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="942e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这一步，我们还可以创建几个帖子来简化未来应用程序的调试。要创建帖子，您可以进入内容→添加SwiftBlog，并创建一个带有标题、副标题、图片和文本的帖子。我们可以暂时将<em class="nu">特色的</em>字段留空，等我们开始开发应用程序的相应部分时再回来。</p><h1 id="15da" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">构建应用程序</h1><p id="0861" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">一旦Contentful设置好了，就该创建实际的应用程序了。在我们开始有趣的东西之前，我们需要连接几个必要的库。</p><p id="b7fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最重要的是，我们需要从Swift包管理器添加<code class="fe nv nw nx ny b">Contentful</code>和<code class="fe nv nw nx ny b">SDWebImageSwiftUI</code>。如果你不确定它是如何做到的，进入文件→添加包，搜索上面的两个名字。或者，将这些GitHub目录用于<a class="ae nr" href="https://github.com/contentful/contentful.swift.git" rel="noopener ugc nofollow" target="_blank"> Contentful </a>和<a class="ae nr" href="https://github.com/SDWebImage/SDWebImageSwiftUI.git" rel="noopener ugc nofollow" target="_blank"> SDWebImageSwiftUI </a>。一旦您添加了这些依赖项，Xcode将负责剩下的工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/3edf609065e19aac5e482993ef8453c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O78uZ8wdQl0M5KmckgJLaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="ab58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以开始实际应用了。</p><h2 id="8434" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">创建数据模型</h2><p id="8eea" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">现在我们继续为我们的博客文章创建数据模型。这个模型应该反映我们在Contentful上为内容模型设置的相同结构，这意味着我们将有一个标题、副标题、图像、实际文本(博客文章)和一个用于<em class="nu">特色</em>字段的布尔值。</p><p id="bcf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将<em class="nu">特性</em>设置为默认为假，除非我们另外指定。通过这样做，我们可以在Contentful的内容模型中使这个字段可选，并且只在我们想要真正展示一篇文章时才关心它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1e69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我们还通过添加一个UUID使<code class="fe nv nw nx ny b">BlogPost</code>结构符合<code class="fe nv nw nx ny b">Identifiable</code>协议。这是必要的，因为我们将在未来的视图模型中使用<code class="fe nv nw nx ny b">ForEach</code>语句。</p><h2 id="8b7d" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">建立内容丰富的连接</h2><p id="d6ac" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">接下来，我们将创建一个连接到CMS的逻辑。为此，您需要空间id和访问令牌。你可以在Contentful上的设置→ API键中得到这些。</p><p id="4116" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">空间id和访问令牌都应该被传递到一个<code class="fe nv nw nx ny b">Client</code>实例中(是<code class="fe nv nw nx ny b">Contentful</code>库的一部分)，然后在一个函数中使用它来获取我们的博客文章数组。您还可以使用以下代码对任何字段返回的列表进行排序:</p><pre class="kj kk kl km gt oc ny od oe aw of bi"><span id="ff26" class="nf lv it ny b gy og oh l oi oj">try! query.order(by: Ordering(sys: .createdAt, inReverse: <strong class="ny iu">true</strong>))</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="3ca9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们只需要创建一个<code class="fe nv nw nx ny b">BlogPostStore</code>可观察类，并使用<code class="fe nv nw nx ny b">getArray</code>函数来填充博客文章列表。因为我们对我们的博客文章使用了<code class="fe nv nw nx ny b">@Published</code>属性包装器，所以我们以后所有显示博客文章列表的视图都会在我们刷新列表时自动重画。换句话说，当我们发布一个新帖子，用户刷新列表时，新内容将直接出现在我们的视图中。</p><p id="927f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个重要的注意事项是，我们将图像转换为URL，这就是为什么我们需要在开始时导入<code class="fe nv nw nx ny b">SDWebImageSwiftUI</code>库。该库将允许我们使用<code class="fe nv nw nx ny b">WebImage</code>类显示来自这个URL的图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="95d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我们CMS集成的后端部分！剩下的工作就是设计我们的应用程序。</p><h1 id="61ae" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">设计应用程序</h1><p id="d772" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">对于我们的博客应用程序，我们将构建两个屏幕(包含几篇特色文章的主屏幕和包含所有文章的列表)和三个组件(主屏幕的博客明信片、列表的博客文章行和实际的博客文章视图)。</p><h2 id="6295" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">为主屏幕创建卡片设计</h2><p id="193e" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">使用所有标准组件，如垂直和水平堆栈和文本，在SwiftUI中设计卡片相当容易。这里唯一的小麻烦是呈现来自我们CMS的网络图像，正如前面提到的，我们通过使用<code class="fe nv nw nx ny b">SDWebImageSwiftUI</code>库来解决这个问题。</p><p id="94f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，由于Swift本身不支持颜色的十六进制值，我们将使用一个扩展来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="3d59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在谈谈卡片本身。这里我们要解决两件至关重要的事情。</p><p id="b4aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们将通过最小化卡片尺寸的硬编码值，使卡片尽可能适应屏幕尺寸。这一点通常很容易在SwiftUI中实现，无需做任何额外的事情(所有的<code class="fe nv nw nx ny b">VStack</code>和<code class="fe nv nw nx ny b">HStack</code>视图都会自动适应屏幕尺寸)，但当涉及到图像时，我们希望确保它们在任何屏幕尺寸上都好看。这就是为什么我们要将图像的高度固定为220像素，同时使用下面的代码来设置宽度:</p><pre class="kj kk kl km gt oc ny od oe aw of bi"><span id="33f5" class="nf lv it ny b gy og oh l oi oj">.frame(maxWidth: UIScreen.main.bounds.width — 80)</span></pre><p id="6230" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着我们将利用应用程序将在其上打开的设备的实际屏幕尺寸，采用屏幕的宽度，并使我们的图像比任何尺寸都小80像素。和SwiftUI一样，这不是实现适应性的唯一方法，但是对于我们特定的卡，这种方法效果最好。</p><p id="f552" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其次，卡片在黑暗模式下要好看。SwiftUI支持黑暗模式作为标准，但我们的工作仍然是确保所有的颜色在两种外观模式下看起来像样和干净。</p><p id="073f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有几种方法可以实现深色模式的配色方案，但由于我们在卡的应用程序中只需要一种自定义颜色，如果<code class="fe nv nw nx ny b">@Environment(\.colorScheme) <strong class="la iu">var</strong> colorScheme</code>值为<code class="fe nv nw nx ny b">.dark</code>，我们将只使用深灰色的实际十六进制值:</p><pre class="kj kk kl km gt oc ny od oe aw of bi"><span id="5b63" class="nf lv it ny b gy og oh l oi oj">.background(colorScheme == .dark ? Color(hex: “#121212”) : Color.white)</span></pre><p id="2b4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是我们主要博客明信片的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="aa85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是iPhone 12和iPhone 8的测试结果。请注意，该卡自动适应屏幕大小和外观模式，看起来都很好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/9731fb0f9c55b617a0ead88fb309f54c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CmiaIivtXicnV1_MIAceng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><h2 id="169a" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">设计列表行</h2><p id="bc20" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">对于所有博客文章的列表，我们需要设计每行的外观。在这里，我们将借用主卡中的大部分代码，但是由于这个视图将被用作列表中的一行，我们不需要阴影或不同的颜色方案用于黑暗模式，这使得事情变得更加容易。</p><p id="a391" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们为每篇博客文章的列表行使用的最终代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e144" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是每一行的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/94595914dc200823a9664e83935b089a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWZBdghAlF5aoSiOrCFzww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><h2 id="fb28" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">创建博客文章详细视图</h2><p id="7ee4" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">下一步是设计我们的博客文章打开时的样子。这里，我们再次没有做任何特别的事情:我们只是在一个垂直堆栈上排列一个图像、标题和文本，并用一个<code class="fe nv nw nx ny b">ScrollView</code>包装它。像往常一样，SwiftUI将负责可访问性和黑暗模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d41c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下图中，你可以看到当我们打开帖子时，里面会是什么样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/0e42f943fc76e90d7612e34b670aa9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZihn8gBzaQh50UYHQ88Ig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><h2 id="5cbf" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">创建最终屏幕</h2><p id="8184" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">现在我们已经创建了我们的主要组件，我们可以在最终的屏幕上以我们想要的方式排列它们。在我们的应用程序中，我们将只有两个标签——<em class="nu">主页</em>，其中有几篇特色文章和最新文章，以及<em class="nu">查看所有文章</em>，其中我们将有所有博客文章的列表。</p><p id="a866" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">后者很容易成为SwiftUI简单性的生动展示。既然我们已经有了博客文章的存储和在列表中显示它们的组件，剩下要做的就是创建一个带有<code class="fe nv nw nx ny b">List</code>的<code class="fe nv nw nx ny b">NavigationView</code>，使用<code class="fe nv nw nx ny b">ForEach</code>语句显示博客文章。请注意，我们不需要做任何额外的工作来使列表适应屏幕大小或外观模式——swift ui做了所有的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="97cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在到主屏幕。主屏幕有两部分——一部分是特色文章，另一部分是最新文章。后者相当简单，不值得太多关注——我们只是对之前制作的卡片使用一个水平的<code class="fe nv nw nx ny b">ScrollView</code>,并将ForEach语句中的帖子数量限制为我们想要的数量。你可以在repo <a class="ae nr" href="https://github.com/roman-luzgin/BlogAppSwiftUI/blob/main/BlogApp/MainView.swift" rel="noopener ugc nofollow" target="_blank">这里</a>找到这个视图的完整代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5535" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至于特色帖子，这是我们最终将使用我们在Contentful中添加到内容模型中的<em class="nu">特色</em>布尔字段的地方。要仅检索特色帖子，我们可以使用一个计算属性，在该属性中我们过滤所有帖子，只返回那些将<em class="nu">特色</em>字段设置为<code class="fe nv nw nx ny b">true</code>的帖子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="387f" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">用选项卡视图排列屏幕</h2><p id="9da5" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">最后一步是用一个<code class="fe nv nw nx ny b">TabView</code>来排列<code class="fe nv nw nx ny b">ContentView</code>文件中的两个屏幕，并为博客文章存储创建一个@StateObject，以便在所有子视图中使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="7b4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就这样，现在我们的应用程序可以使用了！</p><h1 id="bab0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="bbe6" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">按照上面的步骤，我们能够很快创建一个带有内容管理系统的博客应用程序。这是我们的最终结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/4b626c1f526e144ddc3047b287d1d62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*8J4Z3DWelfjZM1BOaSW1sg.gif"/></div></figure><p id="511b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，SwiftUI使得创建具有复杂界面的应用程序变得非常容易，无需太多额外的工作就可以适应不同的屏幕和外观模式。</p><p id="702f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这个博客应用程序的例子，您还可以在现有应用程序中发布新内容，而无需重新发布应用程序本身，这对于显示不同的图像、文章或有用的提示来说是完美的。</p><p id="c4db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div></div>    
</body>
</html>