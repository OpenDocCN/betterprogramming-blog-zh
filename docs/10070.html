<html>
<head>
<title>A Deep Dive Into Idempotence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对幂等性的深入探究</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-idempotence-1a39393df7e6?source=collection_archive---------0-----------------------#2021-11-23">https://betterprogramming.pub/a-deep-dive-into-idempotence-1a39393df7e6?source=collection_archive---------0-----------------------#2021-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="217e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是幂等性，你如何正确使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8db691b4f9cfc328182e654eda0a30f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvQcYrdWbzCwXPNUsvX9oA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@bundo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">本多·金</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幂等性是一个既简单又难的话题。这里，我们从简单的单状态应用程序中的一个普通用例开始。然后我们将深入讨论构建具有多种状态的高度可靠系统的最复杂的用例。</p><h1 id="f3ec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是幂等性</h1><p id="2b52" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从<a class="ae ky" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">维基百科</a>开始:</p><blockquote class="ms mt mu"><p id="3289" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><em class="it">“幂等性是数学和计算机科学中某些运算的属性，它们可以多次应用，而不会改变最初应用后的结果。”</em></p></blockquote><p id="d75f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是“不改变结果”到底是什么意思呢？我认为有两种解释方式:</p><ol class=""><li id="af22" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">无论我提出多少次同样的请求，我都会得到同样的回应。</li><li id="9e46" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">无论我提出多少次同样的请求，我都不会改变系统的状态。</li></ol><p id="314f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种说法听起来很相似，从表面上看似乎都是正确的。不过，第二种说法更合适。我们将在接下来的章节中进一步讨论这一点。</p><h1 id="2ef2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">单态系统中的幂等性</h1><p id="9d6a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们考虑一个非常简单的系统，在一个数据库上运行一个服务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/8d8d389e767d5b18c673413d28fa5036.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*KvGwcyROmqGid75HxQWeaA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="4eb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该数据库跟踪用户帐户。每个帐户都有两个属性:<code class="fe no np nq nr b">UserID</code>和<code class="fe no np nq nr b">Name</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/77a48d3abb421ca295f80632edc5269b.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*RqtGiSEsC-M_nc9XLme3lw.jpeg"/></div></figure><p id="d4ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设服务提供了四个基本的CRUD操作(创建、读取、更新和删除)。</p><p id="2cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些API定义如下:</p><pre class="kj kk kl km gt nt nr nu nv aw nw bi"><span id="410f" class="nx lw it nr b gy ny nz l oa ob">createUser(userId, name)<br/>readUser(userId) -&gt; User<br/>updateUser(userId, name)<br/>deleteUser(userId)</span></pre><p id="9dcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以读操作为例。普遍认为READ是幂等的。</p><p id="b1d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们发出一个读请求，遇到一个网络错误(即超时)，然后重试，我们不一定会得到与初始请求相同的响应。为什么？</p><p id="ce40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为系统的某个其他参与者可能已经改变了系统的状态。例如，<code class="fe no np nq nr b">updateUser</code>可能在第一次和第二次阅读之间被调用。</p><p id="78f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于创建操作，如果我们在<code class="fe no np nq nr b">createUser</code>请求期间遇到网络错误，那么系统的状态就变得不确定，就像<a class="ae ky" href="https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat" rel="noopener ugc nofollow" target="_blank">薛定谔的猫</a>一样。</p><p id="9f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果还没有创建记录，那么重试将触发数据库的正常插入。</p><p id="9102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果记录已经被创造了，那么事情就变得有趣了。我们应该如何回应客户？考虑以下两个选项:</p><ol class=""><li id="5778" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe no np nq nr b">Error: Your record {userId: 'yuchen123', name: 'Yuchen'} already exist</code></li><li id="2e2b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe no np nq nr b">Success: Your record {userId: 'yuchen123', name: 'Yuchen'} is created</code></li></ol><p id="d076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个选项都有效。从客户端的角度来看，返回相同的响应可能对用户更友好，因为客户端只关心创建操作的结果。</p><p id="eeaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，另一方面，我们也可以认为不同的响应提供了更多的透明度，表明先前的请求是成功的。让我们假设我们现在采用选项一。</p><h1 id="1ddb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有两个客户的案子</h1><p id="dcd7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果我们有两个客户端，并且它们都发出创建用户的相同请求:</p><pre class="kj kk kl km gt nt nr nu nv aw nw bi"><span id="4ebd" class="nx lw it nr b gy ny nz l oa ob">createUser(userId: 'yuchen123', name: 'Yuchen')</span></pre><p id="b652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设网络不稳定，客户端A和客户端B的请求都成功到达了服务器。然而，他们都没有得到答复。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/019ff32374edcefb78cb7aa1b5e0f138.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*6N6P5E4S5MYoHDnIPE8vFg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="cacf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过了一会儿，两个客户端都进行了重试，并且都收到了一条错误消息:</p><p id="97d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">Error: Your record {userId: 'yuchen123', name: 'Yuchen'} already exist</code></p><p id="8eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，对于当前的设置，我们没有办法知道两个客户端的初始请求中哪一个成功了。</p><p id="bc21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种常见的方法是引入一个<code class="fe no np nq nr b">idempotentKey</code>。有时也被称为<code class="fe no np nq nr b">idempotentToken</code>、<code class="fe no np nq nr b">requestId</code>、<code class="fe no np nq nr b">nonceToken</code>等。</p><p id="3aa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们将创建请求更改如下:</p><pre class="kj kk kl km gt nt nr nu nv aw nw bi"><span id="8041" class="nx lw it nr b gy ny nz l oa ob">createUser(userId, name, idempotentKey)</span></pre><p id="1d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自客户端A和客户端B的请求现在可能是不同的。</p><p id="08a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自客户端A:</p><pre class="kj kk kl km gt nt nr nu nv aw nw bi"><span id="99b7" class="nx lw it nr b gy ny nz l oa ob">createUser(<br/>  userId: 'yuchen123',<br/>  name: 'Yuchen',<br/>  idempotentKey: 'a2906959'<br/>)</span></pre><p id="0a34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自客户端B:</p><pre class="kj kk kl km gt nt nr nu nv aw nw bi"><span id="533a" class="nx lw it nr b gy ny nz l oa ob">createUser(<br/>  userId: 'yuchen123',<br/>  name: 'Yuchen',<br/>  idempotentKey: 'b54ed6d9'<br/>)</span></pre><p id="a21d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从服务器端来看，当将这个记录插入数据库时，我们还包含了新的列<code class="fe no np nq nr b">idempotentKey</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c7a3b0ea426f10bf59aea2c836ce19af.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*5NkmLxxi-08_ZcZN8aOgFA.png"/></div></figure><p id="c7c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当客户端重试时，它将使用来自其先前请求的相同的<code class="fe no np nq nr b">idempotentKey</code>。有了这个，我们就可以确定哪个客户端的请求更早成功了。</p><p id="d5d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们在数据库中看到一条记录，其中的<code class="fe no np nq nr b">idempotentKey</code>是<code class="fe no np nq nr b">a2906959</code>，那么我们可以向两个客户端返回以下内容。</p><p id="60e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对客户A的响应:<code class="fe no np nq nr b">Success: Your record {userId: 'yuchen123', name: 'Yuchen'} is created</code>。</p><p id="8889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对客户B的响应:<code class="fe no np nq nr b">Error: Your record {userId: 'yuchen123', name: 'Yuchen'} already exist</code>。</p><p id="a116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们使用短字符串作为<code class="fe no np nq nr b">idempotentKey</code>。实际上，它们可以是任何东西，只要它们是独一无二的。</p><h1 id="c2c1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在最多一次和至少一次之间进退两难</h1><p id="a9d5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">大规模分布式系统本质上是不可靠和不可预测的。服务器可能在任何给定的时间点崩溃。</p><p id="287f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前阵子我在博文<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/system-design-in-laymans-terms-design-a-coffee-shop-e1abb42dd123">系统设计中通俗易懂的描述了一个点咖啡的系统</a>。我在那里写道:</p><p id="d590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mv">……收银员在把便签贴在布告栏的同时，把交易记录在分类账薄上。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/46b80f1ec606f2f79737d37bea0d4276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6F6ZHb43UVXeGGAAmXbwfQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="b2c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但我没有解释他们如何同时做到这一点。如果收银员在给咖啡师的贴纸上写下订单，被一个电话分心，然后忘记在分类账上写下交易，会发生什么？</p><p id="b026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的情况在分布式消息队列中被广泛讨论。当消息队列中有新消息时，我们应该:</p><ol class=""><li id="6099" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">首先，确认我们收到了消息，然后处理它</li><li id="3d91" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">首先处理消息，只有在处理完成后才确认消息</li></ol><p id="b7d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在(1)和(2)之间选择将分别导致<strong class="lb iu">最多一次</strong>和<strong class="lb iu">至少一次</strong>的传送。</p><p id="fc1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种解决方案是使用原子提交协议，这在Martin Kleppmann所著的《设计数据密集型应用程序:可靠、可伸缩和可维护系统背后的重要思想》一书中有详细讨论:</p><blockquote class="ms mt mu"><p id="b8e0" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><em class="it">“如果消息传递或数据库事务失败，两者都被中止，因此消息代理可以稍后安全地重新传递消息。因此，通过自动提交消息及其处理的副作用，我们可以确保消息只被有效地处理一次，即使它在成功之前需要几次重试。中止会丢弃部分完成的事务的任何副作用。</em></p></blockquote><p id="9418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这在理论上听起来很优雅，但在实践中却极难实现。在下一节中，我们将研究解决这个问题的不同方法——幂等性。</p><h1 id="b4bd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">多态系统中的幂等性</h1><p id="87a7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个复杂的系统可以由许多组件组成。但从概念上讲，它们可以分为两类:</p><ul class=""><li id="12cf" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu oe nf ng nh bi translated">州</li><li id="8bb3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu oe nf ng nh bi translated">计算</li></ul><p id="b8ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算将改变一个物体的状态。它是可执行功能的一个小单元，通常也称为步骤或任务。</p><p id="36dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们关注状态，这样一个复杂的系统有时被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">状态机</a>。如果我们关注计算，它有时被称为<a class="ae ky" href="https://atscaleconference.com/2021/03/08/powering-developer-productivity/" rel="noopener ugc nofollow" target="_blank">工作流</a>。在学术上，这也被称为<a class="ae ky" href="https://microservices.io/patterns/data/saga.html" rel="noopener ugc nofollow" target="_blank">传奇设计模式</a>。</p><p id="3833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于系统可能在任何给定的时间点崩溃，为了使系统高度可靠，诀窍是使每个计算幂等，以便我们可以在失败的情况下重试它们。</p><p id="65d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用幂等的方法与我们在单态系统中讨论的方法没有什么不同——通过向请求添加一个<code class="fe no np nq nr b">idempotentKey</code>。在服务器端，我们将请求放入数据库，并立即向客户端发送一个确认消息，确认请求已收到。任何后续的重试请求都将被忽略，因为带有此<code class="fe no np nq nr b">idempotentKey</code>的请求已经存在于我们的系统中。</p><p id="f660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要指出的是，这个系统是异步的。我们有一个独立的工作人员来完成这个请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/53df3ab897e17268a4881de14060764f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*X6F_ze6nAONyOlSX1g2vfw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="66a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的系统变得高度可靠。工人可以在任何时候崩溃，它会没事的。</p><p id="4b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在一个电子商务应用程序中，工作人员在处理用户的信用卡时崩溃。我们应该将交易的状态从“待收费”更改为“已收费”由于工人去世，我们不知道我们是否已经成功地更改了用户的信用卡。我们该怎么办？一旦工作人员重新启动，我们只是尝试再次从用户的信用卡中收费。只要请求是等幂的，我们有信心不会扣除两倍的金额。</p><p id="6424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从客户端的角度来看，它可以轮询结果。或者，它也可以依靠一些单独的系统在请求完成后得到通知(例如，电子邮件、推送通知、分布式消息队列等)。).</p><p id="5aa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，在具有多个状态和计算的复杂系统中，使它们高度可靠的技巧是使请求幂等。</p><h1 id="1dd4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在幂等性很重要的地方</h1><p id="59fd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在可靠性上有这么大的好处，为什么我们不使所有的请求都幂等呢？</p><p id="a861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些请求显然可以受益于幂等性。比如我们上面提到的信用卡交易。事实上，大多数(如果不是全部)支付基础设施都支持等幂，比如来自<a class="ae ky" href="https://stripe.com/docs/api/idempotent_requests" rel="noopener ugc nofollow" target="_blank"> Stripe </a>或<a class="ae ky" href="https://developer.squareup.com/docs/working-with-apis/idempotency" rel="noopener ugc nofollow" target="_blank"> Square </a>的支付API。</p><p id="a209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是幂等也是贵的。它的实现更加复杂，并且还有额外的延迟问题。因此，某些服务成为幂等的可能没有意义。举个例子，</p><ul class=""><li id="71f5" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu oe nf ng nh bi translated">在日志系统中我们不需要幂等性。如果系统重新启动，复制日志消息是可以接受的。</li><li id="ffb4" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu oe nf ng nh bi translated">我们不希望在流媒体应用程序(如VoIP呼叫)或协作编辑工具(如GDoc)中出现等幂。在这些系统中，我们优先考虑可用性而不是一致性。</li></ul><p id="2486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如托马斯·索维尔曾经说过的:</p><blockquote class="ms mt mu"><p id="1724" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">“没有解决办法。只有取舍。你试图得到你能得到的最好的平衡。这就是你所能期待的一切。”</p></blockquote><p id="21c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他是在谈论经济学。但这同样适用于美国工程师。我们需要决定哪些操作是关键的，我们需要进行幂等运算，哪些操作不太关键，用最少一次或最多一次就足够了。</p><h1 id="d642" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束了</h1><p id="d3b1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">今天到此为止。这不是一个容易写的话题。如果你已经做到这一步，希望你也能享受等幂的美丽。一如既往，非常感谢阅读。工作中一定要用到幂等吗？你在建造什么？在实施过程中，你觉得最大的挑战是什么？我也很想收到你的来信！</p></div></div>    
</body>
</html>