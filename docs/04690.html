<html>
<head>
<title>Escaping and Non-Escaping Closures in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的转义和非转义闭包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/escaping-and-non-escaping-closures-in-swift-fe2866309599?source=collection_archive---------1-----------------------#2020-04-30">https://betterprogramming.pub/escaping-and-non-escaping-closures-in-swift-fe2866309599?source=collection_archive---------1-----------------------#2020-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3940" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有什么区别？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b70ca74b1c8fb837784ad207e99b9738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0p15_DW6zIhrOHREKDoNrw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由Y <a class="ae kv" href="https://unsplash.com/@yuiizaa" rel="noopener ugc nofollow" target="_blank"> uiizaa </a>在<a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="93d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">闭包是iOS开发的基石。任何在Swift中编写过异步网络获取请求的人一定都使用过用<code class="fe ls lt lu lv b">@escaping</code>表示的转义闭包，但是我们为什么要使用它呢？它是做什么的？如果不用会怎么样？这个就详细说一下吧。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="2700" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">什么是转义闭包？</h1><p id="60ab" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">这就是<a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html" rel="noopener ugc nofollow" target="_blank"> Swift文档</a>所述:</p><blockquote class="na nb nc"><p id="f1be" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">当闭包作为参数传递给函数，但在函数返回后被调用时，闭包被称为对函数进行转义</p></blockquote><p id="bc75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了成为一个转义闭包，闭包传递给的函数必须在闭包执行之前返回。</p><p id="eab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，听起来不错。这什么时候会发生？如果我们能发现这一点，我们就能明白为什么需要逃避。我们开始挖吧。</p><p id="d9ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们深入探讨之前，让我解释一下闭包是如何工作的，以使我们的基础知识变得清晰。看看下面的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/cacbbdd2b9ad36a2fa737542d9919265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPuXf-KxS9ecD4EmUZMPuA.png"/></div></div></figure><p id="6342" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类<code class="fe ls lt lu lv b">ClosureTesting</code>有一个函数<code class="fe ls lt lu lv b">getUser</code>。<code class="fe ls lt lu lv b">getUser</code>接受一个参数<code class="fe ls lt lu lv b">completion</code>，它是一个闭包，接受一个<code class="fe ls lt lu lv b">String</code>并返回<code class="fe ls lt lu lv b">Void</code>。在<code class="fe ls lt lu lv b">getUser</code>函数中，我们只是执行传入的闭包。</p><p id="fb69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们有了<code class="fe ls lt lu lv b">execute</code>函数，它用闭包调用<code class="fe ls lt lu lv b">getUser</code>函数，闭包打印传递给闭包的字符串。</p><p id="a5df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看看执行的流程。我们在<code class="fe ls lt lu lv b">ClosureTesting</code>类实例上调用<code class="fe ls lt lu lv b">execute</code>函数。<code class="fe ls lt lu lv b">execute</code>函数将依次调用带有闭包的<code class="fe ls lt lu lv b">getUser</code>函数。<code class="fe ls lt lu lv b">getUser</code>函数通过调用<code class="fe ls lt lu lv b">completion("kiran")</code>和<strong class="ky ir"> </strong>执行闭包，一旦闭包执行完成，函数返回。</p><p id="4981" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非转义闭包，因为函数<code class="fe ls lt lu lv b">getUser</code>在闭包执行后返回。我们怎样才能让它逃脱？函数返回后，一段代码如何执行？想一想…</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="5ecc" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">1.多线程</h1><p id="6738" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">实现它的一种方法是多线程。我们可以使用并发队列，让闭包在不同的线程上执行。这样，执行函数的线程将闭包的执行委托给另一个线程，函数返回。(如果你想刷新一下你的并发和线程知识，看看这篇<a class="ae kv" href="https://medium.com/better-programming/queues-and-concurrency-in-ios-for-dummies-4089da2365f8" rel="noopener">文章</a>。)</p><p id="182c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们修改上面的代码来使用多线程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/1628a7c2090168a4119224e8aca94839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_MRHRHMr2mHyLae1n5YLQ.png"/></div></div></figure><p id="c354" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了一个名为<code class="fe ls lt lu lv b">queue</code>的新并发队列，并使用该队列异步执行闭包。这样，函数在执行闭包之前返回。上面的例子是我们应用程序中一个典型的网络呼叫场景。我们进行异步调用从服务器获取用户，一旦收到响应，我们就执行完成闭包。编译器在这里抛出一个错误。上面写着<code class="fe ls lt lu lv b">escaping closure captures non-escaping parameter 'completion</code>。这是什么意思？</p><p id="ddf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们问一下Swift文档。</p><blockquote class="na nb nc"><p id="6174" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">当你声明一个将闭包作为其参数之一的函数时，你可以在参数的类型前写<code class="fe ls lt lu lv b"><em class="iq">@escaping</em></code>来表示闭包是允许转义的</p></blockquote><p id="8e8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它说为了转义闭包，参数前面必须有<code class="fe ls lt lu lv b">@escaping</code> <em class="nd"> </em>。在我们的例子中，由于我们没有提供它，闭包将无法转义，我们会得到一个编译错误。让我们修理它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/fe931c4ba31da3c3a4fd9d77452a60ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Umk3F6jNVc5WrZBkFqTS0g.png"/></div></div></figure><p id="da09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！这是固定的，现在我们的闭包可以从函数中逸出，以后再运行。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="01c8" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">2.在函数外存储闭包</h1><p id="08a7" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果在函数外部存储闭包会发生什么？这个闭包可以在应用生命周期的任何时候运行。本质上，闭包是从函数范围中逸出的。看看下面的例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/99a3f96e37323093d37ac31dca3221de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vODs0F1XIZskcaUUIv57rw.png"/></div></div></figure><p id="f980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们将闭包存储在变量<code class="fe ls lt lu lv b">holder</code>中，稍后我们可以使用它并执行闭包。所以我们必须设置闭包参数<code class="fe ls lt lu lv b">@escaping</code>来消除编译器错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/bf13cd59ce37125cf8767e744b788277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*maqFJiW7839kjTGXLq8GZw.png"/></div></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1312" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">大局</h1><p id="0ac4" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在内部，上述两种逃避闭包的方法是相同的。让我借助我们上面写的代码来解释一下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/1628a7c2090168a4119224e8aca94839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_MRHRHMr2mHyLae1n5YLQ.png"/></div></div></figure><p id="211f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，正在转义的闭包就是闭包<code class="fe ls lt lu lv b">queue.asyc{}</code>。通常，闭包会捕获它需要的常量和变量，并可以从其主体内部修改这些常量和变量的值，即使定义常量和变量的原始作用域已经不存在。在这种情况下，它试图捕获<code class="fe ls lt lu lv b">completion</code>，这是一个非转义参数。<em class="nd">非转义参数</em>表示该参数不能存在于函数范围之外。为了让闭包<code class="fe ls lt lu lv b">queue.asyc{}</code>逸出，我们应该让完成参数可逸出。这是我们在添加<code class="fe ls lt lu lv b">@escaping</code> <em class="nd"> </em>的时候做的，这样它就可以离开函数了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/99a3f96e37323093d37ac31dca3221de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vODs0F1XIZskcaUUIv57rw.png"/></div></div></figure><p id="947f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样的事情也发生在这里。如果您将闭包赋给一个范围外的变量，那么闭包本质上是转义的。我们必须添加<code class="fe ls lt lu lv b">@escaping</code>，这样闭包才能离开函数范围。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="aefd" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">摆脱封闭需要“自我”</h1><p id="0799" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">用<code class="fe ls lt lu lv b">@escaping</code>标记闭包意味着您必须在闭包内显式引用<code class="fe ls lt lu lv b">self</code>。</p><p id="d154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们的闭包不再是函数作用域的一部分，如果我们想要使用任何class/struct变量，我们必须使用<code class="fe ls lt lu lv b">self</code>来引用它们。让我们看看如果我们不使用它会发生什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/bce7161f1ae18059a484f9bb7f30c449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7Ne5uIbY5ej2l_xl02lWw.png"/></div></div></figure><p id="7d88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们试图从闭包内部引用类变量<code class="fe ls lt lu lv b">name</code>时，我们会得到一个错误。为了解决它，我们必须使用显式<code class="fe ls lt lu lv b">self</code>，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/3f356630ef46ecdeca5ed656a239dedb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNQMHSuG7t-oV_4kQSjQ2g.png"/></div></div></figure><p id="776e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">self</code>的使用是对引用(也称为<em class="nd">捕获</em>)闭包中的构造(类/结构/枚举)的显式确认，这意味着在所述闭包被释放之前<code class="fe ls lt lu lv b">self</code>不会被释放。因此，当在闭包内使用<code class="fe ls lt lu lv b">self</code>时，你应该非常小心，否则你会以保留循环结束。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="7a1e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结束注释</h1><p id="2eaa" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">这就是我这篇文章的全部内容。关注我的推特了解更多更新。提供一些掌声，如果你喜欢这个职位，因为这将鼓励我写更多(你可以放弃多达50)不要担心书生气。如果你认为我可以在文章中做些改进，请告诉我。</p></div></div>    
</body>
</html>