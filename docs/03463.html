<html>
<head>
<title>Quick Sort Explained in Under 5 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速分类在5分钟内解释完毕</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/quicksort-explained-in-5-minutes-d32cf430a592?source=collection_archive---------16-----------------------#2020-02-11">https://betterprogramming.pub/quicksort-explained-in-5-minutes-d32cf430a592?source=collection_archive---------16-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d40e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最快的排序算法讲解，快</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/22ef8a3d547e682c5eb4a7211205c0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*48KmEcxV8AtXan_Yo3_4yg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按<a class="ae ky" href="https://giphy.com/gifs/art-abstract-pattern-3oGRFHO6YQrxnnU5Ta" rel="noopener ugc nofollow" target="_blank">运动上瘾者</a>分类插图</p></figure><p id="47bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在排序领域，快速排序是王道！</p><p id="cd84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速排序是一种递归的分治算法，在同类算法中速度最快。它的平均时间复杂度为O (n log n)(用big-o表示)，与同类产品相比，这是相当快的。Big-O符号是一种衡量算法随着处理的数据量增长而扩展或执行的方式。</p><p id="c88e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是针对顶级排序算法的图表堆叠快速排序。如你所见，它排在第一位:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/6f85ddfdfa277061fe61c14d0cba0282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*9SxNaDzFVzfNI6cWIV8O8Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">bigocheatsheet.com</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/1a2902bda51b16ae14f647bae815936d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xmpnR90Ixek2SVTUrS4WA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(n log n)在Big-O复杂度图上</p></figure><p id="3fc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得快速排序成为白板面试的最爱，也是任何有抱负的软件工程师的必备。在本文中，我们将使用JavaScript作为基础语言来解释它是如何工作的。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1c64" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">它是如何工作的？</strong></h1><p id="289c" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">Quicksort使用一个pivot，这个值通常被指定为数组的中间或最后一个元素。该算法将数组的每个元素与轴心进行比较，重新排列每个元素，使其一侧(左侧)的值较小，另一侧(右侧)的值较大。然后，它对两边进行分区，并在每一边递归地运行相同的过程，直到数组被排序。</p><p id="7935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有助于了解算法，然后理解其中发生的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以下面的数组为例:<code class="fe nd ne nf ng b">originalArray = [4, 5, 1, 3, 2]</code></p><ul class=""><li id="79ef" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">我们可以将pivot设置为最后一个元素，<code class="fe nd ne nf ng b">2: pivot = 2</code>。</li><li id="5cb2" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">接下来，我们将数组的第一个元素与轴心进行比较:<code class="fe nd ne nf ng b">4 ≤ 2?</code></li><li id="eea3" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">请记住，我们希望将小于轴心的所有元素移动到它的左侧，并在右侧执行相反的操作。由于<code class="fe nd ne nf ng b">4</code>大于<code class="fe nd ne nf ng b">2</code>，我们将其推入一个名为<code class="fe nd ne nf ng b">rightSide</code> : <code class="fe nd ne nf ng b">rightSide = [4]</code>的新数组</li><li id="8659" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们用5做同样的事情:<code class="fe nd ne nf ng b">5 ≤ 2?</code>不，所以:<code class="fe nd ne nf ng b">rightSide=[4, 5]</code></li><li id="d499" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">是的，因此我们把它移到一个名为<code class="fe nd ne nf ng b">leftSide</code> : <code class="fe nd ne nf ng b">leftSide = [1]</code>的数组中</li><li id="42a2" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nd ne nf ng b">3 ≤ 2?</code>否= &gt; <code class="fe nd ne nf ng b">rightSide=[4, 5, 3]</code></li><li id="56fe" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们已经到达数组的末尾，所以我们停止循环。</li></ul><p id="5de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经:</p><p id="360f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">leftSide = [1], pivot = 2, and rightSide = [4, 5, 3]</code></p><p id="a111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转向右侧，我们有:</p><ul class=""><li id="efc1" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">我们的新支点现在是3: <code class="fe nd ne nf ng b">pivot = 3</code></li><li id="9954" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">4 ≤ 3?不，=&gt; `5 ≤ 3？否，=&gt; <code class="fe nd ne nf ng b">rightSide = [4, 5]</code></li><li id="d58b" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nd ne nf ng b">leftSide = []</code>(因为没有元素少于3)</li></ul><p id="0789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">leftSide = []</code>、<code class="fe nd ne nf ng b">pivot = 3</code>、<code class="fe nd ne nf ng b">rightSide = [4, 5]</code></p><p id="c817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们继续递归到右侧:</p><ul class=""><li id="9782" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe nd ne nf ng b">pivot = 5</code></li><li id="bf51" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nd ne nf ng b">4 ≤ 5?</code>是的，=&gt;T6】</li><li id="fef6" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nd ne nf ng b">rightSide = []</code></li></ul><p id="ab98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">leftSide = [4]</code>、<code class="fe nd ne nf ng b">pivot = 5</code>、<code class="fe nd ne nf ng b">rightSide = []</code></p><p id="dc8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在递归地尝试对左侧进行排序:</p><ul class=""><li id="f423" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">由于<code class="fe nd ne nf ng b">leftSide</code>数组只有一个元素，没有什么可排序的，所以我们返回它。</li></ul></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="f2b1" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">从递归返回</strong></h1><p id="55ff" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">假定已经到达了<code class="fe nd ne nf ng b">rightSide</code>数组的基本情况，函数将通过每次递归返回。在每次递归中，将按顺序使用<code class="fe nd ne nf ng b">leftSide</code>、pivot和<code class="fe nd ne nf ng b">rightSide</code>的返回值形成一个新数组(<code class="fe nd ne nf ng b">newArray</code>)。</p><p id="3c35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们得到以下结果:</p><ul class=""><li id="2914" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">第三层递归:记住递归发生在<code class="fe nd ne nf ng b">rightSide</code>数组中。因此，我们有:<code class="fe nd ne nf ng b">return newArray([1], 2, [4, 5])</code></li><li id="d925" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">递归的第二个深度:<code class="fe nd ne nf ng b">return newArray([1], 2, [3, 4, 5])</code></li><li id="088c" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">第一个递归深度:<code class="fe nd ne nf ng b">return newArray([1, 2, 3 , 4, 5])</code></li></ul><p id="2efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用伪代码将算法总结如下:</p><ul class=""><li id="8beb" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">将透视设置为数组中的最后一个元素。</li><li id="96e3" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">将最左边的元素与pivot进行比较——如果它大于pivot，则将它推入一个名为<code class="fe nd ne nf ng b">right</code>的新数组。对左侧做相反的动作。</li><li id="9ebc" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">递归迭代左右数组，直到到达最后一个元素，在这种情况下，它的长度将是<code class="fe nd ne nf ng b">1</code>。然后返回该值。</li><li id="3337" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">该函数将在两端展开递归，对过程中的每一端进行排序，以便最后一个返回值将成为完全排序的数组。</li></ul><p id="d3a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是我能找到的关于快速排序算法的两个最简短但最好的解释。我强烈推荐观看这些视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nc l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nc l"/></div></figure><p id="300c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在本文中讨论的算法可以说是quicksort中最简单、最直观的算法之一。然而，有许多快速排序的方法可以在big-O复杂度图上产生不同的性能。如果您想探索这些资源，可以查看下面的资源:</p><div class="nw nx gp gr ny nz"><a href="https://www.geeksforgeeks.org/quick-sort/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">快速分类-极客搜索</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">像合并排序一样，快速排序是一种分治算法。它选择一个元素作为支点，并划分给定的…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://www.tutorialspoint.com/data_structures_algorithms/quick_sort_algorithm.htm" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">数据结构和算法-快速排序</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">快速排序是一种高效的排序算法，它基于将数据数组划分为更小的数组。一个…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.tutorialspoint.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on ks nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://www.interviewbit.com/tutorial/quicksort-algorithm/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">快速排序算法- InterviewBit</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">快速排序是最有效的排序算法之一，它基于将一个数组分割成更小的数组…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.interviewbit.com</p></div></div><div class="oi l"><div class="op l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>