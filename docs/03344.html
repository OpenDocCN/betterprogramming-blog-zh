<html>
<head>
<title>Not All Underscores Are Equal in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中，并不是所有的下划线都相等</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/not-all-underscores-are-equal-in-python-b50768124092?source=collection_archive---------17-----------------------#2020-02-04">https://betterprogramming.pub/not-all-underscores-are-equal-in-python-b50768124092?source=collection_archive---------17-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f9f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解每个单词的含义</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0dd9de8b1a621f0ccf701e4cc2978d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXI-kg18liPn4XcfZmoqQQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·里德在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，我们在各种场景中使用下划线。你可能已经注意到了，它们并不总是服务于相同的目的。</p><p id="81b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将总结最常见的用例。希望这有助于你理解Python中的下划线，这样你就可以按预期使用它们了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ec7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.对最后一个表达式值的引用</h1><p id="5e12" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下划线的另一个常见用途是在解释器环境(例如，终端会话、Jupyter笔记本)中使用它来引用最后一个表达式值。这里有一个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/8d8f5ebe4b0cffa728d5aa6f8257f27d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjPI661h4VCfG3EXmP4Ldw.png"/></div></div></figure><p id="5746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，[2]中的第一个<code class="fe na nb nc nd b">_</code>的值为10。在[3]的计算中，我们可以使用一个<code class="fe na nb nc nd b">_</code>来直接引用这个值。</p><p id="fb81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是，当一个值(即[4]中的2)被赋给一个<code class="fe na nb nc nd b">_</code>，使其成为一个变量时，<code class="fe na nb nc nd b">_</code>将具有所赋的值，正如[5]中乘法的乘积所反映的那样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f7c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.被忽略值的表示</h1><p id="b475" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这也是一种常见的用法。下面是使用下划线忽略不需要的值的各种情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9f9342d6b17192b129ba15648e15af74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioQJlFPpG0qgXz-RQTtwyQ.png"/></div></div></figure><p id="1e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们分解一个元组时，我们只需要命名将要使用的项。例如，在上面的[6]中，我们只想使用<code class="fe na nb nc nd b">fruit</code>的<code class="fe na nb nc nd b">color</code>，我们使用下划线来命名其他项目。需要注意的一点是，下划线本质上是变量，因此当我们打印<code class="fe na nb nc nd b">_</code>时，它将显示最新的赋值。在这种情况下，<code class="fe na nb nc nd b">_</code>是5——元组的最后一项。</p><p id="b6d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们分解一个列表时，有几个使用场景，如[7]所示。一个是我们只需要使用<code class="fe na nb nc nd b">colors</code>列表中的第一个和最后一个条目，所以我们为每个条目命名两个变量，用<code class="fe na nb nc nd b">*_</code>来指代中间的所有条目。另一种是我们只想使用原始列表中间的项目列表。在这种情况下，我们只使用下划线来命名第一个和最后一个项目，变量<code class="fe na nb nc nd b">c</code>是一个新列表，由原始列表中间的项目组成。</p><p id="8a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个常见的任务是，我们必须迭代一个列表来对每个条目运行一些操作。对于第一次迭代，我们使用<code class="fe na nb nc nd b">i</code>和<code class="fe na nb nc nd b">j</code>分别指代索引和条目。有时候，我们不需要知道索引，在这种情况下，我们可以通过在最初写<code class="fe na nb nc nd b">i</code>的位置使用一个<code class="fe na nb nc nd b">_</code>来忽略它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5bf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.分隔数字的位数</h1><p id="e0f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个特性主要是为了可读性。下图显示了相关的示例。如您所见，第一对数字(即<code class="fe na nb nc nd b">a0</code>和<code class="fe na nb nc nd b">a1</code>)相等，第二对也是如此:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/1e843e8a9b07dabfc962366794dd6593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oR9FzzoApgGNn8pqVQEtbQ.png"/></div></div></figure><h1 id="564c" class="mc md it bd me mf nf mh mi mj ng ml mm jz nh ka mo kc ni kd mq kf nj kg ms mt bi translated">4.变量或函数名的一部分</h1><p id="01b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下划线最常见的用法是作为变量或函数名的一部分。以下代码片段向您展示了一些示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，对于变量，下划线可以在变量的开头、中间或结尾。此外，下划线本身也可以是变量名。</p><p id="4392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下划线可以像变量名一样灵活地用在函数名中。在开头、中间、结尾或单独使用它们都是有效的。但是，根据下划线的数量和位置，它们可以有不同的指示和使用场景，如下所述。</p><h2 id="75c5" class="nm md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">4.1.私有属性和方法</h2><p id="4869" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，下划线可以是函数的前缀。当这些函数在自定义类中定义时，这些函数就变成私有的。如下所示，我们声明了一个<code class="fe na nb nc nd b">Fruit</code>类，其中定义了三个属性:<code class="fe na nb nc nd b">healthy</code>、<code class="fe na nb nc nd b">_price</code>和<code class="fe na nb nc nd b">__vitamines</code>，以及三个方法:<code class="fe na nb nc nd b">grow()</code>、<code class="fe na nb nc nd b">__sprout()</code>和<code class="fe na nb nc nd b">_flower()</code>。</p><p id="a4f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如[10]末尾所示，没有下划线前缀的方法是公共的，可以在类的范围之外调用。一个下划线表示该方法是私有的，但是如果我们在[11]中选择这样做的话，可以从外部调用它。函数名前面的两个下划线使得该方法严格私有，因此不能在外部调用，如[12]的错误消息所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/2f19c58a4b163c6015a49edb5a322286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIFP6nwOtshY3MFru1VdZg.png"/></div></div></figure><p id="3f11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，同样的规则也适用于类的属性。相关的例子如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/b9c664e88d0dcff09f0d74f8dccb2ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEKn4Q0N7myyswJXZzlcEw.png"/></div></div></figure><p id="2a53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然看起来通过在属性和方法名前面使用双下划线，我们能够使它们成为私有的，但事实并非如此。事实上，双下划线表示“名称篡改”，这是指使用公式对这些属性/方法的更改:<code class="fe na nb nc nd b">_ClassName__attributeName or _ClassName__methodName</code>。</p><p id="7654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/c1d3a0dc97081933a7e378ada0127b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Na-W2bjKdEMjWWdRowq5Ig.png"/></div></div></figure><p id="b1ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个相关的场景是，当我们从某个模块导入时，带有下划线前缀的属性和方法不会被导入。这里有一个简化的例子。假设我们有一个名为<code class="fe na nb nc nd b">medium_module</code>的模块，如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="15d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们通过调用<code class="fe na nb nc nd b">from medium_module import *</code>来使用这个模块时，这两个函数并不都可用——带有_前缀的函数不可用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/fe12071cf8e75885f11e8ee01204d026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrkFu63LSp9_uVryFFACKg.png"/></div></div></figure><p id="1135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，需要注意的是，如果我们通过如下调用<code class="fe na nb nc nd b">import medium_module as mm</code>来导入模块，我们可以访问这些“私有”方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/07a9d6f8800c1a5e63e6970b69d455f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiXHFEHkDidcX9d3sjgM9Q.png"/></div></div></figure><h2 id="f315" class="nm md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">4.2.避免命名冲突</h2><p id="b001" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个不太常见的场景。Python有一些关键字，像<code class="fe na nb nc nd b">def</code>、<code class="fe na nb nc nd b">impor</code> t、<code class="fe na nb nc nd b">from</code>，是为特殊用途保留的。通常，我们不能在函数中使用这些关键字，否则会造成命名冲突。为了解决这个问题，我们可以在这些关键字后面使用一个尾随下划线。</p><p id="0e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个简化的例子。如您所见，使用<code class="fe na nb nc nd b">from_</code>有效，而使用<code class="fe na nb nc nd b">from</code>无效:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/e2a537305a0f917395896713d54e33da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgShuXzEY1Rbg6WQflpYvA.png"/></div></div></figure><h2 id="d85c" class="nm md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">4.3.神奇的方法</h2><p id="f6f3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在4.1中，我们提到如果属性或方法有双前导下划线，命名混乱就会发生。然而，有一种特殊情况不会发生名称混淆:当属性或方法以双下划线开始和结束时:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/f0a0d10a8eb0d3818093043c23998e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmLB6R4Vk_OUCVT1wav6OQ.png"/></div></div></figure><p id="8ce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python保留使用双前导和尾随下划线。例如，在自定义类中，我们使用<code class="fe na nb nc nd b">__init__</code>来构造一个对象。这种类型的方法通常被称为“魔术方法”理论上，我们可以使用这种模式创建自己的神奇方法。然而，在大多数情况下，我们不需要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4da0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4dfd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢阅读。我希望你能从这篇文章中学到一些有用的东西。</p><p id="b520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，本教程回顾了Python中下划线的常见用例。除了第三种用法(即分隔数字的位数)只是为了可读性，所有其他用例在Python项目中都很方便。</p></div></div>    
</body>
</html>