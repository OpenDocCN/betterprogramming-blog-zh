<html>
<head>
<title>Building Your Own WotsApp — Part 7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您自己的WotsApp —第7部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-your-own-wotsapp-part-7-47b9b66b3db4?source=collection_archive---------23-----------------------#2020-03-23">https://betterprogramming.pub/building-your-own-wotsapp-part-7-47b9b66b3db4?source=collection_archive---------23-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d83c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用SwiftUI、Combine、通知、CloudKit和加密技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/074bca4aa0b581394c07cc568c3b1feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRqpuM2QHdgUgeXxI4JqMA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰瑞米·毕肖普在<a class="ae ky" href="https://unsplash.com/s/photos/skyscrappers-night-time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="a740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我应该以免责声明开始这篇文章:它是基于iOS 13、Swift 5和Xcode 11.x的。如果你正在阅读这篇文章，而那些数字看起来过时了，请预先警告。</p><p id="2463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还应该提醒你，通知——主要是远程通知——涉及苹果的基础设施，这意味着你需要一个苹果开发者账户才能使用它们。当然，你也需要一个来使用CloudKit。</p><p id="754a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结束我们的审查…在审查中，我认为我们可以通过一些设计更改来解决最后几个问题，这些更改将一次性解决几乎所有问题。</p><p id="f287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一章中，我们做了3/4的工作来阻止和隐藏条目。我想出了一个扭转局面的计划。不过，我现在不会这么做。让我们首先解决多用户问题，这是更重要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0a3e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">第十三章</h1><p id="569c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，我确信我们将有两个用户想要相同的登录名。这一点我们都同意。在当前的设计中，他们也有可能选择同样的秘密。几率比你想象的要大得多——只是谷歌常用密码。这种组合将奠定我们目前的设计。</p><p id="46ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过创建应用内的秘密来解决这个问题，只是我们称之为PIN码。人们已经习惯了被发给密码，而不是秘密。</p><p id="b219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以通过对我们的协议进行细微的修改来解决同名问题。当你点击一个用户时，它不会发送与对方通话的请求。它会要求您确认他们的PIN。我们可以将这个PIN码存储在我们用MD5散列加密的公共目录中。是的，我知道MD5散列不太安全，但我们已经在安装的加密包中获得了代码…毕竟，我们不是在建立一个银行。</p><p id="6593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当他们点击一个名字时，我们将建立一个拥有该名字的所有用户的子集，并要求他们输入PIN。然后，我们可以使用他们的名字和他们刚刚输入的PIN的MD5散列，在我们刚刚下载的子集中找到他们想要通话的用户。</p><p id="b8f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于您已经知道了代码，我们将假设可以连接，这大大简化了整个过程。</p><p id="f4e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以在数据库中拥有无限数量的重复名称，当您列出目录时，只有一个名称出现。这是我们要解决的第一个问题。</p><p id="61f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我不需要一个盒子来键入一个秘密，我就可以把那个空格收回来。所以让我们用它作为一个组名。</p><p id="d365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是双赢。我们不要求用户输入更多的内容，我们保持界面几乎不变。事实上，组名可以是可选的。它甚至可能是一个应用程序购买。现在有一个想法。这是我们的第二点。</p><p id="dc9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们有一个规则，如果你键入一个组，它假设你想创建一个私人目录，不希望你的名字出现在全局目录中。很明显，你需要和你的朋友分享群名。否则，他们永远找不到你。这是我们的第三点。</p><h2 id="6567" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">问题和解决方案</h2><p id="88bb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">编辑<code class="fe nl nm nn no b">Crypto.swift</code>文件并添加这个简短的方法来生成PIN码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，有极小的可能性，你会得到两个用户相同的名字和相同的代码。但这没关系，因为我们将比较这段代码的MD5散列，它应该是唯一的。说到散列，这里是您需要添加到<code class="fe nl nm nn no b">Crypto.swift</code>文件中的<code class="fe nl nm nn no b">md5hash</code>方法的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，您需要在文件的顶部导入Cryptor库。现在移到<code class="fe nl nm nn no b">Storage.swift</code>，编辑<code class="fe nl nm nn no b">saveToPublic</code>方法。给它添加一个对新的<code class="fe nl nm nn no b">md5hash</code>方法的调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当您添加一个用户时，他们的代码将自动生成并保存在他们的私有文件中，并作为哈希保存在他们的公共文件中。诚然，公共文件并不是真正的公共文件——只有这个应用程序可以访问它——但原则是存在的。你不能在公共数据库中存储私人数据。最后，编辑<code class="fe nl nm nn no b">ContentView.swift</code>文件并更新按钮以包含新方法。这将使我们继续前进:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="caa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，你应该准备好测试了。进行更改，使用CloudKit dashboard清空您的数据库，并测试代码。创建一个新用户，确保你有一个PIN码和MD5散列文件。</p><p id="aa16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要对协议进行修改——相当剧烈的修改，真的。我们将不再请求连接许可。我们假设如果他们知道密码，他们可以连接。先说<code class="fe nl nm nn no b">Storage.swift</code>。</p><p id="9192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想要一个记录的简单表示，所以我在<code class="fe nl nm nn no b">Storage.swift</code>中定义了一个新的结构，并定义了一个新的<code class="fe nl nm nn no b">PassThroughPublisher</code>来使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我创建了一些新方法来使用这个新结构。我们还需要一个方法来返回所有的名字，第二个方法来匹配您用选择器选择的名字，第三个方法来更新您确认的名字的授权消息，假设给出了正确的PIN码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="37f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确认代码时，有两种方法保存记录:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="94bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有这个。注意，我们将<code class="fe nl nm nn no b">auth</code>字段保存到私有数据库，但是随着协议的改变，我们现在需要将其保存到公共数据库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了充分利用我们的新协议，还需要对<code class="fe nl nm nn no b">contentView.swift</code>做一点修改。在<code class="fe nl nm nn no b">pickerView</code>下，你需要更改/添加这个标签。注意，我们在这里使用了一个更快的弹出窗口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要再次对目录列表器做一个小小的更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及我们称之为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你已经准备好接受下一次测试了。将第二个用户添加到您的同名设备中，然后开始使用。</p><p id="bfdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来像是一个更干净的解决方案，但是等等:它有两个主要缺点。</p><ul class=""><li id="1fc0" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">一旦您在设备上授权了一个用户，该设备上的所有用户都获得了授权。</li><li id="aa7e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">更糟糕的是，一旦你授权了一个人，你就授权了所有人，因为我们在公共目录中保存了<code class="fe nl nm nn no b">auth</code>。</li></ul><p id="b732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要么需要改变公共数据库，使<code class="fe nl nm nn no b">authorised users</code>成为<code class="fe nl nm nn no b">auth</code>字段下的个人账户列表，要么我们将它保存在设备上。前者听起来不错，这将意味着如果我们改变我们的设备，我们不会失去授权用户，但如果我们改变我们的设备，我们会改变我们的通知签名。让我们重新调整一下，以便在本地保存它。</p><p id="554f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个例程将保存和/或确认我们共享内存的令牌:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="60bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要更改<code class="fe nl nm nn no b">ContentView.swift</code>检查并使用保存例程。我注释掉了保存到公共数据库的调用，并在这里添加了新的调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次测试的时间到了，虽然这次您将需要三个真实的设备，因此您创建三个用户，验证一个用户与第二个用户的对话，并检查第三个用户是否仍然需要验证。</p><p id="208c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还剩下什么？</p><ul class=""><li id="a810" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">解除账户冻结(您还记得第4/4部分)。</li><li id="d9b4" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">实现分组。</li><li id="3cb0" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">实现更高的安全性(这样您就不会有无数次尝试在各方之间设置通知)。</li><li id="f217" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">整理图标上出现的徽章，让它们更有意义。</li><li id="f918" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">清理代码，去掉封存的方法。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac4a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">第十四章</h1><p id="82cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我想用一个摇动的手势来调用一个<code class="fe nl nm nn no b">restore</code>方法用于被封锁的账户。在我开始之前，我应该提到这是一个实现的挑战，因为被阻止的设备在三个地方被阻止:在内存中的本地设备上，在内存中的远程设备上，以及在其他用户的私有数据库中的远程设备上。</p><p id="59a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例程拾取摇动动作。你需要把它添加到你的<code class="fe nl nm nn no b">ContentView.swift</code>文件的末尾。这是最简单的部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ac06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仍然在<code class="fe nl nm nn no b">ContentView.swift</code>中工作，当被<code class="fe nl nm nn no b">togglePublisher</code>触发时，这段代码会引出一个新的分支。这将列出被阻止的帐户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3ad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">togglePublisher</code>本身就是在这里触发的。我注释掉了一些我们还没有实现的方法。</p><pre class="kj kk kl km gt of no og oh aw oi bi"><span id="6a5f" class="mz md it no b gy oj ok l ol om">Text("WotsApp")<br/>.onReceive(togglePublisher) { (_) in<br/>self.display4 = !self.display4<br/>self.display5 = !self.display5<br/>}</span></pre><p id="56ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些方法添加到项目中，编译并运行。根据您的设置，它可能工作，也可能不工作。这里有一个微妙的错误。被封锁的帐户数据保存在被封锁者的私人数据库中。如果你已经在所有登录到同一个苹果ID的设备上运行了这个，它会工作。但是，如果你一直在登录到单独帐户的设备上运行这一功能——这是应该的——它将不起作用，因为<code class="fe nl nm nn no b">blocked</code>标签保存在被阻止的个人的私人数据库中。</p><p id="63e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，你不记得了，但我们需要这样做，因为我们需要阻止消息从源头发出。</p><p id="222f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有另一个问题。如果甲方屏蔽了乙方，我们就没事了…但只是在乙方重新安装应用程序并获得新的令牌值之前。</p><p id="0c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，一步一步来。我们正在寻找解除封锁的解决方案。要做到这一点，两个用户需要同时在线并运行应用程序。我们继续。</p><p id="0b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编辑<code class="fe nl nm nn no b">RemoteNotifications.swift</code>并添加一个<code class="fe nl nm nn no b">unblockMessage</code>方法。这将是我们在前面章节中讨论过的背景通知之一:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bfac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在编辑你的<code class="fe nl nm nn no b">appDelegate</code>并进行修改。这里，我们正在清除本地内存和私有数据库:</p><pre class="kj kk kl km gt of no og oh aw oi bi"><span id="f21d" class="mz md it no b gy oj ok l ol om">if request == "unblock" {<br/>cloud.searchNReturn(device!, action: "unblock")<br/>cloud.saveUnblockedTokenToSharedmemory(token2U: device!)<br/>}</span></pre><p id="2fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您需要编辑<code class="fe nl nm nn no b">Storage.swift</code>中的方法并添加一个新动作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将此方法(由新操作触发的方法)添加到同一个文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="33e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您将需要将未阻止的令牌保存回内存的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该准备好再做一次测试。使用CloudKit dashboard清理您的数据库，并向两个不同的设备添加一些新帐户。现在从一个向另一个发送通知。如果你确信一切都还正常，试着屏蔽彼此之间的信息。检查它们是否被阻止。重新启动一切，摇一摇其中一个设备。取消阻止该帐户，然后尝试再次发送邮件。您可能需要搜索该名称，因为当您重新启动时它不会显示。</p><p id="465d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个与多个用户相关的错误:如果你屏蔽了一个用户，它就会屏蔽该设备上的所有人。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f592" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0f2c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们需要再休息一下，透透气。看似简单的应用程序已经变成了一个巨大的工程，出现的障碍几乎和我们修复它们一样快。我必须承认，我担心我在旅途中错过了什么，让你孤立无援。如果是这样的话，请告诉我，我会尽力救你的。</p><p id="b85e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第10章，我说我们已经到达了终点，但我随后认为我掉了太多球。我们已经解决了几乎所有的问题，我想现在我真的需要结束这个系列了。谢谢你陪我一起探索。我希望你喜欢阅读这个系列，就像我喜欢写它一样，并且确实在这个过程中学到了一些新东西。</p></div></div>    
</body>
</html>