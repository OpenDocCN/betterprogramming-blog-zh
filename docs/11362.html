<html>
<head>
<title>Leaky Abstraction — What Is It?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">漏抽象——是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/leaky-abstraction-what-is-it-ed0bc84000fd?source=collection_archive---------3-----------------------#2022-03-13">https://betterprogramming.pub/leaky-abstraction-what-is-it-ed0bc84000fd?source=collection_archive---------3-----------------------#2022-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c771" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">找出代码中的漏洞，看看如何处理它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98cc6f5abed396e54d9600a23ed3766d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPaH79t0IBQn4QuqoT3z-A.png"/></div></div></figure><p id="d904" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在设计架构时，会进行越来越多的抽象，尤其是在庞大复杂的系统中。高质量的软件应该有正确的抽象，判断它的一个标准是确保它们没有“漏洞”。</p><p id="1a42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将阐明抽象漏洞的含义，并提出处理它的方法。</p><h1 id="2815" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">什么是泄漏抽象？</h1><p id="8044" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">泄漏抽象是一种泄漏了本应抽象掉的细节的抽象。当用户在某个时候必须知道什么是“内部”或“下面”来操作抽象时，就会发生这种情况。在日常生活中，你肯定会面临许多泄漏的抽象概念。如果你开车，你需要记住油位，注意发动机发出的声音，记得不时换油。这就是所谓的泄漏抽象。</p><p id="5a37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">泄漏的抽象也可以在代码中找到——在类实现、库或协议中。让我们关注一个代码示例来更好地理解它。</p><h1 id="d52a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">代码示例</h1><p id="7955" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">考虑以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="bda3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个类似Instagram的应用程序的一部分。<code class="fe mp mq mr ms b">User</code>数据结构有一个名字、上传的照片和一个关注者列表。数据库表<code class="fe mp mq mr ms b">users</code>中有以下列名:<code class="fe mp mq mr ms b">username</code>、<code class="fe mp mq mr ms b">user_photos</code>和<code class="fe mp mq mr ms b">user_followers</code>。</p><p id="6213" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了从数据库中获取用户，我们需要用我们想要获取的列列表(例如<code class="fe mp mq mr ms b">["user_photos","user_followers"]</code>)调用<code class="fe mp mq mr ms b">getUser(...)</code>。开发人员之所以这样做，是因为在不需要的时候获取照片和关注者列表的成本很高。</p><blockquote class="mt mu mv"><p id="7439" class="ku kv mw kw b kx ky ju kz la lb jx lc mx le lf lg my li lj lk mz lm ln lo lp im bi translated">一些ORM允许我们使用延迟加载。这意味着，只有在代码中实际引用了数据时，才会从数据库中获取数据(例如，您编写了<code class="fe mp mq mr ms b">console.log(user.followers)</code>)。但是这是一个没有任何延迟加载技巧的简单例子；p</p></blockquote><h2 id="dd8a" class="na lr it bd ls nb nc dn lw nd ne dp ma ld nf ng mc lh nh ni me ll nj nk mg nl bi translated">你能发现一个有漏洞的抽象吗？</h2><p id="8535" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在这个例子中，数据库抽象泄露了存储库。使用存储库的开发人员需要知道<code class="fe mp mq mr ms b">attributes</code>是数据库中列的名称。此外，他需要知道他不需要提供一个<code class="fe mp mq mr ms b">username</code>列，因为它已经存在了。又一次泄露。</p><h2 id="e713" class="na lr it bd ls nb nc dn lw nd ne dp ma ld nf ng mc lh nh ni me ll nj nk mg nl bi translated">修复</h2><p id="daa2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们可以为所需的每种组合编写一个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="313c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它确实隐藏了抽象，但是随着更多属性的出现，它会增长很多。对于某些情况来说，这可能是足够的，但是在示例中，它不遵循<a class="ae nm" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>原理。</p><p id="d727" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们尝试另一种解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="07d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个解决方案中，我们创建了一个包含可用属性的enum，这些属性可以从<code class="fe mp mq mr ms b">User</code>对象的存储库中检索到。在存储库中，这个枚举被映射为正确的列名。</p><p id="ee62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，使用存储库的开发人员不需要知道列名。他甚至不需要知道它们在关系数据库中！这是非常好的抽象分离。</p><p id="0c24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我希望你对什么是泄漏抽象有所了解。不过，关于他们还有一些更有趣的事情需要讨论。</p><h1 id="8004" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">泄漏抽象法则</strong></h1><p id="2c06" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Joel Spolsky在他2002年的<a class="ae nm" href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/" rel="noopener ugc nofollow" target="_blank">文章中介绍了漏抽象主题，并阐述了漏抽象定律:</a></p><blockquote class="nn"><p id="472b" class="no np it bd nq nr ns nt nu nv nw lp dk translated">在某种程度上，所有非平凡的抽象都是有漏洞的。</p></blockquote><p id="984d" class="pw-post-body-paragraph ku kv it kw b kx nx ju kz la ny jx lc ld nz lf lg lh oa lj lk ll ob ln lo lp im bi translated">他指出，即使我们尽最大努力不泄漏抽象，如果我们构建一个复杂的系统，它最终还是会泄漏。</p><p id="1a16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是否意味着我们不应该关心泄漏，因为有些泄漏总是存在于我们的程序中？</p><p id="bc14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然不是！大多数抽象漏洞需要被修复，但是我们应该意识到有些是不可避免的，我们不应该浪费时间和它们战斗。</p><h1 id="f3b5" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">众所周知的漏洞抽象</h1><p id="91c0" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们许多人在日常编程工作中使用的常见漏抽象:</p><ul class=""><li id="712a" class="oc od it kw b kx ky la lb ld oe lh of ll og lp oh oi oj ok bi translated">根据元素在数据库中的存储方式，在水平方向和垂直方向上迭代大型二维数组的时间可能会有很大不同</li><li id="7da6" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">ORM是伟大的，直到你意识到有些事情不能用它来完成——然后你需要通过ORM抽象向下一层去写一些原始的SQL</li><li id="7061" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">SQL性能查询根据它们的编写方式而有所不同。要编写好的查询，您需要对SQL执行有所了解</li></ul><h1 id="71bc" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">处理泄漏抽象的技巧</h1><ol class=""><li id="dd9a" class="oc od it kw b kx mi la mj ld oq lh or ll os lp ot oi oj ok bi translated">去除复杂性— <code class="fe mp mq mr ms b">More complexity = more abstraction = higher chance of leaks</code>。如果解决方案体系结构变得太复杂，那么重新思考它并尝试找到一种更简单的方法是一个好主意。</li><li id="5acd" class="oc od it kw b kx ol la om ld on lh oo ll op lp ot oi oj ok bi translated">添加一个新的抽象层——一个新的抽象层可能隐藏了泄漏的实现细节，但是，它使系统更加复杂。在这个解决方案中要小心。</li><li id="9d0c" class="oc od it kw b kx ol la om ld on lh oo ll op lp ot oi oj ok bi translated">接受——如果你对抽象泄漏无能为力或者代价太高，那么接受是正确的选择。记住漏抽象的法则。</li></ol><h1 id="dd38" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">最终注释</h1><p id="543c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在生活和软件中，我们每天都会看到泄漏的抽象。这就是我们应该意识到它们的原因。尽管它们很普遍，我们还是应该尝试以一种最小化泄漏的方式来创建系统。这是一项很难的技能，但为了写出高质量的代码，它是值得掌握的。</p></div></div>    
</body>
</html>