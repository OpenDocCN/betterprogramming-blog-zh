<html>
<head>
<title>What is React.memo and How Does It Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是React.memo，它是如何工作的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-react-memo-and-how-does-it-work-f49b031bba75?source=collection_archive---------3-----------------------#2022-03-10">https://betterprogramming.pub/what-is-react-memo-and-how-does-it-work-f49b031bba75?source=collection_archive---------3-----------------------#2022-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d74e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的React应用程序添加更多性能提升</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1534ac2144ab256942a8dbe966fa699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nEN4WKROMRwNb9kPdjYaQ.jpeg"/></div></div></figure><p id="0439" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">React.memo</code>是一个React高阶组件，用于跳过重新渲染。</p><p id="68f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">React.memo</code>中的“备忘录”指的是计算术语记忆化</p><blockquote class="lu lv lw"><p id="8b21" class="ku kv lx kw b kx ky ju kz la lb jx lc ly le lf lg lz li lj lk ma lm ln lo lp im bi translated">记忆化是一种<a class="ae mb" href="https://en.wikipedia.org/wiki/Optimization_(computer_science)" rel="noopener ugc nofollow" target="_blank">优化</a>技术，主要用于通过存储昂贵的<a class="ae mb" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank">函数调用</a>的结果并在相同的输入再次出现时返回缓存的结果来加速<a class="ae mb" href="https://en.wikipedia.org/wiki/Computer_programs" rel="noopener ugc nofollow" target="_blank">计算机程序</a>。</p></blockquote><p id="4574" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您用<code class="fe lq lr ls lt b">React.memo</code>包装一个组件时，React将使用该组件的最后一个渲染版本。</p><p id="1b13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在我的React应用程序中一直使用内存化来提高性能。</p><p id="41c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将回顾一些关于<code class="fe lq lr ls lt b">React.memo</code>如何工作的简单例子，以及我在自己的项目中发现它有用的地方。</p><h1 id="f685" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e936" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，有两个组件在渲染和重新渲染时会写入控制台。<code class="fe lq lr ls lt b">MemoExample</code>组件包含<code class="fe lq lr ls lt b">Component1</code>、<code class="fe lq lr ls lt b">Component2</code>并有一个<code class="fe lq lr ls lt b">counter</code>状态变量，当它改变时，将触发两个组件重新呈现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/2b41ff4f3caa4acce6807657c8e68767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_lJH2QKbvRpIPHYCpPqUg.png"/></div></div></figure><p id="1fd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在将计数器更新为3之后，每个组件有4个日志。一次用于初始渲染，另外三次用于计数器变量的每次更改。</p><p id="87ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我不想让<code class="fe lq lr ls lt b">Component1</code>在<code class="fe lq lr ls lt b">counter</code>变量改变时重新渲染，我可以使用<code class="fe lq lr ls lt b">React.memo</code>跳过它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d859" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在Component1已经被React.memo包装好了，让我们看看它是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/f113a8bea301f92d3a7b946bbe8513f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9qWxKFOPHm2ByNLtnnv7A.png"/></div></div></figure><p id="2a11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们让<code class="fe lq lr ls lt b">Component1</code>为它的初始渲染写一个控制台日志，但是之后就没有了。</p><h1 id="c786" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">性能</h1><p id="a013" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">记忆组件可以像其他组件一样接收道具。如果一个属性值改变，组件将像平常一样重新渲染。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="824d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我已经更新了我的示例，添加了第二个计数器，并添加了初始计数器作为组件1的属性。</p><p id="9244" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe lq lr ls lt b">counter</code>增加时，我们应该在控制台中看到组件1的日志。当我增加<code class="fe lq lr ls lt b">counter2</code>时，<code class="fe lq lr ls lt b">Component1</code>应该像以前一样跳过它的重渲染。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/634d9d1bb52247bc115d99ed0e975307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Hso0gthKggJ9sJHWNzHBQ.png"/></div></div></figure><p id="4746" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我的控制台显示了两个初始渲染的日志，另外两个是在增加<code class="fe lq lr ls lt b">counter</code>的值后，只有一个是在<code class="fe lq lr ls lt b">counter2</code>增加时。</p><p id="bae7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理想情况下，记忆成分应该是纯的。我只建议在记忆化的组件中添加很少改变的属性。</p><h1 id="437c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">跳跃点</h1><p id="084c" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">如果你正在寻找用<code class="fe lq lr ls lt b">React.memo</code>练习的方法，应用程序栏是我第一次使用记忆化的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/3bd4b34c1dfbf67a57b6691a15998877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dR1VZTKiDfXqEa1LI_CuDg.png"/></div></div></figure><p id="62ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上图所示的应用程序栏是<code class="fe lq lr ls lt b">React.memo</code>的绝佳候选，因为它们主要由静态内容组成。如果你正在寻找一个开始记忆的地方，我建议你先去那里看看。</p><p id="5111" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你从未在你的应用程序中使用过内存化，你应该能找到一些可以使用它的地方。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="d7f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望这对于那些希望为他们的React应用程序增加更多性能提升的人来说是常见的。</p></div></div>    
</body>
</html>