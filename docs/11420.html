<html>
<head>
<title>Building a Book Store API in Golang With Gin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Gin在Golang构建书店API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-book-store-api-in-golang-with-gin-d9a84a1a429b?source=collection_archive---------10-----------------------#2022-03-17">https://betterprogramming.pub/building-a-book-store-api-in-golang-with-gin-d9a84a1a429b?source=collection_archive---------10-----------------------#2022-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f9b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2532a28023527443b714dce800fcc82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C4_5o-f6KfQh1nav.jpg"/></div></div></figure><h1 id="261b" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="c25b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Go社区认为我们不需要框架来开发web服务。我同意这一点。当你在不使用任何框架的情况下工作时，你了解了开发的来龙去脉。但是一旦你学会了事情是如何运作的，你必须生活在一个社区中，不要重复发明轮子。</p><p id="4e1e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我以前在Go中创建了POC，我必须处理HTTP头、序列化/反序列化、错误处理、数据库连接等等。但是现在我决定加入Gin社区，因为它是软件开发社区中被广泛接受的社区之一。</p><p id="0ec5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">虽然我写这篇文章是作为一篇独立的文章，并在这里保持事情简单。但是我想在这些例子的基础上继续讨论认证、授权、数据库(包括Postgres、ORM)、swagger和GraphQL。当我创建它们时，将链接的职位。</p><h1 id="f882" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">为什么是杜松子酒</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e8446076d464b121b378a9b467a82a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Puoiq8dBtE097JshJHOYvg.jpeg"/></div></div></figure><p id="0446" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">你可能想用杜松子酒的原因有很多。如果你问我，我是杜松子酒明智的默认大风扇。</p><p id="3c89" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我喜欢Gin的另一点是它是一个完整的框架。你不需要单独的多路复用器和单独的中间件库等等。最重要的是，已经有很多常见的东西，你不必重新发明。它确实提高了我们的生产力。虽然我没有在生产中使用它，但我已经开始感受到它了。</p><h1 id="9c48" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">杜松子酒世界你好</h1><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="658f" class="mp ks iq ml b gy mq mr l ms mt">package main<br/><br/>import (<br/>	"net/http"<br/><br/>	"github.com/gin-gonic/gin"<br/>)<br/><br/>func main() {<br/>	router := gin.New()<br/><br/>	router.GET("/ping", func(ctx *gin.Context) {<br/>		ctx.JSON(http.StatusOK, gin.H{<br/>			"message": "pong",<br/>		})<br/>	})<br/><br/>	router.Run()<br/>}</span></pre><p id="9f18" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们稍微熟悉一下杜松子酒。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="b122" class="mp ks iq ml b gy mq mr l ms mt">router := gin.New()</span></pre><p id="95e8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这就创建了一个<code class="fe mu mv mw ml b">Engine</code>的实例。<code class="fe mu mv mw ml b">gin.Engine</code>是杜松子酒的核心。它还充当路由器，这就是为什么我们将引擎实例放入一个名为<code class="fe mu mv mw ml b">router</code>的变量中。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="4f6f" class="mp ks iq ml b gy mq mr l ms mt">router.GET("/ping", func(ctx *gin.Context) {</span></pre><p id="2054" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这将路由<code class="fe mu mv mw ml b">/ping</code>绑定到一个处理程序。在上面的例子中，我创建了一个匿名函数，但是它也可以是一个单独的函数。这里要注意的是这个函数的参数。<code class="fe mu mv mw ml b">*gin.Context</code>。<code class="fe mu mv mw ml b">Context</code>是除发动机之外的又一重要构造。<code class="fe mu mv mw ml b">Context</code>有将近100个方法。新手应该把大部分时间花在理解这个<code class="fe mu mv mw ml b">Context</code>结构和它们的方法上。</p><p id="2587" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">现在让我们看看下面几行:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="3b21" class="mp ks iq ml b gy mq mr l ms mt">ctx.JSON(http.StatusFound, gin.H{<br/>			"message": "pong",<br/>		})</span></pre><p id="6583" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe mu mv mw ml b">*gin.Context</code>方法之一是<code class="fe mu mv mw ml b">JSON</code>。该方法用于向客户端发送JSON响应。这意味着它自动将响应的<code class="fe mu mv mw ml b">Content-Type</code>设置为<code class="fe mu mv mw ml b">application/json</code>。JSON方法接受一个HTTP状态代码和一个响应映射。<code class="fe mu mv mw ml b">gin.H</code>是<code class="fe mu mv mw ml b">map[string]interface{}</code>的别名。所以基本上我们可以创建一个对象，它可以有字符串键和我们想要的任何值。</p><p id="0fbe" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">接下来是:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="228c" class="mp ks iq ml b gy mq mr l ms mt">router.Run()</span></pre><p id="86d6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">引擎。Run简单地将我们的路由器和路由处理器一起绑定到http.Server，默认端口是<code class="fe mu mv mw ml b">8080</code>，但是如果您愿意，您可以在这里传递另一个地址。</p><h1 id="0f70" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">书店API</h1><p id="9c04" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我之前已经在书店上做过一次POC，当时想在MongoDB和Go之间做一个连接的原型。但这次我的目标是让Postgres和GraphQL合并。</p><p id="31dd" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">首先，我希望您建立一个这样的目录结构:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="a712" class="mp ks iq ml b gy mq mr l ms mt">$ tree<br/>.<br/>├── db<br/>│   └── db.go<br/>├── go.mod<br/>├── go.sum<br/>├── handlers<br/>│   └── books.go<br/>├── main.go<br/>└── models<br/>    └── book.go</span></pre><p id="9137" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们开始填写这些文件。</p><h1 id="770d" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">db/db.go</h1><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="93af" class="mp ks iq ml b gy mq mr l ms mt">package db<br/><br/>import "github.com/santosh/gingo/models"<br/><br/>// Books slice to seed book data.<br/>var Books = []models.Book{<br/>	{ISBN: "9781612680194", Title: "Rich Dad Poor Dad", Author: "Robert Kiyosaki"},<br/>	{ISBN: "9781781257654", Title: "The Daily Stotic", Author: "Ryan Holiday"},<br/>	{ISBN: "9780593419052", Title: "A Mind for Numbers", Author: "Barbara Oklay"},<br/>}</span></pre><p id="ade1" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我决定在这篇文章中使用内存中的数据库，而不是现在就进入设置数据库的复杂性。在这个文件中，我在<code class="fe mu mv mw ml b">db.Books</code> slice中植入了一些书籍。</p><p id="4166" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果<code class="fe mu mv mw ml b">models.Book</code>使，你很好奇，下一个文件是那只。</p><h1 id="a3aa" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">models/book.go</h1><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="98a9" class="mp ks iq ml b gy mq mr l ms mt">package models</span><span id="58ab" class="mp ks iq ml b gy mx mr l ms mt">// Book represents data about a book.<br/>type Book struct {<br/> ISBN   string  `json:"isbn"`<br/> Title  string  `json:"title"`<br/> Author string  `json:"author"`<br/>}</span></pre><p id="9f70" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这里没有什么奇特的，我们现在只有3个领域。它们都是带有struct标签的字符串。</p><p id="d3b7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们先看看我们的main.go，然后再看handlers.go。</p><h1 id="7f55" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">main.go</h1><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="2a73" class="mp ks iq ml b gy mq mr l ms mt">package main</span><span id="6057" class="mp ks iq ml b gy mx mr l ms mt">import (<br/> "github.com/gin-gonic/gin"<br/> "github.com/santosh/gingo/handlers"<br/>)</span><span id="e364" class="mp ks iq ml b gy mx mr l ms mt">func setupRouter() *gin.Engine {<br/>    router := gin.Default()<br/> router.GET("/books", handlers.GetBooks)<br/> router.GET("/books/:isbn", handlers.GetBookByISBN)<br/> // router.DELETE("/books/:isbn", handlers.DeleteBookByISBN)<br/> // router.PUT("/books/:isbn", handlers.UpdateBookByISBN)<br/> router.POST("/books", handlers.PostBook)</span><span id="c761" class="mp ks iq ml b gy mx mr l ms mt">return router<br/>}</span><span id="daee" class="mp ks iq ml b gy mx mr l ms mt">func main() {<br/>    router := setupRouter()<br/> router.Run(":8080")<br/>}</span></pre><p id="1c93" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">几乎类似于我们上面看到的hello world示例。但是这次我们用了<code class="fe mu mv mw ml b">gin.Default()</code>而不是<code class="fe mu mv mw ml b">gin.New()</code>。<code class="fe mu mv mw ml b">Default</code>带有我们大多数人想要的默认设置。比如日志中间件。</p><p id="9861" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">坦白说，我还没怎么用过Gin的中间件。但是创建你的中间件非常简单。我会在帖子底部放一些链接供你探索。但是现在，让我们看看我们的处理程序。</p><h1 id="ef19" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">handlers/books.go</h1><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="cd60" class="mp ks iq ml b gy mq mr l ms mt">package handlers</span><span id="c4b8" class="mp ks iq ml b gy mx mr l ms mt">import (<br/> "net/http"</span><span id="884b" class="mp ks iq ml b gy mx mr l ms mt">"github.com/gin-gonic/gin"<br/> "github.com/santosh/gingo/db"<br/> "github.com/santosh/gingo/models"<br/>)</span><span id="ccd7" class="mp ks iq ml b gy mx mr l ms mt">// GetBooks responds with the list of all books as JSON.<br/>func GetBooks(c *gin.Context) {<br/> c.JSON(http.StatusOK, db.Books)<br/>}</span><span id="dc9e" class="mp ks iq ml b gy mx mr l ms mt">// PostBook takes a book JSON and store in DB.<br/>func PostBook(c *gin.Context) {<br/> var newBook models.Book</span><span id="ff68" class="mp ks iq ml b gy mx mr l ms mt">// Call BindJSON to bind the received JSON to<br/> // newBook.<br/> if err := c.BindJSON(&amp;newBook); err != nil {<br/>  return<br/> }</span><span id="7cfe" class="mp ks iq ml b gy mx mr l ms mt">// Add the new book to the slice.<br/> db.Books = append(db.Books, newBook)<br/> c.JSON(http.StatusCreated, newBook)<br/>}</span><span id="d59c" class="mp ks iq ml b gy mx mr l ms mt">// GetBookByISBN locates the book whose ISBN value matches the isbn<br/>func GetBookByISBN(c *gin.Context) {<br/> isbn := c.Param("isbn")</span><span id="a132" class="mp ks iq ml b gy mx mr l ms mt">// Loop over the list of books, look for<br/> // an book whose ISBN value matches the parameter.<br/> for _, a := range db.Books {<br/>  if a.ISBN == isbn {<br/>   c.JSON(http.StatusOK, a)<br/>   return<br/>  }<br/> }<br/> c.JSON(http.StatusNotFound, gin.H{"message": "book not found"})<br/>}</span><span id="4790" class="mp ks iq ml b gy mx mr l ms mt">// func DeleteBookByISBN(c *gin.Context) {}</span><span id="a534" class="mp ks iq ml b gy mx mr l ms mt">// func UpdateBookByISBN(c *gin.Context) {}</span></pre><p id="ca1a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">真正的内容在这个处理程序文件中。这可能需要一些解释。</p><p id="ac04" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe mu mv mw ml b">handlers.GetBooks</code>，绑定到<code class="fe mu mv mw ml b">GET /books</code>转储整个书切片。</p><p id="04a6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">绑定到<code class="fe mu mv mw ml b">GET /books/:isbn</code>的<code class="fe mu mv mw ml b">handlers.GetBookByISBN</code>也做同样的事情，但是它也接受<code class="fe mu mv mw ml b">isbn</code>作为URL参数。该处理程序扫描整个切片并返回匹配的图书。扫描大切片可能不是最佳解决方案，但是不要忘记，在我们继续开发这个书店的同时，我们将实现一个真正的数据库。</p><p id="ca81" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这里最有意思的是<code class="fe mu mv mw ml b">handlers.PostBook</code>，绑定了<code class="fe mu mv mw ml b">POST /books</code>。<code class="fe mu mv mw ml b">c.BindJSON</code>是一个神奇的方法，它从请求中获取JSON，并将其存储到之前创建的<code class="fe mu mv mw ml b">newBook</code> struct中。后来</p><h1 id="0da5" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">试验</h1><p id="22a2" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们现在需要一点改变。我们需要从main.go中删除这些内容:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="d20a" class="mp ks iq ml b gy mq mr l ms mt">@@ -1,17 +1,9 @@<br/> package main<br/> <br/>-import (<br/>-       "github.com/gin-gonic/gin"<br/>-       "github.com/santosh/gingo/handlers"<br/>-)<br/>+import "github.com/santosh/gingo/routes"<br/> <br/> func main() {<br/>-       router := gin.Default()<br/>-       router.GET("/books", handlers.GetBooks)<br/>-       router.GET("/books/:isbn", handlers.GetBookByISBN)<br/>-       // router.DELETE("/books/:isbn", handlers.DeleteBookByISBN)<br/>-       // router.PUT("/books/:isbn", handlers.UpdateBookByISBN)<br/>-       router.POST("/books", handlers.PostBook)<br/>+       router := routes.SetupRouter()<br/> <br/>        router.Run(":8080")<br/> }</span></pre><p id="1f06" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">并把它放到一个新文件中。</p><h2 id="de80" class="mp ks iq bd kt my mz dn kx na nb dp lb ls nc nd ld lw ne nf lf ma ng nh lh ni bi translated">routes/roures.go</h2><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="39f4" class="mp ks iq ml b gy mq mr l ms mt">package routes</span><span id="2aeb" class="mp ks iq ml b gy mx mr l ms mt">import (<br/> "github.com/gin-gonic/gin"<br/> "github.com/santosh/gingo/handlers"<br/>)</span><span id="e143" class="mp ks iq ml b gy mx mr l ms mt">func SetupRouter() *gin.Engine {<br/> router := gin.Default()<br/> router.GET("/books", handlers.GetBooks)<br/> router.GET("/books/:isbn", handlers.GetBookByISBN)<br/> // router.DELETE("/books/:isbn", handlers.DeleteBookByISBN)<br/> // router.PUT("/books/:isbn", handlers.UpdateBookByISBN)<br/> router.POST("/books", handlers.PostBook)</span><span id="6d46" class="mp ks iq ml b gy mx mr l ms mt">return router<br/>}</span></pre><p id="820c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我有对你有意义的改变。我们这样做是因为我们需要从测试中启动服务器。</p><p id="48f7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">接下来，我们在处理程序中创建一个<code class="fe mu mv mw ml b">books_test.go</code>。</p><h2 id="bd62" class="mp ks iq bd kt my mz dn kx na nb dp lb ls nc nd ld lw ne nf lf ma ng nh lh ni bi translated">handlers/books_test.go</h2><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="fef2" class="mp ks iq ml b gy mq mr l ms mt">package handlers_test</span><span id="0f71" class="mp ks iq ml b gy mx mr l ms mt">import (<br/> "bytes"<br/> "encoding/json"<br/> "net/http"<br/> "net/http/httptest"<br/> "testing"</span><span id="b7de" class="mp ks iq ml b gy mx mr l ms mt">"github.com/santosh/gingo/models"<br/> "github.com/santosh/gingo/routes"<br/> "github.com/stretchr/testify/assert"<br/>)</span><span id="b61b" class="mp ks iq ml b gy mx mr l ms mt">func TestBooksRoute(t *testing.T) {<br/> router := routes.SetupRouter()</span><span id="3374" class="mp ks iq ml b gy mx mr l ms mt">w := httptest.NewRecorder()<br/> req, _ := http.NewRequest("GET", "/books", nil)<br/> router.ServeHTTP(w, req)</span><span id="a948" class="mp ks iq ml b gy mx mr l ms mt">assert.Equal(t, 200, w.Code)<br/> assert.Contains(t, w.Body.String(), "9781612680194")<br/> assert.Contains(t, w.Body.String(), "9781781257654")<br/> assert.Contains(t, w.Body.String(), "9780593419052")<br/>}</span><span id="b1a0" class="mp ks iq ml b gy mx mr l ms mt">func TestBooksbyISBNRoute(t *testing.T) {<br/> router := routes.SetupRouter()</span><span id="781b" class="mp ks iq ml b gy mx mr l ms mt">w := httptest.NewRecorder()<br/> req, _ := http.NewRequest("GET", "/books/9781612680194", nil)<br/> router.ServeHTTP(w, req)</span><span id="25d2" class="mp ks iq ml b gy mx mr l ms mt">assert.Equal(t, 200, w.Code)<br/> assert.Contains(t, w.Body.String(), "Rich Dad Poor Dad")<br/>}</span><span id="a8f9" class="mp ks iq ml b gy mx mr l ms mt">func TestPostBookRoute(t *testing.T) {<br/> router := routes.SetupRouter()</span><span id="b888" class="mp ks iq ml b gy mx mr l ms mt">book := models.Book{<br/>  ISBN: "1234567891012",<br/>  Author: "Santosh Kumar",<br/>  Title: "Hello World",<br/> }</span><span id="3fdd" class="mp ks iq ml b gy mx mr l ms mt">body, _ := json.Marshal(book)</span><span id="bad6" class="mp ks iq ml b gy mx mr l ms mt">w := httptest.NewRecorder()<br/> req, _ := http.NewRequest("POST", "/books", bytes.NewReader(body))<br/> router.ServeHTTP(w, req)</span><span id="c9b3" class="mp ks iq ml b gy mx mr l ms mt">assert.Equal(t, 201, w.Code)<br/> assert.Contains(t, w.Body.String(), "Hello World")<br/>}</span></pre><p id="9d7a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">同样，这也是不言自明的。我认为上面的代码不需要任何解释。我们正在测试特定字符串的响应代码和响应主体。</p><p id="9c7d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们也运行一下测试，看看效果如何:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="2cf2" class="mp ks iq ml b gy mq mr l ms mt">go test ./... -cover<br/>?       github.com/santosh/gingo        [no test files]<br/>?       github.com/santosh/gingo/db     [no test files]<br/>ok      github.com/santosh/gingo/handlers       (cached)        coverage: 83.3% of statements<br/>?       github.com/santosh/gingo/models [no test files]<br/>?       github.com/santosh/gingo/routes [no test files]</span></pre><h1 id="da08" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">锻炼</h1><p id="21b4" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">是的，让我们通过增加一些互动性来使这篇博文更有趣。我有一些任务给你，你需要自己解决。请试穿一下。它们是:</p><ol class=""><li id="5095" class="nj nk iq ll b lm mf lp mg ls nl lw nm ma nn me no np nq nr bi translated">实现<code class="fe mu mv mw ml b">DeleteBookByISBN</code>和<code class="fe mu mv mw ml b">UpdateBookByISBN</code>处理程序并启用它们。</li><li id="e988" class="nj nk iq ll b lm ns lp nt ls nu lw nv ma nw me no np nq nr bi translated">为上面提到的处理程序编写测试。</li><li id="ad3c" class="nj nk iq ll b lm ns lp nt ls nu lw nv ma nw me no np nq nr bi translated">我们的测试非常简单。我们的负责人也是。我们不做任何错误处理。将错误处理添加到处理程序中，并编写测试来验证它们。</li></ol><h1 id="9783" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论</h1><p id="a097" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们已经看到了在Gin中创建hello world应用程序是多么简单。但这一旅程并未就此结束。下次我会带更多教程回来。在那之前，再见。</p><h1 id="a1d6" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">资源</h1><ul class=""><li id="8c52" class="nj nk iq ll b lm ln lp lq ls nx lw ny ma nz me oa np nq nr bi translated">https://sosedoff.com/2014/12/21/gin-middleware.html<a class="ae ob" href="https://sosedoff.com/2014/12/21/gin-middleware.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="a19e" class="nj nk iq ll b lm ns lp nt ls nu lw nv ma nw me oa np nq nr bi translated"><a class="ae ob" href="https://santoshk.dev/posts/2020/sending-post-request-in-go-with-a-body/" rel="noopener ugc nofollow" target="_blank">https://santoshk . dev/posts/2020/sending-post-request-in-go-in-a-body/</a></li></ul></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="0f55" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><em class="oj">最初发布于</em><a class="ae ob" href="https://santoshk.dev/posts/2022/building-a-bookstore-api-in-golang-with-gin/" rel="noopener ugc nofollow" target="_blank"><em class="oj">https://santoshk . dev</em></a></p></div></div>    
</body>
</html>