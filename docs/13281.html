<html>
<head>
<title>Creating a Basic Rate Limiter System With a Sliding Window in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中创建带有滑动窗口的基本速率限制器系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-basic-rate-limiter-system-with-a-sliding-window-in-typescript-7c363bee8728?source=collection_archive---------3-----------------------#2022-08-14">https://betterprogramming.pub/creating-a-basic-rate-limiter-system-with-a-sliding-window-in-typescript-7c363bee8728?source=collection_archive---------3-----------------------#2022-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c964" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习系统设计概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/677a2ae33ecf86c3d4c0d8c1b7fc21a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kfU2doj6Gy38m1hH"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sappyroy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨塔尔希·罗伊</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="085e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Rate_limiting" rel="noopener ugc nofollow" target="_blank">速率限制</a>是系统设计中的基本概念。我们可以用来实现速率限制的算法之一是“滑动窗口”算法。</p><p id="2876" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常基本的速率限制系统的例子，它有一个滑动窗口算法，我们用类型脚本制作了它，并逐行解释:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="688d" class="lx ly iq lt b gy lz ma l mb mc">class RateLimiter {<br/>    allowedRequests = 0;<br/>    timeFrameSize = 0;<br/>    queue = [];<br/>    constructor(n: number, t: number) {<br/>        this.allowedRequests = n;<br/>        this.timeFrameSize = t;<br/>    }</span><span id="d449" class="lx ly iq lt b gy md ma l mb mc">    shouldAllow(timestamp: number): boolean {<br/>        const diff = timestamp - this.timeFrameSize;<br/>        while (this.queue[this.queue.length - 1] &lt;= diff ) { <br/>            this.queue.pop();<br/>        }<br/>        if(this.queue.length &lt; this.allowedRequests){<br/>            this.queue.unshift(timestamp)    <br/>            return true;<br/>        }else{<br/>            return false<br/>        }<br/>    }<br/>}</span></pre><p id="91be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类的输入、输出和解释如下:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="aea8" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">Input</strong><br/>[“RateLimiter”, “shouldAllow”, “shouldAllow”, “shouldAllow”, “shouldAllow”, “shouldAllow”]<br/>[[3, 5], [1], [1], [2], [3], [8]]</span><span id="2f6b" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir">Output</strong><br/>[null, true, true, true, false, true]</span><span id="41bb" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir">Explanation</strong><br/>RateLimiter rateLimiter = new RateLimiter(3, 5);<br/>rateLimiter.shouldAllow(1); // returns True<br/>                            // There are no previous requests, so this request is allowed.<br/>rateLimiter.shouldAllow(1); // returns True<br/>                            // We can allow 3 requests every 5 seconds, so this request is allowed.<br/>                            // Timestamps of allowed requests are [1,1].<br/>rateLimiter.shouldAllow(2); // returns True<br/>                            // Timestamps of allowed requests are [1,1,2].<br/>rateLimiter.shouldAllow(3); // returns False<br/>                            // This request is not allowed because<br/>                            // the time range [1,3] already has 3 allowed requests.<br/>rateLimiter.shouldAllow(8); // returns True<br/>                            // This request is allowed because<br/>                            // the time range [4,8] does not have any allowed requests.</span></pre><p id="0011" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们一步一步来，看看它是如何工作的。</p><p id="0eb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们上课时有3个变量:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="259a" class="lx ly iq lt b gy lz ma l mb mc"> allowedRequests = 0;<br/> timeFrameSize = 0;<br/> queue = [];</span></pre><p id="4c92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe me mf mg lt b">allowedRequests</code>表示我们在特定的<code class="fe me mf mg lt b">timeFrameSize</code>中允许多少个请求(以秒为单位)，这两个值的默认值都是0。</p><p id="fee3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还有一个被初始化为空数组的<code class="fe me mf mg lt b">queue</code>，我们将使用它来监控我们当前有多少请求，以及窗口开始被设置的最后时间戳是什么。</p><p id="4f99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在类构造函数中，我们将<code class="fe me mf mg lt b">allowedRequests</code>和<code class="fe me mf mg lt b">timeFrameSize</code>设置为创建类时发送的值。</p><p id="bb75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们继续使用<code class="fe me mf mg lt b">shouldAllow</code>方法。在这个方法中，我们将首先跳到第5行:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ba96" class="lx ly iq lt b gy lz ma l mb mc">if(this.queue.length &lt; this.allowedRequests){<br/>          this.queue.unshift(timestamp)    <br/>            return true;<br/>        }else{<br/>            return false<br/>        }</span></pre><p id="1a80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很简单——如果我们不超过允许的请求数:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="a68b" class="lx ly iq lt b gy lz ma l mb mc">queue.length &lt; allowedRequests</span></pre><p id="687c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把这个请求的时间戳添加到数组的开头:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e29f" class="lx ly iq lt b gy lz ma l mb mc">this.queue.unshift(timestamp)</span></pre><p id="b4bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并通过返回true来允许这个请求。</p><p id="726a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe me mf mg lt b">queue.length === allowedRequests</code>表示我们不应该在这个时间窗口中允许任何更多的请求。我们返回false。</p><p id="ae39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们回到<code class="fe me mf mg lt b">shouldAllow</code>方法的第一行:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1967" class="lx ly iq lt b gy lz ma l mb mc">const diff = timestamp — this.timeFrameSize;<br/>while (this.queue[this.queue.length — 1] &lt;= diff ) { <br/> this.queue.pop();<br/>}</span></pre><p id="8d5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以首先我们设置一个名为<code class="fe me mf mg lt b">diff</code>的常量。</p><p id="7d9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe me mf mg lt b">diff</code>保存最后一个允许请求的时间戳，减去我们系统的<code class="fe me mf mg lt b">timeFrameSize</code>(我们在几秒钟内允许了多少个请求)。</p><p id="75b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当最后一项(我们添加到队列中的第一项)的时间戳等于或小于diff时，我们将它从队列中删除，并为下一个到来的请求增加空间。这就是窗口向前“滑动”的原因。</p><p id="be75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们以上面的例子来更清楚地理解它—输入看起来像这样:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="cfdd" class="lx ly iq lt b gy lz ma l mb mc">[[3, 5], [1], [1], [2], [3], [8]]</span></pre><p id="e8b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们允许每5秒钟3个请求(开始时的[3，5])。<br/>在前3次中，队列长度是&lt;或者等于3(<code class="fe me mf mg lt b">timeFrameSize</code>)，所以我们允许请求并把它们添加到队列中。</p><p id="ad50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们的队列如下所示:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2612" class="lx ly iq lt b gy lz ma l mb mc">[ 2, 1, 1 ]</span></pre><p id="d140" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这解释了为什么我们得到了如下结果:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="3e7e" class="lx ly iq lt b gy lz ma l mb mc">[null, true, true, true, false, true]</span></pre><p id="14d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个空值是当我们<code class="fe me mf mg lt b">init</code>类并得到<code class="fe me mf mg lt b">void</code>时，之后的3个子序列<code class="fe me mf mg lt b">true</code>值是允许的前3个请求。对于第4个，队列长度已经是3，所以不是从3开始的&lt;(<code class="fe me mf mg lt b">timeFrameSize</code>)。这就是为什么第四个请求为假。</p><p id="9607" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第5个请求中，队列中的最后一项是1，而<code class="fe me mf mg lt b">diff</code>是3，因此第一次:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="be21" class="lx ly iq lt b gy lz ma l mb mc">this.queue[this.queue.length — 1] &lt;= diff</span></pre><p id="8e3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将删除所有小于3的请求(本场景中队列中的所有项目)，并且队列是空的，因此在下一个请求中…</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="7ef6" class="lx ly iq lt b gy lz ma l mb mc">queue.length &lt; allowedRequests</span></pre><p id="145b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…在这种情况下，我们允许请求并将其添加到队列中——现在队列看起来像这样<code class="fe me mf mg lt b">[8]</code>,我们允许另外2个请求到来。<br/>通过这个动作，我们将窗口从时间戳1“滑动”到时间戳8，并从8开始计数3个请求。</p><h1 id="93c4" class="mh ly iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">资源</strong></h1><ul class=""><li id="724e" class="my mz iq ky b kz na lc nb lf nc lj nd ln ne lr nf ng nh ni bi translated">L <a class="ae kv" href="https://leetcode.com/explore/featured/card/system-design/689/system-design-basics/4408/" rel="noopener ugc nofollow" target="_blank"> eetcode挑战</a></li><li id="d553" class="my mz iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">L <a class="ae kv" href="https://leetcode.com/explore/featured/card/system-design/689/system-design-basics/4408/discuss/2302472/Typescript-solution-using-queue-with-comments." rel="noopener ugc nofollow" target="_blank"> eetcode TS解决方案</a></li><li id="27fb" class="my mz iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><a class="ae kv" href="https://www.geeksforgeeks.org/window-sliding-technique/" rel="noopener ugc nofollow" target="_blank">窗口滑动技术</a></li><li id="2b38" class="my mz iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=9CIjoWPwAhU" rel="noopener ugc nofollow" target="_blank">速率限制/ API节流的精彩解释</a></li></ul></div></div>    
</body>
</html>