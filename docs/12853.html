<html>
<head>
<title>Rive 2 — 2.5D Avatar With Pointer Tracking Using Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rive 2 — 2.5D头像，使用Flutter进行指针跟踪</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rive-2-2-5d-avatar-with-pointer-tracking-6ea069df2fa?source=collection_archive---------16-----------------------#2022-07-06">https://betterprogramming.pub/rive-2-2-5d-avatar-with-pointer-tracking-6ea069df2fa?source=collection_archive---------16-----------------------#2022-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8230" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">应用状态机</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e7d29cbf61217fc1e623241d435a69ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yW-UsbxYZaXZZnP20vQwkw.jpeg"/></div></div></figure><h1 id="28b9" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="cacc" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">距离我上一篇Rive文章已经过去很长时间了。以前是Rive 1 (Flare)，但现在，太阳在Rive 2升起。它已经拥有了第一部的大部分功能，加上状态机！这是一个游戏改变者，所以在这里我会告诉你为什么，通过这个“如何”教程，在Rive 2中创建一个跟随指针/点击位置的实时伪3D化身。</p><p id="3cbb" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">类似于<a class="ae mk" href="https://www.youtube.com/watch?v=UxDAs8RgKyY" rel="noopener ugc nofollow" target="_blank">这个视频</a>的东西，嗯……是啊，设计超级牛逼(和往常一样)，但是如何让它在你的网站或者应用上变得交互？这就是我的解决方法，走吧！</p><p id="1800" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在本教程中，我将展示在Flutter中制作的代码部分的实现，然而，这里的逻辑与React Native非常相似。</p><h1 id="99b0" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">设计部分</h1><p id="17e9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我不会详细讲述如何正确地创建一个人或生物的化身并制作动画——这只取决于你的想象力和设计技巧，有大量的例子和教程，包括上面链接中的那个。在这篇文章中，我将向你描述如何应用一个状态机并将不同的状态与动画联系起来，最重要的是，将整个事情与你的代码联系起来。不会超过几分钟，你也可以<a class="ae mk" href="https://youtu.be/EGv2rjTjzDM" rel="noopener ugc nofollow" target="_blank">在这个视频</a>中看到这一部分。</p><p id="f467" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在迁移过程中，状态机为我节省了大约一百行代码。在我的例子中，我将把眼睛和头部的运动与呼吸动画、眼睛返回到原始位置的退出动画(当光标离开化身时)以及背景的按下动画联系起来。比方说，你已经在Rive 2中做了一些动画设计，并且想用指针移动来制作动画——那么，让我们开始吧。</p><h2 id="8172" class="ml ks iq bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">呼吸动画</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/b6b56f68f62c3904fd1667603b67b33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N71Iyq5oGYcHQ1Id3lPFIQ.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">始终打开图层设置</p></figure><p id="1980" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">首先，创建一个空的状态机，如果你还没有的话，在我的例子中，我需要实现一个循环播放的动画，不考虑任何东西的状态——呼吸的动画。</p><p id="ac8d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">要在一个空层上这样做，拖动动画(在我的例子中是“呼吸”)，通过从它的边缘拖动到块动画，将蓝色块“任何状态”链接到呼吸的动画。</p><p id="a3d8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在出现的箭头处，可以将持续时间设置为零，以便动画立即开始。按“播放”按钮可以看到动画现在无限循环播放。很简单，对吧？下一层会稍微复杂一点。</p><h2 id="32f1" class="ml ks iq bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">背景动画</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/d18416f67eb4184eba4a44c1cea31162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*riBQ--c6RzBsgW9vOBPf_g.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">背景层设置</p></figure><p id="4f5e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">创建一个新层，再次拖动你的背景动画，并将其链接到蓝色块，具有相同的持续时间，但这一次我们需要设置回调来播放这个“一次性”动画。我们将使用"<strong class="ll ir">监听器</strong>和"<strong class="ll ir">输入</strong>，因此在输入选项卡中创建一个新的<strong class="ll ir">触发器</strong>，让我们称之为“按下的”，但是现在如何触发它呢？</p><p id="ff34" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">首先，我们需要创建一个用户点击的对象。你可以用一个透明的矩形大小的画板(<em class="nc"> Rive团队，顺便问一下，为什么我们不能用画板作为hitbox？</em>)。现在创建一个新的"<strong class="ll ir">指针向下</strong>类型的"<strong class="ll ir">监听器</strong>"。通过灰色按钮，选择目标—我们的新矩形，在下拉“设置”菜单中指定我们的新触发器“按下”。现在在"<strong class="ll ir">任意状态</strong>"块&gt;你的动画之间的箭头处，添加一个新的"<strong class="ll ir">条件</strong> ": "pressed "并将块动画与红色的" Exit "块链接起来，这样动画将总是结束(<em class="nc">否则，我们不能通过" pressed "触发器再次调用它，因为我们不能调用已经运行的动画，即使它处于完成状态</em>)。下面的动画会很像，走吧。</p><h2 id="f210" class="ml ks iq bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">退出动画</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/7558a017071772dd0dd612c10119d387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGtJ-Z42oDgA2oJZ2wMP5g.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">前景层设置</p></figure><p id="78f3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">同样，该动画独立于其他动画，创建一个新层，也拖动动画，并将其链接到"<strong class="ll ir"> Any State </strong>"块。类似地，创建一个输入触发器“exited”和一个“<strong class="ll ir">指针退出</strong>监听器，再次选择一个“hitbox”目标，并设置“exited”触发器。在退出动画和“<strong class="ll ir">任何状态</strong>块之间的箭头处，将<strong class="ll ir">条件</strong>设置为“按下”。在我的例子中，我增加了300毫秒的持续时间，以使眼球运动更加流畅。最后，将动画块连接到红色的“<strong class="ll ir"> Exit </strong>”块。</p><h2 id="6401" class="ml ks iq bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">光标/点击动画</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/c06e2114578386ff3932da3734296f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QuJLvx66kz_6BzoozcP54g.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">指针移动监听器设置</p></figure><p id="d956" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">现在让我们添加一个全局的"<strong class="ll ir">监听器</strong>"它将对指针的位置做出反应。目标将再次成为我们的“hitbox”矩形，监听器类型应该是一个新的“<strong class="ll ir">指针移动</strong>”，并在“设置”菜单中选择您的目标节点，即我们的对象跟随的点并相应地改变它们的位置，在我的例子中，有两个，分别是眼睛和头部，所以选择它们。</p><p id="441b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们已经完成了设计部分，检查你的动画，头像移动，和播放按钮的回调。如果你满意，下载你的<strong class="ll ir">。最新运行时的riv </strong>文件。在下一节中，我们将看看代码方面。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="dfe0" class="kr ks iq bd kt ku nl kw kx ky nm la lb jw nn jx ld jz no ka lf kc np kd lh li bi translated">代码部分</h1><h2 id="84b9" class="ml ks iq bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">控制器类别和设置</h2><p id="f3e3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">假设您已经有了一些Flutter项目，或者至少已经创建了一个默认项目。向<code class="fe nq nr ns nt b">pubspec.yaml</code>添加<a class="ae mk" href="https://pub.dev/packages/rive" rel="noopener ugc nofollow" target="_blank">驱动依赖</a>，版本<strong class="ll ir"> 0.9.1 </strong>或更高版本:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="6061" class="ml ks iq nt b gy ny nz l oa ob">rive: ^0.9.1</span></pre><p id="fcd4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">或者对最新的master使用git依赖。</p><p id="2932" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">首先，让我们创建一个类来控制动画的逻辑，处理回调等。让我们称之为<code class="fe nq nr ns nt b">RiveAvatar</code>，对于<a class="ae mk" href="https://pub.dev/documentation/rive/latest/rive/Rive-class.html" rel="noopener ugc nofollow" target="_blank"> Rive </a>小部件，我们应该像往常一样需要一个用于画板的字段，还需要一些存储在状态机控制器中的用于输入/触发的字段，所以看起来应该是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9466" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">你可能会注意到，<code class="fe nq nr ns nt b"><a class="ae mk" href="https://pub.dev/documentation/rive/latest/rive/StateMachineController-class.html" rel="noopener ugc nofollow" target="_blank">StateMachineController</a></code> <em class="nc"> </em>现在有了一个名为<code class="fe nq nr ns nt b">pointerMove</code>的新方法，它需要<a class="ae mk" href="https://pub.dev/documentation/rive/latest/math/Vec2D-class.html" rel="noopener ugc nofollow" target="_blank"><em class="nc">【Vec2D】</em></a>，这是一个同样来自Rive包的类型，但是Flutter只提供了一个<code class="fe nq nr ns nt b"><a class="ae mk" href="https://api.flutter.dev/flutter/dart-ui/Offset-class.html" rel="noopener ugc nofollow" target="_blank">Offset</a></code>作为指针坐标参考。另外，那些<code class="fe nq nr ns nt b"><a class="ae mk" href="https://pub.dev/documentation/rive/latest/rive/SMITrigger-class.html" rel="noopener ugc nofollow" target="_blank">SMITrigger</a></code>类型转换看起来很难看，所以让我们写一些助手扩展来将<code class="fe nq nr ns nt b">Offset</code>映射到<code class="fe nq nr ns nt b">Vec2D</code>坐标，避免类型转换(因为<code class="fe nq nr ns nt b">SMITrigger</code>扩展了<code class="fe nq nr ns nt b">SMIInput</code> <em class="nc"> </em>类型，我们可以欺骗飞镖分析器<em class="nc">)，就像这样:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="ac13" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">太好了，现在我们可以用这个可爱的一行程序让我们的化身活起来:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="7e62" class="ml ks iq nt b gy ny nz l oa ob"><em class="nc">void</em> move(<em class="nc">Offset</em> pointer) =&gt; _controller.pointerMoveFromOffset(pointer);</span></pre><p id="5f39" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了触发我们的退出动画，我们可以这样调用<code class="fe nq nr ns nt b">fire()</code>方法:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="1a5e" class="ml ks iq nt b gy ny nz l oa ob"><em class="nc">void</em> onExit() =&gt; _exitInput?.fire();</span></pre><p id="4caf" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">对于<code class="fe nq nr ns nt b">onTap</code>事件也是如此。但是没有鼠标/触控板输入的智能手机、平板电脑和其他设备会怎么样呢？逻辑会稍微复杂一点:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="11e9" class="ml ks iq nt b gy ny nz l oa ob"><em class="nc">void</em> onTapDown(<em class="nc">TapDownDetails</em> details) {<br/>  _pressInput?.fire(); <em class="nc">// Fire background animation.</em></span><span id="b16b" class="ml ks iq nt b gy oe nz l oa ob"><em class="nc">  if</em> (details.kind == PointerDeviceKind.touch) {<br/>    move(details.localPosition); <em class="nc">// Move eyes to the tap position.<br/>    Future</em>.delayed(<em class="nc">const</em> <em class="nc">Duration</em>(seconds: <em class="nc">1</em>), onExit); <em class="nc">// Exit after one sec.<br/>  </em>}<br/>}</span></pre><p id="8b1c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们的<em class="nc">画板</em>目前是私有的，但是我们应该在UI上引用它，我们需要为它获取一个getter。还有，<em class="nc"> RiveAvatar </em>似乎是一个静一些的好地方”。riv "文件缓存方法通过<code class="fe nq nr ns nt b"><a class="ae mk" href="https://pub.dev/documentation/rive/latest/rive/RiveFile-class.html" rel="noopener ugc nofollow" target="_blank">RiveFile</a></code> <em class="nc"> </em>类实现。让我们在这个dart文件中把所有的<a class="ae mk" href="https://github.com/tsinis/tsinis.github.io/blob/master/lib/animations/rive_avatar.dart" rel="noopener ugc nofollow" target="_blank">放在一起。</a></p><h2 id="f734" class="ml ks iq bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">缓存和用户界面部分</h2><p id="9951" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在我们有一个方法可以从项目中的任何地方缓存我们的头像，我强烈建议你在应用程序开始之前做，因为它是异步操作:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="27bd" class="ml ks iq nt b gy ny nz l oa ob"><em class="nc">import</em> ‘package:flutter/widgets.dart’;<br/><em class="nc">import</em> ‘animations/rive_avatar.dart’;<br/><em class="nc">import</em> ‘my_app.dart’;</span><span id="6998" class="ml ks iq nt b gy oe nz l oa ob"><em class="nc">Future</em>&lt;<em class="nc">void</em>&gt; main() <em class="nc">async</em> {<br/><em class="nc">final </em>cachedAnimation = <em class="nc">await</em> <em class="nc">RiveAvatar</em>.cachedAnimation;<br/>runApp(<em class="nc">MyApp</em>(cachedAnimation.mainArtboard));<br/>}</span></pre><p id="8d38" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">你可能会注意到<code class="fe nq nr ns nt b">mainArtboard</code> getter，因为你可能不需要整个<em class="nc"> RiveFile </em>，只需要其中的一个画板。同样，如果你有多个画板，你可以调用<code class="fe nq nr ns nt b">riveFile.artboardByName</code>方法。现在你可以把它提供给任何一个<code class="fe nq nr ns nt b"><a class="ae mk" href="https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html" rel="noopener ugc nofollow" target="_blank">InheritedWidget</a></code>，你喜欢的DI，或者简单的把它传递给构造函数。我更喜欢第一个或最后一个，所以这就是avatar场景类构造函数的样子:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="0370" class="ml ks iq nt b gy ny nz l oa ob"><em class="nc">import</em> ‘package:flutter/material.dart’;<br/><em class="nc">import</em> ‘package:rive/rive.dart’;<br/><em class="nc">import</em> ‘../animations/rive_avatar.dart’;</span><span id="a4ee" class="ml ks iq nt b gy oe nz l oa ob"><em class="nc">class</em> <em class="nc">AvatarScene</em> <em class="nc">extends</em> <em class="nc">StatelessWidget</em> {<br/><em class="nc">final</em> <em class="nc">RiveAvatar</em> _avatar;</span><span id="3140" class="ml ks iq nt b gy oe nz l oa ob"><em class="nc">AvatarScene</em>(<em class="nc">Artboard</em>? cachedArtboard, {<em class="nc">super</em>.key})<br/>: _avatar = <em class="nc">RiveAvatar</em>(cachedArtboard);</span><span id="c8b5" class="ml ks iq nt b gy oe nz l oa ob">...</span><span id="ccb4" class="ml ks iq nt b gy oe nz l oa ob">}</span></pre><p id="41b2" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">要处理鼠标指针退出和悬停事件，我们绝对应该使用<code class="fe nq nr ns nt b"><a class="ae mk" href="https://api.flutter.dev/flutter/widgets/MouseRegion-class.html" rel="noopener ugc nofollow" target="_blank"><em class="nc">MouseRegion</em></a></code> <em class="nc"> </em>小部件，对于简单的点击，处理经典的<code class="fe nq nr ns nt b"><a class="ae mk" href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html" rel="noopener ugc nofollow" target="_blank"><em class="nc">GestureDetector</em></a></code> <em class="nc"> </em>就足够了，两个小部件都可以提供悬停/点击事件的<code class="fe nq nr ns nt b">localPosition</code>作为<code class="fe nq nr ns nt b"><em class="nc">Offset</em></code>。<em class="nc">显然将</em> widget作为那两个的子控件，并将<code class="fe nq nr ns nt b">useArtboardSize</code>标志设置为<code class="fe nq nr ns nt b">true</code>。为了让它更灵活一点——在此基础上增加了一个<code class="fe nq nr ns nt b"><a class="ae mk" href="https://api.flutter.dev/flutter/widgets/FittedBox-class.html" rel="noopener ugc nofollow" target="_blank"><em class="nc">FittedBox</em></a></code>。你也可以选择用<a class="ae mk" href="https://api.flutter.dev/flutter/widgets/ColoredBox-class.html" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> ColoredBox </em> </a>为你的头像提供背景色，这样<a class="ae mk" href="https://github.com/tsinis/tsinis.github.io/blob/master/lib/widgets/avatar_scene.dart" rel="noopener ugc nofollow" target="_blank">看起来就会像这样</a>。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><blockquote class="of og oh"><p id="2402" class="lj lk nc ll b lm mf jr lo lp mg ju lr oi mh lu lv oj mi ly lz ok mj mc md me ij bi translated">在撰写本文时，Poscriptum几乎没有关于“指针移动”侦听器的文档，所以如果您注意到任何错误或遗漏信息，请随意撰写。感谢阅读！</p></blockquote><div class="ol om gp gr on oo"><a href="https://rive.app/s/5TcK-mI1cUark2TkVaaMNA/" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">2.5D头像</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">编辑描述</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">rive.app</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div></div></div>    
</body>
</html>