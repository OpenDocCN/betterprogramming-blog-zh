<html>
<head>
<title>Making a Production-Ready Flappy Bird in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React Native中制作准备就绪的Flappy Bird</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-a-production-ready-flappy-bird-in-react-native-751713661a60?source=collection_archive---------0-----------------------#2019-09-14">https://betterprogramming.pub/making-a-production-ready-flappy-bird-in-react-native-751713661a60?source=collection_archive---------0-----------------------#2019-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c7f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">制作一个有趣的，可玩的，好看的热门游戏的复制品</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2fc5a8e66f43b248c6bc3847df471b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7G2f0FkoTH55O6bVqofAxg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/search/photos/casual-gaming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@hellolightbulb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Hello灯泡</a>拍摄</p></figure><p id="00f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/better-programming/flappy-bird-with-react-native-game-engine-and-matter-js-d5673f50eb9" rel="noopener">上一篇</a>中，我们使用react-native-game-engine和Matter.js创建了Flappy Bird的概念验证版本。虽然它很有趣，但它甚至不是任何正常用户都会喜欢或使用超过10秒钟的那种游戏。</p><p id="53e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们的目标是使游戏(或多或少)为生产做好准备。</p><p id="2fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TL；博士1:看看我是如何在Youtube上制作这个的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="72e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TL；DR #2:在<a class="ae ky" href="https://github.com/lepunk/react-native-videos/tree/master/FlappyBird" rel="noopener ugc nofollow" target="_blank"> Github </a>上抓取源代码</p><p id="265e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们要做的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/91e39f5b06b4a2b080144660ed656c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*0LsQWoD1CWdgwsY-4ir-ZA.gif"/></div></figure><p id="5c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢处理列表，所以我创建了一个小任务列表来完成上面的任务:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/bd31efb724ac8093360cfb910f51599e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*DiSuqjGXw2f369YQYZxbJA.png"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b08d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">添加图形</h1><p id="acb1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一款游戏的好坏取决于它的画面。通常我会问我的设计师或雇人为我创造一个独特的设计，但在这种情况下，我很高兴有一个预先制作的模板。我上了GraphicRiver，花了7美元买了一个<a class="ae ky" href="https://graphicriver.net/item/flappy-duck-game-assets/8915443" rel="noopener ugc nofollow" target="_blank"> Flappy Duck </a>包，这个包非常适合演示。</p><p id="3fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我做了一点切割，最终得到了以下资产:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/1fee992f743d154c0516e5cd02f624c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NAcTArlvhXGxQMRfzGzsFg.png"/></div></div></figure><p id="a5d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将这些文件移动到我的项目中的<code class="fe ne nf ng nh b">/assets/img</code>文件夹，并在<code class="fe ne nf ng nh b">/assets</code>中创建了一个Images.js文件，以便以后方便地引用它们。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="b8e6" class="nm mh it nh b gy nn no l np nq">export default Images = {<br/>    background: require('./img/background.png'),<br/>    floor: require('./img/floor.png'),<br/>    pipeCore: require('./img/pipe_core.png'),<br/>    pipeTop: require('./img/pipe_top.png'),<br/>    bird1: require('./img/bird1.png'),<br/>    bird2: require('./img/bird2.png'),<br/>    bird3: require('./img/bird3.png'),<br/>}</span></pre><p id="e7f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前一集中，我们为<code class="fe ne nf ng nh b">Pipe</code>和<code class="fe ne nf ng nh b">Floor</code>对象使用了相同的<code class="fe ne nf ng nh b">Wall.js</code>组件。但是现在我们希望这些行为稍微不同，所以我们需要创建一个单独的<code class="fe ne nf ng nh b">Floor</code>组件。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="a393" class="nm mh it nh b gy nn no l np nq">import React, { Component } from "react";<br/>import { View, Image } from "react-native";<br/>import Images from "./assets/Images";<br/><br/>export default class Floor extends Component {<br/>    render() {<br/>        const width = this.props.body.bounds.max.x - this.props.body.bounds.min.x;<br/>        const height = this.props.body.bounds.max.y - this.props.body.bounds.min.y;<br/>        const x = this.props.body.position.x - width / 2;<br/>        const y = this.props.body.position.y - height / 2;<br/><br/>        const imageIterations = Math.ceil(width / height);<br/><br/>        return (<br/>            &lt;View<br/>                style={{<br/>                    position: 'absolute',<br/>                    left: x,<br/>                    top: y,<br/>                    width: width,<br/>                    height: height,<br/>                    overflow: 'hidden',<br/>                    flexDirection: 'row'<br/>                }}&gt;<br/>                {Array.apply(null, Array(imageIterations)).map((el, idx) =&gt; {<br/>                    return &lt;Image style={{ width: height, height: height }} key={idx} source={Images.floor} resizeMode="stretch" /&gt;<br/>                })}<br/>            &lt;/View&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="9506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我需要在这里解释一些事情:</p><ul class=""><li id="f020" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">我们曾经从传入的道具中获得<em class="oa">宽度</em>和<em class="oa">高度</em>。这变得很不方便，所以在这个组件中，我决定从底层的Matter.js主体中获取宽度和高度。所有物体都有边界，所以你用<em class="oa"> bounds.max.x减去bounds.min.x </em>来计算宽度和高度</li><li id="6be2" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated">我们的地板背景图像是正方形的，所以我们需要应用多个图像来覆盖地板。所需的迭代次数由<em class="oa"> Math.ceil(宽度/高度)</em>定义</li><li id="3e2a" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated">由于上面的计算可能会导致比我们需要的多一次迭代，我们必须将<em class="oa"> overflow: hidden </em>添加到容器中</li></ul><p id="4478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在说说我们的鸟…</p><p id="4bb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">小鸟图形是一组120x99的透明png文件。然而，我们最初的鸟，由一个矩形表示，是一个50x50点的正方形——如果我们只应用图像，它会变形。让我们通过添加一些常量来解决这个问题:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="f530" class="nm mh it nh b gy nn no l np nq">import { Dimensions } from 'react-native';<br/><br/>export default Constants = {<br/>    MAX_WIDTH: Dimensions.get("screen").width,<br/>    MAX_HEIGHT: Dimensions.get("screen").height,<br/>    GAP_SIZE: 220,<br/>    PIPE_WIDTH: 100,<br/>    BIRD_WIDTH: 50,<br/>    BIRD_HEIGHT: 41<br/>}</span></pre><p id="404a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们仍然将我们的<code class="fe ne nf ng nh b">BIRD_WIDTH</code>设置为50，但是将通过50 / 120(图像宽度)x 99(图像高度)= 41来计算<code class="fe ne nf ng nh b">BIRD_HEIGHT</code></p><p id="25a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要更新Bird.js，使其具有与我们的Floor.js相同的逻辑来获得宽度/高度:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="db11" class="nm mh it nh b gy nn no l np nq">import React, { Component } from "react";<br/>import { View, Image } from "react-native";<br/>import Images from './assets/Images';<br/><br/>export default class Bird extends Component {<br/><br/>    render() {<br/>        const width = this.props.body.bounds.max.x - this.props.body.bounds.min.x;<br/>        const height = this.props.body.bounds.max.y - this.props.body.bounds.min.y;<br/>        const x = this.props.body.position.x - width / 2;<br/>        const y = this.props.body.position.y - height / 2;<br/><br/><br/>        let image = Images['bird' + this.props.pose];<br/>        return (<br/>            &lt;Image<br/>                style={{<br/>                    position: "absolute",<br/>                    left: x,<br/>                    top: y,<br/>                    width: width,<br/>                    height: height,<br/>                }}<br/>                resizeMode="stretch"<br/>                source={image} /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="eca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还添加了对“姿势”道具的支持。我们稍后将使用动画制作鸟的翅膀。</p><p id="1f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们更新我们的<code class="fe ne nf ng nh b">App.js,</code>的<code class="fe ne nf ng nh b">setupWorld</code>方法，将这一切联系在一起:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="5bf0" class="nm mh it nh b gy nn no l np nq">setupWorld = () =&gt; {<br/>        let engine = Matter.Engine.create({ enableSleeping: false });<br/>        let world = engine.world;<br/>        world.gravity.y = 0.0;<br/><br/>        let bird = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 2, Constants.MAX_HEIGHT / 2, Constants.BIRD_WIDTH, Constants.BIRD_HEIGHT);<br/>        //bird.restitution = 20;<br/><br/>        let floor1 = Matter.Bodies.rectangle(<br/>            Constants.MAX_WIDTH / 2,<br/>            Constants.MAX_HEIGHT - 25,<br/>            Constants.MAX_WIDTH + 4,<br/>            50, { isStatic: true }<br/>        );<br/>        let floor2 = Matter.Bodies.rectangle(<br/>            Constants.MAX_WIDTH + (Constants.MAX_WIDTH / 2),<br/>            Constants.MAX_HEIGHT - 25,<br/>            Constants.MAX_WIDTH + 4,<br/>            50, { isStatic: true }<br/>        );<br/><br/>        Matter.World.add(world, [bird, floor1]);<br/>        Matter.Events.on(engine, 'collisionStart', (event) =&gt; {<br/>            var pairs = event.pairs;<br/><br/>            this.gameEngine.dispatch({ type: "game-over"});<br/><br/>        });<br/><br/>        return {<br/>            physics: { engine: engine, world: world },<br/>            floor1: { body: floor1, renderer: Floor },<br/>            floor2: { body: floor2, renderer: Floor },<br/>            bird: { body: bird, pose: 1, renderer: Bird},<br/>        }<br/>    }</span></pre><p id="ad65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意以下事项:</p><ul class=""><li id="d112" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">我们一开始就把世界引力改成了0。这阻止了鸟在开始时落下(待办事项#2)。我们将从我们的Physics.js中控制这个值</li><li id="c44d" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated">移除管道的初始化。我们也会在Physics.js中处理它。</li><li id="ce8a" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated">现在我们有两层楼。这在我们处理待办事项3时会很有用</li></ul><p id="c91e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给我们的游戏添加背景很容易。我们只是将它添加到我们的渲染方法中:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="f7e1" class="nm mh it nh b gy nn no l np nq">&lt;Image style={styles.backgroundImage} resizeMode="stretch" source={Images.background} /&gt;</span></pre><p id="c0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将它添加到App.js中的样式表中:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="5412" class="nm mh it nh b gy nn no l np nq">backgroundImage: {<br/>    position: 'absolute',<br/>    top: 0,<br/>    bottom: 0,<br/>    left: 0,<br/>    right: 0,<br/>    width: Constants.MAX_WIDTH,<br/>    height: Constants.MAX_HEIGHT<br/>},</span></pre><p id="9aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再来加一个分数指标。我已经安装了一个自定义字体<a class="ae ky" href="https://medium.com/react-native-training/react-native-custom-fonts-ccc9aacf9e5e" rel="noopener">，使用了本文</a>中概述的过程。在GameEngine定义之后，我在App.js的render方法中添加了以下代码:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="2682" class="nm mh it nh b gy nn no l np nq">&lt;Text style={styles.score}&gt;{this.state.score}&lt;/Text&gt;</span></pre><p id="7e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，将状态初始化更改为:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="aab2" class="nm mh it nh b gy nn no l np nq">this.state = {<br/>    running: true,<br/>    score: 0<br/>};</span></pre><p id="7d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并应用了以下样式</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="90eb" class="nm mh it nh b gy nn no l np nq">score: {<br/>    color: 'white',<br/>    fontSize: 72,<br/>    fontFamily: '04b_19',<br/>    position: 'absolute',<br/>    top: 50,<br/>    left: Constants.MAX_WIDTH / 2 - 24,<br/>    textShadowColor:'#222222',<br/>    textShadowOffset:{width: 2, height: 2},<br/>    textShadowRadius:2,<br/>},</span></pre><p id="1707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们去掉了Physics.js中的所有内容，除了返回实体部分。我们稍后将重新设计整个系统。</p><p id="dc79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切都做得很好，现在你应该有一个好看的，但非常稳定的游戏。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="50a9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">制作鸟翅膀的动画</h1><p id="19d0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可能还记得，我们在鸟组件中添加了一个姿势道具来控制鸟的图像。</p><p id="767e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了这样做，让我们修改一下我们的<code class="fe ne nf ng nh b">Physics.js</code>:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="ffb9" class="nm mh it nh b gy nn no l np nq">let tick = 0;<br/>let pose = 1<br/><br/>const Physics = (entities, { touches, time, dispatch }) =&gt; {<br/>    let engine = entities.physics.engine;<br/>    let world = entities.physics.world;<br/>    let bird = entities.bird.body;<br/><br/>    Matter.Engine.update(engine, time.delta);<br/><br/>    tick += 1;<br/>    if (tick % 5 === 0){<br/>        pose = pose + 1;<br/>        if (pose &gt; 3){<br/>            pose = 1;<br/>        }<br/>        entities.bird.pose = pose;<br/>    }<br/><br/>    return entities;<br/>};</span></pre><p id="e279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生的事情非常简单。每第五次滴答，我们增加鸟的姿势。如果姿态大于3，我们将其重置回1。</p><p id="b35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们应该有一个漂亮的动画翅膀的鸟。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7f48" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">移动地板</h1><p id="ce1e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们进入重力和管道之前，让我们先看看地板。移动的地板应该给用户一种我们的鸟在移动的错觉。</p><p id="eb16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的Physics.js中添加以下代码:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="4a57" class="nm mh it nh b gy nn no l np nq">Object.keys(entities).forEach(key =&gt; {<br/>    if (key.indexOf("floor") === 0){<br/>        if (entities[key].body.position.x &lt;= -1 * (Constants.MAX_WIDTH / 2)){<br/>            Matter.Body.setPosition( entities[key].body, {x: Constants.MAX_WIDTH + (Constants.MAX_WIDTH / 2), y: entities[key].body.position.y});<br/>        } else {<br/>            Matter.Body.translate( entities[key].body, {x: -2, y: 0});<br/>        }<br/>    }<br/>});<br/><br/>Matter.Engine.update(engine, time.delta);</span></pre><p id="489d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里所做的就是遍历我们的实体。如果实体名称以“floor”开头，我们将它们的x位置移动-2。如果这块地板移出屏幕，我们会快速将其向右移动一个屏幕。</p><p id="13ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该可以解决活动地板的问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4dff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">解决鸟的松弛问题</h1><p id="5303" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们之前的迭代中，当用户点击屏幕时，这只鸟表现出一些奇怪的行为。我们用Matter.js的applyForce方法去撞红方。这种方法的问题是，您可以对已经施加了力的对象施加力。</p><p id="4d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我意识到使用setVelocity是一个更好的解决方案。让我们将下面的代码添加到我们的<code class="fe ne nf ng nh b">Physics.js</code>中:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="2822" class="nm mh it nh b gy nn no l np nq">let hadTouches = false;<br/>touches.filter(t =&gt; t.type === "press").forEach(t =&gt; {<br/>    if (!hadTouches){<br/>        if (world.gravity.y === 0.0){<br/>            // first press really<br/>            world.gravity.y = 1.2;<br/><br/>        }<br/>        hadTouches = true;<br/>        //Matter.Body.applyForce( bird, bird.position, {x: 0.00, y: -0.05});<br/>        Matter.Body.setVelocity(bird, {<br/>          x: bird.velocity.x,<br/>          y: -10<br/>        });<br/>    }<br/>});</span></pre><p id="860e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几样东西需要打开:</p><ul class=""><li id="0531" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">touches变量包含触摸事件列表。使用多个手指可能会导致多个“按压”事件。为了防止这种情况，并且每次点击只撞击鸟一次，我们定义了<code class="fe ne nf ng nh b">hadTouches</code></li><li id="8dc4" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated">如果<code class="fe ne nf ng nh b">world.gravity.y</code>值为0，则表示游戏刚刚开始。我们应该把世界引力设为1.2</li><li id="5719" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated"><code class="fe ne nf ng nh b">setVelocity</code>与<code class="fe ne nf ng nh b">applyForce</code>非常相似，除了它限制了我们的鸟可以拥有的速度，所以它对这个游戏更好。</li></ul><p id="0b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们的鸟正在振翅高飞，重力已经施加。它甚至会撞到地板。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cd16" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">管道</h1><p id="7c8d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们之前的Pipe迭代是一个单一的矩形。对于这个游戏，我们想更有趣一点，所以让我们定义两个组件:管道(管道的核心)和管道顶部(惊喜，惊喜，管道的顶部)</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="93d1" class="nm mh it nh b gy nn no l np nq">import React, { Component } from "react";<br/>import { View, Image } from "react-native";<br/>import Images from "./assets/Images";<br/><br/>export default class Pipe extends Component {<br/>    render() {<br/>        const width = this.props.body.bounds.max.x - this.props.body.bounds.min.x;<br/>        const height = this.props.body.bounds.max.y - this.props.body.bounds.min.y;<br/>        const x = this.props.body.position.x - width / 2;<br/>        const y = this.props.body.position.y - height / 2;<br/><br/>        const pipeRatio = 160 / width; // 160 is the original image size<br/>        const pipeHeight = 33 * pipeRatio;<br/>        const pipeIterations = Math.ceil(height / pipeHeight);<br/><br/>        return (<br/>            &lt;View<br/>                style={{<br/>                    position: "absolute",<br/>                    left: x,<br/>                    top: y,<br/>                    width: width,<br/>                    height: height,<br/>                    overflow: 'hidden',<br/>                    flexDirection: 'column'<br/>                }}&gt;<br/>                {Array.apply(null, Array(pipeIterations)).map((el, idx) =&gt; {<br/>                    return &lt;Image style={{ width: width, height: pipeHeight }} key={idx} source={Images.pipeCore} resizeMode="stretch" /&gt;<br/>                })}<br/>            &lt;/View&gt;<br/>        );<br/>    }<br/>}</span><span id="151d" class="nm mh it nh b gy og no l np nq">import React, { Component } from "react";<br/>import { View, Image } from "react-native";<br/>import Images from "./assets/Images";<br/><br/>export default class PipeTop extends Component {<br/>    render() {<br/>        const width = this.props.body.bounds.max.x - this.props.body.bounds.min.x;<br/>        const height = this.props.body.bounds.max.y - this.props.body.bounds.min.y;<br/>        const x = this.props.body.position.x - width / 2;<br/>        const y = this.props.body.position.y - height / 2;<br/><br/><br/>        return (<br/>            &lt;Image<br/>                style={{<br/>                    position: "absolute",<br/>                    left: x,<br/>                    top: y,<br/>                    width: width,<br/>                    height: height,<br/>                }}<br/>                resizeMode="stretch"<br/>                source={Images.pipeTop}<br/>            /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="3df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得这些不需要任何解释。管道使用的是我们在地板上使用的瓷砖解决方案，但是这次是垂直的。管顶是一个无聊的，旧的，静态的形象。</p><p id="a00a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将管道添加到我们的世界，我们必须修改Physics.js。下面的代码片段可能看起来很吓人，但是不要担心，我会解释的！</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="5434" class="nm mh it nh b gy nn no l np nq">import Matter from "matter-js";<br/>import Constants from './Constants';<br/>import Pipe from './Pipe';<br/>import PipeTop from './PipeTop';<br/><br/>let tick = 0;<br/>let pose = 1;<br/>let pipes = 0;<br/><br/>export const randomBetween = (min, max) =&gt; {<br/>    return Math.floor(Math.random() * (max - min + 1) + min);<br/>}<br/><br/>export const generatePipes = () =&gt; {<br/>    let topPipeHeight = randomBetween(100, (Constants.MAX_HEIGHT / 2) - 100);<br/>    let bottomPipeHeight = Constants.MAX_HEIGHT - topPipeHeight - Constants.GAP_SIZE - 50;<br/><br/>    let sizes = [topPipeHeight, bottomPipeHeight]<br/><br/>    if (Math.random() &lt; 0.5) {<br/>        sizes = sizes.reverse();<br/>    }<br/><br/>    return sizes;<br/>}<br/><br/>export const resetPipeCount = () =&gt; {<br/>    pipes = 0;<br/>}<br/><br/>export const addPipesAtLocation = (x, world, entities) =&gt; {<br/>    let [pipe1Height, pipe2Height] = generatePipes();<br/><br/>    let pipeTopWidth = Constants.PIPE_WIDTH + 20;<br/>    let pipeTopHeight = (pipeTopWidth / 205) * 95; // original image is 205x95<br/><br/>    pipe1Height = pipe1Height - pipeTopHeight;<br/><br/>    let pipe1Top = Matter.Bodies.rectangle(<br/>        x,<br/>        pipe1Height + (pipeTopHeight / 2),<br/>        pipeTopWidth,<br/>        pipeTopHeight,<br/>        { isStatic: true }<br/>    );<br/><br/>    let pipe1 = Matter.Bodies.rectangle(<br/>        x,<br/>        pipe1Height / 2,<br/>        Constants.PIPE_WIDTH,<br/>        pipe1Height,<br/>        { isStatic: true }<br/>    );<br/><br/>    pipe2Height = pipe2Height - pipeTopHeight;<br/><br/>    let pipe2Top = Matter.Bodies.rectangle(<br/>        x,<br/>        Constants.MAX_HEIGHT - pipe2Height - 50 - (pipeTopHeight / 2),<br/>        pipeTopWidth,<br/>        pipeTopHeight,<br/>        { isStatic: true }<br/>    );<br/><br/>    let pipe2 = Matter.Bodies.rectangle(<br/>        x,<br/>        Constants.MAX_HEIGHT - (pipe2Height / 2) - 50,<br/>        Constants.PIPE_WIDTH, pipe2Height,<br/>        { isStatic: true }<br/>    );<br/><br/>    Matter.World.add(world, [pipe1, pipe1Top, pipe2, pipe2Top]);<br/><br/>    entities["pipe" + (pipes + 1)] = {<br/>        body: pipe1, scored: false, renderer: Pipe<br/>    }<br/><br/>    entities["pipe" + (pipes + 1) + "Top"] = {<br/>        body: pipe1Top, scored: false,  renderer: PipeTop<br/>    }<br/><br/>    entities["pipe" + (pipes + 2)] = {<br/>        body: pipe2, scored: false,  renderer: Pipe<br/>    }<br/><br/>    entities["pipe" + (pipes + 2) + "Top"] = {<br/>        body: pipe2Top, scored: false,  renderer: PipeTop<br/>    }<br/><br/>    pipes += 2;<br/>}<br/><br/>const Physics = (entities, { touches, time, dispatch }) =&gt; {<br/>    let engine = entities.physics.engine;<br/>    let world = entities.physics.world;<br/>    let bird = entities.bird.body;<br/><br/>    let hadTouches = false;<br/>    touches.filter(t =&gt; t.type === "press").forEach(t =&gt; {<br/>        if (!hadTouches){<br/>            if (world.gravity.y === 0.0){<br/>                // first press really<br/>                world.gravity.y = 1.2;<br/><br/>                addPipesAtLocation((Constants.MAX_WIDTH * 2) - (Constants.PIPE_WIDTH / 2), world, entities)<br/>                addPipesAtLocation((Constants.MAX_WIDTH * 3) - (Constants.PIPE_WIDTH / 2), world, entities)<br/><br/>            }<br/>            hadTouches = true;<br/>            //Matter.Body.applyForce( bird, bird.position, {x: 0.00, y: -0.05});<br/>            Matter.Body.setVelocity(bird, {<br/>              x: bird.velocity.x,<br/>              y: -10<br/>            });<br/>        }<br/>    });<br/><br/>    Object.keys(entities).forEach(key =&gt; {<br/>        if (key.indexOf("pipe") === 0 &amp;&amp; entities.hasOwnProperty(key)){<br/>            Matter.Body.translate( entities[key].body, {x: -2, y: 0});<br/><br/>            if (key.indexOf("Top") === -1 &amp;&amp; parseInt(key.replace("pipe", "")) % 2 === 0){<br/>                let pipeIndex = parseInt(key.replace("pipe", ""));<br/>                if (entities[key].body.position.x &lt; entities.bird.body.position.x &amp;&amp; !entities[key].scored){<br/>                    entities[key].scored = true;<br/>                    dispatch({ type: "score"})<br/>                }<br/><br/>                if (entities[key].body.position.x &lt;= -1 * (Constants.PIPE_WIDTH / 2)){<br/>                    addPipesAtLocation((Constants.MAX_WIDTH * 2) - (Constants.PIPE_WIDTH / 2), world, entities)<br/><br/>                    delete(entities["pipe" + (pipeIndex - 1)]);<br/>                    delete(entities["pipe" + (pipeIndex - 1) + "Top"]);<br/>                    delete(entities["pipe" + pipeIndex]);<br/>                    delete(entities["pipe" + pipeIndex + "Top"]);<br/>                }<br/>            }<br/><br/><br/>        } else if (key.indexOf("floor") === 0){<br/>            if (entities[key].body.position.x &lt;= -1 * (Constants.MAX_WIDTH / 2)){<br/>                Matter.Body.setPosition( entities[key].body, {x: Constants.MAX_WIDTH + (Constants.MAX_WIDTH / 2), y: entities[key].body.position.y});<br/>            } else {<br/>                Matter.Body.translate( entities[key].body, {x: -2, y: 0});<br/>            }<br/>        }<br/>    });<br/><br/>    Matter.Engine.update(engine, time.delta);<br/><br/>    tick += 1;<br/>    if (tick % 5 === 0){<br/>        pose = pose + 1;<br/>        if (pose &gt; 3){<br/>            pose = 1;<br/>        }<br/>        entities.bird.pose = pose;<br/>    }<br/><br/>    return entities;<br/>};<br/><br/>export default Physics;</span></pre><p id="d7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很大的包袱，但不要担心。</p><ul class=""><li id="ae3a" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">我们定义了一个<code class="fe ne nf ng nh b">pipes = 0</code>变量来跟踪我们世界中管道(集合)的数量。</li><li id="4615" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated">我们向我们的主世界公开了一个<code class="fe ne nf ng nh b">resetPipeCount</code>函数来重置活动管道，以防用户死亡。</li><li id="4bba" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated"><code class="fe ne nf ng nh b">generatePipes</code>和上次一样。它生成两组高度，它们之间有一组间隙。</li><li id="9b21" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated"><code class="fe ne nf ng nh b">addPipesAtLocation</code>在给定的x位置向我们的世界和实体添加一组管道。它将创建以下实体:<code class="fe ne nf ng nh b">pipe1</code>、<code class="fe ne nf ng nh b">pipe1Top</code>、<code class="fe ne nf ng nh b">pipe2</code>、<code class="fe ne nf ng nh b">pipe2Top</code>(当然，根据我们的pipes变量的值，名称会发生变化)</li><li id="3b47" class="nr ns it lb b lc ob lf oc li od lm oe lq of lu nw nx ny nz bi translated">当用户第一次点击屏幕时，我们添加了两组管道。一个在第三个屏幕的末尾，一个在第四个屏幕的末尾</li></ul><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="e885" class="nm mh it nh b gy nn no l np nq">addPipesAtLocation((Constants.MAX_WIDTH * 2) - (Constants.PIPE_WIDTH / 2), world, entities)<br/>addPipesAtLocation((Constants.MAX_WIDTH * 3) - (Constants.PIPE_WIDTH / 2), world, entities)</span></pre><ul class=""><li id="e0fb" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">每一个以单词“pipe”开头的实体，我们每一次都向左移动两个单位:</li></ul><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="e1bd" class="nm mh it nh b gy nn no l np nq">Matter.Body.translate( entities[key].body, {x: -2, y: 0});</span></pre><ul class=""><li id="806b" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">在每个底部管道(偶数管道id)上，我们检查鸟的位置是否已经通过管道的位置，如果是，我们发出一个“得分”事件:</li></ul><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="184e" class="nm mh it nh b gy nn no l np nq">if (entities[key].body.position.x &lt; entities.bird.body.position.x &amp;&amp; !entities[key].scored){<br/>    entities[key].scored = true;<br/>    dispatch({ type: "score"})<br/>}</span></pre><ul class=""><li id="cbb8" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">此外，在每个底部管道上，我们检查给定管道是否已经离开屏幕。如果是这样，我们删除整个管道集并生成一个新的管道集:</li></ul><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="b3df" class="nm mh it nh b gy nn no l np nq">if (entities[key].body.position.x &lt;= -1 * (Constants.PIPE_WIDTH / 2)){<br/>    addPipesAtLocation((Constants.MAX_WIDTH * 2) - (Constants.PIPE_WIDTH / 2), world, entities)</span><span id="ab7a" class="nm mh it nh b gy og no l np nq">delete(entities["pipe" + (pipeIndex - 1)]);<br/>    delete(entities["pipe" + (pipeIndex - 1) + "Top"]);<br/>    delete(entities["pipe" + pipeIndex]);<br/>    delete(entities["pipe" + pipeIndex + "Top"]);<br/>}</span></pre><p id="6781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就这样了！剩下唯一要做的就是修改我们的<code class="fe ne nf ng nh b">App.js</code>来监听“score”类型的事件:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="480d" class="nm mh it nh b gy nn no l np nq">onEvent = (e) =&gt; {<br/>    if (e.type === "game-over"){<br/>        //Alert.alert("Game Over");<br/>        this.setState({<br/>            running: false<br/>        });<br/>    } else if (e.type === "score"){<br/>        this.setState({<br/>            score: this.state.score + 1<br/>        })<br/>    }<br/>}</span></pre><p id="688e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完了。你现在有一个功能齐全的Flappy Bird类型的游戏，玩起来很有趣。</p><p id="43fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p><p id="49c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对源代码感兴趣，你可以<a class="ae ky" href="https://github.com/lepunk/react-native-videos/tree/master/FlappyBird" rel="noopener ugc nofollow" target="_blank">点击这里</a></p></div></div>    
</body>
</html>