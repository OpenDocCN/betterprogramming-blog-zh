<html>
<head>
<title>How to Write Smarter Routing With Express and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Express和Node.js写出更智能的路由</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-smarter-routing-with-express-and-node-js-4cc53bbc55e5?source=collection_archive---------0-----------------------#2020-05-05">https://betterprogramming.pub/how-to-write-smarter-routing-with-express-and-node-js-4cc53bbc55e5?source=collection_archive---------0-----------------------#2020-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c918" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让节点文件系统来完成繁重的工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/24fb206dff7c76173c1fc8d68aa9545b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w639o8sK4Z4ri_QKakbhxA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@youxventures?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">优X创投</a>在<a class="ae ky" href="https://unsplash.com/@youxventures?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ea2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>是<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>的web应用框架。它提供了各种特性，使web应用程序的开发变得快速而简单，如果只使用Node，这项任务将花费更多的时间。</p><p id="6234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Express有许多方法可以创建和管理路由，最简单直接的方法是使用<code class="fe lv lw lx ly b">delete</code>、<code class="fe lv lw lx ly b">get</code>、<code class="fe lv lw lx ly b">post</code>和<code class="fe lv lw lx ly b">put</code>方法。它们中的每一个都被映射到对应的请求<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener ugc nofollow" target="_blank"> HTTP动词</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们有三个路由(<code class="fe lv lw lx ly b">/</code>、<code class="fe lv lw lx ly b">/home</code>、<code class="fe lv lw lx ly b">/about</code>)，每一个都有两个不同的HTTP动词(<code class="fe lv lw lx ly b">get</code>、<code class="fe lv lw lx ly b">post</code>)和它自己的逻辑，向客户端发送一个唯一的文本</p><p id="c7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个小例子中可以看出，当路由数量增加时，这种方法会变得非常混乱。</p><p id="9c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://expressjs.com/en/4x/api.html#app.route" rel="noopener ugc nofollow" target="_blank">route</a></code>方法和链接到相等路径的方法，有一种方法可以使代码更好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样我们可以使代码更短一点，但是仍然很混乱，因为我们在同一个文件中有多个<code class="fe lv lw lx ly b">route</code>路径。</p><p id="b730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的下一步是为每个路径创建一个单独的文件，并使用Express <code class="fe lv lw lx ly b"><a class="ae ky" href="https://expressjs.com/en/4x/api.html#router" rel="noopener ugc nofollow" target="_blank">Router</a></code> <a class="ae ky" href="https://expressjs.com/en/4x/api.html#router" rel="noopener ugc nofollow" target="_blank"> </a>对象。<code class="fe lv lw lx ly b">Router</code>对象是中间件和路由的独立实例。您可以将它视为一个迷你应用程序，只能够执行中间件和路由功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="03df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们在主文件<code class="fe lv lw lx ly b">index.js</code>中有了更干净的代码，每条路由都在自己的文件中定义。除了<code class="fe lv lw lx ly b">Route</code>对象之外，我们还利用了快速方法<code class="fe lv lw lx ly b"><a class="ae ky" href="https://expressjs.com/en/4x/api.html#app.use" rel="noopener ugc nofollow" target="_blank">use</a></code>将路径映射到它的配置文件。</p><p id="7167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比我们在前面的例子中看到的要好得多，但我仍然可以看到一些问题，比如每个路由文件中的代码重复，主要是，每次我们向应用程序添加新的路由文件时，我们都需要更改主文件来映射文件的路径。当我们有大量的路由时，我们有同样的问题:主文件代码变得更大更乱。</p><p id="c299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决第二个问题，我们可以创建一个单独的文件来将每个路径映射到它的route文件，并在主文件中执行一个简单的<code class="fe lv lw lx ly b">require</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f9a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">routes文件夹索引文件从主文件接收应用程序实例，并进行路径映射。主文件利用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">立即调用的函数表达式</a>来请求并执行通过所创建的应用程序的路线索引文件。现在我们有了一个更干净的主文件，但是我们仍然有一个问题，那就是需要手动将每个路径映射到它的文件。</p><p id="20ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们能让Node循环遍历<code class="fe lv lw lx ly b">routes</code>文件夹的文件并进行映射，它可以帮助我们做得更好。为了实现这一点，我们将利用节点的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://nodejs.org/api/fs.html#fs_fs_readdirsync_path_options" rel="noopener ugc nofollow" target="_blank">fs.readdirSync</a></code>。此方法用于同步读取给定目录的内容。方法返回一个包含目录中所有文件名或对象的数组。</p><p id="717b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而你可能会问，<em class="mb">路径呢？</em>如果我们没有一种自动的方法来发现每个路由文件的路径，我们仍然必须为每个添加的路由编辑列表。我认为这个问题有两种解决方案:使用约定优于配置，或者在路由文件中添加一个带有路径的导出。</p><p id="3359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用约定胜于配置，我们将使用文件名作为路由路径。为了更加安全并删除潜在的有问题的字符，我们将使用<a class="ae ky" href="https://lodash.com/docs/4.17.15#snakeCase" rel="noopener ugc nofollow" target="_blank"> Lodash </a>将文件名转换为<a class="ae ky" href="https://en.wikipedia.org/wiki/Snake_case" rel="noopener ugc nofollow" target="_blank"> snakeCase </a>，其中字符串由下划线分隔。</p><p id="88af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的另一个改变是只在routes配置文件中使用<code class="fe lv lw lx ly b">Router</code>对象，这使得route代码更简单并避免代码重复。</p><p id="f1e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们将使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://nodejs.org/api/path.html#path_path_join_paths" rel="noopener ugc nofollow" target="_blank">path.join</a></code>节点方法使我们的代码跨平台，因为基于Windows和Linux的系统使用不同的路径名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，另一个选项是在路由文件中导出所需的路径名，并在路由配置文件中使用该信息。</p><p id="eade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们必须在route文件中导出一个带有path和config键的对象。在这种配置中，我强烈建议您使用filename path方法作为后备，以避免在忘记添加路径导出时出现错误。这样，我们有一个额外的好处:一个在两种情况下都能工作的解决方案。</p><p id="fdfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的最后一个例子中，我们将把home route路径改为<code class="fe lv lw lx ly b">my_home</code>,并保持about route文件不变。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="3fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。这是我们的智能快速路由器配置。通过使用这种配置——以及像<a class="ae ky" href="https://pm2.keymetrics.io/" rel="noopener ugc nofollow" target="_blank"> PM2 </a>或N <a class="ae ky" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank"> odemon </a>这样的解决方案来监视你的应用程序文件夹并在文件改变时自动重启——你所要做的就是在<code class="fe lv lw lx ly b">routes</code>文件夹中添加一个文件来添加一个新的路由。</p><p id="e7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，还有很多改进的空间，比如错误检查，但是这种特性我将留给您，这样您可以习惯所提供的代码并练习您的编码技能，同时尝试实现您认为在我的示例中没有实现的任何特性。为了让您的旅程更加轻松，我在<a class="ae ky" href="https://codesandbox.io/s/articlemediumexpressrouting-q2fb8" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>中提供了最终代码。请随意叉和工作。</p><p id="d32a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你从这篇文章中学到了一些有用的东西。下次见！</p></div></div>    
</body>
</html>