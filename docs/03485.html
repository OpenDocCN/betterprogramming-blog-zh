<html>
<head>
<title>Using Express Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express中间件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-express-middleware-62476ade6243?source=collection_archive---------13-----------------------#2020-02-12">https://betterprogramming.pub/using-express-middleware-62476ade6243?source=collection_archive---------13-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df40" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们看看如何使用应用程序和路由级中间件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f25e1f21b44a6ed8d67e1ace0a8fc7bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmM7UkggDseUdCvBtXNKGw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@duganphoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">康纳·杜根</a>在<a class="ae ky" href="https://unsplash.com/s/photos/middle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kz la lb"><p id="42a5" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">中间件功能是可以访问请求对象(<code class="fe lz ma mb mc b">req</code>)、响应对象(<code class="fe lz ma mb mc b">res</code>)以及应用程序请求-响应周期中的下一个中间件功能的功能— <a class="ae ky" href="https://expressjs.com/en/guide/using-middleware.html" rel="noopener ugc nofollow" target="_blank">快递单据</a></p></blockquote><p id="9d6a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">在这一部分中，我们将看看Express中间件功能是做什么，以及我们如何使用它们。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="2d0a" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">中间件的特点</h1><p id="90ec" class="pw-post-body-paragraph lc ld it lf b lg nf ju li lj ng jx ll md nh lo lp me ni ls lt mf nj lw lx ly im bi translated">中间件功能可以运行任何代码，对请求和响应对象进行更改，结束请求-响应循环，并调用堆栈中的下一个中间件。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="d6d7" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">应用层中间件</h1><p id="f7c3" class="pw-post-body-paragraph lc ld it lf b lg nf ju li lj ng jx ll md nh lo lp me ni ls lt mf nj lw lx ly im bi translated">当任何路由被调用时，我们可以通过将它们作为回调传递给<code class="fe lz ma mb mc b">app.use</code>方法来运行中间件函数。</p><p id="aec3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">如果我们想让一个中间件函数只在一个请求方法的请求被调用时被调用，那么我们可以把它作为回调传递给<code class="fe lz ma mb mc b">app.METHOD</code>方法，这里<code class="fe lz ma mb mc b">METHOD</code>是<code class="fe lz ma mb mc b">get</code>、<code class="fe lz ma mb mc b">post</code>、<code class="fe lz ma mb mc b">put</code>、<code class="fe lz ma mb mc b">delete</code>等等。</p><p id="634e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">例如，我们可以编写一个中间件函数，并将其传递给<code class="fe lz ma mb mc b">app.use</code>来记录一个请求的请求方法，如下所示:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="4d15" class="no mo it mc b gy np nq l nr ns">const express = require('express')<br/>const app = express()<br/>app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="c113" class="no mo it mc b gy nt nq l nr ns">app.use((req, res, next) =&gt; {<br/>  console.log(req.method);<br/>  next();<br/>});</span><span id="97f2" class="no mo it mc b gy nt nq l nr ns">app.get('/', (req, res) =&gt; {<br/>  res.json();<br/>})</span><span id="355d" class="no mo it mc b gy nt nq l nr ns">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="041f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">然后，当我们向<code class="fe lz ma mb mc b">/</code>发出get请求时，我们应该将<code class="fe lz ma mb mc b">GET</code>记录下来。</p><p id="1ef4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">我们可以将中间件功能限制为只在GET请求上运行，并限制在路径<code class="fe lz ma mb mc b">/</code>上，方法是:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="f09e" class="no mo it mc b gy np nq l nr ns">const express = require('express')<br/>const app = express()<br/>app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="324b" class="no mo it mc b gy nt nq l nr ns">app.get('/', (req, res, next) =&gt; {<br/>  console.log(req.method);<br/>  next();<br/>});</span><span id="2b4e" class="no mo it mc b gy nt nq l nr ns">app.get('/', (req, res) =&gt; {<br/>  res.json();<br/>})</span><span id="6c35" class="no mo it mc b gy nt nq l nr ns">app.post('/', (req, res) =&gt; {<br/>  res.json();<br/>})</span><span id="caf9" class="no mo it mc b gy nt nq l nr ns">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="32d8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">然后，当我们向<code class="fe lz ma mb mc b">/</code>路径发出GET请求时，我们只看到记录的<code class="fe lz ma mb mc b">GET</code>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="3377" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">运行一系列中间件功能</h1><p id="9269" class="pw-post-body-paragraph lc ld it lf b lg nf ju li lj ng jx ll md nh lo lp me ni ls lt mf nj lw lx ly im bi translated">我们可以使用<code class="fe lz ma mb mc b">next</code>方法调用系列中的下一个中间件函数，因此我们可以使用它将中间件函数调用链接在一起。</p><p id="e690" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">例如，如果我们有…</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="8c39" class="no mo it mc b gy np nq l nr ns">const express = require('express')<br/>const app = express()<br/>app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="1adf" class="no mo it mc b gy nt nq l nr ns">app.use(<br/>  (req, res, next) =&gt; {<br/>    console.log('middleware 1 called');<br/>    next();<br/>  },<br/>  (req, res, next) =&gt; {<br/>    console.log('middleware 2 called');<br/>    next();<br/>  }<br/>);</span><span id="51eb" class="no mo it mc b gy nt nq l nr ns">app.get('/', (req, res) =&gt; {<br/>  res.json();<br/>})</span><span id="55a3" class="no mo it mc b gy nt nq l nr ns">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="af47" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">…然后我们从每个中间件的<code class="fe lz ma mb mc b">console.log</code>输出中看到:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="9520" class="no mo it mc b gy np nq l nr ns">middleware 1 called<br/>middleware 2 called</span></pre><p id="be0b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">如果我们在中间件中发送一个响应，那么下一个就不会被调用。例如，如果我们有:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="eacf" class="no mo it mc b gy np nq l nr ns">const express = require('express')<br/>const app = express()<br/>app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))<br/>app.get('/',<br/>  (req, res, next) =&gt; {<br/>    next()<br/>  },<br/>  (req, res, next) =&gt; {<br/>    res.send('Second middleware');<br/>  }<br/>)</span><span id="f2ee" class="no mo it mc b gy nt nq l nr ns">app.get('/',  (req, res, next) =&gt; {<br/>  res.end();<br/>})</span><span id="b127" class="no mo it mc b gy nt nq l nr ns">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="2325" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">然后，当我们向<code class="fe lz ma mb mc b">/</code>发出请求时，我们得到输出<code class="fe lz ma mb mc b">‘Second middleware’</code>。</p><p id="75c1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">我们的路线管理员在…</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="1da2" class="no mo it mc b gy np nq l nr ns">app.get('/', function (req, res, next) {<br/>  res.end();<br/>})</span></pre><p id="32a6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">…没有被呼叫。</p><p id="4cb9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">我们可以调用<code class="fe lz ma mb mc b">next</code>，如下所示，直接进入我们的路由处理器，绕过其他中间件功能:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="5da0" class="no mo it mc b gy np nq l nr ns">next('route');</span></pre><p id="2db9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="7cf1" class="no mo it mc b gy np nq l nr ns">const express = require('express')<br/>const app = express()<br/>app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))<br/>app.get('/:id',<br/>  (req, res, next) =&gt; {<br/>    if (req.params.id === '0') {<br/>      next('route');<br/>      return;<br/>    }<br/>    next();<br/>  },<br/>  (req, res, next) =&gt; {<br/>    res.send('Second middleware');<br/>  }<br/>)</span><span id="f750" class="no mo it mc b gy nt nq l nr ns">app.get('/:id', (req, res, next) =&gt; {<br/>  res.end(req.params.id);<br/>})</span><span id="a057" class="no mo it mc b gy nt nq l nr ns">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="d3b1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">然后，当我们向<code class="fe lz ma mb mc b">/0</code>发出请求时，我们得到<code class="fe lz ma mb mc b">0</code>。否则，我们输出<code class="fe lz ma mb mc b">‘Second Middleware’</code>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="93a2" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">路由器级中间件</h1><p id="6d9a" class="pw-post-body-paragraph lc ld it lf b lg nf ju li lj ng jx ll md nh lo lp me ni ls lt mf nj lw lx ly im bi translated">路由器级中间件的工作方式与应用程序级中间件相同，但是它们被绑定到<code class="fe lz ma mb mc b">express.Router()</code>的实例，而不是<code class="fe lz ma mb mc b">express</code>实例。</p><p id="3194" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">例如，我们可以如下使用它:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="6271" class="no mo it mc b gy np nq l nr ns">const express = require('express')<br/>const app = express()<br/>const router = express.Router();</span><span id="8163" class="no mo it mc b gy nt nq l nr ns">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="51dd" class="no mo it mc b gy nt nq l nr ns">router.use((req, res, next) =&gt; {<br/>  req.requestTime = new Date();<br/>  next();<br/>})</span><span id="52be" class="no mo it mc b gy nt nq l nr ns">router.get('/', (req, res, next) =&gt; {<br/>  res.json(req.requestTime);<br/>})</span><span id="7ff5" class="no mo it mc b gy nt nq l nr ns">app.use('/', router);</span><span id="7195" class="no mo it mc b gy nt nq l nr ns">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="2d0b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">然后，当我们向<code class="fe lz ma mb mc b">/</code>路由发出请求时，我们得到时间戳作为输出。</p><p id="d5b3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">链接中间件和跳过路由的工作方式与应用级中间件相同。例如，我们可以编写以下代码来链接中间件:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="30ae" class="no mo it mc b gy np nq l nr ns">const express = require('express')<br/>const app = express()<br/>const router = express.Router();</span><span id="58e4" class="no mo it mc b gy nt nq l nr ns">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="56e2" class="no mo it mc b gy nt nq l nr ns">router.use(<br/>  (req, res, next) =&gt; {<br/>    console.log('middleware 1 called');<br/>    next();<br/>  },<br/>  (req, res, next) =&gt; {<br/>    console.log('middleware 2 called');<br/>    next();<br/>  }<br/>)</span><span id="fb48" class="no mo it mc b gy nt nq l nr ns">router.get('/', (req, res, next) =&gt; {<br/>  res.json();<br/>})</span><span id="dd34" class="no mo it mc b gy nt nq l nr ns">app.use('/', router);</span><span id="7477" class="no mo it mc b gy nt nq l nr ns">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="c404" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">然后我们从每个路由中间件的<code class="fe lz ma mb mc b">console.log</code>输出中看到:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="7d42" class="no mo it mc b gy np nq l nr ns">middleware 1 called<br/>middleware 2 called</span></pre><p id="7f74" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">我们可以使用<code class="fe lz ma mb mc b">next('route')</code>跳到路线，如下所示:</p><pre class="kj kk kl km gt nk mc nl nm aw nn bi"><span id="25ef" class="no mo it mc b gy np nq l nr ns">const express = require('express')<br/>const app = express()<br/>const router = express.Router();</span><span id="6a94" class="no mo it mc b gy nt nq l nr ns">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="27f4" class="no mo it mc b gy nt nq l nr ns">router.get('/:id',<br/>  (req, res, next) =&gt; {<br/>    if (req.params.id === '0') {<br/>      next('route');<br/>      return;<br/>    }<br/>    next();<br/>  },<br/>  (req, res, next) =&gt; {<br/>    res.send('Second middleware');<br/>  }<br/>)</span><span id="513f" class="no mo it mc b gy nt nq l nr ns">router.get('/:id', (req, res, next) =&gt; {<br/>  res.end(req.params.id);<br/>})</span><span id="6f42" class="no mo it mc b gy nt nq l nr ns">app.use('/', router);</span><span id="0b85" class="no mo it mc b gy nt nq l nr ns">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="017c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">然后当我们向<code class="fe lz ma mb mc b">/0</code>发出请求时，我们得到<code class="fe lz ma mb mc b">0</code>。否则，我们输出<code class="fe lz ma mb mc b">‘Second Middleware’</code>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="1081" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="65f3" class="pw-post-body-paragraph lc ld it lf b lg nf ju li lj ng jx ll md nh lo lp me ni ls lt mf nj lw lx ly im bi translated">使用快速中间件很简单。我们可以将它们传递给<code class="fe lz ma mb mc b">app.use</code>以使中间件为所有请求方法运行，或者传递给<code class="fe lz ma mb mc b">app.METHOD</code>以使它们为给定方法运行。</p><p id="65db" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">我们可以调用<code class="fe lz ma mb mc b">next</code>调用下一个中间件，调用<code class="fe lz ma mb mc b">next('route')</code>直接从一个中间件调用路由处理器。</p><p id="639d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">除了分别绑定到<code class="fe lz ma mb mc b">express.Router()</code>和<code class="fe lz ma mb mc b">express()</code>之外，一切都适用于路由和应用级中间件。</p></div></div>    
</body>
</html>