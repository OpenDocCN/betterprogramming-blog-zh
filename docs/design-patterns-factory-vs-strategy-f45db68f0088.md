# 设计模式——工厂与战略

> 原文：<https://betterprogramming.pub/design-patterns-factory-vs-strategy-f45db68f0088>

## 了解实现差异

![](img/1f03f6de607f09e72b0dac054e5a2163.png)

[钱利奥](https://www.freeimages.com/es/photographer/chamleo-61920)在[免费图片](https://www.freeimages.com/)上的照片

几天前我意识到一些问题可以同时使用设计模式工厂和策略来解决，然后我开始思考这些模式实现中的真正区别是什么。

简而言之，两种实现都会根据我们的需要在运行时返回不同的对象实例，它们可以用来解决业务问题或执行算法。

由于我总是更喜欢直接进入动手部分，而不是理论解释，我将开始创建一个示例，重构它，实现这两种模式来改进代码，最后，我们可以研究其他细节。

# 这个例子

这个应用程序有一个负责运送产品的组件，它使用一个非常简单的实现，这个实现基于一个类，每个类有一个方法，正如我们在下面看到的。

这种实现是有效的，但并不理想，因为如果我们添加更多不同类型的运输，类会变得很大，并且每次我们需要调整或更改任何现有的运输方式时，都会更改相同的类。

这肯定会成为未来的瓶颈。

为了改进代码，我们可以开始将类分成多个其他类，因为它们基本上只用于以不同的方式运输产品，我们可以创建一个接口，为每种运输创建一个类，并确保这些类实现接口并实现方法来运输产品

现在，对于每一种新的 shipping 类型，我们只需要创建一个新的类，实现接口，并实现 Ship 方法，而不必更改任何其他现有的 shipping 类。

如果我们需要改变现有的运输方式，我们不需要改变同样的大类了，这很好。

但无论如何，它仍然可以改进，想象一下我们想要避免考虑我们应该使用哪个类，而不是我们更喜欢有一个组件来为我们处理所有的创建过程，在这种情况下，我们可以使用工厂。

# 工厂

当使用工厂设计模式时，组件将根据提供的信息处理实例化过程，并为我们返回具体类的实例，而不是实例化具体类。

在这种情况下，我使用一个 enum 来定义我希望拥有哪种类型的 shipping 实例，而`ShippingFactory`类将负责根据输入实例化正确的类，并将其返回给调用者:

消费者可以使用工厂，如下所示:

现在想象一下，我们希望只有一个组件来发布产品，但是我们需要根据调用方法的组件来发布产品，在这种情况下，我们可以使用策略

# **策略**

当使用一个策略时，我们有策略地在运行时将一个具体的类直接注入到组件中。

我们可以创建一个策略类，它实现相同的接口，并调用注入的具体类实现的方法。

使用这种方法，我们不需要提供任何输入参数，我们只需要在调用组件之前注入正确的实例，策略类将执行它:

消费者可以通过这种简单的方法使用该策略:

# 考虑

尽管我们可以在实现中找到一些相似之处，但它们有许多不同之处。

工厂模式是一种创造模式，而战略是一种行为模式，这意味着它们是使用不同的方法创建的。

我们可以使用这两种方法来解决现实生活中的问题，但是在使用它们之前，我们可以检查哪种方法更简单，更有效地解决我们的问题。

关于这些模式有很多信息来源，对于你可以使用的所有其他相关模式，我真的很喜欢在[重构大师](https://refactoring.guru/design-patterns)那里查看它们。

我在这里的目的是展示模式的一个非常简单的实现，并讨论明显的区别，对我来说它必须是简单的。

如果你认为我可以给这篇文章添加更多的信息，请随时联系我，感谢你的阅读。