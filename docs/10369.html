<html>
<head>
<title>Build a TCP Connection Pool From Scratch With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go从头开始构建TCP连接池</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-tcp-connection-pool-from-scratch-with-go-d7747023fe14?source=collection_archive---------0-----------------------#2022-01-03">https://betterprogramming.pub/build-a-tcp-connection-pool-from-scratch-with-go-d7747023fe14?source=collection_archive---------0-----------------------#2022-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df4a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这里有一些关于如何处理可伸缩软件系统之间的连接的基本想法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/caae8edab20735b62a63c14e53a3189d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQ4M5Rrt34VlA50qfq_NQQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mvdheuvel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马腾·范登赫维尔</a>在Unsplash上拍摄</p></figure><p id="01d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我作为初级软件工程师的入门任务是用Go实现一个用户注册系统。</p><p id="b642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来很简单，对吧？但是，存在性能要求和设计限制。</p><p id="3978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我需要将所有业务逻辑放在一个TCP服务器中，并让一个面向客户端的HTTP服务器通过网络连接与之交互。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/c3aa572ac4a5bc3e48013aa8b015e3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_EvWPcNnUQaqJPbO.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">HTP-TCP服务器架构</p></figure><p id="d257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的是，我不允许使用任何<strong class="lb iu">远程过程调用(RPC) </strong>框架，比如Go的<code class="fe lw lx ly lz b"><a class="ae ky" href="https://pkg.go.dev/net/rpc" rel="noopener ugc nofollow" target="_blank">net/rpc</a></code>或者Google的<code class="fe lw lx ly lz b"><a class="ae ky" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank">gRPC</a></code>。我需要创建自己的逻辑来处理两台服务器之间的连接。</p><p id="636f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，整个系统预计支持每秒1000个并发<strong class="lb iu"> </strong> HTTP请求和3000个登录请求，没有缓存。数据库中还需要有1000万现有用户。</p><p id="41c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">破解这个入口任务的关键是正确管理HTTP和TCP服务器之间的网络连接。如果可用的连接太少，您最终会得到缓慢的请求。如果太多，您的服务器将会面临连接问题。</p><p id="7cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将与您分享我是如何构建一个自定义连接池来实现正确的平衡的。我将用代码片段解释设计概述。我们开始吧！🏃‍♂️</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="909c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">什么是连接池？</h1><p id="9348" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">连接池是服务器中的一组缓存连接，将来可以再次使用。</p><p id="af30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，打开一个新的网络连接是昂贵的。以TCP连接为例，客户端和服务器需要执行<a class="ae ky" href="https://www.techopedia.com/definition/10339/three-way-handshake" rel="noopener ugc nofollow" target="_blank">三次握手</a>。这是一种昂贵的操作，会消耗数据带宽并导致往返延迟。</p><p id="f0bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用连接池，我们可以让连接在等待处理另一个请求时保持空闲，而不是在使用后关闭它。这节省了创建新连接所需的资源。</p><p id="eb7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，任何东西太多都是不好的。维护打开的连接也会占用服务器资源。在开放连接和重用旧连接之间需要一个恰当的平衡。</p><p id="93b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连接池需要知道何时创建、保持或删除连接。</p><p id="9c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将重点关注用两个核心方法构建一个简单的连接池，<code class="fe lw lx ly lz b">get</code>和<code class="fe lw lx ly lz b">put</code>。</p><p id="516a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">put</code>的方法很简单。一旦服务器完成了一个连接，连接池就试图“保存”空闲的连接。如果池已经满了，它会关闭连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/736a406b39ef424773dd7a387aa0db42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/0*nVoYpHHllqgdu-t4.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">put逻辑</p></figure><p id="3f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">get</code>方法稍微复杂一些。除了重用空闲连接和打开新连接之外，如果连接不能立即返回，该方法还可以将连接请求排队。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b1858b6a0a3f129cf550e11a5d548b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/0*3AD5ZuycOsrgeaBt.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取逻辑</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5b71" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Go中的TCP连接</h1><p id="3f49" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在我们开始之前(双关语)，让我展示一些关于如何在Go中用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://pkg.go.dev/net" rel="noopener ugc nofollow" target="_blank">net</a></code>包建立TCP连接的快速代码片段。</p><p id="3418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://pkg.go.dev/net#Dial" rel="noopener ugc nofollow" target="_blank">Dial</a></code>函数创建一个从客户端到服务器的连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="53cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，<code class="fe lw lx ly lz b"><a class="ae ky" href="https://pkg.go.dev/net#Listen" rel="noopener ugc nofollow" target="_blank">Listen</a></code>函数启动一个连接服务器。<code class="fe lw lx ly lz b">Accept</code>方法等待传入的请求并返回一个连接。我们可以用Goroutines同时处理多个请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="47c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从底层连接中读取数据。<code class="fe lw lx ly lz b"><a class="ae ky" href="https://pkg.go.dev/bufio#Reader.ReadBytes" rel="noopener ugc nofollow" target="_blank">bufio.ReadBytes</a></code>和<code class="fe lw lx ly lz b"><a class="ae ky" href="https://pkg.go.dev/io#ReadFull" rel="noopener ugc nofollow" target="_blank">io.ReadFull</a></code>是许多方法中的两种。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将数据写入连接甚至更容易。我们可以使用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://pkg.go.dev/net#IPConn.Write" rel="noopener ugc nofollow" target="_blank">conn.Write</a></code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="14e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些功能足够让我们入门了！现在，我们可以继续构建我们的功能性TCP连接池。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="26a3" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">建造游泳池</h1><p id="1e5e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在其核心，连接池必须有两个配置设置:<code class="fe lw lx ly lz b">maxIdleCount</code>和<code class="fe lw lx ly lz b">maxOpenCount</code>。</p><p id="98af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">maxOpenCount</code>限制连接池可以打开的连接总数，而<code class="fe lw lx ly lz b">maxIdleCount</code>控制连接池中空闲连接的数量。这两个设置一起设置了打开新连接和重用旧连接之间的平衡。</p><p id="0e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我的连接池作为Go结构的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我使用了<code class="fe lw lx ly lz b">tcpConn</code>来表示TCP连接。它是一个定制的包装器，包含底层的<code class="fe lw lx ly lz b"><a class="ae ky" href="https://pkg.go.dev/net#Conn" rel="noopener ugc nofollow" target="_blank">net.Conn</a></code>和对池的引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="aa35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以开始编写我们的<code class="fe lw lx ly lz b">get</code>和<code class="fe lw lx ly lz b">put</code>方法了。</p><p id="0354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">put</code>方法中，我们首先检查连接池是否达到了空闲连接的最大数量。如果是，我们关闭连接并递减<code class="fe lw lx ly lz b">numOpen</code>计数器。如果没有，我们将连接放入池中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ff06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe lw lx ly lz b">get</code>方法很棘手，因为它需要在连接请求不能立即满足时对它们进行排队。</p><p id="b86b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以利用Go的渠道来满足这个要求。让我介绍一个叫做<code class="fe lw lx ly lz b">connRequest</code>的新结构。它包含一个在请求完成时接收<code class="fe lw lx ly lz b">tcpConn</code>的通道。然后，我们还向池中添加了一个名为<code class="fe lw lx ly lz b">requestChan</code>的新字段，这是一个连接请求队列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这仍然令人困惑，请不要担心。让我们一部分一部分地实现<code class="fe lw lx ly lz b">get</code>方法。首先，我们处理池中有空闲连接的最简单的情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，当不再有空闲连接并且无法打开更多连接时，我们创建一个连接请求。同样，我们利用go通道来创建请求队列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c5fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们将连接请求发送到队列中，代码就会阻塞，直到其中一个案例完成。如果连接被接收，我们返回它。否则，我们返回一个错误。</p><p id="dd3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当不再有空闲连接并且打开的连接数量少于允许的最大数量时，我们打开一个新的连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d7af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我是如何在创建新的TCP连接之前递增<code class="fe lw lx ly lz b">numOpen</code>计数器的。这是因为打开新连接可能会有延迟。为了不阻塞其他请求，代码首先假定一个成功的连接，这样它就可以释放互斥体。如果连接未能打开，我们递减计数器并返回一个错误。</p><p id="bb95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就结束了我们的<code class="fe lw lx ly lz b">get</code>方法。现在的问题是，应该如何满足连接请求？</p><p id="d919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将创建一个新方法<code class="fe lw lx ly lz b">handleConnectionRequest</code>。它作为一个<strong class="lb iu">工人</strong>应该永远在一个单独的goroutine中运行。让我来演示一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作线程不断地监听队列中的传入请求。当有一个，它开始一个3秒钟的超时。然后，它尝试满足请求，直到超时或请求完成。</p><p id="a739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况和我们之前的<code class="fe lw lx ly lz b">get</code>逻辑很像。我们只需要将连接传递到<code class="fe lw lx ly lz b">connChan</code>中，并在成功时将<code class="fe lw lx ly lz b">requestDone</code>设置为true。如果不成功，我们进入下一个循环，并重试该过程，直到超时。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ee47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当工人就位后，请求连接的goroutine将得到来自<code class="fe lw lx ly lz b">connChan</code>和<code class="fe lw lx ly lz b">errChan</code>的响应。最后，我们可以创建一个函数来初始化池，并在一个goroutine中启动worker。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="bec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！这就结束了我们对TCP连接池的讨论。还有一个未解决的问题，我们如何正确地从TCP连接中读取数据？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="db37" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">协议</h1><p id="1f52" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">是的，我确实跟你说过<code class="fe lw lx ly lz b">ReadFull</code>和<code class="fe lw lx ly lz b">ReadBytes</code>。这些读取函数的问题是我们无法预先知道<strong class="lb iu">我们需要读取多少</strong>数据。</p><p id="0b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以<code class="fe lw lx ly lz b">ReadFull</code>为例。我们需要传递给它一个预先定义好的数据长度的字节片，在读取之前接收方是不知道的。此外，创建一个非常大的切片是对空间的浪费，并且希望它能覆盖所有可能长度的数据。</p><p id="b451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">ReadBytes</code>怎么样？使用特定字符作为分隔符有漏洞。你永远不知道这个字符什么时候会出现在你的数据中间。<strong class="lb iu">不能保证</strong>所选择的分隔符标记了字节流的结束。</p><p id="f589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，我们需要一种协议，它能为传输多少数据提供强有力的保证。同时，它需要足够的可扩展性来支持不同的数据格式，如JSON和T21协议缓冲区。</p><p id="2133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们需要做的就是让接收者知道他们期望接收多少数据。该信息可以作为前缀<strong class="lb iu">添加到要发送的实际数据中。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4a7a06c25afa1f4815baa02cce2eae92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*VRwRul_ieXGTRF-C.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">协议</p></figure><p id="5996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个前缀的字节数是固定的。我这里是4字节，可以存储<code class="fe lw lx ly lz b">uint32</code>，最大值4294967295。这足以说明我的用例中的数据长度。</p><p id="7ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们发送8个字节的数据，前缀应该存储数字12，即4个字节的前缀加上8个字节的数据。通过首先读取前缀，我们知道我们需要提供<code class="fe lw lx ly lz b">ReadFull</code>来读取实际数据的字节片的大小！</p><p id="fb22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个助手函数，为数据添加前缀。请注意，所使用的<code class="fe lw lx ly lz b"><a class="ae ky" href="https://pkg.go.dev/encoding/binary" rel="noopener ugc nofollow" target="_blank">binary</a></code>包是一个官方库，可以在数字和字节之间进行转换。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要读取数据，我们只需要在读取实际数据之前先读取前缀。这仅用<code class="fe lw lx ly lz b">io.ReadFull</code>就可以做到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将数据写入连接就像调用<code class="fe lw lx ly lz b">conn.Write</code>一样简单。我们只需要使用<code class="fe lw lx ly lz b">createTcpBuffer</code>来确保前缀存在。</p><p id="0d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议到此为止！虽然简单，但只要客户机和服务器同意相同的前缀大小，就足以确保读取正确的数据量。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5716" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">改进的余地</h1><p id="a768" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我描述的连接池好到足以通过我的入门任务需求(耶！).但是，这并不意味着它不能进一步改进。</p><h2 id="5cb5" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">最大空闲时间</h2><p id="1f15" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">还记得我提到过在池中保持空闲连接会消耗服务器资源吗？如果在一段时间内没有传入连接，这是一种浪费。为了节省资源，我们可以关闭那些<strong class="lb iu">打开时间过长</strong>的空闲连接。</p><p id="0dee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过向我们的池中添加一个名为<code class="fe lw lx ly lz b">maxIdleTime</code>的新配置设置来实现这一点。当一个连接被放入池中时，可以启动一个个人计时器。当到达<code class="fe lw lx ly lz b">maxIdleTime</code>时，连接应自动关闭。</p><h2 id="fbc7" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">关闭故障连接</h2><p id="8479" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">读写错误时有发生。当出现这种错误时，我们应该假设连接有故障。我们可以关闭它，而不是把它放回游泳池。</p><h2 id="ec11" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">正常关机</h2><p id="1000" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">正常关闭Go服务器是一个很好的做法，可以确保在关闭服务器连接之前，所有正在进行的请求都被正确终止。这可以防止损害用户体验并可能导致数据丢失的突然关机。</p><p id="269b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go服务器可以通过首先捕获SIGINT和SIGTERM信号，然后采取相应的行动来正常关闭。该池可以为服务器提供一个清理功能，以便在关闭时调用。</p><p id="a504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不需要太多的细节，清理过程可以在关闭连接之前等待连接不再被使用。还需要有一个超时，以防连接被卡住，需要“硬关闭”。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c478" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">最后的想法</h1><p id="1c58" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">本文到此为止！如果您希望了解更多关于连接池的细节，我强烈推荐您阅读Go的<code class="fe lw lx ly lz b"><a class="ae ky" href="https://github.com/golang/go/blob/master/src/database/sql/sql.go" rel="noopener ugc nofollow" target="_blank">sql</a></code>包的源代码。</p><p id="4313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望您和我一样喜欢这篇文章，并对连接池的工作原理有所了解。感谢阅读。</p><pre class="kj kk kl km gt nu lz nv nw aw nx bi"><span id="56cc" class="ni mi it lz b gy ny nz l oa ob"><strong class="lz iu">Want to Connect With the Author?</strong></span><span id="86e6" class="ni mi it lz b gy oc nz l oa ob">You can find me on <a class="ae ky" href="https://www.linkedin.com/in/jonathanseow5177/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>