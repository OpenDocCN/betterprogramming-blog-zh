<html>
<head>
<title>Writing Common Functionality With CRTP Idiom in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++写CRTP·习语的常用功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-common-functionality-with-crtp-idiom-in-c-c8ccbd2dda2e?source=collection_archive---------4-----------------------#2022-01-04">https://betterprogramming.pub/writing-common-functionality-with-crtp-idiom-in-c-c8ccbd2dda2e?source=collection_archive---------4-----------------------#2022-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c55" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">奇怪的是，重复出现的模板模式可以帮助我们通过组合模板和继承来编写通用功能</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="gh gi gj"><img src="../Images/d8a1d31d977dd895aed8d88b42983916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVKg6N9R3MYRK_0-6BMSLQ.png"/></div></div><p class="kt ku gj gh gi kv kw bd b be z dk translated">CRTP(作者图片)</p></figure><h1 id="cb4a" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">什么是CRTP习语？</h1><p id="5404" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">CRTP代表奇怪重复出现的模板模式，这个名字是詹姆斯·o·科普林在他1995年的论文中创造的。它是关于使用派生类作为模板参数来专门化基类。它看起来像下面这样:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f5bc" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">这是一个很常见的例子，当我们在网上搜索CRTP的时候就能找到。然而，仅仅看这个例子并不清楚我们想用这个习语解决什么问题。我将在接下来的章节中介绍细节。</p><p id="afbb" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">正如你可能猜到的，当我们构造一个名为<code class="fe mt mu mv mw b">derived</code>的类<code class="fe mt mu mv mw b">Derived</code>的对象并调用<code class="fe mt mu mv mw b">derived.interface()</code>时，它打印“实现”。</p><h2 id="8537" class="mx ky it bd kz my mz dn ld na nb dp lh ly nc nd lj mc ne nf ll mg ng nh ln ni bi translated">倒置遗传</h2><p id="a5f7" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">当一个类从基类派生时，它将继承基类的函数。然后派生类可以调用<code class="fe mt mu mv mw b">public</code>和<code class="fe mt mu mv mw b">protected</code>函数，如下例所示:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2060" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">在CRTP的例子中，情况正好相反，基类调用派生类中的函数(参见前面的例子)。</p><p id="c4eb" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">它被称为颠倒继承，因为在正常继承中，我们扩展了基类的功能，而在CRTP中，我们基本上是通过继承基类来扩展派生类的功能。希望在后面的章节中会变得更加清晰。</p><h2 id="1aec" class="mx ky it bd kz my mz dn ld na nb dp lh ly nc nd lj mc ne nf ll mg ng nh ln ni bi translated">为什么叫CRTP？</h2><p id="8de7" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我认为这个名字只是被卡住了，因为它可能比“F有界量化”更容易记住。Jim Coplien使用这个名字是因为他在各种场合观察到了这种结合模板和继承的模式。</p><h1 id="a637" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">它是用来做什么的？</h1><p id="5c21" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在学习设计、模式或习惯用法时，我们应该知道的最重要的事情是使用它们我们能解决什么问题。让我们更详细地看看CRTP能提供什么。</p><h2 id="d8c1" class="mx ky it bd kz my mz dn ld na nb dp lh ly nc nd lj mc ne nf ll mg ng nh ln ni bi translated">向类中添加通用功能</h2><p id="2df2" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们都知道应该避免代码中的重复，我们不想在许多不同的类中一遍又一遍地写相同的函数。对于OOP，首先想到的可能是使用多态性。</p><p id="deeb" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">让我们看一个例子，假设我们希望我们所有的类都能够使用<code class="fe mt mu mv mw b">typeid</code>操作符打印出它们类型的名称，我们需要一个名为<code class="fe mt mu mv mw b">PrintType()</code>的函数。在基类中实现这个函数是行不通的，因为它会打印基类类型。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3fd7" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">上面的代码将打印“4Base”两次(带GCC)。这绝对不是我们想要的。我们可以通过将<code class="fe mt mu mv mw b">PrintType()</code>虚拟化来解决多态性的问题。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b4bb" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">现在它正常工作了，这段代码打印了“5Test1”和“5Test2”两次。注意，我们也可以通过使用<code class="fe mt mu mv mw b">Print()</code>函数得到相同的结果。</p><p id="ad13" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">您可能已经知道的一个问题是，通过将我们的函数虚拟化，将会由于使用vtables的动态调度而产生运行时成本。这对您的应用程序来说可能不是问题，因为这取决于您如何使用虚函数、您的应用程序在什么环境中运行等等。如果不像在循环中那样频繁地使用虚函数，那么在现代CPU上成本可能可以忽略不计。但是，如果使用动态调度的成本对您来说是个问题，您可以使用CRTP。</p><p id="e05b" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">以下是CRTP的情况:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="67f2" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">这段代码打印的结果与前一版本完全相同，而且更加简洁，因为您不必在派生类中编写<code class="fe mt mu mv mw b">PrintType()</code>的实现。它没有<strong class="lr iu"> <em class="nj">额外的成本</em> </strong>用于动态调度，因为我们在这个版本中没有使用虚函数。一切都是在编译时解决的。</p><p id="e101" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">您可以看到<code class="fe mt mu mv mw b">Test1</code>和<code class="fe mt mu mv mw b">Test2</code>并不像我们熟悉的继承概念中那样必然相关。我们可以将其视为添加功能，我们希望<code class="fe mt mu mv mw b">Test1</code>和<code class="fe mt mu mv mw b">Test2</code>打印类型，因此我们通过继承<code class="fe mt mu mv mw b">Base&lt;Derived&gt;</code>来添加该功能。</p><h2 id="c059" class="mx ky it bd kz my mz dn ld na nb dp lh ly nc nd lj mc ne nf ll mg ng nh ln ni bi translated">静态多态呢？</h2><p id="1b21" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">人们谈论静态多态性的CRTP，这可能会令人困惑，因为我不认为CRTP是这样的。正如上面所解释的，CRTP是为了分解出共同的功能，使我们的代码更加模块化。</p><p id="0341" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">事实上，如果我们愿意，我们可以使用CRTP来应用静态多态来代替动态多态。在下面的代码中，我们使用众所周知的<code class="fe mt mu mv mw b">Animal</code>类作为例子。对于使用虚函数的动态多态性，它看起来是这样的:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9f46" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">对于CRTP，我们可以用以下方式取代这种实施:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="fa97" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">如果我们想要的是让我们的代码运行得更快，这可能是一个解决方案。但是如果我们想要的是一个统一的接口，在这个例子中是<code class="fe mt mu mv mw b">MakeSound()</code>函数，我们可能应该使用如下的编译时鸭类型:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e2b9" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">如果我们传递给<code class="fe mt mu mv mw b">MakeSound()</code>的对象没有实现<code class="fe mt mu mv mw b">::MakeSound()</code>，编译器将抛出一个错误。</p><p id="d65c" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">所以，是的，我们可以用CRTP实现静态多态性，但是我们必须选择如何明智地实现我们的类，这取决于我们想要实现什么，我们是否想要使用动态多态性，用CRTP实现静态多态性，duck typing编译时，等等。</p><h1 id="a654" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">为什么可能？</h1><p id="68ea" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">现在，让我们看看为什么CRTP是可能的，当你第一次看到它时，语法可能有点混乱。</p><h2 id="58ba" class="mx ky it bd kz my mz dn ld na nb dp lh ly nc nd lj mc ne nf ll mg ng nh ln ni bi translated">C++中的惰性实例化</h2><p id="fb57" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">让我们再看看上面的例子，为了可读性，这里是相同的代码。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f086" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">当编译器在第9行实例化<code class="fe mt mu mv mw b">Base&lt;Test1&gt;</code>时，<code class="fe mt mu mv mw b">Test1</code>被作为模板参数传递，即使<code class="fe mt mu mv mw b">Test1</code>在那时还不是完整的类型。但是，我们没有编译错误，因为在C++中，类模板的成员函数只有在被使用/调用时才会生成。或许我们可以称之为惰性实例化。</p><p id="7d2a" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">在这个例子中，成员函数<code class="fe mt mu mv mw b">PrintType()</code>只在第14行生成。在这一点上，<code class="fe mt mu mv mw b">Test1</code>是一个完整的类型，因此它是有效的。</p><p id="9247" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">对于成员变量来说，情况并非如此。下面的代码会给我们编译错误。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9282" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">唯一不同的是在第7行，它会导致下面的错误。</p><pre class="ki kj kk kl gt nk mw nl nm aw nn bi"><span id="96fd" class="mx ky it mw b gy no np l nq nr">error: ‘Base&lt;Derived&gt;::derived’ has incomplete type Derived derived;</span></pre><p id="7fc5" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">我想我们可以看出为什么，如果编译器不知道<code class="fe mt mu mv mw b">Derived</code>是什么，就不知道<code class="fe mt mu mv mw b">Base&lt;Derived&gt;</code>的内存布局。</p><h2 id="1205" class="mx ky it bd kz my mz dn ld na nb dp lh ly nc nd lj mc ne nf ll mg ng nh ln ni bi translated">继承意味着扩展结构</h2><p id="c848" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">当一个类从基类继承时，除了继承公共和受保护的函数，它还扩展了基类的结构(内存)。如果基类和派生类都有成员变量，如下例所示:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8cab" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated"><code class="fe mt mu mv mw b">Derived</code>类的结构如下所示:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/623e3903d6a5b978ad1e7383ee58d9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*OlswwHKYDmnnzNPDCCrjIw.png"/></div><p class="kt ku gj gh gi kv kw bd b be z dk translated"><code class="fe mt mu mv mw b">Derived</code>内存布局(图片作者提供)</p></figure><p id="ae29" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">所以在CRTP使用<code class="fe mt mu mv mw b">static_cast</code>进行向下转换(我们正在将<code class="fe mt mu mv mw b">interface()</code>中的<code class="fe mt mu mv mw b">Base&lt;Derived&gt;</code>转换为<code class="fe mt mu mv mw b">Derived</code>是安全的，因为我们确实知道<code class="fe mt mu mv mw b">Derived</code>是<code class="fe mt mu mv mw b">Base&lt;Derived&gt;</code>的唯一子元素。</p><p id="bc0e" class="pw-post-body-paragraph lp lq it lr b ls mo ju lu lv mp jx lx ly mq ma mb mc mr me mf mg ms mi mj mk im bi translated">如果你想了解更多关于C++中内存布局和对象模型的知识，你可以阅读我下面的文章。</p><div class="nt nu gp gr nv nw"><a href="https://towardsdatascience.com/c-basics-understanding-object-model-b8152c8a4bcf" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">C++基础:理解对象模型</h2><div class="od l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kr nw"/></div></div></a></div><h2 id="3734" class="mx ky it bd kz my mz dn ld na nb dp lh ly nc nd lj mc ne nf ll mg ng nh ln ni bi translated">模板允许基类知道派生类的类型</h2><p id="8c8e" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">CRTP的另一个要点是，基类必须确切地知道派生类是什么类型，这在我们使用普通继承时是不知道的。由于我们使用模板，我们可以实现这一点。</p><h1 id="636e" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">形象化</h1><p id="250c" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">正如我们上面的例子所述，<code class="fe mt mu mv mw b">Test1</code>和<code class="fe mt mu mv mw b">Test2</code>实际上并不相关。他们使用相同的类模板来添加功能。如果我们使用类图来可视化，我们可以看到它们是两个独立的类。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ce1a051d734085bcc9bf16f82aa2724a.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*IU4ReRy0RDyWo-NvBczCKA.png"/></div><p class="kt ku gj gh gi kv kw bd b be z dk translated">Test1和Test2的类图(图片来自作者)</p></figure><h1 id="795f" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">摘要</h1><ul class=""><li id="54ad" class="ol om it lr b ls lt lv lw ly on mc oo mg op mk oq or os ot bi translated">当编写代码时，我们应该通过分解出共同的功能来避免重复</li><li id="7c71" class="ol om it lr b ls ou lv ov ly ow mc ox mg oy mk oq or os ot bi translated">我们可以通过许多正确的方法来实现，如动态多态(继承)、CRTP等。</li><li id="573a" class="ol om it lr b ls ou lv ov ly ow mc ox mg oy mk oq or os ot bi translated">我们应该通过考虑效率和可伸缩性来选择适合我们应用程序需求的解决方案</li><li id="b797" class="ol om it lr b ls ou lv ov ly ow mc ox mg oy mk oq or os ot bi translated">CRTP提供了一种编写通用功能的方法</li></ul></div></div>    
</body>
</html>