<html>
<head>
<title>How To Access “this” Inside a JavaScript Callback Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript回调函数中访问“this”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/access-this-inside-a-javascript-callback-function-ea07e791dfcb?source=collection_archive---------6-----------------------#2021-02-01">https://betterprogramming.pub/access-this-inside-a-javascript-callback-function-ea07e791dfcb?source=collection_archive---------6-----------------------#2021-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="33f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们一劳永逸地解决这个令人困惑的关键词</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18fc89f1bc75f9e623acfdd3d78072be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LxaNjQQxrxYympai"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@edonugroho?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">江户努格罗霍</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="4f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键字<code class="fe lv lw lx ly b">this</code>让许多JavaScript程序员感到困惑，尤其是那些来自其他语言的程序员。一个常见的问题是如何在回调函数中访问正确的<code class="fe lv lw lx ly b">this</code>。</p><p id="9540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="958e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码没有产生所需的输出。这里的问题是什么？为什么<code class="fe lv lw lx ly b">data</code>按计划行事，而<code class="fe lv lw lx ly b">this.data</code>却不是？</p><p id="45ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是<code class="fe lv lw lx ly b">this</code>的值取决于函数在哪里执行。这叫做<em class="mb">运行时绑定</em>。其他变量的值取决于函数的定义位置。</p><p id="45d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子中常见的误解来自于这样一个事实，即许多人认为<code class="fe lv lw lx ly b">this</code>具有定义回调函数时的值。事实是，它的值取决于调用回调函数的上下文。从这个意义上来说,<code class="fe lv lw lx ly b">this</code>关键字是特殊的。它对其他变量以及来自其他语言(如Java)的<code class="fe lv lw lx ly b">this</code>关键字表现不同。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="e257" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">那我们怎么才能访问它呢？</h1><h2 id="9170" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">1.“自我”模式</h2><p id="d717" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">一个常用的模式是创建一个名为<code class="fe lv lw lx ly b">self</code>的变量，并在定义函数的范围内将<code class="fe lv lw lx ly b">this</code>的值赋给它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="dc7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过声明一个名为<code class="fe lv lw lx ly b">self</code>的新变量(任何其他有效的变量名也可以)，并给它赋值<code class="fe lv lw lx ly b">this</code>，您就实现了想要的行为。</p><h2 id="3fa2" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">2.显式设置“此”</h2><p id="aea7" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">处理我们问题的另一种方法是为函数显式设置<code class="fe lv lw lx ly b">this</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">bind</code>实际上创建了一个新函数，其中的<code class="fe lv lw lx ly b">this</code>永久绑定到您传递给<code class="fe lv lw lx ly b">bind</code>的任何值。这是解决你的问题的一种固有方式。</p><h2 id="4b04" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">3.箭头功能</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">箭头函数不仅仅拥有比匿名函数表达式更简洁的语法。它们也像处理任何变量一样处理<code class="fe lv lw lx ly b">this</code>关键字。这意味着<code class="fe lv lw lx ly b">this</code>将保持封闭词法上下文的值。这并不意味着它获得了该值的副本。它可以像闭包内的任何其他变量一样被其他函数改变。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="52ae" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">我应该使用哪种方法？</h1><p id="f1b5" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这在很大程度上取决于具体情况。我个人认为没有理由使用<code class="fe lv lw lx ly b">self</code>。人们应该记住，JavaScript中的<code class="fe lv lw lx ly b">this</code>行为不是偶然的，而是有意的。它可以是有用的，并使功能非常灵活。所以不要简单地把<code class="fe lv lw lx ly b">var self = this;</code>放在你所有函数的开头来对抗这个意图。尝试使用<code class="fe lv lw lx ly b">this</code>关键字作为调用你的函数的对象的引用。</p><p id="647d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">bind</code>和使用箭头功能都有它们的用例。箭头函数总是匿名的。所以如果你想有一个命名函数，你应该使用<code class="fe lv lw lx ly b">bind</code>。如果匿名函数对你来说很好，并且你想要非常简洁的代码，你可以使用箭头函数。请注意，对于箭头函数，您没有自由更改函数的<code class="fe lv lw lx ly b">this</code>绑定。</p><p id="8441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有单一的最佳解决方案。最终，这是一个固执己见的决定。只要确保你知道你为什么选择你的方法。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="536c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">参考</h1><ul class=""><li id="20d5" class="ns nt it lb b lc nn lf no li nu lm nv lq nw lu nx ny nz oa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/this</a></li><li id="2b06" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://262.ecma-international.org/11.0/#sec-this-keyword" rel="noopener ugc nofollow" target="_blank">https://262.ecma-international.org/11.0/#sec-this-keyword</a></li></ul></div></div>    
</body>
</html>