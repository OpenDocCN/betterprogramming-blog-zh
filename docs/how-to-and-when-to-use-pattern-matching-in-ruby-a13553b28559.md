# 如何以及何时在 Ruby 中使用模式匹配

> 原文：<https://betterprogramming.pub/how-to-and-when-to-use-pattern-matching-in-ruby-a13553b28559>

## 模式匹配让我们编写易于维护和推理的声明性代码。让我们看看如何在 Ruby 中使用它

![](img/492e22d3a1ec018956217050d6cd5cda.png)

照片由 [JJ 英](https://unsplash.com/@jjying?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/pattern?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

Ruby 最近增加的一个重要特性是模式匹配。Ruby 2.7 中已经添加了模式匹配功能，并在此后得到了改进。

很多人都在谈论 Ruby 的新版本，但却没有太多关于模式匹配的内容，这在我看来是一个遗憾，因为这为我们的选择增加了如此之多。所以，让我们改变这一点。

在这篇博文中，我们将讨论*什么是*模式匹配，*何时可以使用*，并且我们还将做一个小的基准测试，将它与类似的`if`语句进行比较。

# 什么是模式匹配

在维基百科中，模式匹配被解释为“检查一个给定的记号序列是否存在某种模式的组成部分的行为”。对我来说，这并不能解释很多，所以让我们看一个实际的例子。

对于包括我在内的许多 Rubyist 来说，模式匹配是随着[药剂](https://elixir-lang.org/)的出现而为人所知的。借助这一功能，Elixir 能够重载函数。

这样，一个函数非常小，只能处理另一个函数处理另一个输入参数的情况。它还使得编写可读性很强的代码来处理错误情况成为可能。这看起来怎么样？让我们来看一个重载函数:

函数`valid_password?`的参数被解构并进行模式匹配。BEAM(运行 Elixir 的 VM)检查参数的形式，然后调用正确的函数。所以，如果自变量是一个映射，并且有键`hashed_password`，那么第一个函数被调用，否则调用另一个。

Elxir 中的错误处理看起来如何？

这里，函数`update_company`返回一个元组，第一个条目是一个`:ok`或`:error`原子。根据这一点，运行时将执行 case 语句的分支。这使得编写只关心一件事情而另一个分支关心其他事情的代码变得容易。

这些例子清楚地说明了什么是模式匹配，并展示了代码质量如何从中受益。那么，Ruby 中的模式匹配是什么样子的呢？

# Ruby 中的模式匹配

首先，让我们看看 Ruby 中模式匹配的一般语法是怎样的:

```
case <expression>
  in <pattern1> 
    ... 
  in <pattern2> 
    ... 
  in <pattern3> 
    ... 
  else 
    ... 
end
```

我们可以对任何表达式进行模式匹配，在 Ruby 中很多都是这样。所以，我们可以调用一个方法，写一个`if`语句或者只是放入一个变量。
现在让我们做一点实验，看看我们能做些什么:

这里我们使用模式匹配而不是一个`if`语句，我们并没有赢很多。让我们做一些更有用的事情，从数据结构中提取一个值，并将其放入一个变量中:

注意，我们不必指定散列中的所有键，而只指定我们感兴趣的键。同样，通过`*`,我们告诉 Ruby 数组中可能有更多的对象，但是我们真的不关心它们。

如果我们使用 If 语句将这个值提取到一个变量中并处理一个错误，代码看起来会更混乱:

模式匹配版本不仅节省了我们编写几行代码的时间，而且可读性更好，因此更易于维护。

这真的很棒，向我们展示了一个很好的用例:从数据结构中提取一些东西，例如，解构一个对象。但是模式匹配可以做得更多！

如上所述，我们评估的第一个表达式也可以是方法调用。这样我们*就可以*实现一个错误处理，就像我们在 Elixir 中所做的那样:

虽然我们可以用这种方式实现错误处理，但这不是惯用的 Ruby。因此，标准库以不同的方式处理错误，我们必须自己对重要的类/方法进行包装。

也就是说，处理我们的业务逻辑中的错误可能是一个好的选择，这必须由个人决定。但是说实话，我会使用其他的东西，比如`dry-rb`单子——它在模式匹配方面做得很好。关于如何用单子实现错误处理的一个很棒的帖子可以在[这里](https://hanamimastery.com/episodes/7-untangle-your-app-with-dry-monads)找到。

# 野外模式匹配

有一个 gem 套件广泛使用模式匹配，即 [dry-rb](https://dry-rb.org) gems。

例如，`dry-validation` gem 可以在成功验证时进行模式匹配，如下所示(直接取自文档):

这里我们使用一个`if`语句作为模式匹配的表达式。当你看一看`dry-rb`文档时，你会发现使用这个优秀库的模式匹配的其他方法。

# 基准模式匹配与 if 语句

与命令式搜索相比，这种模式匹配有多快？让我们来了解一下！

```
Warming up --------------------------------------
   pattern matching:    99.516k i/100ms
  imperative search:   134.871k i/100ms
Calculating -------------------------------------
   pattern matching:    969.440k (± 0.9%) i/s -      9.753M in  10.060889s
  imperative search:      1.319M (± 1.0%) i/s -     13.217M in  10.024136sComparison: 
  imperative search::  1318684.6 i/s
   pattern matching::   969439.8 i/s - 1.36x  (± 0.00) slower
```

如你所见，模式匹配仍然比强制搜索慢得多。但是我们不应该使用这个伟大的功能吗？绝对不行！

当我们只在一个不是紧循环的地方使用这个，不反复运行的时候，区别对我们来说就不重要了。但是可维护的仍然存在，所以我们应该在那时使用它。

# Ruby 模式匹配的未来

Ruby 中模式匹配的故事还没有结束。最近，我看到了来自 Koichi Sasada 的[推文，其中他暗示了一种可能的模式匹配重载方法。没有证实会发生这种情况，但它在我看来真的很有趣！](https://twitter.com/_ko1/status/1458614945608732677?t=7arc8NSzL0fL-lNOd4Z85g&s=09)

正如我们所见，模式匹配是我们工具箱中一个非常强大的工具。我们可以编写非常具有声明性的可维护代码。性能很好，但是也许不应该在紧密循环中使用，因为*需要付出一点点性能代价。*

*不是中等会员？* [*在这里报名*](https://grnt-grdwhl.medium.com/membership) *并支持我的写作过程！*