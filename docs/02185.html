<html>
<head>
<title>Understanding MVC Services for Front End: Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解前端的MVC服务:Angular</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/https-medium-com-ccaballero-understanding-mvc-services-for-front-end-angular-a6196492ee74?source=collection_archive---------9-----------------------#2019-11-12">https://betterprogramming.pub/https-medium-com-ccaballero-understanding-mvc-services-for-front-end-angular-a6196492ee74?source=collection_archive---------9-----------------------#2019-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6868" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">循序渐进的角度教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7c8c7b2a5e1260413be3b1f0c25efb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NfgBteJ0tzuzx3WSSqW3Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="67bb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="2a78" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这篇文章是理解MVC架构如何创建前端应用程序的系列文章中的第三篇。目标是理解如何构建前端应用程序。这是通过从使用JavaScript作为脚本语言的网页向使用JavaScript/TypeScript作为面向对象语言的应用程序发展来实现的。</p><p id="81bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第三篇文章中，将使用Angular构建应用程序，第二个版本使用TypeScript。因此，这篇文章涵盖了应用程序从TypeScript到Angular的迁移。然而，理解应用程序的所有部分是如何关联的以及它是如何构造的是很重要的。Angular让我们忘记了DOM，所以<code class="fe ms mt mu mv b">user.view.ts</code>文件从我们的应用中消失了。</p><p id="a92b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，在最后一部分，我们将转换我们的代码，使其与Angular框架相集成。</p><ul class=""><li id="97bf" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated"><a class="ae ky" href="https://medium.com/better-programming/understanding-mvc-services-for-the-front-end-vanillajs-2268255b36e6" rel="noopener">第一部分。了解前端的MVC服务:VanillaJS </a></li><li id="7763" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">第二部分。了解面向前端的MVC服务:TypeScript </li><li id="7311" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">第三部分。了解面向前端的MVC服务:Angular </li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="881b" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">项目架构</h1><p id="adbc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">没有什么比图像更有价值来理解我们将要建造的东西了。这是我们正在构建的应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e1868b9f9f0934eac0f9f3e59fd27e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*ZU3nvH3x35AoiPpE.gif"/></div></figure><p id="32af" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这可以使用单个JavaScript或TypeScript文件来构建，该文件修改文档的DOM并执行所有操作，但是这是强耦合的代码，不是我们打算在本文中应用的。</p><p id="2f9b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">什么是MVC架构？MVC是一个具有三层/三部分的架构:</p><ul class=""><li id="0471" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated"><strong class="lt iu">模型</strong> —管理应用程序的数据。模型将会缺乏活力(它们将缺乏功能)，因为它们将会被提交给服务。</li><li id="5667" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><strong class="lt iu">视图/模板</strong> —用户与应用程序交互的页面/GUI。</li><li id="9b39" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><strong class="lt iu">控制器</strong> —服务和视图之间的链接。</li></ul><p id="ad20" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我们在问题域中的文件结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5b8d19760c33b1fbf90b23085c965b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/0*3mA-GgJQgf5tuN2O.png"/></div></figure><p id="8a14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<code class="fe ms mt mu mv b">root</code>元素，<code class="fe ms mt mu mv b">index.html</code>文件将作为画布，在其上动态构建整个应用程序。</p><p id="05e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们的文件体系结构由以下类型脚本文件组成:</p><ul class=""><li id="6a22" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated"><strong class="lt iu"> user.model.ts </strong> —用户的属性(模型)。</li><li id="ecaf" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><strong class="lt iu"> user.service.ts </strong> —管理用户的所有操作。</li><li id="3124" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><strong class="lt iu"> users.component.ts </strong> —负责加入服务和视图的人。</li><li id="d76c" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><strong class="lt iu">users.component.html</strong>—负责刷新和改变显示屏。</li></ul><p id="5bc9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">App模块如下所示:</p><pre class="kj kk kl km gt ny mv nz oa aw ob bi"><span id="b33c" class="oc la it mv b gy od oe l of og">import { FormsModule, ReactiveFormsModule } from '@angular/forms';<br/><br/>import { AppComponent } from './app.component';<br/>import { BrowserModule } from '@angular/platform-browser';<br/>import { NgModule } from '@angular/core';<br/>import { UserService } from './shared/services/user.service';<br/>import { UsersComponent } from './views/users/users.component';<br/><br/>@NgModule({<br/>  declarations: [AppComponent, UsersComponent],<br/>  imports: [BrowserModule, FormsModule, ReactiveFormsModule],<br/>  providers: [UserService],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {}</span></pre><p id="996b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你可以看到我们的应用程序使用了三个模块:<code class="fe ms mt mu mv b">BrowserModule</code>、<code class="fe ms mt mu mv b">FormsModule</code>和<code class="fe ms mt mu mv b">reactiveFormsModule</code>。第一个模块用于从Angular获取基本的结构和属性指令，而第二个和第三个模块用于创建表单。在这个例子中，没有定义用户模块，因为这个例子很小。可以看到<code class="fe ms mt mu mv b">UserService</code>和<code class="fe ms mt mu mv b">UsersComponent</code>都包含在这个模块中。事实上，您可以将<code class="fe ms mt mu mv b">UsersComponent</code>分成两个组件(列表和表单),但是在这个例子中，我们的目标是向您展示从JavaScript到Angular的演变。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="528b" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">模型(贫血)</h1><p id="8364" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">本例中第一个构建的类是应用程序模型<code class="fe ms mt mu mv b">user.model.ts</code>，它由类属性和一个生成随机id(这些id可能来自服务器中的数据库)的私有方法组成。</p><p id="ff5b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些模型将具有以下字段:</p><ul class=""><li id="6c93" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated"><strong class="lt iu"> id </strong>。独特的价值。</li><li id="5a86" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><strong class="lt iu">名称</strong>。用户的名称。</li><li id="daa9" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><strong class="lt iu">年龄</strong>。用户的年龄。</li><li id="0b8e" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><strong class="lt iu">完成</strong>。布尔值，让你知道我们是否可以把用户从列表中划掉。</li></ul><p id="287d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">已经使用TypeScript对<code class="fe ms mt mu mv b">User</code> <strong class="lt iu"> </strong>类进行了类型化。但是，用户构造函数接收一个普通对象，该对象将由LocalStorage或通过表单输入的用户数据提供。这个普通对象必须符合<code class="fe ms mt mu mv b">UserDto</code>接口，这样任何普通对象都不能被实例化，但那些满足定义的接口的对象除外。</p><p id="ff21" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">user.model.ts</code>如下图所示:</p><pre class="kj kk kl km gt ny mv nz oa aw ob bi"><span id="ccc8" class="oc la it mv b gy od oe l of og">export interface UserDto {<br/>  name: string;<br/>  age: string;<br/>  complete: boolean;<br/>}<br/><br/>export class User {<br/>  public id: string;<br/>  public name: string;<br/>  public age: string;<br/>  public complete: boolean;<br/><br/>  constructor(<br/>    { name, age, complete }: UserDto = {<br/>      name: null,<br/>      age: null,<br/>      complete: false<br/>    }<br/>  ) {<br/>    this.id = this.uuidv4();<br/>    this.name = name;<br/>    this.age = age;<br/>    this.complete = complete;<br/>  }<br/><br/>  uuidv4(): string {<br/>    return (([1e7] as any) + -1e3 + -4e3 + -8e3 + -1e11).replace(<br/>      /[018]/g,<br/>      (c: number) =&gt;<br/>        (<br/>          c ^<br/>          (crypto.getRandomValues(new Uint8Array(1))[0] &amp; (15 &gt;&gt; (c / 4)))<br/>        ).toString(16)<br/>    );<br/>  }<br/>}</span></pre></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="eba6" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">服务</h1><p id="7bee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对用户执行的操作在服务中执行。因为所有的逻辑负载都在模型中，所以服务允许模型贫血。在这个具体的例子中，我们将使用一个数组来存储所有用户，并构建与读取、修改、创建和删除(CRUD)用户相关的四个方法。</p><p id="d81a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您应该注意到服务利用了模型，实例化了从<code class="fe ms mt mu mv b">LocalStorage</code>提取到<code class="fe ms mt mu mv b">User class</code>的对象。这是因为<code class="fe ms mt mu mv b">LocalStorage</code>只存储数据而不是存储数据的原型。从后端传输到前端的数据也会发生同样的情况:它们没有实例化它们的类。</p><p id="84fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们类的构造函数如下:</p><pre class="kj kk kl km gt ny mv nz oa aw ob bi"><span id="f17b" class="oc la it mv b gy od oe l of og">constructor() {<br/>  const users: UserDto[] = JSON.parse(localStorage.getItem('users')) || [];<br/>  this.users = users.map(user =&gt; new User(user));<br/>}</span></pre><p id="371d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，我们已经定义了一个名为<code class="fe ms mt mu mv b">users</code>的类变量，一旦用户从普通对象(<code class="fe ms mt mu mv b">UserDto</code>)转换为<code class="fe ms mt mu mv b">User</code>类的原型对象，该变量就会存储所有用户。</p><p id="6a9f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们必须在服务中定义的下一件事将是我们想要开发的每个操作。下面使用TypeScript显示了这些操作:</p><pre class="kj kk kl km gt ny mv nz oa aw ob bi"><span id="9f38" class="oc la it mv b gy od oe l of og">add(user: User) {<br/>    this.users.push(new User(user));<br/>    this._commit(this.users);<br/>  }<br/><br/>  edit(userID: string, userToEdit: User) {<br/>    this.users = this.users.map(user =&gt;<br/>      user.id === userID<br/>        ? new User({<br/>            ...user,<br/>            ...userToEdit<br/>          })<br/>        : user<br/>    );<br/><br/>    this._commit(this.users);<br/>  }<br/><br/>  delete(userID: string) {<br/>    this.users = this.users.filter(({ id }) =&gt; id !== userID);<br/>    this._commit(this.users);<br/>  }<br/><br/>  toggle(userID: string) {<br/>    this.users = this.users.map(user =&gt;<br/>      user.id === userID<br/>        ? new User({ ...user, complete: !user.complete })<br/>        : user<br/>    );<br/><br/>    this._commit(this.users);<br/>  }</span></pre><p id="c5de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">负责存储在我们的数据存储中执行的操作的<code class="fe ms mt mu mv b">commit</code>方法(在我们的例子中是<code class="fe ms mt mu mv b">LocalStorage</code>)仍有待定义:</p><pre class="kj kk kl km gt ny mv nz oa aw ob bi"><span id="2c56" class="oc la it mv b gy od oe l of og">_commit(users: User[]) {<br/>  localStorage.setItem('users', JSON.stringify(users));<br/>}</span></pre><p id="cb15" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个方法不调用在创建服务时绑定的<code class="fe ms mt mu mv b">callback</code>函数，而在JavaScript或TypeScript中开发时需要调用这个函数，因为Angular执行这个任务，执行控制器和模板之间的绑定。</p><p id="38cb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">文件<code class="fe ms mt mu mv b">user.service.ts</code>如下:</p><pre class="kj kk kl km gt ny mv nz oa aw ob bi"><span id="13fb" class="oc la it mv b gy od oe l of og">import { User, UserDto } from "../models/user.model";<br/><br/>export class UserService {<br/>  public users: User[];<br/><br/>  constructor() {<br/>    const users: UserDto[] = JSON.parse(localStorage.getItem("users")) || [];<br/>    this.users = users.map(user =&gt; new User(user));<br/>  }<br/><br/>  _commit(users: User[]) {<br/>    localStorage.setItem("users", JSON.stringify(users));<br/>  }<br/><br/>  add(user: User) {<br/>    this.users.push(new User(user));<br/>    this._commit(this.users);<br/>  }<br/><br/>  edit(userID: string, userToEdit: User) {<br/>    this.users = this.users.map(user =&gt;<br/>      user.id === userID<br/>        ? new User({<br/>            ...user,<br/>            ...userToEdit<br/>          })<br/>        : user<br/>    );<br/><br/>    this._commit(this.users);<br/>  }<br/><br/>  delete(userID: string) {<br/>    this.users = this.users.filter(({ id }) =&gt; id !== userID);<br/>    this._commit(this.users);<br/>  }<br/><br/>  toggle(userID: string) {<br/>    this.users = this.users.map(user =&gt;<br/>      user.id === userID<br/>        ? new User({ ...user, complete: !user.complete })<br/>        : user<br/>    );<br/><br/>    this._commit(this.users);<br/>  }<br/>}</span></pre></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="2678" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">视图</h1><p id="b407" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是与本系列前几篇相比变化最大的部分。在这种情况下，我们不需要使用DOM，因为Angular将执行动态操作DOM的困难任务。然而，我们必须正确定义模板。</p><p id="405f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是为这个例子创建的模板(一个角度丰富的HTML版本):</p><pre class="kj kk kl km gt ny mv nz oa aw ob bi"><span id="7ed4" class="oc la it mv b gy od oe l of og">&lt;h1&gt;Users&lt;/h1&gt;<br/><br/>&lt;form [formGroup]="userForm" (ngSubmit)="add(userForm.value)"&gt;<br/>  &lt;input<br/>    type="text"<br/>    placeholder="Name"<br/>    name="name"<br/>    formControlName="name"<br/>  /&gt;&lt;input<br/>    type="text"<br/>    placeholder="Age"<br/>    name="age"<br/>    formControlName="age"<br/>  /&gt;&lt;button&gt;Submit&lt;/button&gt;<br/>&lt;/form&gt;<br/>&lt;ul class="user-list"&gt;<br/>  &lt;li *ngFor="let user of users"&gt;<br/>    &lt;input type="checkbox" (change)="toggle(user)" [checked]="user.complete" /&gt;<br/>    &lt;span&gt;<br/>      &lt;s *ngIf="user.complete; else uncompleteName"&gt;{{ user.name }}&lt;/s&gt;<br/>      &lt;ng-template #uncompleteName&gt;{{ user.name }}&lt;/ng-template&gt;<br/>    &lt;/span&gt;<br/>    &lt;span<br/>      #age<br/>      contenteditable="true"<br/>      class="editable"<br/>      (focusout)="edit(user, age)"<br/>    &gt;<br/>      &lt;s *ngIf="user.complete; else uncompleteAge"&gt;{{ user.age }}&lt;/s&gt;<br/>      &lt;ng-template #uncompleteAge&gt;{{ user.age }}&lt;/ng-template&gt;&lt;/span<br/>    &gt;<br/>    &lt;button class="delete" (click)="delete(user)"&gt;Delete&lt;/button&gt;<br/>  &lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="14f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这不是一个Angular教程，而是一系列的图片，在这些图片中你可以看到Web应用程序从JavaScript到TypeScript再到Angular的演变。</p><p id="6280" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是，我们注意到，Angular提供了两个结构化的指令，如* ngFor和* ngIf，允许从模板本身轻松地操作DOM，从而解决了前面几篇文章中的许多DOM操作代码。</p><p id="c781" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一个有趣的地方是Angular在这个例子中帮助我们使用了反应式。有了这些，模板就可以连接到控制器，而不需要我们发送一个处理程序来进行连接。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="4afd" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">控制器</h1><p id="7871" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个架构的最后一个文件是控制器(<code class="fe ms mt mu mv b">users.component.ts</code>)。控制器通过依赖注入(DI)接收它拥有的两个依赖项(服务和formBuilder)。这些依赖关系存储在控制器的私有变量中。</p><p id="2513" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">控制器只关注管理连接到视图(模板)的属性和调用服务。就像我们之前文章的第一个JavaScript代码或第二个TypeScript版本一样。在这种情况下，我们将所有与DOM相关的任务都留给了框架。</p><p id="014a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是文件<code class="fe ms mt mu mv b">users.component.ts</code>:</p><pre class="kj kk kl km gt ny mv nz oa aw ob bi"><span id="58b6" class="oc la it mv b gy od oe l of og">import { Component, OnInit } from '@angular/core';<br/><br/>import { FormBuilder } from '@angular/forms';<br/>import { UserService } from 'src/app/shared/services/user.service';<br/><br/>@Component({<br/>  selector: 'app-users',<br/>  templateUrl: './users.component.html',<br/>  styleUrls: ['./users.component.css']<br/>})<br/>export class UsersComponent implements OnInit {<br/>  public users;<br/>  public userForm;<br/><br/>  constructor(<br/>    private userService: UserService,<br/>    private formBuilder: FormBuilder<br/>  ) {<br/>    this.userForm = this.formBuilder.group({<br/>      name: '',<br/>      age: ''<br/>    });<br/>  }<br/><br/>  ngOnInit() {<br/>    this.refreshUsers();<br/>  }<br/>  refreshUsers() {<br/>    this.users = this.userService.users;<br/>  }<br/><br/>  add(userForm) {<br/>    this.userService.add(userForm);<br/>    this.refreshUsers();<br/>    this.userForm.reset();<br/>  }<br/>  delete({ id }) {<br/>    this.userService.delete(id);<br/>    this.refreshUsers();<br/>  }<br/>  edit(user, { innerText: age }) {<br/>    const { id } = user;<br/>    this.userService.edit(id, { ...user, age });<br/>    this.refreshUsers();<br/>  }<br/>  toggle({ id }) {<br/>    this.userService.toggle(id);<br/>    this.refreshUsers();<br/>  }<br/>}</span></pre></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="0f49" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">结论</h1><p id="035e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在第三部分中，我们开发了一个web应用程序，在这个应用程序中，项目是按照MVC架构构建的，在这个架构中使用了贫血的模型，逻辑的责任在于服务。</p><p id="3ef3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">需要强调的是，这篇文章的教学内容是让你理解项目在不同责任的不同文件中的结构，以及视图是如何完全独立于模型/服务和控制器的。</p><p id="3015" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">同样重要的是要注意，在这篇文章中，我们已经将应用程序从TypeScript迁移到Angular，这使我们可以忘记与DOM相关的重复性任务，这些任务在我们开发的所有Web应用程序中都是相同的。</p><p id="f70d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我建议你从与JavaScript相关的第一篇文章开始，理解所使用的架构。下一步是通过应用TypeScript(在第二篇文章中)来强化代码，最后回顾这篇文章，在这篇文章中，代码已经适应了一个框架。</p><p id="d2f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这不是一个有角度的教程，而是关于我们的代码从技术到框架的进化。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="8eb6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该岗位的<em class="oh"> GitHub分支</em>为<a class="ae ky" href="https://github.com/Caballerog/Angular-MVC-Users" rel="noopener ugc nofollow" target="_blank">https://github.com/Caballerog/Angular-MVC-Users</a></p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="528c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="oh">原载于2019年11月12日</em><a class="ae ky" href="https://www.carloscaballero.io/understanding-mvc-services-for-frontend-angular" rel="noopener ugc nofollow" target="_blank"><em class="oh">https://www . carloscaballero . io</em></a><em class="oh">。</em></p></div></div>    
</body>
</html>