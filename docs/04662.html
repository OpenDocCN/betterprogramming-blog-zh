<html>
<head>
<title>How to Fix Bugs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何修复bug</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-fix-bugs-b3ae3044bc78?source=collection_archive---------8-----------------------#2020-04-28">https://betterprogramming.pub/how-to-fix-bugs-b3ae3044bc78?source=collection_archive---------8-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d663" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">所有开发人员都必须处理bug，这是如何修复bug的概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/84a9f4d88fe7efbfd6678b5d284b1524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHbmuBKmpjh1JBwV1-gmtQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新Bug由<a class="ae ky" href="https://xkcd.com/1700/" rel="noopener ugc nofollow" target="_blank"> XKCD </a></p></figure><p id="f80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的软件都有缺陷。bug只是软件开发的一个现实，就像产品经理会把它们视为纯粹的浪费一样，修复它们确实会增加价值。作为开发人员，我们有责任尽可能快速有效地处理bug。在这篇文章中，我将分享一些实现这一目标的策略。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="490c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要写它们</h1><p id="1878" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">处理bug的绝对最好的方法是一开始就不要写它们。如果你在一段新代码上写了<code class="fe mz na nb nc b">// TODO</code>或<code class="fe mz na nb nc b">// FIXME</code>，请举手。不要这样！如果你发现自己正在写代码，然后在后面直接添加了<code class="fe mz na nb nc b">// FIXME</code>，你就是在有意地故意给你的代码添加错误。不写bug比写了bug以后再修复要容易得多，所以先从不故意写bug开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6a8f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要修理它们</h1><p id="a6aa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一种处理bug的方法，不管是有意的还是无意的，就是不去管它们。对于某些微不足道的错误或只以非侵入性方式影响一小部分用户的极端情况，这是一种完全有效的方法。</p><p id="194a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个健康的开发工作流程中，bug应该根据开发的其他领域进行分类和优先级排序，比如开发新的特性、架构、偿还技术债务和基础设施工作。您可能想问的一些问题是:</p><ul class=""><li id="a6c2" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">修复bug是否比给定的特性优先级更高，修复它会增加更多的客户价值吗？</li><li id="3a31" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">修复bug的成本是大于还是小于实现一个给定的特性，或者修复其他优先级更高的bug？</li></ul><p id="6234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，我们希望总是致力于最高价值的工作项目，所以如果开发成本对客户价值的比率高于其他竞争优先级，那么最好忽略这个bug，至少现在是这样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3320" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用问题跟踪器</h1><p id="6113" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你不能修复你不知道的错误。因此，问题跟踪器是记录和解决bug的工具箱中必不可少的一部分。它可以用来存储当前bug的列表，区分它们的优先级，记录信息，并将状态反馈给支持人员或用户。</p><p id="08bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">制定一个“错误总是被记录”的策略是一个好主意。口头报告的问题很容易丢失，如果没有跟踪到所有的bug，就很难构建最常报告的bug的图片。</p><p id="8b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<a class="ae ky" href="https://github.com" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae ky" href="https://about.gitlab.com" rel="noopener ugc nofollow" target="_blank"> GitLab </a>这样的版本控制前端包括集成的问题跟踪器，如果你还没有跟踪问题，我建议你从这些开始。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b5a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">收集所有信息</h1><p id="0bc8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好了，我们已经记录了一个错误，并认为它值得修复。接下来呢？</p><p id="d07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的建议是开始收集关于问题本质的信息。这要从一个bug报告说起。一份格式良好的错误报告应该具有以下结构:</p><p id="b26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">复制步骤:</strong></p><ul class=""><li id="40a4" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">打开软件</li><li id="d351" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">点击foo</li><li id="f420" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">点击栏</li></ul><p id="843b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">预期行为:</strong></p><ul class=""><li id="813a" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">将显示一个横幅</li></ul><p id="0eb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">实际行为:</strong></p><ul class=""><li id="a4a3" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">什么都没发生</li></ul><p id="c5cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">系统配置:</strong></p><ul class=""><li id="b74a" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">macOS 10.14，Safari 13.1</li></ul><p id="ae3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制的步骤应该尽可能详细和具体。它们应该包括任何相关的上下文，例如当时在软件中加载的文件或其他状态。</p><p id="91ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要收集的其他信息包括:</p><ul class=""><li id="af1a" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">事故报告</li><li id="6fb2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">调试日志</li><li id="410a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">相关系统信息，如可用内存</li></ul><p id="cd52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些信息大部分可以自动收集，并且有一些框架可以提供帮助，比如<a class="ae ky" href="https://firebase.google.com/products/crashlytics/" rel="noopener ugc nofollow" target="_blank"> Crashlytics </a>。</p><p id="8145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在信息收集阶段，排除不相关的信息也很重要。例如,“重现”的步骤可能包括加载文件，但实际上，无论文件是否被加载，崩溃都可能发生。这是错误分类的关键步骤。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a8a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">写下你的假设</h1><p id="1481" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦你有了可靠的bug报告和关于bug上下文的信息，写下一些最初的假设和理论是个好主意。</p><p id="d6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把事情写下来这个简单的行为，常常能激发灵感或者排除一些事情。一个好主意是将你最初的想法分成两类:</p><ul class=""><li id="6861" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu">假设:</strong>这些是你想当然认为是问题前提的因素。</li><li id="aaee" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">理论:这些是探索的潜在途径。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bdf1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缩小问题的范围</h1><p id="1772" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">缩小问题范围并开始修复bug的一个好方法是从消除任何容易测试的明显的确凿证据开始。</p><p id="0c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可能有一个崩溃报告，它提供了程序崩溃的确切代码行。有时可以沿着堆栈跟踪向上走，找到导致崩溃的代码行，并修复错误。任务完成。</p><p id="e5a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，情况并非总是如此。有时崩溃的程序线程并不是有缺陷的线程。其他时候，未处理的异常会导致崩溃，我们需要找到引发异常的原因。或者错误可能不是崩溃，而是挂起，或者一些更微妙的怪异行为。</p><p id="6d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复这些类型的错误的一个糟糕的方法是从一个精确的理论开始，然后非常深入地研究它。这样做的问题是，我们最终可能会在错误的道路上浪费大量时间。</p><p id="7ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好从排除一般可能性开始，通过隔离问题逐步解决具体问题。一种方法是从注释掉大块的功能开始，看看什么会影响bug，什么不会。我将在下面探索隔离问题的其他方法。</p><h2 id="7107" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">1.使用调试器</h2><p id="c063" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">调试器是开发人员工具箱中的一个宝贵工具，与添加“打印”语句等老派技术相比，它可以节省大量时间(尽管这些也有它们的位置)。</p><p id="08f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数ide(Xcode、Visual Studio、IntelliJ)都内置了调试器，但是如果你更喜欢使用文本编辑器，也有独立的调试器，比如<a class="ae ky" href="https://www.gnu.org/software/gdb/" rel="noopener ugc nofollow" target="_blank"> GDB </a>。对于web开发，大多数浏览器都内置了调试功能。</p><p id="f99c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调试器给我们的主要功能是能够在代码中设置断点。这些是我们可以暂停程序执行并检查状态的地方。这很有用，因为我们可以使用它作为缩小问题范围的另一种方式，找出一个状态何时以及如何发生了变化，从而提供问题所在的线索。</p><p id="34ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更高级的调试器功能包括在引发异常或发生内存分配错误时中断。</p><h2 id="8648" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">2.使用版本控制历史记录</h2><p id="e104" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">缩小bug来源的另一个工具是版本控制。与“注释掉代码”的方法一样，这涉及到在不同的版本中检查您的代码，以隔离哪里引入了问题。</p><p id="a87d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让这一点为您的调试所用依赖于拥有一个有序的、细粒度的提交历史。如果你不经常做小的、独立的提交，现在是时候开始了。</p><p id="5709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用版本控制调试的时候，我一般会用分而治之的方法。我将取上一次提交和当前提交之间的中点，在上次提交时我知道没有出现bug。然后，我将隔离包含bug的那一点上的提交，并将它们分成两半，以此类推，直到我找到引入bug的确切提交。</p><p id="6b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，这可以节省大量时间，并将问题缩小到几个潜在的罪犯。</p><h2 id="4c83" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">3.创建一个测试程序</h2><p id="4639" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在一个大而复杂的程序中，我们可能会有许多影响程序状态的事情。我们还可能不得不处理长时间的测试编译，注释掉大量代码可能是一项巨大的任务。因此，就地调试的另一种方法是创建一个小的测试程序来重现我们正在经历的错误。</p><p id="e9e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过将相关代码从我们的工作应用程序中复制并粘贴到一个新的程序中来实现，也可以通过从头开始创建一个新程序，然后粘贴相关的代码块来实现。</p><p id="8551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时不可能在测试程序中重现bug，这也可以通过告诉我们哪里没有bug来帮助缩小范围。</p><p id="768c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有幸从事全面单元测试的代码库工作，那么失败的测试也是查明和修复bug的好方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3518" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重新思考你的建筑</h1><p id="a8b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">至少有两种方法可以修复bug:</p><ul class=""><li id="a645" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">我们让病毒的症状消失。这通常被称为<em class="od">创可贴</em>方法。从用户的角度来看，bug可能已经消失了，但是导致bug的潜在问题仍然存在。</li><li id="bf2c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">我们修复了导致bug的潜在问题。</li></ul><p id="d61e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我经常发现，如果一个程序中出现了很多bug，那就说明底层设计很差。</p><p id="1b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其单独修复每个bug，不如回到我们的架构中找出一个更好的整体解决方案。这看起来令人望而生畏，因为它不是一个快速的解决方案，但是我强烈推荐这种方法。一个更坚实的底层架构将意味着短期和长期更少的错误，也可以使开发功能更快更容易。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="11dd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">请求帮助</h1><p id="3dab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我修复bug的最后一个策略是在需要的时候寻求帮助。不要试图坚持下去，或者觉得你必须为修复负全部责任。明智的开发人员知道何时询问他人。</p><p id="ba2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">询问同事或合作伙伴是一个不错的首选。如果这不可能，网上有很多帮助来源，其中一个很好的来源是<a class="ae ky" href="https://stackoverflow.com" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>。</p><p id="641c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">寻求帮助是一种技能。在你问之前，准确地想一想你在问什么。准备好解释到目前为止你已经尝试了什么，什么有效，什么无效。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9672" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">知道什么时候该放弃</h1><p id="1d83" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">拒绝放弃一个问题对于开发人员来说是一个很好的品质，但是知道什么时候放弃也很重要。如果你在用头撞砖墙，而一系列的调查毫无进展，那么:</p><ul class=""><li id="42f9" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">休息一会儿，然后带着一个全新的想法回到现实中来</li><li id="6eac" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">暂停你目前的调查，尝试不同的方法</li></ul><p id="7d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多时候，当你几天后精神饱满地回来时，在调试高峰期看起来不可能的事情会变得很容易。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="761d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这些策略有用。如果你有任何其他的分享，请在下面的评论中告诉我！</p></div></div>    
</body>
</html>