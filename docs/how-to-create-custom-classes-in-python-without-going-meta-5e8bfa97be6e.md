# 如何在不使用元的情况下用 Python 创建自定义类

> 原文：<https://betterprogramming.pub/how-to-create-custom-classes-in-python-without-going-meta-5e8bfa97be6e>

## 在不使用元类的情况下使用 Python 元类的能力

![](img/eae73bd289751e52c29cf6ccd8c00bfb.png)

[张杰瑞](https://unsplash.com/@z734923105?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

使用 Python 元类非常强大，可以让你做非常漂亮的事情。其中一件很棒的事情就是定制类的创建。通过定制的类创建，你可以，例如，实现一个插件系统或者动态设置属性的默认值。

不幸的是，使用元类不仅非常强大，而且是 Python 的一个更高级(有时也很乏味)的概念。而且，即使您是 Python 之神，您可能仍然会遇到元类的问题，并且会这样想…

糊涂狗的 Gif。

例如，从具有不同元类的多个类继承是行不通的，因为这会导致元类冲突。解决元类冲突的唯一方法是通过人工干预，这可能非常困难——就像脑外科手术一样。如果您正在使用的库的新版本中引入了元类，情况会变得更糟。突然间，什么都不能工作了，你必须深入库代码的细节来解决这个冲突。这听起来不太好。

所以，问题是:库开发人员和 Python 新手开发人员如何享受定制类创建的好处，而不用担心破坏东西？

[PEP-487](https://www.python.org/dev/peps/pep-0487/) 和 Python 3.6+来救场。

在这篇文章中，我将向您简要介绍 PEP-487 中介绍的 python 中的定制类创建，并提供一个如何使用它创建简单插件系统的小示例。

你准备好了吗？让我们开始吧。

# 定制类创建

假设您想要构建一个应用程序，在该应用程序中，人们可以与不同种类的云数据仓库(DWH)进行对话，如 [BigQuery](https://cloud.google.com/bigquery) 、 [Redshift](https://aws.amazon.com/reshift) 或 [Snowflake](https://www.snowflake.com/) 。对于这个例子，假设所有的 DWH 都有不同的建立连接的方式，这对于每个 DWH 来说是非常特定的。用户应该能够从所有可用的列表中选择他们想要连接的 DWH。

## 不太好的解决方案

实现这一点的一种方法如下:

我在这里做了什么？我添加了一个`warehouse` 基类，它实现了泛型方法，并强制子类实现 connect 方法。使用它，我实现了`BigQuery`、`Redshift`和`Snowflake`的子类。我把这些类类型作为值放入字典，它们各自的名字作为键。最后，`get_connected_warehouse`方法获取用户想要连接的`warehouse`的名称，在字典中查找，并返回连接的`warehouse`。完成了。

这个解决方案当然有效，但是它有两个缺点。

1.  当有人想要添加一种新类型的数据仓库时，他们必须知道必须将它添加到`warehouses`字典中。
2.  当我们通过一个库提供这个功能时，扩展这个字典变得更加麻烦。

如果我们可以自动注册新的仓库子类而不是手动添加它们，那不是很好吗？

男性尖叫的 Gif，“是！”

这就是定制类创建发挥作用的地方。

# 更好的解决方案

让我们从上面重写代码。记住，我们的目标是以某种方式自动注册我们的子类。事不宜迟，我们可以这样做。

我在这里改变了什么？首先，我在`Warehouse` 基类中添加了一个`registry` 作为类变量。这个`registry` 最终将包含`Warehouse`的所有子类。为了方便起见，我还添加了一个类方法`get`，通过名称从`registry` 中检索类对象。但是子类如何进入注册表呢？

实际的魔法发生在类方法`__init_subclass__`中。当您的 Python 解释器第一次读取您的类定义代码时，这个方法被调用一次。当您导入类本身或导入定义它的模块时，就会出现这种情况。因为它是一个类方法，所以它获取`class` 对象作为参数。因此，这是一个完美的地方来做一些你想在每种类上运行一次的逻辑。

对我们来说，这意味着我们可以将参数`cls`给出的`class` 对象添加到我们的注册表中。我们还强迫开发人员给这个类起一个某种类型的名字，你可以从关键字参数中看到。这是不必要的，因为我们也可以使用类似于`cls.__name__`的东西来标识我们的`Warehouse` 类型。然而，我想展示的是，您还可以向`__init_subclass__`传递更多的关键字参数，您可以使用它们来设置/添加类属性。最后，请注意，您不必显式地将类方法`decorator` 添加到该函数中。这是为你含蓄地做的。

就是这样。如果您只想运行一些小的`pre init`代码，就不需要为元类而烦恼。现在你可以做你想做的:使用多重继承，潜在地为更高级的东西添加一个元类，等等。所有这些都不用担心会遇到冲突或元类冲突。

跳舞漫画的 Gif。

# 包裹

在本文中，我介绍了如何使用 Python 中的`__init_subclass__`在创建类之前轻松执行逻辑，而不必使用元类。

与使用元类相比，这种方法的优势在于:

1.  更容易理解和学习
2.  避免元类冲突和麻烦

感谢您关注这篇文章。一如既往，如有任何问题、意见或建议，请随时联系我。