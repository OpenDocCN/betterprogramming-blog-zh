<html>
<head>
<title>Build a Video Chat With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React Hooks建立视频聊天</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-video-chat-with-react-hooks-5f3337881327?source=collection_archive---------16-----------------------#2020-01-06">https://betterprogramming.pub/build-a-video-chat-with-react-hooks-5f3337881327?source=collection_archive---------16-----------------------#2020-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f1dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Twilio Video构建一个视频聊天应用程序，只与功能组件交互</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb447e175986ce2f43b219a3dbda02f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_O4qbg-YLkI5Fb6y2khpqQ.png"/></div></div></figure><p id="522b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们以前在Twilio博客上看过<a class="ae lq" href="https://www.twilio.com/blog/2018/03/video-chat-react.html" rel="noopener ugc nofollow" target="_blank">用React构建的视频聊天，但从那以后，在16.8版本中，React发布了</a><a class="ae lq" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>。钩子允许你在功能组件中使用状态或其他React特性，而不是编写一个类组件。</p><p id="3f0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将使用<a class="ae lq" href="https://www.twilio.com/docs/video/javascript" rel="noopener ugc nofollow" target="_blank"> Twilio Video </a>构建一个视频聊天应用程序，并使用<code class="fe lr ls lt lu b">useState</code>、<code class="fe lr ls lt lu b">useCallback</code>、<code class="fe lr ls lt lu b">useEffect</code>和<code class="fe lr ls lt lu b">useRef</code>钩子只与功能组件进行交互。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="485a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你需要什么</h1><p id="d6d9" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">要构建这个视频聊天应用程序，您需要以下内容:</p><ul class=""><li id="dada" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated"><a class="ae lq" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js和npm已安装</a>。</li><li id="2868" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">一个Twilio账户(在这里注册一个<a class="ae lq" href="https://www.twilio.com/try-twilio" rel="noopener ugc nofollow" target="_blank">免费的Twilio账户</a>)。</li></ul><p id="239f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦你得到了所有这些，我们就可以准备我们的开发环境了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="37a7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><p id="d6bd" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">因此，我们可以直接进入React应用程序，我们可以从我创建的的<a class="ae lq" href="https://github.com/philnash/react-express-starter/tree/twilio" rel="noopener ugc nofollow" target="_blank">React和Express starter应用程序</a> <a class="ae lq" href="https://www.twilio.com/blog/react-app-with-node-js-server-proxy" rel="noopener ugc nofollow" target="_blank">开始。下载或克隆starter app的</a><a class="ae lq" href="https://github.com/philnash/react-express-starter/tree/twilio" rel="noopener ugc nofollow" target="_blank">“twilio”分支</a>，进入新目录，安装依赖项:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="a2e0" class="nr md it lu b gy ns nt l nu nv">git clone -b twilio git@github.com:philnash/react-express-starter.git twilio-video-react-hooks<br/>cd twilio-video-react-hooks<br/>npm install</span></pre><p id="b8ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将<code class="fe lr ls lt lu b">.env.example</code>文件复制到<code class="fe lr ls lt lu b">.env</code>。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="fea7" class="nr md it lu b gy ns nt l nu nv">cp .env.example .env</span></pre><p id="8a2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行应用程序以确保一切正常运行:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="d982" class="nr md it lu b gy ns nt l nu nv">npm run dev</span></pre><p id="44f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该会在浏览器中看到这个页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/37ae68dbb7e3de3cbf68c747e956d6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*Aau22F478TdRglay.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="549f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">正在准备Twilio凭据</h1><p id="453d" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">若要连接到Twilio Video，我们需要一些凭据。从你的<a class="ae lq" href="https://www.twilio.com/console" rel="noopener ugc nofollow" target="_blank"> Twilio控制台</a>中，复制你的账户SID并将其作为<code class="fe lr ls lt lu b">TWILIO_ACCOUNT_SID</code>输入到<code class="fe lr ls lt lu b">.env</code>文件中。</p><p id="a626" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你还需要一个API密匙和密码，你可以在控制台中的<a class="ae lq" href="https://www.twilio.com/console/video/project/api-keys" rel="noopener ugc nofollow" target="_blank">可编程视频工具下创建它们。创建一个密钥对，并将SID和秘密作为<code class="fe lr ls lt lu b">TWILIO_API_KEY</code>和<code class="fe lr ls lt lu b">TWILIO_API_SECRET</code>添加到<code class="fe lr ls lt lu b">.env</code>文件中。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6949" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加一些风格</h1><p id="505b" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在这篇文章中，我们不打算关注CSS，但是让我们添加一些内容，这样结果看起来不会很糟糕！从这个网址中抓取<a class="ae lq" href="https://raw.githubusercontent.com/philnash/twilio-video-react-hooks/master/src/App.css" rel="noopener ugc nofollow" target="_blank">CSS并用它替换<code class="fe lr ls lt lu b">src/App.css</code>的内容。</a></p><p id="88fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们准备开始建造。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d631" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">规划我们的组件</h1><p id="ec50" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">一切都将从我们的<code class="fe lr ls lt lu b">App</code>组件开始，我们可以为应用程序布局页眉和页脚以及<code class="fe lr ls lt lu b">VideoChat</code>组件。</p><p id="2547" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lr ls lt lu b">VideoChat</code>组件中，我们想要显示一个<code class="fe lr ls lt lu b">Lobby</code>组件，用户可以在其中输入他们的名字和他们想要加入的房间。</p><p id="ebfb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦他们输入了这些细节，我们将用一个<code class="fe lr ls lt lu b">Room</code>组件替换<code class="fe lr ls lt lu b">Lobby</code>，该组件将处理与房间的连接并显示视频聊天中的参与者。</p><p id="9314" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，对于房间中的每个参与者，我们将呈现一个<code class="fe lr ls lt lu b">Participant</code>组件来处理他们的媒体显示。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b83" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建组件</h1><h2 id="1a53" class="nr md it bd me nx ny dn mi nz oa dp mm ld ob oc mo lh od oe mq ll of og ms oh bi translated">应用程序组件</h2><p id="53b8" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">打开<code class="fe lr ls lt lu b">src/App.js</code>，这里有很多我们可以删除的初始示例应用程序的代码。</p><p id="534c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，<code class="fe lr ls lt lu b">App</code>组件是一个基于类的组件。我们说过要用功能组件构建整个应用程序，所以我们最好改变这一点。</p><p id="ccf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从导入中，删除<code class="fe lr ls lt lu b">Component</code>和<code class="fe lr ls lt lu b">logo.svg</code>的导入。用一个呈现应用程序框架的函数替换整个<code class="fe lr ls lt lu b">App</code>类。整个文件应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="cdfb" class="nr md it bd me nx ny dn mi nz oa dp mm ld ob oc mo lh od oe mq ll of og ms oh bi translated">视频聊天组件</h2><p id="8bed" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">该组件将根据用户是否输入了用户名和房间名来显示大厅或房间。创建一个新的组件文件<code class="fe lr ls lt lu b">src/VideoChat.js</code>，并使用以下样板文件开始:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="765e" class="nr md it lu b gy ns nt l nu nv">import React from 'react';<br/><br/>const VideoChat = () =&gt; {<br/>  return &lt;div&gt;&lt;/div&gt; // we'll build up our response later<br/>};<br/><br/>export default VideoChat;</span></pre><p id="8ec5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">VideoChat</code>组件将成为处理聊天数据的顶级组件。</p><p id="a25c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要存储加入聊天的用户的用户名，他们将要连接的房间的房间名，以及他们从服务器获取的<a class="ae lq" href="https://www.twilio.com/docs/video/tutorials/user-identity-access-tokens" rel="noopener ugc nofollow" target="_blank">访问令牌</a>。</p><p id="1cf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将构建一个表单，在下一个组件中输入一些数据。</p><p id="38f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于React钩子，我们使用<code class="fe lr ls lt lu b"><a class="ae lq" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code> <a class="ae lq" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">钩子</a>来存储这些数据。</p><h2 id="172b" class="nr md it bd me nx ny dn mi nz oa dp mm ld ob oc mo lh od oe mq ll of og ms oh bi translated">使用状态</h2><p id="5715" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lr ls lt lu b">useState</code>是一个函数，它接受一个参数，即初始状态，并返回一个包含当前状态的数组和一个更新该状态的函数。</p><p id="940f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将析构该数组，给出两个不同的变量，如<code class="fe lr ls lt lu b">state</code>和<code class="fe lr ls lt lu b">setState</code>。我们将使用<code class="fe lr ls lt lu b">setState</code>来跟踪组件中的用户名、房间名和令牌。</p><p id="dfa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从React导入<code class="fe lr ls lt lu b">useState</code>开始，为用户名、房间名和令牌设置状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="b241" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们需要两个函数来处理当用户在各自的输入元素中输入时对<code class="fe lr ls lt lu b">username</code>和<code class="fe lr ls lt lu b">roomName</code>的更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="11ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这可以工作，但是我们可以在这里使用另一个React钩子来优化我们的组件；<code class="fe lr ls lt lu b">useCallback</code>。</p><h2 id="3c6e" class="nr md it bd me nx ny dn mi nz oa dp mm ld ob oc mo lh od oe mq ll of og ms oh bi translated">使用回调</h2><p id="e77d" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">每次调用该函数组件时，都会重新定义<code class="fe lr ls lt lu b">handleXXX</code>函数。它们需要成为组件的一部分，因为它们依赖于<code class="fe lr ls lt lu b">setUsername</code>和<code class="fe lr ls lt lu b">setRoomName</code>函数，但是它们每次都是相同的。</p><p id="52e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">useCallback</code>是一个React钩子，允许我们<a class="ae lq" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆</a>函数。也就是说，如果它们在函数调用之间是相同的，它们就不会被重定义。</p><p id="4b46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">useCallback</code>接受两个参数，要记忆的函数和函数依赖项的数组。如果函数的任何依赖关系发生变化，这意味着被记忆的函数是过时的，然后该函数被重新定义和记忆。</p><p id="794e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，这两个函数没有依赖关系，所以一个空数组就足够了(来自<code class="fe lr ls lt lu b">useState</code>钩子的<code class="fe lr ls lt lu b">setState</code>函数被认为是函数中的常量)。</p><p id="e6f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重写这个函数，我们需要将<code class="fe lr ls lt lu b">useCallback</code>添加到文件顶部的导入中，然后包装这些函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="49f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当用户提交表单时，我们希望将用户名和房间名称发送到服务器，以换取我们可以用来进入房间的访问令牌。我们也将在这个组件中创建这个函数。</p><p id="ad70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>将数据作为JSON发送到端点，接收并解析响应，然后使用<code class="fe lr ls lt lu b">setToken</code>将令牌存储在我们的状态中。</p><p id="545e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还将用<code class="fe lr ls lt lu b">useCallback</code>包装这个函数，但是在这种情况下，这个函数将依赖于<code class="fe lr ls lt lu b">username</code>和<code class="fe lr ls lt lu b">roomName</code>，所以我们将它们作为依赖项添加到<code class="fe lr ls lt lu b">useCallback</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="7878" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个组件的最后一个功能，我们将添加一个注销功能。这将把用户逐出房间，并让他们返回大厅。为此，我们将令牌设置为<code class="fe lr ls lt lu b">null</code>。再一次，我们将它包装在<code class="fe lr ls lt lu b">useCallback</code>中，没有依赖关系。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="ea16" class="nr md it lu b gy ns nt l nu nv">const handleLogout = useCallback(event =&gt; {<br/>    setToken(null);<br/>  }, []);<br/><br/>  return &lt;div&gt;&lt;/div&gt; // we'll build up our response later<br/>};</span></pre><p id="fe40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个组件主要是编排它下面的组件，所以在我们创建这些组件之前，没有什么需要渲染的。</p><p id="57ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来让我们创建<code class="fe lr ls lt lu b">Lobby</code>组件来呈现要求输入用户名和房间名的表单。</p><h2 id="063f" class="nr md it bd me nx ny dn mi nz oa dp mm ld ob oc mo lh od oe mq ll of og ms oh bi translated">大厅组件</h2><p id="b56d" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lr ls lt lu b">Lobby</code>组件的主要工作是使用这些道具来呈现表单，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9aff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们更新<code class="fe lr ls lt lu b">VideoChat</code>组件来渲染<code class="fe lr ls lt lu b">Lobby</code>，除非我们有一个<code class="fe lr ls lt lu b">token</code>，否则我们将渲染<code class="fe lr ls lt lu b">username</code>、<code class="fe lr ls lt lu b">roomName</code>和<code class="fe lr ls lt lu b">token</code>。</p><p id="8fb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要在文件的顶部导入<code class="fe lr ls lt lu b">Lobby</code>组件，并在组件函数的底部渲染一些JSX:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="6a11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了让它显示在页面上，我们还需要将<code class="fe lr ls lt lu b">VideoChat</code>组件导入到<code class="fe lr ls lt lu b">App</code>组件中并呈现它。再次打开<code class="fe lr ls lt lu b">src/App.js</code>并进行以下更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="14b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">确保应用程序仍在运行(或使用<code class="fe lr ls lt lu b">npm run dev</code>重启)，并在浏览器中打开它，您将看到一个表单。</p><p id="e784" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">填写用户名和房间名称并提交，视图将会显示您选择的名称以及从服务器检索的令牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/27eb835c5e0b0cf4be116a122572e2b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*XQkIhkWr0OqPP73e.png"/></div></figure><h2 id="2e84" class="nr md it bd me nx ny dn mi nz oa dp mm ld ob oc mo lh od oe mq ll of og ms oh bi translated">房间组件</h2><p id="597e" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">现在我们已经向应用程序添加了用户名和房间名，我们可以使用它们加入Twilio视频聊天室。要使用Twilio视频服务，我们需要JS SDK，安装时使用:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="c0ae" class="nr md it lu b gy ns nt l nu nv">npm install twilio-video --save</span></pre><p id="8e03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lr ls lt lu b">src</code>目录中创建一个名为<code class="fe lr ls lt lu b">Room.js</code>的新文件。从下面的样板文件开始。</p><p id="81a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在这个组件中使用Twilio Video SDK以及<code class="fe lr ls lt lu b">useState</code>和<code class="fe lr ls lt lu b">useEffect</code>钩子。我们还将从父组件<code class="fe lr ls lt lu b">VideoChat</code>中获得<code class="fe lr ls lt lu b">roomName</code>、<code class="fe lr ls lt lu b">token</code>和<code class="fe lr ls lt lu b">handleLogout</code>作为道具:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="cd60" class="nr md it lu b gy ns nt l nu nv">import React, { useState, useEffect } from 'react';<br/>import Video from 'twilio-video';<br/><br/>const Room = ({ roomName, token, handleLogout }) =&gt; {<br/><br/>});<br/><br/>export default Room;</span></pre><p id="b1ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该组件要做的第一件事是使用令牌和<code class="fe lr ls lt lu b">roomName</code>连接到Twilio视频服务。当我们连接时，我们将得到一个<code class="fe lr ls lt lu b">room</code>对象，我们将希望存储它。</p><p id="9615" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该房间还包括一个参与者列表，该列表会随着时间的推移而变化，因此我们也会存储它们。我们将使用<code class="fe lr ls lt lu b">useState</code>来存储这些，房间的初始值将是<code class="fe lr ls lt lu b">null</code>,参与者的初始值是一个空数组:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="4d94" class="nr md it lu b gy ns nt l nu nv">const Room = ({ roomName, token, handleLogout }) =&gt; {<br/>  const [room, setRoom] = useState(null);<br/>  const [participants, setParticipants] = useState([]);<br/>});</span></pre><p id="1fa8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们加入房间之前，让我们为这个组件渲染一些东西。我们将映射参与者的阵列，以显示每个参与者的身份，并显示房间中本地参与者的身份:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="dc87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们更新<code class="fe lr ls lt lu b">VideoChat</code>组件来呈现这个<code class="fe lr ls lt lu b">Room</code>组件，代替我们之前的占位符信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="55ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在浏览器中运行它将显示房间名称和注销按钮，但没有参与者身份，因为我们还没有连接和加入房间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/76b05a63dc5f3aee62ab5a7cedf27d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*AZ8oOzijBN7Ba80r.png"/></div></figure><p id="32f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经获得了加入房间所需的所有信息，因此我们应该在组件的第一次呈现时触发连接操作。</p><p id="4c14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦组件被破坏，我们也想退出房间(没有必要在后台保持WebRTC连接)。这些都是副作用。</p><p id="4de0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于基于类的组件，这是您使用<code class="fe lr ls lt lu b">componentDidMount</code>和<code class="fe lr ls lt lu b">componentWillUnmount</code>生命周期方法的地方。对于React钩子，我们将使用<a class="ae lq" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> useEffect钩子</a>。</p><h2 id="50cd" class="nr md it bd me nx ny dn mi nz oa dp mm ld ob oc mo lh od oe mq ll of og ms oh bi translated">使用效果</h2><p id="6325" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lr ls lt lu b">useEffect</code>是一个函数，它接受一个方法并在组件渲染后运行该方法。</p><p id="5f59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们的组件加载时，我们希望连接到视频服务，我们还需要在参与者加入或离开房间时运行的函数，以分别添加和删除参与者。</p><p id="8bcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过在<code class="fe lr ls lt lu b">Room.js</code>中的JSX之前添加以下代码来开始构建我们的钩子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4da3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这使用<code class="fe lr ls lt lu b">token</code>和<code class="fe lr ls lt lu b">roomName</code>连接到Twilio视频服务。</p><p id="d14a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当连接完成时，我们设置房间状态，为连接或断开连接的其他参与者设置一个监听器，并遍历任何现有的参与者，使用我们之前编写的<code class="fe lr ls lt lu b">participantConnected</code>函数将它们添加到参与者的数组状态。</p><p id="0de3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个好的开始，但如果我们移除组件，我们仍然会连接到房间。所以，我们也需要清理自己的垃圾。</p><p id="7e5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们从传递给<code class="fe lr ls lt lu b">useEffect</code>的回调函数中返回一个函数，它将在组件卸载后运行。当一个使用<code class="fe lr ls lt lu b">useEffect</code>的组件被重新渲染时，这个函数也会被调用，在再次运行之前清理效果。</p><p id="45ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们返回一个函数，它停止所有本地参与者的跟踪，然后断开与房间的连接，如果本地参与者已连接:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1d83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，在这里，我们使用了之前从<code class="fe lr ls lt lu b">useState</code>获得的<code class="fe lr ls lt lu b">setRoom</code>函数的回调版本。</p><p id="3cc6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你将一个函数传递给<code class="fe lr ls lt lu b">setRoom</code>，那么它将被调用之前的值，在这个例子中，现有的房间，我们称之为<code class="fe lr ls lt lu b">currentRoom</code>，它将把状态设置为你返回的任何值。</p><p id="acc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们还没有完成。在当前状态下，该组件将退出已连接的房间，并在每次重新渲染时重新连接到该房间。这并不理想，所以我们需要告诉它什么时候应该清理并再次运行效果。</p><p id="b2f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很像<code class="fe lr ls lt lu b">useCallback</code>，我们通过传递效果依赖的变量数组来实现。如果变量已经改变，我们想先清理，然后再运行效果。如果它们没有改变，就没有必要再次运行效果。</p><p id="fc9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看功能，我们可以看到，如果<code class="fe lr ls lt lu b">roomName</code>或<code class="fe lr ls lt lu b">token</code>发生变化，我们会连接到不同的房间或作为不同的用户。让我们也将这些变量作为数组传递给<code class="fe lr ls lt lu b">useEffect</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4ea2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们在这个效果中定义了两个回调函数。您可能认为这些应该像我们之前做的那样包装在<code class="fe lr ls lt lu b">useCallback</code>中，但事实并非如此。</p><p id="5dbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为它们是效果的一部分，所以只有在依赖项更新时才会运行。你也不能在回调函数中使用钩子，<a class="ae lq" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">它们必须直接在组件或自定义钩子中使用</a>。</p><p id="5cc0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们基本上完成了这个组件。让我们检查一下它目前是否工作，重新加载应用程序，输入用户名和房间名。</p><p id="81c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你进入房间时，你应该看到你的身份出现。单击注销按钮将带您回到大厅。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e9c8c74b56edc9e4c35a2c826c465973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*DjIdIJ-6GdQiA5co.png"/></div></figure><p id="ed2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">拼图的最后一块是呈现视频通话中的参与者，将他们的视频和音频添加到页面中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c336" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参与者组件</h1><p id="a140" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在<code class="fe lr ls lt lu b">src</code>中创建一个名为<code class="fe lr ls lt lu b">Participant.js</code>的新组件。我们将从通常的样板文件开始，尽管在这个组件中，我们将使用三个钩子，<code class="fe lr ls lt lu b">useState</code>和<code class="fe lr ls lt lu b">useEffect</code>，我们已经看到了，还有<code class="fe lr ls lt lu b">useRef</code>。</p><p id="c5b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还将在道具中传递一个<code class="fe lr ls lt lu b">participant</code>对象，并用<code class="fe lr ls lt lu b">useState</code>跟踪参与者的视频和音频轨迹:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4772" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们从参与者那里获得一个视频或音频流时，我们会想把它附加到一个<code class="fe lr ls lt lu b">&lt;video&gt;</code>或<code class="fe lr ls lt lu b">&lt;audio&gt;</code>元素上。</p><p id="59c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于JSX是声明性的，我们不能直接访问DOM(文档对象模型)，所以我们需要通过其他方式获得对HTML元素的引用。</p><p id="40ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React通过<a class="ae lq" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> refs </a>和<a class="ae lq" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef钩子</a>提供对DOM的访问。要使用引用，我们先声明它们，然后在JSX中引用它们。在渲染任何东西之前，我们使用<code class="fe lr ls lt lu b">useRef</code>钩子创建我们的引用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="7136" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们归还我们想要的JSX。为了将JSX元素连接到ref，我们使用了<code class="fe lr ls lt lu b">ref</code>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="b446" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还将<code class="fe lr ls lt lu b">&lt;video&gt;</code>和<code class="fe lr ls lt lu b">&lt;audio&gt;</code>标签的属性设置为自动播放(这样它们一有媒体流就播放)和静音(这样我就不会在测试期间被反馈弄聋，如果你犯了这个错误，你会感谢我的)。</p><p id="142d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个组件还没有做太多，因为我们需要使用一些效果。我们将在这个组件中实际使用三次<code class="fe lr ls lt lu b">useEffect</code>钩子，你很快就会明白为什么。</p><p id="bd5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个<code class="fe lr ls lt lu b">useEffect</code>钩子将设置视频和音频轨道的状态，并为添加或删除轨道时的参与者对象设置监听器。当组件被卸载时，它还需要清理和删除这些侦听器并清空状态。</p><p id="b750" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的第一个<code class="fe lr ls lt lu b">useEffect</code>钩子中，我们将添加两个函数，这两个函数将在添加或删除参与者的音轨时运行。</p><p id="a897" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些函数都检查轨道是音频轨道还是视频轨道，然后使用相关的状态函数将其添加到状态中或从状态中删除。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="29d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们使用<code class="fe lr ls lt lu b">participant</code>对象来设置音频和视频轨道的初始值，使用我们刚刚编写的函数来设置<code class="fe lr ls lt lu b">trackSubscribed</code>和<code class="fe lr ls lt lu b">trackUnsubscribed</code>事件的侦听器，然后在返回的函数中进行清理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="6a26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，钩子只依赖于<code class="fe lr ls lt lu b">participant</code>对象，除非参与者改变，否则不会被清理并重新运行。</p><p id="080b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要一个<code class="fe lr ls lt lu b">useEffect</code>钩子将视频和音频轨道连接到DOM，这里我只展示其中的一个，视频版本，但是如果你用视频代替音频，音频是一样的。</p><p id="f32f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">钩子将从状态中获取第一个视频轨道，如果它存在，将它附加到我们前面用ref捕获的DOM节点。可以使用<code class="fe lr ls lt lu b">videoRef.current</code>在ref中引用当前DOM节点。</p><p id="83df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们附加了视频轨道，我们还需要返回一个函数来在清理过程中分离它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="0eaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重复<code class="fe lr ls lt lu b">audioTracks</code>的挂钩，我们准备好从<code class="fe lr ls lt lu b">Room</code>组件中呈现我们的<code class="fe lr ls lt lu b">Participant</code>组件。</p><p id="84e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在文件顶部导入<code class="fe lr ls lt lu b">Participant</code>组件，然后用组件本身替换显示标识的段落。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="077d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在重新加载应用程序，加入一个房间，你会在屏幕上看到你自己。打开另一个浏览器，加入同一个房间，你会看到自己两次。点击退出按钮，你将回到大厅。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/6a9553e27d75dd3f4e65cd8ddaa883eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*3HUp81QQWYMScaGW.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="803d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="bf74" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在React中使用Twilio视频构建需要更多的工作，因为有各种各样的副作用要处理。</p><p id="e3e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从请求获取令牌、连接到视频服务，到操纵DOM连接<code class="fe lr ls lt lu b">&lt;video&gt;</code>和<code class="fe lr ls lt lu b">&lt;audio&gt;</code>元素，有相当多的事情需要考虑。</p><p id="b92d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们看到了如何使用<code class="fe lr ls lt lu b">useState</code>、<code class="fe lr ls lt lu b">useCallback</code>、<code class="fe lr ls lt lu b">useEffect</code>和<code class="fe lr ls lt lu b">useRef</code>来控制这些副作用，并使用功能组件构建我们的应用程序。</p><p id="cc3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望这能帮助你理解Twilio Video和React Hooks。这个应用程序<a class="ae lq" href="https://github.com/philnash/twilio-video-react-hooks" rel="noopener ugc nofollow" target="_blank">的所有源代码都可以在GitHub </a>上找到，你可以拆开再组装起来。</p><p id="8e69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于React Hooks的进一步阅读，请看一下<a class="ae lq" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>，它非常全面，这是关于Hooks 中<a class="ae lq" href="https://wattenberger.com/blog/react-hooks" rel="noopener ugc nofollow" target="_blank">思维的可视化，并查看</a><a class="ae lq" href="https://overreacted.io/a-complete-guide-to-useeffect/" rel="noopener ugc nofollow" target="_blank"> Dan Abramov对</a> <code class="fe lr ls lt lu b"><a class="ae lq" href="https://overreacted.io/a-complete-guide-to-useeffect/" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>的深入研究(这是一篇很长的帖子，但我保证这是值得的)。</p><p id="4b4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解更多关于使用Twilio Video构建的信息，请查看这些关于在视频聊天中切换摄像头的帖子。</p><p id="7eef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你开发了这些，或者其他很酷的视频聊天功能，请在评论中告诉我。</p></div></div>    
</body>
</html>