<html>
<head>
<title>How to Recover From a Git Merge Mess</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从Git合并混乱中恢复</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-recover-from-a-git-merge-mess-9070395df249?source=collection_archive---------4-----------------------#2021-03-12">https://betterprogramming.pub/how-to-recover-from-a-git-merge-mess-9070395df249?source=collection_archive---------4-----------------------#2021-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b4a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于git引用、提交和分支的深入讨论</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/651d4ae0651f6058ed05c3a13c24fddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IFuPeHEhE7f6UxqU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@wonderlane?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Wonderlane </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="89b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的项目使用过<a class="ae ky" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git版本控制系统</a>吗？</p><p id="0702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一名软件开发人员，答案可能是“是的，每天都有”。</p><p id="1c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git是世界上使用最广泛的现代版本控制系统。自从它由Linus Torvalds在2005年创建以来，它在协调程序员之间的工作方面发挥了重要作用，这些程序员在软件开发期间协作开发源代码。</p><p id="4ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git提供了速度、数据完整性和对分布式非线性工作流的支持。也带来了痛苦和乱七八糟的操作。</p><p id="9a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有官方的Git文档，也有很多博客和指南。但是要掌握Git版本控制系统还是比较难的。<code class="fe lv lw lx ly b">git &lt;command&gt; --help</code>是一本很长的手册，有许多选项。讽刺的是，科学的描述在你知道命令之后更有意义。</p><p id="cf07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要知道每个Git命令，更不用说每个选项。从Git引用开始，仔细看看Git提交和Git分支。希望这些概念能够帮助您有效地管理Git，并在出现问题时能够解决问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6f85" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Git储存库</h1><p id="9bef" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Git存储库是一个版本控制系统，它跟踪文件的变化。这些更改由提交进行跟踪。每台计算机上的每个Git目录都是一个完全成熟的存储库，具有完整的历史和完整的版本跟踪功能，独立于网络访问或中央服务器。</p><h2 id="8f83" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">工作树/工作目录</h2><p id="35ca" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">工作树或工作目录由当前正在处理的文件组成。它包含自上次提交以来未更改的文件、新添加的文件和/或修改的文件。<code class="fe lv lw lx ly b">git status</code>命令显示工作树状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="efbc" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">索引/暂存区</h2><p id="fec2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">索引或临时区域是准备提交的地方。它包括由<code class="fe lv lw lx ly b">git add</code>策划的文件。</p><h2 id="3dbc" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">提交/合并</h2><p id="379d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在<code class="fe lv lw lx ly b">git commit</code>之后，暂存文件被移动到提交，作为本地存储库中的记录。本地提交可以<code class="fe lv lw lx ly b">git push</code>到远程存储库进行共享，并且可能与其他特性开发合并。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="061d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Git提交</h1><p id="7c72" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Git通过提交来跟踪代码变更，提交是某个时间点上所有文件的快照。在提交中有两件事很重要:</p><ul class=""><li id="b493" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">自上次提交以来的更改列表。</li><li id="bd5a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">一些属性，包括在存储库中唯一标识提交的提交ID。</li></ul><h2 id="8f3c" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">长哈希</h2><p id="7188" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当提交文件时，Git生成一个提交ID，这是一个40个字符的SHA-1散列。该值是根据提交日期、其以前的提交ID、作者姓名等计算的。这个提交ID是一个Git引用。40个字符的完整哈希也称为长哈希。</p><h2 id="989c" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">主要分支</h2><p id="3f8c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们克隆我们的示例存储库来了解更多信息:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="ef6d" class="nd mh it ly b gy oj ok l ol om">$ git clone <a class="ae ky" href="https://github.com/JenniferFuBook/git-fun.git" rel="noopener ugc nofollow" target="_blank">https://github.com/JenniferFuBook/git-fun.git</a></span></pre><p id="d132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从2020年10月1日开始，GitHub上所有新的Git库都将默认分支命名为<code class="fe lv lw lx ly b">main</code>，而不是<code class="fe lv lw lx ly b">master</code>。默认情况下，我们在<code class="fe lv lw lx ly b">main</code>分支上:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="d4cc" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">提交详细信息</h2><p id="64b5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">git log</code>是访问提交历史的命令。在<code class="fe lv lw lx ly b">main</code>分支，<code class="fe lv lw lx ly b">git log</code>列出所有提交:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dfa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">263230cf1cdfcd2b1bba5653a12a7bb3599b1385</code>(第58行)是第一次提交的引用指针。</p><p id="8b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定提交ID，<code class="fe lv lw lx ly b">git show</code>显示提交属性和实际更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e7bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第<code class="fe lv lw lx ly b">8</code>行显示了索引范围，它由内部元数据(不是散列)组成。</p><p id="0394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以添加选项来仅显示更改的文件名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<code class="fe lv lw lx ly b">git log</code>只显示提交属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">git log</code>有压缩格式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="d615" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">短哈希</h2><p id="fcd4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">长哈希可以缩写为短哈希，只要该值在存储库中唯一标识提交，就可以使用前n个字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="71a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反之亦然，可以从短哈希中检索长哈希:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="5341" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">标签</h2><p id="8691" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">因为散列很难记住，所以我们可以创建一个标签来方便地引用它。通常，标签应用于特殊修订，如发布版本。在我们的示例存储库中，我们已经标记了第一个提交:<code class="fe lv lw lx ly b">git tag -a starting-point 263230cf1cdfcd2b1bba5653a12a7bb3599b1385</code>。标签<code class="fe lv lw lx ly b">starting-point</code>可以方便地用来标识提交。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="c397" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">提交差异</h2><p id="5741" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以使用以下命令将提交<code class="fe lv lw lx ly b">f68d41c</code>中的<code class="fe lv lw lx ly b">file.text</code>与工作树上的当前命令进行比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以比较两次提交之间的<code class="fe lv lw lx ly b">file.text</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="3660" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">本地提交</h2><p id="8f7c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">转到<code class="fe lv lw lx ly b">branch2</code>并提交:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">git cherry</code>来检查没有被推送到远程的本地提交:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">git log</code>也可以显示本地提交:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">行<code class="fe lv lw lx ly b">5</code>指定这是一个本地提交。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6470" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Git分支</h1><p id="9f3a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Git分支是一个独立的工作环境，允许独立开发不同的特性。</p><p id="d73e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个分支都有一个名字。下面的命令显示了我们的示例存储库，它有远程分支、<code class="fe lv lw lx ly b">branch1</code>、<code class="fe lv lw lx ly b">branch2</code>、<code class="fe lv lw lx ly b">branch2</code>、<code class="fe lv lw lx ly b">branch4</code>和<code class="fe lv lw lx ly b">main</code>。目前只检出了<code class="fe lv lw lx ly b">main</code>有本地工作树。<code class="fe lv lw lx ly b">*</code>标记当前分支。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="dc5d" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">图示</h2><p id="7bb8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">分支没有严格的父分支。相反，它有一个特定的提交路径。<code class="fe lv lw lx ly b">git log —-graph</code>在输出的左侧绘制基于文本的提交历史图形。每个<code class="fe lv lw lx ly b">*</code>代表一个提交，<code class="fe lv lw lx ly b">*</code>下面的输入行代表父提交。多个传入行表示合并，而传出行标记一个共同的祖先。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种图形表示也有一种压缩格式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="17cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git日志图是帮助我们阅读Git结构和解决问题的基础。编写有意义且唯一的提交消息对于快速发现提交非常重要。</p><p id="0b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对最后一条提交消息不满意，可以用新的描述重写它:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="1cbb" class="nd mh it ly b gy oj ok l ol om">git commit --amend -m "&lt;new-message&gt;"</span></pre><p id="67c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修改本地提交是可以的。对于推式提交，改变历史不是一个好主意，但是<code class="fe lv lw lx ly b">git push --force</code>适用于重命名的提交。</p><h2 id="8f22" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">头部</h2><p id="52e0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">分支是一系列提交的末端，由路径的最后一个提交id标识。<code class="fe lv lw lx ly b">HEAD</code>是指向当前分支顶端的引用指针。它仅仅是当前的提交ID。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="303d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以检查<code class="fe lv lw lx ly b">branch2</code>并列出所有本地和远程分支:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="16ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">HEAD</code>是记忆tip提交ID的简单语法。<code class="fe lv lw lx ly b">HEAD^</code>指向<code class="fe lv lw lx ly b">HEAD</code>的第一个父节点。<code class="fe lv lw lx ly b">HEAD~n</code>是<code class="fe lv lw lx ly b">HEAD</code>的<code class="fe lv lw lx ly b">nth</code>代祖先。<code class="fe lv lw lx ly b">HEAD</code>可简称为<code class="fe lv lw lx ly b">@</code>。</p><p id="7386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe lv lw lx ly b">branch3</code>上的提交日志:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">HEAD</code>语法来过滤输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="6c9a" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">新分支</h2><p id="da90" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通过将分支名称连接到提交ID来创建分支。它可以通过以下命令创建:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="d6a8" class="nd mh it ly b gy oj ok l ol om">$ git branch &lt;branchname&gt; [&lt;reference&gt;]</span></pre><p id="1015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这创建了一个新的分支，它的头指向<code class="fe lv lw lx ly b">reference</code>，可以用提交ID、分支名称、标签或任何链接到提交ID的方法来指定。如果省略<code class="fe lv lw lx ly b">reference</code>，将使用当前的<code class="fe lv lw lx ly b">HEAD</code>。</p><p id="0105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们当前不在某个分支上，我们可以强制将该分支重新分配给任何引用:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="b798" class="nd mh it ly b gy oj ok l ol om">$ git branch -f &lt;branchname&gt; [&lt;reference&gt;]</span></pre><h2 id="1e91" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">分支差异</h2><p id="9dc8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以在Git存储库中区分不同分支。以下两点语法比较了分支并显示了<code class="fe lv lw lx ly b">origin/main</code>和<code class="fe lv lw lx ly b">origin/branch4</code>之间的变化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="401e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三点语法将两个分支的共同祖先的变化与点之后的分支进行比较。</p><p id="7535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">origin/main</code>和<code class="fe lv lw lx ly b">origin/branch4</code>的共同祖先是什么？可以通过<code class="fe lv lw lx ly b">git merge-base</code>命令查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查<code class="fe lv lw lx ly b">git log --graph</code>之前的输出，我们可以确认<code class="fe lv lw lx ly b">36eda0253bd17e8bbe240b151b408b194042056a</code>是<code class="fe lv lw lx ly b">main</code>从<code class="fe lv lw lx ly b">branch4</code>拉取的提交。</p><p id="faae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">git diff origin/main…origin/branch4</code>返回nothing。因此，自最后一个共同祖先以来没有任何变化。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7916" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何从合并的混乱中恢复？</h1><p id="e34c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Git分支允许我们在多个分支上独立工作。当两个分支合并时，我们很可能会面临合并冲突。在另一篇文章的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/git-merge-squash-rebase-or-pull-what-to-choose-50b331d3e7c1">中，我们讨论了如何使用Git merge、squash、rebase或pull来解决合并冲突。最好的方法是避免合并混乱。</a></p><p id="818c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，工作目录可能处于混乱的状态。例如，您的更改丢失了，或者其他开发人员的更改出现在您的pull请求中。重要的是知道如何从合并混乱中恢复，不管它是由<code class="fe lv lw lx ly b">git merge</code>、<code class="fe lv lw lx ly b">git rebase</code>还是<code class="fe lv lw lx ly b">git pull</code>引起的。</p><p id="9f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恢复意味着我们不会丢失任何工作:</p><ul class=""><li id="e3eb" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">已经隐藏的文件可以被检索/取消隐藏。</li><li id="6b0d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">已经提交的文件可以被检索/精选。</li><li id="8123" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">可以将分支重置为首选参考。</li></ul><h2 id="702c" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">贮藏</h2><p id="a94d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">提交更改是安全的，因为提交的所有内容都成为Git历史的一部分。从这个意义上说，这项工作不会丢失。</p><p id="8c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在某些情况下，提交可能没有准备好。对于这些情况，我们可以将更改隐藏在一个脏的工作目录中。</p><p id="c46b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">branch4</code>上进行更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="41e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入<code class="fe lv lw lx ly b">git stash save "Changing sixth line"</code>后，工作目录干净。</p><p id="6f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，做另一个改变:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入<code class="fe lv lw lx ly b">git stash save "Thinking…"</code>后，工作目录又干净了。</p><p id="97f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是藏匿清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ccdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这显示了隐藏描述的优势。稍后，描述有助于我们挑选要取消的隐藏内容:</p><ul class=""><li id="0d26" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">要应用存储并将其从存储堆栈中移除，请键入<code class="fe lv lw lx ly b">git stash pop stash@{n}</code>。</li><li id="1ce4" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">要应用存储并将其保留在存储堆栈中，请键入<code class="fe lv lw lx ly b">git stash apply stash@{n}</code>。</li></ul><h2 id="1e31" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">樱桃采摘</h2><p id="0bd8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于任何现有的提交，我们可以使用<code class="fe lv lw lx ly b">git cherry-pick</code>命令将更改应用到当前分支<code class="fe lv lw lx ly b">HEAD</code>。</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="e58b" class="nd mh it ly b gy oj ok l ol om">git cherry-pick &lt;reference&gt;</span></pre><p id="0162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以选择对当前分支<code class="fe lv lw lx ly b">HEAD</code>的特定提交，或者一系列提交。</p><h2 id="adb7" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">重置分支</h2><p id="cd5b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在一个分支上，我们可以使用<code class="fe lv lw lx ly b">git reset</code>将电流<code class="fe lv lw lx ly b">HEAD</code>重置为<code class="fe lv lw lx ly b">reference</code>。</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="0c39" class="nd mh it ly b gy oj ok l ol om">$ git reset [&lt;mode&gt;] [&lt;<!-- -->reference<!-- -->&gt;]</span></pre><p id="e35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">git reset --hard &lt;reference&gt;</code>将删除工作目录中的更改，并将分支指向特定的<code class="fe lv lw lx ly b">reference</code>。</p><p id="c64a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">git reset --soft &lt;reference&gt;</code>将在工作目录中保存更改，并将分支指向特定的<code class="fe lv lw lx ly b">reference</code>。当存在冲突时，您可能无法使用软复位。</p><p id="7b45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是常用的命令:</p><ul class=""><li id="47fd" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">git reset —-hard origin/&lt;branch-name&gt;</code>:删除所有本地更改/提交。</li><li id="d693" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">git reset --soft HEAD~1</code>:撤消上一次提交，但保留更改。</li></ul><p id="ca5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，如果一个分支真的搞砸了，我们可能想开一个新的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="be43" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">Git参考日志</h2><p id="617a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">git log</code>显示当前的<code class="fe lv lw lx ly b">HEAD</code>及其祖先。它是包含在推送、拉入、获取或克隆中的远程和本地历史。</p><p id="d1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">git reflog</code>显示了<code class="fe lv lw lx ly b">HEAD</code>指向的提交的有序列表。历史只存在于本地存储库中。在一些回退操作之后，引用可能变得不可访问。<code class="fe lv lw lx ly b">git reflog</code>将历史记录保留一段时间(垃圾收集运行前两周)。参考日志提供了一个恢复窗口，但是无法完成的提交最终会被删除。</p><p id="005f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们修改示例存储库后的<code class="fe lv lw lx ly b">git reflog</code>的快照:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0f6f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="3ce8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Git版本控制系统使团队能够同时处理大型项目。当存储库被搞乱时，我们不应该惊慌——只要工作得到了隐藏或提交的支持，我们总是可以将它们恢复/重新应用到代码库中。</p><p id="ceb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是Git的总体帮助:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fb22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在觉得简单了吗？</p><p id="7c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢乌里扬·张、戈塔姆·穆塔和悉达多·钦塔帕利与我一起修复了一个Git合并的烂摊子！</p><p id="2533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>