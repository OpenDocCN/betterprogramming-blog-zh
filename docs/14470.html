<html>
<head>
<title>Creating a Google Fonts Browser in SwiftUI for MacOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在MacOS的SwiftUI中创建Google字体浏览器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-google-fonts-browser-in-swiftui-49c94787d14a?source=collection_archive---------4-----------------------#2022-12-20">https://betterprogramming.pub/creating-a-google-fonts-browser-in-swiftui-49c94787d14a?source=collection_archive---------4-----------------------#2022-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f28d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解字体如何在较低层次上工作，并了解它如何与SwiftUI紧密结合</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0d8c91960c059b72553366617059e681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w46U72VqMS0xPGS1h40wFA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@amadorloureiro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿玛多·洛雷罗</a>在<a class="ae kv" href="https://unsplash.com/s/photos/fonts?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://fonts.google.com" rel="noopener ugc nofollow" target="_blank">谷歌字体</a>是设计用户界面时使用免费字体的首选网站。本教程将展示如何编写一个简单的工具来预览这些字体，而不必在系统中注册每种字体。</p><p id="3283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该应用程序包含一个拆分视图，在左侧面板中有一个字体列表。右侧面板将显示字体样式选项的预览。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/cea52e5ac81c906dbb93c39c768782d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3hJvmGkzRIoxBOUufgYpg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">谷歌字体预览应用</p></figure><h2 id="a8db" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">项目设置</h2><ol class=""><li id="8526" class="mm mn iq ky b kz mo lc mp lf mq lj mr ln ms lr mt mu mv mw bi translated">创建一个名为<code class="fe mx my mz na b">GoogleFontPrevew</code>的新Mac SwiftUI项目</li><li id="8a1c" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">在应用沙盒中启用传出连接(客户端)</li><li id="0b52" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">从<a class="ae kv" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌开发者控制台</a>获取一个谷歌API密钥。</li></ol><h2 id="1241" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">谷歌字体模型</h2><p id="de80" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">谷歌字体API列出了在<a class="ae kv" href="https://fonts.google.com" rel="noopener ugc nofollow" target="_blank">谷歌字体</a>可用的所有字体。使用<a class="ae kv" href="https://developers.google.com/fonts/docs/developer_api" rel="noopener ugc nofollow" target="_blank">谷歌字体API </a>检索字体。响应包含所有样式和一个URL来访问这些样式的字体文件。缺少元数据，如创建者和描述。但是，我们有足够的内容来创建一个简单的预览，这是我们的目标。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="941d" class="nn lu iq na b be no np l nq nr">{<br/>  "kind": "webfonts#webfontList",<br/>  "items": [<br/>    {<br/>      "family": "ABeeZee",<br/>      "variants": [<br/>        "regular",<br/>        "italic"<br/>      ],<br/>      "subsets": [<br/>        "latin",<br/>        "latin-ext"<br/>      ],<br/>      "version": "v22",<br/>      "lastModified": "2022-09-22",<br/>      "files": {<br/>        "regular": "http://fonts.gstatic.com/s/abeezee/v22/esDR31xSG-6AGleN6tKukbcHCpE.ttf",<br/>        "italic": "http://fonts.gstatic.com/s/abeezee/v22/esDT31xSG-6AGleN2tCklZUCGpG-GQ.ttf"<br/>      },<br/>      "category": "sans-serif",<br/>      "kind": "webfonts#webfont"<br/>    }<br/>  ]<br/>}</span></pre><p id="2cd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">谷歌字体模型</strong></p><p id="cd81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个<code class="fe mx my mz na b">GoogleFont.swift</code>文件。这个文件将包含我们将用作视图模型的数据结构。</p><p id="4ab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建API的JSON响应顶层的1:1映射。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="125f" class="nn lu iq na b be no np l nq nr">struct GoogleResponse: Decodable {<br/>  let kind: String<br/>  let items: [GoogleFont]<br/>}</span></pre><p id="7edf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建GoogleFont结构来表示一个字体条目。这将是<code class="fe mx my mz na b">ContentView</code>用来显示字体列表的内容。它主要是响应JSON中字体项的1:1映射。这些文件将从JSON中的字典映射到一个已排序的数组。</p><p id="0ed8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要可用，字体需要是<code class="fe mx my mz na b">Decodable</code>、<code class="fe mx my mz na b">Hashable</code>和<code class="fe mx my mz na b">Identifiable</code>。由于族名对于每个条目都是唯一的，因此它可以用作对象的唯一标识符。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="f853" class="nn lu iq na b be no np l nq nr">struct GoogleFont: Hashable, Identifiable, Decodable {<br/>  var id : String { family }<br/>  <br/>  let family: String<br/>  let files: [GoogleFontStyle]<br/>  let version: String<br/>  let category: String<br/>}</span></pre><p id="28a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">FontFile</code>将在详细信息显示中用于预览字体系列的样式。字体的样式和url将被保存以便于参考。为了能够在列表中使用该样式，它需要是<code class="fe mx my mz na b">Hashable</code>和<code class="fe mx my mz na b">Identifiable</code>。将生成一个UUID来唯一标识该字体文件。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="f4f8" class="nn lu iq na b be no np l nq nr">struct FontFile: Hashable, Identifiable {<br/>  let style: Style<br/>  let id = UUID()<br/>  let url: URL<br/>}</span></pre><p id="9216" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个<code class="fe mx my mz na b">Style.swift</code>文件。这是定义<code class="fe mx my mz na b">Style</code>枚举的地方。谷歌将权重定义为100-900。如果重量有斜体变体，则在值后追加<code class="fe mx my mz na b">italic</code>。但是对于normal和normal-italic，Google只是分别使用了<code class="fe mx my mz na b">regular</code>和<code class="fe mx my mz na b">italic</code>。</p><p id="1544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">enum有一个helper函数来从样式中获取一个友好的名称。友好名称将用作包装样式预览的分组框的标题。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="3602" class="nn lu iq na b be no np l nq nr">enum Style: String, Hashable {<br/>  case thin = "100"<br/>  case thinItalic = "100italic"<br/>  case extraLight = "200"<br/>  case extraLightItalic = "200italic"<br/>  case light = "300"<br/>  case lightItalic = "300italic"<br/>  case normal = "regular"<br/>  case normalItalic = "italic"<br/>  case medium = "500"<br/>  case mediumItalic = "500italic"<br/>  case semiBold = "600"<br/>  case semiBoldItalic = "600italic"<br/>  case bold = "700"<br/>  case boldItalic = "700italic"<br/>  case extraBold = "800"<br/>  case extraBoldItalic = "800italic"<br/>  case black = "900"<br/>  case blackItalic = "900italic"<br/><br/>  var friendlyName: String {<br/>    switch self {<br/>    case .thin: return "Thin"<br/>    case .thinItalic: return "Thin Italic"<br/>    case .extraLight: return "Extra Light"<br/>    case .extraLightItalic: return "Extra Light Italic"<br/>    case .light: return "Light"<br/>    case .lightItalic: return "Light Italic"<br/>    case .normal: return "Normal"<br/>    case .normalItalic: return "Italic"<br/>    case .medium: return "Medium"<br/>    case .mediumItalic: return "Medium Italic"<br/>    case .semiBold: return "Semi Bold"<br/>    case .semiBoldItalic: return "Semi Bold Italic"<br/>    case .bold: return "Bold"<br/>    case .boldItalic: return "Bold Italic"<br/>    case .extraBold: return "Extra Bold"<br/>    case .extraBoldItalic: return "Extra Bold Italic"<br/>    case .black: return "Black"<br/>    case .blackItalic: return "Black Italic"<br/>    }<br/>  }<br/>}</span></pre><p id="ba6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有了这些，定制解码就可以在<code class="fe mx my mz na b">GoogleFont</code>中实现了。添加<code class="fe mx my mz na b">Decodable's</code>所需的初始化器和编码键。Xcode 14的好处是它会自动为你填充一些内容。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="b802" class="nn lu iq na b be no np l nq nr">struct GoogleFont: Hashable, Decodable, Identifiable {<br/>  var id: String { family }<br/>    <br/>  let family: String<br/>  let files: [FontFile]<br/>  let version: String<br/>  let category: String<br/>    <br/>  enum CodingKeys: CodingKey {<br/>    case family<br/>    case files<br/>    case version<br/>    case category<br/>  }<br/>    <br/>  init(from decoder: Decoder) throws {<br/>    let container = try decoder.container(keyedBy: CodingKeys.self)<br/>    self.family = try container.decode(String.self, forKey: .family)<br/>    let files = try container.decode([String: String].self, forKey: .files)<br/>    self.version = try container.decode(String.self, forKey: .version)<br/>    self.category = try container.decode(String.self, forKey: .category)<br/>        <br/>    var keys = Array(files.keys)<br/>        <br/>    // lets do a bit of work to get our files that we want.<br/>    keys.sort { item1, item2 in<br/>      func itemFixer(_ value: String) -&gt; String {<br/>        if value == "regular" {<br/>          return "400"<br/>        } else if value == "italic" {<br/>          return "400Italic"<br/>        }<br/>                <br/>        return value<br/>      }<br/>            <br/>      let fixedItem1 = itemFixer(item1)<br/>      let fixedItem2 = itemFixer(item2)<br/>                <br/>      return fixedItem1 &lt; fixedItem2<br/>    }<br/>        <br/>    self.files = keys.compactMap { key in<br/>      guard let style = Style(rawValue: key),<br/>            let location = files[key]?.replacingOccurrences(of: "http", with: "https")<br/>      else {<br/>        return nil<br/>      }<br/>            <br/>      return FontFile(style: style, url: URL(string: location)!)<br/>    }<br/>  }<br/>}</span></pre><ol class=""><li id="8dfb" class="mm mn iq ky b kz la lc ld lf ns lj nt ln nu lr mt mu mv mw bi translated">直接从字体容器中解码<code class="fe mx my mz na b">family</code>、<code class="fe mx my mz na b">version</code>、<code class="fe mx my mz na b">category</code>。</li><li id="0afc" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">将来自JSON的文件映射解码成一个临时变量。</li><li id="69f1" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">获取密钥，并按照从最亮(100)到最暗(900)的顺序对它们进行排序。块中有一个小的局部函数，它取<code class="fe mx my mz na b">regular</code>并将其映射到<code class="fe mx my mz na b">400</code>，取<code class="fe mx my mz na b">italic</code>并将其映射到<code class="fe mx my mz na b">400italic</code>。这样做允许正常和斜体在中(500)之前和亮(300)之后排序。</li><li id="613a" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">键排序后，使用<code class="fe mx my mz na b">compactMap</code>映射创建排序后的<code class="fe mx my mz na b">FontFile</code>数组。使用<code class="fe mx my mz na b">compactMap</code>允许在创建文件数组时忽略<code class="fe mx my mz na b">nil</code>条目。如果使用了<code class="fe mx my mz na b">map</code>，一个<code class="fe mx my mz na b">nil</code>条目将被插入到数组中。</li><li id="9724" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">用https替换http，这样应用程序就不会抱怨使用不安全的web调用。</li></ol><h2 id="d795" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">谷歌字体服务</h2><p id="ed02" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">创建一个<code class="fe mx my mz na b">GoogleFontService.swift</code>文件。该文件将有一个类，该类对<a class="ae kv" href="https://developers.google.com/fonts/docs/developer_api" rel="noopener ugc nofollow" target="_blank"> Google Fonts API </a>进行网络调用，以检索应用程序中显示的字体列表。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="82b5" class="nn lu iq na b be no np l nq nr">class GoogleFontService {<br/>  let apiKey = "** YOUR KEY HERE **"<br/><br/>  func syncFonts() async throws -&gt; [GoogleFont] {<br/>    var components = URLComponents()<br/><br/>    components.scheme = "https"<br/>    components.host = "www.googleapis.com"<br/>    components.path = "/webfonts/v1/webfonts"<br/>    components.queryItems = [<br/>      URLQueryItem(name: "key", value: apiKey),<br/>      URLQueryItem(name: "sort", value: "alpha")<br/>    ]<br/><br/>    let url = components.url!<br/>    let request = URLRequest(url: url)<br/><br/>    let (data, _) = try await URLSession.shared.data(for: request)<br/>    let googleResponse = try JSONDecoder()<br/>      .decode(GoogleResponse.self, from: data)<br/><br/>    return googleResponse.items<br/>  }<br/>}</span></pre><ol class=""><li id="95eb" class="mm mn iq ky b kz la lc ld lf ns lj nt ln nu lr mt mu mv mw bi translated">用从Google API控制台获取的值替换<code class="fe mx my mz na b">apiKey</code>。</li><li id="02ac" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">使用URLComponents构建API的URL。这保证了URL的格式正确。</li><li id="02a7" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">请API按字母顺序对列表进行排序。</li><li id="7106" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">调用<a class="ae kv" href="https://developers.google.com/fonts/docs/developer_api" rel="noopener ugc nofollow" target="_blank">谷歌字体API </a></li><li id="f130" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">返回解码后的GoogleFont项。</li></ol><p id="3244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有返回值，请确保:</p><ol class=""><li id="6b17" class="mm mn iq ky b kz la lc ld lf ns lj nt ln nu lr mt mu mv mw bi translated">Google API密钥是正确的</li><li id="4f57" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">为应用程序启用传出连接。</li></ol><h2 id="216d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">创建可用的网络字体</h2><p id="3176" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">为了创建一个可用的网络字体，核心图形和核心文本将混合使用。Core Graphics是一个管理图形2D对象(包括文本)的底层框架。另一方面，核心文本是SwiftUI用来呈现文本和处理字体的低级文本呈现和布局引擎。</p><p id="6e14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI的<code class="fe mx my mz na b">Font</code>有一个构造函数，它接受一个<code class="fe mx my mz na b">CTFont</code>(核心文本字体)并返回一个SwiftUI <code class="fe mx my mz na b">Font</code>。注册功能将下载字体文件并进入SwiftUI <code class="fe mx my mz na b">Font</code>。创建一个<code class="fe mx my mz na b">Font+Register.swift</code>文件来存放扩展的代码。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="1dc3" class="nn lu iq na b be no np l nq nr">extension Font {<br/>  static func register(url: URL, size: CGFloat = 18) async throws -&gt; Font? {<br/>    do {<br/>      let request = URLRequest(url: url)<br/>      let (data, _) = try await URLSession.shared.data(for: request)<br/>            <br/>      guard let provider = CGDataProvider(data: data as CFData),<br/>            let cgFont = CGFont(provider)<br/>      else {<br/>        print("Unsucessfully registered font")<br/>        return nil<br/>      }<br/>            <br/>      let ctFont = CTFontCreateWithGraphicsFont(cgFont, size, nil, nil)<br/>            <br/>      return Font(ctFont)<br/>    } catch {<br/>      print(error)<br/>    }<br/>        <br/>    return nil<br/>  }<br/>}</span></pre><ol class=""><li id="a8df" class="mm mn iq ky b kz la lc ld lf ns lj nt ln nu lr mt mu mv mw bi translated">从URL获取字体数据</li><li id="01d0" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">从下载的数据创建核心图形数据提供程序。该代码利用了Swift的数据类可以桥接至CoreFoundation的CFData。</li><li id="5e76" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">创建核心图形字体。</li><li id="c737" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">创建核心文本字体。</li><li id="16b9" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">使用核心文本字体创建SwiftUI字体。</li><li id="e7fa" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">如果有错误，打印错误并返回<code class="fe mx my mz na b">nil</code>。</li></ol><h2 id="fee9" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">创建主视图</h2><p id="457f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated"><code class="fe mx my mz na b">ContentView.swift</code>文件包含应用程序的主视图。主视图将包含一个拆分视图，左边是列表，右边是详细信息。<code class="fe mx my mz na b">ContentView</code>拥有要显示的字体列表以及当前的选择状态。</p><p id="f3b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将调用<code class="fe mx my mz na b">task</code>修改器加载字体并设置初始选择的字体。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="5ce7" class="nn lu iq na b be no np l nq nr">struct ContentView: View {<br/>  @State var fonts = [GoogleFont]()<br/>  @State var font: GoogleFont?<br/><br/>  var body: some View {<br/>    NavigationSplitView {<br/>     FontList(selectedFont: $font, fonts: fonts)<br/>    } detail: {<br/>      if let font = font {<br/>        DetailsView(font: font)<br/>      } else {<br/>        EmptyView()<br/>      }<br/>    }<br/>    .task {<br/>      do {<br/>        fonts = try await GoogleFontService().syncFonts()<br/>      <br/>        await MainActor.run {<br/>          font = fonts[0]<br/>        }<br/>      } catch {<br/>        print (error)<br/>      }<br/>    }<br/>  }<br/>}</span></pre><ol class=""><li id="8af6" class="mm mn iq ky b kz la lc ld lf ns lj nt ln nu lr mt mu mv mw bi translated">创建一个状态变量来保存<code class="fe mx my mz na b">GoogleFont</code>项的列表。</li><li id="4cfe" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">创建一个状态变量来保存当前选择的<code class="fe mx my mz na b">GoogleFont</code></li><li id="bf85" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">创建包含两列的导航拆分视图。</li><li id="f57d" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">将<code class="fe mx my mz na b">FontList</code>添加到第一个块(左侧)。注意，选择状态被绑定到<code class="fe mx my mz na b">FontList's</code>选择。</li><li id="0a5b" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">如果列表不为空，则将详细信息设置为一个<code class="fe mx my mz na b">DetailsView</code>。否则，显示一个<code class="fe mx my mz na b">EmptyView</code></li><li id="90f5" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">添加一个<code class="fe mx my mz na b">task</code>修饰符来检索字体并将当前选择设置为列表中的第一种字体。</li></ol><h2 id="19b5" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">字体列表</h2><p id="d43e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">字体列表显示所有可用的字体，并更新当前选定的字体。创建一个<code class="fe mx my mz na b">FontList.swift</code>文件。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="e8da" class="nn lu iq na b be no np l nq nr">struct FontList: View {<br/>  @Binding var selectedFont: GoogleFont?<br/>  var fonts: [GoogleFont]<br/>  <br/>  var body: some View {<br/>    List(fonts, selection: $selectedFont) { font in<br/>      NavigationLink(value: font) {<br/>        VStack(alignment: .leading) {<br/>          Text(font.family)<br/>            .font(.system(size: 14, weight: .bold))<br/>          Text("\(font.files.count) styles")<br/>            .font(.system(size: 14))<br/>        }<br/>        .padding(8)<br/>      }<br/>    }<br/>  }<br/>}</span></pre><ol class=""><li id="babf" class="mm mn iq ky b kz la lc ld lf ns lj nt ln nu lr mt mu mv mw bi translated">创建绑定以更新当前选定的字体。</li><li id="0aa6" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">创建一个变量来保存要显示的字体。</li><li id="4a75" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">创建列表视图以显示字体并更新选择。</li><li id="6077" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">单元格将是一个简单的垂直堆栈，显示字体系列的名称和样式的数量。</li><li id="7ff8" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">添加少量填充以增加视觉吸引力。</li></ol><h2 id="6194" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">详细视图</h2><p id="700e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated"><code class="fe mx my mz na b">DetailsView</code>为字体系列中的每种样式提供预览。样式将显示在一个缓慢的垂直堆栈中。创造一个<code class="fe mx my mz na b">DetailView.swift</code></p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="f5d5" class="nn lu iq na b be no np l nq nr">struct DetailsView: View {<br/>  var font: GoogleFont<br/><br/>  var body: some View {<br/>    VStack {<br/>      Text(font.family)<br/>        .font(.system(size: 25, weight: .bold))<br/>      Spacer()<br/>      ScrollView {<br/>        LazyVStack(alignment: .leading) {<br/>          ForEach(font.files, id: \.id) { value in<br/>            StyleCell(style: value)<br/>          }<br/>        }<br/>      }<br/>      .id(font.family)<br/>    }<br/>    .padding()<br/>  }<br/>}</span></pre><ol class=""><li id="20a2" class="mm mn iq ky b kz la lc ld lf ns lj nt ln nu lr mt mu mv mw bi translated">显示带有选定系列名称的标题。</li><li id="ac3c" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">使用滚动的惰性垂直堆栈显示字体系列中的样式列表。</li><li id="590c" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">给滚动视图一个唯一的ID，以便它在创建时滚动到顶部。SwiftUI似乎想重用滚动视图，这将导致滚动位置不是每个新选择的顶部。</li></ol><h2 id="d7f4" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">风格细胞</h2><p id="ae74" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated"><code class="fe mx my mz na b">StyleCell</code>负责预览所选系列的单一字体样式。单元格将以给定的特定样式显示A-Z和0–9。字体加载时，显示“尝试加载”。由于字体是临时的，它们只在显示时存在。</p><pre class="kg kh ki kj gt nj na nk bn nl nm bi"><span id="68fe" class="nn lu iq na b be no np l nq nr">struct StyleCell: View {<br/>  let style: FontFile<br/>  @State var font: Font?<br/><br/>  var body: some View {<br/>    GroupBox(label: Text(style.style.friendlyName)) {<br/>      if let font = font {<br/>        Text("ABCDEFGHJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz\n1234567890")<br/>          .font(font)<br/>          .frame(maxWidth: .infinity, alignment: .leading)<br/>      }<br/>      else {<br/>        Text("trying to load")<br/>          .font(.system(size: 20))<br/>          .frame(maxWidth: .infinity, alignment: .leading)<br/>      }<br/>    }<br/>    .task {<br/>      font = try? await Font.register(url: style.url, size: 32)<br/>    }<br/>    .padding()<br/>  }<br/>}</span></pre><ol class=""><li id="b90c" class="mm mn iq ky b kz la lc ld lf ns lj nt ln nu lr mt mu mv mw bi translated">将预览包装在标题为该样式的<code class="fe mx my mz na b">friendlyName</code>的分组框中。</li><li id="108e" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">如果有已注册的字体，显示预览。否则，显示“正在尝试加载”。确保这些显示在水平允许的最大空间内。</li><li id="e33f" class="mm mn iq ky b kz nb lc nc lf nd lj ne ln nf lr mt mu mv mw bi translated">在<code class="fe mx my mz na b">task</code>修改器中，当创建视图时注册样式的字体。</li></ol><p id="9670" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行该项目现在允许用户选择一种字体，并显示其预览。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="8cd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个有趣的教程，可以学习更多关于字体如何在较低层次上工作的知识，并了解它如何与SwiftUI相结合。完整的项目可以在<a class="ae kv" href="https://github.com/scottandrew/GoogleFontPreview" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="2ffe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>