<html>
<head>
<title>Build a Golang RESTful Stock API With the Echo Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Echo框架构建Golang RESTful Stock API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/intro-77f65f73f6d3?source=collection_archive---------2-----------------------#2020-03-07">https://betterprogramming.pub/intro-77f65f73f6d3?source=collection_archive---------2-----------------------#2020-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="828f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建一个速度惊人的股票API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/44efc58fc7b59d95f1598a9532530418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oPXEHY-EvtAu_bmdqtzWHA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kv" href="https://unsplash.com/s/photos/stocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="639c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文描述了如何使用一个从Yahoo Finance返回股票数据的框架来构建一个Golang restful API</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/48f5d12ddf0f195bfc9ddc7a0e7b208a.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*Wo1CovlS9gjrsTb3jx9ZcA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">回声服务器</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="fe14" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">回声框架</h1><blockquote class="ms mt mu"><p id="eb53" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated"><em class="iq">用于Go (Golang)的快速且不常见的HTTP服务器框架。比其他产品快10倍。</em></p><p id="de47" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated"><em class="iq">-回声</em></p></blockquote><p id="da1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Echo使得构建web应用程序和Restful APIs变得非常简单。如果你有Python背景，你可能会发现类似Flask的框架。Echo没有附带电池，没有像Django这样的框架生成器，除了你自己，没有人能构建你的应用程序！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d760" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Web应用程序结构</h1><p id="5e9f" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">首先，您需要考虑项目的文件夹和文件结构。我想遵循MVC架构，所以我们应该有模型、视图和控制器。对于这个Restful API示例，我们不需要视图或模型。</p><p id="9eff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的文件夹将遵循以下结构:</p><p id="2a82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mv"> —控制器<br/> — server.go </em></p><h1 id="3eab" class="ma mb iq bd mc md ne mf mg mh nf mj mk jw ng jx mm jz nh ka mo kc ni kd mq mr bi translated">server.go</h1><p id="0cc8" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这是您的应用程序的入口点。您可以将其重命名，但该文件应该是您的应用程序的主包。</p><p id="e5a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在围棋编程中，包很重要。Go程序只能从主包(<code class="fe nj nk nl nm b">package main</code>)开始:</p><p id="4748" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://gist.github.com/BetterProgramming/f99ebbc60b163ab531634ad4a46e11c4.js" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/better programming/f 99 ebbc 60 b 163 ab 531634 ad 4a 46 e 11 c 4 . js</a></p><p id="593d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nj nk nl nm b">server.go</code>应该包括主函数(<code class="fe nj nk nl nm b">func main</code>)，这是Go程序的入口点。我导入了两个包到<code class="fe nj nk nl nm b">server.go</code>:</p><ul class=""><li id="d983" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><code class="fe nj nk nl nm b">github.com/labstack/echo</code> : echo包是使用echo框架</li><li id="faae" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe nj nk nl nm b">github.com/labstack/echo/middleware</code>:来自中间件echo的子包。</li></ul><p id="6019" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在主函数中，我用下面的代码初始化了<code class="fe nj nk nl nm b">echo</code>对象:</p><pre class="kg kh ki kj gt ob nm oc od aw oe bi"><span id="edbc" class="of mb iq nm b gy og oh l oi oj">e := echo.New()</span></pre><p id="9d19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码在我们的应用程序中使用了中间件。我使用三个中间件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="85f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恢复中间件从链中任何地方的混乱中恢复，打印堆栈跟踪，并将控制交给集中式<code class="fe nj nk nl nm b"><a class="ae kv" href="https://echo.labstack.com/guide/customization#http-error-handler" rel="noopener ugc nofollow" target="_blank">HTTPErrorHandler</a></code>。</p><ul class=""><li id="832b" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">记录器用于服务器日志。</li><li id="5e4f" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">CORS为web服务器提供跨域访问控制，从而实现安全的跨域数据传输。</li></ul><p id="c4e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在端口8000上启动了echo web服务器。(您可以选择任何您喜欢的开放端口)我还将启动功能封装在一个记录器中，以捕捉任何致命错误。</p><pre class="kg kh ki kj gt ob nm oc od aw oe bi"><span id="d0a7" class="of mb iq nm b gy og oh l oi oj">e.Logger.Fatal(e.Start(":8000"))</span></pre><p id="8efb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，app在<code class="fe nj nk nl nm b">localhost:8000</code>和<code class="fe nj nk nl nm b">0.0.0.0:8000</code>运行。但是您可能看不到任何东西，因为您没有处理程序方法来管理请求。</p><p id="f54e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在<code class="fe nj nk nl nm b">server.go</code> <strong class="ky ir"> : </strong>中创建一个handler方法</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b18c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果你去<strong class="ky ir"> </strong> <code class="fe nj nk nl nm b">localhost:8000</code>，你会看到带有“你好，Word”的HTML页面。</p><p id="1fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我将为应用程序创建一个控制器。这个控制器用于从雅虎财经抓取股票数据。Echo不需要您为处理程序创建单独的文件。然而，将每个处理程序方法放在一个文件中是混乱的，并且从长远来看是不可维护的。我们希望我们的功能和测试有一个集中的位置。这是大多数Go开发人员采用的一种风格指南，以产生干净和可维护的代码，使程序更加模块化，使下一个开发人员更容易阅读。</p><p id="ef2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我首先为控制器创建一个名为<code class="fe nj nk nl nm b">controllers</code>的新包。让我们在控制器下创建<code class="fe nj nk nl nm b">price.go</code> rest控制器文件。</p><p id="63a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mv">控制器<br/> | price.go </em></p><p id="8cf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会在这个文件中看到一些额外的流恢复代码。我不想过多地解释我为什么要这样做，但是我从Aldo Giambelluca <em class="mv"> </em>那里找到了一个有用的解释，解释了为什么它如此重要:</p><blockquote class="ms mt mu"><p id="d6f3" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">想想木卫一。像水龙头一样关闭:你可以得到水，但一旦它出来了，它就出来了。</p><p id="4999" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated"><em class="iq">-阿尔多·詹贝鲁卡</em></p></blockquote><div class="om on gp gr oo op"><a href="https://medium.com/@xoen/golang-read-from-an-io-readwriter-without-loosing-its-content-2c6911805361" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ir gy z fp ou fr fs ov fu fw ip bi translated">Golang:从io读取。ReadWriter而不丢失其内容</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">这里的场景是:你有一些在你的控制器动作之前运行的代码，读取请求的主体，做一些事情…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="65eb" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak"> Price.go </strong></h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="725e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以如下使用<code class="fe nj nk nl nm b">server.go</code>中的<code class="fe nj nk nl nm b">price controller</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Echo框架中，每个控制器都有一个独立的结构。不能在整个包中创建同名的方法。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="4a89" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">演示</h1><p id="2df9" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我在演示中使用了Postman，但是您也可以使用任何工具发送一个正文中包含JSON数据的HTTP请求。</p><p id="a5ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从运行服务器开始:</p><p id="6cf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nj nk nl nm b">go run server.go</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/48f5d12ddf0f195bfc9ddc7a0e7b208a.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*Wo1CovlS9gjrsTb3jx9ZcA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">启动Echo服务器</p></figure><p id="85af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们在<code class="fe nj nk nl nm b">Postman</code>中创建一个请求。在我们的代码中，我们创建了<code class="fe nj nk nl nm b">ticker:name</code>作为请求体的键值对。以下是一些示例几何体:</p><pre class="kg kh ki kj gt ob nm oc od aw oe bi"><span id="0951" class="of mb iq nm b gy og oh l oi oj">## Amazon ticker</span><span id="2a29" class="of mb iq nm b gy oy oh l oi oj">{ <br/>"ticker" : "AMZN" <br/>}<br/></span><span id="33f3" class="of mb iq nm b gy oy oh l oi oj">## Apple ticker</span><span id="111c" class="of mb iq nm b gy oy oh l oi oj">{ <br/>"ticker" : "AAPL" <br/>}</span><span id="0364" class="of mb iq nm b gy oy oh l oi oj"><br/>## Tesla ticker</span><span id="d62c" class="of mb iq nm b gy oy oh l oi oj">{ <br/>"ticker" : "TSLA" <br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/ca950c9dbbd29eae7e4a853265256fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*ZAYPBDet1MplHf9n81faTw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">耶！</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="da90" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">结论</strong></h1><p id="41f5" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们用MVC架构在Echo中创建了一个Rest API！</p><p id="2571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在理解了为什么我们以某种结构组织我们的文件——为其他开发人员增加可读性和可维护性。我们也知道如何用更模块化的代码在我们的服务器上创建其他端点。</p><p id="62c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查看该项目的源代码，您可以访问我的Github repo。</p><p id="54a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这能帮助你建立有趣的项目！</p></div></div>    
</body>
</html>