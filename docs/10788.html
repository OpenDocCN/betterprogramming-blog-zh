<html>
<head>
<title>How to Speed Up Your Struct in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何加快你的Golang结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-speed-up-your-struct-in-golang-76b846209587?source=collection_archive---------10-----------------------#2022-01-27">https://betterprogramming.pub/how-to-speed-up-your-struct-in-golang-76b846209587?source=collection_archive---------10-----------------------#2022-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="89eb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您应该知道的简单数据对齐技术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0f5fb6aac594dc0b2bfcd96abbb06a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvnGtbSkZxUcHzJPPfERHA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@mike-468229" rel="noopener ugc nofollow" target="_blank">麦克</a>在<a class="ae kv" href="https://www.pexels.com/photo/depth-of-field-photography-of-file-arrangement-1181772/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="e06d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您以前使用Golang编写过代码，那么您很可能已经见过并实现了该类型——struct。</p><p id="4191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能不知道的是，通过简单地重新排列结构中的字段，您可以极大地提高Go程序的速度和内存使用率！</p><p id="ef2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好得难以置信？我们开门见山吧！</p><h1 id="8626" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">简单演示</h1><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="b5cd" class="mp lt iq ml b gy mq mr l ms mt">type BadStruct struct {<br/>	age         uint8<br/>	passportNum uint64<br/>	siblings    uint16<br/>}<br/><br/>type GoodStruct struct {<br/>	age         uint8<br/>	siblings    uint16<br/>	passportNum uint64<br/>}</span></pre><p id="a16c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，我们创建了两个具有相同<strong class="ky ir">字段的结构。让我们写一个简单的程序来分别输出它们的内存使用情况。</strong></p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="f479" class="mp lt iq ml b gy mq mr l ms mt">// Output<br/>Bad struct is 24 bytes long<br/>Good struct is 16 bytes long</span></pre><p id="ee87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看出，它们在内存使用方面有所不同。</p><p id="da1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发生了什么导致两个完全相似的结构消耗了不同数量的字节？</p><p id="d374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案在于数据在计算机内存中是如何排列的。</p><p id="3b93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，数据结构对齐。</p><h1 id="2def" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据结构对齐</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/e7b8ca3a8e9e4fbee6f9bdda0e89fcfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79Fsvm4AHcwOnJZW4U1jWA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@shvets-production" rel="noopener ugc nofollow" target="_blank">在<a class="ae kv" href="https://www.pexels.com/photo/young-couple-arranging-stack-of-boxes-after-relocation-7203783/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄生产</a></p></figure><p id="5145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CPU以字长而不是字节长读取数据。</p><p id="f027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">64位系统中的一个字是8字节，而32位系统中的一个字是4字节。</p><p id="93d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，CPU以其字长的倍数读取地址。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/2f90ef331613fbc869c6de78f822c540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZcHPvsxBLAzcSJy3fVshg.png"/></div></div></figure><p id="44c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下使用64位系统。为了获取变量<code class="fe mw mx my ml b">passportNum</code>，我们的CPU需要两个周期而不是一个周期来访问数据。</p><p id="256c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个周期将获取内存0到7，随后的周期将获取其余部分。</p><p id="e7b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">把它想象成一个笔记本，每页只能存储一个字长的数据，在本例中是8个字节。如果<code class="fe mw mx my ml b">passportNum</code>分散在两个页面上，那么需要两次翻转来检索完整的数据。</p><p id="f617" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是低效的。</p><p id="01f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，需要数据结构对齐——计算机存储数据的地址等于数据大小的倍数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ca9cb0cedef988f12a3a219ffa63b97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*KJP2khTZuVwlM_Fnx-DMjw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个4字节的数据只能从存储器地址0或4开始</p></figure><p id="e2b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，2字节数据可以存储在存储器0、2或4中，而4字节数据可以存储在存储器0、4或8中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/7eb6c7e2f8701f7c9899ba2e4abcb2e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4iN2ZOCdOHFPAtZsPRi5g.png"/></div></div></figure><p id="445d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过简单地排列数据，计算机可以确保在一个CPU周期内检索到变量<code class="fe mw mx my ml b">passportNum</code>。</p><h1 id="e65b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据结构填充</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/b0cb3607f506776b81840dc1c7570627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qemcklXOM9K6PxfpDUjNmg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@angela-roma" rel="noopener ugc nofollow" target="_blank">安吉拉·罗马</a>在<a class="ae kv" href="https://www.pexels.com/photo/white-empty-frames-hanging-on-wall-7319318/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="1010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">填充是实现数据对齐的关键。</p><p id="0787" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算机在数据结构之间填充额外的字节来对齐数据。</p><p id="1320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是额外内存的来源！</p><p id="2540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们重温一下我们的<code class="fe mw mx my ml b">BadStruct</code>和<code class="fe mw mx my ml b">GoodStruct</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/98b2bd7914a3798066859c0f90a14162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgC5vTRNDpS-ndq2iiH-ig.png"/></div></div></figure><p id="d202" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my ml b">GoodStruct</code>消耗更少的内存，因为它拥有比<code class="fe mw mx my ml b">BadStruct</code>更好的结构字段顺序。</p><p id="1902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于填充，两个13字节的数据结构分别变成了16字节和24字节。</p><p id="7146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，通过简单地对结构字段重新排序，可以节省额外的内存！</p><h1 id="964c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么重要？</h1><p id="2569" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">百万美元的问题来了，你为什么要关心这个？</p><p id="a5fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，两个方面，速度和内存使用。</p><p id="f381" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来做一个简单的基准来证明吧！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4163" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过遍历一个数组并将一个struct字段添加到一个任意变量来对<code class="fe mw mx my ml b">GoodStruct</code>和<code class="fe mw mx my ml b">BadStruct</code>进行基准测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/fd73f0c1d71e1d3cb9c285dc2aa005aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*hTUz1qHoLW_M1mY9RaICLg.png"/></div></figure><p id="90f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从结果可以看出，遍历<code class="fe mw mx my ml b">GoodStruct</code>确实比它的对应物花费更少的时间。</p><p id="fb4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对结构字段进行重新排序可以提高应用程序的内存使用率和速度。</p><p id="30df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，维护一个拥有大量大型结构的大规模应用程序，这将是一个游戏改变者。</p><h1 id="4d79" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关闭</h1><p id="ea79" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">好了，这篇博文就讲到这里。让我们以一个简单的行动号召来结束这一切:</p><blockquote class="nl"><p id="c709" class="nm nn iq bd no np nq nr ns nt nu lr dk translated"><strong class="ak">总是重新排序</strong>你的结构字段！</p></blockquote><p id="043b" class="pw-post-body-paragraph kw kx iq ky b kz nv jr lb lc nw ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">就这样，下次见！</p><h1 id="5d7d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">信用</h1><p id="8d5e" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">特别感谢我的同事Luan Phan分享了这个简单而有用的技术来加速Go应用程序！</p></div></div>    
</body>
</html>