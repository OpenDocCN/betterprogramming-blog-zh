# 我们能在多大程度上利用 TypeScript 编译器？让我们斐波纳契它超越整数的最大值

> 原文：<https://betterprogramming.pub/how-far-can-we-exploit-the-typescript-compiler-lets-fibonacci-it-beyond-integer-max-value-3c70ce142b01>

## 你不知道的类型脚本的类型系统的使用

![](img/4943ecedd11dac277295e673338b27f8.png)

米歇尔·比特托在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

TypeScript 编译器被设计用来完成初学者的任务，比如带有一些类型操作的类型检查。但是如果你仔细观察——我们会的——我们可以在编译时做真正的工作。

是的，你没看错，在编译时！我们选择的武器是打字系统。我们可以使用 TypeScript 类型系统在编译期间执行大量的计算。我们能走多远？让我们疯狂吧！

让我们试着在编译时计算一些非常大的斐波那契数。

# 斐波那契数

斐波纳契数被递归定义为:

*   `Fib(0) = 0`
*   `Fib(1) = 1`
*   `Fib(n) = Fib(n-1) + Fib(n-2)`

这是一个完美的问题，可以看出 TypeScript 的类型系统有多强大。首先，我们需要一些基本的操作。一开始，我们从一位数的运算开始。

# 一位数的基本算术运算

最简单的算术运算是增加或减少一个数字。所以让我们定义一个减量类型`Decrement<Digit>`，它可以从一个位数开始减 1。

我们如何检查我们的减量类型是否有效？我们如何输出结果类型文本？一种可能性是引发类型错误。引发类型错误的最简单方法是将错误的类型赋给结果类型:

类似地，我们可以创建一个`Increment<Digit>`类型来增加一个位数。

这很容易。现在我们可以使用递增和递减类型来添加一个`Addition`类型。

加法可以实现为递归类型，即第一个操作数加 1，第二个操作数减 1。然后调用结果的加法。如果第二个操作数达到零，则第一个操作数是原始操作数的和。

就是这样！现在我们可以计算一些斐波纳契数。

# 在编译期间计算斐波那契数

使用上面的脚本，我们可以计算第 6 个斐波那契数。这是很好的，但它不能是关于这个话题的最后一句话。我们应该争取更多。

# 创建合成数字格式

对于更大的数字，我们可以为`Increment`和`Decrement`类型创建一个巨大的列表，其中映射了每个数字的增量或减量。但是这工作量很大，而且很无聊。

表示较大数字的更聪明的方法是使用分层列表:

列表代表一个从最后一个数字到最高一个数字的数字，并以`null`结束。例如，数字 142 表示为:

```
Num<2, Num<4, Num<1, null>>>
```

这个递归列表的`Decrement`操作符按照以下规则变成递归的:

*   10 的减量是 9
*   如果一个数字以 0 结尾，最后一个数字将是 9，数字的下一项将递减
*   否则，我们只减少最后一个数字

我们新数字格式的`Increment`操作符遵循非常相似的规则:

*   9 的增量是 10
*   如果一个数字以 9 结尾，最后一个数字将是 0，数字的下一项将递增
*   否则，我们只增加最后一位数字

更新的斐波那契数字程序——使用我们的组合数字格式——增加了上述的递增和递减功能。

通过这种优化，我们能够计算第 18 个斐波纳契数，即 2584！我们正在到达那里。

但是将数字 2584 表示为`Num<4, Num<8, Num<5, Num<2, null>>>>`非常令人困惑。我们能使输入和输出的表示更具可读性吗？

# 很好地格式化输出

为了使输出更具可读性，数字必须以自然的顺序排列，我们希望摆脱所有这些`Num<…>`类型。

`PrettyOutput`类型将一个数字从我们的列表表示转换成一个带有数字自然排序的字符串。用`PrettyOutput`键入我们的错误信息如下

# 很好地格式化输入

此外，数字 18 ( `Num<8, Num<1, null>>`)的输入可读性不强。我们需要一个类似于`Pretty`类型的概念，颠倒数字的顺序，去掉所有这些`Num<…>`类型。

如果我们将`Pretty`和`CreateNum`类型应用于我们的斐波纳契类型，数字变得更加可读。

# 更巧妙的添加

如果我们试图计算 19 的斐波纳契数，我们会得到错误`Type instantiation is excessively deep and possibly infinite`。TypeScript 只允许我们进行一定深度的递归。从 100 开始，我们的加法只能进行到一定的深度。

许多递归在加法中被浪费了，因为为了增加 130 + 80 这个数，我们浪费了 80 个递归。如果我们仔细观察加法，我们会发现加法不能使加数一直递减到零。如果我们在最后一位数达到零就足够了。

之后，我们只关心倒数第二位。如果倒数第二位是零，我们只关心倒数第三位，以此类推。如果我们优化加法，它需要做以下事情:

*   如果第二个操作数是 0，我们就完成了。返回第一个操作数作为结果
*   如果第二个操作数以 0 结尾，我们只需要查看高位
*   否则，递增第一个操作数的当前位数，递减第二个操作数的当前位数。

哇，我们可以算出第 70 个斐波那契数了！是`190'392'490'709'135`。这个数字甚至不适合 32 位整数，并且会影响双精度变量的尾数大小。

# 故事时间

在获得科学计算硕士学位后，我从事部署在世界上最大的超级计算机上的高性能 C++应用程序的工作。后来我创办了一家网络公司，把目光转向了 TypeScript。我从来不认为 TypeScript 是一种简单的脚本语言，它可以与大家伙站在一起。