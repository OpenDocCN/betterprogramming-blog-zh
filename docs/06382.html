<html>
<head>
<title>Point-Free’s Swift Composable Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Point-Free的快速组合架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-composable-architecture-an-introductory-view-on-my-first-experiences-a55c6cf32d9e?source=collection_archive---------2-----------------------#2020-09-27">https://betterprogramming.pub/swift-composable-architecture-an-introductory-view-on-my-first-experiences-a55c6cf32d9e?source=collection_archive---------2-----------------------#2020-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3da5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对我第一次经历的初步看法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1586ab1ab1783e62211a85db0c6b476f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tDR3jnyE2d2V2qUd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@pemmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Przemyslaw Marczynski </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="bd8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(注意:这是很长的东西，而且不是完整的代码。这更像是一个概念和用法的旅程，所以会花你一些时间。)</p><p id="700c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">似乎有一个新的炒作来源正在增长。虽然到目前为止，iOS/macOS架构主要由MVC、MVVM或Clean Swift(或其他)驱动，但两年前推出的SwiftUI建立了一个不同的范式，其中许多架构并不完全适合。</p><p id="3281" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多年来，我们尝试了各种方法，以便为我们的应用找到正确的方法，由于架构和维护问题，这需要大量的返工。然而，没有一个经典的方法真正有用，主要是因为它是一个相当大的业务应用程序，具有大量的存储实体，其中许多功能应在不同的上下文中重用——随着使用SwiftUI的应用程序的返工越来越多，在保持一切整洁和分离方面出现了越来越多的问题。</p><p id="de30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">偶然的，也是纯粹的运气，我注意到了由<a class="ae kv" href="https://www.pointfree.co/" rel="noopener ugc nofollow" target="_blank"> Point-Free </a>创建的叫做Swift Composable Architecture(SCA)的东西。我看了一些文章和帖子，看了他们的网站，买了他们的节目，看了视频，越来越有热情。</p><p id="badd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我仍然没有真正理解框架的所有内容，并且仍然专注于简单的用例，但我同时成功地构建了几个视图，感受到了它对我们的应用程序的好处。</p><p id="6256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我想要一个简短的入门部分，包含一些之前/之后的代码片段(实际上，为了进入SCA，我不得不观看和阅读了大量的<em class="ls"/>，但是可能我错过了一些东西)，我将尝试与您分享我的一些经验，希望它可以帮助您更容易地进入这个架构。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d282" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">入门指南</h1><p id="bd50" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在我们的应用程序中，我们有一个向用户公开所有可用数据项的地方。</p><p id="87e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以首先我们需要一个数据类型的列表(比如<code class="fe mx my mz na b">companies</code>、<code class="fe mx my mz na b">persons</code>、<code class="fe mx my mz na b">industries</code>等)。).当用户选择其中一个时，他们将得到该类型所有可用项目的列表(所有公司、所有人、所有行业等。).最后，当选择其中一个项目时，他们将获得编辑该项目的详细视图(公司<em class="ls"> X </em>，人员<em class="ls"> Y </em>，行业<em class="ls"> Z </em>等)。).您可以称之为经典的主视图/详细视图序列。</p><p id="7642" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要一些对存储的灵活访问(我不会在这里介绍)，我们需要所有数据类型的相同概览列表，即使细节视图不同—我们需要使用类似的构建块来获得这些(我也不会在这里介绍)。但对我来说，第一个也是最基本的问题是找出整体结构应该如何设置。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1e75" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">设置整体结构</h1><p id="80d4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">所以我拿了点免提供的样本代码库和他们的视频做了实验。(为了便于处理，我在这里只使用简单的数据结构——没有核心数据等等。)</p><p id="7e29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从最顶端往下钻。起点是某种类型的<code class="fe mx my mz na b">TabView</code> <em class="ls"> </em>，它将引导我们进入数据类型概述页面。目前只有一页。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0779" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这都是经典的swift ui——到目前为止没什么特别的。现在让我们来看看<code class="fe mx my mz na b">MaintainAllDataView</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="385c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来还是像SwiftUI。但是等等:那个奇怪的<code class="fe mx my mz na b">industries</code>设置是什么，那个<code class="fe mx my mz na b">NavigationLink</code> <em class="ls"> </em>又是什么东西？</p><p id="31bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SCA有几个您必须理解的基本概念。让我们开始解释它们(至少就我的理解而言)。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ae0f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">SCA基本概念</h1><p id="4efc" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">最简单的概念是国家。SwiftUI处理状态，当状态发生变化时，视图被刷新。到目前为止，一切顺利。</p><p id="7148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，你会用一些<code class="fe mx my mz na b">@ObservableObject</code> <em class="ls"> </em>或者<code class="fe mx my mz na b">@StateObject</code>变量来表达这个。根据我的经验，这些对象往往会变得越来越大，越来越复杂。但是我们如何系统地避免这种情况呢？</p><p id="2cc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，SCA将状态从所有其他事物中分离出来。通常，它只不过是一个简单的结构，带有一些数据属性，理想情况下是<code class="fe mx my mz na b">Identifiable</code>和<code class="fe mx my mz na b">Equatable</code>(出于列表处理和更新的原因)。出于我们的目的，我们只希望一个<code class="fe mx my mz na b">Industry</code>有一个<code class="fe mx my mz na b">ID</code>和一个<code class="fe mx my mz na b">name</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ce97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以视图中的<code class="fe mx my mz na b">industries</code>变量声明只是将一些数据放入整个游戏中——并不复杂。</p><p id="8a46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是数据集如何流入通过<code class="fe mx my mz na b">NavigationLink</code>应该到达的视图呢？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="77be" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">介绍商店</h1><p id="11d6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这就是商店发挥作用的时刻。实际上，商店只不过是一个(初始)状态、一个缩减器和一个环境的组合。</p><p id="9b4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是商店是交给视图的中心元素。让我们看看另一边的<code class="fe mx my mz na b">IndustriesView</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5f5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，有一个财产持有我们注入的商店。我们暂时不会在这里深入探讨，所以让我们跳回<code class="fe mx my mz na b">NavigationLink</code> <em class="ls">。</em></p><p id="d995" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在了解了状态，那么让我们看看现在的环境。虽然状态提供了控制视图的一切，但是环境被用来注入它工作所需的其他东西——典型的例子是核心数据的托管对象上下文。</p><p id="c9ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，<code class="fe mx my mz na b">IndustriesEnvironment</code>只是一个空结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6250" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在理解了状态和环境，但是那个不祥的缩减器呢？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="23ea" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">介绍减速器</h1><p id="01f6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了回答这个问题，我们一步一步地检查它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们注意到reducer不仅仅需要状态和环境，还需要一些动作。这到底是什么？我们走着瞧。</p><p id="cf2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们注意到它结合了另外两个减速器。</p><p id="6f88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们看到第一个子减压器对那个动作起作用，而第二个子减压器做了一些我们还不理解的魔术。</p><p id="fab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么这里发生了什么——是反应式编程的迷雾吗？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="677f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">介绍行动</h1><p id="329b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">从我的角度来看，SCA的主要优势和好处之一是分离所有维度的关注点。从那里看，一个视图应该只是获取并显示它们，它应该检测用户的动作并对它们做出反应。然而，观众对<em class="ls">事情如何发生</em>和<em class="ls">反应如何</em>不感兴趣。</p><p id="6a84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在经典的SwiftUI中，您会将这些方面放入被观察的对象中，将它们混合起来。</p><p id="43d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在SCA中，状态是如何将事物提供给视图的，而reducer是对动作做出反应的地方。它分离了关注点，因此带来了更多的清晰性、可理解性、可维护性和可测试性。</p><p id="9535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，您需要由视图发送并由reducer接收的动作(通过存储——这是SCA背后的抽象魔法)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6ab3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的操作看起来像这样，您马上就能理解视图提供了什么功能(嗯，<em class="ls">应该在最后提供</em>——我们不会在本文中讨论这一点)。删除索引中的一个项目，将项目从这里移到那里，添加一个项目，然后…嗯，什么？我们一会儿会谈到这一点。</p><p id="84c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是SCA对我如此有吸引力的原因:当你搜索某个东西时，你总是有一个确切的地方可以看。您想在视图中再处理一个属性吗？将其添加到状态中。你想在视图中有另一个动作吗？将它添加到action枚举中，从视图中触发它，并在reducer中对它做出反应。想用不同的方式呈现某样东西？修改视图。而且一切都是明确分开的，所以没有任何东西会以不希望的方式影响其他东西。</p><p id="f9e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是现在，减速器到底是做什么的呢？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="24b0" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">' ForEachStore '</h1><p id="992a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">它目前支持的唯一动作是<code class="fe mx my mz na b">.industry</code>动作。该动作在<code class="fe mx my mz na b">ForEachStore</code>调用中触发。</p><p id="f4de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里发生了什么事？因为一个<code class="fe mx my mz na b">NavigationLink</code>将打开视图来编辑所选择的行业，我们需要将该行业传输到被调用的<code class="fe mx my mz na b">IndustryView</code>的东西。</p><p id="1264" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们需要的是一家<code class="fe mx my mz na b">IndustryView</code>商店，它正好拥有一个行业:</p><p id="8662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">NavigationLink(destination: IndustryView(store: industryStore)…)</code></p><p id="058e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们怎么去这家店？(记得我们将<code class="fe mx my mz na b">IndustryState</code>定义为<code class="fe mx my mz na b">Identifiable</code>和<code class="fe mx my mz na b">Equatable</code>。)看一下<code class="fe mx my mz na b">ForEachStore</code>。</p><p id="d66f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">ForEachStore</code>语句是一个SCA元素，它允许您轻松地遍历视图存储提供的内容，同时可以轻松地集成到SwiftUI视图层次结构中。</p><p id="fb93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，那个<em class="ls">东西</em>是通过在商店的<code class="fe mx my mz na b">industries</code>属性上设置范围来定义的:</p><p id="a6e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">… ForEachStore(store.scope(state: \.industries, …))</code></p><p id="99be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着:交付到trailing closure中的是一个商店，一个接一个地专注于这个属性的项目。</p><p id="daec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们此刻接受了魔法，所以我们现在可以把那个<code class="fe mx my mz na b">industryStore</code>交给<code class="fe mx my mz na b">IndustryView</code>。</p><p id="4943" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们完了。至少对于视图序列来说是这样。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2891" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">谜语的最后一部分</h1><p id="ca30" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">那么<code class="fe mx my mz na b">ForEachStore</code>的第二部分<code class="fe mx my mz na b">action: parameter</code>呢？</p><p id="85ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">ForEachStore(store.scope(state: \.industries, <strong class="ky ir">action: IndustriesAction.industry(id:action:))</strong>)</code></p><p id="a427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是触发选择列表中的项目的原因。SCA封装了一切，所以只提供动作本身(<code class="fe mx my mz na b">.industry</code>)和参数交给reducer就足够了。</p><p id="6d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回到减速器，因为我们仍然需要解决一个谜题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="590b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在知道第一个减速器处理由<code class="fe mx my mz na b">IndustriesView</code>发出的动作。当<code class="fe mx my mz na b">.industry</code>动作到达时，减速器只做一件事:什么也不做。这意味着它将返回<code class="fe mx my mz na b">.none</code>。</p><p id="a52d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们有第二个减速器，即<code class="fe mx my mz na b">industryReducer</code>。那是什么？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1c9d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">'工业减速器'</h1><p id="12ab" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们切换到一个专用行业的上下文，看看它的reducer是如何定义的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1c1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，这些都是那里可能发生的行动。实际上，没有太多——只是改变了一个行业的名称。(您是否注意到，仅通过查看减速器，这是多么容易理解？)</p><p id="2c78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，从列表的角度来看，事情很简单:</p><ul class=""><li id="f2de" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">将<code class="fe mx my mz na b">industryReducer</code>应用于每个给定的状态项(即<code class="fe mx my mz na b">.industries</code>)</li><li id="ad65" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">如果一个动作<code class="fe mx my mz na b">.industry</code>发生，执行列表中给定行业的动作</li></ul><p id="939e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们在列表级别不做任何事情，所以只执行视图的<code class="fe mx my mz na b">NavigationLink</code>目的地——仅此而已。</p><p id="fbc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们不能省去第二个减速器吗？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9375" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">为什么我们不能省去第二个减速器呢？</h1><p id="b276" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当尝试这样做时，你会注意到该应用程序没有按预期执行。首先，让我们再看看<code class="fe mx my mz na b">IndustryView</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="48fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们注释掉第二个reducer会怎么样？应用程序仍然会构建，仍然会工作。但是如果您更改了一个行业的名称，这将不会被持久化—更改会立即丢失。</p><p id="c560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么会这样？</p><p id="d767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，<code class="fe mx my mz na b">IndustriesView</code>的减速器将这两个子减速器结合起来，并将结果(作为一个新状态)传递给<code class="fe mx my mz na b">IndustryView</code>的存储器。</p><p id="1251" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有第二个缩减器，返回的状态将与我们已经拥有的状态相同——因此将显示之前的列表状态(并传递给视图层次结构)。</p><p id="a901" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于第二个缩减器，我们为<code class="fe mx my mz na b">IndustryView</code>创建了一个新的状态，并因此获得了那个变化。不仅<code class="fe mx my mz na b">IndustryView</code>更新其显示，而且<code class="fe mx my mz na b">IndustriesView</code>显示的列表也将被更新。(顺便说一句，如果有人能解释这到底是如何发生在我身上的，我很乐意完全理解这一点。对我来说还是有些魔力的。)</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="99fd" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="27c8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我很高兴你跟踪我到这一步。我知道这是很多东西，但是我希望它可以帮助您了解这种用例的SCA基础。我还在摸SCA的皮毛，但我真的对它充满热情。自由点的两个家伙真的做得很好！</p><p id="19d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有很多东西需要探索，尤其是如何使用effects在一些持久存储上执行CRUD操作。如果你愿意，一旦我成功地挖掘了那个主题，还会有一些后续文章。</p></div></div>    
</body>
</html>