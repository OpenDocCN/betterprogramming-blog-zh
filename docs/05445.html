<html>
<head>
<title>What Is _proto_ in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的_proto_是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-proto-970978bee7c3?source=collection_archive---------14-----------------------#2020-07-08">https://betterprogramming.pub/what-is-proto-970978bee7c3?source=collection_archive---------14-----------------------#2020-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="52a0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你有没有在调试一些JavaScript代码的时候注意到_proto_ property？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f2a468d0092cb9562826c21202710c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zJlmLxJ21uiTVAZn"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="3bf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我学习JavaScript的旅途中，我记得这样做过，并且很快被展开<code class="fe ls lt lu lv b">_proto_</code>下拉菜单后显示的选项所淹没。这就是为什么我决定解释<code class="fe ls lt lu lv b">_proto_</code>和<code class="fe ls lt lu lv b">prototype</code>之间的区别，以及它们与原型继承的关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/04fc3377464e0d311901ea7d2a2711c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KntqGwNK_MUa49ElvEjjRw.png"/></div></div></figure></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="0c20" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">原型继承</strong></h1><p id="fc19" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">为了理解神秘的<code class="fe ls lt lu lv b">_proto_</code>，我们必须从讨论JavaScript的原型继承开始。在JavaScript中，对象可以通过对象原型继承属性和方法。</p><p id="8357" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象原型是当我们声明一个函数时自动初始化的对象。然后，该对象可以用作蓝图来声明方法和属性，这些方法和属性将由使用该对象的构造函数创建的任何对象自动继承。</p><p id="fc17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的函数都有一个原型，在继承树的最高层，我们可以找到JavaScript的<code class="fe ls lt lu lv b">Object.prototype</code>。将对象原型视为所有对象的曾曾祖父。一切都可以最终追溯到对象原型。你可以通过阅读官方的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>来了解更多，并且你可以通过阅读<a class="ae kv" href="https://medium.com/@warren.wilsonjr89/javascript-fundamentals-working-with-objects-6be28208880" rel="noopener">这篇文章</a>来更新你的对象知识，但是对于这篇文章来说，我们将关注于构造函数、继承和<code class="fe ls lt lu lv b">_proto_</code>。</p><p id="dbc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么<code class="fe ls lt lu lv b">_proto_</code>在这一切中扮演什么角色呢？</p><p id="2644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过一个例子来帮助我们想象当我们使用构造函数创建一个新对象时会发生什么。希望到最后这一切都有意义。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="e0b2" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">创建一个构造函数</strong></h1><p id="7964" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">让我们创建一个构造函数:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="4c50" class="nf mf iq lv b gy ng nh l ni nj">We’re creating a function to create puppy instances. </span><span id="d871" class="nf mf iq lv b gy nk nh l ni nj">function Puppy(name) {<br/>this.name = name<br/>  }</span><span id="07fe" class="nf mf iq lv b gy nk nh l ni nj">*Our function name is capitalized as this standard practice, but it has no effect on code functionality. </span></pre><p id="65df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们声明了上面的函数，就会为我们的<code class="fe ls lt lu lv b">Puppy</code>函数创建一个原型对象。这个原型对象用两个属性初始化:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/c335ffad2adc03714ae28d6cec586f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y2y1iLo8sG3XKARLOlGeDg.png"/></div></div></figure><ol class=""><li id="46ab" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">上面声明的原始构造函数。</li><li id="6592" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">对<code class="fe ls lt lu lv b">Object.prototype</code>到<code class="fe ls lt lu lv b">_proto_</code>的引用。</li></ol><p id="baaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我鼓励你打开你的控制台，尝试一下。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="3462" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">创造一只小狗</strong></h1><p id="3fa1" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">下面，我们声明一个名为<code class="fe ls lt lu lv b">toby</code>的变量，创建一个新的<code class="fe ls lt lu lv b">Puppy</code>对象，并将其命名为<code class="fe ls lt lu lv b">toby</code>:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="9fe1" class="nf mf iq lv b gy ng nh l ni nj">const toby = new Puppy(‘toby’);</span></pre><p id="aafa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们创建这个新的<code class="fe ls lt lu lv b">Puppy</code>对象时，下面的事情会在幕后发生:</p><ol class=""><li id="61a0" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">JavaScript创建一个空对象。</li><li id="c6e5" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">它创建了<code class="fe ls lt lu lv b">_proto_</code>属性作为新对象的附加属性。此属性是对构造函数的属性的直接引用。</li><li id="1635" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">它评估我们的<code class="fe ls lt lu lv b">Puppy</code>构造函数中的构造函数，作为这个关键字的结果，它返回一个name属性设置为<code class="fe ls lt lu lv b">toby</code>的对象。然后这个对象被分配给我们的常量<code class="fe ls lt lu lv b">toby</code>。</li></ol><p id="d698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们正在尝试理解<code class="fe ls lt lu lv b">_proto_</code>，我希望你能跟上，我鼓励你在你的控制台上键入以下内容:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="e6bf" class="nf mf iq lv b gy ng nh l ni nj">Object.getPrototypeOf(toby) === Puppy.prototype<br/>//this will return true because our toby __proto__ references the Puppy prototype.</span><span id="58ca" class="nf mf iq lv b gy nk nh l ni nj">toby.__proto__ === Puppy.prototype<br/>//this comparison will also return true, but using the __proto__ is not recommended as it's been deprecated, and replaced by Object.getPrototypeOf(object name here). </span><span id="7906" class="nf mf iq lv b gy nk nh l ni nj">You can also set the prototype of an object with Object.setPrototypeOf(prototype name here), but this is not recommended due to the performance and compability issues this may create.</span></pre><p id="e3ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，对我们的构造函数原型所做的任何更改都将反映在使用该函数创建的对象中。让我们通过向构造函数的原型添加一个新方法来看看下面的操作:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="bd75" class="nf mf iq lv b gy ng nh l ni nj">Puppy.prototype.bark = function() {return `WOOF! WOOF! I am a ferocious puppy named ${this.name} , fear me! `}</span></pre><p id="95f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以在<code class="fe ls lt lu lv b">toby</code>上调用我们的<code class="fe ls lt lu lv b">bark</code>方法。我们的方法将返回下面的代码片段:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/6a8390f7c5f3ab77be89636c164b56e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-TJNuZl7skxODYhSkR-Sg.png"/></div></div></figure><p id="bf12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们决定<code class="fe ls lt lu lv b">toby</code>超级牛逼，他有一套非常独特的技能和一种特别的叫声呢？我们可以简单地为<code class="fe ls lt lu lv b">toby</code>定义一个本地方法:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="9ad8" class="nf mf iq lv b gy ng nh l ni nj">toby.bark = function() {<br/>return `<!-- -->WOOOOOOOOOOOF! WOOOOOOF! I'm an awesome puppy named ${this.name}`<br/>  <!-- -->} </span></pre><p id="97b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们调用<code class="fe ls lt lu lv b">toby.bark</code>时，JavaScript将看到有一个本地bark方法，因此它将执行本地方法，而不是遍历原型链:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/096d28134616eeaf73bd9828e292ac89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YoqA98fEsZwi6ONDrH7AHw.png"/></div></div></figure><p id="e069" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果<code class="fe ls lt lu lv b">toby</code>决定再次改变他的树皮风格，我们可以删除本地的<code class="fe ls lt lu lv b">bark</code>方法，JavaScript将使用<code class="fe ls lt lu lv b">toby</code>对象中的<code class="fe ls lt lu lv b">_proto_</code>引用，并开始沿着原型链再次寻找<code class="fe ls lt lu lv b">bark</code>方法。它将遍历原型链并返回我们上面的第一个例子。</p><p id="5e0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们删除了这两个<code class="fe ls lt lu lv b">bark</code>方法，JavaScript将使用<code class="fe ls lt lu lv b">_proto_</code>引用遍历原型链，一直回到JavaScript的对象原型。它没有一个<code class="fe ls lt lu lv b">bark</code>方法或者一个额外的<code class="fe ls lt lu lv b">_proto_</code>引用，此时它将返回<code class="fe ls lt lu lv b">null</code>。</p><p id="0719" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过在控制台上键入以下代码来验证这一有趣的事实:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/bd6a2c07255f6263e602eaa3d1b96c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQl1z85i7e3Ip6qGpV2HHg.png"/></div></div></figure><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="b0d8" class="nf mf iq lv b gy ng nh l ni nj">Object.getPrototypeOf(Object.prototype)<br/>// This returns null because nothing else exists after the Object.prototype. The end of the road. </span></pre></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="0ed3" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">TLDR</h1><ol class=""><li id="3122" class="nm nn iq ky b kz mw lc mx lf od lj oe ln of lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b">_proto_</code>是在所有JavaScript对象中自动创建的属性。该属性引用创建它的原型。</li><li id="4c0b" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">原型是为所有功能自动创建的对象。该原型可用于声明方法和属性，这些方法和属性将由使用该构造函数创建的所有对象继承。</li><li id="e939" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b">Object.prototype</code>是所有其他对象继承的父对象。</li><li id="396a" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">这是对JavaScript继承的一个简要的抽象解释。要获得更深入的解释，请查看<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>。</li></ol></div></div>    
</body>
</html>