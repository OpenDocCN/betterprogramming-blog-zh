<html>
<head>
<title>Set Up a Flask and Next.js Application with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker设置Flask和Next.js应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/setup-flask-nextjs-application-with-docker-97e82a897573?source=collection_archive---------5-----------------------#2019-09-24">https://betterprogramming.pub/setup-flask-nextjs-application-with-docker-97e82a897573?source=collection_archive---------5-----------------------#2019-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ec98b4fc259758974dd1ff5595ff7477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bqdw-IQrILS7ObvK"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@jesuskiteque?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jesus Kiteque </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1b0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，作为一名兼职人员，我一直致力于推出passporr.com。Passporr.com是一个平台，允许国际学生搜索和找到任何与他们的学习相关的东西。它可以通过向国际学生提供免费工具和社区问答知识库来帮助他们。</p><p id="9f4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用Flask (Python web framework)、Next.js (React framework)搭建平台，把所有东西都包在Docker里。</p><p id="8998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构建passporr之前，我找不到一个好的教程来教我如何使用Docker服务Flask和React.js应用程序。所以我决定写一个。</p><p id="4b45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将分享我如何使用Docker和<code class="fe lb lc ld le b">docker-compose</code>建立我的本地开发。我还会分享我是如何用<code class="fe lb lc ld le b">docker-machine</code>直接部署到DigitalOcean的。</p><p id="657c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的重点是我如何设置代码库来与Docker和<code class="fe lb lc ld le b">docker-compose</code>一起工作。在以后的文章中，我将更深入地讨论Flask和Next.js。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="e3d8" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">那么我们要建造什么呢？</h1><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/1d26b3d2e9216669cc0d83f6ee9b9b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*whxKu1_bJeE8yb_NTOV30g.gif"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">示例应用程序的基本功能</p></figure><p id="41d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将在这里展示的应用程序包括:</p><p id="4d94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">烧瓶应用程序(后端API)</p><ul class=""><li id="b2f9" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">用于身份验证的端点</li><li id="db17" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">获取、发布、放置用户的端点</li></ul><p id="aceb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Next.js应用程序(前端)</p><ul class=""><li id="ac08" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">匿名用户可访问的路线(主页、组件页、登录页)</li><li id="55f3" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">安全路线(个人资料页面)</li></ul></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="9adc" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">将申请归档</h1><p id="dd8f" class="pw-post-body-paragraph kd ke iq kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">如果你去GitHub并克隆<a class="ae kc" href="https://github.com/martindavid/flask-react-docker-app" rel="noopener ugc nofollow" target="_blank"> repo </a>，你会看到代码库由三个主要文件夹组成:<code class="fe lb lc ld le b">api</code>、<code class="fe lb lc ld le b">client</code>和<code class="fe lb lc ld le b">nginx</code>。</p><p id="5846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每个文件夹中，您会发现一个docker文件，它为每个服务构建了容器。您还会看到一个名为<code class="fe lb lc ld le b">Dockerfile-prod</code>的文件。<code class="fe lb lc ld le b">Dockerfile-prod</code>是一个Docker文件，我们将使用它来部署到生产环境中。当我们讨论部署时，我们将回到该文件。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="5c19" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">烧瓶应用图像</h1><pre class="ml mm mn mo gt ni le nj nk aw nl bi"><span id="26da" class="nm ln iq le b gy nn no l np nq"><em class="nr"># Base Image</em><br/>FROM python:3.7.2-slim<br/><br/><em class="nr"># Install netcat</em><br/>RUN apt-get update &amp;&amp; \<br/>    apt-get -y install netcat &amp;&amp; \<br/>    apt-get clean<br/><br/><em class="nr"># set working directory</em><br/>WORKDIR /usr/src/app<br/><br/><em class="nr"># add and install requirements</em><br/>COPY ./requirements.txt /usr/src/app/requirements.txt<br/>RUN pip install -r requirements.txt<br/><br/><em class="nr"># add app</em><br/>COPY . /usr/src/app<br/><br/><em class="nr"># run server</em><br/>CMD python manage.py run -h 0.0.0.0</span></pre><p id="b809" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于开发映像，我使用<code class="fe lb lc ld le b">python:3.7.2-slim</code>作为基础映像，并使用Flask内置的web服务器运行应用程序。如果你查看<code class="fe lb lc ld le b">api</code>文件夹中的另一个文件，你会发现我使用<code class="fe lb lc ld le b">gunicorn</code>服务Flask应用程序的<code class="fe lb lc ld le b">Dockerfile-prod</code>文件。</p><p id="47a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了Flask应用程序映像，在<code class="fe lb lc ld le b">api/project</code>文件夹中，您会发现一个名为<code class="fe lb lc ld le b">db</code>的文件夹，其中包含一个用于创建数据库的SQL文件和一个用于Postgres的docker文件。</p><pre class="ml mm mn mo gt ni le nj nk aw nl bi"><span id="830a" class="nm ln iq le b gy nn no l np nq">FROM postgres:11.1-alpine<br/><br/>ADD create.sql /docker-entrypoint-initdb.d</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="af72" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Next.js应用程序图像</h1><p id="ec16" class="pw-post-body-paragraph kd ke iq kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">Next.js应用程序的Dockerfile</p><pre class="ml mm mn mo gt ni le nj nk aw nl bi"><span id="0876" class="nm ln iq le b gy nn no l np nq">FROM node:10.16.0-alpine<br/><br/>WORKDIR usr/src/app<br/>ENV PATH /usr/src/app/node_modules/.bin:$PATH<br/><br/><em class="nr"># install and cache app dependencies</em><br/>COPY package.json /usr/src/app/package.json<br/><br/>RUN npm install<br/><br/>EXPOSE 3000<br/>CMD ["npm", "run", "dev"]</span></pre><p id="769d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Next.js应用程序的图像非常简单。我使用了<code class="fe lb lc ld le b">node:10.16.0-alpine</code>作为基本映像，并运行了<code class="fe lb lc ld le b">dev</code>脚本来运行热重装。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="0bbe" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Nginx图像</h1><p id="d3ee" class="pw-post-body-paragraph kd ke iq kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">为了连接Flask API和Next.js应用程序，我使用Nginx。这一部分展示了我如何为Nginx设置配置。</p><pre class="ml mm mn mo gt ni le nj nk aw nl bi"><span id="82ac" class="nm ln iq le b gy nn no l np nq">server {<br/>  listen 8080;<br/><br/>  location / {<br/>    proxy_pass        http://client:3000;<br/>    proxy_redirect    default;<br/>    proxy_set_header  Upgrade $http_upgrade;<br/>    proxy_set_header  Connection "upgrade";<br/>    proxy_set_header  Host $host;<br/>    proxy_set_header  X-Real-IP $remote_addr;<br/>    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;<br/>    proxy_set_header  X-Forwarded-Host $server_name;<br/>    proxy_set_header  X-Forwarded-Proto $scheme;<br/>  }<br/><br/>  location /api {<br/>    proxy_pass        http://api:5000;<br/>    proxy_redirect    default;<br/>    proxy_set_header  Host $host;<br/>    proxy_set_header  Upgrade $http_upgrade;<br/>    proxy_set_header  Connection "upgrade";<br/>    proxy_set_header  X-Real-IP $remote_addr;<br/>    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;<br/>    proxy_set_header  X-Forwarded-Host $server_name;<br/>    proxy_set_header  X-Forwarded-Proto $scheme;<br/>  }<br/>}</span></pre><p id="05f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的Nginx配置中，我们可以看到对<code class="fe lb lc ld le b">/api</code>的调用被重新路由到Flask应用程序，它在端口<code class="fe lb lc ld le b">5000</code>上。请求的其余部分被路由到Next.js应用程序。我使用端口<code class="fe lb lc ld le b">8080</code>作为Nginx监听的默认端口，以避免与机器上的其他端口冲突。</p><p id="27d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了上面的配置，下面是Nginx的docker文件，非常简单。</p><pre class="ml mm mn mo gt ni le nj nk aw nl bi"><span id="ee9e" class="nm ln iq le b gy nn no l np nq">FROM nginx:1.15.8-alpine<br/><br/>RUN rm /etc/nginx/conf.d/default.conf<br/>COPY /dev.conf /etc/nginx/conf.d</span></pre><p id="b2cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，为了一次运行所有的服务，我使用<code class="fe lb lc ld le b">docker-compose</code>来编排所有的服务。</p><pre class="ml mm mn mo gt ni le nj nk aw nl bi"><span id="7080" class="nm ln iq le b gy nn no l np nq">version: '3.7'<br/><br/>services:<br/>  api:<br/>    build:<br/>      context: ./api<br/>      dockerfile: Dockerfile<br/>    volumes:<br/>      - './api:/usr/src/app'<br/>    ports:<br/>      - 5002:5000<br/>    environment:<br/>      - FLASK_CONFIG=development<br/>      - FLASK_ENV=development<br/>      - APP_SETTINGS=project.config.DevelopmentConfig<br/>      - DATABASE_URL=postgres://postgres:postgres@tutorial-db:5432/dev_db<br/>      - DATABASE_TEST_URL=postgres://postgres:postgres@tutorial-db:5432/test_db<br/>      - SECRET_KEY=ZQbn05PDeA7v11<br/>    depends_on:<br/>      - tutorial-db<br/><br/>  tutorial-db:<br/>    build:<br/>      context: ./api/project/db<br/>      dockerfile: Dockerfile<br/>    ports:<br/>      - 5436:5432<br/>    environment:<br/>      - POSTGRES_USER=postgres<br/>      - POSTGRES_PASSWORD=postgres<br/><br/>  nginx:<br/>    build:<br/>      context: ./nginx<br/>      dockerfile: Dockerfile<br/>    restart: unless-stopped<br/>    ports:<br/>      - 8080:8080<br/>    depends_on:<br/>      - api<br/>      - client<br/><br/>  client:<br/>    build:<br/>      context: ./client<br/>      dockerfile: Dockerfile<br/>    volumes:<br/>      - './client:/usr/src/app'<br/>      - '/usr/src/app/node_modules'<br/>    ports:<br/>      - 3008:3000<br/>    environment:<br/>      - NODE_ENV=development<br/>      - REACT_APP_SERVICE_URL=http://localhost:8080<br/>      - CHOKIDAR_USEPOLLING=true<br/>    depends_on:<br/>      - api</span></pre><p id="96bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的<code class="fe lb lc ld le b">docker-compose.yml</code>文件中，我们将运行四个服务(<code class="fe lb lc ld le b">api</code>、<code class="fe lb lc ld le b">tutorial-db</code>、<code class="fe lb lc ld le b">nginx</code>和<code class="fe lb lc ld le b">client</code>)。</p><p id="5bca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以从<a class="ae kc" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>打开主应用程序，或者从<a class="ae kc" href="http://localhost:5002/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5002 </a>单独访问Flask应用程序，或者从<a class="ae kc" href="http://localhost:3008/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3008 </a>访问Next.js应用程序。您也可以从端口<code class="fe lb lc ld le b">5436</code>访问Postgres数据库。</p><p id="1e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您设置好一切之后，您可以通过运行<code class="fe lb lc ld le b">docker-compose up -d --build</code>来运行整个配置。</p><h1 id="e9ef" class="lm ln iq bd lo lp ns lr ls lt nt lv lw lx nu lz ma mb nv md me mf nw mh mi mj bi translated">将应用程序部署到数字海洋</h1><p id="0581" class="pw-post-body-paragraph kd ke iq kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">使用<code class="fe lb lc ld le b">docker-machine</code>，您可以轻松地将您的应用程序直接部署到云提供商，如DigitalOcean或AWS。在这篇文章中，我将展示如何将它部署到数字海洋。(有关部署到AWS的更多信息，请点击此处的<a class="ae kc" href="https://docs.docker.com/machine/examples/aws/" rel="noopener ugc nofollow" target="_blank"/>。)在执行以下步骤之前，请确保您已经:</p><ol class=""><li id="133a" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la nx mv mw mx bi translated">数字海洋账户。如果需要，使用这个<a class="ae kc" href="https://m.do.co/c/8756bd95a305" rel="noopener ugc nofollow" target="_blank">链接</a>创建一个。如果你是学生，你也可以利用<a class="ae kc" href="https://education.github.com/pack#offers" rel="noopener ugc nofollow" target="_blank"> GitHub教育包</a>在DigitalOcean上获得50美元的平台积分。</li><li id="652c" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nx mv mw mx bi translated">数字海洋的个人访问令牌</li></ol><h1 id="bf69" class="lm ln iq bd lo lp ns lr ls lt nt lv lw lx nu lz ma mb nv md me mf nw mh mi mj bi translated">创建新的Docker-Engine实例</h1><p id="26a9" class="pw-post-body-paragraph kd ke iq kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">首先要做的是在DigitalOcean上创建一个Docker-machine实例。</p><pre class="ml mm mn mo gt ni le nj nk aw nl bi"><span id="1741" class="nm ln iq le b gy nn no l np nq">docker-machine create --driver digitalocean --digitalocean-access-token &lt;your_personal_access_token&gt; &lt;name-for-your-docker-machine&gt;</span></pre><p id="1674" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">成功创建后，您可以使用<code class="fe lb lc ld le b">docker-machine ls</code>进行检查。</p><pre class="ml mm mn mo gt ni le nj nk aw nl bi"><span id="cab6" class="nm ln iq le b gy nn no l np nq">NAME                     ACTIVE   DRIVER         STATE     URL                              SWARM   DOCKER     ERRORS<br/>&lt;docker-machine-name&gt;    -        digitalocean   Running   tcp://&lt;docker-machine-ip&gt;:2376           v19.03.1</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="f2f3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">部署应用程序</h1><p id="e649" class="pw-post-body-paragraph kd ke iq kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">以下命令将把您连接到DigitalOcean中的实例，您可以使用<code class="fe lb lc ld le b">docker-compose</code>部署应用程序:</p><pre class="ml mm mn mo gt ni le nj nk aw nl bi"><span id="e6cd" class="nm ln iq le b gy nn no l np nq"># Activate the docker-machine. Replace <!-- -->&lt;docker-machine-name&gt;<!-- --> with the actual docker-machine name from the previous step.<br/>$ docker-machine env &lt;docker-machine-name&gt;</span><span id="3ded" class="nm ln iq le b gy ny no l np nq"># Activate shell configuration<br/>$ eval $(docker-machine env &lt;docker-machine-name&gt;)</span><span id="1ff0" class="nm ln iq le b gy ny no l np nq"># Run docker-compose<br/>$ eval $(docker-machine env &lt;docker-machine-name&gt;)</span><span id="4c66" class="nm ln iq le b gy ny no l np nq"># Check if all containers run successfully<br/>$ docker ps</span></pre><p id="6472" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保有三个容器在那里运行。您也可以从<code class="fe lb lc ld le b">http://&lt;docker-machine-ip&gt;</code>访问应用程序。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="a3a6" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">摘要</h1><p id="4ad7" class="pw-post-body-paragraph kd ke iq kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">从开发之初就使用Docker，用它来推送到生产，帮助我快速开发应用。</p><p id="126e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我也更有信心，因为我的应用程序在开发和生产中都有相同的环境设置。</p><p id="3614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这里展示的从本地机器部署的步骤对于团队环境或更健壮的应用程序可能不太理想。在这些情况下，您可能需要尝试使用CI/CD设置的选项。</p></div></div>    
</body>
</html>