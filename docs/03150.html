<html>
<head>
<title>Unexpected Lessons From 100% Test Coverage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自100%测试覆盖率的意外教训</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unexpected-lessons-from-100-test-coverage-eebeee211b7a?source=collection_archive---------8-----------------------#2020-01-23">https://betterprogramming.pub/unexpected-lessons-from-100-test-coverage-eebeee211b7a?source=collection_archive---------8-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c5bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我从测试一切中学到的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9c716bf614d3f17ca6ca44ffe0a5375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OXC-p0kDuTDJt0dpl_6IA.png"/></div></div></figure><p id="d903" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">软件工程界的传统观点认为，争取100%的测试覆盖率是徒劳的。它不一定能帮助你发现所有的错误，而且在你写代码的时候，它可能会把你引向有问题的道路。</p><p id="a42f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最近对100%测试覆盖率的尝试告诉我答案要微妙得多。有时，为了覆盖范围，我很想做一些有问题的代码更改。有些时候，我屈服了。然而我发现通常有一种开明的方法来覆盖一个分支<em class="lq">和</em>使代码对它更好。盲目的100%覆盖会导致我们做出不可接受的妥协。但是，如果我们约束自己只做更好的代码库，考虑100%的覆盖率会改变我们对代码库的看法。我尝试100%测试覆盖率的故事是一个有好有坏的故事。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="c820" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">去年，我看到了NPM创始人Isaac Z. Schlueter提倡100%测试覆盖率的帖子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5ec1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Schlueter提到了一个开发者实现的<em class="lq">心态转变</em>，这引起了我的兴趣:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0640" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">通往100岁的道路</h1><p id="8e5f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我决定<a class="ae mx" href="https://github.com/google/schema-dts" rel="noopener ugc nofollow" target="_blank"> schema-dts </a>将是100%测试覆盖实验的完美候选。给定<a class="ae mx" href="https://en.wikipedia.org/wiki/N-Triples" rel="noopener ugc nofollow" target="_blank"> N-Triples </a>作为输入，schema-dts <a class="ae mx" href="https://blog.eyas.sh/2019/05/modeling-schema-org-schema-with-typescript-the-power-and-limitations-of-the-typescript-type-system/" rel="noopener ugc nofollow" target="_blank">生成描述该本体的有效JSON-LD文字</a>的TypeScript类型。我最近对让它变得稳定非常感兴趣，并试图了解代码库中还有哪些空间。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9db0" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">设置</h1><p id="7e9a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">首先，我没有办法计算我的项目在当前状态下的测试覆盖率。为了得到支持，我最终把我的测试跑步者从茉莉换成了摩卡。不过，这是一个打字稿项目，我必须启用源地图，并使用它们来获得我的实际<code class="fe my mz na nb b">.ts</code>源的覆盖率。我使用伊斯坦堡的<code class="fe my mz na nb b"><a class="ae mx" href="https://istanbul.js.org/" rel="noopener ugc nofollow" target="_blank">nyc</a></code>在当地进行覆盖运行。<code class="fe my mz na nb b"><a class="ae mx" href="https://coveralls.io/" rel="noopener ugc nofollow" target="_blank">Coveralls</a></code>与<code class="fe my mz na nb b">nyc</code>很好地集成在一起，主持代码覆盖时间的在线跟踪。工作服还可与Travis CI无缝集成，并根据其δ覆盖率控制所有PR(<a class="ae mx" href="https://github.com/google/schema-dts/pull/57" rel="noopener ugc nofollow" target="_blank">PR # 57</a>)。</p><p id="898a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设置好之后，我的第一次<em class="lq">真实</em>运行有一个<a class="ae mx" href="https://coveralls.io/builds/28108326" rel="noopener ugc nofollow" target="_blank"> %78.72的测试覆盖率</a>。我想，这还不算太糟。</p><p id="94ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些基线测试肯定<em class="lq">覆盖了</em>很多他们没有真正执行的代码行，这也是为什么这个数字很高的部分原因。这本身就可以证明100%的测试覆盖率是一个没有意义的数字。然而，Schlueter对100%测试覆盖率的承诺是，<em class="lq">到达那个长尾</em>的行为可以对<em class="lq">我如何思考我自己的代码</em>产生变革性的影响。我想在第一手牌上试试运气。如果我们想对我们被覆盖的代码行被真正地<em class="lq">测试</em>更有信心，那么<a class="ae mx" href="https://en.wikipedia.org/wiki/Mutation_testing" rel="noopener ugc nofollow" target="_blank">突变测试</a>可能会比测试覆盖更有效果。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5e7e" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">快乐时光:低垂的果实</h1><p id="097d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">类似Schema.org的本体可以通过用一个<code class="fe my mz na nb b"> <a class="ae mx" href="https://schema.org/supersededBy" rel="noopener ugc nofollow" target="_blank">supersededBy</a></code>谓词标记某个类、属性或枚举值，将它声明为<em class="lq">弃用的</em>。<code class="fe my mz na nb b">schema-dts</code>用两种方式之一来处理这个问题:要么在代码中用<code class="fe my mz na nb b">@deprecated</code> JSDoc注释来标记它，要么完全去掉那些声明。</p><p id="12c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看我的覆盖率报告，大量未测试的代码变得很明显。例如，我<a class="ae mx" href="https://coveralls.io/builds/28108326/source?filename=src/ts/class.ts#L125" rel="noopener ugc nofollow" target="_blank">从未试图生成一个</a> <code class="fe my mz na nb b"><a class="ae mx" href="https://coveralls.io/builds/28108326/source?filename=src/ts/class.ts#L125" rel="noopener ugc nofollow" target="_blank">@deprecated</a></code> <a class="ae mx" href="https://coveralls.io/builds/28108326/source?filename=src/ts/class.ts#L125" rel="noopener ugc nofollow" target="_blank"> <em class="lq">类</em> </a>。好吧，我们来解决这个问题。我<a class="ae mx" href="https://github.com/google/schema-dts/pull/60" rel="noopener ugc nofollow" target="_blank">发现了一个我的几个单元测试没有发现的真正的bug </a>。我增加了9.8%的覆盖率，添加了一些不赞成的基线测试，并添加了一些我从来没有做过的N重解析单元测试。</p><p id="9851" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">测试我的Argparse设置告诉我<a class="ae mx" href="https://github.com/google/schema-dts/pull/76" rel="noopener ugc nofollow" target="_blank">我的一个默认标志值是错误的</a>(尽管是无害的)。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6a59" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">可疑的时代</h1><h2 id="f56f" class="nc mb it bd mc nd ne dn mg nf ng dp mk ld nh ni mm lh nj nk mo ll nl nm mq nn bi translated">日志测试？</h2><p id="efbd" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我看到的许多未覆盖的行都与记录我们跳过或丢弃的内容的语句有关，或者与我们处理的可恢复条件有关。这些日志中有很多是发生在真实Schema.org N重文件中的警告。例如，我们从不处理描述属性的<code class="fe my mz na nb b">sameAs</code>或<code class="fe my mz na nb b">inverseOf</code>三元组。如果我们看到两个描述同一个类或属性的评论，新的那个获胜。</p><p id="b231" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">直觉告诉我们，日志语句不应该被测试。但是出于好的和不好的原因，我认为对日志输出进行一些基线测试可能是可取的。</p><p id="f333" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个单元测试已经足够时，我用它来为多注释情况添加一个日志测试。这很值得怀疑——但是我被我的热情所吸引！</p><p id="af05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">某种程度的基于日志的测试可能是合理的，因为(1)我们正在观察用户交互的变化，以及(2)它记录了我们代码的警告/限制。也许人们可以将某些基于日志的测试视为等同于屏幕截图区分UI测试？也可能我真的在努力解释自己。尽管如此，我对添加<a class="ae mx" href="https://github.com/google/schema-dts/pull/64/commits/2da73f6df3a04c17777e3e33ea45c9694addbe2d" rel="noopener ugc nofollow" target="_blank">一个在解析一个常见的三元组</a>时显示警告的测试的感觉没有对那个注释测试的感觉那么糟糕。</p><h2 id="b9df" class="nc mb it bd mc nd ne dn mg nf ng dp mk ld nh ni mm lh nj nk mo ll nl nm mq nn bi translated">代码高尔夫？</h2><p id="b2b2" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">另一种避免这些<code class="fe my mz na nb b">if (case) { Log(...); }</code>情况的方法是改为编写<code class="fe my mz na nb b">warnIf(case, ...)</code>。我想大多数人都会同意这样的改变是无益的。有人可能会提出马基雅维利式的论点，认为这样的代码高尔夫从结果来看是合理的:一旦你达到了100%的测试覆盖率，你就会停留在那里，并且你会批判性地思考你所有的未来差异。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5b07" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">将自己约束在中立和积极的“代码高尔夫”上</h1><p id="4645" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我中途尝试做的一件事是，确保我不会以测试覆盖的名义参与任何使代码库变得更糟的代码高尔夫。(取决于您如何定义code golf，它可能同义反复地意味着它使代码库变得更糟。在这里，我真的只是指为了覆盖而对代码进行的任何创造性的重新排列。)</p><p id="de1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我发现一些代码高尔夫实际上帮助我更清楚地思考代码。即使在代码库本身看起来相同的情况下，我现在也有了一个新的词汇来谈论错误条件。在其他一些情况下，覆盖代码行驱使我从在代码中做运行时保证转向在代码中做编译时保证(肯定是积极的)。</p><p id="c688" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一些例子。</p><h2 id="48a3" class="nc mb it bd mc nd ne dn mg nf ng dp mk ld nh ni mm lh nj nk mo ll nl nm mq nn bi translated">中立:澄清断言与错误</h2><p id="0de7" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我有转换函数，它接受RDF三元组并把它们转换成类的中间表示。这些功能存在一些问题:</p><p id="3ac7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">案例研究A:内部功能不可能性</strong></p><p id="5b50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的代码中有一行<a class="ae mx" href="https://coveralls.io/builds/28158052/source?filename=src/transform/toClass.ts#L91" rel="noopener ugc nofollow" target="_blank">我的测试从未涉及到。它看起来像这样:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lz l"/></div></figure><p id="8614" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的，只要阅读这个函数就知道:<code class="fe my mz na nb b">(classes.size === 0)</code>永远不会发生。首先，上面有一个<code class="fe my mz na nb b">classes.set(K, V)</code>。我们从这个硬编码的<code class="fe my mz na nb b">wellKnownTypes</code>数组中设置一些其他的键值对，使其总是具有固定数量的元素。</p><p id="b949" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以试着理解这个错误的意义:它可能表明我们得到的RDF三元组没有一个被转换成类(在这种情况下，我们可能想比较<code class="fe my mz na nb b">classes.size</code>和<code class="fe my mz na nb b">wellKnownTypes.length + 1</code>)。或者，当我们对正确构建类不太有信心，并且对这些众所周知的类型没有清晰的概念时，这可能是一个不恰当的验证。</p><p id="7f62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的例子中，创建一个只有知名人物的地图似乎没问题。如果本体是空的或者缺少数据，我们可能会在更早的步骤或者更晚的步骤中发现它。该错误没有给出关于哪里出错的清晰上下文。所以，对我来说，答案是杀死它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lz l"/></div></figure><p id="665a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">案例研究B:函数间断言</strong></p><p id="4dbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我看到的另一个错误是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lz l"/></div></figure><p id="8f56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，第21行从未发生过(并且<code class="fe my mz na nb b">(!cls)</code>条件始终为假)。这应该是有意义的:<code class="fe my mz na nb b">ForwardDeclareClasses</code>检查一个<code class="fe my mz na nb b">TypedTopic</code>是否满足<code class="fe my mz na nb b">IsClass()</code>，如果满足，<em class="lq">无条件地</em>将它添加到地图中。<code class="fe my mz na nb b">BuildClasses</code>断言匹配<code class="fe my mz na nb b">IsClass</code>的主题存在于地图中。</p><p id="f916" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获得该行测试覆盖率的一种方法是导出<code class="fe my mz na nb b">BuildClasses</code>并测试它。但这似乎违背了让代码库变得更好的精神。更好的方法是询问这行代码试图做什么。</p><h2 id="191c" class="nc mb it bd mc nd ne dn mg nf ng dp mk ld nh ni mm lh nj nk mo ll nl nm mq nn bi translated"><strong class="ak">插曲:期望、错误和断言</strong></h2><p id="2142" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">有时，我们断言事物是因为它们要么…</p><ul class=""><li id="fcbe" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated"><em class="lq">错误情况</em>是指由于数据或输入不良而可能在野外发生的情况，</li><li id="6751" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated"><em class="lq">不应该发生</em>，而<em class="lq">如果他们发生了</em>那就是我们代码中有bug的迹象，或者</li><li id="a64e" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated"><em class="lq">不应该发生</em>，如果发生了<em class="lq"/>那就是宇宙辐射的迹象。</li></ul><p id="209f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我决定区分这些。如果我的测试覆盖报告抱怨一个未覆盖的:</p><ul class=""><li id="c6b6" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">错误情况—我应该测试一下。如果我不能，我应该重构我的代码，使其可测试；</li><li id="44f4" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">断言</li><li id="991a" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated"><strong class="kw iu">完全不可能的断言</strong>——也许我应该删除它。</li></ul><p id="b6e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将#1称为<strong class="kw iu">错误条件— </strong> <em class="lq">测试这些</em>。</p><p id="b9e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于断言，我经常发现#2和#3之间的界线通常是<em class="lq">函数</em>的边界(这并不总是正确的)。<em class="lq">函数内</em>断言的例子(就像上面的<strong class="kw iu">案例研究</strong> <strong class="kw iu"> A </strong>一样)看起来是如此的无用，以至于我们最好移除它们。<em class="lq">交互函数</em>断言的情况(就像这个例子)看起来足够有用。</p><h2 id="1edf" class="nc mb it bd mc nd ne dn mg nf ng dp mk ld nh ni mm lh nj nk mo ll nl nm mq nn bi translated"><strong class="ak">修复</strong></h2><p id="3b6a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我发现这种区别不仅有助于吹毛求疵——对阅读代码的人也很有帮助。这个错误是<em class="lq">在正常操作</em>中可能发生的还是<em class="lq">是一个bug </em>的标志？我决定澄清这一点:</p><ul class=""><li id="9c6b" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">正常错误情况:<code class="fe my mz na nb b">if</code> + <code class="fe my mz na nb b">throw</code>，或类似情况。</li><li id="5ca1" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">Bug断言:<code class="fe my mz na nb b">assert</code>和<code class="fe my mz na nb b">assertXyz</code>变种。</li></ul><p id="6baa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这样，我结束了<a class="ae mx" href="https://github.com/google/schema-dts/pull/73/commits/11c9f64397e0ddbe29f09ac1b8945fd72d7ad213" rel="noopener ugc nofollow" target="_blank">这个变化</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lz l"/></div></figure><p id="38b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，考虑覆盖一行代码从根本上帮助我更有效地交流我的代码做了什么。我不得不做的许多“移动东西”在很大程度上是语义代码高尔夫(令人高兴的是<em class="lq"/>碰巧给出了更好的测试覆盖分数)，但我更愿意认为这是一个净积极因素。</p><h2 id="d738" class="nc mb it bd mc nd ne dn mg nf ng dp mk ld nh ni mm lh nj nk mo ll nl nm mq nn bi translated">正面:重构代码以实现编译时保证，而不是运行时保证</h2><p id="e89d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我已经展示了一些<em class="lq">永远不会</em>被测试运行覆盖的行是断言<em class="lq">永远不会发生</em>。有时，我们可以重构代码，对代码的结构做出编译时声明，而不是担心它。</p><p id="75c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我会说得更具体:我的代码有一个<code class="fe my mz na nb b"><a class="ae mx" href="https://coveralls.io/builds/28179594/source?filename=src/ts/util/comments.ts#L32" rel="noopener ugc nofollow" target="_blank">parseComment</a></code>函数，它使用<code class="fe my mz na nb b"><a class="ae mx" href="https://www.npmjs.com/package/htmlparser2" rel="noopener ugc nofollow" target="_blank">htmlparser2</a></code>将HTML注释转换成<a class="ae mx" href="https://jsdoc.app/" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>标记的注释。在这段代码中，我们定义了一个新的<code class="fe my mz na nb b">htmlparser2.Parser</code>，它处理已知的标签并抛出未知的标签。它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lz l"/></div></figure><p id="fa47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最初，上面代码片段中的第11行和第18行没有被覆盖。<code class="fe my mz na nb b">onopentag</code>中的第11行很简单——我添加了一个未知标签的测试，发现它失败了。很好——我们的测试范围现在包括了这一行。</p><p id="0564" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过，我没法搞定18号线。如果存在未知的开始标记，它将抛出on open。自结束标签算作开始标签。关闭一个从未打开的标签是不好的HTML，但实际上并没有注册为关闭的标签。<a class="ae mx" href="https://html.spec.whatwg.org/multipage/parsing.html#tokenization" rel="noopener ugc nofollow" target="_blank">这是有效的HTML </a>:没有匹配开始标记的结束标记不是有效的标记。</p><p id="5877" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，第18行永远不会触发。</p><h2 id="e0e2" class="nc mb it bd mc nd ne dn mg nf ng dp mk ld nh ni mm lh nj nk mo ll nl nm mq nn bi translated"><strong class="ak">修复</strong></h2><p id="6954" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们应该移除它吗？好了，现在，有了上面提到的代码，这一行实际上有了<em class="lq">一些实用程序</em>:如果开发人员为开始标签添加了一些处理程序(例如<code class="fe my mz na nb b">&lt;table&gt;</code>或<code class="fe my mz na nb b">&lt;td&gt;</code>，如果我们忽略添加结束标签处理程序，我们会注意到一个运行时错误。</p><p id="7e13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这还挺有用的。但是使用TypeScript的好处是，我们可以构造我们的代码，这样运行时保证就变成了编译时保证。</p><p id="bd65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，<a class="ae mx" href="https://github.com/google/schema-dts/pull/80" rel="noopener ugc nofollow" target="_blank">这个变化</a>使事情变得更好。以下是一个总结版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lz l"/></div></figure><p id="d773" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在开始和结束标签之间统一标签处理程序，用户不会忘记添加结束标签处理程序，反之亦然，因为编译器为处理标签定义了统一的接口。</p><p id="7f86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般来说，关于并行代码结构的断言和保证(例如，并行开关情况等。)和并行数据结构(例如并行列表或映射)是脆弱的。如果你有两个结构(代码或数据结构),需要就它们有什么元素达成一致，等等。从结构上重新安排它们可能会让你受益匪浅。谷歌的测试博客在其<a class="ae mx" href="https://testing.googleblog.com/2017/11/obsessed-with-primitives.html#docs-internal-guid-c44fb159-b745-02ec-a269-ec156b175826" rel="noopener ugc nofollow" target="_blank">代码健康:痴迷于原语？</a>插曲。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="bc62" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">揭开历史的选择和修复</h1><p id="c369" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们从未涉及的一些行看起来很明显像是针对<em class="lq">或</em>的边缘案例或修复。然而，边缘案例是什么或者我们为什么要这样做，往往并不清楚。</p><p id="fd1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理想情况下，当一个人引入对边缘情况的修正时，他们也会引入测试它们的测试。但是如果你跳过引入一个测试，你可能永远不会有时间去做它；直到你看到你的测试覆盖运行的结果。</p><p id="0fc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们看到一个未覆盖的行，这就成了一个很好的机会来跟踪<em class="lq">为什么添加了</em>并追溯性地为其添加测试。像<code class="fe my mz na nb b">git blame</code>和<code class="fe my mz na nb b">git log</code>这样的工具是及时查明边缘情况并找到相关提交消息的绝佳资源。</p><p id="b779" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我遇到了两种情况:<a class="ae mx" href="https://github.com/google/schema-dts/pull/73/commits/df8c97e199bc235cba76a008ab15b5cde8a24a97#diff-38d6d4505badf711e266526e2c572310" rel="noopener ugc nofollow" target="_blank">一个被跳过的解析器级术语</a>和一些<a class="ae mx" href="https://github.com/google/schema-dts/pull/74/commits/3beea7319520c8ddaa5956947c46563287a08f88#diff-55504ee5640737677ebdfceb255d5bd5" rel="noopener ugc nofollow" target="_blank">特定的枚举处理</a>。这两个问题看起来像是Schema.org 3.4中的大问题，后来都被悄悄地解决了。在这两种情况下，我都添加了注释来解释导致这种情况的三元组，在哪里可以找到它，并添加了测试来练习这种情况。太好了！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1832" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">简化代码的机会</h1><p id="ecbe" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">随着测试覆盖率接近100%，它开始成为代码不可及性分析的代理。虽然有时它会简单地指出测试中的缺点(这也是好的)，但有时它会指出传统静态分析工具检测不到的代码。这是因为测试覆盖率是在实际运行的代码上计算的，而不是对控制流图的一些检查。</p><p id="9bef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lz l"/></div></figure><p id="e48f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，测试没有覆盖第25行。这是有意义的——只有当<code class="fe my mz na nb b">parentNode</code>为空并且<code class="fe my mz na nb b">propLiteral</code>没有成员时，才会出现这一行。除了当<code class="fe my mz na nb b">propLiteral</code>没有父代时，它总是至少有一个成员(<code class="fe my mz na nb b">@id</code>)。</p><p id="cc08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于这个分支的另一个有趣的部分是，<code class="fe my mz na nb b">propLiteral</code>本身就是一个类型文字节点。因此，如果<code class="fe my mz na nb b">propLiteral.members.length === 0</code>，它将等同于第25行返回的节点—一个空类型的文字节点。</p><p id="7044" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，<a class="ae mx" href="https://github.com/google/schema-dts/pull/72/files#diff-0d6e1b40580e3ffa5cb049dd023d0610" rel="noopener ugc nofollow" target="_blank">修复</a>很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lz l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="22b0" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">对100的反思</h1><p id="22fb" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">虽然活到100岁需要做出一些牺牲，但这也让我能够:</p><ul class=""><li id="3967" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">修复了很多bug，</li><li id="a17a" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">捕捉并修复代码中的冗余，</li><li id="6bf8" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">关于我不可及的代码的原因，</li><li id="2dd8" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">在<em class="lq">错误</em>案例和<em class="lq">断言</em>之间仔细描绘，以及</li><li id="8e13" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">仔细考虑将运行时断言转换为编译时保证。</li></ul><p id="f3a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得吗？解决这个问题的一个方法是量化负面影响的危害，并将其与正面影响的收益进行比较。使用这种方法，对我来说，达到100显然是一个净积极的。</p><p id="53c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，真正的问题不仅仅是这些不利因素是否值得这些有利因素:而是如果没有这些不利因素，这些有利因素是否能够实现。我认为，这就是反对100%测试覆盖率的真正原因。</p><p id="bb07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为我可以通过查看测试覆盖率运行来实现这些缺点，而不必纠结于达到100%。也许大多数，我不确定。然而，我发现事实是:</p><ul class=""><li id="6124" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">沉迷于每一条未覆盖的线帮助我思考可达性，如果我只是看一眼未覆盖的线，我不会这样想；</li><li id="063e" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">上面概述的一些有趣的案例可能不会在红色海洋中被发现。</li></ul><p id="4fd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我来说，我对代码的许多有趣的反思和我对代码所做的许多有趣的更改，如果我没有达到95%的覆盖率，似乎很难发现和思考它们。</p><p id="d043" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终，我的感觉是100%的测试覆盖率绝对是至少要做一次的<em class="lq">有用的练习</em>。多做几次可能也是一个有用的练习。对于我和<code class="fe my mz na nb b">schema-dts</code>，我将保持100%的测试覆盖率。我怎么能不——毕竟，100只是一个非常非常好的数字！</p></div></div>    
</body>
</html>