<html>
<head>
<title>How to Compose Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript编写函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-compose-functions-in-javascript-33303859c3a0?source=collection_archive---------7-----------------------#2020-03-15">https://betterprogramming.pub/how-to-compose-functions-in-javascript-33303859c3a0?source=collection_archive---------7-----------------------#2020-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c131" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">组合事物的能力也适用于JavaScript</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d7a09f770de5e5a94720acf635c2414a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoRFYy75lPQaXcnKmwY-6Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@oscrse?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">奥斯卡·尼尔森</a>在<a class="ae ky" href="https://unsplash.com/s/photos/things?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="571b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript之所以成为我最喜欢的编写应用程序的语言，是因为它能够将如此多不同种类的函数组合在一起，最终形成一个工作程序。</p><p id="2ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们到处都能看到JavaScript代码，它们以不同的方式展示了这一点。</p><p id="9834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将函数组合在一起会变得非常有趣，尤其是在它们工作的时候。不幸的是，这并不总是一件容易的事情，因为编写组合代码必须没有任何错误，否则，它就不会运行。</p><p id="9675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，将函数等事物组合在一起是有规则的。</p><p id="affc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将回顾一些用JavaScript编写的例子，并讨论编写时需要牢记的重要概念。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5545" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">作曲是什么意思？</h1><p id="82b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="mz">组合</em>就是把不止一件东西组合起来，建造一个更大的东西。这是数学中的一个一般概念，将两个或更多的函数组合成一个全新的函数。</p><p id="148a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们大多数人在学校成长的过程中一直在处理这个概念，以类似于<code class="fe na nb nc nd b">f(g(x))</code>的形式，发音为“f of g of x”。</p><p id="4bb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，它可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ad84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说一下构成函数。当我们将函数组合在一起时，主要目标是将一个函数与另一个函数组合在一起，这样当两个函数组合在一起时，它会为我们提供一个更强大的函数，有助于产生我们想要的值。</p><p id="7cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们更喜欢组合函数有很多好的理由，比如减少代码和提供更方便的可重用代码。</p><p id="12d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，函数被认为是一级的，这意味着它们可以被传递，可以伪装成“值”，就像字符串、数字、布尔值、对象等。</p><p id="637d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的意思是允许函数<em class="mz">将其他函数作为参数</em>，甚至<em class="mz">可以返回函数</em>。这就是JavaScript成为一种非常强大的语言的原因，因为你可以把它们放在任何你想放的地方。</p><p id="1e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个将<code class="fe na nb nc nd b">'hello'</code>附加到字符串的函数的例子:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="9322" class="nk md it nd b gy nl nm l nn no">function append(str) {<br/>  return `hello ${str}<br/>}</span></pre><p id="120f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个函数并接收一个字符串很容易，如下所示:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="3ccf" class="nk md it nd b gy nl nm l nn no">const result = append('Gary') <em class="mz">// 'hello Gary'</em></span></pre><p id="66e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但正如我们刚刚了解到的，函数可以接受函数，所以让我们只使用第二个参数，并通过向函数添加一个函数参数来测试我们可以做什么:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="34a9" class="nk md it nd b gy nl nm l nn no">function append(str, modify) {<br/>  return `hello ${str}<br/>}</span></pre><p id="b056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好，我们现在为第二个论点留了一个开口，在这里做一些事情。仅仅通过这个简单的改变，它就增加了一些额外的功能，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在上面看到的，由于JavaScript的灵活性，学习如何用JavaScript编写函数是开发JavaScript应用程序时需要掌握的最重要的技能之一！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="edda" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么作曲很重要？</h1><p id="c9ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，人们为什么要编写函数有很多好的理由。</p><p id="1956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这个场景:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7dd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="353d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">doubleTheNums</code>函数负责查看一个对象，如果它是一个<code class="fe na nb nc nd b">number</code>类型，就加倍它的数值。</p><p id="45a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们要把它变成一个复合函数呢？让我们先来看看当前函数遇到的一些问题:</p><ol class=""><li id="104e" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">如果传入的对象是深度嵌套的，代码将会像树形结构一样笨拙地被下推。但是没人有时间做这种事。</li><li id="5c72" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果传入的对象是深度嵌套的，我们不必要地失去了宝贵的大脑能量，耗尽了命名内部变量的想法(<code class="fe na nb nc nd b">innerObjKey</code>、<code class="fe na nb nc nd b">innerObjKeyValue</code>可能导致<code class="fe na nb nc nd b">deeplyInnerObjKey</code>、<code class="fe na nb nc nd b">deeplyInnerObjKeyValue</code>、<code class="fe na nb nc nd b">innerInnerInnerObjKey</code>、<code class="fe na nb nc nd b">innerInnerInnerObjKeyValue</code>等)。)</li><li id="0549" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">随着时间的推移，代码变得重复。这可能会让我们困惑，没有人愿意被困惑。</li><li id="0e2b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">文件大小正在增加。</li></ol><p id="198a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢上帝，我们可以很容易地把函数扔来扔去，然后就到此为止:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="86f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚使用的技术叫做<em class="mz">递归</em>，这是一个非常有用的技术，可以解决我们之前提出的所有问题。</p><p id="4d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键是，我们可以在JavaScript中如此自由地使用函数，这一事实使得编写函数成为一个非常重要的话题！</p><p id="eec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果您是编程新手，那么这里值得注意的是，通过组合函数来创建更强大、更复杂的函数在任何编程语言中都是一种常见的实用工具。但是我们将把重点放在JavaScript上，因为显然这篇文章是关于JavaScript的。</p><p id="2940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您看过JavaScript库的源代码，那么您可能已经接触过大量在编写函数方面表现出色的代码示例。</p><p id="fa5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能还意识到，这些组合函数中的大多数是由更小的模块化函数组成的。</p><p id="4bd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一个什么都不做的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f4c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个<code class="fe na nb nc nd b">compose</code>函数，它采用一组函数来创建另一个函数，并以相同的方式使用它:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="ef80" class="nk md it nd b gy nl nm l nn no">const compose = (...fns) =&gt; (arg) =&gt;<br/>  fns.reduceRight((acc, fn) =&gt; (fn ? fn(acc) : acc), arg)</span></pre><p id="5955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以一次使用一堆无用的功能，同时仍然保持相同的功能！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界中，这很有用，因为您可能需要多个具有相同签名的函数来生成最终值。</p><p id="0d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果多个函数具有相同的签名，并且它们都将通过相同的值被调用，那么这就是使用composer的好时机:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后一个例子中，如果我们需要使用几个数学运算，我们决定组合多个数学运算符函数来产生最终值。</p><p id="5d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使它变得更方便了一点，因为最终，当我们在数字数组中循环时，我们还是会将相同的参数传递给函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dd0d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">注入与现有回调一起使用的回调</h1><p id="63a1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很好地使用组合函数的可能性是无限的。但是为了结束这篇文章，我们将回顾另一个有用的用例，以便您可以更好地理解如何组合函数来实现各种场景。</p><p id="18cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将看一个React应用程序的场景。</p><p id="193c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在构建一个按钮组件。它将有一个<code class="fe na nb nc nd b">onClick</code>事件监听器，这样当用户点击它时，它将接收事件并提醒被点击的<code class="fe na nb nc nd b">currentTarget</code>元素的<code class="fe na nb nc nd b">name</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="aed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果以后我们想从外部为同一个按钮添加一个额外的<code class="fe na nb nc nd b">onClick</code>处理程序，以获得额外的行为，该怎么办？通过这样做，我们可以轻松实现这一目标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="78f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这不是一个好的解决方案，因为如果我们有其他组件需要这个功能，我们必须重复这个过程。这也让后来的处理者很尴尬。</p><p id="6e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个函数组合多个<code class="fe na nb nc nd b">onClick</code>函数来创建一个<em class="mz">增强的</em> <code class="fe na nb nc nd b">onClick</code>函数可能是一个更好的主意，因为您可以在其他事件处理程序中重用它，如<code class="fe na nb nc nd b">onMouseOver</code>、<code class="fe na nb nc nd b">onMouseLeave</code>等。</p><p id="9470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个函数，我们可以用它来解决上一个问题:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="0368" class="nk md it nd b gy nl nm l nn no">function callAll(...fns) {<br/>  return (...args) =&gt; fns.forEach((fn) =&gt; fn &amp;&amp; fn(...args))<br/>}</span></pre><p id="1eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以用它来用一个优雅的解决方案替换我们丑陋的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="53e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它基本上实现了同样的事情。但是重要的是要记住，当你编写函数时，大多数时候你应该<em class="mz">意识到你正在编写的函数的签名</em>！</p><p id="e13a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在我们的<code class="fe na nb nc nd b">callAll</code>中，我们必须确保我们构建的函数都不可能被赋予与第一个参数完全不同的值。</p><p id="3281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们之前的<code class="fe na nb nc nd b">compose</code>示例中，这是因为每个函数的结果都作为第一个参数传递给了管道中下一个函数。</p><p id="7445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe na nb nc nd b">callAll</code>中，<code class="fe na nb nc nd b">.forEach</code>确保管道中的每个函数每次都接收到事件对象，因为根据定义，它不会向调用者返回任何东西，即使它试图返回一个。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="10d8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e52f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这篇文章到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>