<html>
<head>
<title>Use Multicall to Save Tons of API Requests to Your Blockchain Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Multicall将大量API请求保存到您的区块链节点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-multicall-to-save-tons-of-api-requests-to-your-blockchain-node-f759d09a8ef5?source=collection_archive---------4-----------------------#2021-10-18">https://betterprogramming.pub/use-multicall-to-save-tons-of-api-requests-to-your-blockchain-node-f759d09a8ef5?source=collection_archive---------4-----------------------#2021-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5741" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对Alchemy、Infura和其他节点进行更快、有效和免费的API调用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f491882cf9563d4f217135fb1805b610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBXsUMHgy8Z-dsW_48TYEA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="87aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用区块链做任何事情，你必须向区块链节点或服务发送请求，如<a class="ae lu" href="https://www.alchemy.com/" rel="noopener ugc nofollow" target="_blank"> Alchemy </a>和<a class="ae lu" href="https://infura.io/" rel="noopener ugc nofollow" target="_blank"> Infura </a>。</p><p id="87cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你在运行你自己的节点，你可以想做多少就做多少。但是，如果你使用第三方节点，你很快就会受到速率限制，或者你必须提高你的订阅。</p><p id="b21e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我想获得50个不同视图函数调用的值，我必须进行50次API调用，这不是很有效率，也不符合财务要求。这50个API调用可能就像一个卷曲:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="30cf" class="ma mb it lw b gy mc md l me mf">curl --request POST --url https://mainnet.infura.io/v3/PROJECT_ID --header 'Content-Type: application/json' --data '[{"jsonrpc": "2.0", "id": 1, "method": "eth_blockNumber", "params": []},]</span></pre><p id="79b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者，通过像Javascript或Python这样的编程语言</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5485" class="ma mb it lw b gy mc md l me mf">price = price_feed_contract.get_latest_price()</span></pre><p id="fc76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，让我们来学习一下如何在一次通话中用multicall实现更多的功能。</p><h1 id="6247" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">批量请求与多呼叫</h1><p id="8f60" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">现在，在我们进入多呼叫之前，我们需要讨论一下批处理请求。对区块链节点的批处理请求是在我们向区块链节点发送数据输入列表的时候。</p><p id="2293" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在幕后，这将看起来像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="176b" class="ma mb it lw b gy mc md l me mf">curl --request POST --url https://mainnet.infura.io/v3/PROJECT_ID --header 'Content-Type: application/json' --data '[<br/>{"jsonrpc": "2.0", "id": 1, "method": "eth_blockNumber", "params": []},<br/>{"jsonrpc": "2.0", "id": 2, "method": "eth_blockNumber", "params": []},<br/>{"jsonrpc": "2.0", "id": 3, "method": "eth_blockNumber", "params": []},<br/>{"jsonrpc": "2.0", "id": 4, "method": "eth_blockNumber", "params": []},]'</span></pre><p id="f957" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中每个<code class="fe nc nd ne lw b">eth_blockNumber</code>调用是在同一请求中进行的。这显然是一个伪示例，因为呼叫的块号是相同的。当我们使用像<code class="fe nc nd ne lw b">web3.py</code>、<code class="fe nc nd ne lw b">web3.js</code>和<code class="fe nc nd ne lw b">ethers.js</code>这样的包时，这可能在幕后发生。</p><p id="311b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在批处理请求有一些问题。很多节点都没有很好地处理它们，有些服务甚至不支持它们。如果您发出太多的批处理请求，您可能会无限期地挂起，没有返回数据，或者阻塞您的Linux虚拟机。</p><p id="6a52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是多呼叫发挥作用的地方。</p><p id="c878" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们调用链上契约的一个函数，这个函数接受无限的参数，我们定义我们希望契约调用的函数，而不是像这种大批量的请求。这意味着我们回到打一个电话。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2ef9" class="ma mb it lw b gy mc md l me mf">curl --request POST --url https://mainnet.infura.io/v3/PROJECT_ID --header 'Content-Type: application/json' --data '[{"jsonrpc": "2.0", "id": 1, "method": "eth_blockNumber", "params": []},]</span></pre><p id="a67c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不同之处在于，链上函数的返回才是我们真正要寻找的。</p><h1 id="e1ec" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">多呼叫</h1><p id="9937" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">使用multicall的最流行的合同之一是Uniswap multicall合同。</p><p id="9d66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个契约有像<code class="fe nc nd ne lw b">tryAggregate</code>这样的函数，它允许我们传入一系列编码函数和函数输入来调用区块链上的任何其他函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6c19" class="ma mb it lw b gy mc md l me mf">function tryAggregate(bool requireSuccess, Call[] memory calls) public returns (Result[] memory returnData) {<br/>        returnData = new Result[](calls.length);<br/>        for(uint256 i = 0; i &lt; calls.length; i++) {<br/>            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);</span><span id="de15" class="ma mb it lw b gy nf md l me mf">if (requireSuccess) {<br/>                require(success, "Multicall2 aggregate: call failed");<br/>            }</span><span id="b184" class="ma mb it lw b gy nf md l me mf">returnData[i] = Result(success, ret);<br/>        }<br/>    }</span></pre><p id="f4c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它接受一个数组<code class="fe nc nd ne lw b">Call</code>作为输入，该数组有一个编码地址、函数选择器和输入参数。然后<code class="fe nc nd ne lw b">tryAggregate</code>简单地遍历这个列表，调用每个契约。</p><p id="efe7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嘣！我们现在基本上将一系列函数调用打包成一个函数调用，减少了API调用，为我们节省了一大笔钱！</p><h1 id="1541" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Brownie和JavaScript中的多调用</h1><p id="2a07" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated"><code class="fe nc nd ne lw b">Brownie</code>(一个流行的Pythonic智能契约开发框架)内置了我们可以使用的多调用功能。JavaScript也有一些不错的包。我们有一个<a class="ae lu" href="https://github.com/PatrickAlphaC/multicall" rel="noopener ugc nofollow" target="_blank">布朗尼示例</a>和<a class="ae lu" href="https://github.com/PatrickAlphaC/multicall-js" rel="noopener ugc nofollow" target="_blank"> JavaScript示例</a>供您自己探索和尝试！</p><p id="7f0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们想要获得一个<a class="ae lu" href="https://docs.chain.link/docs/historical-price-data/" rel="noopener ugc nofollow" target="_blank"> Chainlink数据馈送</a>的最后50个回合，在没有multicall的情况下，我们可能必须这样做:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7092" class="ma mb it lw b gy mc md l me mf">rounds = []<br/>for round_id in range(latest_round, latest_round - 50, -1):<br/>  round_data = price_feed.getRoundData(round_id)<br/>  rounds.append(round_data)</span></pre><p id="6682" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次我们调用<code class="fe nc nd ne lw b">price_feed.getRoundData</code>都是一个API调用。</p><p id="4cfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了用<code class="fe nc nd ne lw b">brownie</code>做到这一点，我们只需要添加2行代码！</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="627a" class="ma mb it lw b gy mc md l me mf">brownie.multicall(address="0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696")<br/>with brownie.multicall:<br/>  for round_id in range(latest_round, latest_round - 50, -1):<br/>    round_data = price_feed.getRoundData(round_id)<br/>    rounds.append(round_data)</span></pre><p id="e85c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们只需要选择multicall契约地址(在本例中，我们使用Uniswap V3版本)，然后在我们的<code class="fe nc nd ne lw b">with brownie.multicall</code>中添加我们想要进行的所有API调用。</p><p id="c446" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后嘣！我们现在可以做一些很棒的事情，比如用一个对区块链的API调用来绘制最后50轮的链接数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/963f8af4ed81c796228384a9f7b235c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oiwIQwBPtnQFDzZwkW0v2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用<a class="ae lu" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>绘制ETH / USD图</p></figure><p id="230d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！现在你在智能合同世界里更聪明了一步，希望这能为你省下一些钱，并为你打开许多扇门！</p><p id="018c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建多呼叫请求的完整源代码可以在这个<a class="ae lu" href="https://github.com/PatrickAlphaC/multicall" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到。</p><p id="c715" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你也可以观看这个概念的视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多呼叫</p></figure><p id="1300" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。</p></div></div>    
</body>
</html>