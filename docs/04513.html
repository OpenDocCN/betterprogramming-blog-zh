<html>
<head>
<title>Naming Conventions in Go: Short but Descriptive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的命名约定:简短但有描述性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/naming-conventions-in-go-short-but-descriptive-1fa7c6d2f32a?source=collection_archive---------0-----------------------#2020-04-18">https://betterprogramming.pub/naming-conventions-in-go-short-but-descriptive-1fa7c6d2f32a?source=collection_archive---------0-----------------------#2020-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cd4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">成文和不成文的规则</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15ffb974a74bf05ea8edd6d18ea4204f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*17gynzVHHT-0emUo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><blockquote class="kz"><p id="1d0e" class="la lb it bd lc ld le lf lg lh li lj dk translated">"计算机科学中只有两个难题:缓存失效和事物命名."— <a class="ae ky" href="https://martinfowler.com/bliki/TwoHardThings.html" rel="noopener ugc nofollow" target="_blank">菲尔·卡尔顿</a></p></blockquote><p id="79b3" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated">这不是一个有趣的笑话。写作容易，读书痛苦。您是否曾经发现自己想知道某个变量指的是什么，或者某个包的目的是什么？这就是为什么我们需要规则和惯例。</p><p id="4601" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">但是，虽然习俗是为了让生活更容易，但它们可能被高估和滥用。为命名设定适当的惯例和规则是非常重要的，但是盲目地遵循它们是有害的。</p><p id="c377" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">在本文中，我将介绍<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>(成文和不成文的规则)中一些重要的变量命名约定，以及它们是如何被滥用的——尤其是在短变量命名的情况下。包和文件的命名以及项目结构不在本文的讨论范围之内，因为它们值得另写一篇文章。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9527" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">围棋中的成文规则</h1><p id="cd30" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">像任何其他编程语言一样，Go也有命名规则。此外，命名具有语义效果，它决定了包外的<strong class="lm iu"> </strong>标识符的<strong class="lm iu"> </strong>。</p><h2 id="77d4" class="np mt it bd mu nq nr dn my ns nt dp nc lt nu nv ne lx nw nx ng mb ny nz ni oa bi translated">混合瓶盖</h2><p id="fdb2" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">Go中的约定是使用<code class="fe ob oc od oe b">MixedCaps</code>或<code class="fe ob oc od oe b">mixedCaps</code>(简单的camelCase)而不是下划线来写多单词名称。如果标识符需要在包外可见，它的第一个字符应该是大写的。如果你不打算在另一个包中使用它，你可以放心地坚持使用<code class="fe ob oc od oe b">mixedCaps</code>。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="417b" class="np mt it oe b gy oj ok l ol om">package awesome</span><span id="80a5" class="np mt it oe b gy on ok l ol om">type Awesomeness struct {<br/> <br/>}</span><span id="66a2" class="np mt it oe b gy on ok l ol om">// Do is an exported method and is accessible in other packages<br/>func (a Awesomeness) Do() string {<br/> return a.doMagic("Awesome")<br/>}</span><span id="9139" class="np mt it oe b gy on ok l ol om">// doMagic is where magic happens and only visible inside awesome <br/>func (a Awesomeness) doMagic(input string) string {<br/> return input<br/>}</span></pre><p id="d49e" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">如果试图从外部调用<code class="fe ob oc od oe b">doMagic</code>，将会得到一个编译时错误。</p><h2 id="49b6" class="np mt it bd mu nq nr dn my ns nt dp nc lt nu nv ne lx nw nx ng mb ny nz ni oa bi translated">接口名称</h2><blockquote class="oo op oq"><p id="383a" class="lk ll mk lm b ln mf ju lp lq mg jx ls or mh lv lw os mi lz ma ot mj md me lj im bi translated">按照惯例，单方法接口由方法名加上一个-er后缀或类似的修饰来命名，以构造一个代理名词:<code class="fe ob oc od oe b">Reader</code>、<code class="fe ob oc od oe b">Writer</code>、<code class="fe ob oc od oe b">Formatter</code>、<code class="fe ob oc od oe b">CloseNotifier</code>等— <a class="ae ky" href="https://golang.org/doc/effective_go.html" rel="noopener ugc nofollow" target="_blank"> Go的官方文档</a></p></blockquote><p id="d1a0" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">经验法则是<code class="fe ob oc od oe b">MethodName + er = InterfaceName</code>。这里棘手的部分是当你有一个不止一个方法的接口时。遵循惯例命名并不总是显而易见的。我应该用一个方法把接口分成多个接口吗？我觉得这是主观决定，要看案情。</p><h2 id="a26a" class="np mt it bd mu nq nr dn my ns nt dp nc lt nu nv ne lx nw nx ng mb ny nz ni oa bi translated">吸气剂</h2><p id="450f" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">在<a class="ae ky" href="https://golang.org/doc/effective_go.html#Getters" rel="noopener ugc nofollow" target="_blank">官方文档</a>中提到，Go没有自动支持setters和getters，但也没有禁止。它只是有一些规则:</p><blockquote class="oo op oq"><p id="5d56" class="lk ll mk lm b ln mf ju lp lq mg jx ls or mh lv lw os mi lz ma ot mj md me lj im bi translated">“自己提供getter和setter没有错，这样做通常是合适的，但是将<code class="fe ob oc od oe b">Get</code>放在getter的名称中既不习惯也没有必要。”</p></blockquote><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="8fe8" class="np mt it oe b gy oj ok l ol om">owner := obj.Owner()<br/>if owner != user {<br/>    obj.SetOwner(user)<br/>}</span></pre><p id="4b72" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">但是值得一提的是，如果setter不执行任何特殊的逻辑，最好只导出字段，去掉setter和getter方法。如果你是oop的拥护者，这可能听起来很奇怪。但事实并非如此。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d073" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">围棋中的潜规则</h1><p id="a9ae" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">有些规则没有正式记录，但它们在社区中广泛传播。</p><h2 id="59e9" class="np mt it bd mu nq nr dn my ns nt dp nc lt nu nv ne lx nw nx ng mb ny nz ni oa bi translated">较短的变量名</h2><p id="feff" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">Go社区提倡使用更短的描述性变量，但我认为这种特定的约定被误用了。不知何故，忘记它的描述部分是很常见的。一个描述性的名字可以让读者在看到它之前就明白它是关于什么的。</p><blockquote class="kz"><p id="d6e0" class="la lb it bd lc ld ou ov ow ox oy lj dk translated">"程序必须是为人们阅读而写的，并且只是附带地为机器执行而写的."哈罗德·艾贝尔森</p></blockquote><ul class=""><li id="1387" class="oz pa it lm b ln lo lq lr lt pb lx pc mb pd lj pe pf pg ph bi translated">单字母标识符:<strong class="lm iu"> </strong>这特别用于范围有限的局部变量。我们都同意，我们不需要<code class="fe ob oc od oe b">index</code>或<code class="fe ob oc od oe b">idx</code>来理解它是一个增量。当仅限于循环范围时，使用单字母标识符是常见的，也是推荐的。</li></ul><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="d859" class="np mt it oe b gy oj ok l ol om">for i := 0; i &lt; len(pods); i++ {<br/>   //<br/>}<br/>...<br/>for _, p := range pods {<br/>  //<br/>}</span></pre><ul class=""><li id="3010" class="oz pa it lm b ln mf lq mg lt pi lx pj mb pk lj pe pf pg ph bi translated">简写名称:<strong class="lm iu"> S </strong>如果可能的话，推荐使用简写名称<strong class="lm iu"> </strong>，只要它们对于第一次阅读代码的人来说容易理解。使用范围越广，越需要描述性。</li></ul><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="f1b8" class="np mt it oe b gy oj ok l ol om">pid // Bad (does it refer to podID or personID or productID?)<br/>spec // good (refers to Specification)<br/>addr // good (refers to Address)</span></pre><h2 id="b6a7" class="np mt it bd mu nq nr dn my ns nt dp nc lt nu nv ne lx nw nx ng mb ny nz ni oa bi translated">唯一的名称</h2><p id="6f3f" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">这是关于缩写词如API，HTTP，<strong class="lm iu"> </strong>等。<strong class="lm iu"> </strong>或者ID、DB之类的名字。<strong class="lm iu"> </strong>按照惯例，我们保留这些词的原始形式:</p><ul class=""><li id="5902" class="oz pa it lm b ln mf lq mg lt pi lx pj mb pk lj pe pf pg ph bi translated"><code class="fe ob oc od oe b">userID</code>而不是<code class="fe ob oc od oe b">userId</code></li><li id="43f8" class="oz pa it lm b ln pl lq pm lt pn lx po mb pp lj pe pf pg ph bi translated"><code class="fe ob oc od oe b">productAPI</code>而不是<code class="fe ob oc od oe b">productApi</code></li></ul><h2 id="f0ff" class="np mt it bd mu nq nr dn my ns nt dp nc lt nu nv ne lx nw nx ng mb ny nz ni oa bi translated">线长度</h2><p id="bcd5" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">Go中没有固定的行长度，但是总是建议避免长行。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="2cca" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="7077" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">我试图总结Go中常见的命名规则，以及我们何时以及在何种程度上可以应用它们。我还解释了Go中较短命名背后的主要思想，即在简洁和描述性之间找到平衡。</p><p id="d0c8" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me lj im bi translated">习俗会指引你，而不是阻碍你。因此，只要感觉合适，并且仍然服务于一般目的，您就应该放心地打破它们。</p></div></div>    
</body>
</html>