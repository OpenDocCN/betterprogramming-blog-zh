<html>
<head>
<title>A Deep Dive Into Functions in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Swift功能的深入探究</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functions-in-swift-5d8ee85f2de6?source=collection_archive---------9-----------------------#2021-03-09">https://betterprogramming.pub/functions-in-swift-5d8ee85f2de6?source=collection_archive---------9-----------------------#2021-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8db0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从闭包到高阶函数，我们已经涵盖了所有内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/38178387f2bf890ea26db7faa1372e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HHKAxzkTPlnG864K"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">麦克斯韦·纳尔逊</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，函数是任何编程语言的基本组成部分，也是您开始编码时首先要学习的东西之一。在这篇文章中，我们将通过基本知识，然后也深入研究他们的一些细节。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ec2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基础:函数和闭包</h1><p id="c5a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数和闭包都是Swift提供的构造，用于在其内部执行一组任务。它们接受执行任务可能需要的0个或多个参数，并且可以选择返回值。</p><h2 id="ff41" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">功能</h2><p id="c290" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从函数开始，因为它们更容易理解。</p><p id="beb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个函数有五个部分:</p><ol class=""><li id="28f7" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">关键词<code class="fe nu nv nw nx b">func</code>。这个关键字表示一个函数定义的开始。</li><li id="2b29" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">函数的名称。</li><li id="c4cd" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">参数(命名或未命名)</li><li id="c1d9" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">函数的主体。</li><li id="ebf7" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">返回类型后跟一个<code class="fe nu nv nw nx b">-&gt;</code>例如:<code class="fe nu nv nw nx b">-&gt; String</code></li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="c5b6" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">输入参数</h2><p id="f11f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">定义在函数中声明和使用参数的不同方式的最好方法是遵循代码。</p><ol class=""><li id="e9a9" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><strong class="lb iu">命名参数</strong></li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="896d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。未命名的参数</strong></p><p id="35ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在函数签名中的参数名称前添加一个<code class="fe nu nv nw nx b">_</code>，它将成为一个未命名的参数，这可以确保您在调用函数时不必编写参数名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。可变参数</strong></p><p id="b9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这适用于您不知道可以传递给函数的输入数量的情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="f870" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><code class="fe nu nv nw nx b">inout</code>参数</h2><p id="7fcf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数签名中的参数总是<code class="fe nu nv nw nx b">let</code>参数，因此在函数内部修改它们会导致编译时错误。</p><p id="a2b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够修改函数中的参数值，您需要将它们标记为<code class="fe nu nv nw nx b">inout</code>参数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b1d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您<strong class="lb iu">不能</strong>将<code class="fe nu nv nw nx b">let</code>变量作为<code class="fe nu nv nw nx b">inout</code>参数传递，因为它们不能被修改。</p><p id="00c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">inout</code>的工作原理是<code class="fe nu nv nw nx b">copy-in copy-out</code>，也就是说输入的参数首先被复制到一个新的变量中(通过调用它的getter)，然后在函数结束时新的值被设置到参数中(通过调用它的setter)。如果它们的<code class="fe nu nv nw nx b">inout</code>参数原来是一个引用类型，引用本身就被直接修改了。</p><h2 id="affc" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">返回</h2><p id="2ce2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以使用<code class="fe nu nv nw nx b">return</code>关键字从函数中返回值。你需要知道三种类型的<code class="fe nu nv nw nx b">return</code>:</p><p id="b360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。不返回:</strong>Swift中的每个函数本质上都返回一些东西。对于没有显式返回任何内容的函数，该函数返回一个空元组。这个元组被称为类型<code class="fe nu nv nw nx b">Void</code>。您不能显式返回<code class="fe nu nv nw nx b">Void</code>,因为它是一个类型，但是如果您需要的话，您总是可以返回一个空元组——或者更好的是，直接省略那个返回语句！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="fc78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。返回单个或多个值:</strong>只需在要返回的值之前添加<code class="fe nu nv nw nx b">return</code>关键字，就可以返回单个值</p><p id="9a62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在返回之前，需要将多个值包含在一个元组中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。隐式返回:</strong>这是一种特殊类型的<code class="fe nu nv nw nx b">return</code>，在这里您不必编写<code class="fe nu nv nw nx b">return</code>关键字。</p><p id="396e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们只在单一表达式函数中起作用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="1449" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">作为一等公民的职能</h2><p id="3150" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Swift中，函数是语言的一等公民。这基本上意味着函数可以像语言中的其他值一样使用。它们可以存储在变量中，并像其他任何对象一样传递。</p><p id="5a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以引用这些函数。</p><p id="ab29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。创建对实例函数的引用。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="ea9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对实例函数的这种类型的引用最好如下例所示使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="228e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。创建对类/结构的函数的引用:</strong>每当你引用一个类或结构的函数作为变量时，对该函数的静态引用就存储在该变量中。这意味着如果你想通过变量调用那个函数，你也必须传入那个特定类/结构的实例。通过一个例子可以更容易地形象化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看着上面的代码，你可能会问“我为什么要这么做？”。答案是，你可能不会！虽然在一些情况下，它可以使代码更容易阅读，但您可能需要编写自己的扩展来使代码更容易阅读。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift/" rel="noopener ugc nofollow" target="_blank">在这里阅读更多</a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1386" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关闭</h1><p id="2975" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">闭包也是一个接受参数并在其中执行一些处理的构造。</p><p id="7ed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义闭包的方式如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b3c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结尾有四个部分:</p><ol class=""><li id="1998" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">方括号<code class="fe nu nv nw nx b">[]</code>中指定的捕获列表——捕获列表本质上是一个变量列表，您可以将它关联为一个闭包将引用的数组。如果管理不当，它是内存泄漏的主要来源。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-look-into-automatic-reference-counting-b17e9539d34f">阅读此处了解更多详情。</a></li><li id="7560" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">括号内的参数列表<code class="fe nu nv nw nx b">()</code>。闭包的参数总是未命名的。</li><li id="f8f4" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated"><code class="fe nu nv nw nx b">in</code>关键词</li><li id="7f67" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">闭包的主体</li></ol><h2 id="a366" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><code class="fe nu nv nw nx b">@escaping</code> vs <code class="fe nu nv nw nx b">@nonescaping</code>关闭</h2><p id="605d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些关键字用于定义闭包的生存期以及它们在其中捕获的对象。</p><p id="f715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="of">默认情况下，作为参数传递给函数的闭包是@nonescaping。</em></p><p id="d366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">nonescaping</code>闭包告诉编译器闭包将在函数本身中执行，并且一旦函数执行完成就可以被销毁(顺便说一下，销毁只是意味着对闭包的引用将减1，因此如果你有对闭包的任何其他引用，它们仍将被维护，否则它将变成<code class="fe nu nv nw nx b">nil</code></p><p id="9530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">escaping</code>闭包是即使在函数执行完成后也可能被保留的闭包。这些主要在闭包的异步执行期间使用，这时您必须不断传递闭包。这里有一个<code class="fe nu nv nw nx b">escaping</code>闭包用法的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="415b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经有了如何定义函数和闭包的基础知识，让我们更仔细地看看它们，看看它们的区别。</p><h2 id="173d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">函数和闭包的区别</h2><ul class=""><li id="f5d8" class="nl nm it lb b lc mu lf mv li og lm oh lq oi lu oj nr ns nt bi translated">函数参数可以被命名，而闭包参数总是不被命名。</li><li id="161f" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu oj nr ns nt bi translated">函数有自己的隐式名称，而闭包则没有。您可以使用您选择的任何变量名来引用它们。</li><li id="b188" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu oj nr ns nt bi translated">闭包可以捕获带有<code class="fe nu nv nw nx b">strong</code>、<code class="fe nu nv nw nx b">weak</code>或<code class="fe nu nv nw nx b">unonwed</code>关键字的值，而函数不捕获值。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><ul class=""><li id="caab" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu oj nr ns nt bi translated">如果函数本身在闭包中被捕获，那么它们可以捕获值。这意味着，如果在一个函数中使用了一个<code class="fe nu nv nw nx b">object</code>，并且这个函数在闭包中被强捕获，那么这个函数会捕获那个<code class="fe nu nv nw nx b">object</code>，即使你把它变成了<code class="fe nu nv nw nx b">nil</code>。下面的例子应该有助于说明这一点:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h1 id="0927" class="mc md it bd me mf ok mh mi mj ol ml mm jz om ka mo kc on kd mq kf oo kg ms mt bi translated">高阶函数</h1><p id="74eb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">高阶函数(HOF)是接受其他函数作为参数，或者返回一个函数，或者两者兼有的函数。它们通常看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="021c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在日常生活中可能会用到的一些最常见的Hof例子有<code class="fe nu nv nw nx b">filter</code>、<code class="fe nu nv nw nx b">map</code>、<code class="fe nu nv nw nx b">reduce</code>等。我会留下一些常见Hof的链接，你可能会在面试中被问到，但现在，我们将专注于上面的三个。理解它们的最好方法是定义它们，然后实现它们。</p><h2 id="a0dd" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/swift/sequence/3018365-filter" rel="noopener ugc nofollow" target="_blank">过滤器</a></h2><p id="ec63" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个<code class="fe nu nv nw nx b">filter</code>方法"<strong class="lb iu"> <em class="of">过滤掉满足特定标准的</em> </strong>"元素。</p><p id="8daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是查找超过五个字符的名称的代码片段。它展示了如何使用实际的<code class="fe nu nv nw nx b">filter</code>函数以及我们的方法实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://developer.apple.com/documentation/swift/sequence/3018365-filter" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/swift/sequence/3018365-filter</a></p></figure><h2 id="6e4c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/swift/array/3017522-map" rel="noopener ugc nofollow" target="_blank">地图</a></h2><p id="2995" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nu nv nw nx b">map</code>方法<em class="of">使用转换函数转换</em>序列的每个元素，并返回转换后的元素列表。</p><p id="f249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着写一个映射转换函数，让数组中的所有字符串都大写，然后实现我们自己的映射来做同样的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="bc83" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/swift/array/2298686-reduce" rel="noopener ugc nofollow" target="_blank">减少</a></h2><p id="8bd8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个<code class="fe nu nv nw nx b">reduce</code>方法将一个序列简化为任何输出类型，可能是也可能不是一个序列。虽然它通常用于将序列的元素相互组合以得到一个结果(因为如果您希望您的输出只是另一个序列，那么您总是可以使用<code class="fe nu nv nw nx b">map</code>)。</p><p id="297f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个有点棘手，很多人讨厌它，因为它冗长，而且在大多数情况下你可以用一个<code class="fe nu nv nw nx b">forEach</code>块来代替<code class="fe nu nv nw nx b">reduce</code>。不过，我们还是讨论一下吧。</p><p id="109f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="of">其背后的一般思想是将</em> <strong class="lb iu"> <em class="of">可选地</em> </strong> <em class="of"> </em> <strong class="lb iu"> <em class="of">变换</em> </strong> <em class="of">就像</em> <code class="fe nu nv nw nx b"><em class="of">map</em></code> <em class="of">然后</em> <strong class="lb iu"> <em class="of">将</em> </strong> <em class="of">那些映射(或未映射)的元素</em> <strong class="lb iu"> <em class="of">组合成单个值</em> </strong> <em class="of">(在一个方法中完成的两步过程</em></p><p id="dd6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想从一组<code class="fe nu nv nw nx b">Item</code>中找出购物车的总价值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="43ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以使用其他类似的Hof，比如<code class="fe nu nv nw nx b">compactMap</code>、<code class="fe nu nv nw nx b">sorted</code>等。一定要尝试并实现它们，以便更好地理解如何在函数签名中使用闭包作为参数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c6ca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="340d" class="nl nm it lb b lc mu lf mv li og lm oh lq oi lu oj nr ns nt bi translated"><a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html" rel="noopener ugc nofollow" target="_blank"> Swift功能指南</a></li><li id="4d2b" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu oj nr ns nt bi translated"><a class="ae ky" href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID545" rel="noopener ugc nofollow" target="_blank"> Swift文档为</a> <code class="fe nu nv nw nx b"><a class="ae ky" href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID545" rel="noopener ugc nofollow" target="_blank">inout</a></code> <a class="ae ky" href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID545" rel="noopener ugc nofollow" target="_blank">参数</a></li><li id="e70c" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu oj nr ns nt bi translated"><a class="ae ky" href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift/" rel="noopener ugc nofollow" target="_blank">作为一等公民的功能—Sundell Swift</a></li></ul></div></div>    
</body>
</html>