<html>
<head>
<title>Scope vs. Context in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的范围与上下文</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scope-vs-context-in-javascript-b31818f58558?source=collection_archive---------1-----------------------#2019-06-03">https://betterprogramming.pub/scope-vs-context-in-javascript-b31818f58558?source=collection_archive---------1-----------------------#2019-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="31aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">范围和上下文可能看起来相似，但它们实际上有非常不同的功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d12427488e94933abdd002e1fe84509f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_8eneSbaIjTQpKlV-Y6hQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jpvalery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jp瓦列里</a>在<a class="ae kv" href="https://unsplash.com/search/photos/scope?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，计算机代码看起来像是一个深奥的击键组合，长达数百甚至数千行，没有太多的组织或凝聚力。实际上，代码是一个高度组织化和层次化的系统，其中的进程是同步的，但又是分离的。</p><p id="4083" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单的原则支配着计算机如何构造和解释代码。这些原则建立在彼此的基础上，反复组合以创建更复杂和有效的应用程序。这篇文章将特别描述其中的两个原则:<strong class="ky ir">范围</strong>和<strong class="ky ir">上下文。虽然这两个原则在其他编码语言中无疑是重要的，但我将特别关注它们在JavaScript中最基本的行为。</strong></p><p id="307d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">范围和上下文可能看起来非常相似，如果你不时把它们弄混，<em class="ls">不要感到孤独</em>。像编码的许多方面一样，范围和上下文可能很难可视化，并且可能阻碍JavaScript新手尽可能快地提高他们的能力。</p><p id="721c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种混淆的一个可能原因是，范围和上下文都指变量或某些关键字何时变得相关，以及它们被调用时具体指的是什么。让我们先仔细看看scope。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="da9c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">范围</strong></h1><p id="7e55" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">用最简单的术语来说，作用域有两个层次:<strong class="ky ir">全局作用域</strong>和<strong class="ky ir">局部作用域</strong>。全局作用域是指在任何地方都可以访问的变量，因为它们是在任何单独的函数或方法之外声明的——通常在文件的顶部。他们存在于全球空间，随时准备被召唤。下面的第一个例子涉及<em class="ls">全局范围</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/63319a9d50e9af97aa7bad01b09334b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mxyY1uQDid48yH1yJ0QtA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">全局范围变量的示例</p></figure><p id="1edf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">局部作用域指的是在其函数边界内可访问的变量。在这个例子中，我们在文件的顶部有变量<code class="fe my mz na nb b">dog</code>的初始声明，它被赋给字符串“goodBoy”紧接着下面，我们控制台. log了<code class="fe my mz na nb b">dog</code>变量。</p><p id="aebf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如所料，第一张<code class="fe my mz na nb b">console.log</code>印出了“goodBoy”，如图片右侧所示。然后，我们有一个函数<code class="fe my mz na nb b">showScopeExample()</code>，它将我们的<code class="fe my mz na nb b">dog</code>变量重新分配给字符串“badDog”</p><p id="6b36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数立即被调用，但是当我们在第10行第二次使用<code class="fe my mz na nb b">console.log</code>“dog”时，它仍然显示为“goodBoy”尽管第二个<code class="fe my mz na nb b">console.log</code>发生在我们在函数内部重新分配变量之后，但是<code class="fe my mz na nb b">dog</code>变量目前还不能作为“badDog”返回这是故意的。</p><p id="a04d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe my mz na nb b">showScopeExample()</code>中对<code class="fe my mz na nb b">dog</code>的重新声明是在<em class="ls">本地</em>作用域内。最简单的方法就是看它的位置。重声明位于左花括号和右花括号之间，它们是这些变量相关性的障碍。</p><p id="9bf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">限制在函数内部声明的变量的可访问性允许我们重用应用于代码不同部分的变量名。局部作用域的变量还可以防止我们的代码不必要地让数十或数百个全局变量在全局空间中浮动。通过将对变量的访问限制在需要它们的地方，在我们的JavaScript中进行适当的抽象也是一个很好的实践。让我们看一个稍微不同的例子…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/cc0e30ac078eed9d10a635521efd4307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bsf2XoRU6UVwTUbWnJy0YQ.png"/></div></div></figure><p id="3c21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们改变的只是第二个<code class="fe my mz na nb b">console.log</code>的位置，它现在在<code class="fe my mz na nb b">showScopeExample()</code>函数的边界内。如右侧控制台所示，第一个<code class="fe my mz na nb b">console.log</code>仍如预期打印“goodBoy”。</p><p id="2191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，当我们调用<code class="fe my mz na nb b">showScopeExample()</code>(可怜的小狗)时，我们的第二个<code class="fe my mz na nb b">console.log</code>现在打印“badDog”。这是因为我们的第二个<code class="fe my mz na nb b">console.log</code>现在位于花括号的边界内，它将打印位于相同范围内的信息。</p><p id="851f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，第三个<code class="fe my mz na nb b">console.log</code>返回到印刷“好孩子”这也是因为它无法访问本地重新分配，而是求助于初始声明。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e28a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">语境</h1><p id="28ec" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">JavaScript中的上下文是另一个容易混淆的主题。它主要指关键字<code class="fe my mz na nb b">this</code>的使用。<code class="fe my mz na nb b">this</code>的值取决于它被调用的位置。</p><p id="9ed2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在全局空间中调用<code class="fe my mz na nb b">this</code>将返回整个窗口对象。这是因为窗口对象是我们编写的所有代码的起点。试一试，你可能会得到这样的回应…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/869ee3a5dd0f9e69db11a26256132796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZaED7VA0iWcIPqtEpr0Hug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“This”指的是窗口对象——我们代码的最外层上下文</p></figure><p id="fce8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到的回报就是<code class="fe my mz na nb b">window</code> <em class="ls"> </em>对象<em class="ls">无尽的白色文字。</em><code class="fe my mz na nb b">this</code>的<strong class="ky ir">第一个</strong>规则是，默认情况下是指窗口对象。如果有机会，您应该在全局上下文中探索调用<code class="fe my mz na nb b">this</code>返回的窗口对象。</p><p id="b7fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果我们在全球背景之外的地方援引<code class="fe my mz na nb b">this</code>，会发生什么呢？如果我们在一个新对象的上下文中调用<code class="fe my mz na nb b">this</code>，它将返回该对象，就像它返回整个窗口对象一样。让我们看一个简单的例子，然后在此基础上进行构建。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/76dec7840b069934a9adebc94a861b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZviZIX9qGwnT-G7_Z9DKQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">现在“this”指的是新的context obj——一个比以前更有限的上下文</p></figure><p id="60a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们已经创建了一个新的对象，命名为<code class="fe my mz na nb b">newContextObj</code>。当我们调用方法<code class="fe my mz na nb b">invokeThisInNewContext()</code> <em class="ls"> </em>时，它返回整个<code class="fe my mz na nb b">newContextObj</code>。</p><p id="3b55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与我们第一个例子中它返回窗口对象的时候是一样的。唯一不同的是，window对象是一个很大很复杂的对象，而我们的<code class="fe my mz na nb b">newContextObj</code>很小很简单。<code class="fe my mz na nb b">this</code>的<strong class="ky ir">第二个</strong>规则是，在一个对象的上下文中调用时，<code class="fe my mz na nb b">this</code> <em class="ls"> </em>会引用那个对象<em class="ls">。</em></p><p id="f9b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe my mz na nb b">this</code>的<strong class="ky ir">第三</strong>规则稍微复杂一点。在JavaScript中，我们使用<em class="ls">类</em>来创建共享属性的对象的多个实例，即使这些属性的值可能不同。</p><p id="fd7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们可以有一个产生<code class="fe my mz na nb b">car</code>对象实例的类。尽管事实上所有的汽车都有大小、容量和发动机类型，但这三样东西可能因车而异。下面是在<code class="fe my mz na nb b">ContextObj</code>实例的上下文中调用<code class="fe my mz na nb b">this</code>的例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/dbd74c9ef8ec2b6620b9e1736b5281ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSLvYmGAtSFpJRdRD3PlPg.png"/></div></div></figure><p id="bc1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在上面的例子中看到的是对我们的<code class="fe my mz na nb b">ContextObj</code>实例的<code class="fe my mz na nb b">whereIsThis()</code>方法的调用。在第三个也是最后一个例子中，关键字<code class="fe my mz na nb b">this</code>指的是这个特定的<code class="fe my mz na nb b">ContextObj</code> <em class="ls">、</em>实例，不管我们的代码中有多少个<code class="fe my mz na nb b">ContextObj</code>实例。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3c3f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="5ddd" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这三个例子试图用最基本的形式来总结<code class="fe my mz na nb b">this</code>，你会在自己的经历中发现<em class="ls">这个</em>变成了一个非常方便的工具供你使用。更熟悉诸如<em class="ls">上下文</em>和<em class="ls">范围</em>这样的概念的最好方法就是简单地对它们进行实验。</p><p id="7a9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开你喜欢的文本编辑器，开始创建你自己的函数和对象。在函数中乱搞变量放置。你什么时候可以访问它们，它们什么时候返回未定义的？</p><p id="0f98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建越来越复杂的对象，并在越来越具体和有限的上下文中调用<em class="ls">这个</em>。没有比把手指放在键盘上，一次一个概念地努力理解概念更好的方法了。</p></div></div>    
</body>
</html>