<html>
<head>
<title>The Power of Memento Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中Memento设计模式的力量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-memento-design-pattern-in-javascript-309f8bb4d9f2?source=collection_archive---------2-----------------------#2022-04-08">https://betterprogramming.pub/the-power-of-memento-design-pattern-in-javascript-309f8bb4d9f2?source=collection_archive---------2-----------------------#2022-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="617a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">记住你的纪念品</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b997c18b2989fbfe54fd40d982756a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*firqUPZL5NJkWJoxp1QUHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://jsmanifest.com" rel="noopener ugc nofollow" target="_blank"> jsmanifest </a>拍摄</p></figure><p id="895f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程中的Memento模式在我们需要一种方法来恢复对象状态的情况下非常有用。</p><p id="eff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名JavaScript开发人员，我们在许多情况下都会用到这个概念，尤其是在现代web应用程序中。</p><p id="c180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经在网络上发展了一段时间，那么你可能听说过术语<a class="ae ky" href="https://en.wikipedia.org/wiki/Hydration_(web_development)#:~:text=In%20web%20development%2C%20hydration%20or,handlers%20to%20the%20HTML%20elements." rel="noopener ugc nofollow" target="_blank">水合作用</a>。</p><p id="e0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道什么是水合作用，这是web开发中的一种技术，其中客户端获取以任何编程语言(如JSON、JavaScript、HTML等)存储的静态内容。，并将其转换为浏览器能够在运行时运行的代码。在这个阶段，JavaScript运行，并且能够在DOM开始在页面上运行时附加事件侦听器。</p><p id="e4a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纪念品的图案是相似的。在这篇文章中，我们将为运行时实现Memento模式，不会静态存储任何东西。</p><p id="903d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你和<code class="fe lv lw lx ly b">JSON.parse</code>和<code class="fe lv lw lx ly b">JSON.stringify</code>一起工作，你可能会意外地实现一个纪念品。</p><p id="638c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，有三个对象实现了Memento模式的完整流程:</p><ol class=""><li id="6dd4" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><strong class="lb iu">发起人</strong></li><li id="e02b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><strong class="lb iu">纪念品</strong></li><li id="2f35" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><strong class="lb iu">看管人</strong></li></ol><p id="a7f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mn">发起者</em>定义了触发其自身作为纪念品的创建和存储的接口。</p><p id="89b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mn">备忘录</em>是发起者的内部状态表示，它被传递并从看护者处检索。</p><p id="13bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mn">看管人</em>只有一个工作:保管或<em class="mn">保存</em>纪念品以备后用。它可以取回自己储存的记忆，但不会改变任何东西。</p><h1 id="c8ca" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">实现Memento设计模式</h1><p id="fe3c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">既然我们已经描述了模式，我们就要实现它，以便在代码中掌握这种实践。</p><p id="ff7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个交互式电子邮件输入字段作为DOM元素。我们将添加一个智能行为到我们的输入字段，这样我们的用户将立即意识到他们需要在提交前添加<code class="fe lv lw lx ly b">@</code>符号。</p><p id="ff37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当他们的输入字段处于如下所示的错误状态时，他们会知道这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/f1ac0cd8c5bcf630f31b6630e79fcec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*78VNar23tyT3eIGk.png"/></div></div></figure><p id="718c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们将要在其上工作的html标记:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将使我们从这个界面开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/5091fe71c64725a966dc4429509a1bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ar9t9iLwX1NvHYaR.png"/></div></div></figure><p id="4625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们要做的第一件事是为<em class="mn">错误</em>状态定义两个常量变量，我们将在整个代码中使用它们为错误类型赋值。这是为了确保我们在编写代码时不会出现任何打字错误，因为我们将多次重复使用它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2f02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与模式无关，但我认为我随机加入一些最佳实践是一个好习惯，这样你就可以从这篇文章中获得额外的技巧，为什么不呢？；)</p><p id="8871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将创建一个助手函数，它在<em class="mn">错误状态</em>和<em class="mn">正常状态</em>之间切换，因为我们也将多次使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5aa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在两种风格预设之间切换时，我也可以插入一个助手来切换边框半径。这是为了让我们的代码感觉更“自然”，就像它是一个真正的应用程序一样，所以我们在这篇文章中不只是直接关注颜色和纪念品之间的关系。有时我认为，当我们看到随机代码与实际代码的对比时，我们会学得更好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们要做的是编写<em class="mn">发起者</em>。</p><p id="5c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，发起者定义了接口，该接口触发其自身作为纪念品的创建和存储。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们只是创建了一个简单的工厂，为我们生产的创始人。</p><p id="70cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是真正的创始人:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在发起者中，<code class="fe lv lw lx ly b">serialize</code>方法接收一个DOM节点，并返回该DOM节点的状态表示，这样我们就可以将它作为一个字符串存储在本地存储中。这是必需的，因为本地存储只接受字符串。</p><p id="fb58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们是JavaScript中这种模式的顶峰。序列化是这种模式对我们很重要的唯一原因，否则我们就可以直接将DOM节点存储到本地存储中，然后就结束了。</p><p id="4ab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe lv lw lx ly b">serialize</code>方法中，我们隐式地定义了几个规则来帮助我们确定表示。</p><p id="2a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我所指的台词:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当存储输入元素的纪念品时，我们可以选择是这样实现还是那样实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接受我的建议:一个好的实践是从你的代码中创造出有用的意义<em class="mn">，尤其是在你的设计模式实现中</em>。当你在代码中赋予含义时，它会帮助你思考更高层次的抽象，这些抽象可能在代码的其他方面有用。</p><p id="61af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">item.isError</code>来表示预设的错误风格为制作有趣的可重用纪念品打开了更广阔的机会，当我们的项目随着时间变得越来越复杂时，我们可以重用这些纪念品，而不是直接指定任意的风格。</p><p id="4c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当一个关键字段未被隐藏时，表单无法提交是很常见的。表单必须转换到某种状态，在这种状态下它需要阻止自己提交。</p><p id="c8eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要保存一个表单的纪念品，我们需要确保当我们恢复这个状态时，用户被恢复到“禁用”状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们没有直接返回元素，而是确保返回的是呈现纪念品的<em class="mn">当前状态</em>。</p><p id="73c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从更高层次的角度来看，我们利用了这样一个事实，即<code class="fe lv lw lx ly b">isError</code>可以表示和概述类似表单的东西。如果缺少一个小的必填字段或输入的值不正确，则不应提交表单。</p><p id="ae1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们通过在向用户显示表单之前禁用<em class="mn">提交按钮</em>来确保表单<em class="mn">不应该是交互式的</em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/399190696a91ba606377066297812192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GgblbOIpEF4QEWO1.png"/></div></div></figure><p id="f9ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有注意到，我们的<code class="fe lv lw lx ly b">restore</code>从我们的<em class="mn">发起者</em>那里包装了我们最初的<code class="fe lv lw lx ly b">deserialize</code>方法。</p><p id="0040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在拥有的是一个更高层次的抽象纪念品，它支持我们整个纪念品的深层子<em class="mn">和<em class="mn">呈现状态</em> ( <code class="fe lv lw lx ly b">isError</code>)。</em></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="3107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本帖到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>