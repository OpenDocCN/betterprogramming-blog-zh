<html>
<head>
<title>6 Practices in React You Might Find Effective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中你可能会发现有效的6种做法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-practices-in-react-you-might-find-effective-e0aed050a7b0?source=collection_archive---------4-----------------------#2020-02-20">https://betterprogramming.pub/6-practices-in-react-you-might-find-effective-e0aed050a7b0?source=collection_archive---------4-----------------------#2020-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">因为我们总是希望提高我们的技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97fb5c2698fdf78c0f7d5c2469aa954b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_kGXDS0lmR9PyMzBUCrDg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">约翰·施诺布里奇在Unsplash上拍摄的照片</em></p></figure><p id="b2fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React是一个由脸书工程师创建的库，它使得创建复杂的用户界面成为可能。如果你和我一样，在用React开发时你永远不会感到无聊，也许是因为它的声明性。</p><p id="c699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你看着自己随着时间的推移而改进时，事情会变得有趣得多，因为随着你的改进，你的组件也会改进(就它们的代码而言)。然后你自我感觉良好——这是我喜欢的感觉。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac69" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.递归侧边栏</h1><p id="8ff2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">侧边栏是网页最重要的部分之一，因为它帮助用户导航。它还通常用于其他重要目的，如显示来自第三方附属机构的广告、您最近的文章等。</p><p id="fe54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，在react中有许多开发健壮侧栏的好方法。</p><p id="23f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子采用了一种使用<a class="ae mz" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank">递归</a>的方法，令人惊讶的是它的实现只使用了35行代码。</p><p id="16fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是这样做的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它在这里，完美地工作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f811bacd5e8584f1b7ed61618812dc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/0*NjfpeCY21rGdoeqU.jpg"/></div></figure><p id="fc6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法允许你制作动态的、流畅的侧边栏，因为它唯一需要的依赖项是<code class="fe nd ne nf ng b">props.items</code>，而其内部项目的定位已经由<code class="fe nd ne nf ng b">Sidebar</code>处理。如果数组中的任何项目发生变化，侧边栏将相应地更新。当只需要<code class="fe nd ne nf ng b">props.items</code>时，那么就由你来决定如何实现CSS。</p><p id="a7fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以为多个页面重用侧边栏组件，并且由于该组件是动态的，每个页面都可以根据您作为条目传递的内容，轻松地显示带有完全不同数据的侧边栏。</p><p id="5067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，递归在很多地方都很有用。</p><p id="9d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在具有嵌套菜单的下拉菜单中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/e42cb4b7d7b4c7e3fa8288a44d24343e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/0*xUkpfKr3NEz9zxs6.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0c14" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.组合多个提供商</h1><p id="8ed1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您需要一个非常大的React组件(甚至是一个应用程序),并且需要包装在多个提供者中，那么您可以采用常规方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5a57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是<em class="ni">请记住— </em>您可以使用常规的JavaScript概念将它们组合在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您节省了代码行，看起来不那么臃肿:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc37" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.将带有HTML标记名的组件声明为字符串</h1><p id="38cc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您还不知道这一点，那么您可以用表示HTML元素标记的简单字符串创建一个常规的react DOM组件。更准确地说，是表示HTML DOM元素的标记名的字符串。</p><p id="b820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以通过将字符串<code class="fe nd ne nf ng b">'div'</code>赋给变量来创建react组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React将调用<code class="fe nd ne nf ng b">React.createElement</code>并使用该字符串在内部创建元素——这不是很好吗？</p><p id="5bc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/material-ui.com"> Material-UI </a>这样的组件库中常用，可以声明一个<code class="fe nd ne nf ng b">component</code> prop，调用者可以决定组件的根节点成为<code class="fe nd ne nf ng b">props.component</code>的值，像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a6e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以传入将用作根节点的自定义组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很有用，因为当你想让react组件可重用并且<em class="ni">高度可定制</em>时，你想让它<em class="ni">尽可能的准系统</em>。</p><p id="7ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你默认一个<code class="fe nd ne nf ng b">div</code>时，你就把它简化成了开发者最基本的形式。否则，您必须将它默认为具有一些实现细节的其他组件(您的计算机的用户可能不需要这些细节，因为他们想要实现自己的细节)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f8be" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.通过导出映射组件</h1><p id="5cf4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，当您有一个接受输入并从中返回特定组件的开关用例时，每次都将它们输入到开关用例中会变得非常多余。</p><p id="6689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，我们在React中看到这样的事情并不少见:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="334f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你确定传入组件的道具每次都有相同的形状，那么这样写可能是多余的。相反，您可以通过将它们声明为文件的导出来消除冗余，这将有助于避免使用switch cases或if/else条件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="417b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦设置好了，只需导入它们并简单地使用它们，同时保持代码的功能不变:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4b35" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.允许在别处控制组件</h1><p id="d575" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你开发一个普通的组件时，比如一个水平的标签列表，让组件在用户点击它的时候高亮显示一个特定的项目，这是非常有用的，只是为了控制它们。一种常见但有用的方法是为选定的项目添加一种独特的颜色。</p><p id="6e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发该组件的实现细节时，您可能已经决定将该功能放入组件中。但是，如果您认为这个组件在将来可以与另一个组件一起使用时可能有用，那么如果您的组件的用户需要，允许它将控件切换到其父组件可能是一个好主意。</p><p id="8741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面的代码表示一个简单的导航栏，当用户选择某个项目时，它会显示为紫色:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b5dac7c27007718fd111c8f9a350d602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/0*SqdUudFDkU5orqcE.gif"/></div></figure><p id="4c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很有用，因为有两个关键原因:</p><ul class=""><li id="5ff8" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">它现在有能力被重用。</li><li id="e3a8" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">现在，它可以与其他组件组合来创建模块，因为它们可以将控制传递到其他地方。</li></ul><p id="4af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实践中，这个概念如此强大，以至于它被用于许多React库中，比如<a class="ae mz" href="https://github.com/downshift-js/downshift" rel="noopener ugc nofollow" target="_blank">降档</a>。</p><p id="2433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们回到我们的侧边栏片段，实现具有扩展/折叠功能的嵌套项目<em class="ni">并且</em>支持在其他地方控制，它将变得更加强大，因为现在您可以让其他组件扩展/折叠任何嵌套项目，反之亦然。可能性是无限的！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d230" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="38ac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这就是这篇文章的结尾。</p><p id="b199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你发现这是有价值的，并期待在未来更多。</p><p id="dc59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>