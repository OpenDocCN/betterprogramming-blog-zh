<html>
<head>
<title>Kubernetes Operator Logging With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes操作员使用Go进行日志记录</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-operator-logging-4d4553d19f15?source=collection_archive---------16-----------------------#2022-07-11">https://betterprogramming.pub/kubernetes-operator-logging-4d4553d19f15?source=collection_archive---------16-----------------------#2022-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed42" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">操作员日志选择什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/994c054b46ca4fb683e7c433f2fa1f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aApgEeS4RYqDyQkM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Unsplash，<a class="ae ky" href="https://unsplash.com/photos/SId-lmFXSDU" rel="noopener ugc nofollow" target="_blank"> @de </a></p></figure><p id="4839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个操作员信息日志来引出我们的主题。与最常见的打印方法<code class="fe lv lw lx ly b">fmt.Printf</code>不同，它不打印消息中的具体参数信息，而是像JSON字符串一样单独打印在日志中。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c13a" class="md me it ly b gy mf mg l mh mi">{"severity":"INFO","eventTime":"2022-07-09T09:04:55.260Z","logger":"controller.opresource","message":"Deleting OpResource, because it is no longer in scope!","reconciler group":"op.spotify.com","reconciler kind":"OpResource","name":"afs-proxy-0618bce","namespace":"","name":"afs-proxy"}</span></pre><p id="1f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是操作员日志打印的规范方式吗？让我们通过深入运营商日志框架的实现和使用细节来揭示答案。</p><h1 id="26a6" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">登录操作员</h1><p id="4fae" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><code class="fe lv lw lx ly b">controller-runtime</code> <a class="ae ky" href="https://github.com/kubernetes-sigs/controller-runtime/blob/15154aaa67679df320008ed45534f83ff3d6922d/alias.go#L132" rel="noopener ugc nofollow" target="_blank"> alias.go </a>提供了一个默认的<code class="fe lv lw lx ly b">Log</code>对象，默认由<code class="fe lv lw lx ly b">go-logr</code>执行。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c039" class="md me it ly b gy mf mg l mh mi">// Log is the base logger used by controller-runtime.  It delegates<br/>// to another logr.Logger.  You *must* call SetLogger to<br/>// get any actual logging.<br/>Log = log.Log</span></pre><p id="ebab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/go-logr/logr" rel="noopener ugc nofollow" target="_blank">go-logr</a></code>是一个简单的日志框架，本身没有日志输出功能，而是对<a class="ae ky" href="http://dave.cheney.net/2015/11/05/lets-talk-about-logging" rel="noopener ugc nofollow" target="_blank">戴夫·切尼</a>提出的<code class="fe lv lw lx ly b">Go log</code>日志分类的进一步优化。</p><ul class=""><li id="ab17" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">在正常情况下，一个Go程序只需要两级日志，INFO和ERROR而其他层面并不重要。</li><li id="911e" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">对于调试，它提供V电平输出，放弃其他电平，如<code class="fe lv lw lx ly b">trace </code>或<code class="fe lv lw lx ly b">debug</code>。</li></ul><p id="3302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其实现包括<a class="ae ky" href="https://github.com/go-logr/logr/blob/89d4c03b0f902d395854776f2ef6b5948237a5d5/logr.go#L239" rel="noopener ugc nofollow" target="_blank"> Logr </a>和<a class="ae ky" href="https://github.com/go-logr/logr/blob/89d4c03b0f902d395854776f2ef6b5948237a5d5/logr.go#L416" rel="noopener ugc nofollow" target="_blank"> LogSink </a>接口，任何外部日志框架都可以通过实现<code class="fe lv lw lx ly b">LogSink</code>来集成<code class="fe lv lw lx ly b">logr</code>。</p><p id="eb56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在默认的<code class="fe lv lw lx ly b">controller-runtime</code>中，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-runtime/blob/5636d975d88e2072884fd82c75b5d3bacf274919/pkg/log/deleg.go#L89" rel="noopener ugc nofollow" target="_blank">DelegatingLogSink</a></code>被实现为默认Logr的日志输出，其中<code class="fe lv lw lx ly b">logger</code>使用简单的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-runtime/blob/5636d975d88e2072884fd82c75b5d3bacf274919/pkg/log/null.go#L28" rel="noopener ugc nofollow" target="_blank">NullLogSink</a></code>。这个默认实现对于大多数场景来说已经足够了，并且可以与<code class="fe lv lw lx ly b">fmt.Sprintf</code>结合使用。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1c47" class="md me it ly b gy mf mg l mh mi">log.V(10).Info(fmt.Sprintf("Create Resources for User:%s, Project:%s", user, project))</span></pre><p id="e9b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe lv lw lx ly b">DelegatingLogSink</code>有一个明显的缺陷:当它被部署为集群范围的控制器并管理成千上万的资源时，它的低效率是一个性能瓶颈。以下两点是导致其效率低下的主要原因。</p><ul class=""><li id="f483" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">它使用许多锁。<code class="fe lv lw lx ly b">DelegatingLogSink</code>使用了一个<code class="fe lv lw lx ly b">promisesLock</code>互斥锁，<code class="fe lv lw lx ly b">loggerPromise</code>的<code class="fe lv lw lx ly b">WithName</code>和<code class="fe lv lw lx ly b">WithValues</code>方法都需要锁，甚至<code class="fe lv lw lx ly b">Enable</code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-runtime/blob/5636d975d88e2072884fd82c75b5d3bacf274919/pkg/log/deleg.go#L118" rel="noopener ugc nofollow" target="_blank">Info</a></code>和<code class="fe lv lw lx ly b">Error</code>函数都依赖于<code class="fe lv lw lx ly b">RLock</code>读锁。毫无疑问，在具有大量写操作的日志输出中，频繁的锁定(即使是读锁定)会导致低性能。</li></ul><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="515e" class="md me it ly b gy mf mg l mh mi">func (l *DelegatingLogSink) Info(level int, msg string,keysAndValues ...interface{}) {<br/>  l.lock.RLock()<br/>  defer l.lock.RUnlock()<br/>  l.logger.Info(level, msg, keysAndValues...)<br/>}</span></pre><ul class=""><li id="2ae1" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><strong class="lb iu">日志内容使用</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">fmt.Sprintf</strong></code>。我们使用<code class="fe lv lw lx ly b">Strings.Join</code>或<code class="fe lv lw lx ly b">Buffer</code>操作来代替<code class="fe lv lw lx ly b">fmt.Sprintf</code>和<code class="fe lv lw lx ly b">+</code>来连接字符串，以提高许多Go字符串操作的效率(阅读golang a quick benchmark : +或fmt中的<a class="ae ky" href="https://dev.to/pmalhaire/concatenate-strings-in-golang-a-quick-benchmark-4ahh" rel="noopener ugc nofollow" target="_blank"> Concatenate strings)。Sprintf </a>了解更多)。但是在编写日志时，我们确实希望从日志框架中免费获得，而不是重新发明轮子，这是<code class="fe lv lw lx ly b">logr</code>和<code class="fe lv lw lx ly b">controller-runtime</code>的默认实现无法提供的。</li></ul><h1 id="4baf" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">其他选项</h1><p id="f9fa" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如果我们放弃默认实现，还有其他选择吗？以及如何切换？</p><p id="43a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go社区提供了广泛的日志包，甚至原生的也能满足基本的日志输出需求。</p><p id="300d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://levelup.gitconnected.com/a-sip-of-go-log-94b968071ed8" rel="noopener ugc nofollow" target="_blank"> <em class="nt">一口围棋日志</em> </a>中，我们深入挖掘了日志的基本逻辑，对比了一些流行的日志开源包，其中来自优步的<a class="ae ky" href="https://github.com/uber-go/zap" rel="noopener ugc nofollow" target="_blank"> zap </a>以其性能吸引了我们的眼球。让我们回忆一下那些惊人的数字，看看<code class="fe lv lw lx ly b">zap</code>是不是最好的选择。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/d6639d7e60404bb0d424caddc7776bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*ZUXnh7J78_oQu4HC"/></div></figure><p id="9cfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">controller-runtime</code>已经有了<code class="fe lv lw lx ly b">zapr</code>默认<a class="ae ky" href="https://github.com/kubernetes-sigs/controller-runtime/blob/5636d975d88e2072884fd82c75b5d3bacf274919/pkg/log/zap/zap.go#L42" rel="noopener ugc nofollow" target="_blank">实现</a>，在国内不少地方已经使用。但是为什么不用它作为默认实现呢？</p><p id="ba71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户可以通过定制一个<code class="fe lv lw lx ly b">Logger</code>来集成zap，以实现某些附加功能，如时间转换、日志输出到外部存储等。<code class="fe lv lw lx ly b">controller-runtime</code>最终在<code class="fe lv lw lx ly b">controller-runtime</code>的<code class="fe lv lw lx ly b">zap</code>实现中将其封装为<code class="fe lv lw lx ly b">logr.Logger</code>。</p><p id="41d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循定义zap记录器的四个步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9df7b164cd1c1bae4e671d7036680064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/0*MP-0XO-ZIzCnK8z9"/></div></figure><p id="9781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-runtime/blob/5636d975d88e2072884fd82c75b5d3bacf274919/pkg/log/zap/zap.go#L176" rel="noopener ugc nofollow" target="_blank"> zap.go </a>实现了<code class="fe lv lw lx ly b">console</code>和<code class="fe lv lw lx ly b">json</code>两个编码器，提供了<code class="fe lv lw lx ly b">zapr</code>标准<code class="fe lv lw lx ly b">Logger</code>要求的功能，如<code class="fe lv lw lx ly b">WriteTo</code>和<code class="fe lv lw lx ly b">Level</code>。</p><p id="fe85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<code class="fe lv lw lx ly b">zapr</code>在开发模式下使用<code class="fe lv lw lx ly b">consoleEncoder</code>和<code class="fe lv lw lx ly b">debugLevel/warnLevel</code>，而在生产模式下使用<code class="fe lv lw lx ly b">jsonEncoder</code>和<code class="fe lv lw lx ly b">infoLevel/errorLevel</code>。</p><p id="935e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于替换这个<a class="ae ky" href="https://github.com/slaise/operator-test/blob/52447e26da0ca4351ca73f1800cb86669aa7f6da/kubebuilder-test/main.go#L75" rel="noopener ugc nofollow" target="_blank">操作符</a>中的默认<code class="fe lv lw lx ly b">Logr</code>，我们只需要在main方法中初始化<code class="fe lv lw lx ly b">Reconciler</code>时使用<code class="fe lv lw lx ly b">Log: zap.New(),</code>，然后我们就可以按照下面的模式打印控制器中的日志。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="e75a" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">为什么zap很快</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/4d2aee26980ca84eb3fb909733247e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/0*qhEYHGPtsz5iKm_b"/></div></figure><p id="b0b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">zap采取的5个步骤，每个步骤都反映了优化，主要使用了Go的两个特性，这两个特性决定了zap的效率。</p><ul class=""><li id="b39d" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><strong class="lb iu">使用</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">sync.Pool</strong></code> <strong class="lb iu">避免输出日志时的内存开销。</strong></li></ul><p id="610a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/uber-go/zap/blob/2cfc92c94b14298b9ff814f7fbfdda850046e7b3/logger.go#L196" rel="noopener ugc nofollow" target="_blank">日志。检查</a>是打印的第一步，在<code class="fe lv lw lx ly b">Check</code>方法中进行了两次性能优化。</p><ol class=""><li id="ce5f" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nz nl nm nn bi translated">避免不必要的操作，比如跳过不必要的<code class="fe lv lw lx ly b">Log</code>关卡，直接返回不需要打印的日志。例如，如果我们的日志级别是<code class="fe lv lw lx ly b">Info</code>，一旦有<code class="fe lv lw lx ly b">Debug</code>级别的日志，它就直接返回。</li><li id="2157" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nz nl nm nn bi translated">重复使用<code class="fe lv lw lx ly b">Entry</code>对象。<code class="fe lv lw lx ly b">zap</code>构造一个真实的打印入口对象，该对象将被<a class="ae ky" href="https://github.com/uber-go/zap/blob/2cfc92c94b14298b9ff814f7fbfdda850046e7b3/zapcore/core.go#L78" rel="noopener ugc nofollow" target="_blank"> Check </a> ed，以便在<code class="fe lv lw lx ly b">sync.Pool</code>保存的对象中重用，降低高频日志对象的创建和删除频率，最终减少GC。</li></ol><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b378" class="md me it ly b gy mf mg l mh mi">func getCheckedEntry() *CheckedEntry {<br/>  ce := _cePool.Get().(*CheckedEntry)<br/>  ce.reset()<br/>  return ce<br/>}</span></pre><p id="c3d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Pool</code>每隔<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/uber-go/zap/blob/2e615d88d0eb88c94c15f196a538dea3fa181451/zapcore/entry.go#L235" rel="noopener ugc nofollow" target="_blank">Write</a></code>更新一次。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9454" class="md me it ly b gy mf mg l mh mi">func (ce *CheckedEntry) Write(fields ...Field) {<br/>  //…<br/>  putCheckedEntry(ce)<br/>}</span></pre><p id="86a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在输出日志时，我们也使用<code class="fe lv lw lx ly b">sync.Pool</code>进行内存优化。默认的<code class="fe lv lw lx ly b">consoleEncoder</code>和<code class="fe lv lw lx ly b">jsonEncoder</code>都将打印的信息存储在一个<code class="fe lv lw lx ly b">buffer</code>中，这个<code class="fe lv lw lx ly b">buffer</code>使用<code class="fe lv lw lx ly b">sync.Pool</code>构建的<a class="ae ky" href="https://github.com/uber-go/zap/blob/2e615d88d0eb88c94c15f196a538dea3fa181451/buffer/pool.go#L31" rel="noopener ugc nofollow" target="_blank">缓冲池</a>获取一个对象，通过后续拼接得到最终的输出日志。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><ul class=""><li id="0425" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><strong class="lb iu">避免用</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">interface{}</strong></code> <strong class="lb iu">设计API，优化JSON序列化。通过强类型设计和零内存开销实现JSON序列化。</strong></li></ul><p id="e97c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">zap</code>输出的日志中，JSON格式是最终统一的输出格式，甚至<code class="fe lv lw lx ly b">console_encoder</code> <a class="ae ky" href="https://github.com/uber-go/zap/blob/2e615d88d0eb88c94c15f196a538dea3fa181451/zapcore/console_encoder.go#L133" rel="noopener ugc nofollow" target="_blank">最终调用</a> <code class="fe lv lw lx ly b">json_encoder</code>打印字段。<code class="fe lv lw lx ly b">Fields</code>结构设计显著加快了日志打印的速度，并用于定义每个输入参数的类型信息，以快速将类型转换为字符串。并且在Field的<code class="fe lv lw lx ly b">AddTo</code>方法中定义了类型和字符串之间所有可能的转换，避免了zap的类型推断或反射，大大提高了输出效率。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="47f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，别忘了释放<code class="fe lv lw lx ly b">bufferPool</code>中获得的对象！</p><h1 id="ba83" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">特性试验</h1><p id="da84" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">让一个基准测试来验证zap的优秀表现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="55eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过比较三个日志包在非参数和多参数场景下的性能，我可以“自豪地”宣布<code class="fe lv lw lx ly b">zap</code>是最好的:zap Logr比<code class="fe lv lw lx ly b">controller-runtime</code>中的默认<code class="fe lv lw lx ly b">logr</code>快大约<strong class="lb iu"> 7倍</strong>。</p><p id="5a6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很容易得出结论，如果我们想要实现一个高性能的操作符，替换默认的日志实现是必要的。但是需要注意的是，如果您仍然使用v1，您可能需要将您的kubebuilder升级到最新的v3版本，这涉及到从<code class="fe lv lw lx ly b">klog</code>迁移到<code class="fe lv lw lx ly b">logr</code>，请参考<a class="ae ky" href="https://github.com/kubernetes/community/blob/HEAD/contributors/devel/sig-instrumentation/migration-to-structured-logging.md#structured-and-contextual-logging-migration-instructions" rel="noopener ugc nofollow" target="_blank">结构化和上下文日志迁移说明</a>以获得指导。</p><p id="be89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>