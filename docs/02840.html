<html>
<head>
<title>A Simple Guide to Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归的简单指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursion-a-simple-guide-cfe88bfd517e?source=collection_archive---------23-----------------------#2020-01-03">https://betterprogramming.pub/recursion-a-simple-guide-cfe88bfd517e?source=collection_archive---------23-----------------------#2020-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e901" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在代码中实现阶乘</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4924002fa40a059bf3a275fa60ad6088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pexn9tPNYn3N7xiJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@flub?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克西姆·勒布伦</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="584b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">递归</em>是方法调用自身的时候。当一个方法以这种方式运行时，它被称为<em class="lv">递归方法。</em></p><p id="e9ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在处理递归序列时，递归在数学中使用得相当多。如果你不熟悉<em class="lv">递归序列</em>，它们只是一个序列中的下一项使用前一项。我确信对于你们中的一些人来说，阶乘或者斐波那契递归序列可能会出现在脑海中。</p><p id="5e3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归不仅仅在数学中使用。它甚至存在于自然界。一个例子是螺旋楼梯，像上面的图片，它模仿鹦鹉螺壳。再比如向日葵。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/d662ebd0a9e9c31e778fa299d18670a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p4gDppJwvQsewz9a"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡罗琳·贝斯纳德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="992f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仔细观察向日葵，它看起来就像是在其他圆里面的圆。不过，既然这和发展有关，我就尽量不要太被自然冲昏头脑。我将用一个典型的for循环实现阶乘序列，然后递归地执行它。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="269a" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">阶乘</h1><p id="6223" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">阶乘是一个整数和它下面所有整数的乘积。安！用来表示它。例如1 x 2 x 3 x 4 x 5可以写成5！。0!= 1.这可以实现为一个简单的循环，并假设只使用正整数。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3dfc" class="ng mf it nc b gy nh ni l nj nk">public static int factorial(int number){<br/>    if ( number &lt;= 1){<br/>        return 1;<br/>    }</span><span id="ce54" class="ng mf it nc b gy nl ni l nj nk">    int sum = 1;</span><span id="d9e8" class="ng mf it nc b gy nl ni l nj nk">    for(int i = 2; i &lt; number + 1; i ++ ){<br/>        sum *= i;<br/>    }</span><span id="b265" class="ng mf it nc b gy nl ni l nj nk">    return sum;<br/>}</span></pre><p id="3a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用5调用这个方法，你会得到120。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="06bb" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">复发性依赖</h1><p id="5c29" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">如果你足够幸运，上过一些算法课，找到递归公式可以简单地通过找到递归依赖来完成。</p><p id="ef8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">循环依赖</em>是一个模式开始出现的点——在此之前的任何事情都需要单独处理。为了在这里找到它，我们只需要手动找到一些数字的阶乘，直到我们看到它。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5c7a" class="ng mf it nc b gy nh ni l nj nk">0! =&gt; 1<br/>1! =&gt; 1 =&gt; 1x1 =&gt; 1x0!<br/>2! =&gt; 2x1 =&gt; 2x1!<br/>3! =&gt; 3x2x1 =&gt; 3x2!<br/>4! =&gt; 4x3x2x1 =&gt; 4x3!<br/>5! =&gt; 5x4x3x2x1 =&gt; 5x4!<br/>6! =&gt; 6x5x4x3x2x1 =&gt; 6x5!</span></pre><p id="c3d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们可以看到循环依赖从2开始。</p><p id="1650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1和0是特例，都等于1。</p><p id="be2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6!= 6x5！也可以写成6x(6–1)！。如果我们用<em class="lv"> n </em>代替常数，我们得到<em class="lv"> n </em> ( <em class="lv"> n </em> -1)！。</p><p id="c2ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们用它来递归地实现同样的功能。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="fc31" class="ng mf it nc b gy nh ni l nj nk">public static int <strong class="nc iu">factorial</strong>(int number){<br/>    if ( number &lt;= 1){<br/>        return 1;<br/>    }</span><span id="613c" class="ng mf it nc b gy nl ni l nj nk">    return <strong class="nc iu">number</strong> * factorial(<strong class="nc iu">number</strong> -1);<br/>}</span></pre><p id="25f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no nc b">if</code>条件处理两种特殊情况。对于任何等于或小于1的值，都返回1。</p><p id="bf1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住一个循环总是需要一个突破条件。递归依赖从2开始，所以当数值达到1时，方法将停止调用自己。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="059c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="239f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">递归一开始可能很难理解，但它真的很简单。</p><p id="a16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要用看待循环的方式来看待它。唯一的区别是，在周期性依赖开始出现之前，几乎总会有一些特殊情况。这些情况将是你的突破条件，而你的公式是用来递归调用你的方法的——正如我们在前面的例子中看到的。</p></div></div>    
</body>
</html>