<html>
<head>
<title>How Git Really Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git是如何工作的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-short-journey-to-git-internals-fc9d11dd80b7?source=collection_archive---------6-----------------------#2020-09-28">https://betterprogramming.pub/a-short-journey-to-git-internals-fc9d11dd80b7?source=collection_archive---------6-----------------------#2020-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="111b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看Git的内部结构，理解添加、提交、推送等操作时会发生什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/777800305fa77553984603e7e5723631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1titcNhwBH5FNRxlp-YQA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@notethanun" rel="noopener ugc nofollow" target="_blank">注意到</a>上的<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>。</p></figure><p id="a7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过一个真实的例子深入Git内部。如果你还没有打开你的候机厅，那就打开吧，系好安全带，我们走吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="70af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">初始化Git存储库</h1><p id="d66d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能已经使用<code class="fe mz na nb nc b">git init</code>初始化了一个空的Git项目，但是您有没有想过这个命令是做什么的？</p><p id="00f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个空文件夹并初始化一个空的Git项目。这是官方<a class="ae ky" href="https://git-scm.com/docs/git-init" rel="noopener ugc nofollow" target="_blank"> Git文档</a>对<code class="fe mz na nb nc b">git init</code>的描述:</p><blockquote class="nd ne nf"><p id="7be8" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">这个命令创建一个空的Git存储库——基本上是一个包含子目录<code class="fe mz na nb nc b">objects</code>、<code class="fe mz na nb nc b">refs/heads</code>、<code class="fe mz na nb nc b">refs/tags</code>和模板文件的<code class="fe mz na nb nc b">.git</code>目录。还会创建一个引用主分支的头的初始<code class="fe mz na nb nc b">HEAD</code>文件。</p></blockquote><p id="1de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们检查文件夹的内容，我们会看到以下结构:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="a290" class="no md it nc b gy np nq l nr ns">$ tree -L 1 .git/<br/>.git/<br/>├── HEAD<br/>├── config<br/>├── description<br/>├── hooks<br/>├── info<br/>├── objects<br/>└── refs</span></pre><p id="1349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们稍后将讨论一些对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5945" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Git是一个键值存储</h1><p id="4d82" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在其核心，Git是一个<em class="ng">内容寻址的</em>文件系统。啊？好吧，Git只是一个键值数据库。您可以向Git存储库中插入任何类型的内容，Git会返回一个惟一的标识符(一个键),您可以用它来检索内容。</p><p id="c95a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://git-scm.com/docs/git-hash-object" rel="noopener ugc nofollow" target="_blank">hash-object</a></code>命令将值存储到数据库中:</p><blockquote class="nd ne nf"><p id="53b0" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">用命名文件(可以在工作树之外)的内容计算指定类型的对象的对象ID值，并可选择将结果对象写入对象数据库。向其标准输出报告其对象ID。未指定<type>时，默认为‘blob’"</type></p></blockquote><p id="c2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“blob”只不过是一个字节序列。Git blob包含作为文件的确切数据，但是它存储在Git键值数据存储中，而“实际的”文件存储在文件系统中。</p><p id="c8f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个blob:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="1851" class="no md it nc b gy np nq l nr ns">$ echo hello | git hash-object --stdin -w<br/>ce013625030ba8dba906f756967f9e9ca394464a</span></pre><p id="9c75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe mz na nb nc b">-w</code>标志实际上<em class="ng">将</em>对象写入对象数据库，而不仅仅是显示它(通过<code class="fe mz na nb nc b">--stdin</code>标志实现)。</p><p id="5866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值“hello”是Git数据存储中的“值”,从<code class="fe mz na nb nc b">hash-object</code>函数返回的散列是我们的键。我们现在可以做相反的操作，使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://git-scm.com/docs/git-cat-file" rel="noopener ugc nofollow" target="_blank">git-cat-file</a></code>命令通过键值读取值:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="11e4" class="no md it nc b gy np nq l nr ns">$ git cat-file -p ce013625030ba8dba906f756967f9e9ca394464a<br/>hello</span></pre><p id="d6e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mz na nb nc b">-t</code>标志来检查它的类型:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="67d6" class="no md it nc b gy np nq l nr ns">$ git cat-file -t ce013625030ba8dba906f756967f9e9ca394464a<br/>blob</span></pre><p id="5d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">git hash-object</code>将数据存储在<code class="fe mz na nb nc b">.git/objects/</code>文件夹中(又名对象数据库)。让我们验证一下:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="df68" class="no md it nc b gy np nq l nr ns">$ tree .git/objects/<br/>.git/objects/<br/>├── ce<br/>│   └── 013625030ba8dba906f756967f9e9ca394464a<br/>├── info<br/>└── pack</span></pre><p id="fa55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">散列后缀(在“ce”目录下)与我们从<code class="fe mz na nb nc b">hash-object</code>函数中得到的相同，但是它有一个不同的前缀。为什么？这是因为父文件夹名包含我们的密钥的前两个字符。为什么？因为一些文件系统对可能的子目录数量有限制。所以引入这一层可以缓解这个问题。</p><p id="bfff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们保存另一个对象:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="8fb2" class="no md it nc b gy np nq l nr ns">$ echo world | git hash-object --stdin -w<br/>cc628ccd10742baea8241c5924df992b5c019f71</span></pre><p id="4d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，我们现在在<code class="fe mz na nb nc b">.git/objects/</code>下有两个目录:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="e067" class="no md it nc b gy np nq l nr ns">$ tree .git/objects/<br/>.git/objects/<br/>├── cc<br/>│   └── 628ccd10742baea8241c5924df992b5c019f71<br/>├── ce<br/>│   └── 013625030ba8dba906f756967f9e9ca394464a<br/>├── info<br/>└── pack</span></pre><p id="6136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，包含密钥前缀的<code class="fe mz na nb nc b">cc</code>文件夹在包含的文件名中包含密钥的其余部分。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb1b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">树对象</h1><p id="6534" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们要研究的下一个Git对象是树。<strong class="lb iu"> </strong>这种类型解决了文件名的存储问题，允许将一组文件存储在一起。</p><p id="8256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">树对象包含条目。每个条目都是blob或子树的SHA-1及其相关的模式、类型和文件名。让我们检查一下文档中对<code class="fe mz na nb nc b"><a class="ae ky" href="https://git-scm.com/docs/git-mktree" rel="noopener ugc nofollow" target="_blank">git-mktree</a></code>的定义:</p><blockquote class="nd ne nf"><p id="2ada" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">"读取非递归<code class="fe mz na nb nc b">ls-tree</code>输出格式的标准输入，并创建一个树对象。mktree规范了树条目的顺序，因此不需要对输入进行预先排序。构建的树对象的对象名被写入标准输出。</p></blockquote><p id="7cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道<code class="fe mz na nb nc b"><a class="ae ky" href="https://git-scm.com/docs/git-ls-tree" rel="noopener ugc nofollow" target="_blank">ls-tree</a></code>的输出格式，它看起来像这样:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="b02e" class="no md it nc b gy np nq l nr ns">&lt;mode&gt; SP &lt;type&gt; SP &lt;object&gt; TAB &lt;file&gt;</span></pre><p id="7eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们把上面的两个斑点联系起来:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="cbbd" class="no md it nc b gy np nq l nr ns">$ printf '%s %s %s\t%s\n' \<br/>    100644 blob ce013625030ba8dba906f756967f9e9ca394464a hello.txt \<br/>    100644 blob cc628ccd10742baea8241c5924df992b5c019f71 world.txt |<br/>  git mktree<br/>88e38705fdbd3608cddbe904b67c731f3234c45b</span></pre><p id="d2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">mktree</code>返回新创建的树对象的键。</p><p id="83af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们可以将我们的树想象如下:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="ffc8" class="no md it nc b gy np nq l nr ns">             88e38705fdbd3608cddbe904b67c731f3234c45b  <br/>                                |                   <br/>                  +-------------|------------+             <br/>                  |                          |        <br/>                  |                          |        <br/>                  |                          |          <br/>                  |                          |       <br/>                  |                          |<br/>                hello                       world        <br/>            ce013625030b                 cc628ccd1074</span></pre><p id="21f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看树的内容:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="9196" class="no md it nc b gy np nq l nr ns">$ git cat-file -p 88e38705fdbd3608cddbe904b67c731f3234c45b<br/>100644 blob ce013625030ba8dba906f756967f9e9ca394464a hello.txt<br/>100644 blob cc628ccd10742baea8241c5924df992b5c019f71 world.txt</span></pre><p id="4e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，相应地更新了<code class="fe mz na nb nc b">.git/objects</code>:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="e053" class="no md it nc b gy np nq l nr ns">$ tree .git/objects/<br/>.git/objects/<br/>├── 88<br/>│   └── e38705fdbd3608cddbe904b67c731f3234c45b<br/>├── cc<br/>│   └── 628ccd10742baea8241c5924df992b5c019f71<br/>├── ce<br/>│   └── 013625030ba8dba906f756967f9e9ca394464a<br/>├── info<br/>└── pack</span></pre><p id="63a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们还没有更新我们的索引。为此，我们使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://git-scm.com/docs/git-read-tree" rel="noopener ugc nofollow" target="_blank">git-read-tree</a></code>命令:</p><blockquote class="nd ne nf"><p id="952c" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">将由<tree-ish>给出的树信息读入索引，但实际上<strong class="lb iu">不会更新</strong>它缓存的任何文件。(参见:<a class="ae ky" href="https://git-scm.com/docs/git-checkout-index" rel="noopener ugc nofollow" target="_blank"> git-checkout-index[1] </a>)”</tree-ish></p></blockquote><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="c17c" class="no md it nc b gy np nq l nr ns">$ git read-tree 88e38705fdbd3608cddbe904b67c731f3234c45b<br/>$ git ls-files -s<br/>100644 ce013625030ba8dba906f756967f9e9ca394464a 0 hello.txt<br/>100644 cc628ccd10742baea8241c5924df992b5c019f71 0 world.txt</span></pre><p id="7b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，请注意，我们的<em class="ng">文件系统</em>中仍然没有这些文件，因为我们正在将值直接<strong class="lb iu"> </strong>写入Git数据存储。为了“检出”文件，我们将使用<code class="fe mz na nb nc b">git-checkout-index</code>命令将文件从索引复制到<em class="ng">工作树</em>:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="aef6" class="no md it nc b gy np nq l nr ns">git checkout-index 0 -a</span></pre><p id="ebba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">-a</code>代表“所有”现在我们应该可以看到我们的文件了:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="30e7" class="no md it nc b gy np nq l nr ns">$ ls<br/>hello.txt world.txt<br/>$ cat hello.txt<br/>hello<br/>$ cat world.txt<br/>world</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3d01" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金</h1><p id="f9b6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">git-hash-object</code>输出与<code class="fe mz na nb nc b">openssl</code> SHA-1不同的SHA。为什么？这是因为Git使用下面的公式进行<a class="ae ky" href="https://stackoverflow.com/questions/552659/how-to-assign-a-git-sha1s-to-a-file-without-git" rel="noopener ugc nofollow" target="_blank"> SHA-1计算</a>:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="7d6c" class="no md it nc b gy np nq l nr ns">sha1("blob " + filesize + "\0" + data)</span></pre><p id="f012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以为了得到同样的SHA-1，我们需要做下面的<a class="ae ky" href="https://stackoverflow.com/questions/5290444/why-does-git-hash-object-return-a-different-hash-than-openssl-sha1" rel="noopener ugc nofollow" target="_blank">小把戏</a>:</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="1aa1" class="no md it nc b gy np nq l nr ns"># without outputing a newline<br/>$ echo -n hello | git hash-object --stdin -w<br/>b6fc4c620b67d95f953a5c1c1230aaab5db5a1b0<br/>$ printf 'blob 5\0hello' | openssl sha1<br/>b6fc4c620b67d95f953a5c1c1230aaab5db5a1b0</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fedf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="2af6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们将两个文件直接存储到Git数据存储中。这些文件对我们的本地文件系统还不可见。我们已经创建了一棵树，并将两个“blobs”关联起来，然后我们使用<code class="fe mz na nb nc b">git-checkout-index</code>命令将文件放到我们的工作目录中。</p></div></div>    
</body>
</html>