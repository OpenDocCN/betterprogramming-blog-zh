<html>
<head>
<title>Chaining Patterns in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的链接模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/chaining-patterns-in-javascript-df05e3030ee7?source=collection_archive---------12-----------------------#2022-01-27">https://betterprogramming.pub/chaining-patterns-in-javascript-df05e3030ee7?source=collection_archive---------12-----------------------#2022-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b3c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">锁住你的成功之路</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/7e94dc41bdf04b12f303687d1c52b57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Wr_pcNKa-Zi83qINP7fHjQ.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自Pexels的马体·米罗什尼琴科的照片</p></figure><p id="c023" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">作为开发人员，编写好的代码是我们的责任。这意味着编写既高效又可读的代码。但是有时我们会遇到一些障碍，当为了更好地执行而牺牲可读性时，我们必须决定使用哪种代码更好，反之亦然。</p><p id="b02a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这篇文章将介绍JavaScript中不同的链接模式，我希望在编写链接操作时，这篇文章能对你有所帮助。</p><h1 id="2250" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">方法链接</h1><p id="fcfa" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">在JavaScript中，方法链接是指从一个对象到另一个对象调用方法，而不创建中间变量。换句话说，它是我们指示程序执行的多个方法调用的单个语句。</p><p id="e727" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Jquery是充分利用其语义的一个很好的例子，因为它能够在高效封装DOM APIs的同时将命令链接在一起。它使用清晰简洁的语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ed41" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是一个单一语句的示例。在一行代码中，它在一次执行中完成了所有这些操作:</p><ol class=""><li id="adb3" class="mr ms it kx b ky kz lb lc le mt li mu lm mv lq mw mx my mz bi translated">查询id为<code class="fe na nb nc nd b">main</code>的DOM元素</li><li id="fe39" class="mr ms it kx b ky ne lb nf le ng li nh lm ni lq mw mx my mz bi translated">将背景颜色更改为<code class="fe na nb nc nd b">red</code></li><li id="df3f" class="mr ms it kx b ky ne lb nf le ng li nh lm ni lq mw mx my mz bi translated">将高度改为<code class="fe na nb nc nd b">200px</code></li><li id="d405" class="mr ms it kx b ky ne lb nf le ng li nh lm ni lq mw mx my mz bi translated">将文本对齐改为<code class="fe na nb nc nd b">center</code></li><li id="a49d" class="mr ms it kx b ky ne lb nf le ng li nh lm ni lq mw mx my mz bi translated">将宽度改为<code class="fe na nb nc nd b">500px</code></li></ol><p id="49e6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">另一个流行的JavaScript库，<a class="ae nj" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> expressjs </a>利用方法链接为开发人员提供了一个简单而健壮的API。</p><p id="9a78" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下是取自他们的<a class="ae nj" href="https://expressjs.com/en/guide/error-handling.html" rel="noopener ugc nofollow" target="_blank">错误处理</a>页面的一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d923" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">逻辑隐藏在实现中，并返回<code class="fe na nb nc nd b">this</code>以允许方法链接继续:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="536d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae nj" href="https://github.com/dsherret/code-block-writer" rel="noopener ugc nofollow" target="_blank">代码块编写器</a>使得用方法链接api编写代码变得容易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="e25b" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">构建器模式</h1><p id="92d4" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">构建器模式本质上使用方法链接来实现它的目标。根据定义，构建器是一个<a class="ae nj" href="https://en.wikipedia.org/wiki/Creational_pattern" rel="noopener ugc nofollow" target="_blank">创造性的</a>设计模式，让你以一步一步的方式构建复杂的对象，有效地简化过程。</p><p id="0bf7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">听起来很像描述方法链的方式，不是吗？</p><p id="9c91" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们要创建一个<code class="fe na nb nc nd b">Chicken</code>类，它的方法是构造它的所有身体部分，我们可以使用生成器来构造一只完整的鸡:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/91344d0e1cddcf8341f505156e2e4370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*JJXTaMOszGYU5wxM.jpg"/></div></figure><p id="b4fd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们不使用构建器，代码可能会变得重复，消费者不清楚他们是否返回值，这迫使他们寻找一些文档:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="13ae" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您以前从未使用过构建器，请看看下面的例子，看看您是否能发现它为我们提供的好处:</p><blockquote class="nk nl nm"><p id="dd0a" class="kv kw lr kx b ky kz ju la lb lc jx ld nn lf lg lh no lj lk ll np ln lo lp lq im bi translated"><em class="it">无建造者</em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><blockquote class="nk nl nm"><p id="f5ef" class="kv kw lr kx b ky kz ju la lb lc jx ld nn lf lg lh no lj lk ll np ln lo lp lq im bi translated"><em class="it">与建造者</em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="560a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过使用构建器，我们节省了多行代码，但是我们也对消费者隐藏了实现细节。隐藏实现是这里最重要的。</p><p id="0330" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是上面代码片段中构建器的实现(是的，我知道它很长，但是请继续听下去):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3950" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">从这一点来看，作为开发人员，我们的工作是创建<em class="lr">高效和可读的代码</em>。</p><p id="fa04" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">是的，我们没有构建器的例子在技术上更短，但是它是可重用的吗？我们将能够与那些能像我们一样容易读懂代码的人一起工作(我们写了代码)。</p><p id="35c1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这两个问题的答案都是否定的。当我们共享我们的代码时(或者甚至当我们试图重用我们的代码时)，我们可以很容易地拿起构建器并重用它，而不是像以前那样。这是因为如果我们试图重用先前的代码，我们必须复制并粘贴代码。</p><p id="a82f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们复制和粘贴时，我们会产生重复的代码。当代码变得重复时，我们必须对api进行双倍的修改。当我们不得不做两三次不必要的修改时，我们的代码就变得<em class="lr">不可维护</em>。builder模式是一个简单但功能强大的模式，可以一次性解决所有这些问题！</p><h1 id="a5c0" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">责任链模式</h1><p id="b77a" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">责任链(COR)是一种允许多个对象发送、接收和处理某些请求的模式。这些对象(仅仅是函数)既不依赖于前一个请求的实现细节，也不依赖于下一个请求的实现细节，并且可以决定在运行它的执行时做什么。它们也可以中止整个链，或者决定让请求继续到链中的下一个对象(或函数)。</p><p id="8e14" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是DOM中使用的模式的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d8df" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">只要功能能够以可控和可预测的方式一个接一个地链接起来，就没有真正的“官方”或正确的方法来实现这种模式。</p><p id="5f15" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">ExpressJS在它们的路由器中也使用这种模式来将中间件处理程序从一个处理程序传递到下一个处理程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ea69" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是如果你想知道处理程序是如何通过<code class="fe na nb nc nd b">next()</code>调用相互链接的，它的工作方式与<a class="ae nj" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">链表</a>数据结构的工作方式完全一样。</p><p id="653d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在实践中没有实现这种模式的正确方法，但是这里有一个将处理程序链接在一起的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/0f44ee9a06ebe8460b5d25f014704dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/0*tyMxICQ_xb9_uLog.png"/></div></figure><h1 id="1b08" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">可选链接</h1><p id="c842" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">访问嵌套对象是一个危险的操作，因为如果我们的代码不处理值为空的情况，或者仅仅是它的原型不是从对象原型继承的，我们可能会被抛出一个<code class="fe na nb nc nd b">TypeError</code>，这会使我们的程序崩溃。</p><p id="bd43" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我的意思是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="29df" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们试图在<code class="fe na nb nc nd b">items</code>被意外设置为非类似对象的数据类型(如<code class="fe na nb nc nd b">null</code>值)时访问<code class="fe na nb nc nd b">buckets.red.items[1]</code>，我们会得到如下令人不快的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3d55" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">JavaScript提供了一种更简单的方法，称为可选链接，它简化了通过连接的对象访问值，这些对象在某个时候可能会变成<code class="fe na nb nc nd b">null</code>或对象之外的任何东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="d5f2" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">承诺链</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b2cb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过将承诺链接在一起，您可以编写异步代码，其中您的每个函数都将被承诺(字面上)及时接收它们的数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="224d" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">结论</h1><p id="e220" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">本帖到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>