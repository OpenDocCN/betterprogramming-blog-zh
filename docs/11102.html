<html>
<head>
<title>Flutter Blocs: A Simple Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤动块:简单介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/flutter-blocs-a-simple-introduction-8e948456d741?source=collection_archive---------3-----------------------#2022-02-18">https://betterprogramming.pub/flutter-blocs-a-simple-introduction-8e948456d741?source=collection_archive---------3-----------------------#2022-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e9c1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在项目中使用颤振块的逐步指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2cde4113b977cbb2603629ea8e9e3f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywReNjO4GN9Hu65eo1rRCA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@kalaniparker?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯伦·瑞金</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="e41f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你觉得理解正在工作的flutter_blocs库很难吗？或者您知道它，但在实现它时可能会感到困惑？别担心，我们会一步一步来，详细了解每件事。</p><p id="c13c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flutter blocs提供了一种简单的方法来处理应用程序中的不同状态，一旦你理解了它，它就很容易使用并扩展到任何规模的应用程序</p><h1 id="2e4a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">为什么我们还要使用颤振模块？</strong></h1><blockquote class="mk ml mm"><p id="f660" class="kw kx mn ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated"><em class="iq"> Bloc使得将表示从业务逻辑中分离出来变得容易，使得你的代码</em>快速<em class="iq">，</em>易于测试<em class="iq">，</em>可重用<em class="iq">。—官方封锁文件</em></p></blockquote><p id="0598" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flutter Blocs简化了应用程序中的状态管理，它提供了简单的API来使用，抽象了许多细节，使状态管理更容易，它是Flutter中最受欢迎的状态管理库之一，由<a class="ae kv" href="https://github.com/felangel" rel="noopener ugc nofollow" target="_blank">菲利克斯·安杰洛夫</a>和其他开源贡献者积极维护。</p><p id="8e69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，Blocs处理所有的业务逻辑，无论是与数据层交互，还是在UI上显示某些内容或一些复杂的计算。</p><p id="7056" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">但是，什么是状态管理？难道我们不能忽略它，我的意思是我们不用它在Android或iOS上？</strong></p><p id="17c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不，我们不能，因为Flutter是一个声明式框架，它构建自己的UI来显示应用程序的当前状态，所以每当应用程序的状态发生变化时，我们都会触发UI的重绘，所以基本上每个状态都有一些UI，或者像官方文档所说的那样，“UI是应用程序状态的功能”。</p><p id="78ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，—</p><ul class=""><li id="f2b0" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">网络不可用状态下，你显示一个小吃店。</li><li id="92db" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">获取数据状态，你显示一个加载指示器</li><li id="e3ec" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">数据被获取状态，显示一个包含数据的文本小部件，等等。</li></ul><p id="e15c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，在flutter中有多种状态管理解决方案，但flutter_bloc是最流行的一种。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="594b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将添加<a class="ae kv" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank"> flutter_bloc </a>插件作为我们应用程序的依赖项，检查最新版本的库，并将其添加到您项目的<code class="fe nm nn no np b">pubspec.yml</code>文件中，在依赖项部分下，缩进应该是正确的，检查下图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/3261358de69f39fa38e5c6412dad4f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eS3LqW_vf94jENFwlih4A.png"/></div></div></figure><p id="924b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在IDE中添加一个bloc扩展(可用于VSCode和Android Studio ),因为它有助于生成bloc文件并减少大量样板文件。</p><p id="422e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加扩展名后，创建一个文件夹来存储bloc文件，并在文件夹上执行Cmd+N，您将在下拉列表中看到一个Bloc类选项，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/f2fcaefb02617be9ed86ef018dfb2cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVTV2y7b2fK8CzvjdRYuLg.png"/></div></div></figure><p id="0adb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提供一个名字给你的集团，你也可以选择使用公平。这会生成三个文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/6bcfedb4e86fdcf80a413175e77dabd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPceiNO15T9bEcARpgI_rQ.png"/></div></div></figure><p id="a222" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将一个接一个地介绍它们，但在此之前，让我们看一个非常简单的图表来理解这些组件，以及它们如何与UI交互？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/b9e6ed765e162e8a5303960dc6dd2ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uBPdIa2KfYv3dqmjNnSdg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://bloclibrary.dev/#/" rel="noopener ugc nofollow" target="_blank"> Bloc图书馆官方文件</a></p></figure><p id="003b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以很简单明了，不是吗？这包括四个步骤，</p><ul class=""><li id="d424" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">UI触发一个事件。</li><li id="13ce" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">Bloc read的事件运行一些商业逻辑。</li><li id="8c59" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">计算完成后，Bloc发出一个状态。</li><li id="ad31" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">UI监听状态并相应地更新自己。</li></ul><p id="0fa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是三个文件，Bloc、event和state，检查一下你可以忽略的代码片段“稍后会用到”，注释我将在下一节中引用它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5d5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于代码片段的每一行都有一个注释，希望您对这三个文件的作用有所了解，也可以将这些组件可视化，如上面的块架构图所示。</p><p id="31b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经定义了块层，现在让我们构建一个简单的UI来看看，我们如何使用这个<code class="fe nm nn no np b">LoginBloc</code>？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f04a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以在UI中，我们添加了一个文本和按钮，点击按钮我们将改变文本。我们将在按钮上触发一个事件，该事件将从Bloc中获取一个我们将显示的文本。</p><p id="538b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等！<code class="fe nm nn no np b">LoginScreen</code>将如何了解<code class="fe nm nn no np b">LoginBloc</code>？</p><p id="47b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">啊！颤振集团已经有一个非常优雅的解决方案。由于微件在Flutter中无处不在，flutter blocs提供了许多有用的微件，随着例子的进展，我们将在下一节研究其中的一些微件。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="69ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将讨论三个问题，以开始使用该模块</p><h2 id="8fd6" class="nw lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated"><strong class="ak"> 1。如何让Bloc对Widget树(UI)可用？</strong></h2><p id="d52f" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">提供该功能的小部件是BlocProvider小部件，BlocProvider使bloc对整个小部件树可用，这在<code class="fe nm nn no np b">child</code>参数中传递。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1394" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们创建了一个<code class="fe nm nn no np b">LoginBloc</code>的新实例，并且作为一个孩子，我们传递了我们的<code class="fe nm nn no np b">LoginScreen</code>的实例，因此Bloc Provider使<code class="fe nm nn no np b">LoginBloc</code>对<code class="fe nm nn no np b">LoginScreen</code>的小部件树可用，Bloc Provider自动处理Bloc的关闭。</p><h2 id="d080" class="nw lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">2.<strong class="ak">如何从UI触发某个动作的事件？</strong></h2><p id="1613" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">现在我们已经在小部件树上设置了Bloc，我们可以从任何地方访问它，有两种方法可以做到这一点</p><p id="414a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">a.利用上下文，</p><pre class="kg kh ki kj gt on np oo op aw oq bi"><span id="93a6" class="nw lt iq np b gy or os l ot ou">context.read&lt;BlocA&gt;();</span></pre><p id="ad21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">b.使用块提供程序，</p><pre class="kg kh ki kj gt on np oo op aw oq bi"><span id="38b6" class="nw lt iq np b gy or os l ot ou">BlocProvider.of&lt;BlocA&gt;(context)</span></pre><p id="9b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mn">但是有什么区别呢？什么时候应该用哪一个？</em></p><p id="9591" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上没有太大区别，两者几乎相同，但第一个被定义为对<code class="fe nm nn no np b">BuildContext</code>的扩展，所以更容易使用。你喜欢哪个就进行哪个。</p><p id="cdb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在块上添加一个按钮点击事件，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><blockquote class="mk ml mm"><p id="e5e4" class="kw kx mn ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated">注意:—传递块的正确类型很重要，因为它试图查找树来找到该类型的实例，<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/exploring-inherited-widget-in-flutter-10ab959017cb">您可以在这里阅读更多内容。</a></p></blockquote><p id="3b2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到事件，看看从UI触发事件有多容易，我们只需调用块上的<code class="fe nm nn no np b">add</code>方法，并传递一个事件的实例。</p><p id="9875" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要返回到Bloc，检查我们是否已经注册了从UI发送的这个事件，在收到这个事件时，我们将发出一个状态，并在UI上显示一个字符串，您可以参考上面附加的Bloc代码，只需取消所有代码的注释“将在以后使用”。太好了，就这样。</p><h2 id="4748" class="nw lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">3.<strong class="ak">但是当一个新的状态发出时，UI将如何更新自己呢？</strong></h2><p id="1100" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">是的，你猜对了，这也有一个小部件。这叫做集团消费者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8b48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下<code class="fe nm nn no np b">BlocConsumer</code>，虽然上面的例子包含了整个<code class="fe nm nn no np b">LoginScreen</code>，但是现在，你只需要关注<code class="fe nm nn no np b">_buildScaffoldBody</code>函数。</p><p id="3e48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你注意到了<code class="fe nm nn no np b">BlocConsumer</code>，有四个论点让我们一个一个来看，</p><p id="3f43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">builder</code> —它重建小部件树以响应状态变化，这意味着每当您发出新状态时，它将重建小部件，以便您可以使用从块发出的状态中发送的值。所以在这个例子中，我们已经在<code class="fe nm nn no np b">UpdateTextState</code>中传递了来自bloc的文本，并在UI上使用它，每当“Tap me！!"点击按钮。</p><p id="f9cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">listener</code> —因此，每当发出一个状态时，监听器也会被调用，但与builder不同，它不会返回任何小部件。它在每次状态改变时被调用一次，这就是为什么我们通常使用一个在状态改变时发生一次的侦听器，比如显示一个小吃店、对话框、底部表单或导航到下一个屏幕。</p><p id="0847" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">buildWhen</code> —这是一个可选参数，它提供以前和当前的状态，并返回一个布尔值，因此如果我们返回true，它将调用构建器，否则，如果您不使用此参数，每次状态改变时都会调用构建器。</p><p id="f83e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">listenWhen</code> —这与<code class="fe nm nn no np b">buildWhen</code>类似，但用于控制监听器，如果它返回true，则监听器被调用。</p><p id="26aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以在我们的例子中，我们使用Listener作为<code class="fe nm nn no np b">ShowSnackBar</code>状态，它显示了一个小吃店，当点击按钮时会显示一个文本。我们正在为<code class="fe nm nn no np b">LoginInitial</code>、<code class="fe nm nn no np b">UpdateTextState</code>使用builder，当点击一个按钮时，它会更新屏幕上的文本。</p><p id="cc05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个值得注意的有趣的地方是，<code class="fe nm nn no np b">BlocConsumer</code>接受一个可选的参数块，如果你不提供它，它会尝试使用<code class="fe nm nn no np b">BlocProvider</code>和当前的<code class="fe nm nn no np b">BuildContext</code>来查找。因此，如果您错过了注入Bloc(问题1 ),它将抛出一个异常。</p><p id="0b83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些情况下，你要么想使用<code class="fe nm nn no np b">builder</code>或<code class="fe nm nn no np b">listener</code>，对于这种情况，有不同的<code class="fe nm nn no np b">BlocBuilder</code>和<code class="fe nm nn no np b">BlocListener</code>部件，请随意探索它们，Flutter blocs也提供了一些其他有用的部件，但那是改天的事了。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="82bc" class="ls lt iq bd lu lv ov lx ly lz ow mb mc jw ox jx me jz oy ka mg kc oz kd mi mj bi translated">摘要</h1><ol class=""><li id="0aa1" class="mr ms iq ky b kz oi lc oj lf pa lj pb ln pc lr pd mx my mz bi translated">构建一个UI(你有一些业务逻辑要运行？).</li><li id="3f0c" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr pd mx my mz bi translated">创建块(块、事件和状态类)。</li><li id="53e0" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr pd mx my mz bi translated">将它们绑定在一起(还记得那三个问题吗？).</li><li id="a7db" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr pd mx my mz bi translated">使用<code class="fe nm nn no np b">BlocProvider</code>初始化块，使其可用于微件树。</li><li id="a394" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr pd mx my mz bi translated">使用上下文查找块，以便可以添加事件。</li><li id="ed8a" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr pd mx my mz bi translated">在块中执行您的业务逻辑并发出结果。</li><li id="4338" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr pd mx my mz bi translated">使用<code class="fe nm nn no np b">BlocConsumer</code>、<code class="fe nm nn no np b">BlocBuilder</code>、<code class="fe nm nn no np b">BlocListener</code>，监听状态变化并相应地执行动作。</li></ol><h1 id="ffee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">有用的资源</h1><ul class=""><li id="3b8f" class="mr ms iq ky b kz oi lc oj lf pa lj pb ln pc lr mw mx my mz bi translated"><a class="ae kv" href="https://gist.github.com/Sumit-Ghosh/50f1a2c636eba6dcf7414c4dec734091" rel="noopener ugc nofollow" target="_blank"> FlutterBloc官方文档</a></li><li id="8feb" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=knMvKPKBzGE" rel="noopener ugc nofollow" target="_blank">费利克斯在欧洲的演讲</a></li><li id="9382" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=THCkkQ-V1-8" rel="noopener ugc nofollow" target="_blank"> Flutterly Bloc的教程</a></li></ul></div></div>    
</body>
</html>