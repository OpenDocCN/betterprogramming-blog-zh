<html>
<head>
<title>How To Use the Underscore (_) Properly in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中正确使用下划线(_)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-underscore-properly-in-python-37df5e05ba4c?source=collection_archive---------1-----------------------#2022-09-06">https://betterprogramming.pub/how-to-use-underscore-properly-in-python-37df5e05ba4c?source=collection_archive---------1-----------------------#2022-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa68" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你可能没有意识到它的所有含义</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1ee1624fd15bc2e4d5ef3e14c32b561e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XsXyIqInJJW2xKTj"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@drew_beamer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上绘制光束</a></p></figure><p id="8a4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下划线或下划线(<code class="fe ls lt lu lv b">_</code>)在Python中有许多用途，在开始这篇文章之前，我对其中每一个都有一些误解。我做了假设，阅读了不准确的信息，甚至从我参加的在线Python课程中收到了一个不完整的故事。</p><p id="6845" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将演示下划线的用法，并就如何处理它给出我非常偏颇的建议。</p><p id="652a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将介绍<code class="fe ls lt lu lv b">_</code>的以下用法:</p><ul class=""><li id="4ba3" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">它可以优雅地用作循环和赋值语句中的临时变量。</li><li id="56af" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">单(<code class="fe ls lt lu lv b">_</code>)和双(<code class="fe ls lt lu lv b">__</code>)下划线都可以在类变量名前添加，以表明该变量应该是私有的。它能让你的变量保密吗？有什么区别？</li><li id="9d5c" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">它可以在函数名前面加上前缀，以表明函数应该是私有的。下划线让你的函数保持私有吗？</li></ul><h1 id="4baa" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">1.下划线作为临时变量</h1><p id="7d04" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated"><code class="fe ls lt lu lv b">_</code>可以在循环和赋值语句中代替“虚拟”变量，在这些语句中，函数返回多个值，而你想忽略其中的一个或多个值。</p><h2 id="9084" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">在循环中使用</h2><p id="ea0e" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">如果你需要Python做一件事五次，最明显的方法是在for循环中使用一个虚拟变量，如下所示。当我使用虚拟变量时，我巧妙地称它为… <code class="fe ls lt lu lv b">dummy</code>。下面显示的这种语法的缺点是我不得不创建一个变量名，并希望任何阅读我的代码的人都清楚我再也不会使用<code class="fe ls lt lu lv b">dummy</code>。</p><p id="ad2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个简短的代码片段中很容易看出这一点，但是如果循环更长更复杂，就不那么明显了。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="bead" class="nh ml iq lv b gy nx ny l nz oa">for dummy in range(5):<br/>    print("Hello world")</span></pre><p id="8af6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以用<code class="fe ls lt lu lv b">_</code>代替。下面的代码片段使用<code class="fe ls lt lu lv b">_</code>来达到同样的结果，同时向任何阅读代码的人发出信号，我不打算在代码中的任何地方使用循环控制变量。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="94b3" class="nh ml iq lv b gy nx ny l nz oa">for _ in range(5):<br/>    print("Hello world")</span></pre><p id="4354" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢这种语法，并鼓励其他人使用它。然而，我没有意识到Python像跟踪任何其他变量一样跟踪<code class="fe ls lt lu lv b">_</code>的值！考虑下面的片段；它打印整数<code class="fe ls lt lu lv b">0</code>到<code class="fe ls lt lu lv b">4</code>:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="7cff" class="nh ml iq lv b gy nx ny l nz oa">for _ in range(5):<br/>    print(_)</span></pre><p id="7a0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下划线甚至可以在嵌套循环中工作，但是跟踪<code class="fe ls lt lu lv b">_</code>变量的值会变得更加混乱。考虑下面这个循环。你认为这段代码会产生什么？您认为这段代码完成后会在<code class="fe ls lt lu lv b">_</code>中存储什么？</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="d17f" class="nh ml iq lv b gy nx ny l nz oa">for _ in ['A','B','C']:<br/>    print(_, end=": ")<br/>    for _ in range(4):<br/>        print(_, end=",")  # what will this line print?<br/>    print()                # newline</span></pre><p id="eb8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是上面代码的输出:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="5cc3" class="nh ml iq lv b gy nx ny l nz oa">A: 0,1,2,3,<br/>B: 0,1,2,3,<br/>C: 0,1,2,3,</span></pre><p id="41f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许上面的输出没有让你惊讶，但是让我惊讶了。当嵌套的for循环完成时，你认为<code class="fe ls lt lu lv b">_</code>代表什么值？它会包含有效值吗？</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="d8c3" class="nh ml iq lv b gy nx ny l nz oa">for _ in ['A','B','C']:<br/>    pass<br/>    for _ in range(4):<br/>        pass</span><span id="bd4c" class="nh ml iq lv b gy ob ny l nz oa">print(_)               # what will this line print?</span></pre><p id="f81c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很惊讶上面的代码打印的是<code class="fe ls lt lu lv b">3</code>。我期待它是无效的或打印<code class="fe ls lt lu lv b">C</code>。正在发生的事情其实很简单。for循环的每次迭代都将<code class="fe ls lt lu lv b">_</code>赋给迭代器中的下一个值。外部for循环简单地将<code class="fe ls lt lu lv b">_</code>赋给<code class="fe ls lt lu lv b">[‘A’,'B’,’C']</code>中的下一个值，内部for循环将<code class="fe ls lt lu lv b">_</code>赋给迭代器<code class="fe ls lt lu lv b">range(4)</code>中的下一个值。</p><p id="0380" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种困惑让我想到了我的第一个建议:</p><blockquote class="oc od oe"><p id="fc4e" class="kw kx of ky b kz la jr lb lc ld ju le og lg lh li oh lk ll lm oi lo lp lq lr ij bi translated">不要使用下划线作为函数或操作的输入。如果你需要跟踪一个变量，花时间给它一个描述性的名字。</p></blockquote><h2 id="7cb5" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">忽略返回值</h2><p id="a953" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">一些Python函数返回多个值，但我通常不需要所有这些值。<code class="fe ls lt lu lv b">_</code>表示我忽略了那个值。假设我们有一个返回数据集的均值、众数和标准差的函数，但是我们现在只关心标准差。我们可以这样写:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="d7bb" class="nh ml iq lv b gy nx ny l nz oa">_, _, stdev = myfunction(large_dataset)</span></pre><p id="d68d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码告诉任何阅读我的代码的人，我只打算使用由<code class="fe ls lt lu lv b">myfunction</code>返回的三个值中的一个。比起声明两个永远不会用到的额外变量，我更喜欢这个语法。然而，在幕后，Python存储了<code class="fe ls lt lu lv b">_</code>的值—但是是哪个呢？当一行给<code class="fe ls lt lu lv b">_</code>分配了两个不同的值时，你认为下面的代码会打印出什么？</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="b2a9" class="nh ml iq lv b gy nx ny l nz oa">_, _, stdev = myfunction(large_dataset)<br/>print(_)       # what will this line print?</span></pre><p id="f34b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码将显示由<code class="fe ls lt lu lv b">myfunction</code>返回的第二个值。我不知道会发生什么，直到我在Python REPL中进行了如下测试:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="7a82" class="nh ml iq lv b gy nx ny l nz oa">&gt;&gt;&gt; _, _, stdev = (1, 2, 3)<br/>&gt;&gt;&gt; print(_)<br/>2</span></pre><p id="216f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种困惑让我稍微修改了一下我之前给出的建议。</p><blockquote class="oc od oe"><p id="944d" class="kw kx of ky b kz la jr lb lc ld ju le og lg lh li oh lk ll lm oi lo lp lq lr ij bi translated">使用下划线可以忽略函数返回的值。不要使用下划线作为函数或操作的输入。如果你需要跟踪一个变量，花时间给它一个描述性的名字。</p></blockquote><h1 id="637b" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">2.下划线表示类属性是私有的</h1><p id="a148" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">使用下划线向那些阅读和使用代码的人发出信号，您希望变量是私有的，但遗憾的是Python并没有强制执行您的意图。考虑下面这个荒谬的Python类，它定义了两个局部变量，一个以单下划线为前缀，另一个以两个下划线为前缀。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="6ec7" class="nh ml iq lv b gy nx ny l nz oa">class MyClass:<br/>    def __init__(self):<br/>        self._myprivate = 12<br/>        self.__myreallyprivate = 42</span></pre><p id="c57c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这个类的任何人都可以很容易地直接访问这些变量，即使我希望这些变量是私有的。Python对单下划线和双下划线的处理是不同的(我一会儿会解释这一点)，但是在Python中没有办法像在Java或C++中那样真正使类变量私有。下面两行代码将显示这两个变量都可以直接读写:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="5fee" class="nh ml iq lv b gy nx ny l nz oa">instance = MyClass()<br/>print(dir(instance))</span></pre><p id="250f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类实例的<code class="fe ls lt lu lv b">dir</code>列表显示了<code class="fe ls lt lu lv b">_myprivate</code>(单下划线)和<code class="fe ls lt lu lv b">__myreallyprivate</code>(双下划线)之间唯一的区别是<code class="fe ls lt lu lv b">__myreallyprivate</code>稍微有些模糊。我可以像这样覆盖作者原本打算私有的两个变量:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="95df" class="nh ml iq lv b gy nx ny l nz oa">instance._myprivate = 'overwritten!!'<br/>instance._MyClass__myreallyprivate = 'overwritten!!'</span></pre><p id="ecd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能想知道如果用一个简单的<code class="fe ls lt lu lv b">dir</code>或者通过阅读Python文档就能很容易地检测出<code class="fe ls lt lu lv b">__myreallyprivate </code>的混淆的目的是什么。当您创建具有相同局部变量名的子类时，这种混淆会很方便。</p><p id="8d60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将用一个更简单的超类和子类的例子来说明这一点，它们都实现了变量<code class="fe ls lt lu lv b">__private</code>。考虑以下类定义:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="b0cd" class="nh ml iq lv b gy nx ny l nz oa">class Parent:<br/>    def __init__(self):<br/>        self.__private = 42</span><span id="493b" class="nh ml iq lv b gy ob ny l nz oa">class Child(Parent):<br/>    def __init__(self):<br/>        super().__init__()<br/>        self.__private = 52</span></pre><p id="6ec9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的子类将有两个模糊变量。我可以用下面的代码显示这些变量:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="288c" class="nh ml iq lv b gy nx ny l nz oa">mychild = Child()<br/>print(mychild._Parent__private)   # prints 42<br/>print(mychild._Child__private)    # prints 52</span></pre><p id="be1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些关于类变量名中的单下划线和双下划线的观察给了我一些建议:</p><p id="ef3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您是某个类的作者:</p><ul class=""><li id="c690" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">为您希望类的使用者读取的每个局部变量提供一个“get”方法。</li><li id="ec24" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">使用下划线表示变量应该被认为是私有的。</li></ul><p id="2180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是其他人写的类的消费者:</p><ul class=""><li id="503b" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">尽可能避免直接访问类局部变量。</li><li id="2107" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">绝对避免直接访问带有下划线的类变量。作者将下划线(或一对下划线)放在那里是有原因。</li></ul><h1 id="0073" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">3.下划线表示函数是私有的</h1><p id="7b4d" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">与类变量一样，<code class="fe ls lt lu lv b">_</code>用于表示将函数私有的意图，但是Python也不强制这样做。考虑一个名为<code class="fe ls lt lu lv b">my_functions.py</code>的Python文件，其函数定义如下:</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="5770" class="nh ml iq lv b gy nx ny l nz oa">def _private():<br/>    return 'Hello world'</span></pre><p id="3d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我用类似于<code class="fe ls lt lu lv b">import my_functions</code>的通用导入语句导入这个Python模块，那么我仍然可以很容易地访问我试图标记为私有的模块。这根本不是函数<code class="fe ls lt lu lv b">_private</code>的作者想要的。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="8492" class="nh ml iq lv b gy nx ny l nz oa">&gt;&gt;&gt; import my_functions<br/>&gt;&gt;&gt; my_functions._private<br/>'Hello world'</span></pre><p id="0520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何函数——甚至私有函数——都可以显式导入，如下所示。同样，这根本不是函数<code class="fe ls lt lu lv b">_private</code>的作者想要的。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="ce43" class="nh ml iq lv b gy nx ny l nz oa">&gt;&gt;&gt; from my_functions import _private<br/>&gt;&gt;&gt; _private()<br/>'Hello world'</span></pre><p id="c8e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我甚至可以为私有函数创建一个别名，这样我就不会经常被提醒我正在使用私有函数。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="2c5d" class="nh ml iq lv b gy nx ny l nz oa">&gt;&gt;&gt; from my_functions import _private as p<br/>&gt;&gt;&gt; p()<br/>'Hello world'</span></pre><p id="4222" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，私有函数唯一不被导入的时候是使用通配符的时候，但是<a class="ae kv" href="https://peps.python.org/pep-0008/#imports" rel="noopener ugc nofollow" target="_blank"> PEP8 </a>风格指南不鼓励使用通配符，因为它会在名称空间中产生冲突或混淆。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="9c61" class="nh ml iq lv b gy nx ny l nz oa">&gt;&gt;&gt; from my_functions import *<br/>&gt;&gt;&gt; _private()<br/>Traceback (most recent call last):<br/>File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>NameError: name '_private' is not defined</span></pre><p id="a2d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管Python允许什么，不允许什么，我的最后一条建议是:</p><blockquote class="oc od oe"><p id="2608" class="kw kx of ky b kz la jr lb lc ld ju le og lg lh li oh lk ll lm oi lo lp lq lr ij bi translated">即使Python不阻止您这样做，也要避免导入已被标记为私有的函数。</p></blockquote><h1 id="f56c" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">最后的想法</h1><p id="0ae7" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我所有关于<code class="fe ls lt lu lv b">_</code>的建议都是围绕着写代码时表达你的意图和使用他人代码时尊重他人的意图。然而，尊重其他作者的意图并不意味着礼貌。这个建议是关于保护你自己的。</p><p id="3aa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在本文中给出的例子简单易懂。当您使用更复杂的代码时，可能会有您没有预料到的行为。在某些情况下，私有函数或私有变量的行为可能与您预期的不同。</p><p id="a852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，实现这些变量或函数可能会在未来的代码版本中发生变化。毕竟，该代码的作者将它们标记为私有，因此可以随时自由地更改它们。</p><p id="85a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以你要保护好自己，避免使用标记为私有的函数和类变量！</p><p id="246c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这篇文章中的一些内容能让你感到惊讶。快乐强调！</p></div></div>    
</body>
</html>