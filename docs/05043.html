<html>
<head>
<title>7 Quick Kotlin Tips for Android Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android开发人员的7个快速Kotlin技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-quick-kotlin-tips-for-android-developers-884d1021ab1d?source=collection_archive---------3-----------------------#2020-06-03">https://betterprogramming.pub/7-quick-kotlin-tips-for-android-developers-884d1021ab1d?source=collection_archive---------3-----------------------#2020-06-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="4f63" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用Kotlinic的方式写代码，提高你的Android技能</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/df200881bee02d81c08ec48bc507e9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXX8o8hZLmmS_AHYIff3Wg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@louis993546?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">路易·蔡</a>在<a class="ae kz" href="https://unsplash.com/s/photos/kotlin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5705" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Kotlin 的推出是为了让Android开发变得更加容易和快速。在被命名为Android的官方语言后，它已经慢慢接管了Java，成为当今Android开发者的首选。</p><p id="2282" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于转换到Kotlin的Java开发人员来说，这种转换再容易不过了，因为它们有相似之处。但与此同时，人们很容易忽略科特林的独特性，或者更确切地说是惯用的方面。这可能导致编写类似Java的代码。</p><p id="4745" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很高兴，我们可以利用一些<em class="lw">kotrinic</em>(一个受<em class="lw">python</em>启发的术语)的方式在Android中编写不太冗长的代码。让我们开始吧。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="93c6" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">使用“let”函数检查可为空的属性</h1><p id="e27d" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在继续之前，使用“if not null”控制结构对类型进行空检查是相当常见的。使用Kotlin的<code class="fe nb nc nd ne b">let</code>扩展函数有助于避免复杂的分支逻辑。</p><p id="c3cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Kotlin的<code class="fe nb nc nd ne b">let</code>是一个作用域函数，因此在它内部声明的属性不能在外部使用。你可以用它来嵌套<code class="fe nb nc nd ne b">let</code>或者链接一堆可空的。这里有一个例子:</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="ecd0" class="nj mf iu ne b gz nk nl l nm nn">val a: Int? = null<br/>if (a != null) {<br/>    doSomething(a)<br/>}</span><span id="3736" class="nj mf iu ne b gz no nl l nm nn">//less code<br/>a?.let { doSomething(it) }</span></pre><p id="526b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用Kotlin的Elvis操作符(<code class="fe nb nc nd ne b">?:</code>)有助于为可空属性提供默认值。例如，在上面的代码中，您可以调用函数<code class="fe nb nc nd ne b">doSomething(a ?: 0)</code>——从而确保<code class="fe nb nc nd ne b">a</code>有一个默认值。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="c4f9" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">用一行代码生成Kotlin列表</h1><p id="c4b7" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">如果你想创建一个带有默认值的列表，这相当简单。下面一行代码创建一个长度为10的整数数组，每个元素初始化为1。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="399f" class="nj mf iu ne b gz nk nl l nm nn">IntArray(10) { 1 }.asList()</span></pre><p id="3af0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然这既快速又简单，但有人可能想知道如何创建一个包含不同元素的列表。当然，传统的做法是使用<code class="fe nb nc nd ne b">for</code>循环。但是通过利用Kotlin的能力，您可以在一行中完成。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="a210" class="nj mf iu ne b gz nk nl l nm nn">val list = arrayListOf&lt;Int&gt;()<br/>for (x in O until 10 step 2){<br/>list.add (x)<br/>}</span><span id="b377" class="nj mf iu ne b gz no nl l nm nn"><br/>//in a single line<br/>val newList = List(5, {it*2})<br/>//prints: [0,2,4,6,8]</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="4c12" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">使用“要求”或“检查”功能提前退出条件</h1><p id="73e5" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated"><code class="fe nb nc nd ne b">require</code>函数验证传递的参数，如果是<code class="fe nb nc nd ne b">false</code>则抛出一个<code class="fe nb nc nd ne b">IllegalArgumentException</code>。</p><p id="78b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，当对象状态为假时，<code class="fe nb nc nd ne b">check</code>函数抛出<code class="fe nb nc nd ne b">IllegalStateException</code>。</p><p id="4a2e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Android的Kotlin代码库中设置早期退出条件时，这两种方法都很方便。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="bace" class="nj mf iu ne b gz nk nl l nm nn">if (n &lt; 0) {<br/>   throw IllegalArgumentException("message")<br/>}</span><span id="4128" class="nj mf iu ne b gz no nl l nm nn">//use this instead<br/>require(n &gt;= 0) { "Number must no be negative" }</span><span id="01fc" class="nj mf iu ne b gz no nl l nm nn"><br/>//check function throws IllegalStateException<br/>checkNotNull(arg){<br/>"message"<br/>}</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="15f6" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">使用“apply”和“with”函数来减少样板代码</h1><p id="6681" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated"><code class="fe nb nc nd ne b">Apply</code>和<code class="fe nb nc nd ne b">with</code>是两个重要的作用域函数，有助于在设置对象属性时消除对对象的显式引用。在某种程度上，这两个函数都允许您在返回对象之前对其进行转换。</p><p id="5408" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在对象初始化时调用<code class="fe nb nc nd ne b">apply</code>函数，而<code class="fe nb nc nd ne b">with</code>函数需要将对象作为参数传递。</p><p id="4269" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过利用它们，我们可以减少一些样板代码，使我们的代码库清晰简洁。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="03a8" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">“partition”和“groupBy”运算符允许您轻松地拆分列表</h1><p id="e783" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated"><code class="fe nb nc nd ne b">partition</code>允许你将一个列表分成两个子列表，其中第一个包含满足指定条件的元素，其余的放在第二个子列表中。</p><p id="e033" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，<code class="fe nb nc nd ne b">groupBy</code>以键值对的形式返回子列表的映射。通过调用<code class="fe nb nc nd ne b">groupBy</code>上的values属性，可以得到一个列表列表。下面的示例演示了每种方法的一个使用案例。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="5de8" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">用一行代码交换两个属性</h1><p id="8a07" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">交换两个变量是开发人员面临的第一个编程问题。传统上，您需要定义一个临时变量来交换属性。虽然有一种方法可以消除这种情况并将代码减少到两行，但是使用<code class="fe nb nc nd ne b">a = a-b</code>和<code class="fe nb nc nd ne b">b = b-a</code>，我们可以做得更好。</p><p id="2bd1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过使用Kotlin的惯用表达式，可以在一行代码<em class="lw"> </em>中交换两个属性，如下所示:</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="5510" class="nj mf iu ne b gz nk nl l nm nn">a = b.<strong class="ne iv">also</strong> { b = a }</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="bac7" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">对于简单的场景，方法引用优于Lambda表达式</h1><p id="05f9" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">虽然lambda表达式在大多数用例中是好的，但有时当你只需要访问一个属性时，使用方法引用比使用<code class="fe nb nc nd ne b">it</code>更好。</p><p id="f8c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">成员引用用<code class="fe nb nc nd ne b">::</code>表示。类或对象写在左边，它的调用属性写在右边。这里有一个示例场景，使用成员引用代替lambda表达式可以使代码更短、更易于阅读。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="3ab9" class="nj mf iu ne b gz nk nl l nm nn">data class Person(var name: String, var age: Int)</span><span id="80f9" class="nj mf iu ne b gz no nl l nm nn">val listOne = personList.map{it.name}<br/>val listTwo = personList.map{person -&gt; person.name}</span><span id="1499" class="nj mf iu ne b gz no nl l nm nn">//using member reference<br/>val nameList = personList.map(Person::name )</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="adae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">希望你觉得上面提到的科特林招数有用。感谢阅读。</p></div></div>    
</body>
</html>