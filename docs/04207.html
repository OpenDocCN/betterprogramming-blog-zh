<html>
<head>
<title>How to Use Debounce and Throttle in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用去抖和节流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-debounce-and-throttle-in-javascript-da95dc151f7b?source=collection_archive---------8-----------------------#2020-03-30">https://betterprogramming.pub/how-to-use-debounce-and-throttle-in-javascript-da95dc151f7b?source=collection_archive---------8-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a121" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用您可能没有使用的JavaScript方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/316d8953109911c7f9150b94af71d0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LHVep0aI9cIkoHzo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@balazsketyi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Balázs Kétyi </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="46ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有经历过当你向下滚动或者运行一些动画时，你的页面变得非常慢？</p><p id="130c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我过去为仪表板制作画布动画时，仅仅是流畅地呈现每秒钟的动画就需要大量的CPU资源。后来有一天，增加了一个新的需求:当鼠标光标悬停在画布上时，工具提示应该显示出来。这真的要了我的命。我的CPU资源如此耗尽，以至于我的电脑都快冻僵了。</p><p id="daab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过了一段时间，我学会了解决这个问题的方法:节流或去抖。所以在这篇文章中，我想分享它们是什么，为什么它们有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="04e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">阅读前</h1><p id="e244" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你知道JavaScript的异步函数和HOF是如何工作的，你会更容易接受这个理论。你可能会对我其他关于<a class="ae ky" href="https://medium.com/better-programming/be-the-master-of-the-event-loop-in-javascript-part-1-6804cdf6608f" rel="noopener"> JavaScript事件</a>和<a class="ae ky" href="https://medium.com/javascript-in-plain-english/functional-programming-higher-order-function-hof-aaa46bb444bb" rel="noopener">HOF</a>的文章感兴趣。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5d2a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题的一个例子</h1><p id="d4b6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设您想通过API调用来搜索一个国家名称。屏幕上有一个输入框，你可以在里面输入国家名称的字符串。一旦您将字符串放入其中，您的应用程序就会调用API来加载包含您的字符串的所有国家。</p><p id="607a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是CodeSandBox做的一个简短的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试搜索任何国家。</p><p id="dfe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于移动用户或像我这样的懒人，如果您查找国家，会发生以下情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/faedc5285981784aa2e8ca2546695b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/1*j25WLbucg_nMJH9uP5PnDQ.gif"/></div></figure><p id="1dd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">屏幕上的<code class="fe nc nd ne nf b">Request Count</code>指你已经向服务器发送了多少个HTTP请求。请注意，每次按下键盘时，它都会增加，包括退格键。这看起来没问题，但是想象一下你工作的应用程序或者像Airbnb这样的大型应用程序的正常大小。</p><p id="d3f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，每次从键盘或任何用户动作发送请求肯定是太多了。我们需要一个解决方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="307f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">去抖和节流从何而来？</h1><p id="558d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要了解它们到底是什么，我觉得还是告诉你上面这个问题的解决方案背后的想法比较好。</p><p id="f5cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要问题是发送了太多的HTTP请求。假设你想搜索“加拿大”但是如果你的网页因为请求“C”，“Ca”，“Can”，“Cana”等而冻结了。我肯定没有人会高兴。因此，减少请求的需求应运而生。</p><p id="19f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去抖和节流只是实际减少请求的名称。去抖和节流的共同点是一个简单的概念:一旦我的手指按下键盘，在我说可以之前，暂时不要发送任何请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/3e47c0ede5f514e511b257b8a61f74ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4d6AAcxvOIwnSwkTlm8GQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="60e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看上图。它代表了所发生的事情，这取决于具体情况。<code class="fe nc nd ne nf b">Normal</code>每次发送请求。<code class="fe nc nd ne nf b">Throttle</code>在周期内第一次发送请求，并且在周期结束前不再发送请求。一旦周期结束，它再次发送新的请求。<code class="fe nc nd ne nf b">Debounce</code>接受一个将在几毫秒内被调用的回调，并且只要在此期间没有添加额外的请求，就只发送一个请求。看看按下“加拿大”的“n”时的情况。添加了一个额外的请求，按下“a”时添加的前一个请求现在将被忽略。按照这种逻辑，如果所有请求都是在这段时间(几毫秒)内添加的，那么只有最后一个请求会被执行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="539f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">深入研究代码—节流</h1><p id="0687" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好了，现在我们来探究一下代码吧！</p><pre class="kj kk kl km gt nh nf ni nj aw nk bi"><span id="3ad8" class="nl md it nf b gy nm nn l no np">import axios from 'axios';</span><span id="f5e9" class="nl md it nf b gy nq nn l no np">const search = async (city) =&gt;<br/>  await axios.get(`https://restcountries.eu/rest/v2/name/${city}`)</span></pre><p id="b20d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">search</code>是使用样本城市API发送城市的函数。为了让这个例子更加真实，我在测试中使用了真正的restful API。你所需要做的就是在<code class="fe nc nd ne nf b">city</code>中填入城市名称。<a class="ae ky" href="https://restcountries.eu/rest/v2/name/canada" rel="noopener ugc nofollow" target="_blank">自己尝试一下</a>。</p><p id="77ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先看看代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr na l"/></div></figure><p id="abd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个匿名函数是一个返回另一个函数的HOF。第一次调用该函数时，<code class="fe nc nd ne nf b">inThrottle</code>被分配给<code class="fe nc nd ne nf b">false</code>。然后一旦返回的函数被再次调用，<code class="fe nc nd ne nf b">inThrottle</code>被设置为<code class="fe nc nd ne nf b">true</code>，执行回调函数(<code class="fe nc nd ne nf b">fn</code>)。然后<code class="fe nc nd ne nf b">inThrottle</code>在<code class="fe nc nd ne nf b">delay</code>毫秒内再次变为<code class="fe nc nd ne nf b">false</code>，同时<code class="fe nc nd ne nf b">inThrottle</code>为<code class="fe nc nd ne nf b">true</code>时，不能执行<code class="fe nc nd ne nf b">throttle</code>返回的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/f7d608885c5eb5dcf6834854e57edfb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHKS15B_ym_bsCJZHqFdug.png"/></div></div></figure><p id="b10d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你还记得这个吗？例如，即使你一直点击按钮，<code class="fe nc nd ne nf b">Throttle</code>也不允许你连续执行该功能，除非<code class="fe nc nd ne nf b">inThrottle</code>是<code class="fe nc nd ne nf b">false</code>。</p><p id="704e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么新的请求方法应该是这样的:</p><pre class="kj kk kl km gt nh nf ni nj aw nk bi"><span id="cca9" class="nl md it nf b gy nm nn l no np">const sendRequestThrottle = throttle(500, search);</span><span id="6369" class="nl md it nf b gy nq nn l no np">&lt;input type="text" onChange={sendRequestThrottle} /&gt;</span></pre><p id="b7d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有一件事你需要小心。</p><p id="3ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HOF方法<code class="fe nc nd ne nf b">throttle</code>不应包含在React组件中。当组件A中的状态变量被改变时，A被重新渲染，所有的东西都被重新赋值。如果<code class="fe nc nd ne nf b">throttle</code>保持重新渲染，<code class="fe nc nd ne nf b">inThrottle</code>也会被重新分配给<code class="fe nc nd ne nf b">false</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0082" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">深入了解代码——去抖</h1><p id="931d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在让我们来看看<code class="fe nc nd ne nf b">Debounce</code>。这段代码与<code class="fe nc nd ne nf b">Throttle</code>非常相似，所以你也应该很容易理解这一部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr na l"/></div></figure><p id="04d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。超级简单。和<code class="fe nc nd ne nf b">Throttle</code>唯一的区别就是<code class="fe nc nd ne nf b">Debounce</code>不检查<code class="fe nc nd ne nf b">inDebounce</code>是不是<code class="fe nc nd ne nf b">true</code>什么的。如果回调在某个时间段内被执行，它会取消之前将要运行的<code class="fe nc nd ne nf b">setTimeout</code>并创建一个新的。因此，如果你一直快速按下键盘，你的回调将永远不会运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/05b2abe0280869a12b1025d4dcfb05c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egIvSAI-Nj5uV0KFlXjIIg.png"/></div></div></figure><p id="33b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你会更好地理解为什么<code class="fe nc nd ne nf b">Debounce</code>的调用看起来像上图。</p><p id="a62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您所需要做的就是在DOM中注册您的回调:</p><pre class="kj kk kl km gt nh nf ni nj aw nk bi"><span id="2378" class="nl md it nf b gy nm nn l no np">const sendRequestDebounce = debounce(500, search);</span><span id="fa8c" class="nl md it nf b gy nq nn l no np">&lt;input type="text" onChange={sendRequestDebounce} /&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d09f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Lodash中的节流和去抖</h1><p id="60f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在大多数情况下，您不需要编写<code class="fe nc nd ne nf b">Throttle</code>或<code class="fe nc nd ne nf b">Debounce</code>，因为有太多好的轻量级库支持这些特性。<a class="ae ky" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>也是其中之一。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr na l"/></div></figure><p id="8e9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码挺长的，但是看看<code class="fe nc nd ne nf b">debounced</code>函数，是一个HOF:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr na l"/></div></figure><p id="804c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">debounce</code>返回实际执行的新函数(<code class="fe nc nd ne nf b">debounced</code>)。在<code class="fe nc nd ne nf b">debounced</code>内部，使用<code class="fe nc nd ne nf b">lastCallTime</code>。因此您可能会注意到<code class="fe nc nd ne nf b">Lodash</code>中的<code class="fe nc nd ne nf b">debounce</code>可能会将之前的时间(函数之前被调用的时间)与当前的时间(函数当前被调用的时间)进行比较。</p><p id="6abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使这种策略简单一点，代码可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr na l"/></div></figure><p id="2d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你愿意，你可以创建自己的<code class="fe nc nd ne nf b">debounce</code>,但是记住重要的是把函数的执行推迟到以后。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b5a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="f42e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nc nd ne nf b">Debounce</code>和<code class="fe nc nd ne nf b">Throttle</code>都来自于延迟函数执行的需要，因为用户不希望发出太多的HTTP请求。如今，这些都是提高web性能的重要方法。对于任何想要延迟的任务，例如滚动事件，您都可以使用它们中的任何一个。</p></div></div>    
</body>
</html>