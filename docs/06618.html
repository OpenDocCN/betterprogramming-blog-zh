<html>
<head>
<title>5 Git Tricks That I Wish I Had Known Earlier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我希望我能早点知道的5个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-git-tricks-that-i-wished-i-have-known-earlier-af1060881880?source=collection_archive---------7-----------------------#2020-10-19">https://betterprogramming.pub/5-git-tricks-that-i-wished-i-have-known-earlier-af1060881880?source=collection_archive---------7-----------------------#2020-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="35f8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Git lola，更好的分支名称，squashing，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e9d49049c83200ac3efb793217da98de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vm64_oQTGvy-X6iZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c9bc" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak"> 1。运行git lola来可视化提交历史</strong></h1><p id="a205" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当使用Git版本控制时，能够可视化您的Git分支是至关重要的。</p><p id="7c8d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">Git命令可能很长，而且输入起来很乏味。为了在将来节省一些精力，让我们设置一个有用的Git命令来帮助您可视化您的Git分支历史。</p><p id="44bb" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在终端中:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0d43" class="ne lh it na b gy nf ng l nh ni">vim ~/.gitconfig</span></pre><p id="0da5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后在<code class="fe nj nk nl na b">gitconfig</code>文件中，添加以下代码片段:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5747" class="ne lh it na b gy nf ng l nh ni">[alias] lola = log --graph --decorate --pretty=oneline --abbrev-commit --all --date=local</span></pre><p id="8173" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我刚刚克隆了一个全新的项目，它只有最初的承诺。这是来自<code class="fe nj nk nl na b">git lola</code>的提交历史的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/36f5f6ff1570a2c9d216192c3976c2fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*nxkOo62bUlikjj29altZ8g.png"/></div></figure><p id="81db" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><em class="nn">注意:你可以自定义你的命令说</em> <code class="fe nj nk nl na b"><em class="nn">lola</em></code> <em class="nn">以外的话，但这是行业惯例。除非你有充分的理由使用另一个命令，否则就保持这个命令为</em> <code class="fe nj nk nl na b"><em class="nn">lola</em></code> <em class="nn">。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="954b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">2.新分支机构的清晰方便的名称</h1><p id="9029" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">什么时候检查一个新的分支以及给分支取什么名字由你的团队决定。然而，有一些经验法则——尤其是如果您的团队在敏捷环境中工作:</p><ol class=""><li id="2164" class="no np it ma b mb mu me mv mh nq ml nr mp ns mt nt nu nv nw bi translated">特性分支:您可以将分支命名为<code class="fe nj nk nl na b">chat/feature/#12345</code> ( <code class="fe nj nk nl na b">#12345</code>可以是项目过程中的任何类型的引用)。提示:我更喜欢将参考编号放在分行的末尾，因为如果分行名称以英文而不是数字开头，则更容易记住分行名称并点击tab自动完成。</li><li id="0dcc" class="no np it ma b mb nx me ny mh nz ml oa mp ob mt nt nu nv nw bi translated">Bug branch:这是一个类似的想法。可以做<code class="fe nj nk nl na b">chat-styles/bug/#54321</code>。</li></ol><p id="be63" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里，我创建了一个名为<code class="fe nj nk nl na b">chat/feature/#12345</code>的新分支，如上面的例子中所提到的。创建分支后，您可以再次运行<code class="fe nj nk nl na b">git lola</code>来查看您已经创建的新分支。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/f16778709315fbf495a508104c71cad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*O2Zk_s5Yew-_Cv0Jd0HtjA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注意:因为我没有在新分支上进行任何新的提交，git lola显示chat/feature/#12345与主分支具有相同的提交散列。稍后，我们将向这个分支添加更多的提交。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fc7c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">3.运行git add -p，而不是git add。</h1><p id="8b98" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">以前，每当我想暂存所有未暂存的文件时，我只需运行<code class="fe nj nk nl na b">git add .</code>。然而，有时我忘记删除一个<code class="fe nj nk nl na b">TODO</code>注释，一个控制台语句，最后不得不添加另一个只做清理工作的提交。</p><p id="cb36" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当您正在编辑一个已经被Git跟踪的现有文件时，您可以运行<code class="fe nj nk nl na b">git add -p</code>来查看您所做的更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/abc702173e8750d9a4f66491f5703ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*b48ZxEtDRDlQPuG2ad6w0Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在下面的例子中，我第一次创建文件chat.py时，我仍然需要做git add。或者git添加<filename>请求Git开始跟踪文件。但是，对于后面的修改，当我运行git add -p时，它会显示我所做的更改，我可以选择y表示“是”，或者选择n表示“否”，或者只选择q来退出这种交互模式并根据需要更新我的文件。</filename></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/eb629999d9c4351116fa2e594a19d654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*ZJWUNopb1_rO3C00qSrcYg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提交后，这是我运行git lola时显示的内容。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="01f2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">4.挤压提交</h1><p id="24ee" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这里，我向<code class="fe nj nk nl na b">chat/feature/#12345</code>添加了三个额外的提交，向<code class="fe nj nk nl na b">master</code>添加了一个额外的提交，如下面运行<code class="fe nj nk nl na b">git lola</code>所示。</p><p id="19b1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nj nk nl na b">git lola</code>将在左边显示最近提交的分支。最左边的红色垂直线显示了主分支机构的历史记录。我们看到<code class="fe nj nk nl na b">master</code>有两个提交(<code class="fe nj nk nl na b">6769064</code>和<code class="fe nj nk nl na b">b5010ec</code>)，而<code class="fe nj nk nl na b">chat/feature/#12345</code>有提交<code class="fe nj nk nl na b">3886aca</code>、<code class="fe nj nk nl na b">027d0a5</code>、<code class="fe nj nk nl na b">faf5e02</code>和<code class="fe nj nk nl na b">73cee7d</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/b81c78401b629f673e206ef9ddbdd824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*A7kl0b1D4e92P3mv9nWs0A.png"/></div></figure><p id="d777" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">因为我添加的最后一个提交是<code class="fe nj nk nl na b">b5010ec</code>，即使当我从<code class="fe nj nk nl na b">master</code>分支切换到<code class="fe nj nk nl na b">chat/feature/#12345</code>分支时，它仍然在树的最左边显示<code class="fe nj nk nl na b">master</code>分支:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b9a0cfd2db74638bcfe604d16f44e895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*gpWSylAE8ozrOq9A3IQRMQ.png"/></div></figure><p id="c0dd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，让我们在<code class="fe nj nk nl na b">chat/feature/#12345</code>上添加第四个提交消息。如您所见，现在<code class="fe nj nk nl na b">chat/feature/#12345</code>的提交显示在树的最左边。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/96fe1d14ef28dad33ad7797e5623927e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*HiulgD6CEuIQko8ofCEPqA.png"/></div></figure><p id="95d1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">假设我现在已经完成了聊天功能，并希望将其合并到<code class="fe nj nk nl na b">master</code>。与其直接执行<code class="fe nj nk nl na b">git merge chat/feature/#12345</code>，我建议将<code class="fe nj nk nl na b">chat/feature/#12345</code>中的所有提交压缩成一个干净的提交，并将其添加到<code class="fe nj nk nl na b">master</code>。这样，看起来这些特性是在<code class="fe nj nk nl na b">master</code>之上顺序开发的。如果您想稍后恢复您的更改，这也会有所帮助。</p><p id="cb92" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是如何干净利落地粉碎提交的说明:</p><ol class=""><li id="4b6c" class="no np it ma b mb mu me mv mh nq ml nr mp ns mt nt nu nv nw bi translated">找到当前分支的提交分支。在这个例子中，是<code class="fe nj nk nl na b">6769064</code>。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/96fe1d14ef28dad33ad7797e5623927e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*HiulgD6CEuIQko8ofCEPqA.png"/></div></figure><p id="2c9c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">2.运行<code class="fe nj nk nl na b">git rebase -i &lt;branched-off-commit-hash&gt;</code>。<code class="fe nj nk nl na b">-i</code>代表交互，本例中的提交哈希是<code class="fe nj nk nl na b">6769064</code>。确保您位于想要挤压提交的分支上，并运行<code class="fe nj nk nl na b">git rebase -i 6769064</code>。</p><p id="d3d8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一旦我们进入交互模式，您将看到对当前分支的所有提交。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/de1bdcff65749e84b185820f8071be04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*8wURrGgIIE6YTkUHL_kadQ.png"/></div></figure><p id="1499" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">3.从第二次提交开始，将挤压的<code class="fe nj nk nl na b">pick</code>更新为<code class="fe nj nk nl na b">s</code>。在vim中，按<code class="fe nj nk nl na b">i</code>进入插入模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c6e77f17442cb448af0e2450ed9ba9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*zdQ9JyNr2LbtVyQS-eTb3A.png"/></div></figure><p id="9bec" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">完成后，按<code class="fe nj nk nl na b">Esc</code>和<code class="fe nj nk nl na b">:wq</code>保存并退出编辑模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/6bbe81270ccb2474184d5f5a3a0b31b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*_RD8bOCttzfnd5yOTahVcw.png"/></div></div></figure><p id="0aa2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">Git将自动从提交中提取所有的注释。</p><p id="5bec" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">4.删除所有注释，放入一个简洁的注释来总结分支:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/9230dc48d8ca80d4c6316bcca9ebe1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*RGbr0cWc_nPqPdFEdNCokA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我已经将提交消息更新为“#12345]添加聊天核心功能。”</p></figure><p id="0b40" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">提示:按<code class="fe nj nk nl na b">DD</code>删除整行注释，按<code class="fe nj nk nl na b">i</code>再次进入插入模式。</p><p id="7cfe" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">再次按下<code class="fe nj nk nl na b">Esc</code>和<code class="fe nj nk nl na b">:wq</code>保存并退出交互模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/2bfda5129c102cb1a4e88ecf20bc2e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*0hFMO5EjnAr9meq6M6JKbQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现在，它只是特性分支的一个干净的提交。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f131" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">5.如果可以的话，在合并前重设基础</h1><p id="5fa4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">合并只会让Git的历史变得混乱。因此，在合并之前，我尝试先重定基础。这样，当我们将我们的分支合并到<code class="fe nj nk nl na b">master</code>时，<code class="fe nj nk nl na b">master</code>上的提交将是线性的和顺序的，就好像特性是一个接一个开发的一样。如果需要的话，这也使得在<code class="fe nj nk nl na b">master</code>上读取我们的提交历史更加容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e7ee3f2422a17346c082ef4fa1b2fa68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*rUz334q-VvJnbieG4V_GtA.png"/></div></figure><p id="65dc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一旦您重新掌握了master，合并过程将变得快速而简单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/e6d8bf69c0a2b4df4956235fd100697f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*FjFKI2GybEqS51BM6dKd8A.png"/></div></figure><p id="6c34" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">你有它！五个Git技巧让我节省了一些Git历史和合并冲突的痛苦。希望这对您有所帮助！</p></div></div>    
</body>
</html>