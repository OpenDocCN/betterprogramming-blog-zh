<html>
<head>
<title>Running a Flask API Application on Openshift With Nginx As Reverse Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx作为反向代理在Openshift上运行Flask API应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/running-a-flask-api-application-on-openshift-with-nginx-as-reverse-proxy-6f3797f7b4db?source=collection_archive---------8-----------------------#2022-07-29">https://betterprogramming.pub/running-a-flask-api-application-on-openshift-with-nginx-as-reverse-proxy-6f3797f7b4db?source=collection_archive---------8-----------------------#2022-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3153" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用波德曼</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eae8ac689456b16bc7c663a63155bbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXolZfUJgo0oKriYY1FTLw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@cdd20?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">愚木混株 cdd20</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="46a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我上一篇关于在Podman上用Nginx代理运行Flask应用程序的文章中，我解释了如何在Podman上的Nginx反向代理服务器后面配置gunicorn提供的Flask应用程序。我们希望在Red Hat Openshift containers平台上实现同样的结果。要实现这一点，只需做很少的改动。</p><p id="eadb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Openshift上的容器通过服务进行通信。Nginx反向代理必须通过其服务名和端口向Flask应用程序发送流量。</p><p id="7450" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种方法可以启动Openshift的应用程序。对于本文，我选择使用一个预构建的容器映像，我将在本地构建该映像，将其推送到quay.io存储库，并指示我的新Openshift应用程序使用该映像启动一个容器。</p><p id="bd22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，这里是应用程序的文件结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="3720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们看看Flask应用程序Dockerfile。我已经添加了一个在<code class="fe lu lv lw lx b">port 8000</code>上公开应用程序的指令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="31a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Nginx Dockerfile，我们使用Redhat ubi9/nginx-120基本映像，它可以轻松地重新配置为反向代理。在<a class="ae kv" href="https://catalog.redhat.com/software/containers/rhel9/nginx-120/61a609e4bfd4a5234d596286?container-tabs=dockerfile" rel="noopener ugc nofollow" target="_blank">基础映像环境</a>中有一些参数，我们将使用它们来添加我们的定制Nginx配置。基本映像环境包含以下条目:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="27ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的Nginx配置是服务器块，它将定义流量转发到哪里。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="78e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的Nginx反向代理应用程序映像将具有以下Dockerfile指令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7f64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建两个映像并将其推送到quay.io。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2cbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe lu lv lw lx b">oc cli</code>登录Openshift集群。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="c8a7" class="mc md iq lx b gy me mf l mg mh">$ oc login -u &lt;username&gt; &lt;openshift_api_url&gt;<br/>  Password: </span></pre><p id="1627" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个用于Openshift应用程序的项目。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="fa8c" class="mc md iq lx b gy me mf l mg mh">$ oc new-project govtstructure</span></pre><p id="46d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们从quay.io提取图像，所以我们必须对Openshift进行认证，以便能够从图像注册中心提取图像。我们将创建一个包含quay.io API访问令牌的密码，并链接默认服务帐户，以便在提取图像时使用该密码进行身份验证。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="e74e" class="mc md iq lx b gy me mf l mg mh">$ oc create secret generic quayio --from-file \   .dockerconfigjon=${XDG_RUNTIME_DIR}/containers/auth.json \<br/>--type kubernetes.io/dockerconfigjson</span><span id="5247" class="mc md iq lx b gy mi mf l mg mh">#link secret to default service account for pull<br/>$ oc secrets link default quayio --for pull</span></pre><p id="99b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经准备好启动应用程序。我们从Flask应用程序开始。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="5939" class="mc md iq lx b gy me mf l mg mh">$ oc new-app --name govtapplication \<br/>  --image quay.io/wainaina3/govtapplication</span><span id="14cd" class="mc md iq lx b gy mi mf l mg mh">#check all the services which have been launched<br/>$ oc get all -l app=govtapplication</span><span id="150e" class="mc md iq lx b gy mi mf l mg mh">#Verify the application is running<br/>$ oc get pods<br/>NAME                               READY   STATUS    RESTARTS   AGE<br/>govtapplication-858ffb9777-nfgbg   1/1     Running   0        4m53s</span><span id="50c1" class="mc md iq lx b gy mi mf l mg mh">#verify service is up and listening on port 8000<br/>$ oc get svc<br/>NAME            TYPE      CLUSTER-IP     PORT(S)             AGE<br/>govtapplication ClusterIP 172.30.220.218 8000/TCP,8080/TCP   5m57s</span></pre><p id="f0d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">政府应用程序已经启动并运行。接下来，我们可以创建Nginx反向代理应用程序来服务我们的流量。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="3734" class="mc md iq lx b gy me mf l mg mh">#create nginx application with image from quay.io<br/>$ oc new-app --name govtapplication \<br/>  --image quay.io/wainaina3/govtnginxproxy</span></pre><p id="3f07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">验证Nginx容器正在运行，并按照预期监听<code class="fe lu lv lw lx b">port 8181</code>。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="dc81" class="mc md iq lx b gy me mf l mg mh">#Verify application is running as expected<br/>$ oc get pods</span></pre><p id="6f43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有服务都正常，pod运行正常。我们将通过公开Nginx服务来创建一个路由，并显式地选择<code class="fe lu lv lw lx b">port 8181</code>，这样它就可以为我们的Flask应用流量提供服务。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="b36b" class="mc md iq lx b gy me mf l mg mh">$ oc expose svc govtnginxproxy --port 8181</span></pre><p id="d4bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧啊。我们的应用程序现在可以从Nginx路由访问，只需添加以下应用程序路由:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="4a3d" class="mc md iq lx b gy me mf l mg mh">#Get the route<br/>$ oc get routes</span><span id="c616" class="mc md iq lx b gy mi mf l mg mh">#Access the application from the route. use the /sayhello or /getAllCounties(will require database connection) to test</span><span id="0de3" class="mc md iq lx b gy mi mf l mg mh">$ curl http://&lt;route_url&gt;/sayhello<br/>{"greetings":"Hello there"}</span></pre><p id="5d87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在<a class="ae kv" href="https://github.com/Wainaina3/publications/tree/govt" rel="noopener ugc nofollow" target="_blank"> my GitHub </a>资源库中找到应用程序代码。</p></div></div>    
</body>
</html>