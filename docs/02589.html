<html>
<head>
<title>Detecting Truncation in UITextViews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检测UITextViews中的截断</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/detecting-truncation-in-uitextviews-8ab8481da3be?source=collection_archive---------7-----------------------#2019-12-10">https://betterprogramming.pub/detecting-truncation-in-uitextviews-8ab8481da3be?source=collection_archive---------7-----------------------#2019-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ad4a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你的文本视图显示…？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9ac05ff0d600a82fe290936dfd8e3417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsA0Qa1fwLHpeidcZO6jfA.png"/></div></div></figure><p id="b98b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在使用<code class="fe ln lo lp lq b">UITextViews</code>时，你可能会遇到的一个挑战是，它们没有提供一种直接的方法来检测它们是否显示被截断的文本。</p><p id="dfd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ln lo lp lq b">UILabel</code>,您可以通过计算标签中文本的大小并将其与标签本身的边界进行比较来检查截断。如果文本超出边界，则显示为被截断。</p><p id="56cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">UITextView</code>的挑战在于，从设计上来说，它可以容纳比其界限大得多的文本。</p><p id="2ba2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是滚动文本视图操作的本质。这个特性破坏了我们快速检查截断的能力，所以首先，我们需要使用禁用了<em class="lr">滚动的</em>文本视图。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5c86" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决办法</h1><p id="f51b" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">这就是关于<a class="ae mw" href="https://developer.apple.com/documentation/appkit/textkit" rel="noopener ugc nofollow" target="_blank"> TextKit </a>以及iOS如何布局和操作渲染文本的一些知识派上用场的地方。我强烈推荐阅读官方文档<a class="ae mw" href="https://developer.apple.com/documentation/appkit/textkit" rel="noopener ugc nofollow" target="_blank"> TextKit </a>，以及objc.io 的人们所写的这篇精彩的<a class="ae mw" href="https://www.objc.io/issues/5-ios7/getting-to-know-textkit/#cocoa-text-system" rel="noopener ugc nofollow" target="_blank">文章。</a></p><p id="9a45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从现在开始，我假设你至少对iOS中的文本布局有一个粗略的了解。</p><p id="4cd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们不能仅仅依靠<code class="fe ln lo lp lq b">UITextView</code>的边界来进行检查，我们必须依靠文本视图本身中的<code class="fe ln lo lp lq b">NSLayoutManager</code>。</p><p id="f7f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，如果我们有一个文本视图显示如下所示的截断文本，那么我们可以使用下面的代码片段来检测它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/a0fd1cc52dfe4d2b77f3d7225f133327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*GtUjxnCxkO-J3_4O_ESfIg.png"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">尾部截断示例</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="16e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们到底在这里做什么？嗯，<code class="fe ln lo lp lq b">NSLayoutManager</code>使用线条片段来布局文本。这些基本上是定义每行文本边界的矩形。</p><p id="ff03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，objc.io的文章比我在这里所能做的更深入，但是要点是，使用行片段的概念，我们可以要求布局管理器搜索它们来找到我们关心的截断字形(…)。</p><p id="e35a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果找到了，我们就可以停止遍历，并知道我们的文本是以截断的方式呈现的。</p><p id="8a21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">旁注:为什么我们不能在<code class="fe ln lo lp lq b">textContainer.text</code>属性中搜索<code class="fe ln lo lp lq b">...</code>字符呢？</p><p id="1516" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，在引擎盖下，<code class="fe ln lo lp lq b">textContainer</code>根本没有截断字形的概念。在文本最终呈现到屏幕上之前，<code class="fe ln lo lp lq b">NSLayoutManager</code>在上面一层完成了这项工作。</p><p id="bf95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个解决方案本身对于检测尾部截断非常有用。但是，如果textview不够宽或不够高，无法呈现所有文本，该怎么办呢？</p><p id="721e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们需要检查文本容器的字符和字形来进行比较。下面显示了这种textview的一个示例，以及下面详述检测如何工作的代码片段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/6ed1277c6936aaa444a04440256777e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*RSRIswqORd1X6SmeSNQQ6g.png"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">自动换行截断的示例</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4933" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这现在应该涵盖了<code class="fe ln lo lp lq b">lineBreakMode</code>和<code class="fe ln lo lp lq b">byCharWrapping</code> / <code class="fe ln lo lp lq b">byWordWrapping</code>被设置为<code class="fe ln lo lp lq b">byTruncatingTail</code>的两种情况。你可以在这里找到这个解决方案的全部要点。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e5ea" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="a037" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">正如您所看到的，检测某些文本是否以截断的方式显示并不容易。这很可能是苹果的设计，因为它会打开大量的edge外壳，有点违背<code class="fe ln lo lp lq b">UITextView</code>的目的。</p><p id="648c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使有了上面的解决方案，也只能在使用上面列出的三个<code class="fe ln lo lp lq b">lineBreakMode</code>设置时可靠地检测截断。它还要求被检查的textview禁用了<em class="lr">滚动</em>。</p><p id="51e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，你自己斟酌使用。在我的例子中，对这种行为的需求来自于一个产品需求，在这个产品需求中，我们显示简短的注释，并且我们希望允许内联扩展行为。</p><p id="70f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，我想对戴夫·德隆(Dave DeLong)大加赞赏，因为他和我一起坐了很长时间，帮助我找到了这个解决方案，这个方案能够正常运行，大部分功劳都归他。</p><p id="1d04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无论如何，我希望这已经帮到你了，或者至少是一个有益的阅读。如果你在我的解决方案中发现了错误，或者你有不同的解决方法，请在下面留下你的评论。干杯！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="60b1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考资料:</h1><ul class=""><li id="a03a" class="nf ng iq kt b ku mr kx ms la nh le ni li nj lm nk nl nm nn bi translated"><a class="ae mw" href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html" rel="noopener ugc nofollow" target="_blank">苹果开发者——自定义文本处理</a>。</li><li id="0017" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated"><a class="ae mw" href="https://www.objc.io/issues/5-ios7/getting-to-know-textkit/#cocoa-text-system" rel="noopener ugc nofollow" target="_blank">目标io </a></li><li id="c536" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated"><a class="ae mw" href="https://developer.apple.com/documentation/appkit/textkit" rel="noopener ugc nofollow" target="_blank">苹果开发者——text kit</a></li></ul></div></div>    
</body>
</html>