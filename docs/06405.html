<html>
<head>
<title>Running SQL Migrations Before Booting Docker Compose Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在引导Docker合成服务之前运行SQL迁移</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/running-sql-migrations-before-booting-docker-compose-services-a8909bf03cbc?source=collection_archive---------5-----------------------#2020-09-29">https://betterprogramming.pub/running-sql-migrations-before-booting-docker-compose-services-a8909bf03cbc?source=collection_archive---------5-----------------------#2020-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="becd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">拥有丰富的本地开发经验对快乐工程师来说至关重要</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c04ee88541c2cf97ed2e711c2830e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w3erVvkzWjsWvixH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://www.pexels.com/photo/happy-ethnic-woman-sitting-at-table-with-laptop-3769021/" rel="noopener ugc nofollow" target="_blank">像素上的Andrea Piacquadio</a></p></figure><p id="e3a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员乐于进入代码库，开始解决问题，而不是害怕拿起笔记本电脑。随着服务越来越多地被分成单独的“微服务”，新的问题出现了。当我回顾我短暂的职业生涯时，一个让我非常痛苦的问题是SQL迁移以及它们应该如何在Docker Compose中工作。理想情况下，它们应该在web应用程序启动之前运行，这样它们就可以访问结构良好的数据库。您实现这一目标的策略可能因环境而异。在本文中，我将介绍您的本地经验，这很容易扩展到CI，我还将谈到如何在生产中做到这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="54f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一点背景知识</h1><p id="4de6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们开始在堆栈中采用<a class="ae ky" href="https://www.apollographql.com/blog/apollo-federation-f260cf525d21/" rel="noopener ugc nofollow" target="_blank"> Apollo Federation </a>时，我遇到了这个问题。一个网关服务位于我们的其他<a class="ae ky" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>服务之前(它们有自己的数据库)。这个网关是客户端应用程序(图中的“Web浏览器”)查询以获取数据的对象。对于开始使用网关API的客户端，每个依赖的服务都必须是启动的和健康的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/48b5f65e6d1fab314e7412e0a501f76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/0*xdBuqm_VEZJwJywf.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的服务图表</p></figure><p id="f8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的目标是以一种确定的方式启动整个服务集，让每个服务一直等待，直到其依赖的服务运行正常。在本文中，我将重点讨论数据库和迁移，但是这里的概念可以扩展到任何依赖于另一个服务的服务。</p><p id="b34e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行产品服务及其迁移的典型Docker合成文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="864c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个设置有几个问题，主要集中在<code class="fe nc nd ne nf b">depends_on</code>:</p><ol class=""><li id="b3e5" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">当<code class="fe nc nd ne nf b">postgres</code>开始运行时，<code class="fe nc nd ne nf b">products-run-migrations</code>脚本将正确运行，而不是当它健康并准备好接受连接时。当迁移开始运行时，有99%的可能性<code class="fe nc nd ne nf b">postgres</code>容器不健康，导致迁移失败。</li><li id="fd70" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">与<code class="fe nc nd ne nf b">products</code>服务的情况类似。当<code class="fe nc nd ne nf b">products-run-migrations</code>开始运行时，它将正确运行。如果您在健康时查询<code class="fe nc nd ne nf b">products</code>服务，很可能迁移还没有完成。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们想要什么</h1><p id="cc3b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这不是我们目前想要的。理想情况下，开发人员应该能够启动产品服务，当它运行正常时，知道迁移运行成功，并且可以查询它的API。</p><p id="9932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要我做一些研究。</p><p id="055e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现<code class="fe nc nd ne nf b">depends_on</code>有一个<code class="fe nc nd ne nf b">conditions</code>参数，我可以用它来实现我们想要的实现。但接下来我发现事情出了岔子。</p><p id="13d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">我们需要降级我们的Docker撰写版本。</strong></p><p id="0ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，Docker Compose 3.x版本的本意是<a class="ae ky" href="https://github.com/peter-evans/docker-compose-healthcheck/issues/3" rel="noopener ugc nofollow" target="_blank">用于Docker Swarm和Kubernetes环境，在这些环境中，服务并不严格地相互依赖</a>。这促进了服务独立运行的更具容错性的环境。</p><p id="1aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://peterevans.dev/posts/how-to-wait-for-container-x-before-starting-y/" rel="noopener ugc nofollow" target="_blank">我看到人们建议</a>的是切换到Docker Compose 2.4，使用类似<a class="ae ky" href="https://github.com/vishnubob/wait-for-it" rel="noopener ugc nofollow" target="_blank">wait-it</a>的端口等待脚本。</p><p id="5be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的新Docker Compose 2.4文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="14d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些新增内容:</p><ol class=""><li id="68c9" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">在<code class="fe nc nd ne nf b">postgres</code>容器中增加了一个<code class="fe nc nd ne nf b">healthcheck</code>。这使得像<code class="fe nc nd ne nf b">products-run-migrations</code>这样的迁移脚本只有在数据库准备好接受连接时才能开始运行。</li><li id="9802" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们将一个<code class="fe nc nd ne nf b">entrypoint</code>和<code class="fe nc nd ne nf b">condition</code>参数一起添加到我们的迁移映像中。这确保了不仅数据库在运行，而且端口正在返回200响应代码。</li><li id="0d14" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">向<code class="fe nc nd ne nf b">products</code>服务定义中的两个<code class="fe nc nd ne nf b">depends_on</code>添加了<code class="fe nc nd ne nf b">condition</code>参数。</li></ol><p id="7a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它并不完美，但比以前好得多。应用程序在启动前没有等待迁移完全完成的问题仍然存在。如果它们运行得相对较快，本地开发人员可能不会遇到问题。在CI中，我们可以完全控制环境，因此我们可以添加一个额外的命令来绕过这个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="519b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">仍然存在的问题</h1><p id="0647" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我没有提到的是我们的生产环境在Docker Compose方面是什么样的。我们决定维护Docker编写文件的两个版本，一个在2.4，另一个在3.7。这是因为我们想在未来轻松采用Kubernetes。您可能会坚持使用其中的一个，但是为了获得更好的本地开发体验，我们决定始终使用2.4文件。</p></div></div>    
</body>
</html>