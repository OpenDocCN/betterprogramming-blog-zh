<html>
<head>
<title>12 Top iOS Libraries For Your App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的应用程序的12大iOS库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/12-top-ios-libraries-for-your-app-2e9e9d236d3e?source=collection_archive---------3-----------------------#2021-02-22">https://betterprogramming.pub/12-top-ios-libraries-for-your-app-2e9e9d236d3e?source=collection_archive---------3-----------------------#2021-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a965" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不要多此一举，你的问题已经解决了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45047b933d08a51301dcafba272c0919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JwZX37_qMwkMFlSn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@samucabarbosa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塞缪尔·索萨</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="9315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工程学的首要原则之一是不要重新发明轮子。当在一个项目中工作时，每个人都建立在别人写的代码之上。</p><p id="0a3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在非常基础的层面上，我们都使用苹果提供的框架:<code class="fe lv lw lx ly b">Foundation</code>、<code class="fe lv lw lx ly b">UIKit</code>、<code class="fe lv lw lx ly b">StoreKit</code>等等。</p><p id="b388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的是，每个应用程序都有一层与其他应用程序相同的问题。众所周知的问题由成千上万的开发人员使用的库来解决。这有助于使这些库成为一个健壮的、经过测试的、可靠的软件。多亏了这些库，我们可以专注于应用程序的业务逻辑，不再担心网络和持久性等底层任务。</p><p id="d347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我想谈谈我们在<a class="ae ky" href="http://bendingspoons.com" rel="noopener ugc nofollow" target="_blank">Bending soaks</a>使用的最重要的开源库——你也可以使用的库。我将根据它们解决的问题对它们进行分类。所以，我们开始吧！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="49fc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">体系结构</h1><p id="f459" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们需要做出的第一个决定是什么是我们应用程序的最佳架构。苹果力推<a class="ae ky" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC </a>。虽然这对于小型项目来说是一个不错的选择，但是它的伸缩性不好。对于更大的项目，我们正在习惯于<a class="ae ky" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank"> MVVM </a>，如果可能的话，<strong class="lb iu">单向数据流</strong>。</p><p id="a958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种架构伸缩性很好，支持一些高级特性，如模块化和可测试性。然而，它需要一些样板文件。图书馆有助于减少这种样板文件。</p><h2 id="e78c" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">武士刀和天妇罗</h2><div class="kj kk kl km gt ab cb"><figure class="np kn nq nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/be7fc9ccba3e2cca838cb46efd1d09b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*xtMr_VwKoNSgKv6TeX8fTA.png"/></div></figure><figure class="np kn nv nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/7d86a830445c358f606b4b1b900cd948.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*TQ5EaPbqVozfhCF4GNLqhw.png"/></div></figure></div><p id="ba1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们在Bending勺子内部开发的两个库。<a class="ae ky" href="https://github.com/BendingSpoons/katana-swift" rel="noopener ugc nofollow" target="_blank"> Katana </a>实现了单向数据流的概念，并提供了让信息从状态流向UI的基础设施。<a class="ae ky" href="https://github.com/BendingSpoons/tempura-swift" rel="noopener ugc nofollow" target="_blank">天妇罗</a>是MVVM设计模式的实际实现，非常依赖武士刀。</p><p id="27b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在本系列文章的<a class="ae ky" href="https://medium.com/swlh/katana-and-tempura-adding-ui-and-logic-f03026ee47e0?source=your_stories_page-------------------------------------" rel="noopener">中阅读更多关于如何用武士刀和天妇罗建立一个项目的信息。</a></p><h2 id="066e" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">可组合建筑(TCA)</h2><p id="752e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">另一个单向数据流<a class="ae ky" href="https://github.com/pointfreeco/swift-composable-architecture/" rel="noopener ugc nofollow" target="_blank">库</a>更加关注可组合性和可测试性。它比武士刀和天妇罗更严格地遵循<a class="ae ky" href="https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow" rel="noopener ugc nofollow" target="_blank">还原</a>的方法。然而，就其基本形式而言，它在很大程度上依赖于Combine，并且附带了对SwiftUI的开箱即用支持(尽管您可以通过UIKit使用它，编写一个小的包装器)。</p><p id="0efc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://medium.com/swlh/an-app-with-sca-flow-testing-ada82518d313" rel="noopener">系列文章</a>中阅读更多关于如何使用这个架构的内容。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f61f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">建立工作关系网</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/e6a7d9ac1b598bea32807749aea3d9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkOCEhp5g9ixArBdLDwPyw.png"/></div></div></figure><p id="42d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络是另一个大话题。这个比赛真正的冠军只有一个:<a class="ae ky" href="https://github.com/Alamofire/Alamofire" rel="noopener ugc nofollow" target="_blank">阿拉莫菲尔</a>。Alamofire是AFNetworking的快速移植，这是一个来自旧Objective-C世界的历史库。</p><p id="ae28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它在很大程度上简化了配置网络请求和锁定证书，并且抽象了其他几个任务。从版本5开始，它不支持后台下载，但是这个用例出现的频率比您预期的要少。</p><p id="6a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nx">注</em></strong><em class="nx">:2019年9月，苹果发布了Combine。2020年9月，联合收割机改进了很多。有了这个新框架，对网络库的需求将会有所减弱。如果你打算为iOS 13和更高版本创建，那么你可能不需要Alamofire。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ada0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">承诺</h1><p id="dea7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">与网络问题紧密相关的——但不仅仅是这个——是异步代码。闭包是很好的回调——肯定比Objective-C的块好——但是它们仍然会产生著名的<a class="ae ky" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>。</p><p id="be0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Futures_and_promises" rel="noopener ugc nofollow" target="_blank">承诺</a>是处理异步代码时使用回调的更好选择。承诺是一个异步调用的包装器，<em class="nx">承诺</em>最终包含一个预定义类型的值。它们通常带有<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>关键字(或Swift中的方法)——这些关键字让代码等待承诺的执行，并在承诺持有值时让处理继续进行。承诺最好的一点是，它们允许我们将异步代码<em class="nx">写成同步代码</em>。</p><p id="19d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在本文中阅读更多高级承诺的设计模式。</p><p id="e979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注</strong>:2021年9月，苹果可能会发布一个版本的Swift，直接支持该语言的<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>。你可以在这里阅读技术建议书<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" rel="noopener ugc nofollow" target="_blank">。如果是这样的话，promises图书馆可能会在几年内失宠。</a></p><h2 id="7200" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">水螅</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/f91b81abc238debd448829dc70140611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Snk2ZlXbCTjCB4uK_Dn2lg.png"/></div></figure><p id="7cf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你尝试过我们喜爱的武士刀和天妇罗，你会看到他们下载了一个名为<a class="ae ky" href="https://github.com/malcommac/Hydra" rel="noopener ugc nofollow" target="_blank"> Hydra </a>的库。这个库实现了Promise模式。它得到了很好的维护，很好的记录，并且易于使用。试试看！</p><h2 id="9dc6" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">谷歌/承诺</h2><p id="4de7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><a class="ae ky" href="https://github.com/google/promises" rel="noopener ugc nofollow" target="_blank"> Google/Promises </a>是另一个知名的Promises库。它由<a class="ae ky" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase </a>使用，所以如果你已经在使用这种无服务器技术，你可以节省一个依赖。</p><p id="95f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只尝试了一次这个库，发现它比Hydra稍微难用一点，但是这两者在功能上几乎是一样的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4107" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">图像加载</h1><p id="a090" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">迟早，你需要从一个远程URL加载一个图像。令人惊讶的是，这是UIKit长期缺失的特性，而其他语言提供了原生支持这种行为的组件(无论是<a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Image-class.html" rel="noopener ugc nofollow" target="_blank"> Flutter </a>还是<a class="ae ky" href="https://reactnative.dev/docs/image" rel="noopener ugc nofollow" target="_blank"> React Native </a>都有可以从远程URL加载图像的组件)。</p><h2 id="047c" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">阿拉莫菲影像</h2><p id="1838" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个额外的框架，如果我们已经在使用Alamofire，我们可以决定导入它。<a class="ae ky" href="https://github.com/Alamofire/AlamofireImage" rel="noopener ugc nofollow" target="_blank"> AlamofireImage </a>依靠Alamofire下载并缓存图像。</p><p id="25d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从来没有直接使用过这个库，但是它值得一提，因为它与Alamofire有着紧密的联系。</p><h2 id="c567" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">翠鸟</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/1ca3611cba17c8ee33f273a5fd433227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrEOb_gTd3BQrMffBX7T1Q.png"/></div></div></figure><p id="d5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<em class="nx">的</em>镜像加载<a class="ae ky" href="https://github.com/onevcat/Kingfisher" rel="noopener ugc nofollow" target="_blank">库</a>，Github上惊人的18.1k星。它拥有加载图像所需的所有功能。完成、取消、自定义转换器、占位符等等。</p><p id="bde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它非常容易使用，非常容易在你的应用程序中采用——它基于UIKit的<code class="fe lv lw lx ly b">UIImageView</code>！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ed11" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">布局</h1><p id="fa64" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我个人看来，创建布局是UI编码中最无聊的任务之一。由于我们在用代码编写布局时必须处理的抽象层次较低，这项任务甚至更加枯燥。不要让我从约束开始——它们比基于基本<code class="fe lv lw lx ly b">frame</code>的布局复杂得多，苹果已经创造了一种小型语言来更容易地描述它们！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0f2b9b6433677a8d3d26750b4cde7970.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*gxPeVToBsqituVP9euDhPg.png"/></div></figure><p id="e742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们可以利用<a class="ae ky" href="https://github.com/layoutBox/PinLayout" rel="noopener ugc nofollow" target="_blank">引脚布局</a>。这个库允许我们以声明的方式定义布局，描述视图相对于父视图或其兄弟视图的位置。这个库非常强大，可以轻松实现复杂的布局。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a50c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">属性字符串</h1><p id="dadd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">AttributedStrings</code>是苹果的又一个冗长而繁琐的API。它们依赖于属性字典来配置字符串的呈现方式，这使得很难记住这些键以及如何使用它们。</p><p id="b330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您需要实现不同样式的标签，普通的<code class="fe lv lw lx ly b">AttributedStrings</code>API会强制您处理范围和子范围。这些API非常容易出错。</p><p id="1384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这篇文章的<a class="ae ky" href="https://medium.com/swlh/nsattributedstring-unveiled-6c8fb5dce86a?source=your_stories_page-------------------------------------" rel="noopener">中找到所有<code class="fe lv lw lx ly b">AttributedString</code>属性的列表。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5d959e375d03a22048a7001414a71917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*un3wv9_JF6q7O2tnc3cxfA.png"/></div></div></figure><p id="5c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了减少冗长和增加安全性，BonMot是我的首选库。有了这个库，我们可以创建包含样式定义的值，然后我们可以在我们的应用程序中重用这些样式。它支持基于XML的语言在相同的字符串中定义不同的样式，从而消除了所有的复杂性！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1380" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">动画</strong></h1><p id="3f04" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">UIKit提供了一对很好的API来实现动画。我们可以在用于从一个值到另一个值的简单补间的<code class="fe lv lw lx ly b">UIView.animate</code>和用于更精细调整的方法的<code class="fe lv lw lx ly b">animateKeyframes</code>之间进行选择。然而，这两种API都需要在开发方面做一些工作。此外，复杂的动画可能很难用代码优先的方法实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/65376e641c66951e2d6b9f2fa1f27a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aj0HyB9sGXerEmYODsa0HQ.png"/></div></div></figure><p id="bc2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Airbnb来帮忙了。他们开发了<a class="ae ky" href="https://airbnb.design/lottie/" rel="noopener ugc nofollow" target="_blank"> Lottie </a>，一个将After Effects的动画集成到我们的应用程序中的库。这些步骤是:</p><ol class=""><li id="e269" class="od oe it lb b lc ld lf lg li of lm og lq oh lu oi oj ok ol bi translated"><code class="fe lv lw lx ly b">import Lottie</code>。</li><li id="acf1" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">给我们的<code class="fe lv lw lx ly b">UIView</code>添加一个<code class="fe lv lw lx ly b">AnimationView</code>组件</li><li id="7590" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">加载一个<code class="fe lv lw lx ly b">.json</code>。</li><li id="86f8" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">播放<code class="fe lv lw lx ly b">start</code>(通过调用<code class="fe lv lw lx ly b">play()</code>方法。)</li></ol><p id="7aad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nx">注</em> </strong> <em class="nx">:如果你没有动作设计师，可以从这个</em> <a class="ae ky" href="https://lottiefiles.com/featured" rel="noopener ugc nofollow" target="_blank"> <em class="nx">网站</em> </a> <em class="nx">的庞大动画库中选择。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d234" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">InApp采购</h1><p id="4487" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如今，应用内购买(iAP)是一种货币化标准。事实上，许多公司的整个货币化战略都是基于它们。尽管如此，应用内购买还是很难实现。</p><p id="3ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iAP APIs不是闹着玩的。您有一个管理器组件(和一个委托)来从apple服务器检索产品列表(您只获得它们的id！).然后，您需要将这些id与在AppStore Connect上手动创建的一组元信息进行匹配——这些元信息不容易查询。</p><p id="9692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还有一个支付队列(与另一个代理一起)来执行购买/恢复，并监听事务状态的变化。</p><p id="b14d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，你应该验证购买的食谱。如果我们考虑不同的店面、要交付的特殊内容或必须解锁的应用程序部分，一切都会变得更加复杂。</p><h2 id="0453" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">SwiftyStoreKit</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/18985c69c5fa3e7fee304f1f7b5cbe4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVhMj6cZ7O5BuKCOU7SUhg.png"/></div></div></figure><p id="8678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过使用<a class="ae ky" href="https://github.com/bizz84/SwiftyStoreKit" rel="noopener ugc nofollow" target="_blank"> SwiftyStoreKit </a>来忘记所有iAP的复杂性。这是一个Swift库，为您处理所有管理人员和代表。几年前，我们在播放服务中使用它来实现支付，该库为我们提供了很好的服务。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3261" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">奖励:收据验证服务</h1><p id="47b8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">验证收据是一件复杂的事情，出于安全原因，应该在服务器端完成。很可能你没有后端(使用一些无服务器技术，如Firebase)，或者你不知道如何实现后端。有一些服务提供收据验证功能，因此您不必担心实现它们。</p><p id="fa21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从来没有使用过这些服务，所以我不能保证它们工作良好。然而，它们看起来很有趣，而且可以让你省去很多iAP的麻烦。相信我:每次我们不得不与苹果生态系统的这一部分合作时，它总是一场血战。</p><h2 id="e5ff" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">收入类别</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/2f8e9c02ab57d16efa7c5a9725753fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*54K29SOaLPdY9ZerF-oydQ.png"/></div></figure><p id="a759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RevenueCat是一个提供收据验证和一些其他相关服务的服务。它提供了几个集成，免费层允许每月免费处理10k笔交易。使用最低层(0.99美元)，您每月可以免费获得高达1万美元的收入。</p><h2 id="65e8" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">调整</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/649cda0ce3c282a842dcb88d27a998dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOG68IhxuOxv3ewpzK9ntw.png"/></div></div></figure><p id="a59b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://help.adjust.com/en/article/purchase-verification-sdk" rel="noopener ugc nofollow" target="_blank"> Adjust </a>是一项主要用于对来自广告的安装进行归因的服务。然而，它也为iOS和Android提供收据验证服务。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5541" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="ed28" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这篇文章中，我展示了一组我们在<a class="ae ky" href="http://bendingspoons.com" rel="noopener ugc nofollow" target="_blank"> Bending勺子</a>使用或者曾经使用过的库。它们简化了众所周知的问题，让我们专注于应用程序的业务关键部分。它们是构建强大应用程序的坚实起点。</p><p id="3d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为任何人，甚至是独立开发者，都可以从这些库受益，我很确定还有很多其他非常有用的库可以用来解决常见的问题(例如，<a class="ae ky" href="https://github.com/hyperoslo/Cache" rel="noopener ugc nofollow" target="_blank">缓存</a>)。)</p><p id="0654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住:如果你有一个问题，很有可能已经为这个问题开发了一个库。所以，从搜索开始吧！</p></div></div>    
</body>
</html>