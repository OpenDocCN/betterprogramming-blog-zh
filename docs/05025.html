<html>
<head>
<title>An Introduction to Michelson: The Scripting Language of Tezos (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迈克尔逊介绍:Tezos的脚本语言(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-michelson-the-scripting-language-of-tezos-part-2-4cc972c8237c?source=collection_archive---------12-----------------------#2020-06-01">https://betterprogramming.pub/an-introduction-to-michelson-the-scripting-language-of-tezos-part-2-4cc972c8237c?source=collection_archive---------12-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f4a6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用Michelson编程语言并在Tezos上编写智能合同</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b9bec226580ca62cf9694cded067c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XTEXry5Unn2UYtZ7nSpMA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/de/users/comfreak-51581/" rel="noopener ugc nofollow" target="_blank">com break</a>在<a class="ae ky" href="https://pixabay.com/de/illustrations/matrix-code-daten-vernetzung-1735640/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上提供</p></figure><p id="7268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> (Part 1可用</em> <a class="ae ky" href="https://medium.com/better-programming/introduction-to-michelson-the-language-of-tezos-part-1-374c03394cc3" rel="noopener"> <em class="lv">此处</em> </a> <em class="lv">)。)</em></p><p id="7a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前一篇文章中介绍了Michelson的基础知识之后，我们将继续探索这种编程语言。</p><p id="dc35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一期中，我们将介绍一个惊人的工具，它将帮助我们编写、调试和检查我们的迈克尔逊代码:由<a class="ae ky" href="https://baking-bad.org/docs" rel="noopener ugc nofollow" target="_blank"> Baking Bad团队</a>开发的带有迈克尔逊内核的<a class="ae ky" href="https://github.com/baking-bad/michelson-kernel" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本。</a></p><p id="a707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在Michelson中编写一个新的智能合约，使用用户在参数中传递的字符串，我们；在将新字符串保存到存储器中之前，L1连接到存储器中已经存在的字符串。</p><p id="1f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强烈建议先阅读第1部分，因为它介绍了我们将在这里使用的迈克尔逊智能合同的概念。</p><p id="b4c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是首先，让我们看看什么可能是最好的编码工具:迈克尔逊！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1b09" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">烘焙坏的Jupyter笔记本</h1><p id="f66b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Baking Bad开发了一个在线迈克尔逊编译器，超越了编译你的迈克尔逊代码。</p><p id="56bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它提供了语法高亮显示、调试和栈的逐步可视化。在选择<code class="fe na nb nc nd b">MichelsonTutorial-Demo3.ipynb</code>文件之前，你可以使用<a class="ae ky" href="https://mybinder.org/v2/gh/claudebarde/michelson-kernel/binder" rel="noopener ugc nofollow" target="_blank">这个链接</a>打开我们这节课要用的笔记本(记住内核需要一两分钟来加载)。</p><p id="253f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件分为两部分:</p><h2 id="51d6" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">内联代码</h2><p id="9566" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在第一部分中，整个智能合约被放入单个单元格中。您可以通过在下面的单元格中写入<code class="fe na nb nc nd b"><strong class="lb iu">RUN</strong> %default <em class="lv">parameter</em> <em class="lv">storage</em></code>来编译并运行它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/44539434121a4a75067c9552977b2005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSf5X3coAHYdSI_-fuEc9w.png"/></div></div></figure><p id="0c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行智能合约后，有一个详细的描述，说明了每一步和每条指令修改堆栈的内容(在图片上的<code class="fe na nb nc nd b">In [10]</code>)。在运行结束时(在图中的<code class="fe na nb nc nd b">Out [10]</code>),您将获得新的存储。</p><h2 id="1e23" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">循序渐进的代码</h2><p id="4e8d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这个编译器的亮点在于，您可以输入指令来逐个修改堆栈，并在每一步之后检查它们的效果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/0afd29f81f2e131c56c4df7eb934c6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlgnAVfLRtJ6SUiVOX1Nsg.png"/></div></div></figure><p id="6ba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如在每一个迈克尔逊智能合约中一样，首先要指定参数和存储。然后，键入<code class="fe na nb nc nd b"><strong class="lb iu">BEGIN</strong> <em class="lv">parameter</em> <em class="lv">storage</em></code>开始执行。</p><p id="6f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个配置步骤之后，您可以逐个输入指令，并通过点击<code class="fe na nb nc nd b">CMD/CTRL + SHIFT</code>来运行它们，以查看它们如何修改堆栈。在<code class="fe na nb nc nd b">Out [...]</code>单元格中，当前值显示在栈顶。</p><p id="d7c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在步进代码中可以看到一条<code class="fe na nb nc nd b">DUMP</code>指令。这是<em class="lv">而不是</em>迈克尔逊——这只是Jupyter笔记本中用来打印堆栈当前状态的指令。</p><p id="c961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您想要结束智能合约的执行时，您输入<code class="fe na nb nc nd b">COMMIT</code>，它将返回新的存储，前提是您的代码中没有错误。如果在执行的任何一步有一个错误，您将看到一条消息，并且能够立即修复它，而不必逐行检查您的代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1006" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">处理迈克尔逊智能合约中的参数</h1><p id="56ac" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在上一课中，我们介绍了一些指令，这些指令可以处理堆栈中已经存在的数据或我们自己推送的数据。但是如何处理用户的输入呢？这其实很简单！</p><p id="1228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用上面介绍的Jupyter笔记本中的合同。欢迎您跟随笔记本，一条一条地运行指令，以便更好地理解每条指令后堆栈的样子。这是完整的智能合同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/1fe718e842f4eb0ba12d21033d955c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*M1jUOWfZoth0FiWD6QmoPA.png"/></div></figure><p id="f819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还记得，当调用协定时，包含参数和存储的对被自动推到堆栈的顶部。然后，我们可以获得该对的左边部分(参数)并使用它。它是这样工作的。</p><p id="2bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们初始化堆栈:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/ab71eabb75b60a86bfbf47559cf01acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*us-nTkK9uGF0QOgpvVXMJA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初态</p></figure><p id="2bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一步中，我们得到一个新的堆栈，它包含一个类型为<code class="fe na nb nc nd b">string</code> ( <code class="fe na nb nc nd b">world</code>)的参数对和类型为<code class="fe na nb nc nd b">string</code>(<code class="fe na nb nc nd b">Hello</code>)的存储。我们的最终目标是连接这两个字符串并返回它们。</p><p id="a7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一步中，我们复制堆栈的顶部元素，因为我们需要堆栈的两个独立元素中的参数和存储，以便能够将它们放在一个字符串中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/bbf36699d9486b405b03d90522ae31f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XbZTnoy7rmix18UVrK3G7Q.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复制堆栈的顶部元素</p></figure><p id="1741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迈克尔逊没有变量，本质上是不可变的。堆栈的新元素可以用不同的方法创建——例如，通过推送(用<code class="fe na nb nc nd b">PUSH</code>指令)或复制(用<code class="fe na nb nc nd b">DUP</code>指令)。记住，在执行的每一步，你都在处理栈顶元素。这是你唯一可以合作的。</p><p id="10f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从栈的第一个元素开始，让我们从这个对中取出参数。我们使用了<code class="fe na nb nc nd b">CAR</code>指令，它的目的是断开一个类型为<code class="fe na nb nc nd b">pair</code>的元素，并返回该对元素的左侧(在本例中，参数传递给了智能契约)。运行完<code class="fe na nb nc nd b">CAR</code>后，我们剩下栈顶的字符串<code class="fe na nb nc nd b">world</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/46f493b875047ae00d0c9f9086415423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pt8tyIqp-X2bxlnrx0DzVQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">得到一对的左边部分</p></figure><p id="ff67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可能想知道:如果迈克尔逊只处理第一个元素，我怎么能处理堆栈的第二个元素呢？非常简单！用<code class="fe na nb nc nd b">SWAP</code>指令将第二个元素带到顶部，并保留另一个元素以备后用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/fb12011f0a2ce9943db75ed864448910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*s7JajaPKPP0GE8CdyVZSWQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">交换两个元素</p></figure><p id="ab50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<code class="fe na nb nc nd b">SWAP</code>指令时，你告诉迈克尔逊:“我现在不需要第一个元素，但是我想研究第二个。”迈克尔逊将使第一个元素下降到第二个位置，使第二个元素上升到第一个位置。</p><p id="545a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们在开始复制的第二对在顶部，我们可以使用一个反向的<code class="fe na nb nc nd b">CAR</code>来得到带有<code class="fe na nb nc nd b">CDR</code>指令的对的正确部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/93d0f5e12d8fa70f80d8f13d9e452802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iqZfiHKYxHNkHA0f2Mg26g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">得到一对中正确的部分</p></figure><p id="54fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">CDR</code>指令的工作方式类似于<code class="fe na nb nc nd b">CAR</code>指令，但是您将保持所操作的对的右侧(一个对总是只包含两个元素，因此<code class="fe na nb nc nd b">CDR</code>和<code class="fe na nb nc nd b">CAR</code>是唯一可能的操作)。之后，你可以看到我们的堆栈由两个元素组成:第一个位置是字符串<code class="fe na nb nc nd b">Hello</code>，第二个位置是字符串<code class="fe na nb nc nd b">world</code>。</p><p id="5f51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们把它们放在一起！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/31c4109cf62c7f077a6de4367f169c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OC5AMw1FtnB0RCSrxbK_jA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">连接两个元素</p></figure><p id="0d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算机编程中，把两个字符串放在一起的运算叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Concatenation" rel="noopener ugc nofollow" target="_blank"> <em class="lv">串联</em> </a> <em class="lv">。在迈克尔逊中把两个字符串放在一起的指令叫做<code class="fe na nb nc nd b">CONCAT</code>，这是唯一合乎逻辑的。该操作获取当前位于堆栈顶部的两个字符串，并返回单个字符串。要使操作成功，必须满足两个条件:</em></p><ul class=""><li id="8f73" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">在栈顶有两个元素(如果只剩下一个元素，就会产生错误)。如果存在更多的元素，它将只处理顶部的两个元素。</li><li id="b3bf" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">栈顶的两个元素是字符串(迈克尔逊是严格类型化的——它知道栈中有什么样的值，所以不要试图欺骗它)</li></ul><p id="7a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还记得我们在第一部分中讨论的内容，你就知道会发生什么。我们必须创建一个带有列表和新存储的对，以结束智能契约的执行(就像在迈克尔逊说再见一样)。</p><p id="8774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们将一个空列表放在栈顶:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/3920495529087a1146cd35bbd2f6e5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lVNflNbdRU2Q1_swDUSgrw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建空列表</p></figure><p id="e1f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦有了空列表，我们就可以用空列表和字符串创建一个对:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/5a702519e996619d7375b3c3b7002adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BZtf-c9C92w5ncVBe5GT1w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将列表与存储配对</p></figure><p id="45dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次提醒，要注意元素的顺序和类型:迈克尔逊将第一个元素放在元素对的左边，第二个元素放在元素对的右边。返回类型为<code class="fe na nb nc nd b">(Pair string list (operation))</code>的一对将产生一个错误。</p><p id="be37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的堆栈是干净的，包含一对操作列表和一个字符串，智能契约的执行结束了。</p><p id="0c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面的视频中看到堆栈的完整执行和转换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6c0e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="5a1e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在迈克尔逊初学者教程的这个新部分中，我们看了一个带有迈克尔逊内核的Jupyter笔记本，我们将在本教程的后续部分中大量使用它来编写、调试和执行代码。</p><p id="49af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迈克尔逊中引入了新的操作码:<code class="fe na nb nc nd b">CAR</code>，提取一对的左边部分；<code class="fe na nb nc nd b">DUP</code>，复制栈顶元素；<code class="fe na nb nc nd b">CDR</code>、<code class="fe na nb nc nd b"> </code>提取一对中的右半部分；<code class="fe na nb nc nd b">SWAP</code>，交换栈顶两个元素的位置；和<code class="fe na nb nc nd b">CONCAT</code>，它接受两个字符串并返回一个由前面两个字符串组合而成的字符串。</p><p id="e426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还添加了代表堆栈中操作的动画，以帮助您更好地可视化和跟踪每一步发生的事情。当堆栈中的操作变得更加复杂时，这将变得更加有用。</p><p id="a882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">敬请期待！</p></div></div>    
</body>
</html>