<html>
<head>
<title>Handy JavaScript Tricks — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">方便的JavaScript技巧—第1部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handy-javascript-tricks-part-1-d56fcafc1c45?source=collection_archive---------4-----------------------#2019-11-21">https://betterprogramming.pub/handy-javascript-tricks-part-1-d56fcafc1c45?source=collection_archive---------4-----------------------#2019-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9a59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何删除重复的元素，从数组中删除假值，创建空对象，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e927de6cdb32dc30b51de7343b1fdc3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KkEYr2CG4APYbBmp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@luismonse?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Luis Monse </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e7fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript和其他编程语言一样，有许多方便的技巧，让我们可以更容易地编写程序。</p><p id="2f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解如何删除重复的元素，从数组中删除falsy值，创建空对象，以及检查所需的函数参数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c333" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">移除重复元素</h1><p id="5602" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在ES6之前，从数组中删除重复元素是一件痛苦的事情。我们必须检查每个条目是否存在，如果已经存在，那么我们删除在另一个已经存在的地方重复的条目。</p><p id="12e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是创建一个字典，将数组条目作为键，然后遍历字典的键来创建另一个数组。</p><p id="8726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES6中，我们不必再这样做了，因为我们有了一个新的可迭代对象<code class="fe mz na nb nc b">Sets</code>。正如它听起来的那样，它代表了数学中的一个集合。</p><p id="5fed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数学中的一个<code class="fe mz na nb nc b">Set</code>是不能有重复的东西的集合。使用<code class="fe mz na nb nc b">Set</code>构造函数，我们可以将一个数组直接传递给<code class="fe mz na nb nc b">Set</code>构造函数来创建一个集合。</p><p id="5b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个包含重复元素的数组，那么我们可以将它转换成一个<code class="fe mz na nb nc b">Set</code>，然后再转换回一个数组。例如，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ab1e" class="nh md it nc b gy ni nj l nk nl">let arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5];<br/>const set = new Set(arr);<br/>arr = Array.from(set);<br/>console.log(arr);</span></pre><p id="2830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有一个包含许多重复条目的数字数组<code class="fe mz na nb nc b">arr</code>。为了删除重复的元素，我们首先用<code class="fe mz na nb nc b">arr</code>数组创建一个<code class="fe mz na nb nc b">Set</code>。</p><p id="668c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们用<code class="fe mz na nb nc b">Array.from</code>方法将它转换回一个数组，该方法将任何类似数组的对象作为有效参数，然后我们将它赋回<code class="fe mz na nb nc b">arr</code>。</p><p id="ce31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们对数组使用相同的变量，但是所有重复的元素都消失了。如果我们在上面的代码中运行<code class="fe mz na nb nc b">console.log</code>语句，我们将得到<code class="fe mz na nb nc b">[1, 2, 3, 4, 5]</code>。</p><p id="0ad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以用扩展操作符替换<code class="fe mz na nb nc b">Array.from</code>方法，因为<code class="fe mz na nb nc b">Set</code>是一个可迭代对象，这意味着它使用扩展操作符。我们可以像下面这样编写上面的代码:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="eadf" class="nh md it nc b gy ni nj l nk nl">let arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5];<br/>const set = new Set(arr);<br/>arr = [...set]<br/>console.log(arr);</span></pre><p id="53f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们应该得到与第一个例子相同的<code class="fe mz na nb nc b">console.log</code>输出。为了使它更短，我们甚至不必创建<code class="fe mz na nb nc b">set</code>变量，而是使用spread运算符，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4e05" class="nh md it nc b gy ni nj l nk nl">let arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5];<br/>arr = [...new Set(arr)];<br/>console.log(arr);</span></pre><p id="4b6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这甚至更短，使用更少的内存，因为我们不必创建另一个变量来删除重复的元素。有了spread操作符，现在我们不需要一个循环来删除数组中的重复元素。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7aea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">移除虚假值</h1><p id="7722" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要从数组中删除falsy值，如<code class="fe mz na nb nc b">0</code>、<code class="fe mz na nb nc b">undefined</code>、<code class="fe mz na nb nc b">null</code>、<code class="fe mz na nb nc b">NaN</code>或<code class="fe mz na nb nc b">false</code>，我们可以调用<code class="fe mz na nb nc b">Boolean</code>方法来完成，因为<code class="fe mz na nb nc b">Boolean</code>会将falsy值转换为布尔值<code class="fe mz na nb nc b">false</code>。</p><p id="c8e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以删除这些值，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f1c0" class="nh md it nc b gy ni nj l nk nl">let arr = [1, 2, 3, 4, 5, 6, false, null, undefined, , null, NaN, 0];<br/>arr = arr.filter(a =&gt; Boolean(a));<br/>console.log(arr);</span></pre><p id="7da6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有一个数组<code class="fe mz na nb nc b">arr</code>，其中有一些数字和假值，如数组中的<code class="fe mz na nb nc b">false</code>、<code class="fe mz na nb nc b">null</code>、<code class="fe mz na nb nc b">undefined</code>、<code class="fe mz na nb nc b">NaN</code>和<code class="fe mz na nb nc b">0</code>，以及数组中间的一个整体，解释为<code class="fe mz na nb nc b">undefined</code>。</p><p id="994b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过使用返回这些值的真值的<code class="fe mz na nb nc b">Boolean</code>工厂函数来过滤掉它们。虚假的被转换成<code class="fe mz na nb nc b">false</code>，然后是一个新的数组。删除falsy值后，它返回<code class="fe mz na nb nc b">filter</code>函数。</p><p id="2cf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，返回的数组被赋回给<code class="fe mz na nb nc b">arr</code>变量，这使得<code class="fe mz na nb nc b">arr</code>数组采用新值，其中删除了falsy值。最后，我们得到了<code class="fe mz na nb nc b">console.log</code>输出<code class="fe mz na nb nc b">[1, 2, 3, 4, 5, 6]</code>。</p><p id="ce80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe mz na nb nc b">Boolean</code>函数接受一个参数，即您要转换为布尔值的值，并且该值与我们传递给<code class="fe mz na nb nc b">filter</code>方法的回调函数的签名相匹配，因此我们可以通过将<code class="fe mz na nb nc b">Boolean</code>函数直接传递给<code class="fe mz na nb nc b">filter</code>方法作为其回调函数来缩短这个过程，如以下代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f3d8" class="nh md it nc b gy ni nj l nk nl">let arr = [1, 2, 3, 4, 5, 6, false, null, undefined, , null, NaN, 0];<br/>arr = arr.filter(Boolean);<br/>console.log(arr);</span></pre><p id="3b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的代码，我们应该从<code class="fe mz na nb nc b">console.log</code>得到与上面相同的输出。注意，我们从<code class="fe mz na nb nc b">Boolean</code>函数中移除了括号。</p><p id="6cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为我们将对<code class="fe mz na nb nc b">filter</code>方法的函数引用作为回调函数传入。如果我们传入一个函数的引用作为另一个函数的参数，那么我们不应该包括括号，因为我们不调用这个函数，我们只想传入函数引用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9900" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建空对象</h1><p id="3463" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们想要创建一个没有任何原型的纯空对象，我们不应该使用<code class="fe mz na nb nc b">{}</code>文字，因为这会创建一个具有原型类型的对象。如果我们跑:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0404" class="nh md it nc b gy ni nj l nk nl">console.log({}.__proto__)</span></pre><p id="9085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d01f" class="nh md it nc b gy ni nj l nk nl">console.log(Object.getPrototypeOf({}))</span></pre><p id="fa65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到这样的东西:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="518c" class="nh md it nc b gy ni nj l nk nl">constructor: ƒ Object()<br/>hasOwnProperty: ƒ hasOwnProperty()<br/>isPrototypeOf: ƒ isPrototypeOf()<br/>propertyIsEnumerable: ƒ propertyIsEnumerable()<br/>toLocaleString: ƒ toLocaleString()<br/>toString: ƒ toString()<br/>valueOf: ƒ valueOf()<br/>__defineGetter__: ƒ __defineGetter__()<br/>__defineSetter__: ƒ __defineSetter__()<br/>__lookupGetter__: ƒ __lookupGetter__()<br/>__lookupSetter__: ƒ __lookupSetter__()<br/>get __proto__: ƒ __proto__()<br/>set __proto__: ƒ __proto__()</span></pre><p id="2c9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为输出。正如我们所见，已经有一堆从<code class="fe mz na nb nc b">{}</code>的原型继承而来的方法。</p><p id="134c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不需要这些方法，我们可以通过将<code class="fe mz na nb nc b">null</code>传递给<code class="fe mz na nb nc b">Object.create</code>方法来创建一个没有任何原型的对象，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="284d" class="nh md it nc b gy ni nj l nk nl">const obj = Object.create(null);<br/>console.log(obj.__proto__);<br/>console.log(Object.getPrototypeOf(obj))</span></pre><p id="d765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将创建一个没有原型的对象，这就是为什么我们将<code class="fe mz na nb nc b">null</code>传递到<code class="fe mz na nb nc b">Object.create</code>方法的参数中。</p><p id="336b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的第一个<code class="fe mz na nb nc b">console.log</code>语句，我们应该得到<code class="fe mz na nb nc b">undefined</code>，对于第二个语句，我们应该得到<code class="fe mz na nb nc b">null</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e547" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">检查所需的参数</h1><p id="7ea2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用ES6，我们可以在函数签名中设置函数参数的默认值。我们可以将一个值设置为默认参数，也可以将另一个函数的返回值设置为默认参数。</p><p id="b2bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以运行另一个函数，因为我们调用一个带参数的函数。我们可以用它来检查所需的值，方法是通过函数调用来指定参数的默认值。</p><p id="d5bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以编写以下代码:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="aa5d" class="nh md it nc b gy ni nj l nk nl">const checkRequired = (paramName) =&gt; {<br/>  throw new Error(`${paramName} is required`);<br/>};</span><span id="2373" class="nh md it nc b gy nm nj l nk nl">const greet = (name = checkRequired('name'), greeting = checkRequired('greeting')) =&gt; {<br/>  console.log(`Hello ${name}, ${greeting}`)<br/>};</span><span id="02dc" class="nh md it nc b gy nm nj l nk nl">greet('Jane', 'How are you?');<br/>try {<br/>  greet('Jane');<br/>} catch (error) {<br/>  console.log(error);<br/>}</span><span id="c269" class="nh md it nc b gy nm nj l nk nl">try {<br/>  greet('How are you?');<br/>} catch (error) {<br/>  console.log(error);<br/>}</span><span id="042e" class="nh md it nc b gy nm nj l nk nl">try {<br/>  greet();<br/>} catch (error) {<br/>  console.log(error);<br/>}</span></pre><p id="7efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们应该得到这样的东西:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="247c" class="nh md it nc b gy ni nj l nk nl">Hello Jane, How are you?</span><span id="00ff" class="nh md it nc b gy nm nj l nk nl">Error: greeting is required<br/>    at checkRequired ((index):33)<br/>    at greet ((index):36)<br/>    at window.onload ((index):42)</span><span id="e0e8" class="nh md it nc b gy nm nj l nk nl">Error: greeting is required<br/>    at checkRequired ((index):33)<br/>    at greet ((index):36)<br/>    at window.onload ((index):48)</span><span id="a084" class="nh md it nc b gy nm nj l nk nl">Error: name is required<br/>    at checkRequired ((index):33)<br/>    at greet ((index):36)<br/>    at window.onload ((index):54)</span></pre><p id="bba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为<code class="fe mz na nb nc b">console.log</code>语句的输出。</p><p id="685c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用上面的代码所做的是，当我们用给定的参数调用<code class="fe mz na nb nc b">greet</code>函数时，我们正在运行<code class="fe mz na nb nc b">checkRequired</code>函数。</p><p id="1d7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个函数调用，我们运行<code class="fe mz na nb nc b">checkRequired</code>函数，因为如果参数为<code class="fe mz na nb nc b">undefined</code>则每个参数都被传递到参数中，或者如果参数被省略或<code class="fe mz na nb nc b">undefined</code>被传递，则我们将<code class="fe mz na nb nc b">checkRequired</code>函数的返回值设置为参数的默认值。</p><p id="e997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">checkRequired</code>的回报是什么并不重要。我们只是希望它在参数值被省略或者是<code class="fe mz na nb nc b">undefined</code>的情况下运行。这样，如果两个参数都没有传入，<code class="fe mz na nb nc b">greeting</code>函数就不会运行。</p><p id="b0ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript和其他编程语言一样，有许多方便的技巧，让我们可以更容易地编写程序。</p><p id="c9fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们研究了如何删除重复的元素、从数组中删除falsy值、创建空对象以及检查所需的函数参数。</p><p id="7d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些技巧，我们减少了编写代码的工作量，使我们的生活更加轻松。</p></div></div>    
</body>
</html>