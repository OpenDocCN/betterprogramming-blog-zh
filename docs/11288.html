<html>
<head>
<title>Multi-Tenancy Support With Spring Boot, Liquibase, and PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot、Liquibase和PostgreSQL的多租户支持</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/multi-tenancy-support-with-spring-boot-liquibase-and-postgresql-d41942dc0639?source=collection_archive---------2-----------------------#2022-03-07">https://betterprogramming.pub/multi-tenancy-support-with-spring-boot-liquibase-and-postgresql-d41942dc0639?source=collection_archive---------2-----------------------#2022-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4293" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何实施多租户的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1caa2a503ae8e6443bda19d0b62e434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evYvRhWvHuT6SeRLNG34-A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/no-longer-here-19203/" rel="noopener ugc nofollow" target="_blank">不再-这里</a>发自<a class="ae ky" href="https://pixabay.com/photos/lavenders-flowers-field-farm-894919/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="5740" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">多租户模型</h1><p id="5388" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在微服务中实现多租户有多种模式:</p><ol class=""><li id="fa08" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated"><strong class="lt iu">每个租户的数据库</strong>:每个租户都有自己的数据库，并与其他租户隔离。</li><li id="34f8" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><strong class="lt iu">共享数据库，独立模式</strong>:所有租户共享一个数据库，但是有自己的数据库模式和自己的表。</li><li id="b2ff" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><strong class="lt iu">共享数据库，共享模式</strong>:所有租户共享相同的数据库和模式。共享表有一个包含租户标识符的列，它显示行的所有者。</li></ol><p id="2425" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">每种模式都有其优缺点。对于这个故事，我们将关注第三个模型，<strong class="lt iu">共享数据库，共享模式</strong>，共享表有一个带有租户标识符的鉴别器列。见下图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a6efb8829ad54647be161fb9a9a2958d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*eYybZgMzx2NZS8dQUnCTQA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图表</p></figure><h1 id="efa2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据库中的多租户实现</h1><h1 id="dcb2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据隔离:PostgreSQL行级安全性(RLS)</h1><p id="2723" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于数据隔离，我们将使用PostgreSQL行级安全性(RLS)。RLS是PostgreSQL的一个安全特性，它允许数据库管理员定义策略来控制特定数据行如何显示以及如何为一个或多个角色操作。从本质上讲，RLS是我们可以应用于PostgreSQL数据库表的附加过滤器。当用户试图在表上执行操作时，在查询条件或其他筛选之前应用该筛选，并根据安全策略缩小或拒绝数据。我们可以为SELECT、INSERT、UPDATE和DELETE等特定命令创建行级安全策略。</p><h1 id="ec48" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">添加鉴别器列</h1><p id="52c0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在需要多租户支持的表中，需要添加一个鉴别器列，比如说<code class="fe nh ni nj nk b">tenant_id</code>。我们将使用一个名为<a class="ae ky" href="https://github.com/wenqiglantz/multi-tenancy-spring-boot" rel="noopener ugc nofollow" target="_blank">客户服务</a>的演示Spring Boot微服务作为例子。这是一个处理客户CRUD操作的简单微服务。假设我们需要对客户实体的多租户支持。我们需要添加一个新的Liquibase变更集，以将<code class="fe nh ni nj nk b">tenant_id</code>列添加到customer表中，不可为空，见下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="315a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">定义行级策略</h1><p id="d2ae" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">需要为需要多租户支持的表定义行级策略。两步走:</p><ul class=""><li id="5498" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm nn mv mw mx bi translated">为表启用行级安全性</li><li id="0655" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm nn mv mw mx bi translated">为表定义一个策略，引用<code class="fe nh ni nj nk b">tenant_id</code>鉴别器列</li></ul><p id="59c7" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">这两个步骤可以包装在一个Liquibase变更集中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="d714" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">添加应用程序级数据库用户</h1><p id="3540" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于行级安全性，除了表所有者数据库用户(在客户服务的情况下，是数据库用户<code class="fe nh ni nj nk b">postgres</code>)之外，我们需要引入一个应用级数据库用户，该用户可以访问租户特定的操作。为什么？默认情况下，行级安全策略<strong class="lt iu">不会</strong>应用于表所有者，因为表所有者必须能够出于管理目的访问所有行。因此，让我们通过添加新的Liquibase变更集来添加一个应用程序级别的数据库用户，比如“customerservice”。见下文。下面的示例脚本中的第二个变更集是为了确保将所有现有表的SELECT、INSERT、UPDATE、DELETE权限正确地授予“customerservice”用户。第一个变更集中的“<code class="fe nh ni nj nk b">ALTER DEFAULT PRIVILEGES...</code>”确保所有未来的新表都将那些权限正确地授予“customerservice”。这两个变更集都是必需的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="52f0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">应用程序中的多租户实现</h1><h1 id="fa2e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">高级类图</h1><p id="9a4a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">参见下面的客户服务微服务中多租户实现的类图。在下面的部分中，我们将逐类深入研究。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/e5dcacde9ca598d62f72dd86e4890227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izUMZp58EuSHARlIwq8XqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的类图</p></figure><h1 id="ce87" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据源配置</h1><p id="2198" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要两个数据源:</p><ul class=""><li id="00aa" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm nn mv mw mx bi translated"><strong class="lt iu">主数据源</strong> : Liquibase为数据库迁移需求寻找主数据源。</li><li id="255d" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm nn mv mw mx bi translated"><strong class="lt iu">租户数据源</strong>:这个数据源是我们微服务的默认数据源。参见下面的代码。注意<code class="fe nh ni nj nk b">tenantDataSource</code> bean定义上的<code class="fe nh ni nj nk b">@Primary</code>注释。</li></ul><p id="128a" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated"><code class="fe nh ni nj nk b">DataSourceConfiguration</code>类看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="16c3" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">相应地，<code class="fe nh ni nj nk b">application.yml</code>中的数据源定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="7e8b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">租户感知数据库连接</h1><p id="fd19" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有了行级安全策略，每次应用程序向数据源请求连接时，我们都需要将PostgreSQL会话变量设置为<code class="fe nh ni nj nk b">tenant_id</code>来强制数据隔离。当连接关闭时，从PostgreSQL会话中清除<code class="fe nh ni nj nk b">tenant_id</code>。由于每个租户没有单独的数据库用户，我们可以利用定制的<em class="np">会话参数</em>，例如<code class="fe nh ni nj nk b">app.tenant_id</code>，将当前租户与数据库连接相关联。使用Postgres特定的SQL语句来设置会话参数。</p><p id="96c0" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated"><code class="fe nh ni nj nk b">"SET app.tenant_id TO '" + tenantId + "'"</code></p><p id="ee85" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">见下图<code class="fe nh ni nj nk b">TenantAwareDataSource</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="1f4e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">TenantAware界面</h1><p id="976e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是多租户实体类需要实现的接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="72f6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">租户上下文</h1><p id="eeb3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe nh ni nj nk b">InheritableThreadLocal</code>存储/检索/清除当前租户id。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="78a9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">JPA实体列表器</h1><p id="05d9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们如何在每个需要多租户支持的实体类上设置<code class="fe nh ni nj nk b">tenant_id</code>？看向JPA <code class="fe nh ni nj nk b">EntityListener</code>！<code class="fe nh ni nj nk b">EntityListener</code>允许监听器附加到JPA实体的生命周期中。它允许我们用当前租户id填充鉴别器列。见下面<code class="fe nh ni nj nk b">TenantListener</code>类。在更新、删除和保存之前，从<code class="fe nh ni nj nk b">TenantContext </code>捕获<code class="fe nh ni nj nk b">tenantId</code>，并在实体处设置。</p><ul class=""><li id="9993" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm nn mv mw mx bi translated">@PreUpdate:在更新操作之前</li><li id="1d61" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm nn mv mw mx bi translated">@PreRemove:在移除实体之前</li><li id="4459" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm nn mv mw mx bi translated">为新实体调用@PrePersis: before persist</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="86a5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">BaseEntity</h1><p id="3fb0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">添加这个实现<code class="fe nh ni nj nk b">TenantAware</code>接口的类<code class="fe nh ni nj nk b">BaseEntity</code>，由需要多租户支持的实体进行扩展。注意<code class="fe nh ni nj nk b">@EntityListeners(TenantListener.class)</code>，使<code class="fe nh ni nj nk b">TenantListener</code>能够附加到扩展<code class="fe nh ni nj nk b">BaseEntity</code>的特定实体类的生命周期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="38d0" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">需要多租户支持的实体类现在需要扩展<code class="fe nh ni nj nk b">BaseEntity</code>。实体类<code class="fe nh ni nj nk b">Customer</code>示例如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="c649" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">从客户端应用程序捕获租户id</h1><p id="a975" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在让我们考虑如何最好地从传入的请求中提取租赁标识符。一个流行的选择是让客户端应用程序发送一个名为<code class="fe nh ni nj nk b">X-Tenant-ID</code>的HTTP头，以传入现有的<code class="fe nh ni nj nk b">tenantId</code>。然后，我们的微服务读取<code class="fe nh ni nj nk b">X-Tenant-ID</code>头，并将其值存储在<code class="fe nh ni nj nk b">TenantContext</code>的<code class="fe nh ni nj nk b">InheritableThreadLocal</code>中。我们可以像下面这样加一个<code class="fe nh ni nj nk b">TenantInterceptor</code>。在<code class="fe nh ni nj nk b">preHandle</code>方法中，我们根据传入的HTTP头设置<code class="fe nh ni nj nk b">tenantId </code>，如果没有传入，那么<code class="fe nh ni nj nk b">tenantId </code>保存默认值“0”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="edde" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">接下来我们添加<code class="fe nh ni nj nk b">WebConfiguration</code>来给它注入<code class="fe nh ni nj nk b">TenantInterceptor</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="fbd5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">黄瓜BDD测试场景</h1><p id="bdcd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了验证多租户特性的实现，开发了以下测试场景。正如我们所看到的，租户数据仅被隔离到特定的租户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7e8e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">样本步骤定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1c0f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">对于这个故事的完整源代码，请查看<a class="ae ky" href="https://github.com/wenqiglantz/multi-tenancy-spring-boot" rel="noopener ugc nofollow" target="_blank">我的GitHub repo </a>。</p><p id="fc00" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">编码快乐！手工制作快乐！</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h2 id="9a64" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated"><strong class="ak">参考文献</strong></h2><p id="f26f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://satoricyber.com/postgres-security/postgres-row-level-security/" rel="noopener ugc nofollow" target="_blank">https://satoricyber . com/postgres-security/postgres-row-level-security/</a></p><p id="6d0a" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated"><a class="ae ky" href="https://www.bytefish.de/blog/spring_boot_multitenancy_using_rls.html" rel="noopener ugc nofollow" target="_blank">https://www . byte fish . de/blog/spring _ boot _ multi tenance _ using _ RLS . html</a></p><p id="861e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated"><a class="ae ky" href="https://callistaenterprise.se/blogg/teknik/2020/10/24/multi-tenancy-with-spring-boot-part6/" rel="noopener ugc nofollow" target="_blank">https://callista enterprise . se/blogg/teknik/2020/10/24/multi-tenancy-with-spring-boot-part 6</a></p><p id="1c4c" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated"><a class="ae ky" href="https://www.baeldung.com/jpa-entity-lifecycle-events" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/jpa-entity-lifecycle-events</a></p></div></div>    
</body>
</html>