<html>
<head>
<title>Learn Stream Processing With Kafka Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kafka流学习流处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-stream-processing-with-kafka-streams-stateless-operations-2111080e6c53?source=collection_archive---------1-----------------------#2020-03-05">https://betterprogramming.pub/learn-stream-processing-with-kafka-streams-stateless-operations-2111080e6c53?source=collection_archive---------1-----------------------#2020-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="50a6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">无状态操作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/21477c881b0ce47506d56c9e1111eed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3mAHO-JLpBHb8UCjZT1Sg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Joao Branco 在<a class="ae kv" href="https://unsplash.com/s/photos/stream?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f7e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank"> Kafka Streams </a>是一个Java库，用于在Apache Kafka之上开发流处理应用程序。这是Kafka Streams及其API系列文章的第一篇。</p><p id="cc47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是一个关于卡夫卡流的理论指南(尽管我在过去已经涉及了其中的一些方面)。</p><p id="a53a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一部分中，我们将介绍Kafka Streams DSL API中的无状态操作——特别是在<code class="fe ls lt lu lv b">KStream</code>中可用的函数，如<code class="fe ls lt lu lv b">filter</code>、<code class="fe ls lt lu lv b">map</code>、<code class="fe ls lt lu lv b">groupBy</code>等。Kafka Streams中的DSL API提供了一个强大的函数式编程模型来定义流处理拓扑。</p><p id="35b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原料药(<code class="fe ls lt lu lv b">KStream</code>等)。)在这篇文章中引用的可以在<a class="ae kv" href="https://kafka.apache.org/24/javadoc/index.html?org/apache/kafka/streams/" rel="noopener ugc nofollow" target="_blank"> Kafka Streams Javadocs </a>中找到</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1327" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">设置</h1><p id="ad4a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">首先，您需要创建一个<code class="fe ls lt lu lv b">KafkaStreams</code>实例。它需要一个<code class="fe ls lt lu lv b">topology</code>和相关的配置(以<code class="fe ls lt lu lv b">java.util.Properties</code>的形式)。</p><p id="d182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为Kafka streams应用程序设置所需的配置:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="ae30" class="ne me iq lv b gy nf ng l nh ni">Properties config = new Properties();</span><span id="a289" class="ne me iq lv b gy nj ng l nh ni">config.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, App.APP_ID);<br/>config.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");<br/>config.setProperty(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());<br/>config.setProperty(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());</span></pre><p id="a0e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以构建一个定义处理管道的<code class="fe ls lt lu lv b">topology</code>(本文的其余部分将关注拓扑的无状态部分)。</p><p id="ee55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以创建<code class="fe ls lt lu lv b">KafkaStreams</code>实例并开始处理:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="582d" class="ne me iq lv b gy nf ng l nh ni">KafkaStreams app = new KafkaStreams(topology, config);<br/>app.start();<br/>new CountdownLatch(1).await(); // wait forever</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0135" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">使用KStream的无状态操作</h1><p id="41c2" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我通常喜欢把东西分成不同的类别——这有助于我分而治之。在这种情况下，我尝试了同样的方法，将各种<code class="fe ls lt lu lv b">KStream</code>操作分成<code class="fe ls lt lu lv b">filter</code>、<code class="fe ls lt lu lv b">map</code>等。</p><p id="3843" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧！</p><h2 id="0566" class="ne me iq bd mf nk nl dn mj nm nn dp mn lf no np mp lj nq nr mr ln ns nt mt nu bi translated">过滤器</h2><p id="3392" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">您可以使用<code class="fe ls lt lu lv b">filter</code>根据您的标准省略或包含记录。</p><p id="4c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果发送到主题的值包含一个单词，并且您希望包含大于指定长度的单词，那么您可以使用一个<code class="fe ls lt lu lv b">Predicate</code>来定义这个标准，并将其传递给<code class="fe ls lt lu lv b">filter</code>方法——这将创建一个新的带有过滤记录的<code class="fe ls lt lu lv b">KStream</code>实例。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="9308" class="ne me iq lv b gy nf ng l nh ni">KStream&lt;String, String&gt; stream = builder.stream("words");<br/>stream.filter(new Predicate&lt;String, String&gt;() {<br/>    @Override<br/>    public boolean test(String k, String v) {<br/>            return v.length() &gt; 5;<br/>        }<br/>    })</span></pre><p id="415c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想根据某些标准来<code class="fe ls lt lu lv b">exclude</code>记录，也可以使用<code class="fe ls lt lu lv b">filterNot</code>。下面是一个lambda风格的例子:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="f0f9" class="ne me iq lv b gy nf ng l nh ni">KStream&lt;String, String&gt; stream = builder.stream("words");<br/>stream.filterNot((key,value) -&gt; value.startsWith("foo"));</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="bbac" class="ne me iq bd mf nk nl dn mj nm nn dp mn lf no np mp lj nq nr mr ln ns nt mt nu bi translated"><code class="fe ls lt lu lv b">map</code></h2><p id="f4e7" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">一个常用的无状态操作是<code class="fe ls lt lu lv b">map</code>。在Kafka流的情况下，可以通过应用映射器函数来转换输入<code class="fe ls lt lu lv b">KStream</code>中的每个记录。</p><p id="0186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个有多种口味，比如<code class="fe ls lt lu lv b">map</code>、<code class="fe ls lt lu lv b">mapValues</code>、<code class="fe ls lt lu lv b">flatMap</code>、<code class="fe ls lt lu lv b">flatMapValues</code>。</p><p id="be0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想改变键和值，只需使用<code class="fe ls lt lu lv b">map</code>方法。例如，将键和值转换为大写。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="35b4" class="ne me iq lv b gy nf ng l nh ni">stream.map(new KeyValueMapper&lt;String, String, KeyValue&lt;String, String&gt;&gt;() {<br/>    @Override<br/>    public KeyValue&lt;String, String&gt; apply(String k, String v) {<br/>            return new KeyValue&lt;&gt;(k.toUpperCase(), v.toUpperCase());<br/>        }<br/>    });</span></pre><p id="dcb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您只想改变数值，请使用<code class="fe ls lt lu lv b">mapValues</code>:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="d7a9" class="ne me iq lv b gy nf ng l nh ni">stream.mapValues(value -&gt; value.toUpperCase());</span></pre><p id="ef79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">flatMap</code>与<code class="fe ls lt lu lv b">map</code>类似，但允许返回多条记录(<code class="fe ls lt lu lv b">KeyValue</code> s):</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="d85b" class="ne me iq lv b gy nf ng l nh ni">stream.flatMap(new KeyValueMapper&lt;String, String, Iterable&lt;? extends KeyValue&lt;? extends String, ? extends String&gt;&gt;&gt;() {<br/>    @Override<br/>    public Iterable&lt;? extends KeyValue&lt;? extends String, ? extends String&gt;&gt; apply(String k, String csv) {<br/>        String[] values = csv.split(",");<br/>        return Arrays.asList(values)<br/>                    .stream()<br/>                    .map(value -&gt; new KeyValue&lt;&gt;(k, value))<br/>                    .collect(Collectors.toList());<br/>            }<br/>    })</span></pre><p id="0ec8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，流中的每个记录都得到<code class="fe ls lt lu lv b">flatMap</code> ped，这样每个逗号分隔的值(CSV)首先被分成它的组成部分，并且为CSV字符串的每个部分创建一个<code class="fe ls lt lu lv b">KeyValue</code>对。例如，如果您有记录<code class="fe ls lt lu lv b">(foo &lt;-&gt; a,b,c)</code>和<code class="fe ls lt lu lv b">(bar &lt;-&gt; d,e)</code>(其中<code class="fe ls lt lu lv b">foo</code>和<code class="fe ls lt lu lv b">bar</code>是键)，那么结果流将有五个条目:<code class="fe ls lt lu lv b">(foo,a)</code>、<code class="fe ls lt lu lv b">(foo,b)</code>、<code class="fe ls lt lu lv b">(foo,c)</code>、<code class="fe ls lt lu lv b">(bar,d)</code>和<code class="fe ls lt lu lv b">(bar,e)</code>。</p><p id="e14a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您只想从流中接受一个值并返回一个值集合，请使用<code class="fe ls lt lu lv b">flatMapValues</code></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="3ce7" class="ne me iq bd mf nk nl dn mj nm nn dp mn lf no np mp lj nq nr mr ln ns nt mt nu bi translated"><code class="fe ls lt lu lv b">group</code></h2><p id="9b8c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果您想对一个<code class="fe ls lt lu lv b">KStream</code>的内容执行有状态聚合，那么您首先需要按照键对它的记录进行分组，以创建一个<code class="fe ls lt lu lv b">KGroupedStream</code>。</p><p id="a098" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在本系列的后续文章中讨论<code class="fe ls lt lu lv b">KGroupedStream</code>上的有状态操作。</p><p id="d3bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个使用<code class="fe ls lt lu lv b">groupByKey</code>的例子:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="bd44" class="ne me iq lv b gy nf ng l nh ni">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC); <br/>       <br/>KGroupedStream&lt;String,String&gt; kgs = stream.groupByKey();</span></pre><p id="9011" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">groupByKey</code>的一个通用版本是<code class="fe ls lt lu lv b">groupBy</code>，它让您能够使用<code class="fe ls lt lu lv b">KeyValueMapper</code>基于不同的键进行分组。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="10c5" class="ne me iq lv b gy nf ng l nh ni">stream.groupBy(new KeyValueMapper&lt;String, String, String&gt;() {<br/>    @Override<br/>    public String apply(String k, String v) {<br/>        return k.toUpperCase();<br/>    }<br/>});</span></pre><p id="787c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这两种情况下(<code class="fe ls lt lu lv b">groupByKey</code>和<code class="fe ls lt lu lv b">groupBy</code>，如果您需要使用不同的<code class="fe ls lt lu lv b">Serde</code> ( <code class="fe ls lt lu lv b">Serializer</code>和<code class="fe ls lt lu lv b">Deserializer</code>)而不是默认的，请使用重载版本(它接受一个<code class="fe ls lt lu lv b">Grouped</code>对象)。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="e452" class="ne me iq lv b gy nf ng l nh ni">stream.groupByKey(Grouped.with(Serdes.Bytes(), Serdes.Long()));</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="4227" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">终端操作</h1><p id="e1b0" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">Kafka Streams中的终端操作是返回<code class="fe ls lt lu lv b">void</code>而不是中间物的方法，比如另一个<code class="fe ls lt lu lv b">KStream</code>或<code class="fe ls lt lu lv b">KTable</code>。</p><p id="7bdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe ls lt lu lv b">to</code>方法将<code class="fe ls lt lu lv b">KStream</code>的记录存储到Kafka中的一个主题。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="1b3c" class="ne me iq lv b gy nf ng l nh ni">KStream&lt;String, String&gt; stream = builder.stream("words");</span><span id="9766" class="ne me iq lv b gy nj ng l nh ni">stream.mapValues(value -&gt; value.toUpperCase())<br/>      .to("uppercase-words");</span></pre><p id="081c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个重载版本的<code class="fe ls lt lu lv b">to</code>允许你指定一个<code class="fe ls lt lu lv b">Produced</code>对象来定制<code class="fe ls lt lu lv b">Serdes</code>和分割器。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="acf5" class="ne me iq lv b gy nf ng l nh ni">stream.mapValues(value -&gt; value.toUpperCase())<br/>      .to("output-topic",Produced.with(Serdes.Bytes(), Serdes.Long()));</span></pre><p id="8b11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了指定一个静态的主题名称，您还可以利用一个<code class="fe ls lt lu lv b">TopicNameExtractor</code>并包含任何定制的逻辑来动态地选择一个特定的主题</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="0968" class="ne me iq lv b gy nf ng l nh ni">stream.mapValues(value -&gt; value.toUpperCase())<br/>    .to(new TopicNameExtractor&lt;String, String&gt;() {<br/>        @Override<br/>        public String extract(String k, String v, RecordContext rc) {<br/>            return rc.topic()+"_uppercase";<br/>        }<br/>    });</span></pre><p id="b232" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们利用包含记录元数据的<code class="fe ls lt lu lv b">RecordContext</code>来获取主题，然后将<code class="fe ls lt lu lv b">_uppercase</code>追加到主题中。</p><p id="a3b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上述所有情况下，水槽主题应该在卡夫卡中预先存在。</p><p id="0044" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想要记录<code class="fe ls lt lu lv b">KStream</code>记录(用于调试目的)，请使用<code class="fe ls lt lu lv b">print</code>方法。它接受一个<code class="fe ls lt lu lv b">Printed</code>实例来配置行为。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="3573" class="ne me iq lv b gy nf ng l nh ni">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);<br/>stream.mapValues(v -&gt; v.toUpperCase()).print(Printed.toSysOut());</span></pre><p id="86bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将打印出记录——例如，如果您将<code class="fe ls lt lu lv b">(foo, BAR)</code>和<code class="fe ls lt lu lv b">(john, DOE)</code>传递给输入主题，它们将被转换为大写并被记录如下:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="05a8" class="ne me iq lv b gy nf ng l nh ni">[KSTREAM-MAPVALUES-0000000001]: foo, BAR<br/>[KSTREAM-MAPVALUES-0000000001]: john, DOE</span></pre><p id="91e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以使用<code class="fe ls lt lu lv b">Printed.toFile</code>(而不是<code class="fe ls lt lu lv b">toSysOut</code>)来定位特定的文件。</p><p id="a37e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">foreach</code>方法与<code class="fe ls lt lu lv b">print</code>和<code class="fe ls lt lu lv b">peek</code>相似:</p><ul class=""><li id="6276" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated">也是终端操作(像<code class="fe ls lt lu lv b">print</code>)</li><li id="31c9" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">它接受一个<code class="fe ls lt lu lv b">ForeachAction</code>(就像<code class="fe ls lt lu lv b">peek</code>)</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8282" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">多方面的</h1><p id="1851" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">由于<code class="fe ls lt lu lv b">print</code>方法是一个终端操作，您可以选择使用<code class="fe ls lt lu lv b">peek</code>，它返回同一个<code class="fe ls lt lu lv b">KStream </code>实例。它接受一个<code class="fe ls lt lu lv b">ForeachAction</code>，可以用来指定您想要对每条记录做什么——例如，记录键和值。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="6eb6" class="ne me iq lv b gy nf ng l nh ni">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);</span><span id="dd26" class="ne me iq lv b gy nj ng l nh ni">stream.mapValues(v -&gt; v.toUpperCase())<br/>      .peek((k,v) -&gt; System.out.println("key="+k+", value="+v))<br/>      .to(OUTPUT_TOPIC);</span></pre><p id="0783" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，您将能够看到被记录的键和值，它们也将被具体化为输出主题(不像<code class="fe ls lt lu lv b">print</code>操作)。</p><p id="2d12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">branch</code>是一个我没用过的方法(说实话)，但是看起来挺有意思的。它使您能够根据多个标准(由一个<code class="fe ls lt lu lv b">Predicate</code>表示)评估一个<code class="fe ls lt lu lv b">KStream</code>中的每条记录，并输出多个<code class="fe ls lt lu lv b">KStream</code>的数组。这里的关键是您可以使用多个谓词而不是一个——就像<code class="fe ls lt lu lv b">filter</code>和<code class="fe ls lt lu lv b">filterNot</code>的情况一样。</p><p id="1eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以将两个<code class="fe ls lt lu lv b">merge</code>合二为一。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="826a" class="ne me iq lv b gy nf ng l nh ni">StreamsBuilder builder = new StreamsBuilder(); </span><span id="0f97" class="ne me iq lv b gy nj ng l nh ni">KStream&lt;String, String&gt; stream1 = builder.stream("topic1");<br/>KStream&lt;String, String&gt; stream2 = builder.stream("topic2");</span><span id="a488" class="ne me iq lv b gy nj ng l nh ni">stream1.merge(stream2).to("output-topic");</span></pre><p id="a4e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>产生的流可能没有按顺序排列所有记录。</p><p id="e0c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想为您的<code class="fe ls lt lu lv b">KStream</code>中的每条记录派生一个新的键(它也可以有不同的类型)，使用<code class="fe ls lt lu lv b">selectKey</code>方法，它接受一个<code class="fe ls lt lu lv b">KeyValueMapper</code>。<code class="fe ls lt lu lv b">selectKey</code>与<code class="fe ls lt lu lv b">map</code>相似，但区别在于<code class="fe ls lt lu lv b">map</code>将返回类型限制为一个<code class="fe ls lt lu lv b">KeyValue</code>对象。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="aaf9" class="ne me iq lv b gy nf ng l nh ni">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);</span><span id="419a" class="ne me iq lv b gy nj ng l nh ni">stream.selectKey(new KeyValueMapper&lt;String, String, String&gt;() {<br/>            @Override<br/>            public String apply(String k, String v) {<br/>                return k.toUpperCase();<br/>            }<br/>        })</span></pre><p id="0eae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用Kafka Streams DSL开发处理管道时，您会发现自己使用<code class="fe ls lt lu lv b">to</code>将结果流记录推送到输出主题，然后从该(输出)主题创建一个新的流:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="c0cb" class="ne me iq lv b gy nf ng l nh ni">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream1 = builder.stream(INPUT_TOPIC);<br/>stream1.mapValues(v -&gt; v.toUpperCase()).to(OUTPUT_TOPIC);</span><span id="3709" class="ne me iq lv b gy nj ng l nh ni">//output topic now becomes the input source<br/>KStream&lt;String, String&gt; stream2 = builder.stream(OUTPUT_TOPIC);</span><span id="174f" class="ne me iq lv b gy nj ng l nh ni">//continue processing with stream2<br/>stream2.filter((k,v) -&gt; v.length &gt; 5).to(LENGTHY_WORDS_TOPIC);</span></pre><p id="6dc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以通过使用<code class="fe ls lt lu lv b">through</code>方法来简化。因此，您可以将上面的内容重写如下:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="587e" class="ne me iq lv b gy nf ng l nh ni">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);</span><span id="3a11" class="ne me iq lv b gy nj ng l nh ni">stream.mapValues(v -&gt; v.toUpperCase())<br/>      .through(OUTPUT_TOPIC)<br/>      .filter((k,v) -&gt; v.length &gt; 5)<br/>      .to(LENGTHY_WORDS_TOPIC);</span></pre><p id="a975" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们将记录(具有大写值)具体化为一个中间主题，并继续处理(在本例中使用<code class="fe ls lt lu lv b">filter</code>，最后将后置过滤结果存储在另一个主题中。</p><p id="6f4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">暂时就这样了。请继续关注本系列即将发布的文章！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="6581" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">参考</h1><p id="6f46" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">请不要忘记查看以下Kafka Streams资源。</p><ul class=""><li id="d274" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated"><a class="ae kv" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank">卡夫卡文献</a></li><li id="63a4" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated"><a class="ae kv" href="https://docs.confluent.io/current/streams/index.html" rel="noopener ugc nofollow" target="_blank">汇合单据</a></li><li id="9baa" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated"><a class="ae kv" href="https://kafka.apache.org/24/javadoc/index.html?org/apache/kafka/streams/" rel="noopener ugc nofollow" target="_blank">卡夫卡流Javadocs </a></li></ul></div></div>    
</body>
</html>