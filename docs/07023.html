<html>
<head>
<title>Angular: Create a Lazy-Loaded Tailwind Modal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度:创建一个懒惰加载的顺风模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-create-a-lazy-loaded-tailwind-modal-73675c66acae?source=collection_archive---------2-----------------------#2020-11-30">https://betterprogramming.pub/angular-create-a-lazy-loaded-tailwind-modal-73675c66acae?source=collection_archive---------2-----------------------#2020-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e392" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Angular和Tailwind CSS构建一个通用的、惰性加载的对话框</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97f9431eb20b1f457246e4fbba94dc36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yG0_AlxnZfzLYHwbwrcDQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emilegt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾米尔·吉耶莫</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4d2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有机会参与<a class="ae ky" href="https://owlly.ch/" rel="noopener ugc nofollow" target="_blank">owly</a>，这是一个由<a class="ae ky" href="https://twitter.com/saandr0o" rel="noopener ugc nofollow" target="_blank"> Sandro Scalco </a>创立的<a class="ae ky" href="https://github.com/project-owlly" rel="noopener ugc nofollow" target="_blank">开源</a>项目，旨在实现瑞士的数字民主。</p><p id="d1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，当我们讨论使用<a class="ae ky" href="https://scully.io" rel="noopener ugc nofollow" target="_blank"> Scully </a>预渲染主要角度应用程序的需求时，我们也决定将其迁移到<a class="ae ky" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> Tailwind CSS </a>。</p><p id="6097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果，我不得不创建一个定制的、通用的惰性加载模型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="22b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">元</h1><p id="013e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文已于2020年11月发表。该解决方案已经过Angular v11和Tailwind v2测试。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c317" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="a256" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本教程描述了使用Angular和Tailwind CSS创建一个通用对话框。通过<em class="mz"> generic </em>，我的意思是创建一个对话框的容器，它可以在应用程序中使用不同的内容重复使用几次，而不需要多次重写所有内容。</p><p id="2824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，过去和现在对我来说都很重要的是，modal的内容是延迟加载的，以获得最佳性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2543" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加顺风CSS</h1><p id="7ee2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我已经尝试了各种解决方案来将顺风CSS添加到Angular应用程序中，尽管有一个小的<a class="ae ky" href="https://github.com/ngneat/tailwind/issues/16" rel="noopener ugc nofollow" target="_blank">问题</a>可能很快就会得到解决，但是由团队<a class="ae ky" href="https://github.com/ngneat" rel="noopener ugc nofollow" target="_blank"> ngneat </a>提供的<a class="ae ky" href="https://github.com/ngneat/tailwind" rel="noopener ugc nofollow" target="_blank">顺风示意图</a>是迄今为止我尝试过的最简单的方法。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ab2e" class="nf md it nb b gy ng nh l ni nj">ng add @ngneat/tailwind</span></pre><p id="6769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的命令，按照提示，并享受。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bab6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">服务</h1><p id="8475" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了<code class="fe nk nl nm nb b">open</code>和<code class="fe nk nl nm nb b">close</code>任何模态，我们创建一个服务<code class="fe nk nl nm nb b">modal.service.ts</code>。它负责这些操作，还负责将它们附加到DOM <code class="fe nk nl nm nb b">body</code>。</p><p id="90ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个操作，老实说，我不知道如何用Angular来编码这些东西，我不得不在google上寻找解决方案。幸运的是，我找到了Carlos Roso的这篇很好的文章<a class="ae ky" href="https://medium.com/hackernoon/angular-pro-tip-how-to-dynamically-create-components-in-body-ba200cc289e6" rel="noopener">,它描述了所需的步骤。</a></p><p id="4c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，由于服务是在<code class="fe nk nl nm nb b">root</code>中提供的，值得注意的是，我们在内存中保存了对当前附加的组件的引用，分别显示。这样，我们一次只允许一个模态。如果您需要同时显示多个元素，我建议您用数组而不是单个类变量来处理这些元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="461e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模态容器</h1><p id="8cd9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了初始化模态容器，我们创建了一个新的模块<code class="fe nk nl nm nb b">modal.module.ts</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们添加相关的组件<code class="fe nk nl nm nb b">modal.component.ts</code>，除了创建一个默认初始化为<code class="fe nk nl nm nb b">true</code>的状态<code class="fe nk nl nm nb b">display</code>并公开一个函数<code class="fe nk nl nm nb b">close</code>之外，它没做什么。</p><p id="c63d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们延迟加载模态，这些模态将在创建时显示，因此默认状态分别是<code class="fe nk nl nm nb b">open</code>，而不是关闭。</p><p id="2d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nb b">close</code>函数包含一个小的<code class="fe nk nl nm nb b">timeout</code>,这样，在被我们之前创建的服务从DOM中有效分离之前，模态首先以图形方式消失。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器的HTML代码是从Tailwind提供的<a class="ae ky" href="https://tailwindui.com/components/application-ui/overlays/modals" rel="noopener ugc nofollow" target="_blank">免费叠加示例</a>中提取的。我们正在使用一个<code class="fe nk nl nm nb b">section</code>，我们为其应用了一个<code class="fe nk nl nm nb b">fixed</code>位置，并为其赋予了一个<code class="fe nk nl nm nb b">10</code>的<code class="fe nk nl nm nb b">z-index</code>。此外，我们也相应地设计了所需的空间、阴影和尺寸。</p><p id="df30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了UI本身，值得注意的是，我们使用了角度内容投影功能<code class="fe nk nl nm nb b">ng-content</code>，能够分别在模态中添加任何内容，使这个对话框成为一个通用容器。</p><p id="4df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将<code class="fe nk nl nm nb b">close</code>函数附加到该部分，并停止<code class="fe nk nl nm nb b">$event</code>对其内容的传播；否则，每次单击或按下它的一个子对象时，模态就会自动关闭。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="443a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们用一些定制的CSS制作了样式类<code class="fe nk nl nm nb b">open</code>的打开和关闭的动画。用一些顺风工具也许有可能实现这一点，但是我觉得用那种方式解决它更有信心。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9240" class="nf md it nb b gy ng nh l ni nj">section {<br/>  visibility: hidden;<br/>  opacity: 0;<br/><br/>  &amp;.open {<br/>    visibility: inherit;<br/>    opacity: 1;<br/>  }<br/><br/>  transition: opacity 250ms ease-in;<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="60ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模态示例</h1><p id="c571" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">设置好上面的服务和容器后，我们现在可以使用它们来创建任何模态了——例如，在下面的例子中，用户可以输入用户名。</p><p id="fc73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，该示例包含一个表单，但不是强制的。与此相反，真正<strong class="lb iu">重要的</strong>要注意:</p><p id="e1d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议你<strong class="lb iu">不要</strong>为模块声明创建一个单独的文件，但是在这种特定的情况下，在同一个文件中声明它的模块作为组件。</p><p id="7596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能不会遇到和我一样的错误，但是由于我们使用了一堆在另一个单独的模块中声明和引用的核心组件，Angular在构建时抱怨它无法解决这些问题，直到我最终发现在组件文件中添加模块可以解决构建问题。</p><p id="500d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，你的组件被投射到模态容器中，它基本上像其他独立组件一样工作。</p><p id="bb2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想添加一个按钮来从它的内容中关闭模态或者在一个函数完成后关闭它，你可以，如例子所示，使用一个<code class="fe nk nl nm nb b">ViewChild</code>来访问容器并调用我们之前声明的<code class="fe nk nl nm nb b">close</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模板的关键是容器中内容的封装，在我们之前创建的<code class="fe nk nl nm nb b">app-modal</code>组件中。至于组件的代码，没有什么特别需要注意的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c154" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模式创建</h1><p id="0090" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，由于动态导入，我们可以按需加载我们的modal示例，因此只在需要的时候才获取相关代码。此外，我们使用我们的服务来<code class="fe nk nl nm nb b">open</code>它并将其附加到DOM的<code class="fe nk nl nm nb b">body</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切都如预期的那样工作，那么模态应该是延迟加载的，我们应该能够打开和关闭示例模态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/8131d068824079af5279c9e2e6d9a7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*BY_Wt6hf0noQbjakv_2I5A.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e48e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">收场白</h1><p id="1973" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我真的很感激有机会被聘为自由职业者，在像Owlly这样的超级项目上进行合作。再次感谢桑德罗给我这个机会。我也希望这篇教程能对那些想用角度和顺风设置模态的人有所帮助，如果你有改进的想法，请告诉我！</p><p id="719a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到无限和更远的地方！</p><p id="7c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div></div>    
</body>
</html>