<html>
<head>
<title>Developing Kubernetes Native App in Golang With Hot Reload Directly Inside the Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Golang开发Kubernetes本地应用程序，直接在集群中热重装</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/developing-kubernetes-native-app-in-golang-with-hot-reload-directly-inside-the-cluster-f432a7d29384?source=collection_archive---------4-----------------------#2022-02-25">https://betterprogramming.pub/developing-kubernetes-native-app-in-golang-with-hot-reload-directly-inside-the-cluster-f432a7d29384?source=collection_archive---------4-----------------------#2022-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8489" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们讨论一下如何在Golang上直接在集群内部开发K8s原生应用，尤其是使用热重装</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bb9b08cdbc790a89e0bc6f8a4cb2885d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2ZG6wke3nrtC83vA1BYCQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Alessandro Bianchi 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将告诉您我在Golang中开发Kubernetes本地应用程序的经验，该应用程序直接在Kubernetes集群中进行热重装。</p><blockquote class="ls lt lu"><p id="27db" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">通过这种方法，我们可以使用<code class="fe lz ma mb mc b">client-go</code>库中的<code class="fe lz ma mb mc b"><a class="ae kv" href="https://pkg.go.dev/k8s.io/client-go@v0.23.4/rest#InClusterConfig" rel="noopener ugc nofollow" target="_blank">rest.InClusterConfig()</a></code>函数，并创建一个附加到角色的服务帐户来控制应用程序权限，因此配置永远不会离开集群本身。</p></blockquote><h2 id="86fa" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">准备Golang工作空间</h2><p id="3b91" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">让我们创建一个新文件夹，把<code class="fe lz ma mb mc b">main.go</code>文件放在那里。我们也可以使用go模块，现在我们可以用“hello world”函数填充<code class="fe lz ma mb mc b">main.go</code>。</p><h2 id="e7f5" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">启动Minikube集群</h2><p id="255c" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我在开发过程中使用了<code class="fe lz ma mb mc b">minikube</code>,用minikube构建本地kubernetes集群很容易。让我们使用以下命令创建一个:</p><pre class="kg kh ki kj gt nb mc nc nd aw ne bi"><span id="c4fc" class="md me iq mc b gy nf ng l nh ni">minikube start --mount-string="your-directory/your-go-app:/tmp/golang" --mount</span></pre><p id="fa8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的命令中，我们创建了一个minikube并挂载了之前创建的golang工作空间。通过这种方式，我们可以更改golang代码，并能够在部署到集群时进行热重新加载。</p><h2 id="f89f" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">热重装</h2><p id="36ff" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">对于热重新加载特性，我们将使用<a class="ae kv" href="https://github.com/githubnemo/CompileDaemon" rel="noopener ugc nofollow" target="_blank"> CompileDaemon </a>来观察golang文件中的变化并触发重建。</p><p id="2f29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将<code class="fe lz ma mb mc b">CompileDaemon</code>作为docker图像中的<code class="fe lz ma mb mc b">entrypoint</code>。当我们在运行的容器上开发应用程序时，这是拥有热重载能力的关键。</p><h2 id="6a7e" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">准备文档</h2><p id="f888" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">好的，我们需要创建一个docker文件来…当然创建我们的应用程序映像。这只是一个简单的docker文件，你可以修改它来满足你的需要。我的看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">以CompileDaemon作为入口点的Dockerfile</p></figure><p id="fee4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望输出的二进制文件在<code class="fe lz ma mb mc b">tmp/</code>目录中，所以如果你复制了上面的docker文件，不要忘记在你的Golang工作空间中创建<code class="fe lz ma mb mc b">tmp/</code>目录。</p><p id="617d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是创建app镜像，你知道怎么创建；)</p><h2 id="5fdd" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">准备开发工作区</h2><p id="3d5a" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">因为我们在集群中运行应用程序，所以我们将为我们的应用程序创建一个k8s工作负载。这需要一些工作，但是我们希望我们的应用程序运行在生产k8s集群上。</p><p id="462c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们首先要创建一个<code class="fe lz ma mb mc b">service-account</code>、一个<code class="fe lz ma mb mc b">role</code>和一个<code class="fe lz ma mb mc b">rolebinding</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务帐户、角色和角色绑定</p></figure><p id="21d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述角色将授予对来自<code class="fe lz ma mb mc b">my-namespace</code>名称空间的所有资源的访问权。当涉及到生产使用时，您应该调整特权以匹配您的需要。</p><p id="7ee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们创建了<code class="fe lz ma mb mc b">ServiceAccount</code>、<code class="fe lz ma mb mc b">Role</code>和<code class="fe lz ma mb mc b">RoleBinding</code>之后，我们将创建一个部署、PVC和PV，它们从前面的<code class="fe lz ma mb mc b">minikube start</code>命令挂载主机目录，也就是<code class="fe lz ma mb mc b">tmp/golang</code>目录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">pv、pvc和部署</p></figure><p id="fe35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我假设您使用像<code class="fe lz ma mb mc b">my-app:latest</code> :D这样的基本名称构建了您的映像。有了这些，我们开发本地k8s应用程序并在集群中进行热重装的本地工作区就准备好了。</p><h1 id="563e" class="nl me iq bd mf nm nn no mi np nq nr ml jw ns jx mo jz nt ka mr kc nu kd mu nv bi translated">开发应用程序</h1><p id="a2ae" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">准备好工作空间后，我们可以尝试来自<code class="fe lz ma mb mc b">client-go</code> github存储库的<a class="ae kv" href="https://github.com/kubernetes/client-go/tree/master/examples/in-cluster-client-configuration" rel="noopener ugc nofollow" target="_blank">集群内</a>示例。这个例子向您展示了如何配置一个客户机，以便从运行在Kubernetes集群内部的应用程序向Kubernetes API进行身份验证，这个例子与本文的目的相同。</p><h1 id="7ce7" class="nl me iq bd mf nm nn no mi np nq nr ml jw ns jx mo jz nt ka mr kc nu kd mu nv bi translated">结论</h1><p id="6fb8" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">因此，我发现当我们需要一个在集群内与k8s API对话的应用程序，并使用<code class="fe lz ma mb mc b">ServiceAccount</code>来控制应用程序权限和使用<code class="fe lz ma mb mc b"><em class="lv">client-go</em></code>库中的<code class="fe lz ma mb mc b"><a class="ae kv" href="https://pkg.go.dev/k8s.io/client-go@v0.23.4/rest#InClusterConfig" rel="noopener ugc nofollow" target="_blank"><em class="lv">rest.InClusterConfig()</em></a></code>函数时，这种方法很有用，就像上面的例子一样，因此应用程序向k8s进行身份验证的集群配置永远不会离开集群本身。</p></div></div>    
</body>
</html>