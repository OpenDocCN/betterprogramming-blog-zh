<html>
<head>
<title>What’s New in JavaScript — ES2019</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的新功能— ES2019</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/new-features-in-es2019-72f4aa1f03f7?source=collection_archive---------3-----------------------#2019-11-01">https://betterprogramming.pub/new-features-in-es2019-72f4aa1f03f7?source=collection_archive---------3-----------------------#2019-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9f5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Array.flatMap、try/catch改进等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63912618552756880e7c4bdd831f08d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pw0lnT1g2fJUbgR8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Artem Sapegin 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从ES2015发布以来，这本身就是一个巨大的飞跃，JavaScript一直在快速改进。从那以后，JavaScript规范中每年都会增加新的特性。特性一直在增加，比如内置JavaScript的新语法和新方法。</p><p id="9990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES2016和2017中，<code class="fe lv lw lx ly b">Object</code>对象增加了类似<code class="fe lv lw lx ly b">Object.values</code>和<code class="fe lv lw lx ly b">Object.entries</code>的方法。ES2017中加入了类似<code class="fe lv lw lx ly b">padStart</code>和<code class="fe lv lw lx ly b">padEnd</code>的字符串方法。ES2017中还增加了<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>，这是一种链接承诺的简写语法。ES2016中增加了数组的<code class="fe lv lw lx ly b">includes</code>方法。ES2018是另一个具有许多新功能的版本。在ES2018中，扩展语法现在可用于对象文字。还添加了休息参数。添加了<code class="fe lv lw lx ly b">for await...of</code>循环，这是一个顺序遍历承诺的循环语法。添加了用于表示无法分离的原始二进制数据的<code class="fe lv lw lx ly b">SharedArrayBuffer</code>对象。一个<code class="fe lv lw lx ly b">finally</code>函数也被添加到<code class="fe lv lw lx ly b">Promise</code>对象中。</p><p id="2538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2019年，甚至增加了更多新的JavaScript功能。2019的发布为数组和字符串带来了更多的新方法。<code class="fe lv lw lx ly b">catch</code>子句不再需要添加绑定——也就是说，不再需要<code class="fe lv lw lx ly b">catch</code>关键字后括号中的变量。</p><p id="34be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">description</code>方法已添加到<code class="fe lv lw lx ly b">Symbol</code>中。<code class="fe lv lw lx ly b">Function</code>对象的<code class="fe lv lw lx ly b">toString</code>方法现在保留了函数的所有字符，这样它就像在你的代码中一样，现在<code class="fe lv lw lx ly b">JSON.stringify</code>将总是以UTF-8编码。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="16f0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak"> Array.flat() </strong></h1><p id="1988" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">函数的作用是:将嵌套数组中的条目转换成数组顶层的条目。它递归地这样做，直到给定的深度。要在一个数组上调用<code class="fe lv lw lx ly b">flat</code>函数，我们只需进入您想要展平的级别的深度，默认为1。它返回一个新数组，子数组元素串联在其中。为了展平所有级别的嵌套数组，我们可以传入<code class="fe lv lw lx ly b">Infinity</code>。</p><p id="0ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="430b" class="nh mh it ly b gy ni nj l nk nl">const arr1 = [5, 6, [7, 8]];<br/>console.log(arr1.flat());<br/>// [5, 6, 7, 8]</span><span id="5b6c" class="nh mh it ly b gy nm nj l nk nl">const arr2 = [5, 6, [7, 8, [9, 10]]];<br/>console.log(arr2.flat());<br/>// [5, 6, 7, 8, [9, 10]]</span><span id="0734" class="nh mh it ly b gy nm nj l nk nl">const arr3 = [5, 6, [7, 8, [9, 10]]];<br/>console.log(arr3.flat(2));<br/>//  [5, 6, 7, 8, 9, 10]</span><span id="d01f" class="nh mh it ly b gy nm nj l nk nl">const arr4 = [6, 7, [8, 9, [10, 11, [12, 13, [14, 15]]]]];<br/>console.log(arr4.flat(Infinity));<br/>//  [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]</span></pre><p id="3f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，这是从嵌套数组中移除嵌套的一种非常方便的方法。这是非常有价值的，因为我们很难编写自己的函数来递归地将嵌套数组展平为一个没有嵌套或嵌套较少的展平数组。</p><p id="2484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe lv lw lx ly b">Array.flat</code>后，阵列中的空槽被移除。例如:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a034" class="nh mh it ly b gy ni nj l nk nl">const arr = [1, 2, , 3, 4];<br/>arr.flat();<br/>// [1, 2, 3, 4]</span></pre><p id="322d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">空槽从<code class="fe lv lw lx ly b">arr</code>中移除。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bf5e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Array.flatMap()</h1><p id="b9c8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">flatMap</code>方法将一个数组的条目映射到另一个数组，然后展平结果。这相当于在一个数组上调用<code class="fe lv lw lx ly b">map</code>，后跟深度为1的<code class="fe lv lw lx ly b">flat</code>。这是映射和展平的一个很好的速记，有一些用例，因为很多数组嵌套不是很深。<code class="fe lv lw lx ly b">flatMap</code>函数对如何映射数组采取回调函数。回调函数将数组、索引和调用<code class="fe lv lw lx ly b">flatMap</code>方法的原始数组的当前值作为参数。</p><p id="875a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以在下面的例子中使用<code class="fe lv lw lx ly b">flatMap</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ca30" class="nh mh it ly b gy ni nj l nk nl">let arr = [1, 2, 3];<br/><br/>arr.map(x =&gt; [x * 10]); <br/>// [[10], [20], [30]]]<br/><br/>arr.flatMap(x =&gt; [x * 10]);<br/>// [10, 20, 30]<br/><br/>arr.flatMap(x =&gt; [[x * 2]]);<br/>// [[2], [4], [6]]</span></pre><p id="8c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe lv lw lx ly b">flatMap</code>只展平了数组的一个级别。如果我们想在映射后展平多个级别，我们必须分别调用<code class="fe lv lw lx ly b">map</code>和<code class="fe lv lw lx ly b">flat</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8ca0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Function.toString()更改</h1><p id="e272" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">函数对象总是使用<code class="fe lv lw lx ly b">toString()</code>方法来获取函数的字符串表示。在ES2019中，<code class="fe lv lw lx ly b">toString()</code>函数现在保留注释和空格，以获得我们定义的函数的精确字符串表示。</p><p id="abed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有以下内容:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2dbf" class="nh mh it ly b gy ni nj l nk nl">function fn() {<br/>  /* comment */<br/>}</span><span id="7dc8" class="nh mh it ly b gy nm nj l nk nl">console.log(fn.toString())</span></pre><p id="93b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在函数上运行<code class="fe lv lw lx ly b">toString()</code>，我们现在将得到与代码完全相同的东西。这意味着这将被记录:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="bc98" class="nh mh it ly b gy ni nj l nk nl">function fn() {<br/>  /* comment */<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9790" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">JSON.stringify()修复</h1><p id="1ac6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">JSON.stringify</code>现在返回特殊unicode字符的正确字符，因为现在所有字符都是UTF-8编码的。受影响的字符范围从代码U+D800到U+DFF。</p><p id="645d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们用这些字符在一个对象上调用<code class="fe lv lw lx ly b">JSON.stringify</code>，我们不再得到错误的字符。如果我们调用<code class="fe lv lw lx ly b">JSON.stringify</code>,然后在<code class="fe lv lw lx ly b">JSON.parse</code>返回的字符串上调用<code class="fe lv lw lx ly b">JSON.parse</code>,我们在字符串化之前得到相同的字符。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/0766d8baf7d935c4da3db589d568de13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w8U-XNswSp_bnPPG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tormius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿德里·托莫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6f01" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">String.trimStart()</h1><p id="50f4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">string对象现在有了一个<code class="fe lv lw lx ly b">trimStart()</code>函数来修剪字符串开头的空白。还有一个<code class="fe lv lw lx ly b">trimLeft()</code>方法，它是这个方法的别名。</p><p id="e0ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d51e" class="nh mh it ly b gy ni nj l nk nl">let message = '   Hi! How\'s it going?   ';</span><span id="b92b" class="nh mh it ly b gy nm nj l nk nl">console.log(message);</span><span id="a729" class="nh mh it ly b gy nm nj l nk nl">// We get '   Hi! How's it going?   '</span><span id="534b" class="nh mh it ly b gy nm nj l nk nl">let message = '   Hi! How\'s it going?   ';<br/>console.log(message.trimStart());</span><span id="758a" class="nh mh it ly b gy nm nj l nk nl">// We get 'Hi! How's it going?   '</span></pre><p id="59de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，左边的空白消失了。我们可以用<code class="fe lv lw lx ly b">trimLeft()</code>做同样的事情:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c854" class="nh mh it ly b gy ni nj l nk nl">let message = '   Hi! How\'s it going?   ';<br/>console.log(message.trimLeft());</span><span id="3b67" class="nh mh it ly b gy nm nj l nk nl">// We get 'Hi! How's it going?   '</span></pre><p id="4439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果用<code class="fe lv lw lx ly b">trimStart</code>或<code class="fe lv lw lx ly b">trimLeft</code>返回一个新的字符串，那么原来的字符串保持不变。这可以防止我们改变原始字符串，这对于防止意外改变对象的错误是很方便的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5b73" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">String.trimEnd()</h1><p id="6460" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">trimEnd</code>方法删除字符串右端的空白。<code class="fe lv lw lx ly b">trimRight</code>是<code class="fe lv lw lx ly b">trimEnd</code>方法的别名。例如，我们写道:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7aa0" class="nh mh it ly b gy ni nj l nk nl">let message = '   Hi! How\'s it going?   ';<br/>console.log(message);<br/>// We get '   Hi! How's it going?   '</span><span id="7a5c" class="nh mh it ly b gy nm nj l nk nl">let message = '   Hi! How\'s it going?';<br/>console.log(message.trimEnd());<br/>// We get '   Hi! How\'s it going?'</span></pre><p id="052b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果用<code class="fe lv lw lx ly b">trimEnd</code>或<code class="fe lv lw lx ly b">trimRight</code>返回一个新字符串，那么原始字符串保持不变。这可以防止我们改变原始字符串，这对于防止意外改变对象的错误是很方便的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c556" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">可选Catch绑定</h1><p id="2395" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在ES2019中，<code class="fe lv lw lx ly b">catch</code>子句不必添加绑定。也就是说，<code class="fe lv lw lx ly b">catch</code>关键字后括号中的变量不再需要。这意味着现在我们可以这样写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9082" class="nh mh it ly b gy ni nj l nk nl">try {<br/>    ···<br/>} catch {<br/>    ···<br/>}</span></pre><p id="755c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们不必写这个:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="66f9" class="nh mh it ly b gy ni nj l nk nl">try {<br/>    ···<br/>} catch (error) {<br/>    ···<br/>}</span></pre><p id="fab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着如果我们不必使用<code class="fe lv lw lx ly b">error</code>对象，我们就不必将绑定添加到<code class="fe lv lw lx ly b">catch</code>子句中。这对于忽略错误或者我们不关心错误是什么很有用。然而，<code class="fe lv lw lx ly b">error</code>对象对于记录和检查属性输入仍然很方便——并且优雅地处理错误将防止抛出异常。</p><p id="98b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以用它来捕捉任何类型的异常，比如用<code class="fe lv lw lx ly b">JSON.parse</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0928" class="nh mh it ly b gy ni nj l nk nl">try {<br/>  return JSON.parse(str);<br/>} catch {<br/>  return {}<br/>}</span></pre><p id="261b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以优雅地处理无效JSON字符串的错误。唯一的问题是我们只是吞下所有的异常，所以捕捉一些类型的错误可能是一个更好的主意。</p><p id="efa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以用它来使用并非所有浏览器都支持的浏览器功能。例如:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e9a2" class="nh mh it ly b gy ni nj l nk nl">try {<br/>  navigator.geolocation<br/>} catch {<br/>  return false;<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f286" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">符号.描述</h1><p id="2310" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Symbols是一种原始数据类型，它有自己的类型。有一些它自己的静态属性和方法公开全局符号注册表。它就像一个内置对象，但是它没有构造函数，所以我们不能写<code class="fe lv lw lx ly b">new Symbol</code>用<code class="fe lv lw lx ly b">new</code>关键字构造一个符号对象。它主要用于对象中的唯一标识符。这是一个符号的唯一目的。</p><p id="aa3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创造新的符号，我们可以这样写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="69b6" class="nh mh it ly b gy ni nj l nk nl">const fooSymbol = Symbol('foo')</span></pre><p id="e981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，每次我们调用<code class="fe lv lw lx ly b">Symbol</code>函数，我们都会得到一个新的符号——这个表达式可能是假的:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b9b2" class="nh mh it ly b gy ni nj l nk nl">Symbol('sym') === Symbol('sym')</span></pre><p id="21b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于ES2019，我们有一个只读的<code class="fe lv lw lx ly b">description</code>属性。它返回一个字符串，该字符串包含我们传递给<code class="fe lv lw lx ly b">Symbol</code>函数的参数或众所周知的符号的对象属性路径。</p><p id="6d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用上面的例子并使用<code class="fe lv lw lx ly b">description</code>属性，我们得到这样的结果:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6082" class="nh mh it ly b gy ni nj l nk nl">const fooSymbol = Symbol('foo');<br/>console.log(fooSymbol.description);</span></pre><p id="f908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe lv lw lx ly b">foo</code>日志。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="2a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过ES2019，我们获得了更多可用于开发JavaScript应用的新功能。</p><p id="3dda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2019的发布为数组和字符串带来了更多的新方法。<code class="fe lv lw lx ly b">catch</code>子句不再需要添加绑定。也就是说，<code class="fe lv lw lx ly b">catch</code>关键字后括号中的变量不再需要。</p><p id="e7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">descrption</code>方法已添加到<code class="fe lv lw lx ly b">Symbol</code>中。</p><p id="5eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Function</code>对象的<code class="fe lv lw lx ly b">toString</code>方法现在保留了函数的所有字符，这样它就像在你的代码中一样。</p><p id="f110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">JSON.stringify</code>将始终以UTF-8编码，所以现在当我们尝试从代码U+D800到U+DFF的字符串字符时，不会出现畸形字符。</p><p id="e232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，现在不用用<code class="fe lv lw lx ly b">flat</code>和<code class="fe lv lw lx ly b">flatMap</code>方法编写我们自己的代码就可以展平数组。</p></div></div>    
</body>
</html>