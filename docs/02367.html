<html>
<head>
<title>JavaScript Memoization and Expensive Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript记忆化和昂贵的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-memoization-and-expensive-code-1a0aaa37a241?source=collection_archive---------23-----------------------#2019-11-25">https://betterprogramming.pub/javascript-memoization-and-expensive-code-1a0aaa37a241?source=collection_archive---------23-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构造函数示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/91f758342e4e4409893be82f4e88049e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0H3ygbXmDR0X0R-7agiZNQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Agnieszka Boeske 在<a class="ae ky" href="https://unsplash.com/s/photos/browser?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个主流浏览器都有自己的JavaScript引擎，以实现高性能和优化。</p><p id="4b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/01Clarian/Memoization-Cache-Guide" rel="noopener ugc nofollow" target="_blank">源代码</a> — <a class="ae ky" href="https://www.youtube.com/watch?v=4U4Yv7Su6Zk&amp;list=UUDoV8qhKxPN4UkKOkXD0QSw&amp;index=1" rel="noopener ugc nofollow" target="_blank">视频教程</a></p><p id="f8e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现实情况是，JavaScript引擎(如Google的V8)的性能非常好，以至于对于运行时复杂度较低的小程序来说，速度几乎是不言而喻的，对于一个普通的开发人员来说，速度通常不是他们最关心的问题。</p><p id="0b88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，可以理解像析构函数这样冗长的有价值的编码技巧，或者像记忆化这样的技术可能看起来像来自另一个世界的模糊的、遥远的杂音，没有真正直接的实际含义。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ec4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">当记忆变得可行时</h1><p id="3a12" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，当你用一个小的计算脚本和一个文件构建一个像计算器一样的基本程序时，这是非常公平的。然而，如果你的胃口开始增加，从制作计算器和俄罗斯方块到全栈电子商务网站，那么你就进入了一个全新的复杂领域。</p><p id="95e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">突然间，曾经来自遥远的学术文献和虚拟课程领域的优化技术的回声变成了维持有竞争力的功能应用的必要工具。</p><p id="e650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可广泛访问的应用程序随着使用的增加而扩展，更极端的例子包括<strong class="lb iu"> Youtube </strong>或<strong class="lb iu"> AirBnb </strong>，需要更昂贵的运行时复杂性——这就是像memoization这样的技术成为不可或缺的工具的地方。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee49" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">打破记忆</h1><p id="a543" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为一种技术，当有条件地应用于JavaScript函数时，记忆化可以极大地提高应用程序的执行速度。</p><p id="6442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存化是一种特定类型的缓存系统，能够通过存储函数调用的昂贵结果并在相同的输入再次出现时返回缓存结果来提高性能。</p><p id="fbb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，昂贵的结果指的是耗时的计算，可能会降低应用程序的速度。然而，从这个意义上说，这种缓存技术为函数提供了一个人造的内部存储空间。</p><p id="0c36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像这样，如果结果已经被缓存，函数可以通过返回缓存的结果来减少计算开销。</p><p id="ded1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更简单地说，从某种意义上来说，<em class="mz">记忆</em>就是<em class="mz">记忆</em>或者存储数据——让被记忆的函数更快地访问数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/db50efa9e31e23341ba74eb59b4afbec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYl98b1p62Sm9YzDYSpwZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">存储昂贵的函数调用允许更快的访问和返回。</p></figure><p id="0e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续前进之前，让我们停下来喝一口咖啡，整理一下思绪。</p><p id="20c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些概念是新的，到目前为止似乎很难掌握，没有必要担心——这一点也不奇怪。</p><p id="73e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些本质上是JavaScript中记忆化理论用例的核心原则。通过将这些要点应用到以下文档中的相关类比和测井测试结果，我们的目标是通过实际应用巩固我们对记忆化的理论理解。</p><p id="c998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们做我们最擅长的事情:多喝点咖啡，打开文本编辑器，开始编码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d91" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">示例功能设置和比较</h1><p id="0fd3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了说明记忆一个函数的价值，我们将使用提供的相关上下文构建一个函数，记忆那个函数，然后比较和对比结果。</p><p id="72a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种记忆的相关类比功能将被称为构造功能。首先，打开文本编辑器，创建一个链接到script.js文件的index.html文件。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="66e1" class="ng md it nc b gy nh ni l nj nk">&lt;script type="text/javascript" src="script.js"&gt;&lt;/script&gt;</span></pre><p id="a83c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，用以下注释适当地注释标题构造函数:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="8dc1" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">// MEMOIZATION AND CACHING: THE CONSTRUCTION FUNCTION EXAMPLE</strong></span><span id="82bb" class="ng md it nc b gy nl ni l nj nk">// In order to better our understanding of Memoization, we will write a function</span><span id="067f" class="ng md it nc b gy nl ni l nj nk">// entitled '<strong class="nc iu">Building</strong>' and apply various logged results to observe the behaviour</span><span id="6727" class="ng md it nc b gy nl ni l nj nk">// of JavaScript.</span></pre><p id="a223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">附加说明:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="c003" class="ng md it nc b gy nh ni l nj nk">// In this example, you are the boss of a construction company.</span><span id="2c58" class="ng md it nc b gy nl ni l nj nk">// The construction company will be a reference to your Application.</span><span id="a0b0" class="ng md it nc b gy nl ni l nj nk">// Javascript execution commands will be traced by a reference to  // your Construction  Companies employees: Bob and Susy. </span></pre><p id="c1ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，你是一家建筑公司的老板。首先，创建一个名为<code class="fe nm nn no nc b">Building</code>(表示您正在构建的站点)的函数，第一个参数是<code class="fe nm nn no nc b">tasks</code>(表示要在建筑物上做的工作)。</p><p id="2cdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，发送一个雇员，我们称之为<code class="fe nm nn no nc b">Bob</code>的字符串，来完成建筑工地的任务。</p><p id="1724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bob还有指示说建筑工地可能有破裂的管道。鲍勃必须先去现场，看看他需要什么来修理管道，然后分派到一个仓库，带回必要的工具。</p><p id="5836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">这将表示为以下日志:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/8237e4fd0d5541690796e70caa9393da.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*LUfIn70whWZy_V04k4RrPw.png"/></div></figure><p id="6852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在日志分派之后，返回<strong class="lb iu">任务</strong>和一个连接的字符串，表明工作已经完成。</p><p id="a11d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让Bob知道记录<code class="fe nm nn no nc b">Building </code>的结果，以便Bob可以获得工作报酬。</p><p id="9499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">Building</em>函数现在看起来应该是这样的:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b478" class="ng md it nc b gy nh ni l nj nk">function <strong class="nc iu">Building</strong>(tasks) {</span><span id="29b3" class="ng md it nc b gy nl ni l nj nk">    console.log('Dispatch To Depot!')</span><span id="7ef9" class="ng md it nc b gy nl ni l nj nk">        return tasks + ' The work is complete.'</span><span id="3a01" class="ng md it nc b gy nl ni l nj nk">}</span><span id="b73b" class="ng md it nc b gy nl ni l nj nk">console.log(<strong class="nc iu">Building</strong>("Bob's log:"))</span></pre><p id="e10d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在浏览器中运行index.html文件，并检查开发工具以获得以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/d9490f931dd413cf33c6305d1d0acc59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sk4ldWYSOm0SI1fNjwrggQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">源部分开发工具</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/a3b1335e0d40b02cc15eb4a32c3ce79e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8mPWQAla7L8t9ANtrNBQYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台部分开发工具</p></figure><p id="2d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据这些结果，我们现在可以看到Bob做了以下事情。</p><ul class=""><li id="4b94" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">进入大楼，找到了修理管道所需的工具。</li><li id="9ef1" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">派遣<strong class="lb iu">ed到仓库获取工作所需的工具。</strong></li><li id="69c3" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">返回</strong> ed完成工作所需的任务。</li><li id="e8d5" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">日志</strong>退出工作序列以获得报酬。</li></ul><p id="285c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这些结果，我们公司的工作流程似乎没有问题。Bob执行了他的所有任务，并相应地记录了他的结果。</p><p id="524a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个一次性的工作来说，这一切似乎都进行得很好，没有发生任何事故。但是，如果这是一项为期三天的工作，Bob必须返回该站点三次才能完成工作，会发生什么情况呢？</p><p id="523f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进一步说明这种类比，让我们将函数的任务设置为三次<strong class="lb iu">鲍勃的日志</strong>的字符串，用每个唯一的日期字符串指定每个日志:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b45e" class="ng md it nc b gy nh ni l nj nk">function Building(tasks) {</span><span id="1c86" class="ng md it nc b gy nl ni l nj nk">    console.log('Dispatch To Depot!')</span><span id="60a8" class="ng md it nc b gy nl ni l nj nk">        return tasks + ' The work is complete.'</span><span id="477b" class="ng md it nc b gy nl ni l nj nk">}</span><span id="9288" class="ng md it nc b gy nl ni l nj nk">console.log('<strong class="nc iu">Day 1</strong>: ', Building("Bob's log:"))</span><span id="db6c" class="ng md it nc b gy nl ni l nj nk">console.log('<strong class="nc iu">Day 2:</strong> ', Building("Bob's log:"))</span><span id="300a" class="ng md it nc b gy nl ni l nj nk">console.log('<strong class="nc iu">Day 3</strong>: ', Building("Bob's log:"))</span></pre><p id="2c2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">刷新浏览器并检查以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/052b6d21d8b3906fb4e66bb354c01d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m__IKsrkqr9BakrUsvSZNw.png"/></div></div></figure><p id="bb95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在看到Bob完成了三天的所有任务并记录了结果。看起来一切都很顺利，那还有什么问题呢？好吧，让我们沉思地呷一口乔，然后考虑一下。</p><p id="bab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你猜对了！尽管Bob已经完成了三天的工作，但如果您还记得我们公司的类比，他还必须去仓库修理管道。</p><p id="3f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，函数仍然像预期的那样工作。然而，如果Bob开车去仓库花了几个小时才买到供应品呢？当我们提到<strong class="lb iu">昂贵的通话</strong>时，这就是我们所说的记忆化。</p><p id="ccb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果Bob将这些工具存放在现场附近，岂不是更有意义，并为公司节省了宝贵的时间和金钱？</p><p id="e747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，Bob可以通过将他需要的工具存储在站点附近以备将来访问来节省昂贵的调用，因此JavaScript可以将昂贵的函数调用存储在缓存中，然后在必要时返回缓存。当相同的输入(Bob的日志)再次出现时，我们的记忆化函数将返回缓存结果，这可能会节省宝贵的计算运行时间。这种技术被称为记忆化。</p><p id="32d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在明白了吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4354" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为昂贵的结果存储缓存范围</h1><p id="b3c9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们继续实现这个为我们的<code class="fe nm nn no nc b">Building </code>函数设置的记忆，并看看它是如何工作的。</p><p id="7e7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建一个设置为块范围<strong class="lb iu">的对象缓存，让</strong>位于我们的<code class="fe nm nn no nc b">Building </code>函数之上。这将是调度日志的存储对象。</p><p id="6c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写I<strong class="lb iu">f else</strong>condition<strong class="lb iu"/>检查任务是否已经作为数组发送到对象缓存。如果缓存已经接收到任务，那么只返回需要完成的任务。否则，记录字符串“发送到仓库！”并返回任务等于原始连接字符串的缓存，“工作完成。”</p><p id="fcc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的脚本文件现在应该修改为:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="eda5" class="ng md it nc b gy nh ni l nj nk">let cache = {};</span><span id="7170" class="ng md it nc b gy nl ni l nj nk">function Building(tasks) {</span><span id="f68e" class="ng md it nc b gy nl ni l nj nk">   if(tasks in cache) {</span><span id="0685" class="ng md it nc b gy nl ni l nj nk">      return cache[tasks]</span><span id="7ed1" class="ng md it nc b gy nl ni l nj nk">         } else {</span><span id="2612" class="ng md it nc b gy nl ni l nj nk">      console.log('Dispatch To Depot!')</span><span id="589d" class="ng md it nc b gy nl ni l nj nk">      return cache[tasks] = tasks + ' The work is complete.'</span><span id="b1af" class="ng md it nc b gy nl ni l nj nk">}}</span><span id="4222" class="ng md it nc b gy nl ni l nj nk">console.log('Day 1: ', Building("Bob's log:"))</span><span id="33af" class="ng md it nc b gy nl ni l nj nk">console.log('Day 2: ', Building("Bob's log:"))</span><span id="45ad" class="ng md it nc b gy nl ni l nj nk">console.log('Day 3: ', Building("Bob's log:"))</span></pre><p id="96a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次刷新浏览器中的index.html文件，并检查开发工具以获得以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/ca2ca43db4ab4377febd2d716859e991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*921kZLZbRK5S6QDzVnSNnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查CSS标题样式的源代码:)</p></figure><p id="0a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的结果将连续三次执行工作的数据发送给我们，而不必每次都调用调度日志。</p><p id="d430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dispatch只需要调用一次，因为我们的数据现在可以被对象的缓存访问。如果调度控制台日志是一个耗费数千毫秒的函数，那么这个系统将会节省我们脚本宝贵的运行时间。我们现在清楚地展示了记忆的价值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d5dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="fc94" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将JavaScript与我们的建筑公司进行比较，也可以清楚地看到通过记忆化我们将如何为公司节省昂贵的时间。</p><p id="bb21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bob不再需要每次都去取修理破裂管道所需的工具，因为这些工具都存放在本地，他现在可以更快地获得它们。例如，如果Bob在第二天请了病假，而我们让另一名员工Susan去上班，结果就会改变。</p><p id="1718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过将第二个日志中建筑物的输入字符串切换到“Susan的日志”来看到这一点。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="abea" class="ng md it nc b gy nh ni l nj nk">console.log('Day 1: ', Building("Bob's log:"))</span><span id="b609" class="ng md it nc b gy nl ni l nj nk">console.log('Day 2: ', Building("Susan's log:"))</span><span id="66f9" class="ng md it nc b gy nl ni l nj nk">console.log('Day 3: ', Building("Bob's log:"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/4668e67c9f23f56348dbf026e3c3b809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2tKZhMyF9zWQRf0wn3CAQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果第二个日志是<strong class="bd oj"> Susan的日志</strong>的预期结果</p></figure><p id="ecee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于输入是不同的，Susan在缓存对象中没有先前的存储，因此再次初始化分派日志。但是，第3天日志不需要记录派单，因为它记录的是Bob，可以直接从缓存中获取数据。这就是它的要点。</p><p id="6ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些知识，我们现在可以期待为公司和我们的应用程序节省大量的时间复杂性。</p><p id="d908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这个建筑公司关于JavaScript中的记忆化和缓存的类比！</p><p id="2275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，请留下你的评论，或者随时查看这篇文章顶部的代码和视频解释。</p><p id="2dac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我希望您能从中找到一些有用的东西，并了解如何通过这个简单的记忆化函数实现，我们可以通过增强应用程序的整体性能和可用性来节省宝贵的处理时间！</p></div></div>    
</body>
</html>