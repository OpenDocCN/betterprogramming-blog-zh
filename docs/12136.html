<html>
<head>
<title>Compile-Time Polymorphism in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的编译时多态性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/compile-time-polymorphism-in-c-f5ca6934cc55?source=collection_archive---------1-----------------------#2022-05-14">https://betterprogramming.pub/compile-time-polymorphism-in-c-f5ca6934cc55?source=collection_archive---------1-----------------------#2022-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c78" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">面向对象编程是一个兔子洞，多态只是洞中的另一根线，让我们看看它能钻多深。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d8674fa3747bc14d8e07bbba7416ee0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*atvsGU2ed6g3B62a"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@thaliatran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塔利亚·特兰</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6cca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将带您踏上揭开编译时多态之谜的旅程。此外，在<code class="fe ls lt lu lv b">C#</code>中，我们正好有合适的材料来使它变得更糟，方法重载和覆盖，我们还有方法隐藏的概念，这使多态的整个想法有点令人困惑。这就是为什么我要把这个想法分成三个部分来消除困惑。</p><p id="e6ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个由3篇文章组成的系列，我们将在其中深入探讨多态性。以下是拼图的三个部分。</p><ol class=""><li id="7533" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">编译时多态性</li><li id="841b" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><a class="ae kv" href="https://medium.com/@RikamPalkar/run-time-polymorphism-in-c-6f9687857ba6" rel="noopener">运行时多态性</a></li><li id="25a8" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><a class="ae kv" href="https://medium.com/@RikamPalkar/method-hiding-in-c-d653f822ab33" rel="noopener">方法隐藏/隐藏</a></li></ol><h1 id="ea29" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">为什么称之为编译时多态性？</h1><p id="2c16" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">因为编译器知道在编译时根据方法的签名调用哪个方法。这种依赖性是在编译时解决的。好吧！这在理论上听起来不错，但让我们看看它实际上是如何工作的。</p><p id="0945" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍等一下！！，你说的方法签名是什么意思？</p><p id="de6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何方法都有四个部分。</p><ol class=""><li id="5e4c" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">方法名称，</li><li id="710e" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">返回类型，</li><li id="6c99" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">参数，</li><li id="d71b" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">访问说明符</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单1:方法签名</em></p></figure><p id="4bf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发者社区之间有一个巨大的争论，返回类型是否应该是方法签名的一部分！！</p><p id="74f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从微软那里澄清这个困惑怎么样？</p><blockquote class="nk nl nm"><p id="9524" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">按照微软的说法，“方法的返回类型不是方法重载的方法签名的一部分。但是，在确定委托和它所指向的方法之间的兼容性时，它是方法签名的一部分。</p></blockquote><p id="8932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，当“覆盖一个方法”时，返回类型被认为是方法签名的一部分。</p><p id="c8c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当“重载一个方法”时，它就被忽略了。</p><p id="ab06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过实际的编码一步步理解多态性，通过编码示例，我们将学习支持上述论点的行为。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="6e56" class="mk ml iq bd mm mn ny mp mq mr nz mt mu jw oa jx mw jz ob ka my kc oc kd na nb bi translated">所以深呼吸，和我一起踏上这段旅程。</h1><p id="fa59" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">重载方法时，有几个规则需要注意。</p><ol class=""><li id="bb81" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">Type</code>的参数应该是不同的，参数的名称并不重要。</li><li id="e323" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">参数的数量应该不同。</li><li id="1201" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">参数的顺序应该不同。</li><li id="5586" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">最后但并非最不重要的是，<code class="fe ls lt lu lv b">return-type</code>、<code class="fe ls lt lu lv b">access specifiers</code>或任何其他花哨的关键字，如<code class="fe ls lt lu lv b">static</code>、<code class="fe ls lt lu lv b">abstract</code>、<code class="fe ls lt lu lv b">sealed</code>、<code class="fe ls lt lu lv b">virtual</code>都不会被考虑在内。</li></ol><p id="1bdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了演示这些规则，我将在整篇文章中遵循UML进行编码，这将触及方法重载的几乎所有方面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/deffdd9e93957677e24188f8c0100d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-iJCNh44iIpg97Kroug7fA.png"/></div></figure><h1 id="dce3" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">让我们为一些我们喜欢的超级英雄设计一些服装？</h1><p id="71cc" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">假设我们正在设计一个<code class="fe ls lt lu lv b">class superhero</code>，我们的任务是定制一套服装。可能会有不同的争论，衣服的颜色，衣服的类型，或者英雄是否喜欢穿内裤等等。让我们继续设计一个类来实现这些要点。</p><p id="4a29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码片段中，我们正在为一个“超人”设计一套衣服。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单2:职业超级英雄</em></p></figure><p id="710b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要你想让你默认的超级英雄成为超人，这段代码就能起作用。但是让我们面对现实吧，他没那么好。所以为了给另一个超级英雄定制一套衣服，我们可以单独造一套<code class="fe ls lt lu lv b">method CustomizeSuit()</code>。</p><p id="cdd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我有<code class="fe ls lt lu lv b">typeOfSuit</code>，我想定制它，它可以是皮革或金属套装。为了对此进行编码，我可以简单地创建一个接受一个参数<code class="fe ls lt lu lv b">string type</code>的方法，该参数将是<code class="fe ls lt lu lv b">typeOfSuit</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单3:带有一个参数的方法定制套件</em></p></figure><blockquote class="nk nl nm"><p id="35a5" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated"><strong class="ky ir">规则#1: </strong>参数的类型应该不同，参数的名称无关紧要。</p></blockquote><p id="7084" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的超级英雄表达了对金属套装的兴趣，现在他显然不能在上面穿内衣。所以我可以简单地重载<code class="fe ls lt lu lv b">CustomizeSuit() method</code>来接受不同类型的参数。在这里，我们重载了一个接受<code class="fe ls lt lu lv b">boolean type</code>的方法，如果这个参数的值为<code class="fe ls lt lu lv b">true</code>，那么我们的英雄将会在外面穿上一件内衣。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单3:带有布尔参数</em>的重载方法CustomizeSuit</p></figure><blockquote class="nk nl nm"><p id="b357" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated"><strong class="ky ir">规则#2: </strong>参数个数应该不同。</p></blockquote><p id="e815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些用户想要定制服装类型或者决定内衣的位置，但是其他用户可能对两者一起改变感兴趣。我们可以简单地通过用不同数量的参数重载一个方法来实现这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单4:带有两个参数string和boolean的重载方法CustomizeSuit】</em></p></figure><blockquote class="nk nl nm"><p id="0ab1" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated"><strong class="ky ir">规则#3: </strong>参数的顺序应该不同。</p></blockquote><p id="546e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以有相同数量的参数，但顺序必须不同，例如我可以从<code class="fe ls lt lu lv b">listing 4</code>中获取代码并这样做。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单5:带有两个参数boolean和string的重载方法CustomizeSuit】</em></p></figure><p id="55f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="nn">清单5解释:</em> </strong>我只是互换了清单5中参数的顺序。编译器查找参数的索引及其类型。如果<code class="fe ls lt lu lv b">Type</code>在同一个索引处不同，那么它是一个有效的重载方法。</p><p id="7e2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种变化可能如清单6所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单6:带有两个参数string和string的重载方法CustomizeSuit】</em></p></figure><blockquote class="nk nl nm"><p id="094a" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated"><strong class="ky ir">规则#4: </strong>最后但同样重要的是，返回类型、访问说明符或任何其他花哨的关键字，如static、abstract、sealed、virtual，都没有任何意义。</p></blockquote><p id="073c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们全力以赴，好吗？</p><blockquote class="nk nl nm"><p id="944f" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated"><strong class="ky ir">规则#4.1 </strong>:不考虑返回类型。</p></blockquote><p id="3841" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的例子中，除了<code class="fe ls lt lu lv b">return-type</code>，两个方法之间的一切都是一样的。如果您有两个签名相同但<code class="fe ls lt lu lv b">return-type</code>不同的方法，则不认为是方法重载。编译器将抛出编译时异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单7:具有相同签名但不同返回类型的重载方法定制套件</em></p></figure><p id="3865" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">异常:</strong>类型<code class="fe ls lt lu lv b">‘SuperHero’</code>已经定义了具有相同参数类型的成员<code class="fe ls lt lu lv b">‘CustomizeSuit’</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/afbd16c7ebea133f71bcfae979a353d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ocff_3fFrl3GVg8YrQs9g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:返回类型被忽略的异常快照</p></figure></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><blockquote class="nk nl nm"><p id="9c36" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">规则#4.2: 访问说明符被忽略</p></blockquote><p id="3c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">规则4.1很酷，现在对于规则4.2，我们需要改变访问说明符。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单8:具有相同签名但不同访问说明符的重载方法定制套件</em></p></figure><p id="e86f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样好的例外！！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/926364dafbe568f9e5f8e0e52b1fdf73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wsBfQAgqk5QP2GvRAcy50A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:忽略访问说明符的异常快照</p></figure><blockquote class="nk nl nm"><p id="8a75" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">规则#4.3: 特殊关键字被忽略</p></blockquote><p id="a92d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的截图中，您会看到，没有一个关键字使用重载方法。所以用这些关键字装饰一个方法对重载的概念来说毫无意义。</p><p id="d97d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:对于抽象方法，我已经将class标记为abstract。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/b6bc0dbb49e2bf181d0ec7bea1eea4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*RTrFuYcFtHW8kZ9Nui0SFw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图CustomizeSuit方法上不同装饰者的几个例子</p></figure><p id="3faa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上所有方法都属于同一例外。</p><p id="18ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型<code class="fe ls lt lu lv b">‘SuperHero’</code>已经用相同的参数类型定义了一个名为<code class="fe ls lt lu lv b">‘CustomizeSuit’</code>的成员</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c627c038d0a0029df812d0576435cc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*Bzatz5T8pjCe0zN2pazJAA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4:编译时异常</p></figure><p id="2dcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在方法重载方面已经走了很长一段路，有一个更重要的概念我想在这里作为加分。</p><h1 id="55b2" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">用继承重载方法</h1><p id="f2fa" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">下面的代码片段是一个父<code class="fe ls lt lu lv b">class SuperHero</code>。它包含了我们到目前为止讨论过的所有重载方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单9:具有4个重载方法的超级英雄类</em></p></figure><p id="b452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个继承父类<code class="fe ls lt lu lv b">class SuperHero</code>的子类</p><p id="634b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">跟随<code class="fe ls lt lu lv b">class IronMan</code>的是<code class="fe ls lt lu lv b">class SuperHero</code>的孩子。它非常优雅地用3个参数重载了一个<code class="fe ls lt lu lv b">CustomizeSuit() method</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nj">清单10:具有1个重载方法的IronMan类</em></p></figure><h2 id="05df" class="oi ml iq bd mm oj ok dn mq ol om dp mu lf on oo mw lj op oq my ln or os na ot bi translated">耶！！你没听错，方法重载并不局限在同一个类中。</h2><p id="e277" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我已经创建了父类和子类的实例。看看下面的图片5，我用父对象得到了4个重载的方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/a54f9fbd7b457918f9a0be5cf0b421c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ur8dRkhWED3C1ZFYWbYZqw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5:显示重载方法CustomizeSuit数量的父对象</p></figure><p id="9b8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看当我们试图用一个孩子的对象调用<code class="fe ls lt lu lv b">CustomizeSuit()</code>时会得到什么数字。正如您在图6中看到的，子类A.K.A. <code class="fe ls lt lu lv b">IronMan</code>多了一个额外的计数，它引用了我们刚刚在清单10中创建的方法。因此，事实证明，你可以从不同的类重载一个方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/398f76489433588a68ce3f388e705e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KorFgP2QoAk23v8OX6yfeQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6:显示数字重载方法CustomizeSuit的子对象</p></figure><p id="4f25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管我可以在子类中重载父类的方法，但仍有一件事我们应该知道。</p><blockquote class="nk nl nm"><p id="dac9" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">注:</em> </strong> <em class="iq">我上面说的四条规则只适用于同一类内。</em></p></blockquote><p id="1fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不要在这里混淆！让我用一个例子来说明这一点。看看下面两张图7和8。</p><p id="8073" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下图中，<code class="fe ls lt lu lv b">CustomizeSuit() method</code>在<code class="fe ls lt lu lv b">class SuperHero</code>中定义，同样的方法在<code class="fe ls lt lu lv b">class IronMan</code>中再次定义，看起来编译器对此没有问题。</p><p id="6839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">class SuperHero</code>的对象将调用它自己的<code class="fe ls lt lu lv b">CustomizeSuit() method</code>版本，而<code class="fe ls lt lu lv b">class IronMan</code>的对象将有额外的count重载方法，但它仍将调用自己的<code class="fe ls lt lu lv b">CustomizeSuit() method</code>实现。</p><blockquote class="nk nl nm"><p id="2c1a" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">要点是，只有当你处于不同的类型时，你才能拥有重载方法的相同签名。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/ccae57cee60845c26a11ec0250139e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXKqdbqYUetnZZa9QbuGnQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图7:两个类有相同签名的方法</p></figure><blockquote class="nk nl nm"><p id="f5f1" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">但是在同一类型中不能有相同的签名。</p></blockquote><p id="f618" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请看图8中编译器的反应。当我在同一个<code class="fe ls lt lu lv b">class</code>中重载一个具有相同签名的方法时，它给我一个错误。所以请记住，这四条规则适用于同一个<code class="fe ls lt lu lv b">class</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/1e1f0c95b0db4d1e1ca9c1d66bb63c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KppzDVxT9Lm61ckoUpD9kg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图8:具有相同签名的方法在相同的类型中定义</p></figure><h1 id="96c8" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">结论</h1><p id="686c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">是的，当我们试图涵盖所有的可能性时，方法重载可能会令人难以招架，但是一旦你清楚了基本原理，你将能够理解它在面向对象编程中的用途。在本文中，我们通过不同的例子深入探讨了各个方面，以理解在编译时多态性方面什么是可接受的，什么是不可接受的。</p><pre class="kg kh ki kj gt oy lv oz pa aw pb bi"><span id="b570" class="oi ml iq lv b gy pc pd l pe pf"><strong class="lv ir">Want to Connect?</strong></span><span id="dcae" class="oi ml iq lv b gy pg pd l pe pf">Hit me up on <a class="ae kv" href="https://www.linkedin.com/in/rikampalkar" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>