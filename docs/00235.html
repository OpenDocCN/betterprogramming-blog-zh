<html>
<head>
<title>Understanding Functional Components and Class-Based Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解功能组件和基于类的组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-functional-components-895321b1af84?source=collection_archive---------0-----------------------#2018-11-26">https://betterprogramming.pub/understanding-functional-components-895321b1af84?source=collection_archive---------0-----------------------#2018-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="092c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">何时使用哪个React组件的经验法则</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/44d6eece7bf7014fbf8d711cacdd4c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOeXdLwI3cW99wuduFlwZg.png"/></div></div></figure><p id="c977" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>就是让你的前端代码保持模块化和可重用。</p><p id="abe2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组件在使React模块化方面起着至关重要的作用。组件是React的构建块。使用正确的组件可以确保前端代码的可重用性和可伸缩性。</p><p id="7f11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React中有两种类型的组件:</p><ul class=""><li id="43f4" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">功能组件</li><li id="2450" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">基于类的组件</li></ul><p id="8da0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用正确类型的组件将对代码的可重用性和性能产生很大的影响。</p><p id="332b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这一部分中，我们将探索功能组件和基于类的组件之间的区别，这两种类型的组件的优缺点，以及决定何时使用什么的经验法则。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="22bf" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">功能组件</h1><p id="8d52" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">假设我们需要创建一个组件来打印欢迎消息。让我们创建一个名为<code class="fe ng nh ni nj b"><em class="nk">welcomeMessage</em></code>的组件。</p><p id="1d52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该组件最简单的形式如下所示:</p><pre class="kg kh ki kj gt nl nj nm nn aw no bi"><span id="d168" class="np mk iq nj b gy nq nr l ns nt">const <!-- -->welcomeMessage<!-- --> = () =&gt; {<br/>  return "Hello there"<br/>};</span><span id="155a" class="np mk iq nj b gy nu nr l ns nt">export default <!-- -->welcomeMessage<!-- -->;</span></pre><p id="88fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">任何JavaScript开发人员都可以轻松阅读和理解这些代码，甚至是没有任何React背景的人。这只是一个无害的、易读的函数。</p><p id="6b77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您有一个函数定义，然后该函数被导出。这就是包含组件的文件中需要的全部内容。其他都是可选的。</p><p id="d16d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你应该注意到我们甚至没有在React中常见的<code class="fe ng nh ni nj b">import React from "react";</code>。这是因为我们只从这个函数返回一些文本。如果您使用<a class="ae ln" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX </a>，您将需要导入React类。</p><p id="9d46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这将符合React组件的条件，但在我们的大多数场景中，我们通常会根据组件收到的道具返回一些JSX。正是这种基于输入属性创建预期输出的能力使得组件可重用。</p><p id="b147" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，让我们修改我们的<code class="fe ng nh ni nj b">welcomeMessage</code>,将道具作为输入，并在此基础上输出欢迎消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9f3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，这只是一个纯粹的函数，它将<code class="fe ng nh ni nj b">props</code>作为输入，并基于输入返回<code class="fe ng nh ni nj b">JSX</code>作为输出。</p><p id="5883" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，我们使用的是ES6标准。同样的代码也可以这样写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6fdc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，我不建议使用这种格式。</p><p id="7080" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React使用ES6是有原因的，因此，我们也坚持使用它是有道理的。最好让我们自己与语言的未来方向保持一致。</p><p id="5fa6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于<a class="ae ln" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a> (CRA)中的<a class="ae ln" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>设置，我们代码的向后兼容性由默认设置负责。作为一个额外的优势，当您使用ES6时，您的代码将与React代码很好地融合在一起。</p><p id="b0a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以将道具传递给<code class="fe ng nh ni nj b">App.js</code>中的<code class="fe ng nh ni nj b">welcomeMessage </code>组件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="0270" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">功能组件的优势</h1><ol class=""><li id="fb33" class="lo lp iq kt b ku nb kx nc la nx le ny li nz lm oa lu lv lw bi translated">它们有助于保持代码的简单、易读和可重用。</li><li id="959e" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">因为它们是纯函数，所以更容易测试。</li><li id="455b" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">他们不能访问<code class="fe ng nh ni nj b">state</code>，所以你不得不考虑通过<code class="fe ng nh ni nj b">props</code>，这将使你的组件可重用。如果您认为您的组件可以在项目之外使用，您甚至可以考虑将您的组件发布到<a class="ae ln" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>。</li></ol><h2 id="140c" class="np mk iq bd ml ob oc dn mp od oe dp mt la of og mv le oh oi mx li oj ok mz ol bi translated">我应该坚持功能组件吗？</h2><p id="3084" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">这是否意味着使用功能组件总是更好？不尽然，但它们总是组件的一个很好的起点。</p><p id="4ac8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你真的觉得有必要，你可以把它们转换成基于类的组件。在下一部分中，我们将探索什么时候使用基于类的组件是有意义的，以及使用它们有什么好处。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="d940" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">基于类的组件</h1><p id="4853" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">基于类的组件是扩展了<code class="fe ng nh ni nj b">React.Component</code>的JavaScript类。</p><p id="b998" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ng nh ni nj b">React.Component</code>中唯一需要的方法是<code class="fe ng nh ni nj b">render</code>方法。</p><p id="f733" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，我们的功能组件<code class="fe ng nh ni nj b">helloUserFunctionalComponent</code>，是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0052" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在会变成这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4a5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如前所述，功能组件是一个很好的起点。我通常从功能组件开始，然后只在以下一种情况下切换到基于类的组件。</p><h2 id="23f8" class="np mk iq bd ml ob oc dn mp od oe dp mt la of og mv le oh oi mx li oj ok mz ol bi translated">1.需要利用状态</h2><p id="6bdb" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">有些情况下，您需要跟踪组件的状态。在这种情况下，最好使用<code class="fe ng nh ni nj b">state</code>。</p><p id="fe1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如<em class="nk"> accordion </em>，您需要维护accordion在<code class="fe ng nh ni nj b">state</code>中是否被点击。这对应于UI组件的状态。</p><p id="e97e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一个场景，我们使用<code class="fe ng nh ni nj b">state</code>来保存外部数据，我们将在下面讨论。</p><h2 id="46f9" class="np mk iq bd ml ob oc dn mp od oe dp mt la of og mv le oh oi mx li oj ok mz ol bi translated">2.需要获取数据</h2><p id="3ba4" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">另一个场景是您需要获取数据。在这种情况下，最好还是使用基于类的组件。</p><p id="0536" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要使用单一的基于类的组件来获取数据和呈现数据，最好使用一种叫做<em class="nk">容器</em>的方法。在一个容器中，你通常获取数据并将获取的数据存储在<code class="fe ng nh ni nj b">state</code>中。</p><p id="346e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，您将来自<code class="fe ng nh ni nj b">state</code>的相关数据传递给一个功能组件作为<code class="fe ng nh ni nj b">props</code>，它将呈现所提供的数据。</p><p id="08d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只以数据为道具，进行渲染的组件，可以认为类似于模板。它们也被称为<em class="nk">哑元件</em>。</p><h2 id="0a37" class="np mk iq bd ml ob oc dn mp od oe dp mt la of og mv le oh oi mx li oj ok mz ol bi translated">3.需要生命周期挂钩</h2><p id="5e94" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">基于类的组件提供了各种生命周期挂钩，允许我们挂钩到组件生命周期的各个阶段，并基于此执行操作。</p><p id="ec47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然有许多生命周期挂钩，<code class="fe ng nh ni nj b">componentDidMount</code>将是最常用的一个。例如，在上一节中，我们讨论了数据获取，这通常发生在<code class="fe ng nh ni nj b">componentDidMount()</code>钩子中。</p><p id="adac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看一个场景的代码，在这个场景中，我们需要从一个API获取数据，然后呈现它。</p><p id="c4ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将为API调用使用一个容器，然后我们将使用一个哑组件进行渲染。</p><p id="8dab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">容器—一种特殊用途的基于类的组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="37b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个用于呈现用户列表的哑组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4483" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，因为我们创建了一个单独的<code class="fe ng nh ni nj b">UserList</code> <strong class="kt ir"> </strong>功能组件，我们可以重用它来呈现来自任何源的<code class="fe ng nh ni nj b">UserList</code>，只要传递的<code class="fe ng nh ni nj b">users</code>道具在用户对象中有一个<code class="fe ng nh ni nj b">profile_link</code>和<code class="fe ng nh ni nj b">name</code>属性。</p><h2 id="96ec" class="np mk iq bd ml ob oc dn mp od oe dp mt la of og mv le oh oi mx li oj ok mz ol bi translated">4.需要由基于组件的类提供性能优化</h2><p id="c0d6" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">如果您从事过前端优化工作，您会观察到，一旦加载了页面并且状态发生了变化，前端的大部分时间都花在了重新呈现组件上。</p><p id="8558" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与渲染时间相比，用于JavaScript处理的时间似乎可以忽略不计。确保只在需要时重新渲染组件可以极大地提高前端应用程序的性能。</p><p id="c4d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基于类的组件有一个可选的方法叫做<code class="fe ng nh ni nj b"><em class="nk">shouldComponentUpdate</em></code>，它决定你是否需要重新渲染一个组件。</p><p id="4aa9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该方法将<code class="fe ng nh ni nj b">nextProps</code>和<code class="fe ng nh ni nj b">nextState</code>作为输入，允许您返回一个<code class="fe ng nh ni nj b">boolean</code>。如果返回<code class="fe ng nh ni nj b">true</code>，则表示组件将重新渲染，如果返回<code class="fe ng nh ni nj b">false</code>，则表示无需重新渲染组件。</p><p id="f0de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你在不了解后果的情况下干预这个功能，你可能会遇到比开始时更多的问题。还有一个更简单的选择。</p><p id="820c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React提供<code class="fe ng nh ni nj b">React.PureComponent</code>。在大多数情况下，扩展<code class="fe ng nh ni nj b">React.PureComponent</code>而不是<code class="fe ng nh ni nj b">React.Component</code>就足够了。相当于用当前和以前的道具和状态的浅层对比来实现<code class="fe ng nh ni nj b">shouldComponentUpdate()</code>。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="c2b9" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">摘要</h1><ol class=""><li id="eff7" class="lo lp iq kt b ku nb kx nc la nx le ny li nz lm oa lu lv lw bi translated">根据经验，从功能组件开始，只有在需要时才过渡到基于类的组件。</li><li id="0a8c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">由于功能组件无法访问<code class="fe ng nh ni nj b">state</code>，这可防止您不必要地使用<code class="fe ng nh ni nj b">state</code>。利用<code class="fe ng nh ni nj b">state</code>可以让你变懒。从一个功能组件开始让你思考是否真的需要使用<code class="fe ng nh ni nj b">state</code>。</li><li id="79ae" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">功能组件使您的代码简单、易读、可重用。</li><li id="7f15" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">功能组件易于测试。</li><li id="db49" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">每当你需要使用<code class="fe ng nh ni nj b">state</code>时，创建基于类的组件。</li><li id="09d7" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">每当您希望使用组件基类提供的性能优化时，请使用基于类的组件。</li><li id="fcca" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">分离数据获取和呈现。或者，换句话说，将你的业务逻辑/上下文与表示分开。</li><li id="c2d1" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">对于数据获取，使用容器模式，因为它将帮助您遵循关注点分离的范例。容器用于获取数据，它们反过来使用其他组件进行渲染。</li><li id="18c8" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm oa lu lv lw bi translated">我记得在某处读到过:“不要用应用程序逻辑或特定于上下文的细节来加重组件的负担。”这是一个很好的基本规则，其他一切都源于此。</li></ol><p id="7485" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>