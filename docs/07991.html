<html>
<head>
<title>How I Built a Costless Blockchain Database Using DNS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用DNS构建一个无成本的区块链数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/free-dns-blockchain-database-c98fce975134?source=collection_archive---------11-----------------------#2021-03-11">https://betterprogramming.pub/free-dns-blockchain-database-c98fce975134?source=collection_archive---------11-----------------------#2021-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ac6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何利用DNS服务器作为分布式区块链数据库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66c1b5b802500ab7fa167c62231f07f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pylgshT5GGH-V4QX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pierre Borthiry 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="75de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">区块链不仅仅是一个流行语。也不仅限于加密货币和比特币。凭借其创造透明度和公平性的能力，这项技术正在给许多行业带来革命性的变化。应用范围从跟踪系统到保护数据，再到实施在线投票系统。它可以帮助实施反洗钱跟踪系统，或者简单地跟踪您在商店购买的产品的来源。</p><p id="17b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如信息科学中经常发生的那样，许多区块链平台管理所有的复杂性，并使我们能够简单地保存数据，就像我们在引擎盖后面有一个简单的数据库一样。</p><p id="ded0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想实现一个区块链数据库，以便了解这些解决方案的关键要素。此外，为了使它更具挑战性，我将在不使用任何数据库或服务器的情况下这样做。</p><p id="aebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案可以很容易地让您拥有可以验证并安全存储的不可变数据。</p><p id="153b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的结构如下:</p><ul class=""><li id="24bd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">什么是区块链数据库以及如何使用它</li><li id="1ab9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">这个想法</li><li id="e1cd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何仅使用DNS服务实现区块链</li></ul><p id="17c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始旅程吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/f686480ee6df83bb33aac5fe1ad8eeb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RTVt0QwHjAw1EEKP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@launchpresso?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Launchpresso </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e475" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">什么是区块链数据库，如何使用它</h1><p id="2032" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">像往常一样，我们可以从维基百科的定义开始:</p><blockquote class="no np nq"><p id="cbff" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">“一个<strong class="lb iu">区块链</strong>，<a class="ae ky" href="https://en.wikipedia.org/wiki/Blockchain#cite_note-te20151031-1" rel="noopener ugc nofollow" target="_blank">，</a>..]，是一个不断增长的<a class="ae ky" href="https://en.wikipedia.org/wiki/Record_(computer_science)" rel="noopener ugc nofollow" target="_blank">记录</a>列表，称为块，使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Cryptography" rel="noopener ugc nofollow" target="_blank">密码术</a>进行链接。每个块包含前一个块的<a class="ae ky" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="noopener ugc nofollow" target="_blank">密码散列</a>，一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Trusted_timestamping" rel="noopener ugc nofollow" target="_blank">时间戳</a>..].根据设计，区块链可以抵抗对其数据的修改。这是因为一旦记录，任何给定块中的数据都不能在不改变所有后续块的情况下被追溯性地改变。</p><p id="1298" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">为了用作分布式分类帐，区块链通常由一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Peer-to-peer" rel="noopener ugc nofollow" target="_blank">对等</a>网络管理，该网络共同遵守一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Protocol_(communication)" rel="noopener ugc nofollow" target="_blank">协议</a>，用于节点间通信和验证新数据块——【https://en.wikipedia.org/wiki/Blockchain T4】</p></blockquote><p id="b765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，区块链的主要特点是:</p><ul class=""><li id="1978" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">通过将一条记录连接到前一条记录来存储数据</li><li id="a203" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使得你不能改变一个记录而不使所有的数据序列不一致</li><li id="89dd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将数据存储在分布式数据库中</li></ul><p id="8ab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何从零开始创建呢？</p><p id="2bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为一个节点链或多或少是一个链表，其中每个块都有一个不可变的散列。完成这些后，您只需要一个安全的分布式数据库来存储数据。什么是古代的分布式数据库？嗯，有一个分布式数据库，每个人都有，但没有人知道！我说的是DNS。是的，它是分布式的，它存储数据。每个人都有一个DNS服务。我意识到这不是它的预期用途，但是让我们玩玩它吧。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="07af" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">这个想法</h1><p id="64b4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">该协议的工作流程是可信机构将数据写入DNS。每个记录都有一个唯一的键，它是内容的散列。这意味着通过改变数据，你改变了ID，所有指向它的子节点将会不一致。此外，DNS协议是分布式的，因此数据的许多副本在服务器之间共享，这意味着您的一个DNS将离线，而另一个将继续提供数据。还要考虑到DNS被广泛缓存，这使得您的通信性能良好(使用不可变数据缓存从来都不是问题)。</p><p id="4d82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该系统使用DNS作为存储，所有公司都已经拥有，所以它没有任何额外的成本。DNS本身是一个分布式数据库。</p><p id="89d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经定义了在哪里存储数据，我们只需要理解如何存储。下一步是定义一个通信协议，使各方都能发挥各自的作用。下图显示了流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/ca85f2044ff5dd66c3110917c5011832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CJScGcVtJxWkDKugWOHPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DNS区块链工作流程。作者和❤️一起做的</p></figure><p id="4491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，我们有:</p><ul class=""><li id="8c46" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在DNS上发布的<strong class="lb iu">推力实体</strong>。它掌握着写作的关键——其他人可以写记录，但他们不会被理解。</li><li id="7e02" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个<strong class="lb iu">消费者，</strong>推动生产者并读取数据</li><li id="a1d8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">数据，</strong>其中<strong class="lb iu"> </strong>可以是任何JSON数据。你可以选择公开或保密。</li></ul><p id="661a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还写了一个完整详细的文档，您可以在本文末尾找到，它允许任何人用任何编程语言集成它或实现客户机。</p><p id="bf15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将看到如何实现该解决方案。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="376f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">如何实施</h1><p id="0084" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">既然我们知道要做什么，并且有了开始的工具，我们只需要摆弄源代码。</p><p id="06fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用DNS实现区块链，我们必须面对一些重要的问题:</p><ul class=""><li id="9b04" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> DNS限制</strong> — DNS不用于存储大量数据。我们想使用TXT记录，但这些记录只有254个字符长。如果我们的目标是存储一个大的JSON对象，这是一个非常大的限制。</li><li id="e88e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">安全</strong>——即使我们想公开我们的数据，DNS使用的UDP协议也有问题。它没有加密，也没有像HTTPS协议中那样的证书机制来强制授权。</li><li id="2d6a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">数据按照设计是公开的</strong> —这可能是一个问题。</li></ul><p id="6596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些问题都有一个解决方案，正如您将看到的，它非常容易实现。事实上，使用密码术和独创性，我们将为上面列出的所有问题找到一个聪明的解决方案。</p><p id="b961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它是如何工作的。</p><h2 id="1e21" class="nw ms it bd mt nx ny dn mx nz oa dp nb li ob oc nd lm od oe nf lq of og nh oh bi translated">创建沙盒环境</h2><p id="7531" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">第一步是创建一个我们想玩的沙盒环境。我们需要启动这项工作是一个本地的API系统的DNS服务器。我们通过创建托管它的docker-compose文件来实现这一点。我使用了一个<a class="ae ky" href="https://code.visualstudio.com/docs" rel="noopener ugc nofollow" target="_blank"> Visual Studio </a>项目，在那里我创建了一个我们将用于验证数据的web应用程序、一个将成为我们核心的库和一个测试项目。结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/22acd775daefe4225d1be317ac0ae04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*0lQdHhVrw_Ny6t0DxXQANg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DNS区块链项目</p></figure><p id="44f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行<code class="fe oj ok ol om b">docker-compose up</code>，所有启动并准备测试。对于DNS部分，我使用了非常轻量级并且有HTTP APIs可用的<a class="ae ky" href="https://github.com/nanopack/shaman" rel="noopener ugc nofollow" target="_blank">萨满DNS </a>。它使用以下配置运行:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="1c3b" class="nw ms it om b gy or os l ot ou">version: '3.4'</span><span id="b711" class="nw ms it om b gy ov os l ot ou">services:<br/>  blockchaindns.web:<br/>    image: ${DOCKER_REGISTRY-}blockchaindnsweb<br/>    build:<br/>      context: .<br/>      dockerfile: BlockChainDNS.Web/Dockerfile<br/>  dns:<br/>    image: tgpfeiffer/shaman-dns  <br/>    command: shaman --server --token xxx --api-listen 0.0.0.0:1632 --dns-listen 0.0.0.0:53 -l trace --insecure  <br/>    ports:<br/>      - 1632:1632<br/>      - 53:53/udp</span></pre><p id="f206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，xxx是您要用于身份验证的令牌，DNS被配置为接受来自所有主机的请求(0.0.0.0:port)。</p><p id="0116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用<code class="fe oj ok ol om b">docker-compose up</code>运行它之后，您可以使用控制台来测试它:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="a2ca" class="nw ms it om b gy or os l ot ou">#create a record in Shaman DNS<br/>curl --location --request POST 'localhost:1632/records' \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{<br/>  "domain": "test.myfakedomain.it.",<br/>  "records": [<br/>    {<br/>      "ttl": 60,<br/>      "class": "IN",<br/>      "type": "A",<br/>      "address": "127.0.0.1"<br/>    }<br/>  ]<br/>}'</span><span id="0ad7" class="nw ms it om b gy ov os l ot ou">#test the record<br/>nslookup test.myfakedomain.it 127.0.0.1</span><span id="8b96" class="nw ms it om b gy ov os l ot ou">#output<br/># Server:  UnKnown<br/># Address:  127.0.0.1</span><span id="7220" class="nw ms it om b gy ov os l ot ou"># Response from server:<br/># Nome:    test.myfakedomain.it<br/># Address:  127.0.0.1</span></pre><p id="d277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个工作的本地DNS，我们可以创建一个可以通过API管理DNS记录的客户机。</p><h2 id="d0fc" class="nw ms it bd mt nx ny dn mx nz oa dp nb li ob oc nd lm od oe nf lq of og nh oh bi translated">DNS客户端</h2><p id="493e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">第二步是包装要在应用程序中使用的DNS客户端功能。我在这里想做的是在将来有能力改变DNS服务，所以我创建了一个接口和一个类实现。以下代码片段显示了该界面:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="7077" class="nw ms it om b gy or os l ot ou">public interface IDNSClient<br/>{<br/>  Task&lt;DNSEntry&gt; GetRecord(string host, string zone);</span><span id="31a2" class="nw ms it om b gy ov os l ot ou">  Task&lt;bool&gt; AddRecord(DNSEntry entry);</span><span id="a5e1" class="nw ms it om b gy ov os l ot ou">  Action Init { get; set; }<br/>}</span></pre><p id="5e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以想象，客户机实现执行HTTP调用来存储记录。您可以在本文结尾所附的GitHub项目中找到完整的类实现。我们只为Shaman实现了本地提供者，但是很容易扩展它来支持大多数现代主机提供者上的任何商业DNS。</p><h2 id="a953" class="nw ms it bd mt nx ny dn mx nz oa dp nb li ob oc nd lm od oe nf lq of og nh oh bi translated">区块链服务</h2><p id="569d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">现在我们有了操作部分，是时候实现业务逻辑了。所有工作都在客户端完成，客户端计算要存储的数据，并调用DNS客户端方法来保存记录。服务层由两部分组成:</p><ul class=""><li id="a7f9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe oj ok ol om b">BlockChainNode</code>:节点的表示</li><li id="93ad" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oj ok ol om b">BlockChainService</code>:实现逻辑的服务</li></ul><p id="fffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们详细看看这些类是如何工作的。</p><p id="c2c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">区块链节点</strong></p><p id="f2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个带有<code class="fe oj ok ol om b">JObject</code>属性的简单类，用户可以在其中存储任何数据。它计算密钥散列数据。数据包含历史记录，历史记录是指向父项的链接。仅改变数据的一个字节将改变密钥，这将使随后的节点不一致。下面这段代码展示了这个类最重要的部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="71e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准则中最相关的部分是:</p><ul class=""><li id="80e6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">数据对象:一个JSON对象，用户可以在其中存储数据</li><li id="c669" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">历史:与数据同步的可观察列表(历史中的任何变化都会改变<code class="fe oj ok ol om b">_history</code>节点，反之亦然。)</li><li id="0702" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Hash:从数据的文本表示的MD5计算出的散列。结果以Base32算法编码，类似于Base 64，但只使用四个字节，并且只有小写字符。这是因为DNS不区分大小写，并且使用广泛使用的Base64编码会产生不一致的数据。</li></ul><p id="13a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了模型，我们必须进入下一步:由服务实现的业务逻辑。</p><p id="116f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">区块链服务</strong></p><p id="6f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">区块链服务实现了保存、读取和验证记录的方法。困难的部分是解决DNS服务器记录长度255个字符的限制。解决方案是用Base64对内容进行编码，然后按照命名约定分割成块保存在不同的记录中。该密钥用作URL的一部分。所以，对于<code class="fe oj ok ol om b">mykey.domain.dom</code>这个物品，我们会有<code class="fe oj ok ol om b">0.mykey.domain.dom</code>、<code class="fe oj ok ol om b">1.mykey.domain.dom</code>等。下一段代码展示了保存方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="e991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从前面调用<code class="fe oj ok ol om b">WriteDNSFragmentedText</code>的代码片段中可以看到，输入文本被拆分，数据保存在许多DNS条目中。</p><p id="c07b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看数据，是相反的。我尝试获取子记录0、1、2等等，直到有数据为止。一旦我收集了所有的Base64块，程序就是将它们连接起来，解码，并得到普通的JSON。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="708d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端可以很容易地验证所获得的数据是否产生了密钥并且是有效的，因为它可以获取数据、散列和比较结果。此外，客户端可以递归验证，以检查是否所有的父节点都是可信的。这就是验证过程的作用。它由下一段代码表示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="f5b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在前面的代码片段中看到的，记录被验证，然后所有的层次结构被下载并检查数据一致性。</p><p id="eecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经了解了如何从DNS读写数据，下一步就是如何保证它们的安全。</p><h2 id="e4d9" class="nw ms it bd mt nx ny dn mx nz oa dp nb li ob oc nd lm od oe nf lq of og nh oh bi translated">密码术和密钥</h2><p id="a94a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们的系统可以向DNS读写数据，现在是时候考虑安全性了。我们假设向我们的DNS写入数据的人是可信的，但是我们不能保证恶意的DNS服务器不会给我们假数据或者有人不会读取它(记住，DNS数据是公开的)。</p><p id="6e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里所做的是对协议进行如下改进:存储的数据使用非对称算法加密存储。这确保了只有数据的生产者才能生成消费者可以理解的数据。任何人都可以创建一个假的DNS服务器，但他们将无法对待你的假数据。此外，数据现在是加密的，没有人可以读取。</p><p id="37fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不对称算法是完美的，因为它只允许一定数量的读者理解消息，但只有源可以产生它们。为此，客户端生成一对密钥。公钥用于加密数据，因此它由生产者保管。用于解密的私钥与消费者共享。它可以手动共享，例如通过加密存档的电子邮件发送，或者发布在HTTPS网站上，在那里证书可以向用户证明其权威。</p><p id="0a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，这个概念很简单:现在数据被加密了，没有人能代表我们写数据。但是还有一个问题。对称算法处理少量数据(1024–4096字节)，但是我们必须处理巨大的JSON负载。我们有两种方法:</p><ul class=""><li id="ddae" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将整个消息分成小字节块，并逐个加密\解密。</li><li id="c93e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建一个对称密钥，用生成的密钥加密数据，然后用非对称密钥对加密生成的密钥。这样，每个记录都有不同的对称密钥用于加密数据。这个密钥是公开共享的，但只能由拥有私钥的人使用。</li></ul><p id="132a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到编码所有字节块的计算工作量，我使用了第二种解决方案。这将我们带到下一个有效载荷:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="2f71" class="nw ms it om b gy or os l ot ou">{<br/>   "data":"json object encrypted with the symm key",</span><span id="ca19" class="nw ms it om b gy ov os l ot ou">   "key":"symm key encripted with the aymm alghorithm"<br/>}</span></pre><p id="9a5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们可以看到加密的数据和加密的解密密钥存储在JSON有效负载中。读取器将使用私钥来解密对称密钥，然后使用它来解密数据。</p><p id="0227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码中的变化很小:需要的只是包装/解包数据的额外步骤。</p><p id="c632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个片段中，我展示了生成数据的步骤:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="5cbd" class="nw ms it om b gy or os l ot ou">#generate a one time password<br/>var password = SHA512.Create().ComputeHash(Guid.NewGuid().ToByteArray());</span><span id="e934" class="nw ms it om b gy ov os l ot ou">#encrypt the password<br/>var decriptkey = this.cryptoService.EncodeKey(password, publicKey);</span><span id="54f4" class="nw ms it om b gy ov os l ot ou">#encrypt data with the password<br/> var dataEnrypted = this.cryptoService.EncryptData(dataToEncode, password);</span><span id="9c05" class="nw ms it om b gy ov os l ot ou">#json object is stored with decriptkey and dataEnrypted</span></pre><p id="203b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个片段中，我们有一个阅读过程:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="661b" class="nw ms it om b gy or os l ot ou">var decriptKeyEncoded = .. from json<br/>var dataEncrypted = ... from json   </span><span id="309a" class="nw ms it om b gy ov os l ot ou">var decriptKey = this.cryptoService.DecodeKey(decriptKeyEncoded, privateKey); <br/><br/>var decodedData = this.cryptoService.DecodeData(dataEncrypted, decriptKey);</span><span id="eb6c" class="nw ms it om b gy ov os l ot ou">#decodedData is the plain data.</span></pre><p id="4474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经完成了关于区块链实现的解释，我们就有了在DNS区块链中存储数据的所有细节！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="9bdb" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="b2ca" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">即使使用DNS服务器作为数据库看起来很聪明，但事实并非如此。DNS不是用来存储数据的，不是以这种方式。</p><p id="dd6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们必须处理安全的不可变数据，解决方案是使用标准的区块链平台——我指的是真正的区块链系统。</p><p id="eb7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，尝试实现一个无服务器的区块链是非常有趣的，我希望它教会了我们区块链平台背后的原则。</p><p id="2023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我敢肯定，现在你会有足够的好奇心去尝试在你的下一个项目中包含一个区块链的解决方案。</p><p id="387a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在GitHub上找到<a class="ae ky" href="https://github.com/zeppaman/BlockChainDNS" rel="noopener ugc nofollow" target="_blank">源代码</a>和<a class="ae ky" href="https://github.com/zeppaman/BlockChainDNS/blob/master/PROTOCOL.md" rel="noopener ugc nofollow" target="_blank">完整的协议规范</a>。</p></div></div>    
</body>
</html>