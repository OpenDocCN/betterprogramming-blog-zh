<html>
<head>
<title>Combine Framework: First Impressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组合框架:第一印象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/combine-framework-first-impression-2a4115ae5482?source=collection_archive---------11-----------------------#2019-09-23">https://betterprogramming.pub/combine-framework-first-impression-2a4115ae5482?source=collection_archive---------11-----------------------#2019-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f5ef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们作为开发人员将如何处理SwiftUI框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a7d921586277bcb5ed1c978cf0dd288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkDei7842_0u71_vF32RQw.png"/></div></div></figure><p id="2ed8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">这不是用Combine框架编码的教程。这是一个iOS开发者对我们将如何处理它的第一印象。</em></p><p id="de5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不久前，我发表了一篇关于我对SwiftUI框架的第一印象的文章。在文章中，我提到SwiftUI不仅仅是我们项目的UI处理器。在稍微深入SwiftUI(和Swift 5.1)之后，我认识到<em class="lq">状态</em>和<em class="lq">绑定</em>(显然)非常好。通过使用一些提供的<a class="ae lr" href="https://github.com/DougGregor/swift-evolution/blob/property-wrappers/proposals/0258-property-wrappers.md" rel="noopener ugc nofollow" target="_blank">属性包装器</a>，比如<code class="fe ls lt lu lv b">@State</code>、<code class="fe ls lt lu lv b">@Binding</code>或<code class="fe ls lt lu lv b">@ObjectBinding</code>，我们可以更容易、更有表现力地将我们的视图与我们的数据模型连接起来。</p><p id="fc6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我注意到的一个新话题是，为了声明自定义视图模型类型的<code class="fe ls lt lu lv b">@ObjectBinding</code>变量，你应该让它符合<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.apple.com/documentation/swiftui/bindableobject" rel="noopener ugc nofollow" target="_blank">BindableObject</a></code>协议。之后，您必须实现类型为<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.apple.com/documentation/combine/passthroughsubject" rel="noopener ugc nofollow" target="_blank">PassthroughSubject</a></code>的<code class="fe ls lt lu lv b">didChange</code>属性。如果我们追踪<code class="fe ls lt lu lv b">PassthroughSubject</code>层次，我们会发现它是一个类，是<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.apple.com/documentation/combine/subject" rel="noopener ugc nofollow" target="_blank">Subject</a></code>协议的具体类型，符合<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.apple.com/documentation/combine/publisher" rel="noopener ugc nofollow" target="_blank">Publisher</a></code>协议——基本上，它是一个<code class="fe ls lt lu lv b">Publisher</code>。那么，这是怎么回事？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9a2e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我们离斯威夫特UI很远吗？</h1><p id="710c" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">答案是肯定的。当你回顾<code class="fe ls lt lu lv b">Publisher</code>文档时，如果你有敏锐的眼光(虽然，这已经足够清楚了)你会注意到它涉及到家族的<a class="ae lr" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> <em class="lq">结合</em> </a> <em class="lq"> </em>框架:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/d165df33b95d7b9fcf2f22e301468ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AmWfPEoQdTZ4o01rFcKWw.png"/></div></div></figure><h2 id="9b13" class="nb me it bd mf nc nd dn mj ne nf dp mn ld ng nh mp lh ni nj mr ll nk nl mt nm bi translated">你好，联合收割机！</h2><p id="1dfc" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">苹果公司简单地将联合收割机描述为:</p><blockquote class="nn"><p id="1f11" class="no np it bd nq nr ns nt nu nv nw lp dk translated">通过组合事件处理运算符来自定义异步事件的处理。</p></blockquote><p id="0979" class="pw-post-body-paragraph ku kv it kw b kx nx ju kz la ny jx lc ld nz lf lg lh oa lj lk ll ob ln lo lp im bi translated">老实说，当我开始阅读框架文档中使用的“技术术语”时，我的第一印象是——<code class="fe ls lt lu lv b"><em class="lq">Publisher</em></code>、<code class="fe ls lt lu lv b"><em class="lq">Just</em></code>、<code class="fe ls lt lu lv b"><em class="lq">Subscriber</em></code>、<code class="fe ls lt lu lv b"><em class="lq">Subscription</em></code>、<code class="fe ls lt lu lv b"><em class="lq">Operators</em></code>、<code class="fe ls lt lu lv b"><em class="lq">Cancellable</em></code>、<code class="fe ls lt lu lv b"><em class="lq">Scheduler</em></code>、<em class="lq">——</em>我的大脑自动将它们作为关键词与FRP的世界联系起来！</p><p id="fc00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，<em class="lq">是的</em>，如果你熟悉其中一个FRP框架，比如<a class="ae lr" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>或<a class="ae lr" href="https://github.com/ReactiveCocoa/ReactiveCocoa" rel="noopener ugc nofollow" target="_blank">reactive cocoa</a>——恭喜你，你现在知道联合收割机框架存在的主要原因了！目前，我们可以说苹果确实支持FRP范式，而不需要处理第三方框架来构建我们的项目！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/8ce8bdd367b57bad1cbba2e221605b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*n4ZiLItKn1s3RDubzt9aaQ.gif"/></div><p class="od oe gj gh gi of og bd b be z dk translated">最后是苹果！</p></figure><h2 id="8378" class="nb me it bd mf nc nd dn mj ne nf dp mn ld ng nh mp lh ni nj mr ll nk nl mt nm bi translated">但是等等…如果我不知道玻璃钢是什么呢？</h2><p id="b46b" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">嗯，我要说这是一个发现真相的好机会！</p><p id="33fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，处理<a class="ae lr" href="https://en.wikipedia.org/wiki/Functional_reactive_programming" rel="noopener ugc nofollow" target="_blank">功能反应式编程(FRP) </a>让你更少地担心管理数据，并让你专注于你的应用程序应该如何工作。以下几点描述了“更少地担心管理数据”的含义:</p><ul class=""><li id="d161" class="oh oi it kw b kx ky la lb ld oj lh ok ll ol lp om on oo op bi translated">你的应用的某些部分可能会受到影响。</li><li id="8884" class="oh oi it kw b kx oq la or ld os lh ot ll ou lp om on oo op bi translated">您可能需要实现的样板代码的数量(在某些情况下是“冗长的”)(Hello <code class="fe ls lt lu lv b">Delegates</code>、<code class="fe ls lt lu lv b">Targets-Actions</code>、<code class="fe ls lt lu lv b">KVOs</code>...！).</li><li id="01f8" class="oh oi it kw b kx oq la or ld os lh ot ll ou lp om on oo op bi translated">关心同步/异步变化，以及如何将它们的影响与默认应用程序的数据流联系起来。</li></ul><p id="cf0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，值得一提的是，当将FRP与通常的标准方法进行比较时，大多数时候你需要编写更少的代码来获得相同的结果。它是关于以声明的方式来做事情。</p><h2 id="c920" class="nb me it bd mf nc nd dn mj ne nf dp mn ld ng nh mp lh ni nj mr ll nk nl mt nm bi translated"><strong class="ak">少码？！</strong></h2><p id="3d5c" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">为了澄清这一点，让我们看看我们的应用程序中最常见的一种情况，即处理多个异步调用。显然，我们应该考虑一种并发技术，其中一个合适的选择是<a class="ae lr" href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener ugc nofollow" target="_blank">GCD dispatch group</a>。无论任务是在同一个队列上还是在不同的队列上，我们仍然能够观察它们在组中的执行和完成。示例:</p><pre class="kj kk kl km gt ov lv ow ox aw oy bi"><span id="edc6" class="nb me it lv b gy oz pa l pb pc">let queue = DispatchQueue(label: "reverseDomain", attributes: .concurrent)<br/>let group = DispatchGroup()<br/><br/>queue.async (group: group) {<br/>    performAsync01()<br/>}<br/><br/>queue.async (group: group) {<br/>    performAsync02()<br/>}<br/><br/>queue.async (group: group) {<br/>    performAsync03()<br/>}<br/><br/>group.notify(queue: DispatchQueue.main) {<br/>    // tasks executions are finished<br/>}</span></pre><p id="a8ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，异步任务的输出可能是一个返回值。这意味着除了上面的代码之外，我们可能需要声明一个实例变量来设置返回值，以便访问它。</p><p id="0919" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，Combine呢？</p><pre class="kj kk kl km gt ov lv ow ox aw oy bi"><span id="9bfb" class="nb me it lv b gy oz pa l pb pc">let myPublisher = Publishers.Zip3(photoSubject, stringSubject, voidSubject)<br/>myPublisher.sink { (asset, string, _) in<br/>    // tasks executions are finished<br/>    // additionally, we can directly access the tasks (subjects) outputs<br/>}</span></pre><p id="0f94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，<code class="fe ls lt lu lv b">photoSubject</code>、<code class="fe ls lt lu lv b">stringSubject</code>、<code class="fe ls lt lu lv b">voidSubject</code>是预定义的<a class="ae lr" href="https://developer.apple.com/documentation/combine/subject" rel="noopener ugc nofollow" target="_blank">主题</a>(基本都是发布者)。我们只是通过使用<a class="ae lr" href="https://developer.apple.com/documentation/combine/publishers/zip3" rel="noopener ugc nofollow" target="_blank"> Zip3 </a>为上游发行商应用了Zip，仅此而已！它的美妙之处不仅在于已经编写的代码数量，还在于完成这样一项任务所使用的范例。</p><p id="07dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，当你与出版商合作时，你会发现有许多有用的<em class="lq">操作符</em>来处理从出版商那里收到的值并重新发布它们——这太棒了！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4242" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">作为一名开发人员，这对我意味着什么？</h1><p id="1676" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">我们可以看到，我们将有机会(这可能是未来唯一需要的方式)通过使用这些提供的框架来改变开发我们的iOS应用程序的方法。一些开发人员热衷于学习它，一些人厌倦了必须不断处理所有这些新东西，而其余的人只是说，“是的，不管怎样…”。</p><p id="81d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不会说学习和使用Combine是必须的(至少现在是)，但是不管我们喜欢与否，请记住它是存在的。也许在不久的将来，我们会看到新一代的iOS开发者，他们只知道如何用Combine解决问题，除此之外别无其他！这可能吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/6ba845f63a2348b1095044b1be698c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*2-zqbPyfFdS5Xn7xFgwAwQ.jpeg"/></div><p class="od oe gj gh gi of og bd b be z dk translated">我们，老一代。</p></figure><p id="a0a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许你听过这个观点:</p><blockquote class="pe pf pg"><p id="d681" class="ku kv lq kw b kx ky ju kz la lb jx lc ph le lf lg pi li lj lk pj lm ln lo lp im bi translated">为了应用一个替代的架构设计模式，比如MVVM，我必须知道“反应式编程”这个东西。</p></blockquote><p id="b5f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不一定完全正确，但是有道理！这是因为适当地应用诸如MVVM的模式需要<em class="lq">双向</em> <a class="ae lr" href="https://en.wikipedia.org/wiki/Data_binding" rel="noopener ugc nofollow" target="_blank"> <em class="lq">数据绑定</em> </a> <em class="lq">，</em>这是一种痛苦，没有遵循反应式编程方法来实现它。</p><h2 id="9361" class="nb me it bd mf nc nd dn mj ne nf dp mn ld ng nh mp lh ni nj mr ll nk nl mt nm bi translated"><strong class="ak">顺便问一下</strong>，我可以不使用SwiftUI而使用Combine吗？</h2><p id="4003" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">是的，您不仅限于将Combine与SwiftUI一起使用。您可以将Combine framework与UIKit一起使用，这意味着您可以像平时一样利用Combine构建应用程序的UI部分。欢呼吧！</p><p id="5fa2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，好消息是Foundation框架和Combine框架之间存在兼容性。引用联合收割机文档:</p><blockquote class="pe pf pg"><p id="4c3f" class="ku kv lq kw b kx ky ju kz la lb jx lc ph le lf lg pi li lj lk pj lm ln lo lp im bi translated">一些基金会类型通过发布者公开他们的功能，包括<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.apple.com/documentation/foundation/timer" rel="noopener ugc nofollow" target="_blank">Timer</a></code>、<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.apple.com/documentation/foundation/notificationcenter" rel="noopener ugc nofollow" target="_blank">NotificationCenter</a></code>和<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank">URLSession</a></code>。Combine还为任何符合键值观察的属性提供了一个内置的发布器。</p><p id="7820" class="ku kv lq kw b kx ky ju kz la lb jx lc ph le lf lg pi li lj lk pj lm ln lo lp im bi translated">您可以组合多个发布者的输出，并协调它们的交互。例如，您可以从文本字段的发布者订阅更新，并使用文本来执行URL请求。然后，您可以使用另一个发布者来处理响应，并使用它们来更新您的应用程序。</p></blockquote><p id="a17c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将使我们在使用Combine处理一些基础类型时更加轻松。我希望我们将来能看到更多这样的例子。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b188" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">最后</h1><p id="286b" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">正如我在SwiftUI p 中提到的，声明性范式已经很流行了。即使它对您来说是新的，使用它不仅会反映在您的iOS开发知识上，而且会扩展您的一般编程技能，以及您的解决问题的技能。说到iOS开发，它的美妙之处在于我们有更多的动态工具来实现我们想要的模式和方法。更像是“学一次，用在哪里”。</p><p id="f4c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">感谢阅读！</em></p></div></div>    
</body>
</html>