<html>
<head>
<title>6 Things to Know About Accessing Python Attributes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于访问Python属性要知道的6件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-things-to-know-about-accessing-python-attributes-b7da11525a8e?source=collection_archive---------7-----------------------#2021-01-26">https://betterprogramming.pub/6-things-to-know-about-accessing-python-attributes-b7da11525a8e?source=collection_archive---------7-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c1c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以正确的方式编写和使用Python属性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/59fe11dee41e4e1c641623a6c6f65233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*POGwnKY38bpAls5C"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jancanty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬·坎迪</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="1ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本质上讲，Python是一种面向对象的编程(OOP)语言。Python中的一切——模块、类和实例——都是对象。一个基本的构建特性是每个对象拥有不同的属性。如果你来自其他OOP语言，你可能习惯于setters和getters。然而，这在Python编码中并不常见。然而，这是一个你应该知道的基本话题。在本文中，我想回顾一下关于访问属性的六个要点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bf75" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.使用属性装饰器进行封装</h1><p id="9841" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">封装是一种编程风格，它将对外公开的功能与内部实现细节分开。有些人可能习惯于以下编码模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Getters和Setters</p></figure><p id="888a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个模式中，我们使用适当的函数来检索和设置属性值。这个想法是隐藏属性名是如何在内部管理的。然而，这种模式更适合内置的属性装饰器。考虑下面修改后的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">物业装饰</p></figure><p id="3950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性装饰器的使用允许您使用点符号访问和设置属性，而不是像前面代码片段中的实现那样调用函数。对比如下所示。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="1cf3" class="ng md it nc b gy nh ni l nj nk">&gt;&gt;&gt; person = Person("Mike")<br/>&gt;&gt;&gt; person.get_name()<br/>'Mike'<br/>&gt;&gt;&gt; person.set_name("Mike Smith")<br/>&gt;&gt;&gt; <br/>&gt;&gt;&gt; <strong class="nc iu"># Dot notation with the attribute</strong><br/>&gt;&gt;&gt; person1 = Person1("Mike")<br/>&gt;&gt;&gt; person1.name<br/>'Mike'<br/>&gt;&gt;&gt; person1.name = "Mike Smith"</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="e07d" class="ng md it bd me nl nm dn mi nn no dp mm li np nq mo lm nr ns mq lq nt nu ms nv bi translated">2.尽可能直接访问</h2><p id="549f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然从典型的OOP角度来看，属性装饰器对于为setters和getters提供封装很有用，但是过度使用它会使代码库变得不必要的复杂。在大多数情况下，最好直接访问和设置属性。</p><p id="946a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你希望你的代码是可读的。如果两者都能解决问题，那么更少的代码几乎总是比更多的代码好。所以，除非有特别的原因，直截了当总是一个好习惯。考虑下面的替代方案，是不是简洁多了？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">属性的直接访问</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8cc3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.对“非公共”属性使用下划线</h1><p id="7022" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管在大多数情况下，直接访问属性是首选，但是如果您正在创建一个公共的Python模块，您可能希望将一些属性设为“非公共的”这将减少模块最终用户的困惑。换句话说，您希望最终用户能够访问由他们选择的ide提示的“公共”属性。</p><p id="074e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑以下更新版本的<code class="fe nw nx ny nc b">Person</code>类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/1a58aa2ca01fa79d3f3a71b1b8173184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X181fPMBn5bh__30e4EZhQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">隐藏非公共属性</p></figure><p id="ad69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，在<code class="fe nw nx ny nc b">PyCharm</code>中，属性<code class="fe nw nx ny nc b">_name</code>和<code class="fe nw nx ny nc b">__name</code>不在<code class="fe nw nx ny nc b">person3</code>实例的自动完成建议列表中。然而，如果我们坚持访问这些属性——我们可以在Python中这样做；我在上面的“非公共”和“公共”属性中使用引号，因为Python并没有真正区分公共和非公共属性——理论上，一切都是公共的。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="af8c" class="ng md it nc b gy nh ni l nj nk">&gt;&gt;&gt; person3 = Person3("Mike")<br/>&gt;&gt;&gt; person3._name<br/>'_Mike'<br/>&gt;&gt;&gt; person3._Person3__name<br/>'__Mike'</span></pre><p id="9c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，当您在属性名前面使用两个下划线时，名称将会与类名混淆。在这种情况下，<code class="fe nw nx ny nc b">__name</code>属性将改为由<code class="fe nw nx ny nc b">_Person3__name</code>访问。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c5f0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.明确实例属性</h1><p id="eb8f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python不限制定义实例属性的位置。甚至可以在类定义的范围之外设置属性。然而，在类定义中明确适用的实例属性是一个很好的实践，因为代码的读者会理解你的类有什么属性。更具体地说，应该在<code class="fe nw nx ny nc b">__init__</code>方法中提供实例属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显式实例属性</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><ul class=""><li id="4073" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">上面的代码片段向您展示了相同功能的两种可能的实现。</li><li id="e9cc" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nw nx ny nc b">Person5</code>比<code class="fe nw nx ny nc b">Person4</code>好，因为它明确了可能的实例属性，即使<code class="fe nw nx ny nc b">relative</code>属性的初始值被设置为<code class="fe nw nx ny nc b">None</code>。但是你的代码的读者会理解这个属性在代码中的某个地方是有用的。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="91a6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.属性设置的值验证</h1><p id="04a0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，我们希望验证是否可以为特定属性设置某些值。有几种方法可以做到这一点。一种是将属性实现为属性。下面的代码向您展示了这样的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">属性验证</p></figure><p id="f918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在代码片段中看到的，我们检查设置age属性的值是否小于零——当值无效时，我们将引发一个错误。当它有效时，我们可以设置属性值。这种检查防止了任何可能的数据错误。</p><p id="b158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是覆盖<code class="fe nw nx ny nc b">__setattr__</code>方法。然而，如果你不熟悉这种特殊的方法，不推荐这样做。它只有在您想要管理多个属性时才有用，这不是一个常见的用例。如果您想要管理几个属性，只需使用属性装饰器方法，如上所述。进一步说，下面的代码提供了一个概念证明，说明我们如何在设置属性值之前检查它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">覆盖__setattr__</p></figure><ul class=""><li id="1f2a" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">我们检查设置任何属性的键为<code class="fe nw nx ny nc b">age</code>时的值。</li><li id="db8a" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">请注意，即使在实例初始化期间，也会调用这个特殊的方法。这就是为什么会打印“将年龄设置为无”消息的原因。</li><li id="1e0f" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">您还需要使用<code class="fe nw nx ny nc b">super()</code>来设置属性。使用超级方法很重要，否则，你会因为重复调用类本身的<code class="fe nw nx ny nc b">__setattr_</code>而陷入无限循环。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5609" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.谨慎使用猴子补丁</h1><p id="4ea1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Monkey patching是一种向现有代码库添加自定义行为的编程技术。换句话说，就是随时修改一些预定义的功能。这可能会产生产生冲突的副作用。以下代码向您展示了一个简单的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">猴子补丁</p></figure><ul class=""><li id="d7dd" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">不知何故，您在两个不同的地方使用同一个实例为方法属性<code class="fe nw nx ny nc b">speak</code>分配了两个不同的函数(<code class="fe nw nx ny nc b">foo</code>和<code class="fe nw nx ny nc b">bar</code>)。</li><li id="604a" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">第二次分配将覆盖先前的设置。在这种情况下，<code class="fe nw nx ny nc b">person8</code>实例将采用<code class="fe nw nx ny nc b">bar</code>函数中定义的功能。如果您检查speak属性的签名，您会发现以下信息:</li></ul><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="838b" class="ng md it nc b gy nh ni l nj nk">&gt;&gt;&gt; person8.speak.__name__<br/>'bar'</span></pre><p id="5460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子并没有说你不应该使用猴子补丁。实际上，它在你的程序开发过程中会很有帮助。在某些情况下，您可能已经创建了正在使用的类的实例。不知何故，你修改了一个特定的方法。在这种情况下，您可以在控制台中运行该方法，并将其分配给现有的实例，这允许您继续使用原始流。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="69e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="f3f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了在Python中访问属性的六个有用的技巧。当然，还有许多其他的提示。请随意分享你的，我们一起学习可以写出更好的Python代码！</p><p id="2809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这篇文章。</p></div></div>    
</body>
</html>