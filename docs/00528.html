<html>
<head>
<title>Django select_related and prefetch_related</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django选择相关和预取相关</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/django-select-related-and-prefetch-related-f23043fd635d?source=collection_archive---------0-----------------------#2019-06-06">https://betterprogramming.pub/django-select-related-and-prefetch-related-f23043fd635d?source=collection_archive---------0-----------------------#2019-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ca86" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过示例检查使用这些方法减少了多少查询</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b519bbd33feefa299fed799de0277bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zc_pRb0xwC1Wd97dav490w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@etienneblg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾蒂安·布朗热</a>在<a class="ae ky" href="https://unsplash.com/s/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a47a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>中，<code class="fe lv lw lx ly b">select_related</code>和<code class="fe lv lw lx ly b">prefetch_related</code>被设计用来阻止由于访问相关对象而导致的数据库查询的泛滥。</p><p id="5784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我基本上试图弄清楚它如何减少了多少查询，在本文中，我将描述我的发现。</p><p id="66c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在GitHub 上找到源代码。</p><p id="e640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整篇文章中，我们将使用以下模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="484a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试我们的功能，我们需要将数据插入到模型中。</p><p id="7845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我编写了一个管理命令，其中插入了五个出版商、100本书(每个出版商20本书)和10个商店(每个商店10本书)。跑<code class="fe lv lw lx ly b">python manage.py load_items</code>就是了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我编写了一个装饰器来测量函数的执行时间和执行的查询数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0c79" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">选择_相关</h1><p id="d53d" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">当你要选择的对象是单个对象时，我们使用<code class="fe lv lw lx ly b">select_related</code>，这意味着向前<code class="fe lv lw lx ly b">ForeignKey, OneToOne</code>和向后<code class="fe lv lw lx ly b">OneToOne</code>。</p><p id="af04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">select_related</code>的工作原理是创建一个SQL连接，并在<code class="fe lv lw lx ly b">SELECT</code>语句中包含相关对象的字段。因此，<code class="fe lv lw lx ly b">select_related</code>在同一个数据库查询中获取相关对象。</p><p id="c109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用一个例子来深入探讨一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该函数后，输出显示:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="6cb1" class="nj mj it ly b gy nk nl l nm nn">Function :  book_list<br/>Number of Queries : 101<br/>Finished in : 0.08s</span></pre><p id="e16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个用于填充所有书籍的查询，每次迭代时，我们访问另一个单独查询执行的外键<code class="fe lv lw lx ly b">publisher</code>。</p><p id="1134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe lv lw lx ly b">select_related</code>如下修改查询，看看会发生什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该函数后，输出显示:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="6361" class="nj mj it ly b gy nk nl l nm nn">Function :  book_list_select_related<br/>Number of Queries : 1<br/>Finished in : 0.02s</span></pre><p id="a400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是不是很神奇？这个查询将101减少到1。这就是<code class="fe lv lw lx ly b">select_related</code>的作用。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="6c16" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">预取相关</h1><p id="6843" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">当我们要得到一个<code class="fe lv lw lx ly b">set</code>的东西时，我们用<code class="fe lv lw lx ly b">prefetch_related</code>。</p><p id="dd4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着向前<code class="fe lv lw lx ly b">ManyToMany</code>和向后<code class="fe lv lw lx ly b">ManyToMany,</code> <code class="fe lv lw lx ly b">ForeignKey</code>。<code class="fe lv lw lx ly b">prefetch_related</code>对每个关系进行单独的查找，并在<a class="ae ky" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>中执行“连接”。</p><p id="0b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">select_related</code>不同的是，<code class="fe lv lw lx ly b">prefetch_related</code>使用Python而不是在数据库中进行连接。</p><p id="3052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用一个例子来深入探讨一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="78aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该函数后，输出显示:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="4060" class="nj mj it ly b gy nk nl l nm nn">Function :  store_list<br/>Number of Queries : 11<br/>Finished in : 0.02s</span></pre><p id="c177" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在数据库中有10个商店，每个商店有10本书。这里发生的是一个获取所有商店的查询，在遍历每个商店时，当我们访问<code class="fe lv lw lx ly b">ManyToMany</code>字段<code class="fe lv lw lx ly b">books</code>时，另一个查询正在执行。</p><p id="b693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用<code class="fe lv lw lx ly b">prefetch_related</code>来减少查询的数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该函数后，输出显示:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="b958" class="nj mj it ly b gy nk nl l nm nn">Function : store_list_prefetch_related<br/>Number of Queries : 2<br/>Finished in : 0.01s</span></pre><p id="edda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的查询性能提高了，11比2的查询。我想让你明白<code class="fe lv lw lx ly b">prefetch_related</code>在这里做什么。</p><p id="7c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再举一个<code class="fe lv lw lx ly b">prefetch_related</code>的例子。</p><p id="52b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在管理命令代码中，我将图书价格从50到300随机设置。现在，我们会在每个商店里发现昂贵的书(价格250到300)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="5942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该函数后，输出显示:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="12ba" class="nj mj it ly b gy nk nl l nm nn">Function :  store_list_expensive_books_prefetch_related<br/>Number of Queries : 12<br/>Finished in : 0.05s</span></pre><p id="dc6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们使用了<code class="fe lv lw lx ly b">prefetch_related</code>，我们的查询增加了而不是减少了。但是为什么呢？</p><p id="2330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">prefetch related</code>，我们告诉Django给出所有要连接的结果，但是当我们使用<code class="fe lv lw lx ly b">filter(price__range=(250, 300))</code>时，我们改变了主查询，然后Django没有为我们连接正确的结果。</p><p id="a76a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们有12个查询，11个查询迭代存储，一个查询获取预取中的所有结果。</p><p id="9446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">Prefetch</code>来解决问题吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该函数后，输出显示:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="3edf" class="nj mj it ly b gy nk nl l nm nn">Function :  store_list_expensive_books_prefetch_related_efficient<br/>Number of Queries : 2<br/>Finished in : 0.03s</span></pre><p id="210f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任务成功！两个问题，不是12个。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="8bc8" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">资源</h1><ul class=""><li id="c616" class="no np it lb b lc na lf nb li nq lm nr lq ns lu nt nu nv nw bi translated"><a class="ae ky" href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/" rel="noopener ugc nofollow" target="_blank">https://docs.djangoproject.com/en/2.2/ref/models/querysets/</a></li><li id="eca3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/#django.db.models.query.QuerySet.select_related" rel="noopener ugc nofollow" target="_blank">https://docs . django project . com/en/2.2/ref/models/query sets/# django . db . models . query . query set . select _ related</a></li><li id="f7f4" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/#prefetch-related" rel="noopener ugc nofollow" target="_blank">https://docs . django project . com/en/2.2/ref/models/query sets/#预取相关</a></li><li id="b074" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/#prefetch-objects" rel="noopener ugc nofollow" target="_blank">https://docs . django project . com/en/2.2/ref/models/query sets/# prefetch-objects</a></li></ul></div></div>    
</body>
</html>