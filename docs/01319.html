<html>
<head>
<title>Why Model Objects Shouldn’t Implement Swift’s Decodable or Encodable Protocols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么模型对象不能实现Swift的可解码或可编码协议</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-model-objects-shouldnt-implement-swift-s-decodable-or-encodable-protocols-1249cb44d4b3?source=collection_archive---------2-----------------------#2019-09-01">https://betterprogramming.pub/why-model-objects-shouldnt-implement-swift-s-decodable-or-encodable-protocols-1249cb44d4b3?source=collection_archive---------2-----------------------#2019-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8a5d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">良好做法</h2><div class=""/><div class=""><h2 id="a95e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">以及哪些对象应该</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/8a4ce95768ddcd16c86db87d8986d0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7AnDs_rtleMBW0JCdlx7A.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@lazycreekimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Michael Dziedzic </a>在<a class="ae lh" href="https://unsplash.com/search/photos/trespassing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="ead9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，你可能在想:“他在说什么？<code class="fe me mf mg mh b">Decodable</code>和<code class="fe me mf mg mh b">Encodable</code>协议很有用！”</p><p id="2bc8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我同意你的观点。<code class="fe me mf mg mh b">Decodable</code>和<code class="fe me mf mg mh b">Encodable</code>协议确实非常有用。例如，Swift提供了一种本地方式来解析JSON元素，或者从<em class="mi">用户默认设置</em>中存储和检索对象，这很棒。没毛病。</p><p id="d387" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，我认为我们在模型对象中使用这些协议是错误的。我会试着解释为什么。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c287" class="mq mr it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">领域模型和数据模型</h1><p id="766b" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated"><em class="mi">域模型</em>是一个面向对象的模型，它结合了行为和数据。这是我们试图建模的业务规则的代表。</p><p id="054e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mi">数据模型</em>是持久性存储中的数据结构。它没有行为。</p><p id="baee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">持久性存储的一些例子有<em class="mi">用户默认值</em>、<em class="mi">核心数据</em>、文件、数据库，甚至外部API。这些商店的数据模型可能各不相同。</p><p id="772c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">领域模型和数据模型都包含数据，但是领域模型也包含业务规则。</p><p id="b7f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">域模型中的对象应该不知道使用了哪个持久存储或数据模型。</p><p id="142c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那是因为领域模型和数据模型有不同的改变理由。只有当业务规则发生变化或者对要解决的问题有了更多的了解时，领域模型才应该发生变化。</p><p id="5e70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，数据模型可能因为不同的原因而改变。例如，持久性存储需要从本地存储更改为远程API。领域模型不应该受到基础设施变化的影响。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dc9e" class="mq mr it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">可解码和可编码</h1><p id="6412" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated"><code class="fe me mf mg mh b">Decodable</code>协议用于<em class="mi">水合来自一些外部表示的</em>对象。例如，它用于将JSON对象解析成结构或类。</p><blockquote class="nn no np"><p id="3393" class="li lj mi lk b ll lm kd ln lo lp kg lq nq ls lt lu nr lw lx ly ns ma mb mc md im bi translated">可解码的:一种可以从外部表示中解码自身的类型。</p></blockquote><p id="5925" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，<code class="fe me mf mg mh b">Encodable</code>协议用于将对象存储到某种外部表示中。例如，它可以用来获得一个对象的JSON表示。</p><blockquote class="nn no np"><p id="3646" class="li lj mi lk b ll lm kd ln lo lp kg lq nq ls lt lu nr lw lx ly ns ma mb mc md im bi translated">可编码的:一种可以将自身编码成外部表示的类型。</p></blockquote><p id="5419" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是为什么我们不应该在我们的领域模型对象中使用<code class="fe me mf mg mh b">Decodable</code>或<code class="fe me mf mg mh b">Encodable</code>？</p><p id="6dbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用一个例子来回答这个问题。假设我们有以下用户的JSON表示:</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="5e67" class="nx mr it mh b gy ny nz l oa ob">{<br/>   <strong class="mh jd">"first_name"</strong>:"dick",<br/>   <strong class="mh jd">"last_name"</strong>:"richardson",<br/>   <strong class="mh jd">"mail"</strong>:"drichardson@enclave.com",<br/>   <strong class="mh jd">"day_of_birth"</strong>:7026198103<br/>}</span></pre><p id="cfd6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用一个名为<code class="fe me mf mg mh b">User</code>的<code class="fe me mf mg mh b">Decodable</code>结构来解析JSON并在我们的域模型中表示一个<code class="fe me mf mg mh b">User</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9322" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是如果JSON改变了会发生什么呢？假设现在<code class="fe me mf mg mh b">first</code>和<code class="fe me mf mg mh b">last</code>名称在<code class="fe me mf mg mh b">name</code> <strong class="lk jd"> </strong>字段中:</p><pre class="ks kt ku kv gt nt mh nu nv aw nw bi"><span id="9fc6" class="nx mr it mh b gy ny nz l oa ob">{<br/>   <strong class="mh jd">"name"</strong>:{<br/>      <strong class="mh jd">"first"</strong>:"dick",<br/>     <strong class="mh jd"> "last"</strong>:"richardson"<br/>   },<br/>   <strong class="mh jd">"email"</strong>:"drichardson@enclave.com",<br/>   <strong class="mh jd">"day_of_birth"</strong>:7026198103<br/>}</span></pre><p id="9c7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于这个小小的变化，以前的<code class="fe me mf mg mh b">User</code>结构现在无法解析JSON数据。我们被迫改变领域模型来解析新的数据模型:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8be6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好。现在<code class="fe me mf mg mh b">User</code>结构解析新的JSON格式，但是我们必须改变<code class="fe me mf mg mh b">firstName</code>和<code class="fe me mf mg mh b">lastName</code>的所有用法，分别替换为<code class="fe me mf mg mh b">name.first</code>和<code class="fe me mf mg mh b">name.last</code>。</p><p id="9e97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于数据的变化，我们刚刚更改了我们的领域模型。</p><p id="4bc1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是我在我的领域模型对象中不使用<code class="fe me mf mg mh b">Decodable</code>或<code class="fe me mf mg mh b">Encodable</code>的原因。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2a6e" class="mq mr it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">将领域模型与数据模型分开</h1><p id="8727" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">我们需要做的是将领域模型从数据模型中分离出来。</p><p id="50e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以通过使用两个不同的类或结构来实现这一点。一个解析JSON，另一个表示域模型对象。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c840" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意<code class="fe me mf mg mh b">User</code>不再实现<code class="fe me mf mg mh b">Decodable</code>协议，因为它不再用于解析JSON数据。<code class="fe me mf mg mh b">User</code>现在表示领域模型，并且从数据模型中分离出来。</p><p id="b6f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们已经创建了一个名为<code class="fe me mf mg mh b">UserDTO</code>(数据传输对象)的<code class="fe me mf mg mh b">Decodable</code>结构，用于解析JSON数据。这个结构包含创建一个<code class="fe me mf mg mh b">User</code>所需的数据。</p><p id="1807" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，a <code class="fe me mf mg mh b">UserDTOMapper</code>从de <code class="fe me mf mg mh b">UserDTO</code>数据中创建一个新的<code class="fe me mf mg mh b">User</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f13d" class="mq mr it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">优势</h1><p id="7ce6" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">由于这种方法，领域模型不再与数据耦合，并且不需要每次数据模型改变时都改变。</p><p id="1457" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当然，领域模型并不能避免所有的数据变化。有时候，模式无论如何都会改变。</p><p id="909e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，问问你自己:“是数据迫使领域模型改变，还是相反？”也许业务规则改变了，领域模型也改变了，这导致了数据模型的改变。</p><p id="474f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将领域模型从数据中分离出来的另一个好处是领域模型变得更有表现力。我们可以使用更多的<em class="mi">复杂</em>类型，而不仅仅是简单的<code class="fe me mf mg mh b">String</code>、<code class="fe me mf mg mh b">Int</code>或其他<code class="fe me mf mg mh b">Decodable</code>类型。</p><p id="d2cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在前面的例子中，出生日期现在被表示为<code class="fe me mf mg mh b">User</code>结构中的<code class="fe me mf mg mh b">Date</code>，不像<code class="fe me mf mg mh b">UserDTO</code>结构中的出生日期被表示为<code class="fe me mf mg mh b">Int</code>。那些更复杂的<em class="mi"> </em>类型可以在映射过程中创建。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c818" class="mq mr it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">仓库</h1><p id="9ae7" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">既然我们知道了从数据中分离领域模型的价值，我想引入一个概念来帮助我们实现这个目标:T21库T22。</p><p id="7f84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">存储库可以看作是元素的集合，在这里可以存储或检索元素。它提供了获取这些元素并存储它们的方法。</p><p id="5f11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是领域模型和数据模型之间的边界。这是一个隐藏所使用的真正持久性存储及其所有实现细节的好地方，比如JSON解析和到域模型对象的映射。</p><h2 id="2d91" class="nx mr it bd ms oe of dn mw og oh dp na lr oi oj nc lv ok ol ne lz om on ng iz bi translated">例子</h2><p id="2ee1" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">让我们看一个例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="1fa3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是怎么回事？</p><ol class=""><li id="895e" class="oo op it lk b ll lm lo lp lr oq lv or lz os md ot ou ov ow bi translated">储存库协议。使用协议是一个好主意，因为这样的话，使用<em class="mi">依赖注入</em>可以非常容易地改变真正的存储库实现。取名<code class="fe me mf mg mh b">UserRepository</code>。这个名称不应该告诉我们任何关于所使用的持久性存储的信息。</li><li id="d93c" class="oo op it lk b ll ox lo oy lr oz lv pa lz pb md ot ou ov ow bi translated">存储库实现。与协议不同，类名应该为我们提供关于所选持久性存储的线索。在这种情况下，<code class="fe me mf mg mh b">APIUserRepository</code>使用外部API来检索<code class="fe me mf mg mh b">Users</code>。</li><li id="0371" class="oo op it lk b ll ox lo oy lr oz lv pa lz pb md ot ou ov ow bi translated">存储库使用<code class="fe me mf mg mh b">URLSession</code>来执行请求并获得一个<code class="fe me mf mg mh b">User</code>。我不打算在这里深究更多的细节，因为我不想错过这个例子的要点。如果你想了解更多关于使用<code class="fe me mf mg mh b">URLSession</code>联网的知识，可以在这里看到一个非常好的教程<a class="ae lh" href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="48d0" class="oo op it lk b ll ox lo oy lr oz lv pa lz pb md ot ou ov ow bi translated">一个<code class="fe me mf mg mh b">UserDTO</code>结构用于解析从API获得的JSON数据。如果数据被成功解析到DTO中，那么一个<code class="fe me mf mg mh b">UserDTOMapper</code>将从其中创建一个<code class="fe me mf mg mh b">User</code>。如果解析失败，则返回<code class="fe me mf mg mh b">nil</code>。</li></ol><p id="f850" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仅此而已。很简单吧？</p><p id="524d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当您使用存储库时，很容易更改所使用的持久性存储。让我们这样做，并将用户存储在本地。顾名思义，这个新的实现使用<em class="mi">用户默认值</em>来检索用户:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="ecbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，本实施中使用的DTO与<code class="fe me mf mg mh b">APIUserRepository</code>中使用的相同。当然，这不是强制性的。</p><p id="1ad4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个实现都可以使用不同的DTO来满足存储库的需求。但是为了使例子简单，我使用了同一个例子。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cd83" class="mq mr it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">结论</h1><p id="7ee3" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">关于存储库的一个好处是，你可以把所有的实现细节隐藏在协议后面。</p><p id="12bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用存储库的对象不应该关心实际使用的是哪种机制。它所关心的只是存储库返回一个域模型对象，在这个例子中是一个<code class="fe me mf mg mh b">User</code>。</p><p id="1adf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而且，由于我们已经将域模型从数据模型中分离出来，存储库实现可以在对系统影响最小的情况下进行更改，因为返回的域模型将保持不变。</p><p id="c4f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！</p></div></div>    
</body>
</html>