<html>
<head>
<title>Building a Kotlin Mobile App With the Salesforce SDK: Synchronizing Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Salesforce SDK构建Kotlin移动应用程序:同步数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-kotlin-mobile-app-with-the-salesforce-sdk-synchronizing-data-72c041a5605c?source=collection_archive---------7-----------------------#2022-05-03">https://betterprogramming.pub/building-a-kotlin-mobile-app-with-the-salesforce-sdk-synchronizing-data-72c041a5605c?source=collection_archive---------7-----------------------#2022-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="975b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在我的系列文章的最后部分利用Salesforce SDK</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c18dcdf70c8b8883b6b7e10dc1fe18b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6u8inJNAU2iiVwdOJ5YugA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">资料来源:undraw.co</p></figure><p id="f6ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们演示如何使用Salesforce Mobile SDK构建与Salesforce平台配合使用的Android应用程序的三部分系列的最后一篇文章。在我们的第一篇文章中，我们向你展示了如何连接到你的组织。<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/building-a-kotlin-mobile-app-with-the-salesforce-sdk-editing-and-creating-data-45916b0cc2bb">我们的第二篇文章</a>向您展示了如何从您的应用程序编辑数据并将数据添加到您的组织。本文将向您展示如何将数据从您的Salesforce组织同步到您的移动设备，以及如何处理网络中断等情况。让我们开始吧！</p><h1 id="f266" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用移动同步</h1><p id="0b29" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">移动开发最困难的方面之一是处理数据同步。当您需要添加一个新的代理，但是您处于离线状态时，您如何处理这种情况？或者，如果两个代理正在更新同一个代理，您如何处理这两个变更的合并呢？</p><p id="9132" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">借助Salesforce Mobile SDK，这些现实世界中的问题将由一个名为<a class="ae lu" href="https://developer.salesforce.com/docs/atlas.en-us.mobile_sdk.meta/mobile_sdk/entity_framework_native_using.htm" rel="noopener ugc nofollow" target="_blank">移动同步</a>的系统为您处理。移动同步让您将手机的本地数据映射到Salesforce中的数据；它还要求您定义获取和推送数据的操作——它称之为<code class="fe ms mt mu mv b">syncDown</code>和<code class="fe ms mt mu mv b">syncUp</code>。</p><h1 id="d19b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">定义要同步的数据的形状</h1><p id="d019" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">要开始使用移动同步，在<code class="fe ms mt mu mv b">res/raw</code>中创建一个名为<code class="fe ms mt mu mv b">brokerstore.json</code>的文件:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="54eb" class="na lw it mv b gy nb nc l nd ne">{<br/> "soups": [<br/>   {<br/>     "soupName": "brokers",<br/>     "indexes": [<br/>       { "path": "Id", "type": "string"},<br/>       { "path": "Name", "type": "string"},<br/>       { "path": "Title__c", "type": "string"},<br/>       { "path": "Phone__c", "type": "string"},<br/>       { "path": "Mobile_Phone__c", "type": "string"},<br/>       { "path": "Email__c", "type": "string"},<br/>       { "path": "Picture__c", "type": "string"},<br/>       { "path": "__local__", "type": "string"},<br/>       { "path": "__locally_created__", "type": "string"},<br/>       { "path": "__locally_updated__", "type": "string"},<br/>       { "path": "__locally_deleted__", "type": "string"},<br/>       { "path": "__sync_id__", "type": "integer"}<br/>     ]<br/>   }<br/> ]<br/>}</span></pre><p id="c0d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该文件定义了手机上数据的形状，以及同步所需的一些附加元数据。</p><p id="9c5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，创建一个名为<code class="fe ms mt mu mv b">brokersync.json</code>的文件:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9844" class="na lw it mv b gy nb nc l nd ne">{<br/> "syncs": [<br/>   {<br/>     "syncName": "syncDownBrokers",<br/>     "syncType": "syncDown",<br/>     "soupName": "brokers",<br/>     "target": {"type":"soql", "query":"SELECT Name, Title__c, Phone__c, Mobile_Phone__c, Email__c, Picture__c FROM Broker__c LIMIT 10000"},<br/>     "options": {"mergeMode":"OVERWRITE"}<br/>   },<br/>   {<br/>     "syncName": "syncUpBrokers",<br/>     "syncType": "syncUp",<br/>     "soupName": "brokers",<br/>     "target": {"createFieldlist":["Name", "Title__c", "Phone__c", "Mobile_Phone__c", "Email__c", "Picture__c"]},<br/>     "options": {"fieldlist":["Id", "Name", "Title__c", "Phone__c", "Mobile_Phone__c", "Email__c", "Picture__c"], "mergeMode":"LEAVE_IF_CHANGED"}<br/>   }<br/> ]<br/>}</span></pre><p id="2700" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是移动同步将在向下和向上同步数据时使用的操作。</p><p id="9b78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成移动同步过程的代码取决于几个因素，例如当您想要执行同步时，以及当设备失去(和恢复)连接时挂钩到Android事件周期。</p><p id="d5b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码示例将向您展示一个完整的例子，说明同步工作需要做些什么，但是它们应该被视为高级概念，而不一定是生产就绪的企业级代码。</p><h1 id="4036" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置定期同步</h1><p id="2463" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">说了这么多，让我们看看如何实现同步。首先，将这一行添加到我们在<code class="fe ms mt mu mv b">MainActivity.kt</code>中的<code class="fe ms mt mu mv b">onResume(client: RestClient)</code>方法的末尾:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b7b9" class="na lw it mv b gy nb nc l nd ne">setupPeriodicSync();</span></pre><p id="8c4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将向<code class="fe ms mt mu mv b">MainActivity</code>类添加一个新变量和一个新函数:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="35be" class="na lw it mv b gy nb nc l nd ne">private val SYNC_CONTENT_AUTHORITY =<br/>   "com.salesforce.samples.mobilesyncexplorer.sync.brokersyncadapter"</span><span id="09e5" class="na lw it mv b gy nf nc l nd ne">private fun setupPeriodicSync() {<br/>   val account = MobileSyncSDKManager.getInstance().userAccountManager.currentAccount</span><span id="c070" class="na lw it mv b gy nf nc l nd ne">   ContentResolver.setSyncAutomatically(account, SYNC_CONTENT_AUTHORITY, true)<br/>   ContentResolver.addPeriodicSync(<br/>       account, SYNC_CONTENT_AUTHORITY,<br/>       Bundle.EMPTY, 10<br/>   )<br/>}</span></pre><p id="4814" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们在函数中使用了<code class="fe ms mt mu mv b">ContentResolver</code>，所以让我们确保通过在靠近<code class="fe ms mt mu mv b">MainActivity.kt</code>顶部的其他导入语句旁边添加这一行来导入它:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="859f" class="na lw it mv b gy nb nc l nd ne">import.android.content.ContentResolver</span></pre><p id="2dcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经定义了两种触发同步的方法。<code class="fe ms mt mu mv b">setupPeriodicSync</code>将每隔<code class="fe ms mt mu mv b">10</code>秒运行一次同步。这对于生产环境来说太频繁了，但是出于演示的目的，我们将这样设置。</p><h1 id="bb49" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将同步操作映射到我们的数据和UI</h1><p id="c634" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们将一次展示接下来的几个代码样本，然后讨论它们在做什么。</p><p id="aafc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe ms mt mu mv b">app/java/com.example.sfdc</code>中，创建一个名为<code class="fe ms mt mu mv b">BrokerSyncAdapter.kt</code>的新文件，并将这些行粘贴到其中:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6429" class="na lw it mv b gy nb nc l nd ne">package com.example.sfdc</span><span id="c21f" class="na lw it mv b gy nf nc l nd ne">import android.accounts.Account<br/>import android.content.AbstractThreadedSyncAdapter<br/>import android.content.ContentProviderClient<br/>import android.content.Context<br/>import android.content.SyncResult<br/>import android.os.Bundle<br/>import com.salesforce.androidsdk.accounts.UserAccount<br/>import com.salesforce.androidsdk.accounts.UserAccountManager<br/>import com.salesforce.androidsdk.app.SalesforceSDKManager<br/>import com.example.sfdc.BrokerListLoader</span><span id="4053" class="na lw it mv b gy nf nc l nd ne">class BrokerSyncAdapter<br/>   (<br/>   context: Context?, autoInitialize: Boolean,<br/>   allowParallelSyncs: Boolean<br/>) :<br/>   AbstractThreadedSyncAdapter(context, autoInitialize, allowParallelSyncs) {<br/>   override fun onPerformSync(<br/>       account: Account, extras: Bundle, authority: String,<br/>       provider: ContentProviderClient, syncResult: SyncResult<br/>   ) {<br/>       val syncDownOnly = extras.getBoolean(SYNC_DOWN_ONLY, false)<br/>       val sdkManager = SalesforceSDKManager.getInstance()<br/>       val accManager = sdkManager.userAccountManager<br/>       if (sdkManager.isLoggingOut || accManager.authenticatedUsers == null) {<br/>           return<br/>       }<br/>       if (account != null) {<br/>           val user = sdkManager.userAccountManager.buildUserAccount(account)<br/>           val contactLoader = BrokerListLoader(context, user)<br/>           if (syncDownOnly) {<br/>               contactLoader.syncDown()<br/>           } else {<br/>               contactLoader.syncUp() // does a sync up followed by a sync down<br/>           }<br/>       }<br/>   }</span><span id="4735" class="na lw it mv b gy nf nc l nd ne">   companion object {<br/>       // Key for extras bundle<br/>       const val SYNC_DOWN_ONLY = "syncDownOnly"<br/>   }<br/>}</span></pre><p id="d861" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在同一个文件夹中，用下面几行创建<code class="fe ms mt mu mv b">BrokerListLoader.kt</code>:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f4e6" class="na lw it mv b gy nb nc l nd ne">package com.example.sfdc</span><span id="5827" class="na lw it mv b gy nf nc l nd ne">import android.content.AsyncTaskLoader<br/>import android.content.Context<br/>import android.content.Intent<br/>import android.util.Log<br/>import com.salesforce.androidsdk.accounts.UserAccount<br/>import com.salesforce.androidsdk.app.SalesforceSDKManager<br/>import com.salesforce.androidsdk.mobilesync.app.MobileSyncSDKManager<br/>import com.salesforce.androidsdk.mobilesync.manager.SyncManager<br/>import com.salesforce.androidsdk.mobilesync.manager.SyncManager.MobileSyncException<br/>import com.salesforce.androidsdk.mobilesync.manager.SyncManager.SyncUpdateCallback<br/>import com.salesforce.androidsdk.mobilesync.util.SyncState<br/>import com.salesforce.androidsdk.smartstore.store.QuerySpec<br/>import com.salesforce.androidsdk.smartstore.store.SmartSqlHelper.SmartSqlException<br/>import com.salesforce.androidsdk.smartstore.store.SmartStore<br/>import org.json.JSONArray<br/>import org.json.JSONException<br/>import java.util.ArrayList</span><span id="9a22" class="na lw it mv b gy nf nc l nd ne">class BrokerListLoader(context: Context?, account: UserAccount?) :<br/>   AsyncTaskLoader&lt;List&lt;String&gt;?&gt;(context) {<br/>   private val smartStore: SmartStore<br/>   private val syncMgr: SyncManager<br/>   override fun loadInBackground(): List&lt;String&gt;? {<br/>       if (!smartStore.hasSoup(BROKER_SOUP)) {<br/>           return null<br/>       }<br/>       val querySpec = QuerySpec.buildAllQuerySpec(<br/>           BROKER_SOUP,<br/>           "Name", QuerySpec.Order.ascending, LIMIT<br/>       )<br/>       val results: JSONArray<br/>       val brokers: MutableList&lt;String&gt; = ArrayList&lt;String&gt;()<br/>       try {<br/>           results = smartStore.query(querySpec, 0)<br/>           for (i in 0 until results.length()) {<br/>               brokers.add(results.getJSONObject(i).getString("Name"))<br/>           }<br/>       } catch (e: JSONException) {<br/>           Log.e(TAG, "JSONException occurred while parsing", e)<br/>       } catch (e: SmartSqlException) {<br/>           Log.e(TAG, "SmartSqlException occurred while fetching data", e)<br/>       }<br/>       return brokers<br/>   }</span><span id="2eba" class="na lw it mv b gy nf nc l nd ne">   @Synchronized<br/>   fun syncUp() {<br/>       try {<br/>           syncMgr.reSync(<br/>               SYNC_UP_NAME<br/>           ) { sync -&gt;<br/>               if (SyncState.Status.DONE == sync.status) {<br/>                   syncDown()<br/>               }<br/>           }<br/>       } catch (e: JSONException) {<br/>           Log.e(TAG, "JSONException occurred while parsing", e)<br/>       } catch (e: MobileSyncException) {<br/>           Log.e(TAG, "MobileSyncException occurred while attempting to sync up", e)<br/>       }<br/>   }</span><span id="6aaf" class="na lw it mv b gy nf nc l nd ne">   /**<br/>    * Pulls the latest records from the server.<br/>    */<br/>   @Synchronized<br/>   fun syncDown() {<br/>       try {<br/>           syncMgr.reSync(<br/>               SYNC_DOWN_NAME<br/>           ) { sync -&gt;<br/>               if (SyncState.Status.DONE == sync.status) {<br/>                   fireLoadCompleteIntent()<br/>               }<br/>           }<br/>       } catch (e: JSONException) {<br/>           Log.e(TAG, "JSONException occurred while parsing", e)<br/>       } catch (e: MobileSyncException) {<br/>           Log.e(TAG, "MobileSyncException occurred while attempting to sync down", e)<br/>       }<br/>   }</span><span id="aadb" class="na lw it mv b gy nf nc l nd ne">   private fun fireLoadCompleteIntent() {<br/>       val intent = Intent(LOAD_COMPLETE_INTENT_ACTION)<br/>       SalesforceSDKManager.getInstance().appContext.sendBroadcast(intent)<br/>   }</span><span id="d5b0" class="na lw it mv b gy nf nc l nd ne">   companion object {<br/>       const val BROKER_SOUP = "brokers"<br/>       const val LOAD_COMPLETE_INTENT_ACTION =<br/>           "com.salesforce.samples.mobilesyncexplorer.loaders.LIST_LOAD_COMPLETE"<br/>       private const val TAG = "BrokerListLoader"<br/>       private const val SYNC_DOWN_NAME = "syncDownBrokers"<br/>       private const val SYNC_UP_NAME = "syncUpBrokers"<br/>       private const val LIMIT = 10000<br/>   }</span><span id="a583" class="na lw it mv b gy nf nc l nd ne">   init {<br/>       val sdkManager = MobileSyncSDKManager.getInstance()<br/>       smartStore = sdkManager.getSmartStore(account)<br/>       syncMgr = SyncManager.getInstance(account)<br/>       // Setup schema if needed<br/>       sdkManager.setupUserStoreFromDefaultConfig()<br/>       // Setup syncs if needed<br/>       sdkManager.setupUserSyncsFromDefaultConfig()<br/>   }<br/>}</span></pre><p id="4925" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们刚刚做了什么？每个文件都有一个特定的角色，虽然您的应用程序的对象和字段肯定会有所不同，但这些类的功能和原理是相同的:</p><ul class=""><li id="dc58" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated"><code class="fe ms mt mu mv b">BrokerListLoader</code>负责将您在<code class="fe ms mt mu mv b">brokersync.json</code>中定义的同步操作映射到实际执行工作的Kotlin代码。注意，有<code class="fe ms mt mu mv b">syncUp</code>和<code class="fe ms mt mu mv b">syncDown</code>方法使用移动SDK的<code class="fe ms mt mu mv b">SyncManager</code>加载JSON文件并与Salesforce来回通信。</li><li id="0777" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe ms mt mu mv b">BrokerSyncAdapter</code>也许最好被认为是负责调度同步的代码。也就是说，它是<code class="fe ms mt mu mv b">BrokerListLoader</code>的入口点，可以被UI元素(比如在刷新按钮点击期间)或Android系统事件(比如连接丢失)调用。</li></ul><p id="b2e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们需要在我们的<code class="fe ms mt mu mv b">AndroidManifest.xml</code>文件中添加一行(在<code class="fe ms mt mu mv b">app/manifests</code>中)。我们新的同步功能将需要特殊的Android权限，我们要求用户在运行时安装应用程序时允许。将以下带有<code class="fe ms mt mu mv b">WRITE_SYNC_SETTINGS</code>的行添加到清单的末尾:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="bc71" class="na lw it mv b gy nb nc l nd ne">&lt;uses-permission android:name="com.example.sfdc.C2D_MESSAGE" /&gt;<br/>  &lt;uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS" /&gt;<br/>&lt;/manifest&gt;</span></pre><h1 id="77de" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">测试同步</h1><p id="b921" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们的最后一步是测试移动同步工作。随着模拟器的运行，您应该登录并看到一个代理列表。这个列表应该反映您在本地机器上的web浏览器中看到的代理列表。在您的web浏览器中，编辑其中一个代理名称，并保存更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/952414b2a200a30d7c0d0b22ddcab47f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ana9nLRrbAl__dv2.png"/></div></div></figure><p id="300d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，在您的模拟器中，您可以关闭手机或切换到另一个应用程序，然后切换回您的<code class="fe ms mt mu mv b">sfdc-mobile-app</code>。您应该会看到您的经纪人姓名列表随着您在浏览器中所做的更改而更新:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/ce98e6848865a53cf9d0159d83598d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kKz_dNK3Y5CCsjWc.png"/></div></div></figure><p id="7b74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅此而已！同样，这只是一个供您学习的基础构件。在大约150行代码中，我们为一系列相当复杂的运动部件设计了一个解决方案:</p><ul class=""><li id="1eb1" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">将Salesforce自定义对象映射到JSON</li><li id="0bd3" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">设置计时器以定期在Salesforce组织和移动设备之间来回同步数据</li><li id="d8b7" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">处理网络连接方面的错误(并从问题中恢复)</li></ul><h1 id="e445" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="6b04" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Salesforce Mobile SDK使移动设备与Salesforce数据的连接变得非常容易。在这篇文章中，您学习了如何从您的手机查询和操作数据，并看到结果即时反映在Salesforce上。您还了解了移动同步及其在预测连接问题方面的作用。</p><p id="f29f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，有了所有这些信息，Salesforce Mobile SDK还可以做更多的。看看<a class="ae lu" href="https://developer.salesforce.com/docs/atlas.en-us.noversion.mobile_sdk.meta/mobile_sdk" rel="noopener ugc nofollow" target="_blank">关于与SDK合作的完整文档</a>。或者，如果你喜欢做更多的编码，有足够的教程让你忙起来。我们迫不及待地想看看你的作品！</p></div></div>    
</body>
</html>