<html>
<head>
<title>Deep Insights Into JavaScript’s Fetch API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解JavaScript的Fetch API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deep-insights-into-javascripts-fetch-api-e8e8203c0965?source=collection_archive---------5-----------------------#2021-01-12">https://betterprogramming.pub/deep-insights-into-javascripts-fetch-api-e8e8203c0965?source=collection_archive---------5-----------------------#2021-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a0db" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">更深入地了解fetch</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/71d89b1e21a926def433f9e84c75ebdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxsdWXwYFkXZPawgMPeRuA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Rob Fuller 在<a class="ae kv" href="https://unsplash.com/s/photos/fetch?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="65b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从API请求资源是构建现代应用程序所需的一个流行且几乎至关重要的特性。无论您已经创建了自己的API还是正在实现第三方API，您都需要一种方法来创建您的请求，而不会降低应用程序的速度。<code class="fe ls lt lu lv b">fetch()</code>是<code class="fe ls lt lu lv b">XMLHttpRequest</code>的升级版，用于在JavaScript脚本中进行HTTP请求。Fetch和<code class="fe ls lt lu lv b">XMLHttpRequest</code>的主要区别在于Fetch API使用承诺，因此避免了回调地狱。除了Internet Explorer，所有现代浏览器都支持fetch API。本文详细介绍了它的用法。这是我第35篇中型文章。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a063" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">基本用法</h1><p id="0dca" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">fetch()</code>的功能与<code class="fe ls lt lu lv b">XMLHttpRequest</code>基本相同，但主要有三点不同。</p><ul class=""><li id="05ba" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">fetch()</code>用promise代替了回调函数，所以大大简化了书写，让书写更加简洁。</li><li id="9a51" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">fetch()</code>采用模块化设计，API分散在多个对象中(响应对象、请求对象、头对象)。相比之下，XMLHttpRequest的API设计不是很好——它只有输入、输出和状态。用同样的界面管理很容易写出非常乱的代码。</li><li id="da0c" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">fetch()</code>通过数据流(Stream object)处理数据，可以分块读取，有利于提升网站性能，减少内存占用。这对于需要大文件或者网速慢的情况非常有用。<code class="fe ls lt lu lv b">XMLHTTPRequest</code>对象不支持数据流。所有数据都必须存储在缓存中。不支持块读取。你必须等到所有的都得到之后，才能一口气吐出来。</li></ul><p id="3171" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法上，<code class="fe ls lt lu lv b">fetch()</code>接受一个URL字符串作为参数，默认向该URL发送一个<code class="fe ls lt lu lv b">GET</code>请求，返回一个<code class="fe ls lt lu lv b">Promise</code>对象。其基本用法如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d134" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个从服务器获取JSON数据的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="69f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe ls lt lu lv b">fetch()</code>接收到的<code class="fe ls lt lu lv b">response</code>是一个流对象，<code class="fe ls lt lu lv b">response.json()</code>是一个异步操作，取出所有的内容，转换成JSON对象。可以使用await语法重写Promise，使语义更加清晰。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d16e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe ls lt lu lv b">await</code>语句必须放在<code class="fe ls lt lu lv b">try...catch</code>中，以捕捉异步操作中可能出现的错误。以下文字使用<code class="fe ls lt lu lv b">await</code>代替<code class="fe ls lt lu lv b">.then()</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/d2a3bfd96253448b42b7ba2b6ee0ce07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgPdG2k7_uK-49xh6ZKz1g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com/s/photos/basic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="b8e3" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">响应对象:处理HTTP响应</h1><h2 id="e18a" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated">响应对象的同步属性</h2><p id="4e76" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">fetch()</code>请求成功后，你得到一个<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank">Response</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank">对象</a>。它对应于服务器的HTTP响应。</p><pre class="kg kh ki kj gt od lv oe of aw og bi"><span id="0446" class="nr me iq lv b gy oh oi l oj ok">const response = await fetch(url);</span></pre><p id="d756" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，<code class="fe ls lt lu lv b">Response</code>中包含的数据是通过<code class="fe ls lt lu lv b">Stream</code>接口异步读取的，但它也包含一些同步属性，这些属性对应于HTTP响应的头信息(Headers)，可以立即读取。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f91a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe ls lt lu lv b">response.status</code>和<code class="fe ls lt lu lv b">response.statusText</code>是<code class="fe ls lt lu lv b">Response</code>的同步属性，可以立即读取。</p><h2 id="f3e7" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">Response.ok</code></h2><p id="9f58" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Response.ok</code>属性返回布尔值，表示请求是否成功，<code class="fe ls lt lu lv b">true</code>对应HTTP请求状态码200到299，<code class="fe ls lt lu lv b">false</code>对应其他状态码。</p><h2 id="a501" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">Response.status</code></h2><p id="99cd" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Response.status</code>属性返回一个数字，表示HTTP响应的状态代码(例如，200，表示请求成功)。</p><h2 id="3b0f" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">Response.statusText</code></h2><p id="83e6" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Response.statusText</code>属性返回一个表示HTTP响应状态信息的字符串(比如请求成功后，服务器返回“OK”)。</p><h2 id="b4ce" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">Response.url</code></h2><p id="b95d" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Response.url</code>属性返回请求的URL。如果URL有重定向，该属性返回最终的URL。</p><h2 id="5fde" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">Response.type</code></h2><p id="b920" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Response.type</code>属性返回请求的类型。可能的值如下:</p><ul class=""><li id="27e8" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">basic</code>:普通，同源请求。</li><li id="d10e" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">cors</code>:跨产地请求。</li><li id="0372" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">error</code>:网络错误，主要用于服务人员。</li><li id="4381" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">opaque</code>:如果<code class="fe ls lt lu lv b">fetch()</code>请求的<code class="fe ls lt lu lv b">mode</code>属性设置为<code class="fe ls lt lu lv b">no-cors</code>，则返回该响应值。</li><li id="4118" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">opaqueredirect</code>:如果<code class="fe ls lt lu lv b">fetch()</code>请求的<code class="fe ls lt lu lv b">redirect</code>属性设置为<code class="fe ls lt lu lv b">manual</code>，则返回该响应值。</li></ul><h2 id="54d6" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">Response.redirected</code></h2><p id="f3a7" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Response.redirected</code>属性返回一个布尔值，表明请求是否被重定向。</p><h2 id="a5d1" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated">确定请求是否成功</h2><p id="f4f5" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">fetch()</code>发出请求后，有一点需要注意:<code class="fe ls lt lu lv b">fetch()</code>只有在出现网络错误或无法连接时才会报错。在其他情况下，不会报告错误，但是请求被认为是成功的。</p><p id="6004" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，即使服务器返回的状态码是4xx或5xx，<code class="fe ls lt lu lv b">fetch()</code>也不会报错(即承诺不会变成<code class="fe ls lt lu lv b">rejected</code>)。只有通过<code class="fe ls lt lu lv b">Responese.status</code>属性获取HTTP响应的真实状态码，才能确定请求是否成功。请看下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="61e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe ls lt lu lv b">Responese.status</code>属性必须等于2xx (200~299)才能确定请求成功。不需要考虑URL跳转(状态码为3xx)，因为<code class="fe ls lt lu lv b">fetch()</code>会自动将跳转的状态码转换为200。另一种方法是确定<code class="fe ls lt lu lv b">Responese.ok</code>是否为<code class="fe ls lt lu lv b">true</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="ee34" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">Response.headers</code>属性</h2><p id="22eb" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Response</code>对象还有一个<code class="fe ls lt lu lv b">Responese.headers</code>属性，指向一个<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Headers" rel="noopener ugc nofollow" target="_blank">Headers</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Headers" rel="noopener ugc nofollow" target="_blank">对象</a>，对应HTTP响应的所有头。<code class="fe ls lt lu lv b">Headers</code>使用<code class="fe ls lt lu lv b">for...of</code>循环可以遍历对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f0fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Headers</code>对象提供了以下方法来操作标题。</p><ul class=""><li id="357b" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">Headers.get()</code>:根据指定的键名，返回键值。</li><li id="2ab7" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">Headers.has()</code>:返回一个布尔值，表示是否包含标题。</li><li id="0b41" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">Headers.set()</code>:将指定的键名设置为新的键值，如果键名不存在，将被添加。</li><li id="b0d0" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">Headers.append()</code>:添加表头。</li><li id="5028" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">Headers.delete()</code>:删除表头。</li><li id="9ba6" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">Headers.keys()</code>:返回一个可以依次遍历所有键的迭代器。</li><li id="c580" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">Headers.values()</code>:返回一个可以依次遍历所有键值的迭代器。</li><li id="141a" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">Headers.entries()</code>:返回一个可以依次遍历所有键值对的迭代器(<code class="fe ls lt lu lv b">[key, value]</code>)。</li><li id="8adc" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">Headers.forEach()</code>:依次遍历表头。每个头将执行一个参数函数。</li></ul><p id="6773" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的一些方法可以修改头，因为它们继承自<code class="fe ls lt lu lv b">Headers</code>接口。对于HTTP响应，修改头意义不大——许多头是只读的，浏览器不允许修改。在这些方法中，最常用的是<code class="fe ls lt lu lv b">response.headers.get()</code>，用来读取某个表头的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3226" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Headers.keys()</code>和<code class="fe ls lt lu lv b">Headers.values()</code>方法分别用于遍历标题键和键值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="cce0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法还可以遍历所有的键值和键名。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="f0d3" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated">如何阅读内容</h2><p id="4688" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Response</code>对象根据服务器返回的数据类型不同，提供不同的读取方法。</p><ul class=""><li id="6105" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">response.text()</code>:获取文本字符串。</li><li id="e189" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">response.json()</code>:获取JSON对象。</li><li id="00a0" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">response.blob()</code>:获取二进制<code class="fe ls lt lu lv b">Blob</code>对象。</li><li id="6202" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">response.formData()</code>:获得<code class="fe ls lt lu lv b">FormData</code>物体。</li><li id="6c42" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">response.arrayBuffer()</code>:获取二进制<code class="fe ls lt lu lv b">ArrayBuffer</code>对象。</li></ul><p id="b184" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上五种读取方法都是异步的，都返回<code class="fe ls lt lu lv b">Promise</code>对象。您必须等到异步操作结束，才能获得服务器返回的完整数据。</p><h2 id="6da5" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">response.text()</code></h2><p id="2613" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">response.text()</code>可用于获取文本数据，如HTML文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="c6bb" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">response.json()</code></h2><p id="416d" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">response.json()</code>主要用于获取服务器返回的JSON数据。前面已经给出了例子。</p><h2 id="c776" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">response.formData()</code></h2><p id="7cdb" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">response.formData()</code>主要用于服务工作者拦截用户提交的表单，修改一些数据，然后提交给服务器。</p><h2 id="2f0e" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">response.blob()</code></h2><p id="02de" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">response.blob()</code>用于获取二进制文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子读取了<code class="fe ls lt lu lv b">flower.jpg</code>图像文件并将其显示在网页上。</p><h2 id="771c" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">response.arrayBuffer()</code></h2><p id="5e63" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">response.arrayBuffer()</code>主要用于获取流媒体文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ceac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子是<code class="fe ls lt lu lv b">response.arrayBuffer()</code>获取音频文件<code class="fe ls lt lu lv b">song.ogg</code>然后在线播放的例子。</p><h2 id="bb89" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated">Response.clone()</h2><p id="9f7c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Stream</code>对象只能读一次，读完就没了。这意味着只能使用上一节中的五种读取方法中的一种，否则会报错。</p><pre class="kg kh ki kj gt od lv oe of aw og bi"><span id="f200" class="nr me iq lv b gy oh oi l oj ok">let text =  await response.text();<br/>let json =  await response.json();  // <!-- -->Report an error</span></pre><p id="13fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子首先使用<code class="fe ls lt lu lv b">response.text()</code>，然后读取<code class="fe ls lt lu lv b">Stream</code>。稍后调用<code class="fe ls lt lu lv b">response.json()</code>后，没有内容可读，报错。<code class="fe ls lt lu lv b">Response</code>对象提供了<code class="fe ls lt lu lv b">response.clone()</code>方法，该方法创建了<code class="fe ls lt lu lv b">Response</code>对象的副本并实现了多次读取。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="436b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe ls lt lu lv b">response.clone()</code>复制了一个<code class="fe ls lt lu lv b">Response</code>对象，然后读取同一个图像两次。<code class="fe ls lt lu lv b">Response</code>对象也有一个<code class="fe ls lt lu lv b">Response.redirect()</code>方法，用于将<code class="fe ls lt lu lv b">Response</code>结果重定向到指定的URL。这种方法一般只在<code class="fe ls lt lu lv b">Service Worker</code>中使用，这里就不介绍了。</p><h2 id="d1c8" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b">Response.body</code>属性</h2><p id="e694" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Response.body</code>属性是由<code class="fe ls lt lu lv b">Response</code>对象公开的底层接口。它返回一个<code class="fe ls lt lu lv b">ReadableStream</code>对象供用户操作。它可以用来读取块中的内容。一个应用程序是显示下载的进度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="27b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe ls lt lu lv b">response.body.getReader()</code>方法返回一个迭代器。这个遍历器的<code class="fe ls lt lu lv b">read()</code>方法每次返回一个对象，代表这次读取的内容块。这个对象的<code class="fe ls lt lu lv b">done</code>属性是一个布尔值，用来判断是否被读取。<code class="fe ls lt lu lv b">value</code>属性是一个<code class="fe ls lt lu lv b">arrayBuffer</code>数组，代表内容块的内容。<code class="fe ls lt lu lv b">value.length</code>属性是当前块的大小。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/5ac84c8f27f4dc71c9f62828e48914c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*x8Is0ZGUft6UHAD2gB6izw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.bccfalna.com/ebooks/wp-content/uploads/ebooks/2018/12/HTTP-Hyper-Text-Transfer-Protocol-for-Webpage-%E2%80%93-Request-and-Response-Core-JSP-in-Hindi.png" rel="noopener ugc nofollow" target="_blank">https://www . bccfalna . com/ebooks/WP-content/uploads/ebooks/2018/12/HTTP-Hyper-Text-Transfer-Protocol-for-网页-% E2 % 80% 93-Request-and-Response-Core-JSP-in-Hindi . png</a></p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="94dd" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">fetch()的第二个参数:自定义HTTP请求</h1><p id="0d1b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">fetch()</code>的第一个参数是URL，第二个参数也可以作为配置对象接受，自定义发出的HTTP请求。</p><pre class="kg kh ki kj gt od lv oe of aw og bi"><span id="8d83" class="nr me iq lv b gy oh oi l oj ok">fetch(url, optionObj)</span></pre><p id="b93e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述命令的<code class="fe ls lt lu lv b">optionObj</code>是第二个参数。HTTP请求方法、头和数据体都在这个对象中设置。这里有一些例子。</p><h2 id="c267" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated">发布请求</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="99e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的示例中，配置对象使用三个属性:</p><ul class=""><li id="f783" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">method</code>:HTTP请求方法、POST、DELETE、PUT都在该属性中设置。</li><li id="772c" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">headers</code>:用于定制HTTP请求头的对象。</li><li id="9740" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">body</code>:POST请求的数据体。</li></ul><p id="9dae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意有些表头不能用<code class="fe ls lt lu lv b">headers</code>属性设置，比如<code class="fe ls lt lu lv b">Content-Length</code>、<code class="fe ls lt lu lv b">Cookie</code>、<code class="fe ls lt lu lv b">Host</code>等。它们由浏览器自动生成，不能修改。</p><h2 id="69c6" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated">提交JSON数据</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9d89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，标题<code class="fe ls lt lu lv b">Content-Type</code>应该设置为<code class="fe ls lt lu lv b">'application/json;charset=utf-8'</code>。因为默认是发送纯文本，<code class="fe ls lt lu lv b">Content-Type</code>的默认值是<code class="fe ls lt lu lv b">'text/plain;charset=UTF-8'</code>。</p><h2 id="80e6" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated">提交表单</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="0bed" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated">文件上传</h2><p id="1d2b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果表单中有文件选择器，可以使用前面例子的写法。上传的文件包含在整个表单中并一起提交。另一种方法是用脚本添加文件，构造一个表单，然后上传，请看下面的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b737" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上传二进制文件时，不需要修改文件头的<code class="fe ls lt lu lv b">Content-Type</code>，浏览器会自动设置。</p><h2 id="4a20" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated">直接上传二进制数据</h2><p id="c242" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">fetch()</code>也可以直接上传二进制数据，将<code class="fe ls lt lu lv b">Blob</code>或<code class="fe ls lt lu lv b">arrayBuffer</code>数据放在<code class="fe ls lt lu lv b">body</code>属性中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om np l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="4d74" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">Fetch() API的完整配置对象</h1><p id="178f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">fetch()</code> API的第二个参数完成如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d18b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">fetch()</code>请求的底层使用了<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request" rel="noopener ugc nofollow" target="_blank">Request()</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request" rel="noopener ugc nofollow" target="_blank">对象</a>的接口。参数完全一样，所以上面的API也是<code class="fe ls lt lu lv b">Request()</code>的API。在这些属性中，<code class="fe ls lt lu lv b">headers</code>、<code class="fe ls lt lu lv b">body</code>和<code class="fe ls lt lu lv b">method</code>之前已经给出了例子。下面是对其他属性的介绍。</p><h2 id="a1e9" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><code class="fe ls lt lu lv b"><strong class="ak">cache</strong></code></h2><p id="4685" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">cache</code>属性指定了如何处理缓存。可能的值如下:</p><ul class=""><li id="294d" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">default</code>:默认值是先在缓存中查找匹配的请求。</li><li id="dbd0" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">no-store</code>:直接请求远程服务器，不更新缓存。</li><li id="7e85" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">reload</code>:直接请求远程服务器，更新缓存。</li><li id="73c8" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">no-cache</code>:将服务器资源与本地缓存进行比较，当有新版本时使用服务器资源。否则使用本地缓存。</li><li id="3eeb" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">force-cache</code>:缓存优先，只有在没有缓存的情况下才请求远程服务器。</li><li id="c7f2" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">only-if-cached</code>:只检查缓存。如果缓存不存在，将返回504错误。</li></ul><h2 id="d330" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><strong class="ak">模式</strong></h2><p id="5914" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">mode</code>属性指定了请求的模式。可能的值如下:</p><ul class=""><li id="9e1f" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">cors</code>:默认值允许跨域请求。</li><li id="8d57" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">same-origin</code>:只允许同源请求。</li><li id="2264" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">no-cors</code>:请求方法仅限于GET、POST和HEAD，只能使用有限数量的简单头，不能添加跨域的复杂头，相当于提交表单就可以发出的请求。</li></ul><h2 id="ca87" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><strong class="ak">全权证书</strong></h2><p id="c74f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">credentials</code>属性指定是否发送cookies。可能的值如下:</p><ul class=""><li id="c2fc" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">same-origin</code>:默认情况下，当从同一来源请求时，会发送cookies，但跨域请求时不会发送。</li><li id="d3ee" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">include</code>:无论同源请求还是跨域请求，总是会发送cookies。</li><li id="b106" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">omit</code>:从不发送。</li></ul><p id="8800" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于发送cookies的跨域请求，<code class="fe ls lt lu lv b">credentials</code>属性需要设置为<code class="fe ls lt lu lv b">include</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="9c02" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><strong class="ak">信号</strong></h2><p id="0d16" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">signal</code>属性指定一个<code class="fe ls lt lu lv b">AbortSignal</code>实例来取消<code class="fe ls lt lu lv b">fetch()</code>请求，详见下一节。</p><h2 id="4680" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><strong class="ak"> keepalive </strong></h2><p id="511c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">页面卸载时使用<code class="fe ls lt lu lv b">keepalive</code>属性，告知浏览器在后台保持连接，继续发送数据。一个典型的场景是，当用户离开网页时，脚本向服务器提交一些关于用户行为的统计信息。此时，如果不使用<code class="fe ls lt lu lv b">keepalive</code>属性，可能会因为浏览器卸载了页面而无法发送数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="4fc3" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><strong class="ak">重定向</strong></h2><p id="fb38" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">redirect</code>属性指定HTTP重定向的处理方法。可能的值如下:</p><ul class=""><li id="ade6" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">follow</code>:默认情况下，<code class="fe ls lt lu lv b">fetch()</code>跟随HTTP重定向。</li><li id="9feb" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">error</code>:如果发生跳跃，<code class="fe ls lt lu lv b">fetch()</code>会报错。</li><li id="b6ca" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">manual</code> : <code class="fe ls lt lu lv b">fetch()</code>不跟随HTTP重定向，但是<code class="fe ls lt lu lv b">response.url</code>属性会指向新的URL，<code class="fe ls lt lu lv b">response.redirected</code>属性会变成<code class="fe ls lt lu lv b">true</code>。开发人员决定以后如何处理重定向。</li></ul><h2 id="c9cc" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><strong class="ak">完整性</strong></h2><p id="eff1" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">integrity</code>属性指定一个哈希值，用于检查HTTP响应返回的数据是否等于预设的哈希值。例如，下载文件时，检查文件的SHA-256哈希值是否匹配，以确保它没有被篡改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="c090" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><strong class="ak">推荐人</strong></h2><p id="e2f7" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">referrer</code>属性用于设置<code class="fe ls lt lu lv b">fetch()</code>请求的<code class="fe ls lt lu lv b">referrer</code>报头。该属性可以是任何字符串或空字符串(即不发送<code class="fe ls lt lu lv b">referrer</code>头)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="e3c1" class="nr me iq bd mf ns nt dn mj nu nv dp mn lf nw nx mp lj ny nz mr ln oa ob mt oc bi translated"><strong class="ak">推荐者策略</strong></h2><p id="e657" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">referrerPolicy</code>属性用于设置<code class="fe ls lt lu lv b">Referrer</code>表头的规则。可能的值如下:</p><ul class=""><li id="8ad5" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">no-referrer-when-downgrade</code>:缺省值，总是发送<code class="fe ls lt lu lv b">Referrer</code>头，除非从HTTPS页面请求HTTP资源时不发送。</li><li id="23cb" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">no-referrer</code>:不发送<code class="fe ls lt lu lv b">Referrer</code>报头。</li><li id="4e12" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">origin</code>:<code class="fe ls lt lu lv b">Referrer</code>头只包含域名，不包含完整路径。</li><li id="4800" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">origin-when-cross-origin</code>:同源请求的<code class="fe ls lt lu lv b">Referrer</code>头包含完整路径，跨域请求只包含域名。</li><li id="dbca" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">same-origin</code>:跨域请求不发送<code class="fe ls lt lu lv b">Referrer</code>，但发送同源请求。</li><li id="59d6" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">strict-origin</code>:<code class="fe ls lt lu lv b">Referrer</code>头只包含域名。当HTTPS页面请求HTTP资源时，不发送<code class="fe ls lt lu lv b">Referrer</code>头。</li><li id="77d5" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">strict-origin-when-cross-origin</code>:<code class="fe ls lt lu lv b">Referrer</code>头包含同源请求的完整路径，仅包含跨域请求的域名。当HTTPS页面请求HTTP资源时，不会发送此标头。</li><li id="4f95" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">unsafe-url</code>:无论什么情况，都要发送<code class="fe ls lt lu lv b">Referrer</code>头。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/408ff9c0af3712e355c7287f96781069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ELG0a7FoW2yu_UyRaTWrg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com/s/photos/complete-configuration?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="93f9" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">取消<code class="fe ls lt lu lv b">fetch() </code>请求</h1><p id="bf8f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">fetch()</code>请求发出后，如果想中途取消，需要使用<code class="fe ls lt lu lv b">AbortController</code>对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="733d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，首先创建一个<code class="fe ls lt lu lv b">AbortController</code>实例，然后发送一个<code class="fe ls lt lu lv b">fetch()</code>请求。配置对象的<code class="fe ls lt lu lv b">signal</code>属性必须指定它接收由<code class="fe ls lt lu lv b">AbortController</code>实例发送的信号<code class="fe ls lt lu lv b">Controller.signal</code>。<code class="fe ls lt lu lv b">Controller.abort</code>方法用于发出取消信号。此时会触发<code class="fe ls lt lu lv b">abort</code>事件。这个事件可以被监控，或者您可以通过<code class="fe ls lt lu lv b">Controller.signal.aborted</code>属性确定取消信号是否已经被发送。以下是一秒钟后自动取消请求的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/5d3cda3357a0f9dabf8af489f30e5f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSK0GdPArv3m1UFDLNJT1w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Peggy Anke 在<a class="ae kv" href="https://unsplash.com/s/photos/cancel-request?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="f7f7" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="9903" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在这里，我用JavaScript描述了获取API用法、处理HTTP响应、定制HTTP请求、配置对象和取消请求。Fetch API可能有点让人不知所措，但在您继续学习JavaScript代码时，它绝对是至关重要的。</p><p id="4b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p></div></div>    
</body>
</html>