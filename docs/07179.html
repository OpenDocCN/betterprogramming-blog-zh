<html>
<head>
<title>Beginner Tips: Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者技巧:异步/等待</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginner-tips-async-await-b4ee13e71f7f?source=collection_archive---------10-----------------------#2020-12-14">https://betterprogramming.pub/beginner-tips-async-await-b4ee13e71f7f?source=collection_archive---------10-----------------------#2020-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5bcf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">异步JavaScript入门</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f30fa29722c05a3a6a1d8bd88e6bc4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ysZ8gZYvcObOfmlf"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图为<a class="ae kv" href="https://unsplash.com/@h4x0r3?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陶黎黄</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="1b56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名Flatiron学生，我的一个项目涉及制作一个单页面应用程序，该应用程序利用Rails API后端和JavaScript、CSS和HTML前端。我最终制作了一个(简化)版本的韩国卡牌游戏Hwatu，在日语中也被称为Hanafuda。在项目开始时，我一点也不知道我很快就会一头扎进async/await的世界。希望我从奋斗中获得的知识对未来的学生和有抱负的软件工程师有用。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0fec" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是异步/等待？</h1><p id="ef07" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Async只是承诺的语法糖。如果你不确定什么是承诺，这里有一篇非常有用的文章。您可以通过在函数前添加<code class="fe mw mx my mz b">async</code>来创建一个<code class="fe mw mx my mz b">async</code>函数。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="3f17" class="ne ma iq mz b gy nf ng l nh ni">const someAsyncFunction = async () =&gt; {<br/>  console.log('Hello!');<br/>};</span></pre><p id="a473" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe mw mx my mz b">async</code>添加到函数中后，您就可以使用<code class="fe mw mx my mz b">await</code>关键字来等待一个履行的承诺，然后再继续使用该函数。请注意，<code class="fe mw mx my mz b">await</code>必须加在返回承诺的函数之前(换句话说，另一个异步函数)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="acc5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Async不能与一起使用。为每一个</h1><p id="79d0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我遇到的第一个问题是将<code class="fe mw mx my mz b">async</code>与<code class="fe mw mx my mz b">.forEach</code>一起使用。不幸的是，我花了一段时间才意识到它们并不兼容。这是因为<code class="fe mw mx my mz b">.forEach</code>只调用一个函数，这意味着它不会等待函数结束就继续下一次迭代。有几个选择，当谈到补救这一点。一种选择是使用<code class="fe mw mx my mz b">.reduce</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5b35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">.reduce</code>允许你遍历一个数组，在给定的元素上调用一个<code class="fe mw mx my mz b">async</code>函数，等待解析，然后继续迭代。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0746" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Await不会阻塞执行堆栈</h1><p id="1866" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">await</code>只暂停使用它的函数中的代码。它不会一直阻塞调用堆栈。这是什么意思？让我们通过重构第一个代码块来看看。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="18da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出顺序让你吃惊吗？这是因为在<code class="fe mw mx my mz b">sayHelloAndGreet()</code>中调用<code class="fe mw mx my mz b">greeting()</code>之前没有使用<code class="fe mw mx my mz b">await</code>。因为没有<code class="fe mw mx my mz b">await</code> , <code class="fe mw mx my mz b">sayHelloAndGreet()</code>只是简单地调用<code class="fe mw mx my mz b">greeting()</code>却不等待它履行承诺。</p><p id="5a69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">操作顺序可以理解如下:</p><ol class=""><li id="597f" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">该函数通过调用<code class="fe mw mx my mz b">await sayHello()</code>开始。这告诉JavaScript等待<code class="fe mw mx my mz b">sayHello()</code>实现它的承诺，然后继续执行其余的代码。</li><li id="79b2" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">当<code class="fe mw mx my mz b">sayHello()</code>开始时，它首先执行<code class="fe mw mx my mz b">await timeout(4000)</code>。四秒钟后，它打印出“你好！”，兑现承诺。</li><li id="69dc" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">现在<code class="fe mw mx my mz b">sayHello()</code>已经完成了，<code class="fe mw mx my mz b">sayHelloAndGreet()</code>可以继续执行代码了。下一行调用<code class="fe mw mx my mz b"> greeting()</code>。但是因为<code class="fe mw mx my mz b">greeting()</code>之前没有<code class="fe mw mx my mz b">await</code>，所以不会等待<code class="fe mw mx my mz b">greeting()</code>完成，它把<code class="fe mw mx my mz b">greeting()</code>解释为<code class="fe mw mx my mz b">Promise {pending}</code>。(记住这并不意味着<code class="fe mw mx my mz b">greeting()</code>停止执行！)</li><li id="9936" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><code class="fe mw mx my mz b">sayHelloAndGreet()</code>中的一切完成后，执行下面的<code class="fe mw mx my mz b">.then</code>，打印出“打招呼和问候完毕！”。</li><li id="de7e" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">然而，<code class="fe mw mx my mz b">greeting()</code>仍然在后台执行。一旦完成，它就会打印“你好吗？”到控制台。</li></ol></div></div>    
</body>
</html>