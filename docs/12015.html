<html>
<head>
<title>Intercepting GraphQL Requests With Cypress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Cypress拦截GraphQL请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/intercepting-graphql-requests-with-cypress-99984d6d500c?source=collection_archive---------2-----------------------#2022-05-05">https://betterprogramming.pub/intercepting-graphql-requests-with-cypress-99984d6d500c?source=collection_archive---------2-----------------------#2022-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="85e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写端到端测试不一定是痛苦的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a073a1c30cb96683f704188dbfa1ff0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IHP33IupWzOgjGoT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/es/@cifilter?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">香农·波特</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="07b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为我们的web应用程序构建一套集成测试可能是一件痛苦的事情！在真实的浏览器环境中，在与其他服务隔离的情况下，很难创建一套完整的测试来彻底测试我们的应用程序的代码覆盖率。</p><p id="0a4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可能遇到的一些问题包括认证测试用户、与第三方服务交互以及在测试环境中与我们自己的后端交互。Cypress是构建e2e测试最流行的框架之一，它帮助我们处理了许多这样的问题。</p><p id="82bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我的经验，cypress提供的最有用的功能之一是<code class="fe ls lt lu lv b">cy.intercept()</code>，它用于拦截网络请求并模拟对你的应用程序的响应。这使得您的应用程序可以独立运行，并像在生产中一样运行，发出网络请求并接收预期的(尽管<em class="lw">被嘲笑</em>)响应，以继续运行和测试。这里有一个简单的例子，展示了网络请求REST API的实际情况…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h1 id="b61b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">GraphQL请求怎么办？</h1><p id="a2a2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">然而，这种模式有一个问题。应用程序发送的请求使用<code class="fe ls lt lu lv b">cy.intercept()</code>的前两个参数进行匹配——使用的HTTP方法和请求发送到的uri。如果你的应用程序使用GraphQL，<em class="lw">每一个</em>网络请求都将匹配前两个参数，因为<em class="lw">每一个</em> GraphQL请求都将是对<code class="fe ls lt lu lv b">&lt;server-uri&gt;/graphql</code>的POST请求！</p><p id="8d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个问题需要一点技巧。我们不是将一个<code class="fe ls lt lu lv b">StaticResponse</code>对象作为第三个参数传递给<code class="fe ls lt lu lv b">cy.intercept()</code>，而是传递一个回调函数，它允许我们更仔细地查看被拦截的请求。首先，假设我们有这个获取练习的查询，我们将这个操作命名为<code class="fe ls lt lu lv b">AllExercises</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="1b66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的cypress规范中做一点欺骗，我们可以完成同样的目标，拦截这个请求并发送回一个模拟的响应…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4917" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们仍然拦截每个对<code class="fe ls lt lu lv b">localhost:4000/graphql</code>的POST请求。但是通过使用回调函数作为<code class="fe ls lt lu lv b">cy.intercept()</code>的第三个参数并检查请求对象，我们实际上只对<em class="lw">关心的请求做了</em>任何事情。我们检查请求是否满足比方法和URI更具体的条件(在本例中，检查请求的<code class="fe ls lt lu lv b">operationName</code>是否为<code class="fe ls lt lu lv b">"AllExercises"</code>)，然后使用<code class="fe ls lt lu lv b">req.reply()</code>发回适当的模拟响应。</p><p id="a8a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们正在测试的页面产生了许多GraphQL请求，这种技术可能会有点混乱。我们可能会被大量的if语句和<code class="fe ls lt lu lv b">cy.intercept()</code>函数中的许多模拟响应对象所困扰。那会很快变丑的！这里有一个我发现的技术，它帮助我保持代码的整洁和可读性，同时仍然处理拦截许多需要不同模拟响应的不同gql请求的问题…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="a963" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将模拟响应映射到它们各自的<code class="fe ls lt lu lv b">operationName</code>,我们可以大大简化拦截。当然，根据您测试的内容，这并不总是有效，但是如果您只是需要确保您的应用程序获得它需要的数据，这可能是一个很好的简单方法。</p><p id="ecaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们大多数人不喜欢为我们的应用程序编写e2e测试。模仿对GraphQL服务器的响应可能特别痛苦。希望这种使用cypress的intercept函数，并将模拟响应映射到GraphQL操作名的技术可以帮助减轻痛苦！</p></div></div>    
</body>
</html>