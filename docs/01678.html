<html>
<head>
<title>Expressive Clean Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">表达清晰的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-code-give-meaning-to-your-code-to-exist-f966b3f00848?source=collection_archive---------2-----------------------#2019-10-04">https://betterprogramming.pub/clean-code-give-meaning-to-your-code-to-exist-f966b3f00848?source=collection_archive---------2-----------------------#2019-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="bebf" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">第17天| # 100天代码</h2><div class=""/><div class=""><h2 id="4484" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用美丽的节目讲美丽的故事</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/cd3ef4d574abd700f79704da2eaafc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUNrIFsJtPVGyBfnUsqJow.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">德米特里·拜尔在<a class="ae lh" href="https://unsplash.com/s/photos/bubbles?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="9efb" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">一个好的讲故事的人对他/她的语言有很强的控制力，并且知道在什么地方使用什么结构来正确优美地讲述任何故事。</p><p id="db98" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">类似地，你必须知道名词和动词(至少一开始是这样),才能写出清晰的表达程序，向任何阅读它们的人讲述一个美丽的故事。</p><p id="25cc" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">名词是变量和类，动词是函数。今天，我们将学习如何正确地创建和使用它们。</p><p id="e2b4" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">不要低估有意义地命名变量、函数和类所面临的困难。不是有机化学，但还是很难。</p><p id="8d47" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">好了，我们开始吧。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0c7d" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">清除变量名</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nf"><img src="../Images/a6cfa6dcf051b0c919e96512ee6a0e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3UE1BKFFsNW_0AYxSOpozg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">事实</p></figure><p id="9e24" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">不要花太多时间去考虑正确的名称——只需在编写代码时考虑不同的变量名，然后看看哪一个最符合您编写的代码。</p><p id="570c" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">一个你可以一直坚持的简单而可靠的规则是:变量名应该向阅读你的代码的人揭示三个问题。</p><ol class=""><li id="d0d0" class="ng nh it lm b ln lo lq lr lt ni lx nj mb nk mf nl nm nn no bi translated">为什么会存在这种情况？</li><li id="50c6" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nl nm nn no bi translated">它是做什么的？</li><li id="7602" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nl nm nn no bi translated">如何使用？</li></ol><p id="2179" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">以下是一些需要记住的额外要点:</p><ul class=""><li id="cc83" class="ng nh it lm b ln lo lq lr lt ni lx nj mb nk mf nu nm nn no bi translated">区分两个变量不会花太多时间。例如，这两个变量需要花费太多不必要的努力来区分。</li></ul><pre class="ks kt ku kv gt nv nw nx ny aw nz bi"><span id="b328" class="oa mo it nw b gy ob oc l od oe"><strong class="nw jd"><em class="of">var XYZControllerForEfficientHandlingOfStrings <br/>var XYZControllerForEfficientStorageOfStrings</em></strong></span></pre><ul class=""><li id="87c4" class="ng nh it lm b ln lo lq lr lt ni lx nj mb nk mf nu nm nn no bi translated">使用像<code class="fe og oh oi nw b">1</code>(一)和<code class="fe og oh oi nw b">l</code>(小写L)或<code class="fe og oh oi nw b">O</code>(大写O)和<code class="fe og oh oi nw b">0</code>(零)这样的字符时要小心。</li><li id="bf9a" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nu nm nn no bi translated">永远不要仅仅为了满足编译器而给名字。当编译器对相同范围内的重复名称提出错误时，不要只是将变量名改成类似<code class="fe og oh oi nw b">variable2</code>或其他随机名称。如果你的变量是不同的，它们的名字应该说明它们不同的存在理由。</li><li id="eba5" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nu nm nn no bi translated">使用容易发音的名称，以便在与他人讨论您的代码时更容易发音。</li><li id="3be7" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nu nm nn no bi translated">使用可搜索的名称。ide可以帮助我们搜索代码，甚至给出直观的建议。但是只有给变量/函数起名字，你才能利用这种能力。这将帮助您从代码的任何部分引用它们，而不必回来检查您给它们取了什么名字。</li><li id="c26c" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nu nm nn no bi translated">命名时不要使用幽默或双关语。说你的意思，说话算数。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5e91" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">编写干净的函数</h1><p id="8d3b" class="pw-post-body-paragraph lk ll it lm b ln oj kd lp lq ok kg ls lt ol lv lw lx om lz ma mb on md me mf im bi translated">当你工作在干净的代码上时，你会知道每个函数都是你所期望的。</p><ol class=""><li id="279e" class="ng nh it lm b ln lo lq lr lt ni lx nj mb nk mf nl nm nn no bi translated">职能要做一件事，而且要做好。</li><li id="5503" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nl nm nn no bi translated">函数应该只有一个改变的理由。他们必须遵循单一责任原则。</li><li id="2a70" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nl nm nn no bi translated">当有新的需求时，功能不应该改变。它们必须遵循开闭原则。</li></ol><p id="dc8b" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">(如果你没有听说过上面提到的两个原则，<a class="ae lh" href="https://medium.com/@devDeeJay/the-solid-principles-for-good-software-design-14b4ec6d7607" rel="noopener">在这里阅读它们</a>。)</p><p id="305f" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">一个函数包括一个主体和一个参数列表，两者对编写干净的函数都有同等的贡献。</p><p id="3ef4" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">让我们来看看两者的一些要点:</p><h2 id="ece0" class="oa mo it bd mp oo op dn mt oq or dp mx lt os ot mz lx ou ov nb mb ow ox nd iz bi translated">1.函数体:</h2><ul class=""><li id="c9f9" class="ng nh it lm b ln oj lq ok lt oy lx oz mb pa mf nu nm nn no bi translated">一个函数应该做一些事情或者返回一些东西，但是不能两者都做。要么它应该修改对象的状态，要么它应该返回一些关于对象的信息。双管齐下，只会导致未来的混乱。</li><li id="c89a" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nu nm nn no bi translated">函数应该很小，这意味着它们永远不应该超过20行代码(但是尽量让它们小于20行)。</li><li id="2744" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nu nm nn no bi translated">与父行相比，函数的缩进级别不应大于一或二。当然，这使得函数更容易阅读和理解。</li></ul><p id="f788" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">下面是一个错误代码缩进的例子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/6910cbf43680cd9618ab0ab7af1f525a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mEJKCPmVmGYLDBkx.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">信用:<a class="ae lh" href="https://stackoverflow.com/questions/15157504/eclipse-javascript-formatter-crazy-i-e-too-much-padding" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a></p></figure><ul class=""><li id="c075" class="ng nh it lm b ln lo lq lr lt ni lx nj mb nk mf nu nm nn no bi translated"><code class="fe og oh oi nw b">if</code>语句、<code class="fe og oh oi nw b">else</code>语句、<code class="fe og oh oi nw b">while</code>语句等等中的块应该是一行长。如果它是一个长的条件语句，将它重构为返回<code class="fe og oh oi nw b">true</code>或<code class="fe og oh oi nw b">false</code>的函数。</li><li id="fe9d" class="ng nh it lm b ln np lq nq lt nr lx ns mb nt mf nu nm nn no bi translated">函数的一个长的描述性名称比一个短的神秘名称要好。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="f33a" class="oa mo it bd mp oo op dn mt oq or dp mx lt os ot mz lx ou ov nb mb ow ox nd iz bi translated">2.函数参数</h2><p id="f2da" class="pw-post-body-paragraph lk ll it lm b ln oj kd lp lq ok kg ls lt ol lv lw lx om lz ma mb on md me mf im bi translated"><strong class="lm jd">理想数量:</strong>一个函数应该拥有的理想参数数量为零。之后，不超过一个、两个或最多三个是可取的(尽管应避免后者)。只有在非常特殊的情况下才允许三个以上的参数。</p><p id="7e63" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">为什么？从测试的角度来看，多重论证更加困难。想象一下编写所有测试用例以确保所有不同的参数组合正常工作的难度。</strong></p><p id="a4e0" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">问题:</strong>如果没有参数，这是微不足道的。如果有一个论点，也不是太难。有了两个论点，问题变得更具挑战性。如果有两个以上的参数，测试每个适当值的组合就变得令人生畏。您可以通过编写参数数量最少的函数来避免这种情况。</p><p id="bf28" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">从不传递标志参数:</strong>将标志(真/假)作为参数传递确实是一种可怕的做法。它会立即使您的函数违反SRP——因为当参数为真时，您的函数会以某种方式运行，而当参数为假时，函数会以另一种方式运行。</p><p id="137c" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">你该怎么办？使用参数对象:</strong>在一个类中包装多个参数看起来像是欺骗，但实际上不是。当涉及到需要发送给函数的多个参数时，它们可能以某种方式相互关联。将这些字段封装到一个类中，并给这个类起一个有意义的名字，这确实是一个很好的做法。</p><p id="500c" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">许多语言为你提供了编写内嵌函数的平台。例如，要求您编写一个函数，该函数将一个报表作为输入，并在该报表后添加一个页脚。</p><p id="83b7" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">方法1: </strong>创建一个函数，该函数将报表作为输入，并向其附加一个页脚。这个函数有一个参数。可以改进。</p><pre class="ks kt ku kv gt nv nw nx ny aw nz bi"><span id="116b" class="oa mo it nw b gy ob oc l od oe">public void appendFooter(StringBuffer report) {...}</span></pre><p id="3220" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">方法2: </strong>创建一个内嵌函数，它没有参数，但实际上直接处理报表实例。</p><pre class="ks kt ku kv gt nv nw nx ny aw nz bi"><span id="1384" class="oa mo it nw b gy ob oc l od oe">report.appendFooter()</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f5fd" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">如何处理错误/异常？</h1><p id="0f87" class="pw-post-body-paragraph lk ll it lm b ln oj kd lp lq ok kg ls lt ol lv lw lx om lz ma mb on md me mf im bi translated">处理错误的函数必须只处理错误，不应该做任何其他事情。</p><p id="ea9c" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">更喜欢抛出异常而不是返回错误代码。当您返回错误代码时，您强制调用者函数立即处理它。这意味着更多的样板代码。</p><p id="8be3" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">让我们看一个例子。我们正在做一些联网工作，用食物列表更新我们的用户界面。</p><p id="17e9" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">联网类:</strong></p><pre class="ks kt ku kv gt nv nw nx ny aw nz bi"><span id="ca95" class="oa mo it nw b gy ob oc l od oe">// Inside some function<br/>// Getting list from somewhere</span><span id="2d46" class="oa mo it nw b gy pc oc l od oe">val listOfFoodItems = getFoodItemsList()</span><span id="6b77" class="oa mo it nw b gy pc oc l od oe"><strong class="nw jd">// If list is null, means something went wrong</strong><br/>if (listOfFoodItems.isNull()) {<br/>    callback(FoodOrder.Error)<br/>}<br/><strong class="nw jd">// If all goes well, we send back list of food items</strong><br/>else {<br/>    callback(FoodOrder.FoodMenu(listOfFoodItems))<br/>}</span></pre><p id="1b13" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">用户界面类:</strong></p><pre class="ks kt ku kv gt nv nw nx ny aw nz bi"><span id="7382" class="oa mo it nw b gy ob oc l od oe">// Getting list from somewhere<br/>var status = getReturningStatus()</span><span id="4f63" class="oa mo it nw b gy pc oc l od oe">if (status == ERROR) {<br/>    // Handle errors<br/>} else if (status == FoodItemList) {<br/>    // Do something with food list<br/>}</span></pre><p id="e822" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">如果我们使用异常，我们的代码会变得更加紧凑。</p><p id="c3e8" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">改进的网络类:</strong></p><pre class="ks kt ku kv gt nv nw nx ny aw nz bi"><span id="2d1e" class="oa mo it nw b gy ob oc l od oe">val listOfFoodItems = getFoodItemsList()</span><span id="2522" class="oa mo it nw b gy pc oc l od oe">if (listOfFoodItems.isNull()) {<br/>    throw some custom Exception<br/>}<br/>else {<br/>    callback(FoodOrder.FoodMenu(listOfFoodItems))<br/>}</span></pre><p id="994c" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">改进的UI类:</strong></p><pre class="ks kt ku kv gt nv nw nx ny aw nz bi"><span id="f471" class="oa mo it nw b gy ob oc l od oe">try {<br/>  var listOfFoodItems = getAllFoodItems()<br/>} catch (your exception type) {<br/>  // Act accordingly<br/>}</span></pre><p id="8a2d" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">即使您的错误用例数量增加，您也只需从networking类中抛出异常，并在UI类中添加更多catch块。</p><p id="0531" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">对了，这段代码也是遵循开闭原则的。</p><p id="c80c" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated"><strong class="lm jd">提示:</strong>如果你在你的try/catch块中做多件事情，提取出不合适的函数，使你的代码看起来干净易读。不要留下嵌套的、难看的try-catch块。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5ad4" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">结论</h1><p id="3861" class="pw-post-body-paragraph lk ll it lm b ln oj kd lp lq ok kg ls lt ol lv lw lx om lz ma mb on md me mf im bi translated">编程大师认为系统是要讲的故事，而不是要写的程序。</p><p id="54c0" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">他们选择编程语言的结构来表达他们用代码写的故事。函数是语言的动词，类是名词。编程的艺术在于如何使用语言提供的工具来讲述最好的故事。</p><p id="99e0" class="pw-post-body-paragraph lk ll it lm b ln lo kd lp lq lr kg ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">在接下来的几天里，我会和你们分享更多的东西。感谢你的阅读，一如既往，你太棒了！</p></div></div>    
</body>
</html>