<html>
<head>
<title>How to Make a Whiteboard App with React Konva</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React Konva制作白板App</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-a-whiteboard-app-with-react-konva-8766a532a39f?source=collection_archive---------3-----------------------#2019-09-04">https://betterprogramming.pub/how-to-make-a-whiteboard-app-with-react-konva-8766a532a39f?source=collection_archive---------3-----------------------#2019-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f3d668d1bf30102af0d8ac166a2832ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yw4w_fTZ-GFXgDaYIeNVxA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@austindistel" rel="noopener ugc nofollow" target="_blank">奥斯汀·迪斯特尔</a>在<a class="ae kf" href="https://unsplash.com/photos/wD1LRb9OeEo" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3a71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">HTML Canvas是HTML规范的一部分，允许开发人员轻松地向他们的应用程序添加图形和交互性。</p><p id="2bac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在HTML画布中，您可以添加具有不同颜色、填充和渐变的图像、文本和形状。几乎所有最新的浏览器都支持它。</p><p id="a0e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要向画布添加内容，首先要向页面添加一个<code class="fe le lf lg lh b">canvas</code>元素。然后，您可以将线条添加到您想要的形状的画布上。</p><p id="ee7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，要将一条线和一个圆添加到您的<code class="fe le lf lg lh b">canvas</code>元素中，在您的HTML文件中执行以下操作:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="be4b" class="lq lr it lh b gy ls lt l lu lv">&lt;canvas id="canvas" width="200" height="100" style="border:2px solid #000000;"&gt;<br/>&lt;/canvas&gt;</span></pre><p id="fc13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在您的JavaScript文件中，您这样做:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="bed9" class="lq lr it lh b gy ls lt l lu lv">let c = document.getElementById("canvas");<br/>let ctx = c.getContext("2d");<br/>ctx.moveTo(0, 0);<br/>ctx.lineTo(50, 100);<br/>ctx.stroke();<br/>ctx.beginPath();<br/>ctx.arc(1, 50, 40, 0, 2 * Math.PI);<br/>ctx.stroke();</span></pre><p id="ac05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想添加任何更复杂的东西，那就很难做到了。</p><p id="31d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<a class="ae kf" href="https://konvajs.org/" rel="noopener ugc nofollow" target="_blank"> Konva </a>库抽象了向画布添加项目的艰苦工作。它允许您通过简单地编写几行代码来添加更多的形状。还有针对Konva的React绑定，它具有带附加功能的抽象。但是React Konva的功能集比较有限，所以为了满足大部分app的需求，React Konva应该作为Konva的配套使用。</p><p id="2b62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你也可以让用户轻松地移动和变换你的形状，如果你想在<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> HTML Canvas API </a>中这样做，你必须自己编写。</p><p id="4e65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Konva的工作原理是创建一个舞台和一个舞台层，这将允许您添加所需的线条、形状和文本。</p><p id="8bd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将构建一个白板应用程序，允许用户向白板添加形状、文本、线条和图像。此外，用户可以撤销他们的工作，从屏幕上删除内容。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9550" class="md lr it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">入门指南</h1><p id="3a19" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">首先，我们将使用Create React app命令行程序创建一个React App。运行<code class="fe le lf lg lh b">npx create-react-app whiteboard-app</code>为我们的应用程序创建初始文件。</p><p id="e93b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要添加一些包。除了Konva包之外，我们还想使用Bootstrap来设计样式，并使用一个助手包来为我们的形状、线条和文本创建唯一的id。我们还需要React路由器进行路由。</p><p id="d467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了安装这些库，我们运行<code class="fe le lf lg lh b">npm i bootstrap react-bootstrap konva react-konva react-router-dom use-image uuid</code>。</p><p id="ee5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">use-image</code>是一个将图像URL转换成可以在画布上显示的图像对象的包。UUID包为我们的形状生成唯一的ID。</p><p id="6785" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装好包之后，我们就可以开始编写代码了。首先从我们app的入口点开始，这个入口点就是<code class="fe le lf lg lh b">App.js</code>。将文件的现有代码替换为:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="36d9" class="lq lr it lh b gy ls lt l lu lv">import React from "react";<br/>import { Router, Route, Link } from "react-router-dom";<br/>import HomePage from "./HomePage";<br/>import TopBar from "./TopBar";<br/>import { createBrowserHistory as createHistory } from "history";<br/>import "./App.css";<br/>const history = createHistory();</span><span id="93f3" class="lq lr it lh b gy nf lt l lu lv">function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Router history={history}&gt;<br/>        &lt;TopBar /&gt;<br/>        &lt;Route path="/" exact component={HomePage} /&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="d982" class="lq lr it lh b gy nf lt l lu lv">export default App;</span></pre><p id="e8b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所添加的是我们唯一的路线，这是主页，和一个顶栏。</p><p id="9985" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们添加形状的代码。React Konva拥有矩形和圆形等常见形状的库。我们首先从圆圈开始。在<code class="fe le lf lg lh b">src</code> <br/>文件夹中，创建一个名为<code class="fe le lf lg lh b">Circle.js</code>的文件，并添加:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="8f1e" class="lq lr it lh b gy ls lt l lu lv">import React from "react";<br/>import { Circle, Transformer } from "react-konva";</span><span id="9efd" class="lq lr it lh b gy nf lt l lu lv">const Circ = ({ shapeProps, isSelected, onSelect, onChange }) =&gt; {<br/>  const shapeRef = React.useRef();<br/>  const trRef = React.useRef();</span><span id="56d6" class="lq lr it lh b gy nf lt l lu lv">  React.useEffect(() =&gt; {<br/>    if (isSelected) {<br/>      trRef.current.setNode(shapeRef.current);<br/>      trRef.current.getLayer().batchDraw();<br/>    }<br/>  }, [isSelected]);</span><span id="4ee2" class="lq lr it lh b gy nf lt l lu lv">  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;Circle<br/>        onClick={onSelect}<br/>        ref={shapeRef}<br/>        {...shapeProps}<br/>        draggable<br/>        onDragEnd={e =&gt; {<br/>          onChange({<br/>            ...shapeProps,<br/>            x: e.target.x(),<br/>            y: e.target.y(),<br/>          });<br/>        }}<br/>        onTransformEnd={e =&gt; {<br/>          // transformer is changing scale<br/>          const node = shapeRef.current;<br/>          const scaleX = node.scaleX();<br/>          const scaleY = node.scaleY();<br/>          node.scaleX(1);<br/>          node.scaleY(1);<br/>          onChange({<br/>            ...shapeProps,<br/>            x: node.x(),<br/>            y: node.y(),<br/>            width: node.width() * scaleX,<br/>            height: node.height() * scaleY,<br/>          });<br/>        }}<br/>      /&gt;<br/>      {isSelected &amp;&amp; &lt;Transformer ref={trRef} /&gt;}<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span><span id="7c85" class="lq lr it lh b gy nf lt l lu lv">export default Circ;</span></pre><p id="f35a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码返回可以随意添加到画布上的<code class="fe le lf lg lh b">Circle</code>形状。在<code class="fe le lf lg lh b">React.useEffect</code>回调函数中，我们可以检测形状是否被选中，然后为形状绘制一个句柄，这样它就可以被调整大小和移动。</p><p id="64c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">return</code>语句中的组件是<code class="fe le lf lg lh b">Circle</code>的主要代码。我们有一个<code class="fe le lf lg lh b">onClick</code>处理程序，它获取所选形状的ID。</p><p id="6cc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">draggable</code>道具使<code class="fe le lf lg lh b">Circle</code>可拖动。</p><p id="cc75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">onDragEnd</code>当用户停止拖动时处理事件。位置在那里被更新。</p><p id="7510" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">onTransformEnd</code>当用户拖动可用的手柄时缩放形状。<code class="fe le lf lg lh b">width </code>和<code class="fe le lf lg lh b">height</code>随着手柄的拖动而改变。</p><p id="d8f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">{isSelected &amp;&amp; &lt;Transformer ref={trRef} /&gt;}</code>创建<code class="fe le lf lg lh b">Transformer</code>对象，这是一个Konva对象，如果您将它附加到形状上，当您选择它时，它允许您更改形状的大小。</p><p id="a519" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们为图像添加一个组件。在<code class="fe le lf lg lh b">src</code>文件夹中创建一个名为<code class="fe le lf lg lh b">Image.js</code>的文件，并添加以下内容:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="0ea5" class="lq lr it lh b gy ls lt l lu lv">import React from "react";<br/>import { Image, Transformer } from "react-konva";<br/>import useImage from "use-image";</span><span id="7921" class="lq lr it lh b gy nf lt l lu lv">const Img = ({ shapeProps, isSelected, onSelect, onChange, imageUrl }) =&gt; {<br/>  const shapeRef = React.useRef();<br/>  const trRef = React.useRef();<br/>  const [image] = useImage(imageUrl);</span><span id="d9d1" class="lq lr it lh b gy nf lt l lu lv">  React.useEffect(() =&gt; {<br/>    if (isSelected) {<br/>      // we need to attach transformer manually<br/>      trRef.current.setNode(shapeRef.current);<br/>      trRef.current.getLayer().batchDraw();<br/>    }<br/>  }, [isSelected]);</span><span id="ae5b" class="lq lr it lh b gy nf lt l lu lv">  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;Image<br/>        onClick={onSelect}<br/>        image={image}<br/>        ref={shapeRef}<br/>        draggable<br/>        onDragEnd={e =&gt; {<br/>          onChange({<br/>            ...shapeProps,<br/>            x: e.target.x(),<br/>            y: e.target.y(),<br/>          });<br/>        }}<br/>        onTransformEnd={e =&gt; {<br/>          const node = shapeRef.current;<br/>          const scaleX = node.scaleX();<br/>          const scaleY = node.scaleY();<br/>          onChange({<br/>            ...shapeProps,<br/>            x: node.x(),<br/>            y: node.y(),<br/>            width: node.width() * scaleX,<br/>            height: node.height() * scaleY,<br/>          });<br/>        }}<br/>      /&gt;<br/>      {isSelected &amp;&amp; &lt;Transformer ref={trRef} /&gt;}<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span><span id="6e94" class="lq lr it lh b gy nf lt l lu lv">export default Img;</span></pre><p id="f20e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这非常类似于<code class="fe le lf lg lh b">Circle</code>组件，除了我们有由<code class="fe le lf lg lh b">use-image</code>库提供的<code class="fe le lf lg lh b">useImage</code>函数来将给定的<code class="fe le lf lg lh b">imageUrl</code>道具转换成将在画布上显示的图像。</p><p id="c335" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们创建一条自由绘制线。在<code class="fe le lf lg lh b">src</code>文件夹中创建一个名为<code class="fe le lf lg lh b">line.js</code>的文件，并添加:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="8a2f" class="lq lr it lh b gy ls lt l lu lv">import Konva from "konva";</span><span id="5d7d" class="lq lr it lh b gy nf lt l lu lv">export const addLine = (stage, layer, mode = "brush") =&gt; {<br/>  let isPaint = false;<br/>  let lastLine;</span><span id="b7cf" class="lq lr it lh b gy nf lt l lu lv">  stage.on("mousedown touchstart", function(e) {<br/>    isPaint = true;<br/>    let pos = stage.getPointerPosition();<br/>    lastLine = new Konva.Line({<br/>      stroke: mode == "brush" ? "red" : "white",<br/>      strokeWidth: mode == "brush" ? 5 : 20,<br/>      globalCompositeOperation:<br/>        mode === "brush" ? "source-over" : "destination-out",<br/>      points: [pos.x, pos.y],<br/>      draggable: mode == "brush",<br/>    });<br/>    layer.add(lastLine);<br/>  });</span><span id="9014" class="lq lr it lh b gy nf lt l lu lv">  stage.on("mouseup touchend", function() {<br/>    isPaint = false;<br/>  });</span><span id="579b" class="lq lr it lh b gy nf lt l lu lv">  stage.on("mousemove touchmove", function() {<br/>    if (!isPaint) {<br/>      return;<br/>    }</span><span id="6a83" class="lq lr it lh b gy nf lt l lu lv">  const pos = stage.getPointerPosition();<br/>    let newPoints = lastLine.points().concat([pos.x, pos.y]);<br/>    lastLine.points(newPoints);<br/>    layer.batchDraw();<br/>  });<br/>};</span></pre><p id="97e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个文件中，我们使用普通的Konva，因为React Konva没有一种方便的方法来绘制一条自由的画线，用户可以拖动鼠标并以自由的形式绘制一条线。当<code class="fe le lf lg lh b">mousedown</code>和<code class="fe le lf lg lh b">touchstart</code>被触发时，我们根据<code class="fe le lf lg lh b">mode</code>设置线条的颜色。当它是<code class="fe le lf lg lh b">brush</code>时，我们画一条红线。如果是<code class="fe le lf lg lh b">erase</code>，我们会画一条粗白线，这样用户可以在他们的内容上画白线，让用户删除他们的更改。</p><p id="4580" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当<code class="fe le lf lg lh b">mousemove</code>和<code class="fe le lf lg lh b">touchend</code>事件被触发时，我们将<code class="fe le lf lg lh b">isPaint</code>设置为假，因此我们停止画线。当<code class="fe le lf lg lh b">mousemove</code>和<code class="fe le lf lg lh b">touchmove</code>事件被触发时，当用户在点击或触摸触摸屏时移动鼠标时，我们沿着用户想要的方向添加圆点来绘制线条。</p><p id="204b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们创建用于绘制自由形状矩形的<code class="fe le lf lg lh b">Rectangle</code>组件。在<code class="fe le lf lg lh b">src</code>文件夹中，创建一个名为<code class="fe le lf lg lh b">Rectangle.js</code>的文件，并添加:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="c3dc" class="lq lr it lh b gy ls lt l lu lv">import React from "react";<br/>import { Rect, Transformer } from "react-konva";</span><span id="134a" class="lq lr it lh b gy nf lt l lu lv">const Rectangle = ({ shapeProps, isSelected, onSelect, onChange }) =&gt; {<br/>  const shapeRef = React.useRef();<br/>  const trRef = React.useRef();</span><span id="a671" class="lq lr it lh b gy nf lt l lu lv">  React.useEffect(() =&gt; {<br/>    if (isSelected) {<br/>      // we need to attach transformer manually<br/>      trRef.current.setNode(shapeRef.current);<br/>      trRef.current.getLayer().batchDraw();<br/>    }<br/>  }, [isSelected]);</span><span id="6eea" class="lq lr it lh b gy nf lt l lu lv">  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;Rect<br/>        onClick={onSelect}<br/>        ref={shapeRef}<br/>        {...shapeProps}<br/>        draggable<br/>        onDragEnd={e =&gt; {<br/>          onChange({<br/>            ...shapeProps,<br/>            x: e.target.x(),<br/>            y: e.target.y(),<br/>          });<br/>        }}<br/>        onTransformEnd={e =&gt; {<br/>          // transformer is changing scale<br/>          const node = shapeRef.current;<br/>          const scaleX = node.scaleX();<br/>          const scaleY = node.scaleY();<br/>          node.scaleX(1);<br/>          node.scaleY(1);<br/>          onChange({<br/>            ...shapeProps,<br/>            x: node.x(),<br/>            y: node.y(),<br/>            width: node.width() * scaleX,<br/>            height: node.height() * scaleY,<br/>          });<br/>        }}<br/>      /&gt;<br/>      {isSelected &amp;&amp; &lt;Transformer ref={trRef} /&gt;}<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span><span id="7636" class="lq lr it lh b gy nf lt l lu lv">export default Rectangle;</span></pre><p id="fe57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该组件类似于<code class="fe le lf lg lh b">Circle</code>组件。</p><p id="6b31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过添加<code class="fe le lf lg lh b">onDragEnd</code>和<code class="fe le lf lg lh b">onTransformEnd</code>回调函数来移动和调整矩形的大小。我们也可以在<code class="fe le lf lg lh b">onDragEnd</code>处理程序中改变<code class="fe le lf lg lh b">x</code>和<code class="fe le lf lg lh b">y</code>坐标，在<code class="fe le lf lg lh b">onTransformEnd</code>事件回调中改变<code class="fe le lf lg lh b">width</code>和<code class="fe le lf lg lh b">height</code>。</p><p id="78f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果形状被选中，则添加<code class="fe le lf lg lh b">Transformer</code>组件，以便用户可以在选中时使用手柄移动形状或调整形状大小。</p><p id="a5a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们添加一个文本字段组件，让用户向白板添加文本。创建一个名为<code class="fe le lf lg lh b">textNode.js</code>的文件，并添加以下内容:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="bcd6" class="lq lr it lh b gy ls lt l lu lv">import Konva from "konva";<br/>const uuidv1 = require("uuid/v1");</span><span id="34ef" class="lq lr it lh b gy nf lt l lu lv">export const addTextNode = (stage, layer) =&gt; {<br/>  const id = uuidv1();<br/>  const textNode = new Konva.Text({<br/>    text: "type here",<br/>    x: 50,<br/>    y: 80,<br/>    fontSize: 20,<br/>    draggable: true,<br/>    width: 200,<br/>    id,<br/>  });</span><span id="55d6" class="lq lr it lh b gy nf lt l lu lv">  layer.add(textNode);</span><span id="1da4" class="lq lr it lh b gy nf lt l lu lv">  let tr = new Konva.Transformer({<br/>    node: textNode,<br/>    enabledAnchors: ["middle-left", "middle-right"],<br/>    // set minimum width of text<br/>    boundBoxFunc: function(oldBox, newBox) {<br/>      newBox.width = Math.max(30, newBox.width);<br/>      return newBox;<br/>    },<br/>  });</span><span id="7e4a" class="lq lr it lh b gy nf lt l lu lv">  stage.on("click", function(e) {<br/>    if (!this.clickStartShape) {<br/>      return;<br/>    }<br/>    if (e.target._id == this.clickStartShape._id) {<br/>      layer.add(tr);<br/>      tr.attachTo(e.target);<br/>      layer.draw();<br/>    } else {<br/>      tr.detach();<br/>      layer.draw();<br/>    }<br/>  });</span><span id="dcd7" class="lq lr it lh b gy nf lt l lu lv">  textNode.on("transform", function() {<br/>    // reset scale, so only with is changing by transformer<br/>    textNode.setAttrs({<br/>      width: textNode.width() * textNode.scaleX(),<br/>      scaleX: 1,<br/>    });<br/>  });</span><span id="5c3c" class="lq lr it lh b gy nf lt l lu lv">  layer.add(tr);</span><span id="bb48" class="lq lr it lh b gy nf lt l lu lv">  layer.draw();</span><span id="9ff0" class="lq lr it lh b gy nf lt l lu lv">  textNode.on("dblclick", () =&gt; {<br/>    // hide text node and transformer:<br/>    textNode.hide();<br/>    tr.hide();<br/>    layer.draw();</span><span id="6b6a" class="lq lr it lh b gy nf lt l lu lv">// create textarea over canvas with absolute position<br/>    // first we need to find position for textarea<br/>    // how to find it?</span><span id="285c" class="lq lr it lh b gy nf lt l lu lv">// at first lets find position of text node relative to the stage:<br/>    let textPosition = textNode.absolutePosition();</span><span id="f7eb" class="lq lr it lh b gy nf lt l lu lv">// then lets find position of stage container on the page:<br/>    let stageBox = stage.container().getBoundingClientRect();</span><span id="421d" class="lq lr it lh b gy nf lt l lu lv">// so position of textarea will be the sum of positions above:<br/>    let areaPosition = {<br/>      x: stageBox.left + textPosition.x,<br/>      y: stageBox.top + textPosition.y,<br/>    };</span><span id="b7c1" class="lq lr it lh b gy nf lt l lu lv">// create textarea and style it<br/>    let textarea = document.createElement("textarea");<br/>    document.body.appendChild(textarea);</span><span id="c2c4" class="lq lr it lh b gy nf lt l lu lv">// apply many styles to match text on canvas as close as possible<br/>    // remember that text rendering on canvas and on the textarea can be different<br/>    // and sometimes it is hard to make it 100% the same. But we will try...<br/>    textarea.value = textNode.text();<br/>    textarea.style.position = "absolute";<br/>    textarea.style.top = areaPosition.y + "px";<br/>    textarea.style.left = areaPosition.x + "px";<br/>    textarea.style.width = textNode.width() - textNode.padding() * 2 + "px";<br/>    textarea.style.height =<br/>      textNode.height() - textNode.padding() * 2 + 5 + "px";<br/>    textarea.style.fontSize = textNode.fontSize() + "px";<br/>    textarea.style.border = "none";<br/>    textarea.style.padding = "0px";<br/>    textarea.style.margin = "0px";<br/>    textarea.style.overflow = "hidden";<br/>    textarea.style.background = "none";<br/>    textarea.style.outline = "none";<br/>    textarea.style.resize = "none";<br/>    textarea.style.lineHeight = textNode.lineHeight();<br/>    textarea.style.fontFamily = textNode.fontFamily();<br/>    textarea.style.transformOrigin = "left top";<br/>    textarea.style.textAlign = textNode.align();<br/>    textarea.style.color = textNode.fill();<br/>    let rotation = textNode.rotation();<br/>    let transform = "";<br/>    if (rotation) {<br/>      transform += "rotateZ(" + rotation + "deg)";<br/>    }</span><span id="f30d" class="lq lr it lh b gy nf lt l lu lv">    let px = 0;<br/>    let isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") &gt; -1;<br/>    if (isFirefox) {<br/>      px += 2 + Math.round(textNode.fontSize() / 20);<br/>    }<br/>    transform += "translateY(-" + px + "px)";</span><span id="2053" class="lq lr it lh b gy nf lt l lu lv">    textarea.style.transform = transform;<br/>    textarea.style.height = "auto";<br/>    // after browsers resized it we can set actual value<br/>    textarea.style.height = textarea.scrollHeight + 3 + "px";</span><span id="3574" class="lq lr it lh b gy nf lt l lu lv">    textarea.focus();</span><span id="acac" class="lq lr it lh b gy nf lt l lu lv">    function removeTextarea() {<br/>      textarea.parentNode.removeChild(textarea);<br/>      window.removeEventListener("click", handleOutsideClick);<br/>      textNode.show();<br/>      tr.show();<br/>      tr.forceUpdate();<br/>      layer.draw();<br/>    }</span><span id="6147" class="lq lr it lh b gy nf lt l lu lv">    function setTextareaWidth(newWidth) {<br/>      if (!newWidth) {<br/>        // set width for placeholder<br/>        newWidth = textNode.placeholder.length * textNode.fontSize();<br/>      }<br/>      // some extra fixes on different browsers<br/>      let isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);<br/>      let isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") &gt; -1;<br/>      if (isSafari || isFirefox) {<br/>        newWidth = Math.ceil(newWidth);<br/>      }</span><span id="5fd6" class="lq lr it lh b gy nf lt l lu lv">let isEdge = document.documentMode || /Edge/.test(navigator.userAgent);<br/>      if (isEdge) {<br/>        newWidth += 1;<br/>      }<br/>      textarea.style.width = newWidth + "px";<br/>    }</span><span id="fda8" class="lq lr it lh b gy nf lt l lu lv">    textarea.addEventListener("keydown", function(e) {<br/>      // hide on enter<br/>      // but don't hide on shift + enter<br/>      if (e.keyCode === 13 &amp;&amp; !e.shiftKey) {<br/>        textNode.text(textarea.value);<br/>        removeTextarea();<br/>      }<br/>      // on esc do not set value back to node<br/>      if (e.keyCode === 27) {<br/>        removeTextarea();<br/>      }<br/>    });</span><span id="0b3a" class="lq lr it lh b gy nf lt l lu lv">    textarea.addEventListener("keydown", function(e) {<br/>      let scale = textNode.getAbsoluteScale().x;<br/>      setTextareaWidth(textNode.width() * scale);<br/>      textarea.style.height = "auto";<br/>      textarea.style.height =<br/>        textarea.scrollHeight + textNode.fontSize() + "px";<br/>    });</span><span id="7bc5" class="lq lr it lh b gy nf lt l lu lv">    function handleOutsideClick(e) {<br/>      if (e.target !== textarea) {<br/>        removeTextarea();<br/>      }<br/>    }<br/>    setTimeout(() =&gt; {<br/>      window.addEventListener("click", handleOutsideClick);<br/>    });<br/>  });<br/>  return id;<br/>};</span></pre><p id="9057" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加一个文本区域，然后处理由文本区域创建的事件。当用户单击文本区域时，将显示一个带有手柄的框，让用户在画布上移动文本区域。这就是载物台的<code class="fe le lf lg lh b">click</code>处理器正在做的事情。它通过ID找到文本区域，然后附加一个Konva <code class="fe le lf lg lh b">Transformer</code>到它上面，添加带有手柄的框，让用户移动和调整文本区域的大小。</p><p id="3af5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们为<code class="fe le lf lg lh b">textNode</code>文本区域提供了一个<code class="fe le lf lg lh b">transform</code>处理程序，当用户拖动手柄时可以调整文本区域的大小。我们有一个双击处理程序，让用户在双击时输入文本。大部分代码都是为了让文本框尽可能地接近画布，这样它就能融入画布。不然看起来会很奇怪。我们还让用户旋转文本区域，方法是应用CSS在用户拖动手柄时旋转文本区域。</p><p id="a265" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">keydown</code>事件处理程序中，我们在用户输入时改变文本区域的大小，以确保它显示所有文本而不滚动。</p><p id="b9c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户在文本区域之外单击时，带有手柄的框会消失，让用户选择其他项目。</p><p id="62b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主页是我们把所有东西放在一起的地方。在<code class="fe le lf lg lh b">src</code>文件夹中创建一个名为<code class="fe le lf lg lh b">HomePage.js</code>的新文件，并添加:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="a027" class="lq lr it lh b gy ls lt l lu lv">import React, { useState, useRef } from "react";<br/>import ButtonGroup from "react-bootstrap/ButtonGroup";<br/>import Button from "react-bootstrap/Button";<br/>import "./HomePage.css";<br/>import { Stage, Layer } from "react-konva";<br/>import Rectangle from "./Rectangle";<br/>import Circle from "./Circle";<br/>import { addLine } from "./line";<br/>import { addTextNode } from "./textNode";<br/>import Image from "./Image";<br/>const uuidv1 = require("uuid/v1");</span><span id="33fd" class="lq lr it lh b gy nf lt l lu lv">function HomePage() {<br/>  const [rectangles, setRectangles] = useState([]);<br/>  const [circles, setCircles] = useState([]);<br/>  const [images, setImages] = useState([]);<br/>  const [selectedId, selectShape] = useState(null);<br/>  const [shapes, setShapes] = useState([]);<br/>  const [, updateState] = React.useState();<br/>  const stageEl = React.createRef();<br/>  const layerEl = React.createRef();<br/>  const fileUploadEl = React.createRef();</span><span id="2aa5" class="lq lr it lh b gy nf lt l lu lv">  const getRandomInt = max =&gt; {<br/>    return Math.floor(Math.random() * Math.floor(max));<br/>  };</span><span id="4c9a" class="lq lr it lh b gy nf lt l lu lv">  const addRectangle = () =&gt; {<br/>    const rect = {<br/>      x: getRandomInt(100),<br/>      y: getRandomInt(100),<br/>      width: 100,<br/>      height: 100,<br/>      fill: "red",<br/>      id: `rect${rectangles.length + 1}`,<br/>    };<br/>    const rects = rectangles.concat([rect]);<br/>    setRectangles(rects);<br/>    const shs = shapes.concat([`rect${rectangles.length + 1}`]);<br/>    setShapes(shs);<br/>  };</span><span id="7f62" class="lq lr it lh b gy nf lt l lu lv">  const addCircle = () =&gt; {<br/>    const circ = {<br/>      x: getRandomInt(100),<br/>      y: getRandomInt(100),<br/>      width: 100,<br/>      height: 100,<br/>      fill: "red",<br/>      id: `circ${circles.length + 1}`,<br/>    };<br/>    const circs = circles.concat([circ]);<br/>    setCircles(circs);<br/>    const shs = shapes.concat([`circ${circles.length + 1}`]);<br/>    setShapes(shs);<br/>  };</span><span id="4066" class="lq lr it lh b gy nf lt l lu lv">const drawLine = () =&gt; {<br/>    addLine(stageEl.current.getStage(), layerEl.current);<br/>  };</span><span id="1407" class="lq lr it lh b gy nf lt l lu lv">  const eraseLine = () =&gt; {<br/>    addLine(stageEl.current.getStage(), layerEl.current, "erase");<br/>  };</span><span id="b888" class="lq lr it lh b gy nf lt l lu lv">  const drawText = () =&gt; {<br/>    const id = addTextNode(stageEl.current.getStage(), layerEl.current);<br/>    const shs = shapes.concat([id]);<br/>    setShapes(shs);<br/>  };</span><span id="113b" class="lq lr it lh b gy nf lt l lu lv">  const drawImage = () =&gt; {<br/>    fileUploadEl.current.click();<br/>  };</span><span id="caae" class="lq lr it lh b gy nf lt l lu lv">  const forceUpdate = React.useCallback(() =&gt; updateState({}), []);</span><span id="a22a" class="lq lr it lh b gy nf lt l lu lv">  const fileChange = ev =&gt; {<br/>    let file = ev.target.files[0];<br/>    let reader = new FileReader();</span><span id="7ed4" class="lq lr it lh b gy nf lt l lu lv">    reader.addEventListener(<br/>      "load",<br/>      () =&gt; {<br/>        const id = uuidv1();<br/>        images.push({<br/>          content: reader.result,<br/>          id,<br/>        });<br/>        setImages(images);<br/>        fileUploadEl.current.value = null;<br/>        shapes.push(id);<br/>        setShapes(shapes);<br/>        forceUpdate();<br/>      },<br/>      false<br/>    );</span><span id="f732" class="lq lr it lh b gy nf lt l lu lv">    if (file) {<br/>      reader.readAsDataURL(file);<br/>    }<br/>  };</span><span id="d5dd" class="lq lr it lh b gy nf lt l lu lv">  const undo = () =&gt; {<br/>    const lastId = shapes[shapes.length - 1];<br/>    let index = circles.findIndex(c =&gt; c.id == lastId);<br/>    if (index != -1) {<br/>      circles.splice(index, 1);<br/>      setCircles(circles);<br/>    }</span><span id="6b3e" class="lq lr it lh b gy nf lt l lu lv">    index = rectangles.findIndex(r =&gt; r.id == lastId);<br/>    if (index != -1) {<br/>      rectangles.splice(index, 1);<br/>      setRectangles(rectangles);<br/>    }</span><span id="d90e" class="lq lr it lh b gy nf lt l lu lv">    index = images.findIndex(r =&gt; r.id == lastId);<br/>    if (index != -1) {<br/>      images.splice(index, 1);<br/>      setImages(images);<br/>    }<br/>    shapes.pop();<br/>    setShapes(shapes);<br/>    forceUpdate();<br/>  };</span><span id="8220" class="lq lr it lh b gy nf lt l lu lv">  document.addEventListener("keydown", ev =&gt; {<br/>    if (ev.code == "Delete") {<br/>      let index = circles.findIndex(c =&gt; c.id == selectedId);<br/>      if (index != -1) {<br/>        circles.splice(index, 1);<br/>        setCircles(circles);<br/>      }</span><span id="73a5" class="lq lr it lh b gy nf lt l lu lv">      index = rectangles.findIndex(r =&gt; r.id == selectedId);<br/>      if (index != -1) {<br/>        rectangles.splice(index, 1);<br/>        setRectangles(rectangles);<br/>      }</span><span id="2578" class="lq lr it lh b gy nf lt l lu lv">      index = images.findIndex(r =&gt; r.id == selectedId);<br/>      if (index != -1) {<br/>        images.splice(index, 1);<br/>        setImages(images);<br/>      }<br/>      forceUpdate();<br/>    }<br/>  });</span><span id="abf8" class="lq lr it lh b gy nf lt l lu lv">  return (<br/>    &lt;div className="home-page"&gt;<br/>      &lt;h1&gt;Whiteboard&lt;/h1&gt;<br/>      &lt;ButtonGroup&gt;<br/>        &lt;Button variant="secondary" onClick={addRectangle}&gt;<br/>          Rectangle<br/>        &lt;/Button&gt;<br/>        &lt;Button variant="secondary" onClick={addCircle}&gt;<br/>          Circle<br/>        &lt;/Button&gt;<br/>        &lt;Button variant="secondary" onClick={drawLine}&gt;<br/>          Line<br/>        &lt;/Button&gt;<br/>        &lt;Button variant="secondary" onClick={eraseLine}&gt;<br/>          Erase<br/>        &lt;/Button&gt;<br/>        &lt;Button variant="secondary" onClick={drawText}&gt;<br/>          Text<br/>        &lt;/Button&gt;<br/>        &lt;Button variant="secondary" onClick={drawImage}&gt;<br/>          Image<br/>        &lt;/Button&gt;<br/>        &lt;Button variant="secondary" onClick={undo}&gt;<br/>          Undo<br/>        &lt;/Button&gt;<br/>      &lt;/ButtonGroup&gt;<br/>      &lt;input<br/>        style={{ display: "none" }}<br/>        type="file"<br/>        ref={fileUploadEl}<br/>        onChange={fileChange}<br/>      /&gt;<br/>      &lt;Stage<br/>        width={window.innerWidth * 0.9}<br/>        height={window.innerHeight - 150}<br/>        ref={stageEl}<br/>        onMouseDown={e =&gt; {<br/>          // deselect when clicked on empty area<br/>          const clickedOnEmpty = e.target === e.target.getStage();<br/>          if (clickedOnEmpty) {<br/>            selectShape(null);<br/>          }<br/>        }}<br/>      &gt;<br/>        &lt;Layer ref={layerEl}&gt;<br/>          {rectangles.map((rect, i) =&gt; {<br/>            return (<br/>              &lt;Rectangle<br/>                key={i}<br/>                shapeProps={rect}<br/>                isSelected={rect.id === selectedId}<br/>                onSelect={() =&gt; {<br/>                  selectShape(rect.id);<br/>                }}<br/>                onChange={newAttrs =&gt; {<br/>                  const rects = rectangles.slice();<br/>                  rects[i] = newAttrs;<br/>                  setRectangles(rects);<br/>                }}<br/>              /&gt;<br/>            );<br/>          })}<br/>          {circles.map((circle, i) =&gt; {<br/>            return (<br/>              &lt;Circle<br/>                key={i}<br/>                shapeProps={circle}<br/>                isSelected={circle.id === selectedId}<br/>                onSelect={() =&gt; {<br/>                  selectShape(circle.id);<br/>                }}<br/>                onChange={newAttrs =&gt; {<br/>                  const circs = circles.slice();<br/>                  circs[i] = newAttrs;<br/>                  setCircles(circs);<br/>                }}<br/>              /&gt;<br/>            );<br/>          })}<br/>          {images.map((image, i) =&gt; {<br/>            return (<br/>              &lt;Image<br/>                key={i}<br/>                imageUrl={image.content}<br/>                isSelected={image.id === selectedId}<br/>                onSelect={() =&gt; {<br/>                  selectShape(image.id);<br/>                }}<br/>                onChange={newAttrs =&gt; {<br/>                  const imgs = images.slice();<br/>                  imgs[i] = newAttrs;<br/>                }}<br/>              /&gt;<br/>            );<br/>          })}<br/>        &lt;/Layer&gt;<br/>      &lt;/Stage&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="9e28" class="lq lr it lh b gy nf lt l lu lv">export default HomePage;</span></pre><p id="6515" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们添加按钮的地方，当用户点击这些按钮时，按钮会添加形状。对于React Konva提供的形状，我们通过向形状的数组中添加一个对象来添加形状。然后，我们将它们映射到具有由对象指定的属性的形状。</p><p id="d5d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，要添加一个矩形，我们创建一个对象，并通过调用推送该对象将其添加到数组中。然后我们调用<code class="fe le lf lg lh b">setRectangles</code>并在渲染画布时将其映射到实际的<code class="fe le lf lg lh b">Rectangle</code>组件。我们传入了<code class="fe le lf lg lh b">onSelect</code>处理程序，这样当用户点击形状时，就可以获得所选形状的ID。<code class="fe le lf lg lh b">onChange</code>处理程序让我们设置更新现有形状的属性，然后更新形状的相应数组。</p><p id="4bc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加的每个React Konva形状都应该在<code class="fe le lf lg lh b">Layer</code>组件内部。该组件为形状提供驻留的位置。<code class="fe le lf lg lh b">Stage</code>组件为<code class="fe le lf lg lh b">Layer</code>提供了一个位置。</p><p id="dd6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">Stage</code>组件中，我们有一个<code class="fe le lf lg lh b">onMouseDown</code>处理程序，用于在单击所有形状之外时取消选择所有形状。</p><p id="e953" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单击“撤消”按钮时，将从数组中删除最后一个形状以及相应的形状数组。例如，如果undo删除一个矩形，那么它将从<code class="fe le lf lg lh b">shapes</code>数组和<code class="fe le lf lg lh b">rectangle</code>数组中删除。<code class="fe le lf lg lh b">shapes</code>数组是所有形状的id数组。</p><p id="d370" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，为了让用户在使用delete键选择形状时删除形状，我们添加了一个按键处理程序。在key-down处理函数中，当delete键事件被触发时，处理程序将通过ID在数组中找到形状并删除它。它还会将其从<code class="fe le lf lg lh b">shapes</code>数组中删除。</p><p id="db25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们定义了<code class="fe le lf lg lh b">forceUpdate</code>函数，这样即使在React之外进行DOM操作，画布也会更新。<code class="fe le lf lg lh b">keydown</code>处理程序是用<code class="fe le lf lg lh b">document.addEventListener</code>添加的，不是React代码，所以我们需要调用<code class="fe le lf lg lh b">forceUpdate</code>根据新的状态重新渲染。</p><p id="6de5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，作为结束，我们添加顶部的酒吧。在<code class="fe le lf lg lh b">src</code>文件夹中创建一个名为<code class="fe le lf lg lh b">TopBar.js</code>的文件，并添加:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="da15" class="lq lr it lh b gy ls lt l lu lv">import React from "react";<br/>import Navbar from "react-bootstrap/Navbar";<br/>import Nav from "react-bootstrap/Nav";<br/>import NavDropdown from "react-bootstrap/NavDropdown";<br/>import "./TopBar.css";<br/>import { withRouter } from "react-router-dom";</span><span id="3286" class="lq lr it lh b gy nf lt l lu lv">function TopBar({ location }) {<br/>  const { pathname } = location;</span><span id="90d5" class="lq lr it lh b gy nf lt l lu lv">  return (<br/>    &lt;Navbar bg="primary" expand="lg" variant="dark"&gt;<br/>      &lt;Navbar.Brand href="#home"&gt;React Canvas App&lt;/Navbar.Brand&gt;<br/>      &lt;Navbar.Toggle aria-controls="basic-navbar-nav" /&gt;<br/>      &lt;Navbar.Collapse id="basic-navbar-nav"&gt;<br/>        &lt;Nav className="mr-auto"&gt;<br/>          &lt;Nav.Link href="/" active={pathname == "/"}&gt;<br/>            Home<br/>          &lt;/Nav.Link&gt;<br/>        &lt;/Nav&gt;<br/>      &lt;/Navbar.Collapse&gt;<br/>    &lt;/Navbar&gt;<br/>  );<br/>}</span><span id="898a" class="lq lr it lh b gy nf lt l lu lv">export default withRouter(TopBar);</span></pre><p id="cd56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Navbar</code>组件由React Boostrap提供。</p><p id="b665" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有的工作完成后，我们得到一个可以在上面画画的白板。</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/8b2d880098725e1e4ab547e09fadc305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olGeWQXMj-a2LY-xH5If3w.png"/></div></div></figure></div></div>    
</body>
</html>