<html>
<head>
<title>How To Write Bash One-Liners for Cloning and Managing GitHub and GitLab Repositories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写Bash一行程序来克隆和管理GitHub和GitLab库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-bash-one-liners-for-cloning-and-managing-github-and-gitlab-repositories-a17b8eeb26c0?source=collection_archive---------12-----------------------#2019-08-19">https://betterprogramming.pub/how-to-write-bash-one-liners-for-cloning-and-managing-github-and-gitlab-repositories-a17b8eeb26c0?source=collection_archive---------12-----------------------#2019-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="822d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Bash中使用xargs和awk来自动管理远程托管的存储库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2a4e084de7b4725a6820ab7bbe127abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ene6pCN-LGJ7U3u_FdHk1Q.png"/></div></div></figure><p id="df4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很少有什么比一行优雅的Bash<a class="ae lq" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank">Bash</a>自动化几个小时的繁琐工作更让我满意的了。</p><p id="c8d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为最近用Bash脚本自动重新创建我的笔记本电脑的探索的一部分(帖子即将发布！)，我想找到一种方法，轻松地将GitHub托管的存储库克隆到一台新机器上。</p><p id="461d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">经过一番挖掘，我写了一行这样的代码。然后，本着不把所有鸡蛋放在同一个篮子里的精神，我编写了另一个一行程序来自动创建和推送GitLab托管的备份。</p><p id="0b8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们来了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a502" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">一个Bash一行程序来克隆你所有的GitHub库</h1><p id="5548" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">警告:您需要一份想要克隆的GitHub库的列表。这样做的好处是，它让您可以完全控制在您的机器上选择您想要的存储库，而不是全情投入。</p><p id="73a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用HTTPS和你的<a class="ae lq" href="https://help.github.com/en/articles/caching-your-github-password-in-git" rel="noopener ugc nofollow" target="_blank"> 15分钟缓存凭证</a>或者我更喜欢的方法<a class="ae lq" href="https://help.github.com/en/articles/connecting-to-github-with-ssh" rel="noopener ugc nofollow" target="_blank">通过SSH </a>连接到GitHub，你可以很容易地克隆GitHub库，而不需要每次都输入密码。</p><p id="9691" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简单起见，我假设我们使用后者，并且我们的SSH密钥已经设置好了。</p><p id="efbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">给定文件<code class="fe mv mw mx my b">gh-repos.txt</code>中的GitHub URLs列表，如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="9c9b" class="nd lz it my b gy ne nf l ng nh">git@github.com:username/first-repository.git<br/>git@github.com:username/second-repository.git<br/>git@github.com:username/third-repository.git</span></pre><p id="2743" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们运行:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="3be0" class="nd lz it my b gy ne nf l ng nh">xargs -n1 git clone &lt; gh-repos.txt</span></pre><p id="9629" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这会将列表中的所有存储库克隆到当前文件夹中。如果您替换适当的URL，同样的一行程序也适用于GitLab存储库。</p><h2 id="66c6" class="nd lz it bd ma ni nj dn me nk nl dp mi ld nm nn mk lh no np mm ll nq nr mo ns bi translated">这是怎么回事？</h2><p id="2304" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这个一行程序有两个部分:右边是违反直觉的输入，左边是让事情发生的部分。</p><p id="8217" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以让这些部分的顺序更直观(也许？)通过编写如下相同的命令:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="aaeb" class="nd lz it my b gy ne nf l ng nh">&lt;gh-repos.txt xargs -n1 git clone</span></pre><p id="c2a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了对我们输入的每一行运行命令，<code class="fe mv mw mx my b">gh-repos.txt</code>，我们使用<code class="fe mv mw mx my b">xargs -n1</code>。工具<code class="fe mv mw mx my b">xargs</code>从输入中读取条目并执行它找到的任何命令(如果它没有找到任何命令，它将<code class="fe mv mw mx my b">echo</code>)。</p><p id="cedb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，它假定项目由空格分隔；新行也可以让我们的列表更容易阅读。</p><p id="2733" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">标志<code class="fe mv mw mx my b">-n1</code>告诉<code class="fe mv mw mx my b">xargs</code>使用<code class="fe mv mw mx my b">1</code>参数，或者在我们的例子中，每个命令一行。我们用<code class="fe mv mw mx my b">git clone</code>构建命令，然后<code class="fe mv mw mx my b">xargs</code>为每一行执行该命令。哒哒。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ff33" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Bash一行程序，用于在GitLab上创建和推送许多存储库</h1><p id="0363" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">与GitHub不同，GitLab让我们可以做这件漂亮的事情，我们不必先使用网站来创建一个新的存储库。我们可以从终端创建一个新的GitLab存储库。</p><p id="88f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">新创建的存储库默认设置为私有，所以如果我们想在GitLab上公开它，我们必须稍后手动完成。</p><p id="4bde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GitLab文档告诉我们使用<code class="fe mv mw mx my b">git push --set-upstream</code>创建一个新项目，但是我发现这对于使用GitLab作为备份并不方便。</p><p id="79f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我将来使用我的存储库时，我希望运行一个命令，将GitHub <em class="nt">和</em> GitLab都推给我，而不需要我做额外的工作。</p><p id="3b8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了让这个Bash一行程序工作，我们还需要一个GitLab的存储库URL列表(还不存在)。我们可以通过复制我们的GitHub库列表，用<a class="ae lq" href="https://www.vim.org/" rel="noopener ugc nofollow" target="_blank"> Vim </a>打开它，并进行<a class="ae lq" href="https://vim.fandom.com/wiki/Search_and_replace" rel="noopener ugc nofollow" target="_blank">搜索和替换</a>来轻松做到这一点:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="ebc9" class="nd lz it my b gy ne nf l ng nh">cp gh-repos.txt gl-repos.txt<br/>vim gl-repos.txt<br/>:%s/\&lt;github\&gt;/gitlab/g<br/>:wq</span></pre><p id="d03f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这产生了<code class="fe mv mw mx my b">gl-repos.txt</code>，看起来像:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="ed95" class="nd lz it my b gy ne nf l ng nh">git@gitlab.com:username/first-repository.git<br/>git@gitlab.com:username/second-repository.git<br/>git@gitlab.com:username/third-repository.git</span></pre><p id="0401" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在GitLab上创建这些存储库，添加URL作为远程，并通过运行以下命令将我们的代码推送到新的存储库:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="b252" class="nd lz it my b gy ne nf l ng nh">awk -F'\/|(\.git)' '{system("cd ~/FULL/PATH/" $2 " &amp;&amp; git remote set-url origin --add " $0 " &amp;&amp; git push")}' gl-repos.txt</span></pre><p id="8458" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等一下，我会解释的；现在，注意<code class="fe mv mw mx my b">~/FULL/PATH/</code>应该是包含GitHub库的目录的完整路径。</p><p id="f8cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们必须注意几个假设:</p><ol class=""><li id="fd1d" class="nu nv it kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">本地机器上包含存储库的目录的名称与URL中存储库的名称相同(如果它是用上面的一行代码克隆的，就会出现这种情况)。</li><li id="a5da" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">每个存储库当前都被检出到您想要推送的分支，即。<code class="fe mv mw mx my b">master</code>。</li></ol><p id="755b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以扩展这个一行程序来处理这些假设，但是作者认为，在这种情况下，我们真的应该编写一个Bash脚本。</p><h2 id="4b9b" class="nd lz it bd ma ni nj dn me nk nl dp mi ld nm nn mk lh no np mm ll nq nr mo ns bi translated">这是怎么回事？</h2><p id="254f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们的Bash一行程序使用<code class="fe mv mw mx my b">gl-repos.txt</code>文件中的每一行(或URL)作为输入。</p><p id="da6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe mv mw mx my b">awk</code>，它分离出包含我们本地机器上的存储库的目录名，并使用这些信息来构建我们更大的命令。</p><p id="2ebe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们对<code class="fe mv mw mx my b">awk</code>的输出进行<code class="fe mv mw mx my b">print</code>，我们会看到:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="7d72" class="nd lz it my b gy ne nf l ng nh">cd ~/FULL/PATH/first-repository &amp;&amp; git remote set-url origin --add git@gitlab.com:username/first-repository.git &amp;&amp; git push<br/>cd ~/FULL/PATH/second-repository &amp;&amp; git remote set-url origin --add git@gitlab.com:username/second-repository.git &amp;&amp; git push<br/>cd ~/FULL/PATH/third-repository &amp;&amp; git remote set-url origin --add git@gitlab.com:username/third-repository.git &amp;&amp; git push</span></pre><p id="dbb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何构建这个命令。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="10da" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">用<code class="fe mv mw mx my b">awk</code>拆分字符串</h1><p id="a207" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">工具<code class="fe mv mw mx my b">awk</code>可以根据<a class="ae lq" href="https://www.gnu.org/software/gawk/manual/html_node/Command-Line-Field-Separator.html" rel="noopener ugc nofollow" target="_blank">字段分隔符</a>拆分输入。默认的分隔符是一个空白字符，但是我们可以通过传递<code class="fe mv mw mx my b">-F</code>标志来改变它。</p><p id="8814" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了单个字符，我们还可以使用一个<a class="ae lq" href="https://www.gnu.org/software/gawk/manual/html_node/Regexp-Field-Splitting.html#Regexp-Field-Splitting" rel="noopener ugc nofollow" target="_blank">正则表达式字段分隔符</a>。</p><p id="7a3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们的存储库URL有一个固定的格式，我们可以通过查询斜杠字符<code class="fe mv mw mx my b">/</code>和URL末尾<code class="fe mv mw mx my b">.git</code>之间的子字符串来获取存储库名称。</p><p id="a746" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实现这一点的方法之一是使用我们的正则表达式<code class="fe mv mw mx my b">\/|(\.git)</code>:</p><ul class=""><li id="5ebe" class="nu nv it kw b kx ky la lb ld nw lh nx ll ny lp oi oa ob oc bi translated"><code class="fe mv mw mx my b">\/</code>是转义的<code class="fe mv mw mx my b">/</code>字符。</li><li id="5eca" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><code class="fe mv mw mx my b">|</code>表示“或”，告诉awk匹配任一表达式。</li><li id="e256" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><code class="fe mv mw mx my b">(\.git)</code>是我们的URL末尾匹配“”的捕获组。git”，带有转义的<code class="fe mv mw mx my b">.</code>字符。这有点像作弊，因为”。git”并没有严格地分割任何东西(另一边什么也没有)，但它是我们去掉这一部分的一个简单方法。</li></ul><p id="ecc0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们告诉了<code class="fe mv mw mx my b">awk</code>在哪里拆分，我们就可以用<a class="ae lq" href="https://www.gnu.org/software/gawk/manual/html_node/Fields.html#index-_0024-_0028dollar-sign_0029_002c-_0024-field-operator" rel="noopener ugc nofollow" target="_blank">字段操作符</a>获取正确的子串。</p><p id="1440" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用一个<code class="fe mv mw mx my b">$</code>字符引用我们的字段，然后用字段的列号。在我们的例子中，我们需要第二个字段，<code class="fe mv mw mx my b">$2</code>。</p><p id="e390" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是所有子字符串的样子:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="c477" class="nd lz it my b gy ne nf l ng nh">1: git@gitlab.com:username<br/>2: first-repository</span></pre><p id="4274" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使用整个字符串，或者在我们的例子中，整个URL，我们使用字段操作符<code class="fe mv mw mx my b">$0</code>。</p><p id="a295" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要编写命令，我们只需用字段操作符代替存储库名称和URL。在我们建造它的时候用<code class="fe mv mw mx my b">print</code>运行它可以帮助我们确保所有的空间都是正确的。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="134d" class="nd lz it my b gy ne nf l ng nh">awk -F'\/|(\.git)' '{print "cd ~/FULL/PATH/" $2 " &amp;&amp; git remote set-url origin --add " $0 " &amp;&amp; git push"}' gl-repos.txt</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="bb11" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">运行命令</h1><p id="3440" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们在<code class="fe mv mw mx my b">system()</code>的括号内构建我们的命令。通过将此作为<code class="fe mv mw mx my b">awk</code>的输出，每个命令将在构建和输出后立即运行。</p><p id="18ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mv mw mx my b">system()</code>函数创建一个<a class="ae lq" href="https://en.wikipedia.org/wiki/Child_process" rel="noopener ugc nofollow" target="_blank">子进程</a>，它执行我们的命令，然后在命令完成后返回。简单地说，这让我们可以在每个存储库上一个接一个地执行Git命令，而不会中断我们的主进程，在主进程中<code class="fe mv mw mx my b">awk</code>正在处理我们的输入文件。</p><p id="d67a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们最后的命令。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="8adc" class="nd lz it my b gy ne nf l ng nh">awk -F'\/|(\.git)' '{system("cd ~/FULL/PATH/" $2 " &amp;&amp; git remote set-url origin --add " $0 " &amp;&amp; git push")}' gl-repos.txt</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f522" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用我们的备份</h1><p id="f37e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">通过添加GitLab URLs作为远程，我们简化了推送至两个外部托管存储库的过程。如果我们在我们的一个存储库目录中运行<code class="fe mv mw mx my b">git remote -v</code>，我们会看到:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="41ad" class="nd lz it my b gy ne nf l ng nh">origin git@github.com:username/first-repository.git (fetch)<br/>origin git@github.com:username/first-repository.git (push)<br/>origin git@gitlab.com:username/first-repository.git (push)</span></pre><p id="46a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，只需不带参数地运行<code class="fe mv mw mx my b">git push</code>就会将当前分支推送到两个远程存储库。</p><p id="8d39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还应该注意到，<code class="fe mv mw mx my b">git pull</code>通常只会尝试从您最初克隆的远程库(在我们上面的例子中标有<code class="fe mv mw mx my b">(fetch)</code>的URL)中提取。</p><p id="7627" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同时从多个Git仓库拉取数据是可能的，但是很复杂，超出了本文的范围。</p><p id="173b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你好奇的话，这里有一个关于推拉多个遥控器的<a class="ae lq" href="https://astrofloyd.wordpress.com/2015/05/05/git-pushing-to-and-pulling-from-multiple-remote-locations-remote-url-and-pushurl/" rel="noopener ugc nofollow" target="_blank">解释</a>来帮助你开始。关于遥控器的<a class="ae lq" href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes" rel="noopener ugc nofollow" target="_blank"> Git文档可能也有帮助。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="824b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">详细阐述Bash一行程序的简洁性</h1><p id="d948" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">理解Bash一行程序后，它可能是有趣且方便的捷径。至少，意识到像<code class="fe mv mw mx my b">xargs</code>和<code class="fe mv mw mx my b">awk</code>这样的工具可以帮助自动化和减轻我们工作中的许多乏味。</p><p id="99b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，也有一些缺点。</p><p id="828b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就易于理解、可维护和易于使用的工具而言，Bash一行程序很糟糕。它们通常比使用<code class="fe mv mw mx my b">if</code>或<code class="fe mv mw mx my b">while</code>循环的Bash脚本更复杂，阅读起来也更复杂。</p><p id="4e9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很可能，当我们写它们的时候，我们会在某个地方漏掉一个单引号或右括号；正如我希望这篇文章所展示的那样，他们也需要相当多的解释。</p><p id="3016" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，为什么要使用它们呢？</p><p id="12e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，一步一步地阅读烘焙蛋糕的食谱。你了解方法和成分，并收集你的用品。</p><p id="4828" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，当你思考这个问题的时候，你开始意识到，如果你把所有的原料按照正确的顺序放入烤箱，一个蛋糕就会立刻变成现实。你试一下，它就起作用了！</p><p id="8805" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那会很令人满意，不是吗？</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6801" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">按外观顺序排列的资源</h1><ul class=""><li id="e090" class="nu nv it kw b kx mq la mr ld oj lh ok ll ol lp oi oa ob oc bi translated"><a class="ae lq" href="https://help.github.com/en/articles/caching-your-github-password-in-git" rel="noopener ugc nofollow" target="_blank">https://help . github . com/en/articles/caching-your-github-password-in-git</a></li><li id="ef62" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><a class="ae lq" href="https://help.github.com/en/articles/connecting-to-github-with-ssh" rel="noopener ugc nofollow" target="_blank">https://help . github . com/en/articles/connecting-to-github-with-ssh</a></li><li id="8557" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><a class="ae lq" href="https://gitlab.com/help/gitlab-basics/create-project#push-to-create-a-new-project" rel="noopener ugc nofollow" target="_blank">https://gitlab . com/help/gitlab-basics/create-project # push-to-create-a-new-project</a></li><li id="33b4" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><a class="ae lq" href="https://vim.fandom.com/wiki/Search_and_replace" rel="noopener ugc nofollow" target="_blank">https://vim.fandom.com/wiki/Search_and_replace</a></li><li id="3e07" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><a class="ae lq" href="https://www.gnu.org/software/gawk/manual/html_node/Command-Line-Field-Separator.html" rel="noopener ugc nofollow" target="_blank">https://www . GNU . org/software/gawk/manual/html _ node/Command-Line-Field-separator . html</a></li><li id="3119" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><a class="ae lq" href="https://www.gnu.org/software/gawk/manual/html_node/Regexp-Field-Splitting.html#Regexp-Field-Splitting" rel="noopener ugc nofollow" target="_blank">https://www . GNU . org/software/gawk/manual/html _ node/Regexp-Field-Splitting . html # Regexp-Field-Splitting</a></li><li id="e63f" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><a class="ae lq" href="https://www.gnu.org/software/gawk/manual/html_node/Fields.html#index-_0024-_0028dollar-sign_0029_002c-_0024-field-operator" rel="noopener ugc nofollow" target="_blank">https://www . GNU . org/software/gawk/manual/html _ node/fields . html # index-_ 0024-_ 0028 dollar-sign _ 0029 _ 002 c-_ 0024-field-operator</a></li><li id="c6d1" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><a class="ae lq" href="https://en.wikipedia.org/wiki/Child_process" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Child_process</a></li><li id="56af" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><a class="ae lq" href="https://astrofloyd.wordpress.com/2015/05/05/git-pushing-to-and-pulling-from-multiple-remote-locations-remote-url-and-pushurl/" rel="noopener ugc nofollow" target="_blank">https://astro Floyd . WordPress . com/2015/05/05/git-pushing-to-and-pull-from-multiple-remote-locations-remote-URL-and-push URL/</a></li><li id="01df" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated"><a class="ae lq" href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes" rel="noopener ugc nofollow" target="_blank">https://Git-SCM . com/book/en/v2/Git-Basics-Working-with-Remotes</a></li></ul></div></div>    
</body>
</html>