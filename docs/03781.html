<html>
<head>
<title>How to Improve the Validation in Your SwiftUI App Using ValidatedPropertyKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用ValidatedPropertyKit改进SwiftUI应用程序中的验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/validation-in-swiftui-using-validatedpropertykit-3c85f27b123a?source=collection_archive---------4-----------------------#2020-03-04">https://betterprogramming.pub/validation-in-swiftui-using-validatedpropertykit-3c85f27b123a?source=collection_archive---------4-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="925c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Swift 5.1的属性包装器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c76773f4ac2cc8d2b65eefc496002110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUppC4iWteHpSHKrxWkkMg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@jesuskiteque?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jesus Kiteque </a>拍摄的照片。</p></figure><p id="1901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/SvenTiigi/ValidatedPropertyKit" rel="noopener ugc nofollow" target="_blank"> ValidatedPropertyKit </a>是一个在应用中执行验证的Swift框架。它使用Swift 5.1中引入的属性包装特性，用所需的验证属性来修饰属性。在本文中，我们将把ValidatedPropertyKit集成到我们现有的SwiftUI应用程序中，并在界面上显示破坏的规则。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1ae5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">集成有效属性工具包</strong></h1><p id="dcec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第一步是在SwiftUI应用程序中集成ValidatedPropertyKit框架。请记住，ValidatedPropertyKit是一个独立的库，不依赖于SwiftUI的框架。</p><p id="5c2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">集成ValidatedPropertyKit的最简单方法是使用Swift Package Manager。在Xcode中，打开文件菜单，选择Swift包，<strong class="lb iu"> </strong>，然后添加包依赖。这将打开一个对话框，您可以在其中输入依赖项的Github URL。如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/d4066ea295737fc356a5a38a9a8a8b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0a5khC2nl-wlCOeX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过Xcode中的Swift Package Manager添加依赖关系。</p></figure><p id="fd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击“下一步”按钮，完成整个过程。一旦对话框关闭了您的依赖项，ValidatedPropertyKit将被成功添加到项目中。接下来，我们将使用属性包装来修饰视图模型，这将支持验证。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5b76" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">向RegistrationViewModel添加验证</strong></h1><p id="21fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，ValidatedPropertyKit围绕属性包装器展开。为了执行验证，我们必须在视图模型中修饰我们的属性。如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用属性包装修饰的RegistrationViewModel。</p></figure><p id="9417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们已经将属性声明为可选属性，并将其初始化为空字符串，因为ValidatedPropertyKit将只验证非空值。</p><p id="fd2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现从导入ValidatedPropertyKit开始，然后在将参与验证的属性上装饰属性包装。在ValidatedPropertyKit框架中有许多不同的属性包装器可用。下面的列表显示了其中的一些:</p><ul class=""><li id="2a1b" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated"><code class="fe nl nm nn no b"><strong class="lb iu">.</strong>nonEmpty</code> —值不能为null或空。</li><li id="6f38" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><code class="fe nl nm nn no b"><strong class="lb iu">.</strong>isEmail</code> —值必须为电子邮件格式。</li><li id="b3a1" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><code class="fe nl nm nn no b">.range(8…)</code> —值必须满足范围。</li><li id="735d" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><code class="fe nl nm nn no b">.greaterOrEqual(1)</code> <strong class="lb iu"> </strong> —值必须满足条件。</li></ul><p id="887d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以为默认的ValidatedPropertyKit中没有涵盖的情况创建自己的自定义验证包装。</p><p id="1417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是实现validate函数，它将负责评估属性。实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">验证RegistrationViewModel的功能。</p></figure><p id="ddb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在validate函数中，我们创建了一个<code class="fe nl nm nn no b">rules</code>数组，其中包含属性的名称以及与该属性相关的验证错误。</p><p id="fd27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们遍历规则。如果我们发现任何与该属性相关的失败原因，我们会将它作为一个破规则添加到<code class="fe nl nm nn no b">brokenRules</code>数组中。<code class="fe nl nm nn no b">brokenRules</code>还标记了<code class="fe nl nm nn no b">@Published</code> <strong class="lb iu"> </strong>属性包装器，这意味着它一更新就会发布一个事件。</p><p id="5ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是在用户界面上显示被破坏的规则。这与之前完全相同:我们将在registrationVM上调用validate函数，然后使用BrokenRulesView来显示错误。实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">已将BrokenRulesView添加到ContentView。</p></figure><p id="899d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你们注意的话，会注意到我们在将值绑定到TextField视图时使用了一个绑定函数。原因是TextField绑定到<code class="fe nl nm nn no b">Binding&lt;String&gt;</code>而不是<code class="fe nl nm nn no b">Binding&lt;String?&gt;</code>。绑定的扩展允许我们打开可选的，然后可以用来绑定到用户界面上的视图。绑定函数的实现可以下载源代码。</p><p id="0285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c1d5010b960caba2ab7dfb58ca9bb59c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*yCtR2BCvD80YPFdT"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ValidatedPropertyKit显示错误。</p></figure><p id="dd53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，验证被触发，默认的错误消息显示在屏幕上。这在某些情况下是可行的，但是如果我们可以自定义错误消息，那就更好了。在下一节中，您将学习如何编写可以提供自定义错误信息的自定义验证规则。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4a2d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">自定义验证错误</strong></h1><p id="5daa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了自定义或添加新的验证规则，您需要扩展ValidatedPropertyKit提供的验证结构。向现有项目添加一个名为<code class="fe nl nm nn no b">Validation+Extension.swift</code>的新文件，并添加一个名为<code class="fe nl nm nn no b">required</code>的新静态属性。实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe nl nm nn no b">required</code>验证属性的实现。</p></figure><p id="69b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">required</code>属性是我们的自定义属性，它将对字符串值执行验证。如果该值为空，则错误消息将触发失败关闭。否则，将触发成功关闭。</p><p id="41fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，更新您的RegistrationViewModel并使用新的<code class="fe nl nm nn no b">required</code>验证规则。如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用必需的验证规则注册ViewModel。</p></figure><p id="5036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次运行您的应用程序，点击注册按钮，无需填写表格。结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/37669729e0e90c44fe63af0b9b1b3c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/0*qvkGme-BRQww_65Q"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义验证消息。</p></figure><p id="1fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以更进一步，在属性包装器中提供错误消息。为了实现这一点，我们将把定制的必需验证器从属性更新为函数。实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义必需的验证程序</p></figure><p id="ba77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以更新您的RegistrationViewModel以利用新的<code class="fe nl nm nn no b">required</code>函数。如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将必需的验证器更新为函数。</p></figure><p id="446e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/158e6bbab5739fffd1e6a48b9acbb584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/0*OEpl6qzBHFBsuSUe"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用自定义验证程序的错误消息。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1175" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="825e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，您学习了如何使用ValidatedPropertyKit来验证您的视图模型属性。ValidatedPropertyKit是一个令人惊叹的框架，它利用Swift 5.1的属性包装器的力量，允许开发人员向他们的应用程序添加验证。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c869" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ol class=""><li id="5cbd" class="nc nd it lb b lc mu lf mv li nx lm ny lq nz lu oa ni nj nk bi translated"><a class="ae ky" href="https://github.com/SvenTiigi/ValidatedPropertyKit" rel="noopener ugc nofollow" target="_blank">在GitHub上验证了property kit</a></li><li id="d043" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu oa ni nj nk bi translated"><a class="ae ky" href="https://github.com/nsscreencast/427-validation-property-wrappers" rel="noopener ugc nofollow" target="_blank">NSScreencast validated property kit演示项目</a></li><li id="6106" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu oa ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/57021722/swiftui-optional-textfield" rel="noopener ugc nofollow" target="_blank">栈溢出上绑定函数的实现</a></li></ol></div></div>    
</body>
</html>