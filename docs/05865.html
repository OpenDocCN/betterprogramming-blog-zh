<html>
<head>
<title>Continuous Integration With GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与GitHub动作的持续集成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/continuous-integration-with-github-actions-fccc5a339b75?source=collection_archive---------9-----------------------#2020-08-12">https://betterprogramming.pub/continuous-integration-with-github-actions-fccc5a339b75?source=collection_archive---------9-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5768" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实现三个不同的工作流来测试、修改版本和发布新版本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66401a3519771083cbe64309f0d3483b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZ_jv-xjX_FfJR5fQH_6UQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片鸣谢:<a class="ae ky" href="https://github.blog/2019-10-03-github-actions-adds-policy-controls-for-organization-and-repository-owners/" rel="noopener ugc nofollow" target="_blank"> GitHub博客2019年10月3日</a></p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="41ee" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="422e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果您有一个GitHub存储库，您可能会看到一个名为Actions:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/5a57b293de394baa28a810bb9771e854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j39t4W3WtvyKYzCou3YgcQ.png"/></div></div></figure><p id="a8f5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这个选项卡允许您将一个<a class="ae ky" href="https://docs.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow" rel="noopener ugc nofollow" target="_blank">工作流</a>添加到您的存储库中，也就是说，一个在某些事件上运行的自动化过程，以在GitHub上构建、测试、打包、发布或部署任何项目。为了帮助你做到这一点，GitHub引入了所谓的<a class="ae ky" href="https://docs.github.com/en/actions/getting-started-with-github-actions/about-github-actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>。这些是存储在GitHub存储库中的任务或工具，它们执行一个动作。例如，<a class="ae ky" href="https://github.com/actions" rel="noopener ugc nofollow" target="_blank"> actions </a> / <a class="ae ky" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank"> checkout </a>将为您执行一个git checkout命令。在<a class="ae ky" href="https://github.com/marketplace" rel="noopener ugc nofollow" target="_blank"> GitHub Marketplace </a>中有很多动作。</p><p id="19ca" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在本教程中，我将解释我所采取的自动化开源框架开发生命周期的过程。尽管工作流中使用的一些操作可能与这个库的平台iOS相关，但我们将重点关注一般概念，以帮助您理解关键思想。</p><p id="40a1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在接下来的部分中，我们将致力于三个不同的工作流程:</p><ul class=""><li id="31cb" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">对包进行单元测试，并报告代码覆盖率</li><li id="29b9" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">删除版本并创建标签</li><li id="a817" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">发布新版本并部署/分发它</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f641" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">单元测试和代码覆盖率</h1><h2 id="33b8" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">工作流程要点</h2><p id="b94f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">首先，转到存储库中的标签操作，您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/4ba01c947eb58ba2abdea713addd13b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amEPfdR7RI_nn63B2Qd_Mg.png"/></div></div></figure><p id="30f1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">GitHub会推荐一些模板给你使用。根据存储库的主要语言，建议可能会有所不同。如果你看到任何符合你的目的，继续点击它添加它。就我而言，我将点击“自己设置工作流”这产生了一些样板文件。让我们来看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="46c1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">让我们解释一下这里发生了什么:</p><ol class=""><li id="b73a" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt od ng nh ni bi translated">工作流标有名称。一旦我们设置了一对，这是很有用的，因为它将帮助我们识别哪个正在运行</li><li id="7abd" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt od ng nh ni bi translated">工作流由事件触发。这些事件可能是“推至主控”、“拉”请求、新标签、新版本的发布等等。参见<a class="ae ky" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">所有支持的事件</a>。</li><li id="d5b7" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt od ng nh ni bi translated">工作流由作业组成。这些是触发工作流后将发生的操作。作业被标记(在这种情况下，我们唯一的作业被标记为<code class="fe oe of og oh b">build</code>)并定义运行的环境:Windows、macOS、Ubuntu，(参见<a class="ae ky" href="https://docs.github.com/en/actions/reference/virtual-environments-for-github-hosted-runners" rel="noopener ugc nofollow" target="_blank">所有虚拟环境</a>)。这一点很重要，因为有些操作是为在特定环境中运行而设计的。最后，工作被分解成<code class="fe oe of og oh b">steps</code>。这些步骤按顺序运行，与并行运行的作业相反，除非明确定义为按顺序运行。</li></ol><h2 id="9724" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">创建您的第一个工作流程</h2><p id="a873" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">既然我们理解了要点，让我们定义我们的第一个工作流程。我想在被合并到master并生成代码覆盖报告的分支上运行测试。因此，这个工作流将在对master的pull请求上被触发，并且需要检查分支并运行测试。幸运的是，有两个GitHub动作可以帮助我完成这个任务:actions/checkout和maxep/spm-lcov-action。这是我的工作流程的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7ae3" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我的任务<code class="fe oe of og oh b">run_tests</code>需要在<code class="fe oe of og oh b">macos-latest</code>上运行，因为在接下来的步骤中它需要<code class="fe oe of og oh b">swift</code>的命令。它将首先检查分支，运行测试，最后生成一个报告。对于这最后一步，我使用开源动作(没错，动作可以由个人开发和维护，与第三方库相同)。</p><p id="74f3" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><strong class="ma iu">注意:</strong>为了有效地应用工作流，您需要提交。工作流存储在存储库根目录下的<code class="fe oe of og oh b">./github/workflows</code>中。</p><p id="209e" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在，当我创建一个新的拉式请求时，我的工作流被触发，并生成一个报告:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/c50cbcc27593b5da869740b13c86c552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgFzxK64bldTX6Pb6wlbYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新的提取请求</p></figure><p id="17e2" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果您点击“详细信息”,将会转到“操作”选项卡:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/85c641e7b7a6235429dcc9ec4f6e89af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ETUOmb7VMbMiAaLFjrOqhQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查看工作流详细信息中的代码覆盖率</p></figure><p id="6ba8" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">厉害！现在我不需要一遍又一遍地运行我的测试，因为GitHub会替我做。让我们继续深入了解GitHub操作。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c490" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">删除版本并创建标签</h1><p id="cbbd" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这个新的工作流将在对主服务器的新提交时触发。我们将检查该分支，并使用一个新的操作来生成标记:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="255b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">注意这个作业是如何在另一个环境Ubuntu上运行的。这是github-tag-action所要求的。我们还添加了额外的参数来创建不带“v”前缀的标签(如<code class="fe oe of og oh b">v1.0.0</code>、<code class="fe oe of og oh b">v2.1.3</code>、……),默认为小突起(从<code class="fe oe of og oh b">1.1.0</code>，我们会转到<code class="fe oe of og oh b">1.2.0</code>)。和标签上下文。最后一个是检索正确的标签号所必需的。</p><p id="929f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><a class="ae ky" href="https://github.com/anothrNick/github-tag-action" rel="noopener ugc nofollow" target="_blank">github-tag-action</a><em class="ok"/>使用<a class="ae ky" href="http://Semantic Versioning 2.0.0 | Semantic Versioningsemver.org" rel="noopener ugc nofollow" target="_blank"> Semver </a>确定下一个版本。您可以通过将关键字<code class="fe oe of og oh b">#patch</code>、<code class="fe oe of og oh b">#minor</code>或<code class="fe oe of og oh b">#major</code>添加到您的提交消息中来指定您想要的提升类型。该操作将从最后一个标签开始搜索这些关键字中的一个，并将获取排名最高的关键字(<code class="fe oe of og oh b">#major</code> &gt; <code class="fe oe of og oh b">#minor</code> &gt; <code class="fe oe of og oh b">#patch</code>)。</p><p id="0797" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">此时，如果我们要合并到master中，我们会注意到触发了一个新的动作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/fe05bfca5d7b93f104306e692d1ff3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxy9QVdMa2XHyWJG8DnmaQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/91640466e0df05ff7b006299ad0a8ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Kc8faqj7NmjBMW9ZDVKbw.png"/></div></div></figure><p id="a9e4" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">您还会注意到新标签是由github-actions创建的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/3b925573ad8ee0a2d15317bf62f1dfdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*DamG0md_Fo6GRdvsm3wbIQ.png"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a43f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">发布和部署新版本</h1><h2 id="9854" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">链接工作流。秘密</h2><p id="b96a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">最后，我想从每个新创建的标签中发布一个新版本。为此，我需要将以前的工作流与新的工作流“链接”起来。</p><p id="ea8d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">乍一看，您可能认为只要定义新标签触发的新工作流就足够了:</p><pre class="kj kk kl km gt oo oh op oq aw or bi"><span id="5d21" class="no lh it oh b gy os ot l ou ov">on:<br/>  push: <br/>    tags:<br/>      - '*'</span></pre><p id="30f2" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">你不会错，但有一个问题。截至目前:</p><blockquote class="ow ox oy"><p id="7d5a" class="ly lz ok ma b mb mv ju md me mw jx mg oz mx mj mk pa my mn mo pb mz mr ms mt im bi translated">"使用<em class="it"> GITHUB_TOKEN </em>从工作流引发的事件当前不会触发其他工作流。"— <a class="ae ky" href="https://github.community/t/action-does-not-trigger-another-on-push-tag-action/17148/3" rel="noopener ugc nofollow" target="_blank"> GitHub支持社区，2019年12月</a></p></blockquote><p id="f06f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在上面的链接里有一个完整的讨论。幸运的是，有一个变通办法:我们将创建自己的个人访问令牌，并在前面的工作流中使用它来创建标签，而不是使用<code class="fe oe of og oh b">GITHUB_TOKEN</code>。</p><p id="7c74" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">怎么做呢？如果你转到你的头像所在的屏幕左上方，你会看到选项设置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/f1d141df7ca6cf51d44225f81adc3a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*r-Z8aq3NEDd5dYZCIafUqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">配置文件菜单中的设置选项</p></figure><p id="370a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">然后转到左侧面板上的开发者设置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/a670b6247b10275beac3504d0beb72f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*0k4hD0wGzXNTTSwFqpwDFA.png"/></div></figure><p id="75ac" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在那里你会发现一个选项来创建一个新的个人访问令牌<em class="ok"> : </em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/23f250acb2e898507e5fef565652e77b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08W3L4WVPFBdJ6aUUra4IQ.png"/></div></div></figure><p id="7af1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">创建后，复制生成的值。现在，您将把它作为“秘密”添加到您的存储库中。要做到这一点，你只需要去你的仓库，点击设置，并在左侧面板寻找秘密。然后，创建一个新的密码，并将其命名为PERSONAL_TOKEN:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/5fa57ea789041c8cedd22d855072c0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXMheDrv7UTA3YK6cfO2DQ.png"/></div></div></figure><p id="f3e2" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">最后，在上一个作业中，将<code class="fe oe of og oh b">GITHUB_TOKEN</code>替换为<code class="fe oe of og oh b">PERSONAL_TOKEN</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="4033" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">发布您的新闻稿</h2><p id="ed1f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">此时，我们可以为我们的工作流生成一个新的YML文件了。我的工作流程将由三个不同的工作组成。首先，我将编译一个二进制工件来附加到我的版本中。我把这份工作叫做<code class="fe oe of og oh b">create_xcframework</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3184" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">此作业的输出是将附加到作业的工件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/c14eed348c2cd8fd3376e7e25f1695d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-X1j0U_YQoen_3v3CwzUZw.png"/></div></div></figure><p id="8196" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">其次，我将运行第二个作业，它依赖于<code class="fe oe of og oh b">create_xcframework</code>来发布发布版本，并将工件上传到发布版本。为此，我们需要使用<code class="fe oe of og oh b">needs:</code>。此外，这个作业需要从runner环境下载工件，以便将它上传到发布的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8589" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">让我们复习一下步骤:</p><ol class=""><li id="fd17" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt od ng nh ni bi translated">像往常一样，我们需要检查标签来访问它的内容。我们将在第二步中用到这一步。</li><li id="1f34" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt od ng nh ni bi translated">创建并发布一个版本。主体取自位于标签中的文件。</li><li id="c895" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt od ng nh ni bi translated">将工件下载到根文件夹。</li><li id="3b19" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt od ng nh ni bi translated">重命名zip。</li><li id="079f" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt od ng nh ni bi translated">上传资产。</li></ol><p id="39d1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">作为将与其余作业并行运行的第三个也是最后一个作业，我将把标记的内容部署到<a class="ae ky" href="https://cocoapods.org/" rel="noopener ugc nofollow" target="_blank"> CocoaPods </a>，这是iOS库的一个包存储库。请注意，此作业不需要按顺序运行，因为它没有任何依赖关系:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3ac3" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在任何新标签都会触发此工作流:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/12b294bcc3f909d1b5090a6efbf87c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lu3t8ma19NAhv5isUIkRpg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">触发了创建发放活动</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/f8b8ecee7e47a328ff889785851a658d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d82hamORzLEzRJm9T07OBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新版本的资产</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d6e7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="1a07" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本教程中，我们已经介绍了三种最有可能实现自动化的常见场景。我们已经了解了工作流及其语法、操作(可以在市场上找到)，以及最终的秘密和如何链接两个工作流。</p><p id="eb99" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">GitHub Actions是在您的GitHub存储库中实现CI/CD的一个免费且易于使用的选择:</p><ul class=""><li id="896f" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">由于其他用户执行的操作，它们将您从复杂的操作中抽象出来。</li><li id="7d7a" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">作业可以顺序运行，也可以并行运行。</li><li id="1d73" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">您可以安装在虚拟主机运行程序中运行作业、运行shell命令、产生输出等所需的任何东西。</li><li id="31a7" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">不同的虚拟环境:Ubuntu，Windows，macOS等。</li></ul></div></div>    
</body>
</html>