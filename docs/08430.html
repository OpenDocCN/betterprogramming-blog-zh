<html>
<head>
<title>8 Things You Can Do With Destructuring in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用析构可以做的8件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-things-you-can-do-with-destructuring-in-javascript-3da9975fcec1?source=collection_archive---------1-----------------------#2021-04-29">https://betterprogramming.pub/8-things-you-can-do-with-destructuring-in-javascript-3da9975fcec1?source=collection_archive---------1-----------------------#2021-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d720" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索析构赋值语法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63c76e9ec347bbdbd0fd62fd88bfe981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k8XsspwNEEA7rq3G"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上用<a class="ae ky" href="https://unsplash.com/@derveit?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Veit Hammer </a>拍照</p></figure><p id="f5b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释JavaScript中的析构赋值是什么。但是首先，让我们看看什么是对象属性值速记。</p><h1 id="6b7e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">对象属性值速记</h1><p id="568a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在ES6中，如果有一个对象，它的键与作为属性传入的变量同名，那么可以使用对象属性值简写来简化代码。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9a32" class="mx lw it mt b gy my mz l na nb">const data = { item: '123' };<br/>const dummy = { data: data };</span></pre><p id="3b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样简化上面的代码:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fdc6" class="mx lw it mt b gy my mz l na nb">const data = { item: '123' };<br/>const dummy = { data };</span></pre><p id="a30b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个让我们的代码更干净的小特性！</p><h1 id="1f0e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">析构赋值语法</h1><p id="e3b1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">析构赋值语法是一个将数组和对象属性中的值解包到变量中的表达式。听起来很奇怪，其实不然！本质上，我们将一个结构(destructure)分解成单个的元素，例如，一个数组到数组项。</p><h2 id="cdc5" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">从数组中获取数据</h2><p id="f612" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们有一个包含两个元素的数组:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6f6e" class="mx lw it mt b gy my mz l na nb">const array = [1, 2];</span></pre><p id="5022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望第一个元素的值存储在名为“a”的变量中，第二个元素的值存储在名为“b”的变量中</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="88d9" class="mx lw it mt b gy my mz l na nb">const a = array[0];<br/>const b = array[1];</span></pre><p id="f18b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过析构，我们可以这样做:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5a5b" class="mx lw it mt b gy my mz l na nb">const [a, b] = array;</span></pre><p id="2a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在析构中，表达式的左边部分称为<strong class="lb iu">目标</strong>，右边部分称为<strong class="lb iu">源</strong>。</p><p id="11d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，要使析构起作用，目标和源必须具有相同的数据结构。</p><p id="8f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过析构，我们可以很容易地跳过数组中的项目。代码如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ec57" class="mx lw it mt b gy my mz l na nb">const array = [1, 2, 3];<br/>const [a, , b] = array;</span></pre><p id="2c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<strong class="lb iu"> a </strong>的值为1，而<strong class="lb iu"> b </strong>的值为3。我们可以添加任意多的逗号，但是在一行中的两个逗号之后，就不可读了。</p><p id="dc74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个包含九项的数组:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e316" class="mx lw it mt b gy my mz l na nb">const array = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span></pre><p id="3fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望将第一个元素的值存储到名为“a”的变量中，将第二个元素的值存储到名为“b”的变量中，并将数组的其余部分存储到名为“c”的变量中。</p><p id="e12e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助重置参数，我们可以轻松做到这一点。如果你不知道什么是复位参数，不要着急，读读<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/exploring-the-spread-operator-and-rest-parameter-in-javascript-8f425b4031e2">这个</a>。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8c80" class="mx lw it mt b gy my mz l na nb">const [a, b, ...c] = array;<br/>console.log(a); // 1<br/>console.log(b); // 2<br/>console.log(c); // [3, 4, 5, 6, 7, 8, 9]</span></pre><h2 id="2b34" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">交换变量值</h2><p id="7499" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们有两个变量，我们想交换它们的值。代码如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7950" class="mx lw it mt b gy my mz l na nb">let a = 1;<br/>let b = 2;<br/>const temp = a;<br/>let a = b;<br/>let b = temp;</span></pre><p id="9cd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了析构，我们不用temp变量也能轻松做到:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8560" class="mx lw it mt b gy my mz l na nb">let a = 1;<br/>let b = 2;<br/>let [b, a] = [a, b];</span></pre><p id="3107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在源和目标中创建了相同的数据结构(数组)。这是一个简单的交换技巧。</p><h2 id="040d" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">毁灭函数返回值(数组)</h2><p id="1bcd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们假设我们有一个返回两个项目的数组的函数:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a72e" class="mx lw it mt b gy my mz l na nb">const data = () =&gt; [1, 2];</span></pre><p id="ebfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望将第一个元素的值存储到名为“a”的变量中，将第二个元素的值存储到名为“b”的变量中。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d375" class="mx lw it mt b gy my mz l na nb">const value = data();<br/>const a = value[0];<br/>const b = value[1];</span></pre><p id="fd95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过析构，我们可以简化上述操作并删除value变量:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a002" class="mx lw it mt b gy my mz l na nb">const [a, b] = data();</span></pre><h2 id="bfc3" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">添加默认值</h2><p id="dcc7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们有一个数组，它有时有两个值，有时只有一个值。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d30f" class="mx lw it mt b gy my mz l na nb">const array = [1];</span></pre><p id="1417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望将第一个元素的值存储到名为“a”的变量中，将第二个元素的值存储到名为“b”的变量中。同样，当数组只有一个值时，变量“b”的值为“1”。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0222" class="mx lw it mt b gy my mz l na nb">const a = array[0];<br/>const b = array[1] || 2;</span></pre><p id="7cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旧的方法是使用逻辑运算符。如果你不知道什么是逻辑运算符，不要着急，读读<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/exploring-the-spread-operator-and-rest-parameter-in-javascript-8f425b4031e2">这个</a>。</p><p id="3248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过析构，我们可以这样做:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c251" class="mx lw it mt b gy my mz l na nb">const [a, b=2] = array;</span></pre><p id="cb45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，这仅在解包后的值为<code class="fe nn no np mt b">undefined</code>或根本不存在的情况下有效。因此，如果值是假的，例如null、false等，它将不会使用默认值。</p><h2 id="adb0" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">从对象获取数据</h2><p id="0149" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们假设我们有对象:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="eeb0" class="mx lw it mt b gy my mz l na nb">const user = { name: 'George', email: 'george.roubie@gmail.com' };</span></pre><p id="172e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要两个变量“name”和“email”以及用户对象的值。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f762" class="mx lw it mt b gy my mz l na nb">const name = user.name;<br/>const email = user.email;</span></pre><p id="efbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过析构，我们可以这样做:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="313d" class="mx lw it mt b gy my mz l na nb">const { name: name, email: email } = user;</span></pre><p id="87fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的工作非常完美，因为源和目标具有相同的数据结构。但是我们可以使用对象属性值简写来以一种更简单的方式来写它。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="dec0" class="mx lw it mt b gy my mz l na nb">const { name, email } = user;</span></pre><p id="fdd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们希望变量具有不同于属性的名称时，扩展方法很有帮助，例如，“用户名”、“用户电子邮件”:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="54a4" class="mx lw it mt b gy my mz l na nb">const { name: userName, email: userEmail } = user;</span></pre><h2 id="8dad" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">用rest参数从对象获取数据</h2><p id="eb1a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们假设你有这个对象:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2120" class="mx lw it mt b gy my mz l na nb">const user = { <br/>  name: 'George',<br/>  role: 'SA',<br/>  killingZombies: true, <br/>  dancing: true<br/>};</span></pre><p id="7868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个包含用户名的变量“name ”,一个包含用户角色的变量“role ”,以及一个包含所有用户爱好的对象的变量“favorites”。</p><p id="b5e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用析构和rest参数，我们可以这样做:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="698b" class="mx lw it mt b gy my mz l na nb">const { name, role, ...hobbies } = user;</span></pre><h2 id="60e6" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">破坏函数返回值(对象)</h2><p id="89e0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们有一个返回对象的函数:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5ffb" class="mx lw it mt b gy my mz l na nb">const data = () =&gt; ({ name: 'George', role: 'SA' });</span></pre><p id="1744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个包含用户名的变量“name”和一个包含用户角色的变量“role”。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d2c3" class="mx lw it mt b gy my mz l na nb">const value = data();<br/>const name = value.name;<br/>const role = value.role;</span></pre><p id="610d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过析构，我们可以简化上述操作并删除value变量:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2f53" class="mx lw it mt b gy my mz l na nb">const { name, role } = data();</span></pre><h2 id="37c0" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">破坏功能参数</h2><p id="aab4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们假设我们有这个函数:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="da5b" class="mx lw it mt b gy my mz l na nb">function (currentUser) {<br/>  const name = currentUser.name;<br/>  const email = currentUser.email;<br/>  const roles = currentUser.roles;<br/>  console.log('Name', name);<br/>  console.log('Email', email);<br/>  console.log('Roles', roles);<br/>}</span></pre><p id="cdb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过析构函数参数来优化以上内容:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4a2e" class="mx lw it mt b gy my mz l na nb">function ({ name, email, roles }) {<br/>  console.log('Name', name);<br/>  console.log('Email', email);<br/>  console.log('Roles', roles);<br/>}</span></pre><p id="38f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在参数部分创建了所有变量，现在代码可读性更好了。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="9298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，JavaScript中的析构赋值语法非常强大，可以优化/简化我们的代码。</p></div></div>    
</body>
</html>