<html>
<head>
<title>Do Your Vue Components Communicate Correctly?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的Vue组件是否能正确通信？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/do-your-vue-components-communicate-correctly-9239c30cc495?source=collection_archive---------5-----------------------#2020-03-13">https://betterprogramming.pub/do-your-vue-components-communicate-correctly-9239c30cc495?source=collection_archive---------5-----------------------#2020-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="174c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">七个图案，挑一个合适的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c06270c3b3f8b834f3bd359b0e66647a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HHQL8mw2WfRq8Ldd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hannynaibaho?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">刘汉宁·内巴霍</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="583f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着应用程序的成熟，组件之间的通信会越来越多，因此选择正确的通信模式至关重要。</p><p id="7b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择正确的通信模式不仅简化了调试，而且有助于快速的特性开发，因为模式是重复的，代码库是可预测的。</p><p id="82a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍在组件之间传递信息时可以添加的七种通信模式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bbda" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">道具向下，事件向上—父级到子级</h1><p id="dd9c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">支持下降-事件上升当然应该在列表的顶部，因为它是最常见的模式。</p><p id="fdea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">父级和子级之间的单向数据流是您的团队成员对数据如何在您的应用程序中流动达成共识的基础。</p><p id="5478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，仅在定义的地方改变数据<em class="mz"/>(也就是避免直接改变道具)确保了变化变得可预测和可预期。</p><p id="5e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个典型的用例是呈现一个项目列表，并在项目点击时修改它。这里我们有一个用户列表，我们想在用户名被点击时修改列表:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c58b" class="nf md it nb b gy ng nh l ni nj">// UserList -- Parent pass user prop down<br/>&lt;user v-for="user in users" :key="user.id" @change="updateUser" :user="user" /&gt;</span><span id="6c65" class="nf md it nb b gy nk nh l ni nj">//User -- Child emits change event up<br/>&lt;div @click="$emit('change', user)"&gt; {{user.name}} &lt;/div&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bd34" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">插槽—父到子</h1><p id="acb0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一个实现亲子沟通的强大方法是使用插槽，它暴露了几个要填充内容的出口。</p><p id="a28b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们定义了一个带有后备内容<code class="fe nl nm nn nb b">Default Text</code>的出口/占位符。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fd99" class="nf md it nb b gy ng nh l ni nj">// base-button<br/>&lt;button&gt;<br/>  &lt;slot&gt;<br/>    Default Text<br/>   &lt;/slot&gt;<br/>&lt;button&gt;</span></pre><p id="e596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们通过提供所需的内容来消费组件:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0b2c" class="nf md it nb b gy ng nh l ni nj">// consuming component<br/>&lt;base-button&gt;<br/>  overriding text <br/>&lt;/base-button&gt;</span></pre><p id="829d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于可以传递标记，使用插槽可以为您提供比props更高的灵活性，因此您可以这样做:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ccaf" class="nf md it nb b gy ng nh l ni nj">// consuming component<br/>&lt;base-button&gt; <br/>  &lt;icon name="save"&gt;&lt;/icon&gt;<br/>  &lt;b&gt;SAVE&lt;/b&gt;  <br/>&lt;/base-button&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc50" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">作用域插槽—子到父</h1><p id="646c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作用域插槽能够中断单向数据流(向下传递属性)，而是将内容暴露给父对象。</p><p id="0cd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在填充插槽时想要使用可插入插槽的组件中的一些数据或方法时，这尤其有用:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4453" class="nf md it nb b gy ng nh l ni nj">// User Component<br/>&lt;span&gt;   <br/>  &lt;slot&gt; {{ user.lastName }} &lt;/slot&gt;<br/>&lt;/span&gt;</span></pre><p id="c87a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在消费时，我们可能希望显示来自<code class="fe nl nm nn nb b">User</code>组件的附加信息——例如名字:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ccbb" class="nf md it nb b gy ng nh l ni nj">&lt;user&gt;<br/>  {{ user.firstName }}  {{ user.lastName}}  // Won't Work<br/>&lt;/user&gt;</span></pre><p id="4ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，这是行不通的，因为对象用户还没有定义消费组件的范围。幸运的是，我们可以通过作用域插槽来实现:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0832" class="nf md it nb b gy ng nh l ni nj">&lt;span&gt;   <br/>  &lt;slot v-bind:user="user"&gt; // expose user object to consumer<br/>     {{ user.lastName }}   <br/>   &lt;/slot&gt; <br/>&lt;/span&gt;</span></pre><p id="b487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nl nm nn nb b">v-bind:user</code>将用户暴露为老虎机道具后，我们可以在消费者中使用它:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2517" class="nf md it nb b gy ng nh l ni nj">&lt;user&gt; <br/>  &lt;template v-slot:default=”slotProps”&gt; <br/>   {{ slotProps.user.firstName }} {{ slotProps.user.lastName }}<br/>  &lt;/template&gt; <br/>&lt;/user&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb6c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">注入/提供-组件子树</h1><p id="5d6b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">随着应用程序的发展和构建更多可重用的组件，组件树层次结构会因为组件的嵌套而变得更深。</p><p id="8559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在父组件中使用<code class="fe nl nm nn nb b">provide</code>和在其子组件中使用<code class="fe nl nm nn nb b">inject</code>可以将道具传递给一个远的后代，而不管它在层次结构中有多深。</p><p id="275a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这种模式在Vue社区中名声不佳，但它便于提供具有“全局”依赖性的组件子树(想想React中的上下文API)，<em class="mz"> </em>，所以它在插件中被大量使用。</p><p id="3e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>记住提供的数据<em class="mz">不是</em>反应性的，除非你经过一个可观察的物体。</p><p id="c90d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以以<a class="ae ky" href="https://michaelnthiessen.com/provide-inject-not-dependency-injection" rel="noopener ugc nofollow" target="_blank">这个模式</a>为契机，更深入的了解<a class="ae ky" href="https://medium.com/js-dojo/understand-vue-reactivity-implementation-step-by-step-599c3d51cd6c" rel="noopener">反应性</a>和<a class="ae ky" href="https://alligator.io/vuejs/creating-custom-plugins/" rel="noopener ugc nofollow" target="_blank">插件</a></p><div class="no np gp gr nq nr"><a href="https://vuejs.org/v2/api/#provide-inject" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">API — Vue.js</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Vue.config是一个包含Vue全局配置的对象。您可以在…之前修改下面列出的属性</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">vuejs.org</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="da84" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">事件总线—旁路通信</h1><p id="6ad1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不同组件树中的组件可能想要通信。在这种情况下,<code class="fe nl nm nn nb b">EventBus</code>模式很方便。</p><p id="9b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">受网络中<a class="ae ky" href="https://en.wikipedia.org/wiki/Bus_network" rel="noopener ugc nofollow" target="_blank">总线拓扑</a>的启发，<code class="fe nl nm nn nb b">EventBus</code>是一种创建发布者-订阅者模式的简单方便的方法，允许组件一起通信，而不管它们之间的关系如何</p><p id="58f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要做的就是创建一个Vue实例<code class="fe nl nm nn nb b">EventBus</code>，并将其导入到所有依赖于总线的组件中。</p><p id="8e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后，任何组件都可以使用<code class="fe nl nm nn nb b">EventBus.$emit(‘eventName’)</code>向<code class="fe nl nm nn nb b">EventBus</code>发布新事件:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="88b6" class="nf md it nb b gy ng nh l ni nj">import EventBus from '...'</span><span id="9e20" class="nf md it nb b gy nk nh l ni nj">//subscribe<br/>mounted() { EventBus.$on(‘eventName’, () =&gt; { //… }) }</span><span id="39f8" class="nf md it nb b gy nk nh l ni nj">//cleanup<br/>beforeDestroy() { Eventbus.$off('eventName', () =&gt; {// ...})</span></pre><p id="314c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种通信方法虽然有效，但在应用程序扩展时会带来一些问题，比如名称空间、时间和开发工具支持。</p><p id="7de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好使用状态管理解决方案，并且只在极少数情况下使用<code class="fe nl nm nn nb b">EventBus</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b37f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">门户—任何</h1><p id="06e7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然这不是Vue.js核心的一部分，但它是由Vue.js核心团队的成员Linus Borg构建的。</p><p id="e420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得一提的是，它有利于处理流行的用例，比如模态/通知。</p><blockquote class="og"><p id="619c" class="oh oi it bd oj ok ol om on oo op lu dk translated">Vuejs的一个门户组件，用于在组件之外、文档中的任何地方呈现DOM。</p></blockquote><p id="2031" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">它的工作方式与插槽类似，主要区别在于实现方式，因为它不需要父/子关系:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4ad7" class="nf md it nb b gy ng nh l ni nj">&lt;portal to="destination"&gt;<br/>  &lt;p&gt;This slot content will be rendered wherever the &lt;portal-target&gt; with name 'destination'<br/>    is  located.&lt;/p&gt;<br/>&lt;/portal&gt;</span><span id="ee76" class="nf md it nb b gy nk nh l ni nj">&lt;portal-target name="destination"&gt;<br/>  &lt;!--<br/>  This component can be located anywhere in your App.<br/>  The slot content of the above portal component will be rendered here.<br/>  --&gt;<br/>&lt;/portal-target&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8f55" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">国家管理—集中化</h1><p id="88ed" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，<code class="fe nl nm nn nb b">EventBus</code>可以走很长的路，但它最终会引入足够多的问题，你最好使用状态管理。</p><p id="88a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过有一个集中的<strong class="lb iu">单一的真理来源</strong>、<strong class="lb iu">、</strong>所有组件访问这种反应性的全局状态。</p><p id="7be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首选方法是Vuex，它带有开发工具支持和一个状态管理模式，由最佳实践、状态、突变、动作、getters和所有这些可爱的东西强制执行！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6eb4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="6991" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">组件可以使用几种模式进行通信。在大多数情况下，所有这些模式都可以完成工作。</p><p id="d56c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标不仅是促进交流，而且减少调试时间，使修改代码库变得容易。</p><p id="8c35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你选择正确的模式时，这里有一些问题需要回答。</p><ul class=""><li id="5911" class="ov ow it lb b lc ld lf lg li ox lm oy lq oz lu pa pb pc pd bi translated">需要一起通信的组件之间的关系是什么？</li><li id="2a27" class="ov ow it lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">谁拥有这些数据？</li><li id="8995" class="ov ow it lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">在这种交流中，时机有多重要？</li></ul></div></div>    
</body>
</html>