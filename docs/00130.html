<html>
<head>
<title>JavaScript Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15?source=collection_archive---------0-----------------------#2018-05-14">https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15?source=collection_archive---------0-----------------------#2018-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae9b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最有用设计模式的终极指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/746d0f360128f1d2f3e8f1741fd0d89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGaKti_VLbb4_bBZQkm_sA.jpeg"/></div></div></figure><blockquote class="ku kv kw"><p id="b089" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">更新注意:</strong>更新了代理模式示例以使用ES6代理和反射。用<strong class="la iu">GitHub</strong>gist替换了源代码片段的图片。</p></blockquote><p id="f982" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在本文中，我们将讨论设计模式，它可以也应该被用来编写更好的、可维护的JavaScript代码。我假设您对JavaScript和类(JavaScript中的类可能很复杂)、对象、原型继承、闭包等概念有基本的理解。</p><p id="1e65" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">由于主题的性质，这篇文章作为一个整体是一篇很长的阅读，所以我尽量保持各部分独立。所以作为读者，你可以挑选特定的部分(或者，在这种情况下，特定的模式)，忽略那些你不感兴趣或者不熟悉的部分。现在，让我们开始吧。</p><blockquote class="ku kv kw"><p id="f0ac" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注:</strong>这里解释的所有设计模式实现的源代码在<a class="ae lx" href="https://github.com/drenther/js-design-patterns" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> GitHub </strong> </a>上。</p></blockquote><h1 id="f891" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">介绍</h1><p id="cfe7" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">我们写代码来解决问题。这些问题通常有许多相似之处，并且，当试图解决它们时，我们注意到几个共同的模式。这就是设计模式的用武之地。</p><blockquote class="ku kv kw"><p id="1bbb" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">设计模式</strong>是软件工程中的一个术语，指的是软件设计中常见问题的通用、可重用解决方案。</p></blockquote><p id="8a21" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">设计模式的基本概念从一开始就存在于软件工程行业中，但是它们并没有被正式化。<a class="ae lx" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">设计模式:可重用面向对象软件的元素</strong> </a>由<strong class="la iu"> Erich Gamma，Richard Helm，Ralph Johnson </strong>，<strong class="la iu"> </strong>和<strong class="la iu">John Vlissides</strong>——著名的四人帮(GoF)——撰写，在软件工程中推动设计模式的形式化概念方面发挥了重要作用。现在，设计模式是软件开发的重要组成部分，并且已经存在很长时间了。</p><p id="120d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">原著中介绍了23种设计模式。</p><div class="kj kk kl km gt ab cb"><figure class="mv kn mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c0297e1ee9faad35bbcd38b0e95b34e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*wPH4aXJ_Arv4jnliLUySyQ.png"/></div></figure><figure class="mv kn nb mx my mz na paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/cf749b5aa1399a9507a5ac1887166ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*pD3iU_fQx56oDlIMMBnbNw.png"/></div></figure><figure class="mv kn nc mx my mz na paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/a262cc2a07f5f6dc4e7dd1bce92555c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*weYSJ2_ZxVY8yZ8reEGq6g.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk nh di ni nj translated"><strong class="bd nk"> GoF </strong>推出的经典23式</p></figure></div><p id="a4ba" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">出于各种原因，设计模式是有益的。它们是业内资深人士已经尝试和测试过的成熟解决方案。它们是以广泛接受的方式解决问题的可靠方法，反映了帮助定义这些问题的行业领先开发人员的经验和见解。模式还使您的代码更具可重用性和可读性，同时大大加快了开发过程。</p><p id="1f7b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">设计模式绝不是最终的解决方案。它们只为我们提供解决问题的方法或方案。</p><blockquote class="ku kv kw"><p id="4034" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>在本文中，我们将主要从面向对象的角度并在现代JavaScript的可用性背景下讨论设计模式。这就是为什么许多来自GoF的经典模式可能会被省略，而一些来自<a class="ae lx" href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> Addy Osmani的Learn JavaScript设计模式</strong> </a>的现代模式将被包括在内。为了更容易理解，示例保持简单，因此不是它们各自设计模式的最佳实现。</p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="b607" class="ly lz it bd ma mb ns md me mf nt mh mi jz nu ka mk kc nv kd mm kf nw kg mo mp bi translated">设计模式的类别</h1><p id="6dae" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">设计模式通常分为三大类。</p><h2 id="1b00" class="nx lz it bd ma ny nz dn me oa ob dp mi lu oc od mk lv oe of mm lw og oh mo oi bi translated">创造性的设计模式</h2><p id="7362" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">顾名思义，这些模式用于处理对象创建机制。创造性设计模式基本上是通过控制对象的创建过程来解决问题的。</p><p id="2dcf" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">我们将详细讨论以下几种模式:<strong class="la iu"> <em class="kz">构造器模式、工厂模式、原型模式、</em> </strong>和<strong class="la iu"> <em class="kz">单体模式。</em>T13】</strong></p><h2 id="22d6" class="nx lz it bd ma ny nz dn me oa ob dp mi lu oc od mk lv oe of mm lw og oh mo oi bi translated">结构设计模式</h2><p id="23ba" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这些模式与类和对象的组成有关。它们帮助构建或重组一个或多个部分，而不影响整个系统。换句话说，它们有助于在不破坏现有功能的情况下获得新功能。</p><p id="7827" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">我们将详细讨论以下模式:<strong class="la iu"> <em class="kz">适配器模式、复合模式、装饰者模式、faade模式、Flyweight模式、</em> </strong>和<strong class="la iu"> <em class="kz">代理模式。</em> </strong></p><h2 id="6e03" class="nx lz it bd ma ny nz dn me oa ob dp mi lu oc od mk lv oe of mm lw og oh mo oi bi translated">行为设计模式</h2><p id="b9c2" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这些模式与改善不同对象之间的通信有关。</p><p id="32e2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">我们将详细讨论以下模式:<strong class="la iu"> <em class="kz">责任链模式、命令模式、迭代器模式、中介器模式、观察者模式、状态模式、策略模式、</em> </strong>和<strong class="la iu"> <em class="kz">模板模式。</em>T29】</strong></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="2d15" class="ly lz it bd ma mb ns md me mf nt mh mi jz nu ka mk kc nv kd mm kf nw kg mo mp bi translated">构造器模式</h1><p id="ffb2" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一个基于类的创造性设计模式。构造函数是特殊的函数，可以用来用该函数定义的方法和属性实例化新对象。</p><p id="75ce" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">它不是经典的设计模式之一。事实上，在大多数面向对象语言中，它更多的是一种基本的语言结构，而不是一种模式。但是在JavaScript中，对象可以动态创建，不需要任何构造函数或“类”定义。因此，我认为用这个简单的模式为其他模式打下基础是很重要的。</p><p id="f229" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">构造器模式是JavaScript中最常用的模式之一，用于创建给定类型的新对象。</p><p id="5f01" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们定义了一个具有像<code class="fe oj ok ol om b">name</code>和<code class="fe oj ok ol om b">specialAbility</code>这样的属性和像<code class="fe oj ok ol om b">getDetails</code>这样的方法的<code class="fe oj ok ol om b">Hero</code>类。然后，我们通过调用带有关键字<code class="fe oj ok ol om b">new</code>的构造函数方法实例化一个对象<code class="fe oj ok ol om b">IronMan</code>,将相应的属性值作为参数传入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">构造器模式</p></figure><h1 id="2f2e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">工厂模式</h1><p id="9b37" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">工厂模式是另一种基于类的创建模式。在这里，我们提供了一个通用接口，将对象实例化的责任委托给它的子类。</p><p id="22f1" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">当我们需要管理或操作不同但具有许多相似特征的对象集合时，经常使用这种模式。</p><p id="fc0c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们创建了一个名为<code class="fe oj ok ol om b">BallFactory</code>的工厂类，它有一个接受参数的方法，根据参数，它将对象实例化的责任委托给相应的类。如果类型参数为<code class="fe oj ok ol om b">"football"</code>或<code class="fe oj ok ol om b">"soccer"</code>，则对象实例化由<code class="fe oj ok ol om b">Football</code>类处理，如果类型参数为<code class="fe oj ok ol om b">"basketball"</code>，则对象实例化由<code class="fe oj ok ol om b">Basketball</code>类处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">工厂模式</p></figure><h1 id="4fdb" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">原型模式</h1><p id="f965" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这种模式是基于对象的创造性设计模式。在这里，我们使用一种现有对象的“框架”来创建或实例化新对象。</p><p id="d09e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">这种模式对JavaScript特别重要和有益，因为它利用原型继承而不是传统的面向对象继承。因此，它发挥了JavaScript的优势，并拥有原生支持。</p><p id="dd0c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们使用一个<code class="fe oj ok ol om b">car</code>对象作为原型来创建另一个具有JavaScript的<code class="fe oj ok ol om b">Object.create </code>特性的对象<code class="fe oj ok ol om b">myCar</code>，并在新对象上定义一个额外的属性<code class="fe oj ok ol om b">owner</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">原型模式</p></figure><h1 id="5c2d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">单一模式</h1><p id="154e" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">Singleton是一种特殊的创造性设计模式，其中一个类只能有一个实例。它是这样工作的——如果不存在singleton类的实例，那么创建并返回一个新的实例，但是如果一个实例已经存在，那么返回对现有实例的引用。</p><p id="b9f1" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">一个完美的真实例子是<code class="fe oj ok ol om b">mongoose</code>(著名的MongoDB node . js ODM库)。它利用了单例模式。</p><p id="92f8" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们有一个单独的<code class="fe oj ok ol om b">Database</code>类。首先，我们通过使用<code class="fe oj ok ol om b">new</code>操作符调用<code class="fe oj ok ol om b">Database</code>类构造函数来创建一个对象<code class="fe oj ok ol om b">mongo</code>。这一次实例化一个对象，因为不存在任何对象。第二次，当我们创建<code class="fe oj ok ol om b">mysql</code>对象时，没有实例化新的对象，而是返回对之前实例化的对象的引用，即<code class="fe oj ok ol om b">mongo</code>对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">单一模式</p></figure><h1 id="6054" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">适配器模式</h1><p id="d865" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一种结构模式，其中一个类的接口被转换成另一个类的接口。这种模式允许类一起工作，否则由于不兼容的接口而无法工作。</p><p id="53f7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">这种模式通常用于为新的重构API创建包装器，以便其他现有的旧API仍然可以使用它们。当新的实现或代码重构(出于提高性能等原因)导致不同的公共API时，通常会这样做，而系统的其他部分仍在使用旧的API，需要进行调整才能协同工作。</p><p id="cd4e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们有一个旧的API，即<code class="fe oj ok ol om b">OldCalculator</code>类，和一个新的API，即<code class="fe oj ok ol om b">NewCalculator</code>类。<code class="fe oj ok ol om b">OldCalculator</code>类为加法和减法都提供了一个<code class="fe oj ok ol om b">operation</code>方法，而<code class="fe oj ok ol om b">NewCalculator</code>为加法和减法提供了单独的方法。适配器类<code class="fe oj ok ol om b">CalcAdapter</code>包装<code class="fe oj ok ol om b">NewCalculator</code>以将<code class="fe oj ok ol om b">operation</code>方法添加到面向公众的API中，同时使用其自己的加减实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">适配器模式</p></figure><h1 id="fde5" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">复合模式</h1><p id="8f95" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一种结构设计模式，它将对象组成树状结构来表示整体-部分层次结构。在这种模式中，树状结构中的每个节点可以是单个对象，也可以是对象的组合集合。无论如何，每个节点都被同等对待。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b2b9d3271579722e915e053bb797e2d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*yAkeYCKDaRQtMRAV2Kx5sA.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">多级菜单结构</p></figure><p id="8725" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">形象化这种模式有点复杂。考虑这个问题最简单的方法是以多级菜单为例。每个节点可以是一个不同的选项，也可以是一个菜单本身，其中有多个选项作为其子节点。有子节点的节点组件是复合组件，而没有子节点的节点组件是叶组件。</p><p id="22c2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们创建了一个基类<code class="fe oj ok ol om b">Component</code>,它实现了所需的通用功能，并抽象了所需的其他方法。基类也有一个静态方法，利用递归来遍历由它的子类组成的复合树结构。然后我们创建两个扩展基类的子类——<code class="fe oj ok ol om b">Leaf</code>没有任何子类，而<code class="fe oj ok ol om b">Composite</code>可以有子类——因此有处理添加、搜索和删除子功能的方法。这两个子类用于创建一个复合结构——在本例中是一棵树。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">复合模式</p></figure><h1 id="db35" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">装饰图案</h1><p id="3bab" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这也是一种结构设计模式，它关注于向现有类动态添加行为或功能的能力。这是另一个可行的替代分类的方法。</p><p id="0848" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">装饰类型行为很容易在JavaScript中实现，因为JavaScript允许我们动态地向对象添加方法和属性。最简单的方法是给一个对象添加一个属性，但是它不能被有效地重用。</p><p id="197c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">事实上，有人提议在JavaScript语言中添加装饰器。看看<a class="ae lx" href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" rel="noopener"> <strong class="la iu"> Addy Osmani关于JavaScript中装饰者的帖子</strong> </a>。</p><p id="903d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">如果你想了解<a class="ae lx" href="https://tc39.es/proposal-decorators/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">提案本身</strong> </a>，请随意。</p><p id="f004" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们创建了一个<code class="fe oj ok ol om b">Book</code>类。我们还创建了两个decorator函数，它们接受一个book对象并返回一个“装饰过的”<code class="fe oj ok ol om b">book</code>对象— <code class="fe oj ok ol om b">giftWrap</code>添加一个新属性和一个新函数，以及<code class="fe oj ok ol om b">hardbindBook</code>添加一个新属性并编辑一个现有属性的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">装饰图案</p></figure><h1 id="28e9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">立面图案</h1><p id="3960" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一种在JavaScript库中广泛使用的结构设计模式。它被用来提供一个统一的、更简单的、面向公众的接口，以方便使用，避免复杂的子系统或子类。</p><p id="dc1a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在像jQuery这样的库中，这种模式的使用非常普遍。</p><p id="a555" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们用类<code class="fe oj ok ol om b">ComplaintRegistry</code>创建了一个面向公众的API。它只公开了一个方法供客户端使用，即<code class="fe oj ok ol om b">registerComplaint</code>。它根据类型参数在内部处理所需的<code class="fe oj ok ol om b">ProductComplaint</code>或<code class="fe oj ok ol om b">ServiceComplaint</code>对象的实例化。它还处理所有其他复杂的功能，如生成唯一的ID，将投诉存储在内存中等。但是，所有这些复杂性都被外观模式隐藏起来了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">立面图案</p></figure><h1 id="f163" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">轻量级模式</h1><p id="b29d" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一种结构设计模式，专注于通过细粒度对象实现高效的数据共享。它用于提高效率和节省内存。</p><p id="32b0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">这种模式可以用于任何类型的缓存目的。事实上，现代浏览器使用了一种flyweight模式的变体来防止两次加载相同的图像。</p><p id="a009" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们创建了一个细粒度的flyweight类<code class="fe oj ok ol om b">Icecream</code>来共享关于冰淇淋口味的数据，还创建了一个工厂类<code class="fe oj ok ol om b">IcecreamFactory</code>来创建这些flyweight对象。为了节省内存，如果同一个对象被实例化两次，则对象将被回收。这是一个flyweight实现的简单例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">轻量级模式</p></figure><h1 id="e1d3" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">代理模式</h1><p id="f0b9" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一种结构设计模式，正如它的名字所暗示的那样。它充当另一个对象的代理或占位符来控制对它的访问。</p><p id="e9f2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">它通常用于目标对象受到约束并且可能无法有效处理其所有职责的情况。在这种情况下，代理通常向客户端提供相同的接口，并添加一个间接层来支持对目标对象的受控访问，以避免对其造成不适当的压力。</p><p id="4183" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">代理模式在处理大量网络请求的应用程序时非常有用，可以避免不必要的或多余的网络请求。</p><p id="85ff" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们将使用ES6的两个新特性，<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">代理</strong> </a>和<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">反射</strong> </a>。代理对象用于为JavaScript对象的基本操作定义自定义行为(记住，函数和数组也是JavaScript中的对象)。它是一个构造器方法，可以用来创建一个<code class="fe oj ok ol om b">Proxy</code>对象。它接受一个将被代理的<code class="fe oj ok ol om b">target</code>对象和一个将定义必要定制的<code class="fe oj ok ol om b">handler</code>对象。handler对象允许定义一些陷阱函数，如<code class="fe oj ok ol om b">get</code>、<code class="fe oj ok ol om b">set</code>、<code class="fe oj ok ol om b">has</code>、<code class="fe oj ok ol om b">apply</code>等。用于将自定义行为添加到它们的用法中。另一方面，<code class="fe oj ok ol om b">Reflect</code>是一个内置对象，它提供了类似的方法，这些方法由代理的handler对象作为静态方法支持。它不是构造函数；它的静态方法用于可拦截的JavaScript操作。</p><p id="e1f2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">现在，我们创建一个可以看作是网络请求的函数。我们将其命名为<code class="fe oj ok ol om b">networkFetch</code>。它接受一个URL并做出相应的响应。我们希望实现一个代理，如果缓存中没有响应，我们就只能从网络中获得响应。否则，我们只是从缓存中返回一个响应。</p><p id="49a5" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated"><code class="fe oj ok ol om b">cache</code>全局变量将存储我们缓存的响应。我们创建一个名为<code class="fe oj ok ol om b">proxiedNetworkFetch</code>的代理，用我们原来的<code class="fe oj ok ol om b">networkFetch</code>作为<code class="fe oj ok ol om b">target</code>，并在我们的<code class="fe oj ok ol om b">handler</code>对象中使用apply方法来代理函数调用。apply方法在<code class="fe oj ok ol om b">target</code>对象本身上传递。这个值作为<code class="fe oj ok ol om b">thisArg</code>和参数以类似数组的结构<code class="fe oj ok ol om b">args</code>传递给它。</p><p id="8d7f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">我们检查传递的url参数是否在缓存中。如果它存在于缓存中，我们从那里返回响应，从不调用原始的目标函数。如果没有，那么我们使用<code class="fe oj ok ol om b">Reflect.apply</code>方法调用带有<code class="fe oj ok ol om b">thisArg</code>的<code class="fe oj ok ol om b">target</code>函数(尽管在我们的例子中没有任何意义)和它传递的参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">代理模式</p></figure><h1 id="8faf" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">责任链模式</h1><p id="7d2e" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一种行为设计模式，提供了一系列松散耦合的对象。这些对象中的每一个都可以选择处理客户端的请求。</p><p id="8edc" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">责任链模式的一个很好的例子是DOM中的事件冒泡，其中一个事件通过一系列嵌套的DOM元素传播，其中一个元素可能附加了一个“事件监听器”来监听事件并对其进行操作。</p><p id="e5b7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们创建了一个类<code class="fe oj ok ol om b">CumulativeSum</code>，它可以用可选的<code class="fe oj ok ol om b">initialValue</code>实例化。它有一个方法<code class="fe oj ok ol om b">add</code>，将传递的值添加到对象的<code class="fe oj ok ol om b">sum</code>属性，并返回<code class="fe oj ok ol om b">object</code>本身，以允许链接<code class="fe oj ok ol om b">add</code>方法调用。</p><p id="05e3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">这是一个常见的模式，也可以在jQuery中看到，几乎所有对jQuery对象的方法调用都会返回一个jQuery对象，这样方法调用就可以链接在一起。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">责任链模式</p></figure><h1 id="6b07" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">命令模式</h1><p id="eaec" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一种行为设计模式，旨在将动作或操作封装为对象。这种模式通过将请求操作或调用方法的对象与执行或处理实际实现的对象分开，允许系统和类的松散耦合。</p><p id="cba4" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">剪贴板交互API有点类似于命令模式。如果你是一个<a class="ae lx" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> Redux </strong> </a>用户，那么你已经遇到了命令模式。允许令人惊叹的时间旅行调试功能的动作不过是封装的操作，可以跟踪这些操作来重做或撤消操作。因此，时间旅行成为可能。</p><p id="c403" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们有一个名为<code class="fe oj ok ol om b">SpecialMath</code>的类，它有多个方法，还有一个<code class="fe oj ok ol om b">Command</code>类，它封装了将在其主题上执行的命令，即<code class="fe oj ok ol om b">SpecialMath</code>类的一个对象。<code class="fe oj ok ol om b">Command</code>类还跟踪所有执行的命令，这可以用来扩展它的功能，包括撤销和重做类型的操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">命令模式</p></figure><h1 id="6de9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">迭代器模式</h1><p id="1385" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">它是一种行为设计模式，提供了一种顺序访问聚合对象的元素而不暴露其底层表示的方法。</p><p id="0b57" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">迭代器有一种特殊的行为，我们通过调用<code class="fe oj ok ol om b">next()</code>一次遍历一组有序的值，直到到达末尾。ES6中迭代器和生成器的引入使得迭代器模式的实现非常简单。</p><p id="0274" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">下面我们举两个例子。首先，一个<code class="fe oj ok ol om b">IteratorClass</code>使用迭代器规范，而另一个<code class="fe oj ok ol om b">iteratorUsingGenerator</code>使用生成器函数。</p><p id="fccf" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated"><code class="fe oj ok ol om b">Symbol.iterator</code>(<code class="fe oj ok ol om b">Symbol</code>—一种新的原始数据类型)用于指定对象的默认迭代器。必须为集合定义它才能使用<code class="fe oj ok ol om b">for...of</code>循环结构。在第一个例子中，我们定义构造函数来存储一些数据集合，然后定义<code class="fe oj ok ol om b">Symbol.iterator</code>，用<code class="fe oj ok ol om b">next</code>方法返回一个对象进行迭代。</p><p id="6de5" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">对于第二种情况，我们定义一个生成器函数，向它传递一个数据数组，并使用<code class="fe oj ok ol om b">next</code>和<code class="fe oj ok ol om b">yield</code>迭代地返回它的元素。生成器函数是一种特殊类型的函数，它作为迭代器的工厂工作，可以显式地维护自己的内部状态并迭代地产生值。它可以暂停和恢复自己的执行周期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">迭代器模式</p></figure><h1 id="efb2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">中介模式</h1><p id="fd55" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">它是一种行为设计模式，封装了一组对象之间的交互方式。它通过促进松散耦合来提供对一组对象的集中管理，防止对象显式地相互引用。</p><p id="2ed4" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们用<code class="fe oj ok ol om b">TrafficTower</code>作为中介来控制<code class="fe oj ok ol om b">Airplane</code>对象相互交互的方式。所有的<code class="fe oj ok ol om b">Airplane</code>对象向一个<code class="fe oj ok ol om b">TrafficTower</code>对象注册自己，并且是中介类对象处理一个<code class="fe oj ok ol om b">Airplane</code>对象如何接收所有其他<code class="fe oj ok ol om b">Airplane</code>对象的坐标数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">中介模式</p></figure><h1 id="1dbc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">观察者模式</h1><p id="e4c2" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一个关键的行为设计模式，它定义了对象之间的一对多依赖关系，因此当一个对象(发布者)改变其状态时，所有其他依赖对象(订阅者)都会得到通知并自动更新。这也称为PubSub(发布者/订阅者)或事件调度程序/侦听器模式。发布者有时被称为主体，订阅者有时被称为观察者。</p><p id="d484" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">如果您使用过<code class="fe oj ok ol om b">addEventListener</code>或jQuery，您可能已经对这种模式有些熟悉了。<code class="fe oj ok ol om b">on</code>编写偶数处理代码。它对反应式编程也有影响(想想<a class="ae lx" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> RxJS </strong> </a>)。</p><p id="0a09" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们创建了一个简单的<code class="fe oj ok ol om b">Subject</code>类，该类具有从订阅者集合中添加和移除<code class="fe oj ok ol om b">Observer</code>类的对象的方法。还有一个<code class="fe oj ok ol om b">fire</code>方法，将<code class="fe oj ok ol om b">Subject</code>类对象中的任何变化传播给订阅的观察者。另一方面，<code class="fe oj ok ol om b">Observer</code>类有它的内部状态和一个基于从它订阅的<code class="fe oj ok ol om b">Subject</code>传播的变化来更新它的内部状态的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">观察者模式</p></figure><h1 id="56a9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">状态模式</h1><p id="6429" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">它是一种行为设计模式，允许对象根据其内部状态的变化来改变其行为。状态模式类返回的对象似乎改变了它的类。它为有限的一组对象提供特定于状态的逻辑，其中每个对象类型代表一个特定的状态。</p><p id="740d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">我们将以一个简单的交通灯为例来理解这种模式。<code class="fe oj ok ol om b">TrafficLight</code>类根据其内部状态改变其返回的对象，该对象是<code class="fe oj ok ol om b">Red</code>、<code class="fe oj ok ol om b">Yellow</code>或<code class="fe oj ok ol om b">Green</code>类的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">状态模式</p></figure><h1 id="87e7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">战略模式</h1><p id="4cd0" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">它是一种行为设计模式，允许封装特定任务的替代算法。它定义了一系列算法，并以这样一种方式封装它们，使得它们在运行时可以互换，而无需客户端干预或了解。</p><p id="76d6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在下面的例子中，我们创建了一个类<code class="fe oj ok ol om b">Commute</code>来封装所有可能的通勤策略。然后，我们定义三种策略，即<code class="fe oj ok ol om b">Bus</code>、<code class="fe oj ok ol om b">PersonalCar</code>和<code class="fe oj ok ol om b">Taxi</code>。使用这种模式，我们可以在运行时交换用于<code class="fe oj ok ol om b">Commute</code>对象的<code class="fe oj ok ol om b">travel</code>方法的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">战略模式</p></figure><h1 id="c927" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">模板模式</h1><p id="d7d2" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">这是一种行为设计模式，基于定义算法的框架或操作的实现，但将一些步骤推迟到子类。它允许子类在不改变算法外部结构的情况下重新定义算法的某些步骤。</p><p id="f141" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在这个例子中，我们有一个模板类<code class="fe oj ok ol om b">Employee</code>，它部分实现了<code class="fe oj ok ol om b">work</code>方法。子类实现责任方法使其作为一个整体工作。然后我们创建两个子类<code class="fe oj ok ol om b">Developer</code>和<code class="fe oj ok ol om b">Tester</code>，它们扩展了模板类并实现了所需的方法来填补实现的空白。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">模板模式</p></figure><h1 id="bfde" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="4fd5" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lu ms lj lk lv mt ln lo lw mu lr ls lt im bi translated">设计模式对软件工程至关重要，并且在解决常见问题时非常有帮助。但这是一个非常庞大的主题，不可能在一篇短短的文章中囊括所有的内容。因此，我选择简单明了地只谈论那些我认为在编写现代JavaScript时非常有用的内容。要深入探究，我建议你看看这些书:</p><ol class=""><li id="8413" class="oq or it la b lb lc le lf lu os lv ot lw ou lt ov ow ox oy bi translated"><a class="ae lx" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">设计模式:可重用面向对象软件的元素</strong> </a> <strong class="la iu"> </strong>由<em class="kz">埃里希·伽马、理查德·赫尔姆、拉尔夫·约翰逊和约翰·维里西德斯(四人组)</em></li><li id="3d56" class="oq or it la b lb oz le pa lu pb lv pc lw pd lt ov ow ox oy bi translated"><a class="ae lx" href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">通过<em class="kz"> Addy Osmani </em>学习JavaScript设计模式</strong> </a></li><li id="2415" class="oq or it la b lb oz le pa lu pb lv pc lw pd lt ov ow ox oy bi translated"><a class="ae lx" href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> JavaScript模式</strong> </a>作者<em class="kz">斯托扬·斯特凡诺夫</em></li></ol></div></div>    
</body>
</html>