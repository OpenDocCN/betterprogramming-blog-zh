<html>
<head>
<title>Building Full-Stack TypeScript Applications Using tRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用tRPC构建全栈类型脚本应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-full-stack-typescript-applications-using-trpc-eef8588979d8?source=collection_archive---------4-----------------------#2022-11-30">https://betterprogramming.pub/build-full-stack-typescript-applications-using-trpc-eef8588979d8?source=collection_archive---------4-----------------------#2022-11-30</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="c1a6" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">使用Next和Express适配器实现前端和后端之间的类型安全集成</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/d01264c780fd6b8daf889c03f0d4c674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b1wl2mCvjBcYsfEJ"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae la" href="https://unsplash.com/@danedeaner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dane Deaner </a>拍摄的照片</p></figure><p id="dced" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在构建全栈应用程序时，您可能会使用REST或GraphQL来为您的前端提供API功能。tRPC试图改变这种情况，或者至少提供一种替代方案，在客户机和服务器之间增加类型共享的好处。</p><p id="f4ec" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">好奇吗？当我看到tRPC出现在我的Twitter feed中时，我也是，所以我决定仔细看看。在本文中，我们将看看tRPC提供了什么，以及它如何简化前端应用程序的API开发。</p></div><div class="ab cl lx ly hz lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="io ip iq ir is"><h1 id="a2bb" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">tRPC是什么？</h1><p id="de6d" class="pw-post-body-paragraph lb lc iv ld b le mw jw lg lh mx jz lj lk my lm ln lo mz lq lr ls na lu lv lw io bi translated">简而言之，tRPC是一个使用TypeScript构建类型安全API的框架。与REST和GraphQL等传统API相反，tRPC中没有API模式。相反，您在后端API中定义的类型可以在客户端访问。</p><p id="0326" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">起初这听起来可能有点奇怪，但是如果你考虑到tRPC的主要用例是在全栈应用程序中提供API，这实际上很有意义。</p><p id="c9b1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当涉及到服务之间的HTTP调用时，为了理解客户机和服务器之间的契约，模式是必不可少的。然而，对于用tRPC构建的全栈应用程序的API，类型提供了契约。</p><p id="5434" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">tRPC本身是非常轻量级的，没有依赖性和框架无关性。大多数主流框架都有tRPC的适配器，包括<a class="ae la" href="https://trpc.io/docs/example-apps" rel="noopener ugc nofollow" target="_blank"> Next.js和Express </a>。</p><p id="1325" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在我们了解了tRPC是什么，它解决了什么问题？</p></div><div class="ab cl lx ly hz lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="io ip iq ir is"><h1 id="7180" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">tRPC解决什么问题？</h1><p id="5747" class="pw-post-body-paragraph lb lc iv ld b le mw jw lg lh mx jz lj lk my lm ln lo mz lq lr ls na lu lv lw io bi translated">与任何新(ish)技术一样，它的产生很可能是因为有人遇到了以前的技术没有解决的问题。</p><p id="23ac" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这种情况下，问题是为前端API创建模式，以及随之而来的所有相关管道。在客户端更是如此，您需要格式化请求并进行HTTP调用。tRPC基本上解决了这个问题，因为它为你处理了这个问题。本质上，它解放了你，工程师，去关注前端显示和后端逻辑，而不必担心两者如何互相交流。</p><p id="b94d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这确实在前端代码和后端代码之间引入了耦合感。然而，因为它是TypeScript，所以您的前端代码只知道它将接收一个符合特定接口的对象。这意味着我们通过依赖抽象，坚持了<a class="ae la" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>。</p><p id="79a4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">tRPC的另一大卖点是速度和安全性。由于我们不必担心模式，因为它们是通过类型隐含的，前端和后端之间的集成是快速的。</p><p id="85bf" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">至于安全性，您可以确保当您对前端或后端进行更改时，不会破坏正在使用的数据。如果您重命名从您的API返回的<code class="fe nb nc nd ne b">User</code>上的一个属性，任何使用该属性的客户端代码都将被突出显示以进行更新。</p></div><div class="ab cl lx ly hz lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="io ip iq ir is"><h1 id="68d9" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">tRPC的一个简单例子</h1><p id="ad5b" class="pw-post-body-paragraph lb lc iv ld b le mw jw lg lh mx jz lj lk my lm ln lo mz lq lr ls na lu lv lw io bi translated">为了完善这篇文章，我将展示一个简单的例子。为了简单起见，我不打算用Next或Express创建任何东西。相反，我将展示如何在tRPC中创建快速端点，以及如何在客户端使用它。</p><p id="65a5" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">下面是服务器端，实现一个端点来从列表中检索动物:</p><pre class="kl km kn ko gt nf ne ng bn nh ni bi"><span id="cbe8" class="nj mf iv ne b be nk nl l nm nn">import { initTRPC } from '@trpc/server';<br/><br/>const t = initTRPC.create();<br/><br/>interface Animals {<br/>    id: number,<br/>    type: string;<br/>}<br/><br/>const listOfAnimals: Animals[] = [<br/>    {<br/>        id: 1,<br/>        type: 'Dog'<br/>    },<br/>    {<br/>        id: 2,<br/>        type: 'Cat'<br/>    },<br/>];<br/><br/>const appRouter = t.router({<br/>    getAnimal: t.procedure<br/>        // The input is unknown at this time.<br/>        // A client could have sent us anything<br/>        // so we won't assume a certain data type.<br/>        .input((req: unknown) =&gt; {<br/>            //Here we should do some validation of the input<br/>        })<br/>        .query((req) =&gt; {<br/>            const { input } = req;<br/>            const animal = listOfAnimals.find((u) =&gt; u.id === input);<br/><br/>            return animal;<br/>        }),<br/>});<br/><br/>export type AppRouter = typeof appRouter;</span></pre><p id="0c7c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">很简单，对吧？我知道它使用的是虚拟数据，但我真的很喜欢用tRPC创建端点是多么容易。这是一个简单的查询，本质上映射到一个GET请求。它还支持突变，用于创建或修改数据。</p><p id="c99d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果我们现在想在客户端调用这个端点，代码甚至比服务器还要简单:</p><pre class="kl km kn ko gt nf ne ng bn nh ni bi"><span id="9f28" class="nj mf iv ne b be nk nl l nm nn">import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';<br/>// This is our server definition from above, using import type<br/>// is important, as it only imports type, not code, to avoid<br/>// accidentally using server-side code<br/>import type { AppRouter } from './server';<br/> <br/>//This configures the client to talk to our server<br/>const trpc = createTRPCProxyClient&lt;AppRouter&gt;({<br/>  links: [<br/>    httpLink({<br/>      url: 'http://localhost:3000/trpc',<br/>    }),<br/>  ],<br/>});<br/><br/>// Call the API<br/>const animal = await trpc.getAnimal.query(1);</span></pre><p id="712d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">代码被很好地注释了，所以它应该解释发生了什么。这些链接是tRPC的一个有趣的特性，你可以在这里阅读关于<a class="ae la" href="https://trpc.io/docs/links" rel="noopener ugc nofollow" target="_blank">的内容。值得注意的是，在指定的端口上没有运行任何东西，但是如果我们将tRPC与Next.js一起使用，默认情况下，它将在该端口上本地公开。</a></p></div><div class="ab cl lx ly hz lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="io ip iq ir is"><h1 id="6b49" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">摘要</h1><p id="ef91" class="pw-post-body-paragraph lb lc iv ld b le mw jw lg lh mx jz lj lk my lm ln lo mz lq lr ls na lu lv lw io bi translated">在这一点上，你可能认为tRPC是一个新的框架。不过也有几年历史了，最近发布了10版，所以保养的很好。然而，随着GitHub上的明星越来越多，它的势头越来越大。</p><p id="54eb" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果我要构建一个全新的全栈应用程序，我当然愿意尝试tRPC。这看起来是一个非常简单而可靠的产品，与大多数主流框架都有很好的集成。它的<a class="ae la" href="https://trpc.io/docs" rel="noopener ugc nofollow" target="_blank">文档</a>也很不错。</p><p id="a102" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">你试过tRPC吗，还是准备试一试？给我留言，让我知道！</p></div><div class="ab cl lx ly hz lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="io ip iq ir is"><blockquote class="no np nq"><p id="0c0a" class="lb lc nr ld b le lf jw lg lh li jz lj ns ll lm ln nt lp lq lr nu lt lu lv lw io bi translated">我的书《用现代图表技术创建软件》已经出版了！</p><p id="c091" class="lb lc nr ld b le lf jw lg lh li jz lj ns ll lm ln nt lp lq lr nu lt lu lv lw io bi translated"><a class="ae la" href="https://www.amazon.com/dp/1680509837?maas=maas_adg_265A9C302E256D26C2E10C30DA1AA728_afap_abs&amp;ref_=aa_maas&amp;tag=maas" rel="noopener ugc nofollow" target="_blank">点击此处</a>学习如何创建图表，比文字更直接、更清晰地传达信息。仅使用基于文本的标记，由Mermaid提供支持，创建有意义和有吸引力的图表来记录您的领域，可视化用户流，揭示任何所需级别的系统架构，等等！</p></blockquote></div></div>    
</body>
</html>