<html>
<head>
<title>Understanding Ethereum ERC-20 Meta-Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解以太坊ERC-20元交易</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ethereum-erc-20-meta-transactions-4cacbb3630ee?source=collection_archive---------0-----------------------#2021-10-22">https://betterprogramming.pub/ethereum-erc-20-meta-transactions-4cacbb3630ee?source=collection_archive---------0-----------------------#2021-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="56b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本指南中，我们将在<a class="ae kj" href="https://eips.ethereum.org/EIPS/eip-20" rel="noopener ugc nofollow" target="_blank"> ERC-20 </a>代币的背景下探讨无汽油交易的概念，也就是通常所说的<em class="ki"> meta- </em>交易，其中<strong class="ak">用户不需要支付他们的汽油费</strong>。</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/ebe47d403803bb9bc7116a1684a24aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8ZDlCF08pKku99hK.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated"><a class="ae kj" href="https://www.ethos.io/what-is-ethereum-gas" rel="noopener ugc nofollow" target="_blank">原始来源</a></p></figure><blockquote class="la"><p id="335b" class="lb lc it bd ld le lf lg lh li lj lk dk translated"><em class="ki">“哦，一个非常酷的项目在我的以太坊钱包上空投了一个令牌，但不幸的是，现在我无法将它转移到我的主钱包，因为我在这个地址上没有任何以太。那真的很烂！”</em></p></blockquote><p id="ce2e" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf lk im bi translated">如果您对此很熟悉，您可以跳过下一部分。然而，如果整件事对你来说听起来很神秘，这里是以太坊上气体挑战的简要说明。</p><p id="4618" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">气体是以太世界的关键。打个比方，是燃料让它运转，就像汽车需要汽油一样。</p><p id="3501" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">总之，gas是指测量在以太坊网络上执行特定操作(例如发送以太网(ETH)或令牌)所需的计算工作量的单位。</p><p id="d0c8" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">由于每一笔以太坊交易都需要计算资源来执行，所以每一笔交易都需要费用(=俗称的气价和交易消耗的气的倍数)。</p><p id="bd0c" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">燃气费用以太坊的本币ETH支付。此外，天然气价格通常用一个叫做<em class="ml"> gwei </em>的单位来表示，gwei本身就是ETH的一个单位——每个gwei等于0.000000001 ETH(或10⁻⁹ ETH)。</p><p id="b7f1" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">例如，不要说你的汽油值0.000000001 ETH，你通常会说你的汽油值1 gwei。gwei这个词本身的意思是千兆位，它等于1'000'000'000位(1位= 10⁻ ⁸联邦理工学院)。卫本身——以b币的发明者的名字命名——是ETH的最小单位。</p><p id="98e0" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">但是为什么气费实际存在呢？简而言之，燃气费有助于保持以太坊网络的安全。通过对网络上执行的每项计算收取费用，我们可以防止不良行为者在网络上发送垃圾邮件。为了进一步深入这个话题，我可以推荐<a class="ae kj" href="https://ethereum.org/en/developers/docs/gas/" rel="noopener ugc nofollow" target="_blank">这个</a>参考。</p><p id="da16" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">因此，我们到目前为止了解到，以太坊区块链上的每个(写)交互都需要交互地址上的少量ETH。</p><p id="556f" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">从UX的角度来看，对于令牌持有者来说，这听起来真的很可怕，因为用户首先需要通过集中交换获得ETH，并相应地将其转移到钱包地址。但是，等等，难道不是这样的吗——非常简单——在最基本的区块链级别，它只是一个验证签名有效载荷的问题，即链外加密？</p><p id="ff08" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">啊，是的，听起来不错！那么，钱包用户只需在链外签署有效载荷，而其他人(如运营商)广播并支付交易费用，这种情况如何？</p><p id="b704" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">这就是我们的解决方案:<strong class="ln iu">元事务</strong>。</p><h1 id="b147" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">背景</h1><p id="8b5d" class="pw-post-body-paragraph ll lm it ln b lo ne ju lq lr nf jx lt lu ng lw lx ly nh ma mb mc ni me mf lk im bi translated">一个<em class="ml">元事务</em>是一个常规的以太坊事务，它包含另一个事务，即实际事务。实际交易由用户签名，然后发送给运营商或类似的机构；不需要气体和区块链相互作用。运营商接受这一签署的交易，并将其提交给自己支付费用的区块链。<em class="ml"> forwarding </em>智能合约确保实际交易上有有效的签名，然后执行它。</p><p id="94f6" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">在<a class="ae kj" href="https://eips.ethereum.org/EIPS/eip-20" rel="noopener ugc nofollow" target="_blank"> ERC-20 </a>令牌转移的背景下，我们还必须意识到以下重要的治理层:可以说，ERC-20令牌成功的主要原因之一在于<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20-approve-address-uint256-" rel="noopener ugc nofollow" target="_blank">approve</a></code>和<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20-transferFrom-address-address-uint256-" rel="noopener ugc nofollow" target="_blank">transferFrom</a></code>之间的相互作用，这使得令牌不仅可以在<a class="ae kj" href="https://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html" rel="noopener ugc nofollow" target="_blank">外部拥有的账户</a> (EOA)之间转移，还可以在特定于应用程序的条件下用于其他合同，方法是将<code class="fe nj nk nl nm b">msg.sender</code>抽象为令牌访问控制的定义机制。</p><p id="ccd8" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">然而，这种设计的一个限制因素源于ERC-20 <code class="fe nj nk nl nm b">approve</code>函数本身是根据<code class="fe nj nk nl nm b">msg.sender</code>定义的。这意味着用户涉及ERC-20代币的初始动作必须由EOA执行。如果用户需要与智能合约交互，那么他们需要进行两个事务(<code class="fe nj nk nl nm b">approve</code>和智能合约调用，后者将在内部调用<code class="fe nj nk nl nm b">transferFrom</code>)。即使在向另一个人付款的简单用例中，他们也需要持有ETH来支付交易气成本。</p><p id="d047" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">为了解决这个挑战，我们可以用一个新的函数<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Permit-permit-address-address-uint256-uint256-uint8-bytes32-bytes32-" rel="noopener ugc nofollow" target="_blank">permit</a></code>来扩展ERC-20令牌契约，该函数允许用户使用签名消息(通过<code class="fe nj nk nl nm b"><a class="ae kj" href="https://en.bitcoin.it/wiki/Secp256k1" rel="noopener ugc nofollow" target="_blank">secp256k1</a></code>签名)来修改许可映射，而不是通过<code class="fe nj nk nl nm b">msg.sender</code>。或者换句话说，<code class="fe nj nk nl nm b">permit</code>方法可用于通过提交由账户签名的消息来改变账户的ERC-20津贴(参见<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-allowance-address-address-" rel="noopener ugc nofollow" target="_blank">IERC20.allowance</a></code>)。通过不依赖<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-approve-address-uint256-" rel="noopener ugc nofollow" target="_blank">IERC20.approve</a></code>，令牌持有者账户不需要发送交易，因此根本不需要持有ETH。</p><p id="486d" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">为了改善用户体验，签名数据的结构遵循<a class="ae kj" href="https://eips.ethereum.org/EIPS/eip-712" rel="noopener ugc nofollow" target="_blank"> EIP-712 </a>，这已经在主要的RPC &amp;钱包提供商中广泛采用。</p><p id="a1b6" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">这种设置将我们引向以下架构:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nn"><img src="../Images/84cd648ea5e8a74f70a0643658d83313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwQKuIpTXUnvfu4WnK0tQQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">ERC 20元事务架构</p></figure><h1 id="47c0" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">EIP-712 —以太坊类型的结构化数据哈希和签名</h1><p id="4cd3" class="pw-post-body-paragraph ll lm it ln b lo ne ju lq lr nf jx lt lu ng lw lx ly nh ma mb mc ni me mf lk im bi translated"><a class="ae kj" href="https://eips.ethereum.org/EIPS/eip-712" rel="noopener ugc nofollow" target="_blank"> EIP-712 </a>是一个用于散列和签名类型化结构化数据的标准。EIP中指定的编码非常通用，在Solidity中这样的通用实现是不可行的，因此我们的合同本身并不实现编码。协议需要使用<code class="fe nj nk nl nm b">abi.encode</code>和<code class="fe nj nk nl nm b">keccak256</code>的组合来实现它们在契约中需要的特定于类型的编码。</p><p id="158b" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">我们标为<code class="fe nj nk nl nm b">Forwarder.sol</code>的示例智能契约实现了EIP-712域分隔符(<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/utils#EIP712-_domainSeparatorV4--" rel="noopener ugc nofollow" target="_blank">_domainSeparatorV4</a></code>)，它被用作编码方案的一部分，编码的最后一步是获得消息摘要，然后通过<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA" rel="noopener ugc nofollow" target="_blank">ECDSA</a></code> ( <code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/utils#EIP712-_hashTypedDataV4-bytes32-" rel="noopener ugc nofollow" target="_blank">_hashTypedDataV4</a></code>)对消息摘要进行签名。</p><p id="2bfa" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">域分隔符的<a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/utils#EIP712" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin实现</a>被设计为尽可能高效，同时仍然正确地更新链ID，以防止对链的最终分支的重放攻击。</p><p id="d5f0" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated"><strong class="ln iu">注意:</strong>smart contract forwarder . sol实现称为“v4”的编码版本，由MetaMask 中的JSON RPC方法<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.metamask.io/guide/signing-data.html#sign-typed-data-v4" rel="noopener ugc nofollow" target="_blank">eth_signTypedDataV4</a></code> <a class="ae kj" href="https://docs.metamask.io/guide/signing-data.html#sign-typed-data-v4" rel="noopener ugc nofollow" target="_blank">实现。</a></p><h1 id="528b" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak"> Forwarder契约——以太坊上可扩展元交易转发的智能契约</strong></h1><p id="f32c" class="pw-post-body-paragraph ll lm it ln b lo ne ju lq lr nf jx lt lu ng lw lx ly nh ma mb mc ni me mf lk im bi translated">智能合同<code class="fe nj nk nl nm b">Forwarder.sol</code>扩展了<a class="ae kj" href="https://eips.ethereum.org/EIPS/eip-2770" rel="noopener ugc nofollow" target="_blank"> EIP-2770 </a>，并包含以下核心功能:</p><ul class=""><li id="c4dd" class="no np it ln b lo mg lr mh lu nq ly nr mc ns lk nt nu nv nw bi translated"><code class="fe nj nk nl nm b">verify</code>:基于类型化的结构化数据验证签名。</li></ul><pre class="kl km kn ko gt nx nm ny nz aw oa bi"><span id="b176" class="ob mn it nm b gy oc od l oe of">/**<br/> * <a class="ae kj" href="http://twitter.com/dev" rel="noopener ugc nofollow" target="_blank">@dev</a> Verifies the signature based on typed structured data. <br/> * See <a class="ae kj" href="https://eips.ethereum.org/EIPS/eip-712" rel="noopener ugc nofollow" target="_blank">https://eips.ethereum.org/EIPS/eip-712</a><br/> */<br/>function <strong class="nm iu">verify</strong>(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {<br/>    address signer = _hashTypedDataV4(keccak256(abi.encode(<br/>        _TYPEHASH,<br/>        req.from,<br/>        req.to,<br/>        req.value,<br/>        req.gas,<br/>        req.nonce,<br/>        keccak256(req.data)<br/>    ))).recover(signature);<br/>    return _nonces[req.from] == req.nonce &amp;&amp; signer == req.from;<br/>}</span></pre><ul class=""><li id="33dc" class="no np it ln b lo mg lr mh lu nq ly nr mc ns lk nt nu nv nw bi translated"><code class="fe nj nk nl nm b">execute</code>:通过底层调用执行元事务。</li></ul><pre class="kl km kn ko gt nx nm ny nz aw oa bi"><span id="067c" class="ob mn it nm b gy oc od l oe of">/**<br/> * <a class="ae kj" href="http://twitter.com/dev" rel="noopener ugc nofollow" target="_blank">@dev</a> Main function; executes the meta-transaction via a low-level call.<br/> */<br/>function <strong class="nm iu">execute</strong>(ForwardRequest calldata req, bytes calldata signature) public payable whenNotPaused() returns (bool, bytes memory) {<br/>    require(_senderWhitelist[msg.sender], "AwlForwarder: sender of meta-transaction is not whitelisted");<br/>    require(verify(req, signature), "AwlForwarder: signature does not match request");<br/>    _nonces[req.from] = req.nonce + 1;</span><span id="5563" class="ob mn it nm b gy og od l oe of">    // solhint-disable-next-line avoid-low-level-calls<br/>    (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(abi.encodePacked(req.data, req.from));<br/>    <br/>    if (!success) {<br/>        // solhint-disable-next-line no-inline-assembly<br/>        assembly {<br/>        returndatacopy(0, 0, returndatasize())<br/>        revert(0, returndatasize())<br/>        }<br/>    }</span><span id="6250" class="ob mn it nm b gy og od l oe of">    /**<br/>     * <a class="ae kj" href="http://twitter.com/dev" rel="noopener ugc nofollow" target="_blank">@dev</a> Validates that the relayer/forwarder EOA has sent enough gas for the call.<br/>     * See <a class="ae kj" href="https://ronan.eth.link/blog/ethereum-gas-dangers/" rel="noopener ugc nofollow" target="_blank">https://ronan.eth.link/blog/ethereum-gas-dangers/</a>.<br/>     */<br/>    assert(gasleft() &gt; req.gas / 63);</span><span id="1c46" class="ob mn it nm b gy og od l oe of">    emit MetaTransactionExecuted(req.from, req.to, req.data);</span><span id="0ec8" class="ob mn it nm b gy og od l oe of">    return (success, returndata);<br/>}</span></pre><blockquote class="oh oi oj"><p id="0644" class="ll lm ml ln b lo mg ju lq lr mh jx lt ok mi lw lx ol mj ma mb om mk me mf lk im bi translated">完整的智能合同可在<a class="ae kj" href="https://github.com/pcaversaccio/metatx/blob/main/contracts/Forwarder.sol" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></blockquote><h1 id="c138" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">安全考虑</h1><p id="7d5c" class="pw-post-body-paragraph ll lm it ln b lo ne ju lq lr nf jx lt lu ng lw lx ly nh ma mb mc ni me mf lk im bi translated">为了确保重放保护，我们跟踪链上的一个<code class="fe nj nk nl nm b">nonce</code>映射。此外，为了防止任何人传播具有潜在恶意的交易，<code class="fe nj nk nl nm b">Forwarder.sol</code>智能合约为<code class="fe nj nk nl nm b">execute</code>功能实现了一个白名单。此外，智能契约是<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable" rel="noopener ugc nofollow" target="_blank">Ownable</a></code>，它提供了一个基本的访问控制机制，其中有一个EOA(一个<code class="fe nj nk nl nm b">owner</code>，它被授予对特定功能(即<code class="fe nj nk nl nm b">addSenderToWhitelist</code>、<code class="fe nj nk nl nm b">removeSenderFromWhitelist</code>、<code class="fe nj nk nl nm b">killForwarder</code>、<code class="fe nj nk nl nm b">pause</code>、<code class="fe nj nk nl nm b">unpause</code>)的独占访问权。此外，智能合约功能<code class="fe nj nk nl nm b">execute</code>为<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/security#Pausable" rel="noopener ugc nofollow" target="_blank">Pausable</a></code>，即实现可由<code class="fe nj nk nl nm b">owner</code>触发的紧急停止机制。最后，作为紧急备份，通过功能<code class="fe nj nk nl nm b">killForwarder</code>执行<code class="fe nj nk nl nm b">selfdestruct</code>操作。</p><ul class=""><li id="4dfd" class="no np it ln b lo mg lr mh lu nq ly nr mc ns lk nt nu nv nw bi translated"><strong class="ln iu">注1: </strong>白名单中的eoa在发送交易前仔细检查编码(用户签名)<code class="fe nj nk nl nm b">calldata</code>非常重要。</li><li id="5a39" class="no np it ln b lo on lr oo lu op ly oq mc or lk nt nu nv nw bi translated"><strong class="ln iu">注2: </strong> <code class="fe nj nk nl nm b">calldata</code>是存储函数外部调用数据的地方。函数可以在内部调用，例如从契约内部调用，也可以在外部调用。当函数的可见性是外部的时，只有外部契约可以调用该函数。当这样的外部呼叫发生时，该呼叫的数据存储在<code class="fe nj nk nl nm b">calldata</code>中。</li><li id="7edd" class="no np it ln b lo on lr oo lu op ly oq mc or lk nt nu nv nw bi translated"><strong class="ln iu">注3: </strong>对于函数<code class="fe nj nk nl nm b">addSenderToWhitelist</code>和<code class="fe nj nk nl nm b">killForwarder</code>，我们并没有实现一个专用的严格策略来从不允许零地址<code class="fe nj nk nl nm b">0x0000000000000000000000000000000000000000</code>。这样做的原因是，首先，这些功能受到了<code class="fe nj nk nl nm b"><a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable" rel="noopener ugc nofollow" target="_blank">Ownable</a></code>的保护，其次，可以说像<code class="fe nj nk nl nm b">0x00000000000000000000000000000000000001</code>这样的地址同样危险，但我们对此无动于衷。</li></ul><h1 id="5d0c" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">“允许”和“执行”的签名用户数据(输入参数)</h1><p id="9160" class="pw-post-body-paragraph ll lm it ln b lo ne ju lq lr nf jx lt lu ng lw lx ly nh ma mb mc ni me mf lk im bi translated">我准备了一个基于JavaScript的示例脚本，可以在这里访问<a class="ae kj" href="https://github.com/pcaversaccio/metatx/blob/main/scripts/sign-data.js" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="46db" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated"><strong class="ln iu">注:</strong>函数调用的<code class="fe nj nk nl nm b">calldata</code>的前四个字节指定要调用的函数。它是函数签名的<code class="fe nj nk nl nm b">keccak256</code>散列的第一个(左，高位字节)四个字节。因此，由于1个半字节(4位)可以由一个十六进制数字表示，所以我们有4个字节= 8个十六进制数字。</p><h1 id="5cc0" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结束语</h1><p id="d7c6" class="pw-post-body-paragraph ll lm it ln b lo ne ju lq lr nf jx lt lu ng lw lx ly nh ma mb mc ni me mf lk im bi translated">需要强调的是，整个代码库都没有经过审计，所以使用时风险自担(并且首先在一个实时测试网络上进行测试)。</p><p id="4506" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">此外，有人可能会说，由于可暂停的功能，像<code class="fe nj nk nl nm b">killForwarder</code>这样的定制函数是不必要的。在这里，我并不要求完美的智能契约，而是提供了一个良好的平台，其中考虑了足够多的安全方面(如重播保护)。</p><p id="8602" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">此外，一套完整的单元测试是可用的<a class="ae kj" href="https://github.com/pcaversaccio/metatx/blob/main/test/Forwarder.test.js" rel="noopener ugc nofollow" target="_blank">这里</a>实现了100%的测试覆盖率。然而，非常重要的是，100%的测试覆盖率并不意味着没有漏洞。真正重要的是测试本身的质量和范围。</p><p id="2e68" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">最终，上述方法绝不是路的尽头，但是存在潜在的弱点，例如关于支付者的分散化。</p><p id="5417" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">一个解决这个问题并实现了高级实现架构的项目是<a class="ae kj" href="https://docs.opengsn.org" rel="noopener ugc nofollow" target="_blank">以太坊加油站网络</a> (GSN)。去看看吧！</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="545e" class="mm mn it bd mo mp oz mr ms mt pa mv mw jz pb ka my kc pc kd na kf pd kg nc nd bi translated">更多参考</h1><p id="9fee" class="pw-post-body-paragraph ll lm it ln b lo ne ju lq lr nf jx lt lu ng lw lx ly nh ma mb mc ni me mf lk im bi translated">[1]<a class="ae kj" href="https://github.com/pcaversaccio/metatx" rel="noopener ugc nofollow" target="_blank">https://github.com/pcaversaccio/metatx</a></p><p id="74a0" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">[2]<a class="ae kj" href="https://soliditydeveloper.com/meta-transactions" rel="noopener ugc nofollow" target="_blank">https://soliditydeveloper.com/meta-transactions</a></p><p id="4043" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">[3]https://docs.openzeppelin.com/contracts/4.x/api/metatx<a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/api/metatx" rel="noopener ugc nofollow" target="_blank"/></p><p id="eabc" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">[4]https://docs.opengsn.org<a class="ae kj" href="https://docs.opengsn.org" rel="noopener ugc nofollow" target="_blank"/></p><p id="7aca" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated">[5]<a class="ae kj" href="https://eips.ethereum.org/EIPS/eip-2612" rel="noopener ugc nofollow" target="_blank">https://eips.ethereum.org/EIPS/eip-2612</a></p><p id="89c6" class="pw-post-body-paragraph ll lm it ln b lo mg ju lq lr mh jx lt lu mi lw lx ly mj ma mb mc mk me mf lk im bi translated"><a class="ae kj" href="https://eips.ethereum.org/EIPS/eip-712" rel="noopener ugc nofollow" target="_blank">https://eips.ethereum.org/EIPS/eip-712</a></p></div></div>    
</body>
</html>