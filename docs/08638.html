<html>
<head>
<title>7 Tips for Using React Query in Large Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在大型项目中使用React Query的7个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-tips-for-using-react-query-in-large-projects-22ccc49d61c2?source=collection_archive---------0-----------------------#2021-05-25">https://betterprogramming.pub/7-tips-for-using-react-query-in-large-projects-22ccc49d61c2?source=collection_archive---------0-----------------------#2021-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7963" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">副作用回调、手动使缓存数据无效等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/170c317f316dc9c6567c42e479ef7fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Svaf5b9izSvX-g_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上，由<a class="ae ky" href="https://unsplash.com/@amayli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿姆莉·莫里雄</a>拍摄的照片。</p></figure><p id="cc97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索一些在现实世界的代码库中使用<a class="ae ky" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> React Query </a>的技巧和诀窍，这将帮助您保持项目的可维护性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动机</h1><p id="5e7c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我的目标是以要点的形式提供一些技巧，这些技巧是我在一年多的时间里经常在企业应用程序上使用react-query时学到的。</p><p id="f258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当开始使用一个新工具时，不缺少内容，<em class="mz"> </em>和React Query也不例外，通常使用一个小应用程序作为参考(例如待办事项列表或计数器)。这很好，不会因为精心设计的领域逻辑而分散观众的注意力。然而，当考虑像企业应用程序或大型代码库这样的真实世界的例子时，需要更多的指导。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b174" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">初步资源</h1><p id="db06" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文假设对React Query的工作原理有一些基本的了解。要开始并更熟悉它，请随意查看我以前的文章。另外，看看他们精彩的<a class="ae ky" href="https://react-query.tanstack.com/overview" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="3b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对<code class="fe na nb nc nd b"><a class="ae ky" href="https://react-query.tanstack.com/reference/useQuery" rel="noopener ugc nofollow" target="_blank">useQuery</a></code>和<code class="fe na nb nc nd b"><a class="ae ky" href="https://react-query.tanstack.com/reference/useMutation" rel="noopener ugc nofollow" target="_blank">useMutation</a></code>钩子的工作原理有一个非常基本的了解，你就可以开始了。</p><p id="06c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说完了，我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c329" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.将React查询挂钩包装到您自己的定制挂钩中</h1><p id="316b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不要直接从React组件中调用<code class="fe na nb nc nd b"><a class="ae ky" href="https://react-query.tanstack.com/reference/useQuery" rel="noopener ugc nofollow" target="_blank">useQuery</a></code>和<code class="fe na nb nc nd b"><a class="ae ky" href="https://react-query.tanstack.com/reference/useMutation" rel="noopener ugc nofollow" target="_blank">useMutation</a></code>，而是将它们包装在您自己定制的钩子中。这将提供一个清晰的关注点分离，拥有一个分离的数据层和表示层。它还将消除将API获取函数导入React组件的需要。</p><p id="80ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它将允许您重用包含更多复杂性的钩子，我们将在本文后面讨论。</p><p id="8c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="32d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢在一个文件中有几个这样的定制钩子，按域分组。在前面的例子中，我们可以让多个钩子与同一个文件中的<code class="fe na nb nc nd b">'items'</code>域交互。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e496" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.为了避免正确钻孔，将状态集中在需要的位置附近</h1><p id="729f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster" rel="noopener ugc nofollow" target="_blank">状态托管</a>是保持应用程序可维护性的最佳策略之一。</p><p id="62d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在早期使用React Query时犯的一个错误(盲目地遵循<a class="ae ky" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">智能和非智能组件模式</a>)是在一个高级组件中导入React查询挂钩，并通过props将数据传递给低级组件。这在几个级别上运行良好，但是随着我的应用程序的增长，众所周知的<a class="ae ky" href="https://kentcdodds.com/blog/prop-drilling" rel="noopener ugc nofollow" target="_blank">支柱钻孔</a>成为了一个问题。</p><p id="bd01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，从多个组件调用React查询钩子来访问同一块缓存数据几乎没有任何障碍，因此，您可以在那些确实需要数据的组件中调用钩子，而不是通过props传递一些数据。在本文的后面，我们将看到如何最小化执行的API请求的数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c637" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.通过设置过时配置属性来防止不必要的API请求</h1><p id="dd6d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React Query带有一些默认值，可能会让您措手不及。根据他们的<a class="ae ky" href="https://react-query.tanstack.com/guides/important-defaults" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="ng nh ni"><p id="693d" class="kz la mz lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">默认情况下，通过useQuery或useInfiniteQuery的查询实例将缓存的数据视为陈旧数据。</p><p id="2265" class="kz la mz lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">要改变这种行为，您可以使用staleTime选项对查询进行全局和逐个配置。指定较长的失效时间意味着查询将不会频繁地重新获取数据</p><p id="7a1d" class="kz la mz lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">在以下情况下，将在后台自动重新获取过时查询:</p><p id="043b" class="kz la mz lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">查询装载的新实例</p><p id="6a28" class="kz la mz lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">窗口被重新聚焦</p><p id="442f" class="kz la mz lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">网络重新连接。</p><p id="a744" class="kz la mz lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">该查询可选地配置有重新获取间隔。"</p></blockquote><p id="94c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用默认配置，如果您不止一次调用查询函数，那么您将获得与您调用它的次数一样多的API请求。</p><p id="c411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的需要，您可以使用<code class="fe na nb nc nd b">staleTime</code> config prop来节省一些请求。我在当前项目中放置了30秒的过时时间，这意味着缓存数据将在30秒内有效，因此只要我不显式地使缓存无效，在这个时间范围内就不会执行新的请求。</p><p id="beae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止请求超过您需要的数量，在初始化React查询时，将<code class="fe na nb nc nd b">staleTime</code>配置属性设置到<code class="fe na nb nc nd b">QueryClient</code>对象中。然后，只要缓存仍然新鲜，您就可以多次调用同一个挂钩，而不会触发多个API请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="df0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">注意:这里提出的建议是基于我当前项目的需求，可能与你的一致，也可能不一致。根据数据的特殊性，您可以给自己或多或少的陈旧时间。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="12b2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.对副作用使用onSuccess和onError回调</h1><p id="f7ac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">利用提供的回调来执行副作用——特别是但不限于<code class="fe na nb nc nd b">onSuccess</code>和<code class="fe na nb nc nd b">onError</code>。让我们考虑一个例子，每次<code class="fe na nb nc nd b">'items'</code>变异时都需要呈现一条toast消息，但是您可以在变异或查询之前或之后放置任何您想要的代码片段作为副作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意我是如何将包含<code class="fe na nb nc nd b">onSuccess</code>和<em class="mz"> </em> <code class="fe na nb nc nd b">onError</code>回调的对象作为第二个参数传递给<code class="fe na nb nc nd b">useMutation</code>钩子的。</p><p id="171c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法通过利用钩子来做重复的或特定于域逻辑的副作用，从组件中去除了大量的复杂性。</p><p id="3414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe na nb nc nd b">onSuccess</code>和<code class="fe na nb nc nd b">onError</code>还有其他有用的回调，虽然那些是我用的最多的。在<a class="ae ky" href="https://react-query.tanstack.com/reference/useMutation#_top" rel="noopener ugc nofollow" target="_blank">正式文件</a>中查看。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5fb2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.手动使过期数据的缓存失效</h1><p id="4f3d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您的缓存过期时，使用<code class="fe na nb nc nd b">invalidateQueries</code>函数使其无效并自动重新获取。</p><p id="7e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再想一个例子。您已经从服务器获取了一个项目列表，并且已经使用React Query对它们进行了缓存。然后你添加一个新的项目。这使得最初从服务器获取的数据无效，因为项目列表已经更改。</p><p id="c528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上一篇技巧文章中介绍的场景类似，让我们利用React Query的回调来使过时的缓存失效，这是变异的副作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们正在调用<code class="fe na nb nc nd b">useQueryClient</code>钩子来访问缓存，并调用<code class="fe na nb nc nd b">invalidateQueries</code>函数来使与<code class="fe na nb nc nd b">ServerStateKeysEnum.Items</code>查询关键字对应的缓存无效。这将导致API在使用<code class="fe na nb nc nd b">useGetItems</code>钩子需要对应于那个键的缓存时重新获取。</p><p id="58ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这节省了大量的工作，因为您不再担心每次发生变化时手动重新获取API数据。相反，您可以让React Query来处理它</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dbcb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.通过启用/禁用查询控制对数据的访问</h1><p id="136b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时候你想呈现一个包含一个<code class="fe na nb nc nd b">useQuery</code>钩子的组件，但是你不想让它获取数据。</p><p id="3734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们想一个例子。我们希望用户只有在对系统拥有有效订阅的情况下才能获取<em class="mz">项</em>。当然，这也需要在服务器端进行验证，但是在客户端进行快速检查可以防止不必要的请求。</p><p id="d8f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React Query提供了一个名为<code class="fe na nb nc nd b"><a class="ae ky" href="https://react-query.tanstack.com/guides/disabling-queries" rel="noopener ugc nofollow" target="_blank">enabled</a></code>的选项，它接收一个布尔值。如果布尔值为<code class="fe na nb nc nd b">false</code>，则不会执行查询功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fc94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意我是如何修改<code class="fe na nb nc nd b">useGetItems</code>来接收一个<code class="fe na nb nc nd b">options</code>对象作为参数的。通过这样做，您可以直接从组件中提供选项，例如，启用或禁用查询。您也可以提供自己的<code class="fe na nb nc nd b">onSuccess</code>或<code class="fe na nb nc nd b">onError</code>回调。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="82fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.避免混合用户界面和服务器缓存</h1><p id="f831" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Kent C. Dodds对UI状态和服务器状态有一个很好的定义:</p><blockquote class="ng nh ni"><p id="b703" class="kz la mz lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">“服务器缓存—实际存储在服务器上的状态，我们存储在客户端以供快速访问(如用户数据)。</p><p id="e833" class="kz la mz lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">UI状态——仅在UI中用于控制应用程序交互部分的状态(如模态isOpen状态)。"</p></blockquote><p id="cb38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要将服务器缓存与UI状态混淆。随着应用程序的增长，UI状态也会增长。在适当的情况下，您可以依靠React上下文或第三方库来实现自己的状态管理解决方案。无论您采用哪种方法，都不在本文的讨论范围之内。然而，一个重要的建议是尽量避免将React Query管理的服务器缓存与您选择的武器处理的UI状态混淆。</p><p id="b699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器缓存本质上具有不同的行为，并带来不同的挑战。虽然UI状态通常具有同步行为，但是状态缓存是异步的。</p><p id="a3fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">混合服务器缓存和UI状态会产生可维护性问题，随着应用程序的增长，这个问题会变得更加明显。我的建议是选择适合您处理UI状态需求的任何方法，但是让React Query自己为来自服务器的数据施展魔法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e0dd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b559" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React Query仍然是一个频繁更新的新工具，因此人们不断地创建模式并发现使用该库的有效方法。</p><p id="9a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。敬请关注未来更多内容！</p></div></div>    
</body>
</html>