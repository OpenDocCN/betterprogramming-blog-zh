<html>
<head>
<title>Kubernetes GraphQL Dynamic Query in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的Kubernetes GraphQL动态查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-graphql-dynamic-query-in-go-b6cc3ab5490f?source=collection_archive---------15-----------------------#2022-06-09">https://betterprogramming.pub/kubernetes-graphql-dynamic-query-in-go-b6cc3ab5490f?source=collection_archive---------15-----------------------#2022-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c10f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用客户端玩点魔法-去发现客户端</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/530782932d6551fb574d15de8151dfde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0gROIl4buWGCAIsHWnAiw.png"/></div></div></figure><p id="7db3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go<em class="lr"/>中的第一集<a class="ae lq" href="https://laiyuanyuan-sg.medium.com/kubernetes-graphql-query-in-go-2f88af8f0d67" rel="noopener"> <em class="lr"> Kubernetes GraphQL查询中，我们构建了使用GraphQL查询集群中pod的服务器代码。然而，由于相关的<code class="fe ls lt lu lv b">graphql.Feilds</code>的定义都是硬编码的，这需要重构，所以这种查询在灵活性和可伸缩性方面很差。</em></a></p><p id="f812" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">于是<em class="lr">动态查询第二集来了，</em>使用<code class="fe ls lt lu lv b">client-go <a class="ae lq" href="https://pkg.go.dev/k8s.io/client-go@v0.24.1/discovery#DiscoveryClient" rel="noopener ugc nofollow" target="_blank">DiscoveryClient</a></code>灵活定义GraphQL查询结构。</p><h1 id="3187" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">自定义资源定义(</strong> CRD)</h1><p id="3be4" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">大多数Kubernetes用户都知道，像<code class="fe ls lt lu lv b">Pod</code>、<code class="fe ls lt lu lv b">Deployment</code>这样的Kubernetes资源对象都是Kubernetes原生资源类型，本质上一个Kubernetes原生<a class="ae lq" href="https://medium.com/swlh/kubernetes-operator-for-beginners-what-why-how-21b23f0cb9b1" rel="noopener"> Operato </a> r就像那些用户定制的操作员一样，是以<strong class="kw iu"> CRD +控制器</strong>的形式实现的。唯一的区别是本地资源类型分散在Kubernetes源代码的不同包中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/8edd57d4db0bcf2d7143d4e02505dccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dVtRokKe4Ym2jMVK"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">操作员如何处理</p></figure><ul class=""><li id="3b52" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">用户向集群提交符合CRD定义的YAML。</li><li id="6c0a" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">Kubernetes APIServer基于相关的CRD类型在<code class="fe ls lt lu lv b">etcd</code>存储资源。</li><li id="9928" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">CRD对应控制器找到要处理的资源并执行协调过程，包括更新资源状态。</li><li id="2c2a" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">将最新的资源状态保存到<code class="fe ls lt lu lv b">etcd</code>。</li></ul><p id="8498" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很容易得出结论，<strong class="kw iu"> CRD是对应于Kubernetes资源类型</strong>的模式，就像数据库表的DDL语句，或者XML文件的XSD文件。</p><h1 id="21c3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">读取模式</h1><p id="28c8" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">在构建与集群中所有资源类型相对应的GraphQL查询时，我们面临的第一个困难是如何获取所有资源类型的模式。</p><h2 id="b056" class="nm lx it bd ly nn no dn mc np nq dp mg ld nr ns mi lh nt nu mk ll nv nw mm nx bi translated">Kubectl命令</h2><p id="0a8d" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">命令总是我们在Kubernetes相关查询中尝试的第一种方法。</p><p id="2b28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当前集群中的所有资源类型都可以用<code class="fe ls lt lu lv b">kubectl get api-resources</code>返回，比如<code class="fe ls lt lu lv b">Pod</code>、<code class="fe ls lt lu lv b">Deployment</code>等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/392bc4c5e3a7c2e1081c2d015d7ed1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fLgbK8LiXAZp6pMo"/></div></div></figure><p id="b937" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在运行<code class="fe ls lt lu lv b">kubectl get crd</code>时，我们没有看到像<code class="fe ls lt lu lv b">pod</code>那样的本地资源类型的返回。</p><p id="6f79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们肯定需要寻求一个补充来找到原生资源类型的模式，让我们尝试一些。</p><ul class=""><li id="cb43" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">一些YAML验证工具，比如<code class="fe ls lt lu lv b">kubeval</code>，它指向一些包含各种Kubernetes版本模式的GitHub存储库，比如<a class="ae lq" href="https://github.com/yannh/kubernetes-json-schema" rel="noopener ugc nofollow" target="_blank">yannh/Kubernetes-JSON-schema</a>。这些GitHub模式也支持通过相应的URL获取JSON版本模式，比如版本1.22.8的<a class="ae lq" href="https://raw.githubusercontent.com/yannh/kubernetes-json-schema/master/v1.22.8/_definitions.json#/definitions/io.k8s.api.core.v1.Pod" rel="noopener ugc nofollow" target="_blank"> pod模式</a>。</li><li id="574b" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><code class="fe ls lt lu lv b">kubectl explain</code>命令，可以打印相应类型的模式。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/d31b35a5c43e38a47e69ebf943cfeac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0i34BTpNDIKN78S9"/></div></div></figure><p id="d37e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但以上两种方法都有隐藏的缺陷:第一种受版本限制，一旦集群升级就需要代码升级；第二个只能返回被搜索类型的模式，而不能返回嵌套类型的模式，并且不支持JSON格式。</p><ul class=""><li id="9e13" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated"><strong class="kw iu"> Discovery API，是我最终发现的真正可以扫除棘手问题的东西</strong>。</li></ul><blockquote class="oa ob oc"><p id="11c7" class="ku kv lr kw b kx ky ju kz la lb jx lc od le lf lg oe li lj lk of lm ln lo lp im bi translated">discovery包用于发现Kubernetes API服务器支持的API。</p><p id="7121" class="ku kv lr kw b kx ky ju kz la lb jx lc od le lf lg oe li lj lk of lm ln lo lp im bi translated">OpenAPISchema使用rest客户机获取open api v2模式，并解析proto。</p></blockquote><p id="6e6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ls lt lu lv b">DiscoveryClient</code>中的<a class="ae lq" href="https://pkg.go.dev/k8s.io/client-go@v0.24.1/discovery#DiscoveryClient.OpenAPISchema" rel="noopener ugc nofollow" target="_blank"> OpenAPISchema </a> API返回集群中定义的所有类型的模式定义。从它的简介中你无法完全感受到这个API的强大，尤其是在<code class="fe ls lt lu lv b">client-go</code>中没有展示相关的例子时。</p><p id="1d70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是多尝试永远不会让你失望。一开始，我只是在Kubernetes文档“CRD是一个可选的基于OpenAPI v3的验证模式”的指导下，尝试使用这个API来获得CRD的定义然后我幸运地发现，它可以返回集群中的所有模式定义，包括原生类型。</p><h2 id="40a3" class="nm lx it bd ly nn no dn mc np nq dp mg ld nr ns mi lh nt nu mk ll nv nw mm nx bi translated">Kubernetes API</h2><p id="7d4e" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">让我们深入挖掘一下，看看为什么<code class="fe ls lt lu lv b">OpenAPISchema </code>函数可以返回所有模式？</p><p id="9873" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没什么神奇的，只是通过简单地调用Kubernetes API。</p><pre class="kj kk kl km gt og lv oh oi aw oj bi"><span id="8baa" class="nm lx it lv b gy ok ol l om on">d.restClient.Get().AbsPath(“/openapi/v2”).SetHeader(“Accept”, openAPIV2mimePb).Do(context.TODO()).Raw()</span></pre><p id="79d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">返回到之前的<code class="fe ls lt lu lv b">kubectl explain</code>命令，添加<code class="fe ls lt lu lv b">-v</code>标志，并再次运行。</p><p id="13b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ls lt lu lv b">kubectl explain pods -v 9</code>显示器</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/520112c0630bffa60316a6e93b581f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TV5Lg0A7OdBxacer"/></div></div></figure><p id="516b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由此可见，是<a class="ae lq" href="https://kubernetes.io/id/docs/concepts/overview/kubernetes-api/#swagger-and-openapi-definition" rel="noopener ugc nofollow" target="_blank"> OpenApi </a>在<code class="fe ls lt lu lv b">explain</code>命令之后进行处理，但接收的是<code class="fe ls lt lu lv b">protobuf</code>格式的数据，并为用户提供了更高的可读性。</p><p id="083e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以尝试在CLI中调用<code class="fe ls lt lu lv b">OpenApi</code>，下面的命令是针对GKE的。</p><pre class="kj kk kl km gt og lv oh oi aw oj bi"><span id="304b" class="nm lx it lv b gy ok ol l om on">curl -X GET https://{ip}/openapi/v2 --header "Authorization: Bearer $(gcloud auth application-default print-access-token)" --insecure</span></pre><h1 id="7b78" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">解析模式</h1><p id="45c3" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">我们需要充分理解我们得到的信息，然后才能很好地利用它。</p><p id="9f20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将<code class="fe ls lt lu lv b">curl</code>命令的输出导出到一个文件中，我们可以看到得到的只是Kubernetes中每个API的分析，就像swagger API文档一样。向下滚动到底部可以看到<code class="fe ls lt lu lv b">definitions</code>，其中显示了所有资源类型的所有字段的定义。</p><p id="69b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Pod定义会很长，所以以下面的<code class="fe ls lt lu lv b">resources</code>字段为例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="4fe6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ls lt lu lv b">client-go</code>已经将模式解析成openapi_v2 <code class="fe ls lt lu lv b"><a class="ae lq" href="https://pkg.go.dev/github.com/google/gnostic/openapiv2#Document" rel="noopener ugc nofollow" target="_blank">Document</a></code>，准备应用于开发。</p><p id="de2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但有一个问题不容忽视:在返回所有资源类型的情况下，很难区分真正的顶级资源类型，例如，我们不希望用户查询PodAffinity，而只希望用户查询Pods。</p><p id="3dba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ls lt lu lv b">DiscoveryClient</code>还提供API <code class="fe ls lt lu lv b"><a class="ae lq" href="https://pkg.go.dev/k8s.io/client-go@v0.24.1/discovery#DiscoveryClient.ServerGroups" rel="noopener ugc nofollow" target="_blank">ServerGroups</a></code>和<code class="fe ls lt lu lv b"><a class="ae lq" href="https://pkg.go.dev/k8s.io/client-go@v0.24.1/discovery#DiscoveryClient.ServerResourcesForGroupVersion" rel="noopener ugc nofollow" target="_blank">ServerResourcesForGroupVersion</a></code>来帮助构建所需的<code class="fe ls lt lu lv b">GKV</code> (GroupKindVersion)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="ea1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们终于可以开始解析模式了。</p><ul class=""><li id="c772" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">找到要解析的资源类型</li><li id="eb7a" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">查找类型中的字段。</li><li id="4923" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">建立相应的<code class="fe ls lt lu lv b">graphql.Fields</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="7c5d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">构建GraphQL查询</h1><p id="aa26" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">这一步的关键是通过<code class="fe ls lt lu lv b">graphqlType</code>函数在相应的Kubernetes Go类型和GraphQL类型之间建立连接。</p><ul class=""><li id="0909" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">对于普通型，直接连接。诸如</li></ul><pre class="kj kk kl km gt og lv oh oi aw oj bi"><span id="b91a" class="nm lx it lv b gy ok ol l om on">// a TypeItem from the schema<br/>switch openApiType {<br/>case "boolean":<br/>   return graphql.Boolean<br/>case "integer":<br/>   return graphql.Int<br/>case "number":<br/>   return graphql.Float<br/>case "string":<br/>   return graphql.String</span></pre><ul class=""><li id="818e" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">对于对象类型，在递归解析后在GraphQL中构建对象类型。</li></ul><pre class="kj kk kl km gt og lv oh oi aw oj bi"><span id="0938" class="nm lx it lv b gy ok ol l om on">case "object":<br/>   objectFields := parse(document, schema)<br/>   return graphql.NewObject(graphql.ObjectConfig{<br/>      Name:        rt.Kind + "Props",<br/>      Description: schema.GetDescription(),<br/>      Fields:      objectFields,<br/>   })</span></pre><ul class=""><li id="b102" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">对于数组类型，解析第一个元素对应的GraphQL类型，然后组合成GraphQL列表类型。</li></ul><pre class="kj kk kl km gt og lv oh oi aw oj bi"><span id="7b79" class="nm lx it lv b gy ok ol l om on">case "array":<br/>   iType = graphqlType(docuemnt, possible_type,     schema.GetItems().GetSchema()[0])<br/>   return graphql.NewList(iTypes)</span></pre><p id="338b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">循环之后，我们得到了集群中所有资源类型对应的GraphQL <code class="fe ls lt lu lv b">Fields</code>，可以进一步组合成一个GraphQL <code class="fe ls lt lu lv b">Object</code>。</p><p id="c45d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们在<code class="fe ls lt lu lv b">localhost:8080/graphql</code>做一个快速测试。重新运行程序，并尝试获取关于<code class="fe ls lt lu lv b">PrometheusRule</code>资源的信息。太棒了。在编辑请求时，GraphQL不仅返回相关信息，还返回相关提示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/390cd7c3e64dec79996ab9cf6d84a433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X9kAEZUrCqNG7KxG"/></div></div></figure><h1 id="026a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">包裹</h1><p id="68c0" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">GraphQL已经推出10年了，但它并没有像REST那样被广泛采用。很难解释为什么，就像你不能理解为什么许多Java程序仍然使用Java8，甚至Java 7一样。</p><p id="1e75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我对GraphQL有信心。与REST相比，它在很多方面都有巨大的优势，比如它大大简化了前端-后端API的设计交互，提高了开发效率。并且被越来越多的互联网公司雇佣，将成为未来的发展标准。</p><p id="2a28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p><h1 id="c6f6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">参考</h1><p id="f99e" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">【k8s.io/client-go/discovery T4】探索套餐—旅行套餐</p></div></div>    
</body>
</html>