<html>
<head>
<title>React Reusable API Calls With Custom Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用自定义挂钩来响应可重用的API调用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-reusable-api-calls-with-custom-hooks-typescript-obviously-a62fda7df1b6?source=collection_archive---------4-----------------------#2022-08-10">https://betterprogramming.pub/react-reusable-api-calls-with-custom-hooks-typescript-obviously-a62fda7df1b6?source=collection_archive---------4-----------------------#2022-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6646" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">显然使用了Typescript</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6580294db72c2c037bc771f1b9b92475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JKxdu2OPYtj930dT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@tata186?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塔蒂亚娜·罗德里格斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d75a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目录:</p><ul class=""><li id="a87f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="#c71e" rel="noopener ugc nofollow">什么是HTTP方法(简单看一下POST和GET) </a></li><li id="03c5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#2af5" rel="noopener ugc nofollow">什么是自定义挂钩？为什么是Typescript？</a></li><li id="10d8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#d8d6" rel="noopener ugc nofollow">带GET的自定义挂钩</a></li><li id="c549" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#923e" rel="noopener ugc nofollow">带立柱的定制挂钩</a></li><li id="c1f8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">结论:<a class="ae kv" href="#466a" rel="noopener ugc nofollow">上得到</a>，<a class="ae kv" href="#48f1" rel="noopener ugc nofollow">最终结论</a></li></ul><h1 id="c71e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">什么是HTTP方法？(快速简介)</h1><p id="a59e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">HTTP提供了一组方法，通过这些方法，web浏览器可以与web服务器进行通信。有4种流行/众所周知的方法:GET、POST、PUT和DELETE。我们将在本文中讨论GET和POST，但还有更多。</p><p id="2a27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> GET </strong>:顾名思义，被设计成一个安全的操作，从服务器中检索一些数据。</p><p id="bf83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> POST: </strong>这个方法允许我们向服务器发送一些数据，例如，向数据库添加一个新的实体。</p><h1 id="2af5" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">什么是自定义挂钩？为什么是typescript？</strong></h1><p id="90d5" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当React切换到功能组件时，它给了我们一些非常酷和强大的工具来构建逻辑、管理状态和设计UI，变得更加容易和快速。所谓的钩子就是一些直接来自React库的特殊函数。有一个约定是，钩子必须以use <em class="nd"> </em>前缀开始，这样它们就很容易被识别。</p><p id="eecc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中之一是<code class="fe ne nf ng nh b">useState</code>，它帮助我们在重新呈现器之间保存动态数据。</p><p id="1bb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个是<code class="fe ne nf ng nh b">useEffect</code>，它允许我们执行副作用，比如调用API、与本地存储交互、使用定时器(setInterval/setTimeout)等。</p><p id="87f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有更多:<code class="fe ne nf ng nh b">useCallback</code>、<code class="fe ne nf ng nh b">useMemo</code>、<code class="fe ne nf ng nh b">useRef</code>等。本文就不讨论了。</p><p id="b6bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自定义钩子是我们创建的一个特殊函数，它利用React在其实现中提供的钩子。这种方法使得代码可以重用，并且对组件隐藏了逻辑，使得代码简洁，组件更容易阅读、理解和维护。</p><h2 id="0593" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated">为什么要打字稿？</h2><p id="f0f2" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">因为它提供了类型检查等功能，允许我们塑造一个对象，以便我们在处理变量时有一个更快更清晰的理解。它也有编译错误，所以我们可以在进入浏览器看到错误之前解决它们。</p><h1 id="d8d6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">带有GET的自定义挂钩</h1><p id="8042" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">正如我们前面看到的，GET用于从服务器检索数据。在React中，这可以通过它最著名的两个钩子来实现:<code class="fe ne nf ng nh b">useState</code>和<code class="fe ne nf ng nh b">useEffect</code>。使用useState，我们可以跟踪检索到的数据、任何潜在的错误，或者数据是否还在路上。使用<code class="fe ne nf ng nh b">useEffect</code>,我们可以执行对服务器的实际调用。</p><p id="2dd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来组件要处理很多逻辑。让我们在一个自定义钩子中提取它，使我们的代码变得干净。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这里会发生什么。我们的定制钩子有两个参数:</p><ul class=""><li id="ff00" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">实际查询字符串(<code class="fe ne nf ng nh b">https://myserver/myroute</code>)</li><li id="ea4e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">第二个是地图功能。它的目的是将服务器返回的any类型的原始对象从客户端塑造成我们的模型。这样做的一些好处是，我们可以利用TS特性，并且总是清楚地看到对象的属性；此外，可能从服务器返回的对象比我们实际需要的属性更多，或者它的结构略有不同。这里更有趣的是函数的返回类型，类型为<code class="fe ne nf ng nh b">T</code>。这表示一个泛型类型，意味着当我们实际调用钩子时，函数必须返回一个我们指定类型的对象。注意函数(hook)定义中的<code class="fe ne nf ng nh b">&lt;T,&gt;</code> <em class="nd"> </em>？这意味着我们的钩子是一个泛型函数。</li></ul><p id="857f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在这里看到我们如何定义我们的模型和一个映射函数的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="76c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们看到定义了三个<code class="fe ne nf ng nh b">useState</code>钩子。第一个表示将从服务器接收的数据。我们在这里可以再次看到泛型(T)类型。<br/>第二个只是一个布尔值，用于标记数据是否仍在加载，最后一个将保存任何可能出现的潜在错误；无论是从服务器还是从我们下面的代码。</p><p id="d20d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们有了执行API调用的<code class="fe ne nf ng nh b">useEffect</code>钩子。首先，我们将loading标志设置为true，表示正在获取数据。然后我们打真正的电话。在调用之后，我们将数据映射到我们的形状，并将加载标志设置回false，以指示调用已经结束。</p><p id="6291" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果出现任何错误，我们将设置错误消息并将标志恢复为false。</p><p id="cfd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们返回3个对象:数据、加载标志和错误。然后，在组件中，我们可以按以下方式使用它。如果加载标志为真，那么我们显示一些加载指示器。否则，如果我们有错误显示一些用户友好的错误信息。如果没有，我们可以愉快地显示数据。</p><h1 id="466a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">获取自定义挂钩的结论</strong></h1><p id="8c35" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这里有趣的是泛型类型和映射函数的使用。如果我们需要调用不同的API，我们只需用特定的查询调用钩子，并实现映射数据的函数。</p><p id="69d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们使用钩子的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9726" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，上面钩子实现中的东西可以用不同的方式实现。状态可以被分组为一个而不是三个。我们可以验证响应状态并相应地返回内容，甚至可以使用错误处理程序回调。我们可以为fetch添加options参数。以此类推，让这篇文章的读者决定什么最适合自己的场景。</p><h1 id="923e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">带立柱的定制挂钩</h1><p id="2500" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">POST的钩子设计和实现与GET略有不同，但不会太多。因为它发送一些数据，我们可以定义一个通过主体发送的数据模型。当然，它也可以有响应数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d942" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们讨论一下不同之处。</p><p id="92e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们现在有两个泛型类型:<code class="fe ne nf ng nh b">BodyData</code>和<code class="fe ne nf ng nh b">ResponseData</code>。<code class="fe ne nf ng nh b">BodyData</code>用于整形需要发送到服务器的体对象，<code class="fe ne nf ng nh b">ResponseData</code>用于整形来自服务器的响应数据。</p><p id="bb67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个钩子实现的另一个显著区别是使用了<code class="fe ne nf ng nh b">useCallback</code>钩子而不是<code class="fe ne nf ng nh b">useEffect</code>。这里，<code class="fe ne nf ng nh b">useCallbacks</code>包装了API调用函数，我们的自定义钩子返回它。我们这样做是为了在自定义钩子返回的函数被传递给子组件的情况下记忆该函数，以防止无用的重新呈现，因为每次React组件重新呈现时，它的函数都会被重新创建。</p><p id="379a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以在点击按钮时调用这个方法，例如，触发POST请求，当然，这也可以应用到GET钩子中。我们可以定义fetch函数，从我们的钩子中返回它，并在我们触发某个动作时调用它，而不是在组件呈现时调用它(<code class="fe ne nf ng nh b">useEffect</code>)。</p><p id="c529" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们还可以为头设置一个参数。</p><h1 id="48f1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">结论</strong></h1><p id="0b0c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">同样，这两个定制挂钩的实现可能会有所不同，并根据开发人员的需求进行改进。值得注意的是TypeScript和泛型类型的用法、映射系统、自定义钩子的用法，以及实现钩子的<code class="fe ne nf ng nh b">useEffect</code>和<code class="fe ne nf ng nh b">useCallback</code>方法之间的区别。你可以随意摆弄它。</p></div></div>    
</body>
</html>