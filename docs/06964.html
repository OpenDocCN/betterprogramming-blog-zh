<html>
<head>
<title>8 Big Ideas From 8 Programming Languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自8种编程语言的8大理念</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/eight-big-ideas-from-eight-programming-languages-f3be5f6c9701?source=collection_archive---------0-----------------------#2020-11-21">https://betterprogramming.pub/eight-big-ideas-from-eight-programming-languages-f3be5f6c9701?source=collection_archive---------0-----------------------#2020-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e6d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">八种不同编程语言的一些定义性特征和思想之旅</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0a2d3a208598ce89dc4fca2b5c939b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrvhtANKMDonnMV_Ky72hw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@luis-gomes-166706?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">路易斯·戈麦斯</a>从<a class="ae ky" href="https://www.pexels.com/photo/blur-close-up-code-computer-546819/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><p id="d4c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">20多年来，我一直喜欢尝试不同的编程语言。这是一次试图回忆那些经历的尝试——那些在每种语言中都非常突出的想法，或者那些我回想起来已经看到其重要性的想法。</p><p id="f7b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个列表非常主观。这是一个代表引起我注意的想法的特性列表。你总会发现有人认为其他一些特征或想法更突出或更重要，但这没关系。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/22ce7c6212e3d6128a7e796e634ae4e1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*2wy7QVM25DQjmhW5mw2cRw.png"/></div></figure><h1 id="d027" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Zig —编译时间代码</h1><p id="a06f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在某些领域，<a class="ae ky" href="https://ziglang.org/" rel="noopener ugc nofollow" target="_blank"> Zig </a>尽管是静态类型的，但几乎表现为动态语言。对于静态类型语言，在编译完代码之前，不会运行任何代码。然而，在Zig中，您可以在编译时将数据标记为已知。如果编译器在编译时无法确定该值，则是编译错误。</p><p id="c987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，完全依赖于编译时已知值的代码被允许在编译时运行，而不是在运行时运行。看看这个简单的例子，它看起来很像用C语言调用<code class="fe na nb nc nd b">printf</code>:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="5753" class="ni me it nd b gy nj nk l nl nm">print("number: {} string: {}", .{num, str});</span></pre><p id="11e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在C中，这是一个有潜在风险的函数调用，因为在运行时，代码必须分析格式字符串以查看要读入多少个参数。但是，格式字符串可能与参数列表不匹配。事实上，这已经足够糟糕了，以至于现代C编译器将此视为特例，并在编译时进行验证。然而，这只是针对<code class="fe na nb nc nd b">printf</code>功能的一个特殊例外。</p><p id="18b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Zig，不需要特殊处理。格式字符串在编译时用特殊的<code class="fe na nb nc nd b">comptime</code>关键字标记为<em class="nn">已知</em>:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="b434" class="ni me it nd b gy nj nk l nl nm">print(comptime format: []const u8, args: anytype)</span></pre><p id="8057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，如果编译器发现它是未知的(例如，因为您从文件中读取该字符串)，那么将产生编译错误，并且您必须确保该格式字符串在编译时确实是已知的。</p><p id="1b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">num</code>和<code class="fe na nb nc nd b">str</code>变量的值在编译时可能未知，但它们的类型是已知的。这允许Zig执行<code class="fe na nb nc nd b">print</code>中的所有代码，它只依赖于格式字符串和参数的类型。</p><p id="42d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以想象这涉及到一堆循环和if语句，根据<code class="fe na nb nc nd b">num</code>和<code class="fe na nb nc nd b">str</code>变量的类型决定调用其他什么函数。在最终编译的函数中，这些代码都将消失，只剩下运行时要执行的代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/4a9fa01e4f9414f1ab88fafa4f4d0d38.png" data-original-src="https://miro.medium.com/v2/format:webp/1*RYacRy484cgSrCQAmxaInQ.png"/></div></figure><h1 id="87fd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">朱莉娅——多重派遣</h1><p id="0b80" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">关于Julia有很多要说的，但是Julia有一个突出的特点，那就是一切都是建立在多重分派之上的。那是什么意思？在Julia术语中，可以有一个函数<code class="fe na nb nc nd b">fight</code>，但是一个函数有多个被称为<em class="nn">方法</em>的实现。因此，我们可以定义多个方法(不要与OOP混淆),例如:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="29c8" class="ni me it nd b gy nj nk l nl nm">fight(a::Archer,  b::Knight)<br/>fight(a::Pikeman, b::Archer)<br/>fight(a::Knight,  b::Knight)</span></pre><p id="e82b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与面向对象编程不同，所有的参数决定运行什么代码，而不仅仅是第一个特殊的参数，比如<code class="fe na nb nc nd b">this</code>或<code class="fe na nb nc nd b">self</code>。不，这不是函数重载，因为这个决定是在运行时做出的，而不是在编译时。编译时不需要知道<code class="fe na nb nc nd b">a</code>和<code class="fe na nb nc nd b">b</code>的类型。</p><p id="9d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在类似游戏的事情上很重要。在编译的时候，你无法知道什么类型的士兵会在游戏中互相战斗。弓箭手打骑士还是枪兵，是玩家在运行时做出的动态决定。</p><p id="5743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用它来定义显示不同数据类型的不同方式。例如，Julia中的所有数据类型都使用<code class="fe na nb nc nd b">show</code>函数来显示任何IO设备上的任何数据类型:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="0e5f" class="ni me it nd b gy nj nk l nl nm">show(io::IO, x)</span></pre><p id="289e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不添加你自己的方法，默认情况下，它会简单地使用反射来发现你的对象<code class="fe na nb nc nd b">x</code>中的字段并显示它。但是您可以定义自己的自定义显示，比如说一个<code class="fe na nb nc nd b">Point</code>类型，使用:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="8040" class="ni me it nd b gy nj nk l nl nm">show(io::IO, p::Point) = print(io, "($(p.x), $(p.y)")</span></pre><p id="60be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于另一个IO设备，以不同的方式表示该点也是可能的:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2f13" class="ni me it nd b gy nj nk l nl nm">show(io::IOBuffer, p::Point) = print(io, "BufPoint($(p.x), $(p.y)")</span></pre><p id="7f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有多重分派，这种灵活性将很难实现。要么<code class="fe na nb nc nd b">Point</code>类型必须实现一些序列化接口，要么您必须修改一个<code class="fe na nb nc nd b">IO</code>基类及其子类来接受新的<code class="fe na nb nc nd b">Point</code>类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/c2a0e817412cb6cb611713e2499335c0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*NYuyB302V_QDr9-uLvAKxw.png"/></div></figure><h1 id="8b76" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Swift —可选</h1><p id="023d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">虽然Swift不是开创可选类型或sum类型的语言，也不是第一种让我接触到这一概念的语言，但它是我开始经常使用这一概念的第一种语言。苹果Swift文档中有一个解释这一概念的例子:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="5b92" class="ni me it nd b gy nj nk l nl nm">if let firstNumber = Int("4") {<br/>    if let secondNumber = Int("42") {<br/>        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br/>            print("\(firstNumber) &lt; \(secondNumber) &lt; 100")<br/>        }<br/>    }<br/>}<br/><br/>// Prints "4 &lt; 42 &lt; 100"</span></pre><p id="104a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将字符串<code class="fe na nb nc nd b">"4"</code>解析为整数<code class="fe na nb nc nd b">4</code>可能会失败。在Swift中，<code class="fe na nb nc nd b">Int</code>函数将返回一个<code class="fe na nb nc nd b">Int?</code>类型的值，这意味着它可以是一个整数或者一个<code class="fe na nb nc nd b">null</code>。类型<code class="fe na nb nc nd b">Int</code>只能是整数。像<code class="fe na nb nc nd b">Int?</code>和<code class="fe na nb nc nd b">String?</code>这样的类型不能直接使用，因为它们可能是<code class="fe na nb nc nd b">null</code>。它们必须以某种方式打开。这就是Swift中的<code class="fe na nb nc nd b">if let</code>语句的作用。</p><p id="1ac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个等价的例子:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="5778" class="ni me it nd b gy nj nk l nl nm">if let firstNumber = Int("4"), <br/>   let secondNumber = Int("42"), <br/>   firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 <br/>{<br/>    print("\(firstNumber) &lt; \(secondNumber) &lt; 100")<br/>}<br/><br/>// Prints "4 &lt; 42 &lt; 100"</span></pre><p id="3396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html" rel="noopener ugc nofollow" target="_blank">苹果文档</a>中阅读更多相关内容。从Objective-C到Swift，我惊讶地发现我可以从中捕捉到多少狡猾的小bug。尤其是与C++相比，我喜欢它简化了许多功能。我不再需要写大量的防御性代码来检查空指针。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/91f42a6d0cab039aa398bb358498b444.png" data-original-src="https://miro.medium.com/v2/format:webp/1*84cAVu5G7W3eyEl6i_OeVw.png"/></div></figure><h1 id="98a7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">go-结构类型</h1><p id="9884" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在《T21 Go》中，大多数人会继续谈论编程的并发性有多棒。但是对我来说，结构打字有最大的吸引力。你们大多数人熟悉的就是所谓的<a class="ae ky" href="https://en.wikipedia.org/wiki/Nominal_type_system" rel="noopener ugc nofollow" target="_blank">名义打字</a>。这就是C/C++、Java和C#中键入的工作方式。</p><p id="603b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种非常类似于动态语言的鸭式输入，但是在编译时进行检查。Go没有实现继承，但是可以用方法定义结构，也可以定义接口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/4c980f5eb6d395364251e85ae0a81806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKHNon7EhC_z8AUJGjIxxA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd np">枪兵</strong>和<strong class="bd np">骑士</strong>需要有士兵中定义的方法才能坚持<strong class="bd np">士兵</strong>接口。</p></figure><p id="e7d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以定义一个函数<code class="fe na nb nc nd b">fight</code>，它接受一个类型为<code class="fe na nb nc nd b">Soldier</code>的参数，其中<code class="fe na nb nc nd b">Soldier</code>是一个带有方法列表的接口。然后，<code class="fe na nb nc nd b">fight</code>可以接受类型<code class="fe na nb nc nd b">Pikeman</code>或类型<code class="fe na nb nc nd b">Knight</code>的对象，只要它们都具有在<code class="fe na nb nc nd b">Soldier</code>接口中定义的所有方法。以下是Go中这种实现的一部分示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="8bd6" class="ni me it nd b gy nj nk l nl nm">type Soldier interface {<br/>    damage(amount int)<br/>    attack(soldier Soldier)<br/>}</span><span id="1295" class="ni me it nd b gy nq nk l nl nm">func fight(a Soldier, b Soldier) {<br/>    a.attack(b)<br/>    b.attack(a)<br/>}</span></pre><p id="96a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在定义<code class="fe na nb nc nd b">Knight</code>时，我们没有指定它实现了<code class="fe na nb nc nd b">Soldier</code>接口；它只是通过实现它的方法:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="3d24" class="ni me it nd b gy nj nk l nl nm">type Knight struct {<br/>    health int<br/>}</span><span id="b4b5" class="ni me it nd b gy nq nk l nl nm">func (knight *Knight) damage(amount int) {<br/>    knight.health -= amount<br/>}</span><span id="9bab" class="ni me it nd b gy nq nk l nl nm">func (knight *Knight) attack(soldier Soldier) {<br/>    soldier.damage(4)<br/>}</span></pre><p id="a70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将<code class="fe na nb nc nd b">Knight</code>和<code class="fe na nb nc nd b">Pikeman</code>传递给一个需要<code class="fe na nb nc nd b">Soldier</code>类型的函数，Go编译器会计算出这些接口在结构上匹配。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4d55" class="ni me it nd b gy nj nk l nl nm">knight := Knight{12}<br/>pikeman := Pikeman{8}</span><span id="405d" class="ni me it nd b gy nq nk l nl nm">fight(&amp;knight, &amp;pikeman)</span></pre><p id="47b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这类似于Python或Ruby。他们不关心输入的确切类型，只要对象响应对它们的方法调用。Go允许您这样做，但是是以类型安全的方式。如果接口类型和结构类型不匹配，就会出现编译错误。例如，如果我没有为<code class="fe na nb nc nd b">Pikeman</code>实现<code class="fe na nb nc nd b">damage</code>方法，我会得到以下错误:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="b3d8" class="ni me it nd b gy nj nk l nl nm">cannot use &amp;pikeman (type *Pikeman) as type Soldier in argument to fight:<br/>    *Pikeman does not implement Soldier (missing damage method)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ca3e" class="md me it bd mf mg nr mi mj mk ns mm mn jz nt ka mp kc nu kd mr kf nv kg mt mu bi translated">目标-C-类别</h1><p id="2428" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于来自C++背景的人来说，我非常喜欢Objective-C的一点就是分类。category允许你在现有的类中添加任意数量的方法，而不用子类化它，这可以在单独的库中完成。</p><p id="0018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有什么用？想象一下，你正在把一个表示复杂用户界面的对象图存储到磁盘上，你想重新创建它。您可以遍历这个对象图并调用方法<code class="fe na nb nc nd b">createUI</code>来为该对象创建相应的UI对象。</p><p id="7434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是:由模型对象组成的对象图不应该依赖GUI代码。您不希望将图形库链接到包含非GUI代码的库。</p><p id="f490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于类别，您可以向对象图中的每一个对象类型添加一个<code class="fe na nb nc nd b">createUI</code>方法。您可以为每种对象类型添加不同的代码。</p><p id="bd60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个优雅的解决方案，C++开发人员必须用，比如说，一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Visitor_pattern" rel="noopener ugc nofollow" target="_blank">访问者模式</a>来解决。类别不再是Objective-C独有的。Swift也提供了这一功能。由于Swift具有更规范的语法，因此展示一个类似于类别的Swift类扩展示例会很有用:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="7fcc" class="ni me it nd b gy nj nk l nl nm">extension Int {<br/>    func takeAway(value: Int) -&gt; Int {<br/>        return self-value<br/>    }<br/>}<br/><br/>let a = 10<br/>let b = a.takeAway(value: 3)<br/>print(b)</span></pre><p id="2772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们用<code class="fe na nb nc nd b">takeAway</code>方法扩展了<code class="fe na nb nc nd b">Int</code>类型——这很没用，但这只是一个简单的例子。</p><p id="70c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于如何在Swift中更优雅地实现visitor模式的更详细的解释，可以看看这个更<a class="ae ky" href="https://erik-engheim.medium.com/making-visitor-pattern-obsolete-using-swift-c16e49a2e52f" rel="noopener">详细的解释</a>。它在Objective-C中同样适用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/6a174e8cb7863837616dca83d26d925b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ppbzmobR7kzuBNoU1ZChNg.png"/></div></figure><h1 id="da97" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">LISP —同象性</h1><p id="681f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="noopener ugc nofollow" target="_blank"> LISP编程</a>语言及其衍生语言有一个特性叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Homoiconicity" rel="noopener ugc nofollow" target="_blank"> <em class="nn">同象性</em> </a>让我着迷了很久，即使我不做LISP的常规编程。</p><p id="0428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着代码以与数据相同的方式表示，因此可以以与数据相同的方式操作。</p><p id="5010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在LISP中，核心数据结构是一个链表。下面是一个包含一些元素的列表的简单示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="a6a3" class="ni me it nd b gy nj nk l nl nm">(list 43 "hello" true 2.5 'c')</span></pre><p id="232b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我在这里对布尔值和字符使用了熟悉的类似C的语法。LISP将使用不同的语法。</p><p id="941d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">链表由节点组成，每个节点可以指向另一个节点。它还有一个储存数据的单元格。但这也可以是指向另一个列表的指针。因此我们可以有列表的列表，这些列表也可以是列表的列表。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e305" class="ni me it nd b gy nj nk l nl nm">(list 34 (list "hello" true) (list 2.5 'c'))</span></pre><p id="d265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们可以用这种方式表达复杂的数据结构和树结构。如果你对编译器的工作原理有所了解，你就会知道当它解析代码时，会产生一个抽象的语法树。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/237f3a78d7f1056aac38f41e3a4bdd8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*qlzpQgPdHf65yjgCZHmGbA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表达式的抽象语法树:<em class="nx">a+3&gt;4–2b</em></p></figure><p id="12b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用LISP编码时，你是在直接创建这个抽象语法树，原则上你可以像任何其他代码一样重新排列和转换这样的代码树。</p><p id="070f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个例子来说明LISP方法的普遍性。如果我们看一个用C语言编写的Hello World程序，那么代表这个程序的抽象语法树或数据结构就不会立即显现出来。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e70a" class="ni me it nd b gy nj nk l nl nm">#include &lt;stdio.h&gt;<br/><br/>int main () {<br/>    printf("hello, world\n");<br/>    return 0;<br/>}</span></pre><p id="3b6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有一些带有LISP风格的C语言版本可以让你用LISP语法写这个程序(我们称之为<em class="nn"> s表达式</em>)。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="f830" class="ni me it nd b gy nj nk l nl nm">(import cstdio)<br/><br/>(def main (fn extern-c int (void)<br/>  (printf "hello, world\n")))</span></pre><p id="fe7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再举一个例子来说明这是如何工作的。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="c644" class="ni me it nd b gy nj nk l nl nm">struct Point {<br/>    int x;<br/>    int y;<br/>};</span></pre><p id="c899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用LISP s表达式，这变成:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="1154" class="ni me it nd b gy nj nk l nl nm">(def Point (struct intern (<br/>    (x int) <br/>    (y int)<br/>)))</span></pre><p id="f742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要带着这个去哪里？为什么要用这样一种看起来丑陋和笨拙的语法写代码呢？有了这个语法，一切都完全规范化了。例如，在这个定义中，可以清楚地看到代码被定义为一个列表，其中前两个元素是<code class="fe na nb nc nd b">def</code>和<code class="fe na nb nc nd b">Point</code>。第三个元素是另一个列表，以元素<code class="fe na nb nc nd b">struct</code>和<code class="fe na nb nc nd b">internt</code>开始。它还有第三个元素，这是另一个包含结构中所有变量定义的列表。</p><p id="aaa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，那又怎样？那给了我什么？例如，您可以将这个LISP代码放在一个文件中，其他LISP代码可以将这个代码作为数据加载并转换它。它可以像任何其他链表一样遍历这段代码。它可以插入和替换元素。</p><p id="070d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在LISP中，你甚至不需要把它放在一个单独的文件中。使用引号，代码可以作为数据直接放在其他LISP代码中。例如，在LISP中，这意味着给变量<code class="fe na nb nc nd b">x</code>加4。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="3f01" class="ni me it nd b gy nj nk l nl nm">(+ 4 x)</span></pre><p id="a3f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在普通的LISP中，您可以像这样用一个值来声明一个变量:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="6c56" class="ni me it nd b gy nj nk l nl nm">(defvar y 10)</span></pre><p id="900e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后用<code class="fe na nb nc nd b">setf</code>改变数值:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="7ecd" class="ni me it nd b gy nj nk l nl nm">(setf y 5)</span></pre><p id="cbe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是它不需要包含数字。我们可以在里面放任何东西，甚至是一列代码。但是我们如何避免代码被执行呢？如果我们这样做，我们只需在<code class="fe na nb nc nd b">y</code>中存储7:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="fd1a" class="ni me it nd b gy nj nk l nl nm">(setf y (+ 3 4))</span></pre><p id="7d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以做的是引用一个列表，它将一个表达式转换成常规的列表数据:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9a8f" class="ni me it nd b gy nj nk l nl nm">(setf y '(+ 3 4))</span></pre><p id="7f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我使用SBCL这样的LISP REPL环境(交互式命令行),我们可以检查并评估它:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="f876" class="ni me it nd b gy nj nk l nl nm">sbcl&gt; y<br/>=&gt; (+ 3 4)<br/><br/>sbcl&gt; (eval y)<br/>=&gt; 7</span></pre><p id="d4d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是您可以自己动态地创建这样一个代码列表。函数的作用是:在列表的开头添加一个节点。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="fda8" class="ni me it nd b gy nj nk l nl nm">sbcl&gt; (cons 3 '(5 8))<br/>=&gt; (3 5 8)</span></pre><p id="8966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以用它来组合列表中的代码片段。例如，在下面的例子中，我们挑选出了<code class="fe na nb nc nd b">y</code>的第一个元素，即<code class="fe na nb nc nd b">+</code>操作符，然后我们将它添加到数字4和5的列表中。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="626e" class="ni me it nd b gy nj nk l nl nm">sbcl&gt; (cons (first y) '(4 5))<br/>=&gt; (+ 4 5)</span></pre><p id="c170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以评估我们创造的这个新表达式:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="26cd" class="ni me it nd b gy nj nk l nl nm">sbcl&gt; (eval (cons (first y) '(4 5)))<br/>=&gt; 9</span></pre><p id="0ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这显然是一个更大的话题，我只能触及表面。但关键是要表明，通过将任何代码放入s表达式中，您都可以轻松地转换和操作这些代码。因此，举例来说，您可以在常规LISP代码中使用我之前展示的LISP风格的C代码，并对该代码执行转换。然后，这些代码可以被输入到一个程序中，如<a class="ae ky" href="https://github.com/kiselgra/c-mera" rel="noopener ugc nofollow" target="_blank"> C-Mera </a>，它会将LISP风格的C语言转换成可以编译的普通C代码。</p><p id="d6f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这被顽皮狗公司用在了Playstation 2上，该公司制作了<a class="ae ky" href="https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp" rel="noopener ugc nofollow" target="_blank">面向游戏的汇编LISP </a>来创建<a class="ae ky" href="https://en.wikipedia.org/wiki/Jak_and_Daxter" rel="noopener ugc nofollow" target="_blank"> Jak和Daxter等游戏。</a>基本上，这是用LISP语法包装PS2汇编代码，提供了用高级语言编写低级语言的机会。</p><p id="38bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么LISP经常被认为是创造语言的语言。高度规则语法的另一个优点是，您可以使用特殊的LISP编辑器来导航树结构，而不是行和列。因此，键盘组合可以移动到语法树中的下一个兄弟，移动到父节点，或者移动到子节点。您可以选择所有子节点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/f0378ff647214a35066fb9bfa74f35f4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*rtdl9X9eOb04ElhJSJZ_Xw.png"/></div></figure><h1 id="f526" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Smalltalk —基于图像的开发</h1><p id="4574" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://pharo.org/" rel="noopener ugc nofollow" target="_blank"> Smalltalk </a>并不是第一个基于图像开发的语言。事实上，这是由LISP开创的。然而，Smalltalk可能是最适合的语言，也是最强大的语言。</p><p id="99e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然回避了这个问题:什么是<em class="nn">基于图像的开发</em>？</p><p id="e021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不，这并不意味着你正在绘制图像来创建程序。相反，我们使用单词<em class="nn"> image </em>来表示内存中数据的串行化。您可以将Smalltalk编程想象成REPL环境中的一个交互式会话。如果你已经编程了JavaScript、Python、Ruby或Lua，你应该熟悉基于REPL的开发。你定义变量、函数等。在互动的环境中。</p><p id="325a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Smalltalk更进了一步。您的代码没有保存在您可能偶尔在REPL环境中加载的某个单独的文件中。不，整个开发过程都发生在这个交互式环境中，整个过程都被转储到磁盘上。本质上，您没有需要管理的单独的文本文件。</p><p id="b254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，您可以将Smalltalk开发视为使用IDE操作对象数据库。但还有比这更疯狂的。整个交互环境本身是用Smalltalk编写的，并且是同一个环境的一部分。</p><p id="8281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它大致是这样工作的:在底部，有一个虚拟机(VM ),它加载一个映像，这个映像基本上是一个对象数据库。这个映像包含了整个Smalltalk开发环境本身。通过IDE，它本身存在于Smalltalk映像中，您可以执行向该映像添加更多对象的操作。</p><p id="c5a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图来自一个叫做<a class="ae ky" href="https://pharo.org" rel="noopener ugc nofollow" target="_blank"> Pharo </a>的Smalltalk的现代化身。它展示了一个典型的Smalltalk代码编辑器。在最左边，你有包裹。在包的旁边，有一个在所选包中定义的类的列表。接下来，你得到了方法的类别。最后，在最右边，你会看到这一类的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/a640c8d2b4b11e303bd2d0c030d3c2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/1*KuwvrH97Dim8WmayLcOgIg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pharo IDE中遍历类和方法的例子。如你所见，在Smalltalk中，甚至True和False都是类。</p></figure><p id="6cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下半部分，您可以看到该方法的代码。然而，重要的是要认识到这些代码是作为数据存储在类中的。它不存储在文本文件中。您不能再向下滚动查看下一个方法。每种方法都是独立的，因为它们是独立的实体。</p><p id="ace1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么这有什么意义呢？为什么重要？这种方法给了我们什么？</p><p id="96c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着Smalltalk IDE拥有完整的、总是最新的、内存中的代码表示。这种表现就是Smalltalk对象。因此，您和IDE都可以遍历所有的类、对象和方法。正是它给了Smalltalk IDEs如此强大的重构工具。像重命名方法或移动方法这样的操作不像其他ide那样是文本替换操作。相反，它是一个对象操作。你操纵活着的物体。</p><p id="412e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为整个开发环境是由类、方法和对象组成的，您可以从开发环境中浏览这些类、方法和对象，并且它们是实时存在的，所以您可以修改自己的开发环境并立即看到发生的变化。这意味着您可以改变行为并添加新功能。事实上，甚至编译器本身也是用Smalltalk编写的，所以你甚至可以改变你的类和方法的编译方式。</p><p id="c7f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您第一次使用Smalltalk时，可能会有点困惑。例如，Pharo从一个简单的启动程序开始，您可以选择要启动的图像。这是自然的。否则，我们将如何处理你搞砸了你的整个形象，因为这可能意味着你的整个开发环境不再工作？</p><p id="68d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Pharo有很多工具可以保存图像、恢复图像、重置图像和执行版本控制。Smalltalk中的版本控制很有趣，因为原则上没有文本文件。例如，你如何在Smalltalk中使用Git和GitHub呢？</p><p id="a166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Pharo中，这是通过一个名为Iceberg的特殊Git管理器解决的，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/4d7d3b3c36f5f706e9b3e6f2b8b37c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*K5V-RLDKXCSC3AJH.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Iceberg在Pharo中是用来和Git交互的。因为Smalltalk不是基于文件的，所以需要一个特殊的工具。</p></figure><p id="0b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Iceberg会将Smalltalk图像导出为Git可以处理的格式。这意味着类被转换成目录，每个方法被转换成一个单独的文件。这允许您使用Iceberg跟踪单个方法级别的代码变化。</p><p id="8731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">认识到这只是一种导出格式很重要。您不能直接运行它。您使用Iceberg从Git导入更改。</p><p id="1fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于图像的开发提供了许多有趣的机会。例如，您可以在调试会话过程中存储您的映像，然后重新加载您的IDE并从您停止的地方继续。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/63141d18bf147cf060cbf6eff90e576d.png" data-original-src="https://miro.medium.com/v2/1*R7JSbMTshcotcn9bxMKmaA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在调试会话过程中保存IDE状态的示例。稍后可以在同一位置继续调试。</p></figure><p id="0eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以只将调试器的状态导出到单独的文件中。您可以将此附加到错误报告中，让其他开发人员从您停止的地方继续调试。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/410987d794b1adbf66cba267e9ef20d5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*TbLbO1U1_IGfom1tmNULWw.png"/></div></figure><h1 id="e040" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Lua——一切都是哈希表</h1><p id="c1ff" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在LISP中，一切都是链表。在Smalltalk中，一切都是对象。Lua 在这方面有自己独特的见解。在Lua中，一切都围绕着作为主要数据结构的哈希表。</p><p id="2720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，Lua中的数组只是一个散列表，其中的索引是整数。Lua对任何事情都使用哈希表。名称空间只是包含函数、对象和其他哈希表的哈希表。</p><p id="4e93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些哈希表非常聪明。它们可以指向元哈希表，元哈希表在无限链中也可以有自己的元哈希表。</p><p id="3481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您试图在哈希表中查找一个项目，而它没有那个键，它将继续在其元哈希表中查找。如果那个表没有它，它将询问它的元哈希表，以此类推。</p><p id="3e2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能会形成层级。几个散列表可以指向同一个元散列表。和元散列表的集合都可以指向另一个共享的元散列表。因此，我们可以创建一个层次树结构。</p><p id="207b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以用于许多目的。当您还没有定义一个值时，它提供了一种提供默认值的方法。Lua最初是作为一种配置语言设计的，在这里你可以指定复杂的配置设置。</p><p id="5bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你可以更进一步。如果你愿意，你可以用它来定义一个面向对象的系统。假设我们用一个<code class="fe na nb nc nd b">width</code>和<code class="fe na nb nc nd b">height</code>字段定义一个矩形。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="5c7d" class="ni me it nd b gy nj nk l nl nm">local rectangle = {width = 10, height = 20}</span></pre><p id="5091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，将一个function对象分配给<code class="fe na nb nc nd b">area</code>键，该键将一个矩形作为参数，并计算矩形的面积。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="63b5" class="ni me it nd b gy nj nk l nl nm">rectangle["area"] = function(rect)<br/>  return rect["width"] * rect["height"]<br/>end</span></pre><p id="5f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这种形式有一个等价的语法sugar版本，可以这样写:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4a25" class="ni me it nd b gy nj nk l nl nm">rectangle.area = function(self)<br/>  return self.width * self.height<br/>end</span></pre><p id="e6f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个等价形式:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="5a09" class="ni me it nd b gy nj nk l nl nm">function rectangle.area(self)<br/>  return self.width * self.height<br/>end</span></pre><p id="f105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果我们使用<code class="fe na nb nc nd b">:</code>符号而不是<code class="fe na nb nc nd b">.</code>，那么我们就不必显式地将<code class="fe na nb nc nd b">self</code>写成第一个参数，即使它仍然是第一个参数:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="5a4c" class="ni me it nd b gy nj nk l nl nm">function rectangle:area()<br/>  return self.width * self.height<br/>end</span></pre><p id="95c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当访问<code class="fe na nb nc nd b">rectangle</code>散列表中的函数对象并调用它时，有一个简单的相似之处。以下两种形式是等效的:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="1d5f" class="ni me it nd b gy nj nk l nl nm">rectangle.area(rectangle)<br/>rectangle:area()</span></pre><p id="5df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，不用给每个矩形分配一个<code class="fe na nb nc nd b">area</code>函数，你可以将每个矩形的所有函数分配给另一个哈希表；姑且称之为<code class="fe na nb nc nd b">Rectangle</code>。然后我们可以设置<code class="fe na nb nc nd b">rectangle</code>的元表，并且每隔一个矩形对象指向这个元表。这意味着当你调用<code class="fe na nb nc nd b">rectangle:area()</code>时，你实际上在元表上找到了<code class="fe na nb nc nd b">area</code>。瞧，我们得到了一个面向对象的系统，有继承和一切。</p><p id="66c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的部分吸引力在于Lua是一种非常小的语言。你可以在明信片上定义语法。然而，你有一个非常灵活和多才多艺的语言，有一些特点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2aa8" class="md me it bd mf mg nr mi mj mk ns mm mn jz nt ka mp kc nu kd mr kf nv kg mt mu bi translated">结束语</h1><p id="2c53" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">还有许多其他有趣的语言。虽然我过去喜欢使用Ruby和Python，但我不能说它们一定提供了我以前没有见过的革命性的新东西。相反，它更多的是提供一套以前在其他地方探索过的新功能。例如，对我来说，Ruby允许我以一种更务实的方式做很多你可以在Smalltalk中做的事情。当然，Ruby没有基于图像的开发模型，但是它可以处理好的旧文件，并且可以像bash一样作为脚本运行。因此，您可以使用它来制作简单的shell工具。相比之下，Smalltalk并不适合这样做。或者至少不是，当我第一次探索它的时候。</p><p id="1353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一些语言本身确实很新颖，比如<a class="ae ky" href="https://www.haskell.org" rel="noopener ugc nofollow" target="_blank"> Haskell </a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Rebol" rel="noopener ugc nofollow" target="_blank"> Rebol </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Forth_(programming_language)" rel="noopener ugc nofollow" target="_blank">fouth</a>，但我对它们的经验太少，无法一一评价。</p><p id="03e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我可以简单地提一下，Haskell将类型系统和函数式编程提升到了一个新的层次。或者至少曾经是。现在有了更多的现代变体，比如<a class="ae ky" href="https://www.idris-lang.org" rel="noopener ugc nofollow" target="_blank"> Idris </a>。</p><p id="e622" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Forth很有趣，因为它是一种基于堆栈的语言，提供了非常高级和低级的编程。对于习惯于普通编程语言的人来说，这些代码看起来很奇怪，但它可能是在只能访问汇编代码的新架构上实现的最快的语言。因此，许多微控制器系统通常安装有第四系统。</p></div></div>    
</body>
</html>