<html>
<head>
<title>Implement gRpc Global Exception Handler in ASP.NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ASP中实现gRpc全局异常处理程序。网</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-grpc-global-exception-handler-in-asp-net-e371fb35b7b7?source=collection_archive---------2-----------------------#2022-05-22">https://betterprogramming.pub/implement-grpc-global-exception-handler-in-asp-net-e371fb35b7b7?source=collection_archive---------2-----------------------#2022-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a582" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这个例子展示了gRpc中一元服务器句柄中的gRpc全局异常处理程序。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a4fce9ef26b0c522b6abd5d21597461a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t_epD_LQDgWenrwM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多梅尼科·洛亚在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8a33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在微服务中，我们有两种方式与其他内部服务集成。</p><p id="360e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方式是请求-响应模式，这是最著名的。</p><p id="7430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请求-响应模式的优点是客户端可以立即从其他内部服务获得响应，无论是查看数据还是数据操作结果。</p><p id="5ec9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方式是消息模式；生产者将数据排队到队列中(像Kafka一样)，消费者将从队列中接收数据。</p><p id="3769" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在系统设计中，什么时候使用请求-响应模式，什么时候使用消息模式？</p><p id="3e30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的几篇文章中，我会对此进行更多的解释。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="b498" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的内部系统使用gRpc与其他内部服务集成，以实现请求-响应模式。</p><p id="e25b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个模式中的问题是，我们如何知道响应是成功还是失败？</p><p id="b10d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式中的响应有两种失败情况；一个是网络错误，另一个是商业错误。</p><p id="d0ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了区分响应，我们在API响应中制定了一种格式。</p><p id="9882" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">响应密钥具有代码、消息和数据；下面的JSON就是一个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><ul class=""><li id="6307" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">代码:表示您的操作是否成功；如果没有，会给出相应的错误代码。</li><li id="9d72" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">消息:API想告诉你的一些错误消息。</li><li id="b449" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">数据:您需要来自服务的数据。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d045" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">web API中的全局异常处理程序</h1><p id="9890" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">如果我们想在web API中处理全局异常，我们编写一个中间件，捕捉特定的域异常，并重写响应体。</p><p id="5d68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建一个域异常类。</p><p id="f662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">域异常有两个属性，即代码和消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">域异常</p></figure><p id="a92d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们的域逻辑发生异常，比如order not found或store not found，我们抛出域异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">域应用服务</p></figure><p id="a665" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是创建一个中间件来处理域异常。</p><p id="8a85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">全局异常处理程序中间件将捕获域异常，并用域异常中的代码和消息将响应体重写为我们的规范格式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">全局异常处理中间件</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1019" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">gRpc上的解决方案是否相同？</h1><p id="18a3" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">gRpc请求也通过全局异常处理器中间件。</p><p id="1219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如果不从全局异常处理程序中间件中排除gRpc请求会发生什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/19c88dde96791fb140fb5c3ab3d618fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8KJwzxTZAd64te9emjLoZw.png"/></div></div></figure><p id="b174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">糟糕，我们收到状态代码2未知响应。</p><p id="00dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该解决方案在web API上工作，在gRpc上完全不可用。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3caf" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">gRpc中的全局异常处理程序</h1><p id="a51a" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">正如你所看到的，我们重写了JSON主体，以适应web API的格式。</p><p id="e0e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在gRpc中，我们不能像web API那样使用中间件来处理异常。</p><p id="0786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们需要用另一种方式来处理这件事。</p><p id="8f1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用Grpc。处理异常的拦截器。</p><p id="034c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个Grpc全局异常处理程序拦截器，如下所示。</p><p id="5f6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将拦截器注册到gRpc服务器管道。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="93a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">gRpc响应体是一个具体类型；当我们捕捉到异常时，我们不能像web API那样重写JSON主体。</p><p id="6191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须向响应返回一个特定的类。</p><p id="d76f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们使用反射来映射到泛型类型。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f980" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">如果全局异常处理中间件和gRpc全局异常处理拦截器同时存在，是否有效？</h1><p id="875e" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">答案是肯定的。</p><p id="ff55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是只有一种方法可以成功捕获异常。</p><p id="1fb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原因是中间件和拦截器的顺序。</p><p id="f44b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">web API请求不会通过gRpc拦截器。</p><p id="3a84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此中间件将捕获web API请求抛出的异常。</p><p id="b781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">gRpc请求不仅要通过中间件，还要通过拦截器。</p><p id="4c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请求的顺序是中间件第一，gRpc拦截器最后。</p><p id="e8c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此拦截器将捕获gRpc请求抛出的异常，而不是将它们转发给中间件。</p><p id="b1de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的几篇文章中，我将说明中间件和拦截器在ASP.NET的顺序。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="981e" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">结论</h1><p id="e02c" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">这个例子展示了gRpc中一元服务器句柄中的gRpc全局异常处理程序。</p><p id="e037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你使用客户端流或服务器流，你需要在额外处理那些方法。</p><p id="b5f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需覆盖其他服务器句柄方法。</p><p id="950b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这个方案能解决你的问题。</p></div></div>    
</body>
</html>