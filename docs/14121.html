<html>
<head>
<title>Manage Goroutine, GC, Debug, and Collect Metrics With Runtime Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用运行时包管理Goroutine、GC、Debug和收集指标</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/manage-goroutine-gc-debug-and-collect-metrics-with-runtime-package-abe2ee7a65bd?source=collection_archive---------11-----------------------#2022-11-08">https://betterprogramming.pub/manage-goroutine-gc-debug-and-collect-metrics-with-runtime-package-abe2ee7a65bd?source=collection_archive---------11-----------------------#2022-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">何时以及如何使用Go运行时包</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/86747810a35f62fc75c3ac7fb2d5b9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aXp8HpwUwqvJhS-s"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自https://unsplash.com/photos/QVD3Xht9txA的</p></figure><p id="d205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go <a class="ae ky" href="https://pkg.go.dev/runtime" rel="noopener ugc nofollow" target="_blank"> runtime </a>包及其子包<a class="ae ky" href="https://pkg.go.dev/runtime/debug" rel="noopener ugc nofollow" target="_blank"> debug </a>对于管理metrics、debug、goroutine、GC非常实用，也可以方便我们理解Go本身的实现。</p><p id="f521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文旨在通过一些使用案例和示例代码来回答以下五个“如何做”。</p><ul class=""><li id="b255" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何使用运行时和运行时/调试包公开的环境变量</li><li id="0f00" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何使用运行时和运行时/调试包公开的Go指标</li><li id="a2d1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何用运行时和运行时/调试包管理goroutines</li><li id="14d6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何用运行时和运行时/调试包操作GC</li><li id="fbc8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何使用运行时和运行时/调试包进行调试</li></ul><p id="20f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行时包提供了许多我们可以在开发中调用的内置环境变量。</p><h1 id="77d7" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">包封/包围（动词envelop的简写）</h1><p id="78ee" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">最常见的环境变量有<code class="fe ng nh ni nj b">GOARCH</code>、<code class="fe ng nh ni nj b">GOOS</code>、<code class="fe ng nh ni nj b">GOPATH</code>、<code class="fe ng nh ni nj b">GOROOT,</code>，分别针对基于不同底层操作系统的不同实现。以下输出与我们在CLI中执行<code class="fe ng nh ni nj b">go env</code>得到的结果相同。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="be17" class="no mk it nj b gy np nq l nr ns">fmt.Printf(“OS: %s, GOARCH: %s”, runtime.GOOS, runtime.GOARCH)</span></pre><p id="6ffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，还有一些与GC、debug和trace相关的环境变量。</p><ul class=""><li id="b372" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">GOGC</code>设置垃圾收集的初始目标百分比，并根据剩余垃圾对象的比例决定是否触发GC。默认情况下，<code class="fe ng nh ni nj b">debug.SetGCPercent</code>函数在运行时修改这个百分比，并在<code class="fe ng nh ni nj b">GOGC=100. GOGC=off</code>时完全禁用垃圾收集。</li><li id="0cdc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">GODEBUG</code>控制运行时的调试变量，由一组<code class="fe ng nh ni nj b">name=val</code>，逗号分隔的字符串，以及<code class="fe ng nh ni nj b">allocfreetrace=1, clobberfree=1</code>等支持配置组成。更多信息请参考这张<a class="ae ky" href="https://pkg.go.dev/runtime#hdr-Environment_Variables" rel="noopener ugc nofollow" target="_blank">清单</a>。</li><li id="869a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">GORACE</code>用于通过在<code class="fe ng nh ni nj b">build</code>时添加<code class="fe ng nh ni nj b">-race</code>标志来配置<a class="ae ky" href="https://golang.org/doc/articles/race_detector.html" rel="noopener ugc nofollow" target="_blank">竞争检测器</a>。</li><li id="c4d0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">GOMAXPROCS </code>限制并发执行用户级Go代码的操作系统线程数量，但不限制系统调用中阻塞的线程数量。</li><li id="0a6e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">GOTRACEBACK</code>控制Go程序因未处理的异常或意外运行条件而失败时的输出量。默认情况下，当出现错误时，将打印当前goroutine的堆栈跟踪，忽略内部运行时函数，并使用<code class="fe ng nh ni nj b">exit 2</code>退出。<br/>如果没有当前的goroutine，或者故障是运行时内部的，则在发生错误时打印所有go routine的堆栈跟踪，支持值包括<code class="fe ng nh ni nj b">none(0)</code>、<code class="fe ng nh ni nj b">all(1)</code>、<code class="fe ng nh ni nj b">system(2)</code>、<code class="fe ng nh ni nj b">single</code>、<code class="fe ng nh ni nj b"> crash</code>，其中<code class="fe ng nh ni nj b">all</code>和<code class="fe ng nh ni nj b">system</code>是最常用的。<code class="fe ng nh ni nj b">all</code>为所有用户创建的goroutines添加堆栈跟踪信息。和<code class="fe ng nh ni nj b">system</code>类似，但是添加了运行时函数的堆栈跟踪信息，并显示运行时内部创建的goroutines。</li></ul><h1 id="b8ff" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">戈罗廷</h1><p id="d1dd" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Goroutine是Go的核心特性之一。通常，我们使用<code class="fe ng nh ni nj b">go func()</code>来创建goroutines，但是只要最终结果是正确的，我们就不太关心后续的调度和执行。</p><p id="ffea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是作为高水平的Go开发者，我们需要了解goroutine的调度，比如GMP模型，每个goroutine可以使用的堆栈大小，可以并行执行的Go routine的最大数量等等。在某种程度上，这些会受到运行时包中的方法的影响。</p><h2 id="d814" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">运行时。GOMAXPROCS(n)</h2><p id="3404" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">runtime.GOMAXPROCS(n)</code>设置一个进程中并行执行的goroutines的最大数量(<code class="fe ng nh ni nj b">P</code>)，与<code class="fe ng nh ni nj b">NumCPU()</code>相同，最大256。但是修改这个值会触发STW(停止世界)，所以我们应该避免频繁调用它。当工作池中的工作线程数量(或<code class="fe ng nh ni nj b">waitGroups</code>)可配置时，此方法主要用于确保<code class="fe ng nh ni nj b">GOMAXPROCS()</code>少于工作线程池。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="0d6d" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">运行时。戈舍德</h2><p id="d46c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">调用<code class="fe ng nh ni nj b">runtime.Gosched()</code>的goroutine将被<code class="fe ng nh ni nj b">runtime.Gosched()</code>挂起，重置为<code class="fe ng nh ni nj b">Runnable</code>，并放入调度器的可运行G队列中。它可以与runnable worker pool结合使用，监控当前正在运行的任务数量，并在任务数量超过线程池大小时，将当前的goroutine修改为下次执行的<code class="fe ng nh ni nj b">Runnable</code>状态。一个完美的例子如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="92af" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">运行时。Goexit</h2><p id="a2cc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">runtime.Goexit()</code>在执行完该goroutine中的<code class="fe ng nh ni nj b">defer</code>语句后，立即终止调用它的goroutine的运行，但不影响其他go routine。在错误处理中，<code class="fe ng nh ni nj b">runtime.Goexit()</code>可以保持当前goroutine中的异常，保证整个Go程序处于正常状态。</p><h2 id="44e6" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">运行时。LockOSThread和运行时。解锁线程</h2><p id="9e8d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">runtime.LockOSThread()</code>锁:goroutine用运行它的<code class="fe ng nh ni nj b">M</code>调用它，而<code class="fe ng nh ni nj b">runtime.UnlockOSThread()</code>解锁锁。请记住以下几点:</p><ul class=""><li id="2a3e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">多次调用<code class="fe ng nh ni nj b">runtime.LockOSThread()</code>不会导致任何问题，但最后一次调用将被记录。</li><li id="f55c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">即使没有调用<code class="fe ng nh ni nj b">runtime.LockOSThread()</code>也不会影响<code class="fe ng nh ni nj b">runtime.UnlockOSThread()</code>的调用。</li></ul><p id="aa63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在调用非Go程序(如C代码或OS服务)之前使用它，可以使相关的goroutine在程序失败时发现错误。在Postman的代码中，你可以找到很多<a class="ae ky" href="https://sourcegraph.com/search?q=context:global+runtime.LockOSThread%28%29+lang:Go+repo:%5Egithub%5C.com/containers/podman%24+&amp;patternType=standard" rel="noopener ugc nofollow" target="_blank">访问不同OS时的例子</a>。例如:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="e7dd" class="no mk it nj b gy np nq l nr ns">runtime.LockOSThread()<br/>defer runtime.UnlockOSThread()</span><span id="a483" class="no mk it nj b gy og nq l nr ns">// Call unix functions(non-Go)<br/>fds, err := unix.Socketpair(unix.AF_UNIX, unix.SOCK_DGRAM, 0)<br/> if err != nil {<br/>  return false, -1, err<br/> }<br/> r, w := os.NewFile(uintptr(fds[0]), "sync host"), os.NewFile(uintptr(fds[1]), "sync child")</span></pre><p id="e46d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，运行时/调试包中还有一些方法会影响goroutines的运行。</p><h2 id="c56a" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">调试。SetMaxStack</h2><p id="2309" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">debug.SetMaxStack()</code>限制单个goroutine可以申请的堆栈空间的最大大小。​</p><h2 id="d664" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">调试。SetMaxThreads</h2><p id="aecf" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">debug.SetMaxThreads()</code>设置运行时使用的内核线程数(<code class="fe ng nh ni nj b">M</code>)。此方法通常与队列和工作池大小设置一起调用。</p><h1 id="26b1" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">韵律学</h1><p id="ddab" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">运行时和运行时/调试包中有两种类型的数据。</p><ul class=""><li id="7b34" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">profiles</code>，包括<code class="fe ng nh ni nj b">BlockProfile</code>、<code class="fe ng nh ni nj b">MemProfile</code>、<code class="fe ng nh ni nj b">GoroutineProfile</code>等。，当前栈信息的所有封装都可以用<code class="fe ng nh ni nj b">pprof</code>工具获得，Go官方不建议在代码中直接调用。</li><li id="2b41" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">stats</code>，直读数据，非常直观。它们通常用于直接在线分析当前程序。</li></ul><h2 id="de96" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">NumCPU，NumCgoCall，NumGoroutine</h2><p id="09bb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这三种方法都直接返回实时数据。但是需要注意的是<code class="fe ng nh ni nj b">runtime.NumGoroutine()</code>在被调用后会返回特定状态下的goroutines的数量。这里的特定状态指的是<code class="fe ng nh ni nj b">Grunnable\Gruning\Gsyscall\Gwaition,</code>，其中goroutines被认为是活动的或预定的。</p><h2 id="1ac1" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">ReadMemStats，ReadGCStats</h2><p id="4fa5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">​ReadMemStats()</code>读取当前内存，包括堆占用、堆释放、栈占用、缓存状态、GC数量、下次GC时间等。打印出来看看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="91fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">ReadGCStats()</code>在调试包中，它提供的部分数据与<code class="fe ng nh ni nj b">READMemStats</code>有重复，但都集中在GC上，比如<code class="fe ng nh ni nj b">LastGc</code>、<code class="fe ng nh ni nj b">NumGc</code>、<code class="fe ng nh ni nj b">Pause</code>、<code class="fe ng nh ni nj b">PauseTotal</code>等。比如普罗米修斯的代码中就应用了<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/22f3e6403904ba54bb7bb3b9a743367909669f08/vendor/github.com/prometheus/client_golang/prometheus/go_collector.go#L251" rel="noopener ugc nofollow" target="_blank"> GCStats </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以在开发Go server服务时添加API来返回这些数据，以方便在线调试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="d408" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">车底距地高(Ground Clearance)</h1><p id="b16a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Go封装GC非常出色，即使成千上万个goroutines同时运行，程序也能有效地执行，几乎不需要用户干预。但是运行时包提供了一些函数来弥补默认GC的缺点。</p><h2 id="0aa8" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">运行时。车底距地高(Ground Clearance)</h2><p id="385e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">runtime.GC()</code>在运行时执行强制GC，不同于<code class="fe ng nh ni nj b">GOGC</code>配置触发的非强制GC。</p><p id="eef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我们在分析之前手动触发GC，就像我们在<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/e8449012e2909ba55e5636bc912a16f98f42196d/staging/src/k8s.io/kubectl/pkg/cmd/profiling.go#L90" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>中所做的那样。代码如下:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="ebc3" class="no mk it nj b gy np nq l nr ns">func flushProfiling() error {<br/> switch profileName {<br/> case "none":<br/>  return nil<br/> case "cpu":<br/>  pprof.StopCPUProfile()<br/> case "heap":<br/>  runtime.GC()<br/>  fallthrough<br/>...<br/>}</span></pre><h2 id="3bb1" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">运行时。SetFinalizer</h2><p id="7615" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">SetFinalizer()</code>截取特定对象的GC，用<code class="fe ng nh ni nj b">Finalizer</code>增加额外的清理操作，比如Go的crypto包中的<a class="ae ky" href="https://github.com/golang/go/blob/3ba3b4893f3630b2bd78ec6f4f366d60e16bd636/src/crypto/internal/boring/hmac.go#L102" rel="noopener ugc nofollow" target="_blank">终结器</a>调用C来清理对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="08b2" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">运行时。保持活跃</h2><blockquote class="oh oi oj"><p id="d8ef" class="kz la ok lb b lc ld ju le lf lg jx lh ol lj lk ll om ln lo lp on lr ls lt lu im bi translated"><code class="fe ng nh ni nj b"><em class="it">​KeepAlive</em></code>将其参数标记为当前可达。这确保了在程序中调用<code class="fe ng nh ni nj b"><em class="it">KeepAlive</em></code>之前，对象没有被释放，并且它的终结器没有运行。</p></blockquote><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="b112" class="no mk it nj b gy np nq l nr ns">runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })<br/>var buf [10]byte<br/>n, err := syscall.Read(p.d, buf[:])<br/>// Ensure p is not finalized until Read returns.<br/>runtime.KeepAlive(p)​</span></pre><p id="d4a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些重对象像文件描述符和空队列在GC被触发前使用KeepAlive，比如在Kubernetes中获得的windows <code class="fe ng nh ni nj b">os.File</code> <a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/e8449012e2909ba55e5636bc912a16f98f42196d/vendor/github.com/Microsoft/go-winio/fileinfo.go#L26" rel="noopener ugc nofollow" target="_blank">对象</a>。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="9922" class="no mk it nj b gy np nq l nr ns">func GetFileBasicInfo(f *os.File) (*FileBasicInfo, error) {<br/> bi := &amp;FileBasicInfo{}<br/> if err := windows.GetFileInformationByHandleEx(windows.Handle(f.Fd()), windows.FileBasicInfo, (*byte)(unsafe.Pointer(bi)), uint32(unsafe.Sizeof(*bi))); err != nil {<br/>  return nil, &amp;os.PathError{Op: "GetFileInformationByHandleEx", Path: f.Name(), Err: err}<br/> }<br/> runtime.KeepAlive(f)<br/> return bi, nil<br/>}​​​</span></pre><h1 id="da27" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">调试</h1><p id="84c5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">一旦出现错误，我们还可以通过运行时包获得异常打印和堆栈信息。</p><h2 id="5eda" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">运行时。呼叫者</h2><p id="2e93" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">Caller()</code>反映堆栈帧的绝对路径和语句所在文件的行号。<code class="fe ng nh ni nj b">skip</code>是用<code class="fe ng nh ni nj b">0</code>标识<code class="fe ng nh ni nj b">Caller</code>的堆栈帧数。而要打印所有堆栈信息，可以直接使用<code class="fe ng nh ni nj b">debug.PrintStack()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子还使用了<code class="fe ng nh ni nj b">FuncForPC</code>函数，它通常用于</p><ul class=""><li id="10aa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">获取函数的名称，<code class="fe ng nh ni nj b">.Name()</code></li><li id="e60d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">获取函数的文件行，<code class="fe ng nh ni nj b">.FileLine()</code></li></ul><p id="3de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法最常用于在定制打印日志时获取更多信息，例如<code class="fe ng nh ni nj b">SetV</code>功能在<code class="fe ng nh ni nj b">klog</code>包中扮演的角色。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="45e7" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">追踪</h2><p id="fae1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">运行时包还支持打印<code class="fe ng nh ni nj b">trace</code>信息，使用<code class="fe ng nh ni nj b">StartTrace()</code>和<code class="fe ng nh ni nj b">StopTrace()</code>方法开始和结束跟踪，使用<code class="fe ng nh ni nj b">ReadTrace()</code>读取信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="59f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go本身使用这些函数来跟踪运行时的活动。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="09c9" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="059e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这篇文章总结了运行时包中的大多数方法，其中与goroutine和metrics相关的方法在Go工具开发中非常有用。它们提供了一些功能，比如在更高的层次上管理Go的内存使用、监控性能和保护程序健康。与调试相关的功能有助于构建对意外错误提示的默认支持，这可以显著加快我们定位错误的速度。</p><p id="1fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>