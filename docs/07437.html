<html>
<head>
<title>Type-Safe Domain Modeling in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的类型安全域建模</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/type-safe-domain-modeling-in-kotlin-425ddbc73732?source=collection_archive---------6-----------------------#2021-01-14">https://betterprogramming.pub/type-safe-domain-modeling-in-kotlin-425ddbc73732?source=collection_archive---------6-----------------------#2021-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e072" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“如果它能编译，它就能与Valiktor和Konad一起工作”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f091ce7c4a0df0db754457318014a625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UujPH5meqQa6uGVS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rudakov_g?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔治·鲁达科夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="0478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在领域驱动设计中，有一个<a class="ae ky" href="https://martinfowler.com/bliki/UbiquitousLanguage.html" rel="noopener ugc nofollow" target="_blank">无处不在的语言</a>的概念。简单来说，这通常与您给域模型中的实体起的名字有关。</p><p id="e863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有可能更进一步。我们可以将代码转换成领域的明确表达。</p><p id="06b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这里它遵循了美国领域专家如何描述一个“联系人”和一些业务规则。</p><p id="9fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">联系人有名字、姓氏和电子邮件。姓名可以有中间名的首字母。必须验证该电子邮件。您可以发送密码恢复只验证电子邮件。</em></p><p id="3222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个典型的、面向持久性的建模可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="f79c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码表达了任何需求吗？是的，它列举了所有的数据。反正字符串有约束吗？所有的数据都是必须的吗，还是有些数据可能会丢失？</p><p id="04c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在模型中声明这些信息，我们可以做得更好。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="6739" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">声明性领域模型</h1><p id="2f7f" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">首先，回忆一下基础。</p><h2 id="2a60" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated">内聚力</h2><p id="eca0" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">如果一些数据是相关的，那么将它们分组是一个好主意。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模型表达了哪些信息是相关的。保持高内聚也有利于重用。</p><h2 id="61bf" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated">声明约束</h2><p id="6434" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated"><code class="fe no np nq nr b">PersonalName</code>的字符串属性不能为空。这个在代码中没有明确，我们来明确一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe no np nq nr b">middleInitial</code>是可空的。这表示在编译时中间的首字母是可选的。</p><p id="b409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在<code class="fe no np nq nr b">NotEmptyStrings</code>中包装了字符串，以确保符合约束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我使用了一个<a class="ae ky" href="https://kotlinlang.org/docs/reference/inline-classes.html" rel="noopener ugc nofollow" target="_blank">内联</a>类，并且声明了一个编译时错误以防止使用构造函数。这个类只能使用工厂方法<em class="lv"> </em> <code class="fe no np nq nr b">of</code>进行实例化，因此没有机会跳过验证。我用<a class="ae ky" href="https://github.com/valiktor/valiktor" rel="noopener ugc nofollow" target="_blank"> Valiktor </a>来实现它。</p><p id="9803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kotlin中存在内联类，目的是增强原始类型的表达能力。在域模型中使用原始类型是一种代码味道，被称为<a class="ae ky" href="https://refactoring.guru/smells/primitive-obsession" rel="noopener ugc nofollow" target="_blank">原始痴迷</a>。</p><h2 id="85c9" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated">使其在编译时安全</h2><p id="97ab" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated"><code class="fe no np nq nr b">NotEmptyString.of</code>的签名声明，如果你输入一个<code class="fe no np nq nr b">string</code>，你将总是得到一个<code class="fe no np nq nr b">NotEmptyString</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="7738" class="nc mg it nr b gy nw nx l ny nz">fun of(value: String): NotEmptyString</span></pre><p id="d5ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是谎言。如果验证失败，那么Valiktor将抛出一个<code class="fe no np nq nr b">ConstraintViolationException</code>。它抛出的可能性没有在签名中声明，那么您可能会得到一个意外的运行时错误。让我们用<a class="ae ky" href="https://github.com/lucapiccinelli/konad" rel="noopener ugc nofollow" target="_blank"> Konad </a>来解决这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="90ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我使用了助手函数<code class="fe no np nq nr b">valikate</code>，它捕捉异常，用Valiktor API格式化它的消息，并将所有东西包装在<code class="fe no np nq nr b">Result</code>中。</p><p id="7f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建器<code class="fe no np nq nr b">ok()</code>和<code class="fe no np nq nr b">error()</code>是来自<a class="ae ky" href="https://github.com/lucapiccinelli/konad" rel="noopener ugc nofollow" target="_blank"> Konad </a>的扩展方法，分别构建一个<code class="fe no np nq nr b">Result.Ok</code>和一个<code class="fe no np nq nr b">Result.Errors</code>。</p><p id="b44c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看新的签名:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="eb1f" class="nc mg it nr b gy nw nx l ny nz">fun of(value: String): <strong class="nr iu">Result</strong>&lt;NotEmptyString&gt;</span></pre><p id="c7fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">失败的可能性现在很明显。在Konad中，<code class="fe no np nq nr b">Result</code>是一个<a class="ae ky" href="https://kotlinlang.org/docs/reference/sealed-classes.html" rel="noopener ugc nofollow" target="_blank">密封的</a>类，可以是<code class="fe no np nq nr b">Result.Ok</code>或<code class="fe no np nq nr b">Result.Errors</code>。使用它，功能是免费的副作用。</p><h2 id="f7fc" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated">撰写个人姓名</h2><p id="54fa" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">现在我们可以创建一些可能导致错误或期望值的<code class="fe no np nq nr b">Result&lt;NotEmptyString&gt;</code>。从这些，我们需要获得一个<code class="fe no np nq nr b">PersonalName</code>。如果你习惯于像<a class="ae ky" href="https://www.baeldung.com/java-optional" rel="noopener ugc nofollow" target="_blank">Java</a>T15】或<a class="ae ky" href="https://www.baeldung.com/kotlin-null-safety" rel="noopener ugc nofollow" target="_blank"> Kotlin nullables </a>这样的“单子式”结构，那么你可以预期我将会写一个无限的<code class="fe no np nq nr b">.flatMap.flatMap.map…</code>或<code class="fe no np nq nr b">let.let.let…</code>列表。</p><p id="57cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不是。这就是<a class="ae ky" href="https://github.com/lucapiccinelli/konad" rel="noopener ugc nofollow" target="_blank"> Konad </a>大放异彩的地方。我们将使用Konad的组合API创建一个<code class="fe no np nq nr b">PersonalName</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="bf13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Konad累积所有的误差。示例中的<code class="fe no np nq nr b">println</code>将打印所有错误的列表，用新的一行<code class="fe no np nq nr b">name.description("\n")</code>隔开。</p><h2 id="ffe1" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated">移除标志</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa lx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://media.giphy.com/media/Lec4TntkAgnQc/giphy.gif" rel="noopener ugc nofollow" target="_blank"> Giphy </a>提供</p></figure><p id="f241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">邮件可以验证，也可以不验证。在初始模型中，有一个布尔标志<code class="fe no np nq nr b">isVerified</code>保存这个信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="936c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该标志不是类型安全的。每当我们需要一封经过验证的电子邮件时，都需要进行检查。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在编译时无法检查。我的首选方法是为<code class="fe no np nq nr b">Unverified</code>状态创建一个类型，为<code class="fe no np nq nr b">Verified</code>创建一个类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="609d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">sendPasswordRecovery</code>功能可以改变如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="f575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">if</code>已经过去了，不可能有人忘记检查<code class="fe no np nq nr b">verified</code>状态。此外，您不需要阅读实现来理解只有经过验证的电子邮件才能实现密码恢复。</p><h2 id="42fb" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated">验证电子邮件</h2><p id="92b1" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我们需要限制电子邮件的结构，就像我们已经为<code class="fe no np nq nr b">NotEmptyString</code>做的那样。</p><p id="ba4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个<code class="fe no np nq nr b">Verified</code>电子邮件，你需要一个<code class="fe no np nq nr b">Unverified</code>电子邮件。由此可见，只对<code class="fe no np nq nr b">Unverified</code>电子邮件实施验证就足够了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="05cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意</em> <code class="fe no np nq nr b"><em class="lv">Unverified</em></code> <em class="lv">变成了普通类，而不是数据类。这是因为没有办法使私有的</em> <code class="fe no np nq nr b"><em class="lv">copy</em></code> <em class="lv">方法成为一个数据类。</em></p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="287b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">最后，声明性模型</h1><p id="65dc" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">最后，这个模型看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="fa34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要看一下就能明白所有的要求:一个联系人由一个名字和一个邮箱组成；名称由三个不能为空的字符串组成；其中一个字符串可能丢失；电子邮件可以是未验证的，也可以是已验证的。</p><p id="3c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一些示例服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c9c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如何打造一个<code class="fe no np nq nr b">ContactInfo</code>。再次，用<a class="ae ky" href="https://github.com/lucapiccinelli/konad" rel="noopener ugc nofollow" target="_blank"> Konad </a>的组合API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="dede" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="4869" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">使用建议的方法，您不需要查看任何方法实现就可以理解:</p><ul class=""><li id="7d06" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">数据的结构</li><li id="06ac" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">所有的限制</li><li id="0958" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">涉及这些数据的流程</li></ul><p id="bce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都在签名里！</p><p id="8c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计确保编译时安全且没有副作用的类并不容易。我提出了一些实现示例，使用:</p><ul class=""><li id="1101" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">用几行代码实现可读的数据检查。</li><li id="819f" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><a class="ae ky" href="https://github.com/lucapiccinelli/konad" rel="noopener ugc nofollow" target="_blank"> Konad </a>提高编译时安全性。</li></ul><p id="9a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单子的使用增加了代码的复杂性。使用Konad，您可以受益于它们的编译时安全性，同时对代码复杂性的影响最小。Konad composition API易于使用，不需要任何函数概念的知识。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="0578" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">代码和材料</h1><p id="1433" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">下面是完整的代码示例。你可以在以下回购处找到:【https://github.com/lucapiccinelli/typesafe-domain-model】T4。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="ff0c" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">感谢</h1><p id="0b15" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">这篇文章基于Scott Wlaschin 带来的概念，他的演讲(和书)“<a class="ae ky" href="https://www.youtube.com/watch?v=Qt2iGKT09UY&amp;t=3095s" rel="noopener ugc nofollow" target="_blank">领域建模功能化</a>”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or lx l"/></div></figure><p id="0496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>