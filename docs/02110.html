<html>
<head>
<title>Learn React Hooks in 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在5分钟内学会反应钩子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-react-hooks-in-5-minutes-f600113e4424?source=collection_archive---------16-----------------------#2019-11-06">https://betterprogramming.pub/learn-react-hooks-in-5-minutes-f600113e4424?source=collection_archive---------16-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f6de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React中最常用的两个钩子:useState和useEffect</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63e5433109614f3fec0b137da59e2f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eyI9pbFoS3eo-tQCCmtrPg.jpeg"/></div></div></figure><p id="8e01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将看看React中最常用的两个钩子:<code class="fe lq lr ls lt b">useState</code>和<code class="fe lq lr ls lt b">useEffect</code>。</p><p id="a6f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你不熟悉钩子，这里有TL；DR:因为钩子，几乎不再需要基于类的组件。钩子允许您“钩入”功能组件中组件的底层生命周期和状态变化。不仅如此，它们还提高了组件的可读性和组织性。</p><p id="aa98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lu">如果你想对这个主题有一个适当的介绍，你可以在Scrimba上查看我们的</em> <a class="ae lv" href="https://scrimba.com/g/greact?utm_source=medium.com&amp;utm_medium=referral&amp;utm_campaign=hooks_article" rel="noopener ugc nofollow" target="_blank"> <em class="lu">高级反应课程</em> </a> <em class="lu">。或者，如果你还是初学者，报名参加我们的</em> <a class="ae lv" href="https://scrimba.com/g/glearnreact?utm_source=medium.com&amp;utm_medium=referral&amp;utm_campaign=hooks_article" rel="noopener ugc nofollow" target="_blank"> <em class="lu">免费课程</em> </a> <em class="lu">学习React。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6190" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">使用状态</h1><p id="b1df" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">让我们从一个功能组件开始。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="58f8" class="ne me it lt b gy nf ng l nh ni">import React from 'react'; <br/>function App() { <br/>  return (<br/>    &lt;div&gt; <br/>      &lt;h1&gt;0&lt;/h1&gt; <br/>      &lt;button&gt;Change!&lt;/button&gt; <br/>    &lt;/div&gt;<br/>  ); <br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d3754de33f9101fcff460024970a82f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*ZHpKZLDXQOgaG5FhNRAGaA.png"/></div></figure><p id="f436" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，目前还没有什么新奇的东西。我们只是渲染一些文本和一个(无用的)按钮。</p><p id="1fc6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们导入我们的第一个钩子<code class="fe lq lr ls lt b">useState</code>，并学习如何在我们的函数组件中处理状态。</p><p id="ed60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这个钩子是一个函数，让我们<code class="fe lq lr ls lt b">console.log</code>我们从它那里得到什么返回。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="e0a6" class="ne me it lt b gy nf ng l nh ni">import React, { useState } from 'react'; </span><span id="8c83" class="ne me it lt b gy nk ng l nh ni">function App() { <br/>  const value = useState(); <br/>  console.log(value); <br/>  return ( <br/>    &lt;div&gt; <br/>      &lt;h1&gt;0&lt;/h1&gt; <br/>      &lt;button&gt;Change!&lt;/button&gt; <br/>    &lt;/div&gt;<br/>  ); <br/>}</span></pre><p id="4fe6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在控制台中，我们得到一个数组。</p><p id="d29c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们把一个论点传递给<code class="fe lq lr ls lt b">useState</code>时:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="4d0e" class="ne me it lt b gy nf ng l nh ni">const value = useState(true);</span></pre><p id="c07f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在控制台中，我们得到一个数组，我们的值作为第一个成员:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="da63" class="ne me it lt b gy nf ng l nh ni">&gt; [true, ƒ()]</span></pre><p id="c87f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在我们的组件中，我们可以在<code class="fe lq lr ls lt b">value[0]</code>访问我们的状态，并在<code class="fe lq lr ls lt b">&lt;h1&gt;</code>中呈现它，而不是硬编码的值。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="1d38" class="ne me it lt b gy nf ng l nh ni">import React, { useState } from 'react';<br/><br/>function App() {<br/>  const value = useState(0);<br/>  console.log(value); // [0, ƒ()]<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{value[0]}&lt;/h1&gt;<br/>      &lt;button&gt;Change!&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d3754de33f9101fcff460024970a82f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*ZHpKZLDXQOgaG5FhNRAGaA.png"/></div></figure><p id="a6d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过使用数组析构来存储来自<code class="fe lq lr ls lt b">useState</code>钩子的值来改进代码。这类似于更常见的对象析构。如果你不太熟悉对象析构，这里有一个快速回顾:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="5f42" class="ne me it lt b gy nf ng l nh ni">const person = {<br/>  name: 'Joe',<br/>  age: 42<br/>};<br/><br/>// creates 2 const values from person object<br/>const { name, age } = person;<br/>console.log(name); // 'Joe'<br/>console.log(age); // 42</span></pre><p id="8904" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数组析构几乎相同，但是使用方括号<code class="fe lq lr ls lt b">[]</code>代替花括号<code class="fe lq lr ls lt b">{}</code>。</p><p id="fabe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">快速提示:在对象析构中，所创建变量的名称必须与对象中属性的名称相匹配。对于数组析构来说，情况并非如此。一切都是为了秩序。这里的好处是我们可以随意命名这些项目。</p><p id="0980" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用数组析构，我们可以从<code class="fe lq lr ls lt b">useState()</code>钩子中获得状态的初始值。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="e988" class="ne me it lt b gy nf ng l nh ni">import React, { useState } from 'react';<br/><br/>function App() {<br/>  <br/>  // remember, there's a second item from the array that's missing here, but we'll come right back to use it soon<br/>  <br/>  const [count] = useState(0);  <br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{count}&lt;/h1&gt;<br/>      &lt;button&gt;Change!&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="de1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，我们已经得到了初始状态值。我们如何用钩子改变状态中的值？</p><p id="f099" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还记得<code class="fe lq lr ls lt b">useState()</code> hook返回一个有两个成员的数组吗？第二个成员是更新状态的函数！</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="5aa3" class="ne me it lt b gy nf ng l nh ni">const [count, setCount] = useState(0);</span></pre><p id="7a95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，您可以随意称呼它，但是按照惯例，它通常以前缀“set-”命名，然后是我们希望更新的状态变量的名称。所以在这种情况下，<code class="fe lq lr ls lt b">setCount</code>就是。</p><p id="319e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用这个功能很简单。只需调用它并传递您希望该状态拥有的新值！或者，就像类组件中的<code class="fe lq lr ls lt b">this.setState</code>一样，可以传递一个接收旧状态并返回新状态的函数。经验法则:当您需要依靠过去的状态来确定新状态时，请随时这样做。</p><p id="8338" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了调用它，我们将把它传递给<code class="fe lq lr ls lt b">onClick</code>事件监听器。就像基于类的组件中的常规<code class="fe lq lr ls lt b">setState</code>一样，我们可以将状态更新传递给<code class="fe lq lr ls lt b">setCount</code>。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="f190" class="ne me it lt b gy nf ng l nh ni">function App() {<br/>  const [count, setCount] = useState(0);<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{count}&lt;/h1&gt;<br/>      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;<br/>        Change!<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="cdaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过将状态更新提取到一个单独的函数中来稍微清理一下。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="1917" class="ne me it lt b gy nf ng l nh ni">function App() {<br/>  const [count, setCount] = useState(0);<br/><br/>  function change() {<br/>    setCount(prevCount =&gt; prevCount + 1);<br/>  }<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{count}&lt;/h1&gt;<br/>      &lt;button onClick={change}&gt;Change!&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="8fd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了！现在，当我们点击按钮时，我们可以看到计数器在上升。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/2349a3bedffc91c50231529c65718a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*yajFVB5c3uBmFtbm3kJJ4w.png"/></div></figure><p id="9cd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，<code class="fe lq lr ls lt b">useState</code>可以比这复杂得多，但是我们只有五分钟的时间，所以现在让我们进入下一个钩子。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0ddd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">使用效果</h1><p id="2437" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">与基于类的组件相比，钩子简化了很多事情。以前，我们需要了解一些生命周期方法，以及哪种方法最适合哪种情况。<code class="fe lq lr ls lt b">useEffect</code> hook简化了这种情况。如果您希望执行副作用、网络请求、手动DOM操作、事件监听器或超时和间隔。</p><p id="5b66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">useEffect</code>钩子可以像<code class="fe lq lr ls lt b">useState</code>一样导入。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="8490" class="ne me it lt b gy nf ng l nh ni">import React, { useState, useEffect } from 'react';</span></pre><p id="0fb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了让<code class="fe lq lr ls lt b">useEffect</code>做点什么，我们给它传递一个匿名函数作为参数。每当React重新渲染这个组件时，它都会运行我们传递给<code class="fe lq lr ls lt b">useEffect</code>的函数。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="0ebb" class="ne me it lt b gy nf ng l nh ni">useEffect(() =&gt; { <br/>  <br/>  /* any update can happen here */ </span><span id="f478" class="ne me it lt b gy nk ng l nh ni">});</span></pre><p id="2a3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">整个代码可能是这样的:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="67dc" class="ne me it lt b gy nf ng l nh ni">import React, { useState, useEffect } from 'react';<br/><br/>function App() {<br/>  const [count, setCount] = useState(0);<br/><br/>  function change() {<br/>    setCount(prevCount =&gt; prevCount + 1);<br/>  }<br/><br/>  useEffect(() =&gt; {<br/>    /* any update can happen here */<br/>  });<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{count}&lt;/h1&gt;<br/>      &lt;button onClick={change}&gt;Change!&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre><p id="9dbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我们将使用一个漂亮的<code class="fe lq lr ls lt b">npm</code>包来生成随机颜色。如果你愿意的话，你可以自由地写你自己的，但是对于这个教程，我们只是安装它，<code class="fe lq lr ls lt b">npm i randomcolor</code>，然后导入。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="cb05" class="ne me it lt b gy nf ng l nh ni">import randomcolor from 'randomcolor';</span></pre><p id="2070" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们用我们关于<code class="fe lq lr ls lt b">useState</code>钩子的知识在状态中存储一些随机颜色。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="fcfb" class="ne me it lt b gy nf ng l nh ni">const [color, setColor] = useState(''); <br/>// initial value can be an empty string</span></pre><p id="f05f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们可以分配我们已经拥有的计数器的颜色。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="f79d" class="ne me it lt b gy nf ng l nh ni">&lt;h1 style={{ color: color }}&gt;{count}&lt;/h1&gt;</span></pre><p id="e058" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，为了方便起见，让我们在每次点击<code class="fe lq lr ls lt b">Change!</code>按钮时改变计数器的颜色。<code class="fe lq lr ls lt b">useEffect</code>每次组件重新渲染都会运行，每次状态改变组件都会重新渲染。</p><p id="247f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着如果我们编写下面的代码，我们将陷入一个无限循环！这是<code class="fe lq lr ls lt b">useEffect</code>的一个常见问题</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="3504" class="ne me it lt b gy nf ng l nh ni">useEffect(() =&gt; { <br/>  setColor(randomcolor()); <br/>});</span></pre><p id="17fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">setColor</code>更新状态，重新呈现组件，组件调用<code class="fe lq lr ls lt b">useEffect</code>，运行<code class="fe lq lr ls lt b">setColor</code>更新状态，重新呈现组件...呀！</p><p id="813d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当变量<code class="fe lq lr ls lt b">count</code>改变时，我们大概只有<em class="lu">想要运行这个<code class="fe lq lr ls lt b">useEffect</code>。</em></p><p id="f383" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了告诉<code class="fe lq lr ls lt b">useEffect</code>要跟踪哪些变量，我们给出一个这样的变量数组作为第二个参数:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="6a62" class="ne me it lt b gy nf ng l nh ni">useEffect(() =&gt; { <br/>  setColor(randomcolor()); <br/>}, [count]);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5f13a651915e09b8ca416e880f53b446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*9DkbcyKf_e3DsB-KykQSWQ.png"/></div></figure><p id="71d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这基本上是说“只有当状态改变时，才运行这个效果<em class="lu">。这样，我们可以改变颜色，而不会影响到无限运行。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e0b5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="3553" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">关于钩子还有很多东西要学，但是我希望你喜欢这五分钟的快速浏览。</p><p id="a4d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要了解更多关于React挂钩和React的其他强大功能，您可以加入我们<a class="ae lv" href="https://scrimba.com/g/greact?utm_source=medium.com&amp;utm_medium=referral&amp;utm_campaign=hooks_article" rel="noopener ugc nofollow" target="_blank">即将推出的高级React课程</a>的等候名单。或者，如果你正在寻找一个对初学者更友好的方法，你可以看看我们关于React的入门课程。</p></div></div>    
</body>
</html>