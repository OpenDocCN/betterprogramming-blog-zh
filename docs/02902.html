<html>
<head>
<title>JavaScript’s Object Constructor: Preventing Changes and Getting Entries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的对象构造函数:防止更改和获取条目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascripts-object-constructor-preventing-changes-and-getting-entries-1d27882c19f3?source=collection_archive---------23-----------------------#2020-01-07">https://betterprogramming.pub/javascripts-object-constructor-preventing-changes-and-getting-entries-1d27882c19f3?source=collection_archive---------23-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecb9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何防止更改和获取条目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb375c5037f3e3eb13743c683e519a52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0o_-bMDcvCxWPuZQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@delfidelarua7?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德尔菲·德拉鲁阿</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="91ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，<code class="fe lv lw lx ly b">Object</code>构造函数让我们用给定的值创建一个对象包装器。如果将<code class="fe lv lw lx ly b">null</code>或<code class="fe lv lw lx ly b">undefined</code>传递给<code class="fe lv lw lx ly b">Object</code>构造函数，它将创建一个空对象。</p><p id="9d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果传入构造函数的值已经是一个对象，那么它将返回该对象。</p><p id="fa95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object</code>构造函数有两个属性。它有一个始终为1的<code class="fe lv lw lx ly b">length</code>属性，像所有其他对象一样，<code class="fe lv lw lx ly b">Object</code>构造函数有一个原型来获取类型<code class="fe lv lw lx ly b">Object</code>的所有附加属性。</p><p id="3050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究如何防止更改并获取键和值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d8a3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.isSealed()</code></h1><p id="479a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.isSealed()</code>方法用于检查对象是否密封。</p><p id="af01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密封一个对象意味着我们防止新的属性被添加到一个对象中，并将所有现有的属性标记为不可配置，这意味着属性的属性描述符不能改变，属性不能被删除。</p><p id="7551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性描述符是一个对象，其属性名作为关键字，属性<code class="fe lv lw lx ly b">writable</code>、<code class="fe lv lw lx ly b">configurable</code>、<code class="fe lv lw lx ly b">enumerable</code>和<code class="fe lv lw lx ly b">value</code>作为属性名关键字的属性。</p><p id="04cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">writable</code>表示属性值可以更改。<code class="fe lv lw lx ly b">configurable</code>表示属性描述符是否可以更改，以及属性是否可以从对象中删除。</p><p id="1e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">enumerable</code>属性表示该属性在用<code class="fe lv lw lx ly b">for...in</code>循环枚举属性的过程中出现，<code class="fe lv lw lx ly b">value</code>是该属性的值。</p><p id="4aa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对象是密封的，则返回<code class="fe lv lw lx ly b">true</code>，否则返回<code class="fe lv lw lx ly b">false</code>。例如，我们可以使用如下函数:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="92fe" class="nh mh it ly b gy ni nj l nk nl">let obj = {};<br/>const objSealed = Object.isSealed(obj);<br/>console.log(objSealed);</span></pre><p id="43c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最简单的情况，其中对象没有被显式密封或者修改了属性描述符。上面的<code class="fe lv lw lx ly b">console.log</code>语句将返回<code class="fe lv lw lx ly b">false</code>,因为对象不是密封的。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0d5b" class="nh mh it ly b gy ni nj l nk nl">let obj = {};<br/>Object.preventExtensions(obj);<br/>const objSealed = Object.isSealed(obj);<br/>console.log(objSealed);</span></pre><p id="e40a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们调用<code class="fe lv lw lx ly b">Object.preventExtensions()</code>方法来阻止属性被添加，那么上面代码中的<code class="fe lv lw lx ly b">objSealed</code>将返回<code class="fe lv lw lx ly b">true</code>，因为我们用<code class="fe lv lw lx ly b">Object.preventExtensions()</code>方法阻止了属性被添加，并且对象中没有现有的属性。这只适用于空对象。</p><p id="d3aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将带有<code class="fe lv lw lx ly b">configuration</code>属性的属性描述符设置为<code class="fe lv lw lx ly b">false</code>，并对对象调用<code class="fe lv lw lx ly b">Object.preventExtensions()</code>，那么<code class="fe lv lw lx ly b">Object.isSealed()</code>将返回<code class="fe lv lw lx ly b">true</code>，因为我们阻止了对象属性的属性描述符被修改或删除。</p><p id="0bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="11b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在一个对象上调用<code class="fe lv lw lx ly b">Object.seal()</code>方法，那么它会做一切事情来密封该对象，包括防止属性被添加，防止现有属性的属性描述符被修改，以及防止对象的属性被删除。</p><p id="726d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3ea2" class="nh mh it ly b gy ni nj l nk nl">let sealedObj = { a: 1 };<br/>Object.seal(sealedObj);<br/>console.log(Object.isSealed(sealedObj));</span></pre><p id="1f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe lv lw lx ly b">console.log</code>将记录<code class="fe lv lw lx ly b">true</code>，因为我们在对象上调用了<code class="fe lv lw lx ly b">Object.seal()</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9726" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.keys()</code></h1><p id="ea98" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.keys()</code>方法返回一个字符串形式的对象属性名数组，这些属性名被设置为可枚举的。它们的返回顺序与普通循环相同。</p><p id="77c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个数组作为参数传入，那么我们返回数组的索引。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5d2a" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>};<br/>console.log(Object.keys(obj));</span></pre><p id="de21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们运行<code class="fe lv lw lx ly b">console.log</code>时，我们得到<code class="fe lv lw lx ly b">[“a”, “b”, “c”]</code>，因为我们在对象<code class="fe lv lw lx ly b">obj</code>中有这些属性名。</p><p id="6164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以将数组传递给这个方法。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ca35" class="nh mh it ly b gy ni nj l nk nl">const arr = [1, 2, 3];<br/>console.log(Object.keys(arr));</span></pre><p id="2d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们运行<code class="fe lv lw lx ly b">console.log</code>时，我们得到<code class="fe lv lw lx ly b">[“0”, “1”, “2”]</code>，因为我们在<code class="fe lv lw lx ly b">arr</code>数组中有这些属性作为索引。如果我们有一个类似数组的对象，它包含所有的数字键，那么我们将按顺序返回这些键。</p><p id="d2b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7804" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  2: 1,<br/>  3: 2,<br/>  1: 3<br/>};<br/>console.log(Object.keys(obj));</span></pre><p id="2959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们运行<code class="fe lv lw lx ly b">console.log</code>时，我们得到<code class="fe lv lw lx ly b">[“1”, “2”, “3”]</code>，因为我们有数字键，<code class="fe lv lw lx ly b">Object.keys()</code>方法将按升序返回数字键。</p><p id="5e46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有数字键和非数字键的混合，那么数字键将在其余的键被返回之前以升序被返回。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="aa6d" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  a: 1,<br/>  3: 2,<br/>  1: 3<br/>};<br/>console.log(Object.keys(obj));</span></pre><p id="5fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行<code class="fe lv lw lx ly b">console.log</code>时，我们得到<code class="fe lv lw lx ly b">[“1”, “3”, “a”]</code>。</p><p id="a8d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.keys()</code>只返回可枚举属性的名称。例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe lv lw lx ly b">console.log</code>将返回一个空数组，因为属性<code class="fe lv lw lx ly b">a</code>有一个属性描述符，其中<code class="fe lv lw lx ly b">enumerable</code>被设置为<code class="fe lv lw lx ly b">false</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0dec" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.preventExtensions()</code></h1><p id="2a95" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.preventExtensions()</code>方法防止新属性被添加到对象中。在对其调用<code class="fe lv lw lx ly b">Object.preventExtensions()</code>后，不能添加新属性。</p><p id="52df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，仍然可以删除现有属性。一个对象不可扩展后就不能再扩展了。它的返回值是不可扩展的对象。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="fead" class="nh mh it ly b gy ni nj l nk nl">let obj = {};<br/>Object.preventExtensions(obj);<br/>Object.defineProperty(obj, 'a', {})</span></pre><p id="8868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将得到一条错误消息，说明:<code class="fe lv lw lx ly b">‘Cannot define property a, object is not extensible.’</code></p><p id="dbcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们所期望的，因为我们阻止了使用<code class="fe lv lw lx ly b">Object.preventExtensions()</code>方法将属性添加到对象中。</p><p id="b305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们尝试用点符号向它添加一个属性，如下面的代码所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="741f" class="nh mh it ly b gy ni nj l nk nl">let obj = {};<br/>Object.preventExtensions(obj);<br/>obj.a = 1;<br/>console.log(obj);</span></pre><p id="d7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从我们对它调用了<code class="fe lv lw lx ly b">Object.preventExtension()</code>之后，我们得到了一个空的日志对象。如果我们像下面的代码一样以严格模式运行上面的代码，我们将得到<code class="fe lv lw lx ly b">‘Cannot define property a, object is not extensible.’</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a231" class="nh mh it ly b gy ni nj l nk nl">'use strict';<br/>let obj = {};<br/>Object.preventExtensions(obj);<br/>obj.a = 1;<br/>console.log(obj);</span></pre><p id="0713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们向该方法传递一个原始值，它将被原样返回，就好像它是一个不可扩展的对象。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e8be" class="nh mh it ly b gy ni nj l nk nl">console.log(Object.preventExtensions(1));</span></pre><p id="64a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们得到1，因为它原样返回原始值。在ES5中，相同的代码将记录一个<code class="fe lv lw lx ly b">TypeError</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8c98" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.seal()</code></h1><p id="bb3d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.seal()</code>方法密封一个对象。密封一个对象意味着我们防止新的属性被添加到一个对象中，并将所有现有的属性标记为不可配置，这意味着属性的属性描述符不能改变，属性不能被删除。</p><p id="95ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性的值仍然可以被修改，除非它们的属性描述符的<code class="fe lv lw lx ly b">writable</code>属性被显式地设置为<code class="fe lv lw lx ly b">false</code>。原型链没有被修改，但是<code class="fe lv lw lx ly b">__proto__</code>属性也被密封。</p><p id="7e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对象上调用<code class="fe lv lw lx ly b">Object.seal()</code>之前，可以添加属性，修改属性描述符，或者随意删除属性。例如，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在<code class="fe lv lw lx ly b">obj</code>上运行了<code class="fe lv lw lx ly b">console.log</code>，那么我们会看到我们得到了<code class="fe lv lw lx ly b">{a: 3}</code>，因为我们修改了<code class="fe lv lw lx ly b">a</code>的值并删除了<code class="fe lv lw lx ly b">b</code>属性。</p><p id="a5ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，JavaScript对象是不密封的，所以您可以随意更改属性。</p><p id="48ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们对一个对象调用<code class="fe lv lw lx ly b">Object.seal()</code>，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">console.log</code>输出中得到<code class="fe lv lw lx ly b">{a: 3, b: 2}</code>,因为<code class="fe lv lw lx ly b">Object.seal()</code>阻止属性被删除，但是不阻止属性值被赋值。例如，如果我们有以下代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e086" class="nh mh it ly b gy ni nj l nk nl">let obj = {<br/>  a: 1,<br/>  b: 2<br/>};<br/>Object.seal(obj)<br/>console.log(Object.getOwnPropertyDescriptors(obj));</span></pre><p id="c3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">console.log</code>中，因为<code class="fe lv lw lx ly b">Object.seal()</code>的全部目的是将每个属性描述符的<code class="fe lv lw lx ly b">configurable</code>属性设置为<code class="fe lv lw lx ly b">false</code>。</p><p id="551d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着不能再更改它们的属性描述符，也不能从对象中删除这些属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/44515a3124a5a5978d408e5df1cc9b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DhZefnH3xdjLPEO-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@alvaroreyes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿尔瓦罗·雷耶斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0fae" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.setPrototypeOf()</code></h1><p id="8bce" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.setPrototypeOf()</code>方法让我们设置一个对象的原型。它需要两个参数。第一个参数是要更改其原型的对象，第二个参数是要将其设置为的原型对象。</p><p id="a66e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们改变了调用<code class="fe lv lw lx ly b">Object.setPrototypeOf()</code>的对象所继承的对象。</p><p id="0010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法不能在不可扩展的对象上调用，也就是说，不能在那些有<code class="fe lv lw lx ly b">Object.isExtensible()</code>返回<code class="fe lv lw lx ly b">false</code>的对象上调用。如果<code class="fe lv lw lx ly b">prototype</code>参数不是一个对象或者它是<code class="fe lv lw lx ly b">null</code>，它什么也不做。</p><p id="17cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个普通的对象，那么我们可以用<code class="fe lv lw lx ly b">Object.setPrototypeOf()</code>方法设置对象的原型。返回具有原型集的对象。例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe lv lw lx ly b">{a: 3, b: 4}</code>作为<code class="fe lv lw lx ly b">newObj</code>的值，它的原型是<code class="fe lv lw lx ly b">proto</code>对象。我们也可以用这个方法将一个对象的原型设置为<code class="fe lv lw lx ly b">null</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8dbd" class="nh mh it ly b gy ni nj l nk nl">let obj = {<br/>  a: 3,<br/>  b: 4<br/>};<br/>const newObj = Object.setPrototypeOf(obj, null);<br/>console.log(newObj);</span></pre><p id="db71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe lv lw lx ly b">{a: 3, b: 4}</code>作为原型为<code class="fe lv lw lx ly b">null</code>的<code class="fe lv lw lx ly b">newObj</code>的值。如果设置原型的对象是不可扩展的，则该方法不起作用。例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dfde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们会得到一个<code class="fe lv lw lx ly b">TypeError</code>因为对象是密封的，也就是说所有的属性包括prototype属性都不能添加。</p><p id="8828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果我们冻结一个对象，这将密封一个对象，并防止属性值被更改，当我们调用此方法时，它也将失败。例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们会得到一个<code class="fe lv lw lx ly b">TypeError</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="263b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.values()</code></h1><p id="0443" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.values()</code>方法返回一个对象数组，这些对象是对象中可枚举的顶级属性的值。它们以与<code class="fe lv lw lx ly b">for...in</code>循环中相同的顺序返回。</p><p id="82b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe lv lw lx ly b">Object.values()</code>不返回原型链上的属性值。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2f48" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>};</span><span id="aacc" class="nh mh it ly b gy np nj l nk nl">console.log(Object.values(obj));</span></pre><p id="2cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe lv lw lx ly b">[1, 2, 3]</code>，因为我们在<code class="fe lv lw lx ly b">obj</code>对象中列出了三个属性。如果我们有一个像array这样的对象，所有的数字键都在里面，那么它们是按升序排列的。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3312" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  6: 1,<br/>  5: 2,<br/>  4: 3<br/>};<br/>console.log(Object.values(obj));</span></pre><p id="6deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们记录了<code class="fe lv lw lx ly b">[3,2,1]</code>,因为这些键都是数字，所以是升序排列的。如果我们有一个数组，那么这个数组将原样返回。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ac31" class="nh mh it ly b gy ni nj l nk nl">const arr = [1, 2, 3]<br/>console.log(Object.values(arr));</span></pre><p id="64de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们记录了<code class="fe lv lw lx ly b">[1, 2, 3]</code>，因为我们向<code class="fe lv lw lx ly b">Object.values()</code>方法传递了一个数组。如果我们有不可枚举的属性值，那么它们不会被列出。例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c61b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们记录了<code class="fe lv lw lx ly b">[“a”]</code>,因为我们只有属性<code class="fe lv lw lx ly b">a</code>是可枚举的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7d53" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="ddf3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object</code>构造函数有更多的方法来从一个带有键值的数组中构造对象，还有从对象、属性名和属性符号中获取属性描述符的方法。</p><p id="a7f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它获取对象的键，防止属性被添加、删除或修改它们的属性描述符。</p><p id="c7f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们对于控制属性的行为非常有用，因为JavaScript对象在默认情况下是动态的。这些方法可以更容易地防止意外更改。</p></div></div>    
</body>
</html>