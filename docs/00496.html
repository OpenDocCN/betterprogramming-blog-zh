<html>
<head>
<title>Angular and RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度和RxJS</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-rxjs-async-pipe-deep-dive-2510b56f793a?source=collection_archive---------0-----------------------#2019-06-01">https://betterprogramming.pub/angular-rxjs-async-pipe-deep-dive-2510b56f793a?source=collection_archive---------0-----------------------#2019-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a9c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入研究异步管道</h2></div><p id="eb2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经用异步管道的分叉版本构建了一个示例角度应用程序。我在整个分叉版本中添加了标记为<code class="fe le lf lg lh b">Async:</code>的console.log()语句，其他内容保持不变。这些组件模拟了异步管道的各种情况。</p><p id="4f01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下载<a class="ae li" href="https://github.com/Everduin94/forked-async-pipe-tester" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/a92b6c244a2607fe6a8e36a957439439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*TNhAJQfiHCb8cM3OA4fDvg.png"/></div></figure><p id="0f31" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将介绍几个异步管道在运行时如何工作的例子，以及异步管道在高性能和可维护代码中的实际应用。如果异步管道对你来说是新的，请看<a class="ae li" href="https://angular.io/guide/observables-in-angular#async-pipe" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae li" href="https://angular.io/api/common/AsyncPipe" rel="noopener ugc nofollow" target="_blank">这里</a>快速介绍。</p><h1 id="5cae" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">异步管道创建</strong></h1><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/f11cd520a9e2f66f618e815bfe23e03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7MmiQWlnn2niVYhen-CM8w.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">intro.component.html</p></figure><p id="d936" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个异步管道被创建时，它将在每个变化检测周期开始调用<code class="fe le lf lg lh b">transform()</code>。在第一次调用transform时，将从我们传入的可观察对象中创建一个订阅。如果我们的可观察值发出一个新值，显示值(<code class="fe le lf lg lh b">this._latestValue</code>)将被更新。</p><p id="09ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，<code class="fe le lf lg lh b">obj</code>是我们传入的可观测量，也称为源可观测量。<code class="fe le lf lg lh b">this._obj</code>是异步管道中可观察对象的保存状态。<code class="fe le lf lg lh b">this._latestValue</code>是我们在<code class="fe le lf lg lh b">{{data}}</code>中看到的值，我们称之为我们的显示/最新值。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ms"><img src="../Images/9de631e80f1880d5664eca325473761a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62eFl13vNy6nBPjP-sXjrw.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">异步管道</p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/fd48d02391e0084dd2b3a9862d715225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*AEr3WuEpl9PP26xgIloigA.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">observable$ | async的初始输出</p></figure><h1 id="a65a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">实用:不要为同一个可观察对象创建多个异步管道</h1><p id="61e5" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">对于创建的每个异步管道，将会创建一个新的冗余订阅。每个管道的转换方法将在每个变化检测周期被调用。使用<code class="fe le lf lg lh b">as</code>，我们可以重用来自异步管道的最新值，并维护单一订阅。这将保持我们的应用程序的性能和可维护性。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mz"><img src="../Images/91ed22069b74e5962fed20d79261cbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMhiLu7iI7Tfd35usGC-oQ.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">clean . component . ts &amp; dirty . component . ts</p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi na"><img src="../Images/4d154a7f23860ef2411ad821429f1433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kW4gUtB2Tbaj5ZFVksbPw.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">清洁.组件. ts</p></figure><p id="e785" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">clean.component.html</code>中，当<code class="fe le lf lg lh b">observable$</code>发出一个值时，一个change事件将被触发，transform方法将被调用一次。在<code class="fe le lf lg lh b">dirty.component.html</code>中，当<code class="fe le lf lg lh b">observable$</code>发出一个值时，将触发三个change事件，每个异步管道将调用transform方法三次。对于三个冗余管道，输出如下所示:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nb"><img src="../Images/9d2967f583b214dd5fa36c0126e7349c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQYbxDiB6ZrVTB4kVlh5ZA.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">dirty.component.html</p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b1049b7055c38ee564af938e39519b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*-nhjsIu5Q3JXkxphXaH7NA.png"/></div></figure><h1 id="40ed" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">异步管道破坏</strong></h1><p id="2dd4" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">当异步管道的容器从DOM中移除或者其父组件被销毁时，异步管道将被销毁。当异步管道被销毁时，它会执行任何必要的清理，例如取消订阅。在任何时候，我们都不需要显式地/手动地对源可观察对象的订阅调用unsubscribe。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nd"><img src="../Images/8cfcafbe83ca0649c412205355774766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5xn2J2FxCrZRPGuofBgTw.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">toggle.component.html</p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1791f6e4d026af6839bbe6fe20f25bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*MBoDPy-IA49sSnzT0j6lbg.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">切换异步容器的创建/销毁</p></figure><p id="bac5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过在Google Chrome开发工具中运行分配时间表来验证我们的订户正在被清理。从51个订户开始，我们反复切换组件。一旦我们停止，我们在切换时创建的任何订户都将被释放，因为我们仍然有51个订户。有关分配时间表的更多信息，请参见<a class="ae li" href="https://itnext.io/angular-rxjs-detecting-memory-leaks-bdd312a070a0" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/3d9cca8f3e2d73da2d541db97f2cda5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*YQXoAnku4BVodXRB0Zd4aA.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">分配时间表</p></figure><h1 id="761a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">实用:异步管道联合收割机</h1><p id="6230" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">RxJS操作符<code class="fe le lf lg lh b">combineLatest</code>允许我们将多个可观察值组合成一个包含我们所有值的数组的可观察值。我们可以将这个数组映射到一个对象，然后从异步管道访问该对象上的任何显示值。<a class="ae li" href="https://www.youtube.com/watch?v=Z76QlSpYcck" rel="noopener ugc nofollow" target="_blank">【2】</a></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ng"><img src="../Images/00bd9b0d81f3f34b02ef7d2804f5357b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6RGN4X5EV-PT9-jh-cm5g.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">component.ts</p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi na"><img src="../Images/a3e1e2031919bc2ed2e4c7eec034d86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvhCe0dtPb22YtbU10JdQw.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">combine.component.html</p></figure><p id="9380" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，异步管道将对<code class="fe le lf lg lh b">allData$</code>中任何值的更改视为对对象的单个更改。这使我们的组件保持高性能，只需在检测到变化时发出一次订阅。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/75f31e14e3e3fb2f3ed94244d6313b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*FGk8bkyF4eFBm_Z6Ur9cLQ.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">更改allData$中的值</p></figure><h1 id="ff3b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">异步管道重新分配和完成</h1><h2 id="bba7" class="ni ls it bd lt nj nk dn lx nl nm dp mb kr nn no md kv np nq mf kz nr ns mh nt bi translated">异步管道重新分配</h2><p id="82b5" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">如果源可观察对象被重新分配，异步管道将取消订阅先前的可观察对象，并订阅新的可观察对象。这本质上是边缘案例订阅管理。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nu"><img src="../Images/f99a59d183004a589bede49e1c4d9417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAsXeB6PQrzcjb2twya_tA.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">异步管道</p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/127c2eba5409317dd2a1ac25674037b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*5X-m35Lv2i-gx5WRqUDMZA.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">重新分配可观察的美元</p></figure><h2 id="a34c" class="ni ls it bd lt nj nk dn lx nl nm dp mb kr nn no md kv np nq mf kz nr ns mh nt bi translated">异步管道完成</h2><p id="607a" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">如果观测完成，排放将停止，我们的最新值仍将显示在DOM中。但是，异步管道仍然会在每个更改检测周期调用transform方法，直到它被销毁。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/84644de3f5c5899dc7790e130305edd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*U5IC_It9UQ-M_vsebNx5cg.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">完成后切换更改检测</p></figure><h1 id="b5e4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">实用:适用时使用OnPush进行优化(高级)</h1><p id="b753" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">异步管道在每个变化检测周期调用转换方法，因为它是一个不纯的管道<a class="ae li" href="https://angular.io/guide/pipes" rel="noopener ugc nofollow" target="_blank">【3】</a>。对于每个转换调用，异步管道都执行一个检查来查看最新的值是否已经更改，如果没有，则提前返回。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nx"><img src="../Images/d72a59a36d983955059c131669f096a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9j7baP5F0bVFk5z2m2hnQ.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">异步管道结合我</p></figure><p id="d381" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们可以完全避免这些多余的检查。当异步管道的父组件使用<code class="fe le lf lg lh b">ChangeDectionStrategy.OnPush</code>时，它会进行优化。当父组件使用这种策略时，只有当视图被标记为更改时，才会调用transform。</p><p id="87e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个值从异步管道的源observable发出时，它将通过<code class="fe le lf lg lh b">markForCheck()</code>标记要检查变更的视图。这意味着我们的异步管道只会告诉我们的组件，当它的源observable发出一个值时，它需要重新呈现。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nu"><img src="../Images/27e8b288263b4877d87f1868f3dccbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1x_0bmkP0MeNcoLdomB9qw.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">异步管道</p></figure><p id="54a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，异步管道使我们能够利用<code class="fe le lf lg lh b">ChangeDetectionStrategy.OnPush</code>，而不必显式地/手动地管理变更检测。</p><p id="c49f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过模拟多个变化检测周期来验证这个想法。我在应用程序中添加了一个按钮，通过触发DOM中不相关的事件来模拟变化检测。我们将从测试<code class="fe le lf lg lh b">ChangeDetectionStrategy.Default</code>开始。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ny"><img src="../Images/4407b409609aa10abfba835c163f3d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PuhVRT-EUZU53nUEwHzF8Q.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">组件简介. ts</p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/18f7eba6cae4d59f244f07ee9940224b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*usK18F4PPPIHdpX-RcAa-g.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">默认策略</p></figure><p id="db48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们将更改<code class="fe le lf lg lh b">intro.component.ts</code>以利用推送更改检测策略。我们可以看到transform方法不再被调用十次。请注意，视图仍在我们的应用程序中按预期进行更新。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ny"><img src="../Images/e1447f325559e703edb4c6142d260eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DtIoGmQUbenX3aaW30kewQ.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">组件简介. ts</p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/e93131e6911b33579abe6efdaa03405b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*BfDqF2jVu20qyN-X-zSQwQ.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">推进策略</p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e4ac63f5bc7e3aa356d2cde7ee6ba78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*Fre4B_2_XwnAOkbIesR78w.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">来自异步管道的最新值</p></figure><p id="5080" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">警告</strong>:虽然on-push可以提高我们组件的性能，但是必须谨慎使用，并且只在适用的时候使用。不正确地使用on-push会导致视图没有按预期更新的错误。<a class="ae li" href="https://angular.io/api/core/ChangeDetectionStrategy" rel="noopener ugc nofollow" target="_blank">【4】</a></p><h1 id="8ed4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">摘要</h1><ul class=""><li id="aaa4" class="oc od it kk b kl mu ko mv kr oe kv of kz og ld oh oi oj ok bi translated">对每个可观察对象使用一个异步管道，以避免冗余订阅</li><li id="452f" class="oc od it kk b kl ol ko om kr on kv oo kz op ld oh oi oj ok bi translated">在适用的情况下，使用RxJS combineLatest运算符将数据组合到单个异步管道中</li><li id="fdd1" class="oc od it kk b kl ol ko om kr on kv oo kz op ld oh oi oj ok bi translated">使用异步管道启用推送更改检测策略时要小心，并且仅在适用时才启用</li></ul><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/c148d29c04c453b3d82a9fcab0e670bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*XpWCsZjUUTn0Jr5WODi36Q.png"/></div></figure></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><blockquote class="oy oz pa"><p id="c7fb" class="ki kj pb kk b kl km ju kn ko kp jx kq pc ks kt ku pd kw kx ky pe la lb lc ld im bi translated">☁️<a class="ae li" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank">flotes</a>——尝试演示，不需要登录。或者免费报名。Flotes是我记笔记和高效学习的方式，即使在我很忙的时候。</p></blockquote><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi pf"><img src="../Images/8e468f6e74135bbbc2ecbfce7e2db2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGqAj2R16w33dIiKDnHEUA.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated"><a class="ae li" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank">flots</a></p></figure><h1 id="e464" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">资源/参考资料</h1><p id="c124" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">【答】:简介<a class="ae li" href="https://angular.io/guide/observables-in-angular#async-pipe" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/observables-in-angular#async-pipe</a></p><p id="9279" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[B]:简介<a class="ae li" href="https://angular.io/guide/pipes" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/pipes</a></p><p id="16eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[1]关于检测内存泄漏的文章:<a class="ae li" href="https://itnext.io/angular-rxjs-detecting-memory-leaks-bdd312a070a0" rel="noopener ugc nofollow" target="_blank">https://it next . io/angular-rxjs-detecting-memory-leaks-BDD 312 a 070 a 0</a></p><p id="f5f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2]我在ngConf上看到了这种技术，这要归功于黛博拉·库拉塔。<a class="ae li" href="https://www.youtube.com/watch?v=Z76QlSpYcck" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Z76QlSpYcck</a></p><p id="001d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[3]在本指南中搜索纯净/不纯净管道，了解更多信息<a class="ae li" href="https://angular.io/guide/pipes" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/pipes</a></p><p id="c260" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[4]https://angular.io/api/core/ChangeDetectionStrategy<a class="ae li" href="https://angular.io/api/core/ChangeDetectionStrategy" rel="noopener ugc nofollow" target="_blank"/></p><p id="b5b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[5]我的代码片段内置于<a class="ae li" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank"> https://carbon.now.sh </a></p><p id="d5b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">【6】感谢朋友们的校对和帮我编辑</p></div></div>    
</body>
</html>