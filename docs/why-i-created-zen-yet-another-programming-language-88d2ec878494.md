# 为什么我创造了 Zen(另一种编程语言)

> 原文：<https://betterprogramming.pub/why-i-created-zen-yet-another-programming-language-88d2ec878494>

## Zen 是一种通用编程语言，旨在构建简单、可靠、高效的程序

![](img/30ae368beb1b0fd375ac3b459be515a2.png)

斯科特·韦伯在 [Unsplash](https://unsplash.com/s/photos/zen-garden?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

当我说简单、可靠和高效时，我是认真的。Zen 的语法设计得很清晰，这意味着你写的代码不言自明。此外，运行时的体系结构被设计为无论在什么平台上都能高效可靠地运行您的程序。您可以在几乎任何环境中开发 Zen 应用程序，并且不管平台如何，部署时几乎没有性能损失。

> 在撰写本文时，Zen 正在开发中。编译器和虚拟机的 alpha 版本将很快推出。同时，你可以[浏览源代码](https://github.com/itssamuelrowe/zen)。

我决定创建自己的编程语言，因为我从九年级起就对编译器设计感兴趣。此外，我没有找到任何满足我所有需求的现有语言。在本文中，我将解释一些概念，我认为这些概念对于一种既有趣又高效的动态类型编程语言是必要的。我的目标不是构建一种玩具语言，而是创建一种成熟的编程语言。为什么？因为我认为创造一种每个人都喜欢的编程语言真的很酷。

# 简单的

Zen 的语法是有意设计来限制完成某项任务的方法数量的。例如，与其他动态类型编程语言不同，方法和属性不能在运行时引入对象。作为一名 Zen 程序员，你将更多地关注程序的逻辑，而不是处理对象的复杂状态。

编写代码所需的令牌最少。考虑到这一点，去掉了标记，例如分号来结束简单语句，大括号来括住块，等等——这在类似 C 的编程语言中很常见。

Zen 提供了良好的可读性和清晰的语法，强调自然语言。乍一看，用 Zen 写的代码几乎看起来像伪代码。您可以编写代码并快速执行来测试您的想法。

对于新手和初学者来说，Zen 非常容易学习和使用。鉴于学习曲线很简单，你不必成为专家就能在日常生活中应用禅。Zen 会自动为您处理垃圾收集和释放资源之类的事情。

还不相信禅是简单的吗？在这种情况下，这里有一个用 Zen 写的二分搜索法算法的例子:

```
**function** search(values, key)
    **var** start = 0
    **var** end = values.size - 1
    **var** result = null
    **while** start <= end
        **var** middle = (end - start) / 2
        **if** values[middle] == key
             result = middle
             **break**
        **else** **if** values[middle] > key
            end = middle - 1
        **else**
            end = middle + 1
    **return** result**function** main(...arguments)
    **var** values = array(53, 118, 519, 1216)
    **var** result = search(values, 27)
    **if** result != null
        print('Found key 27 at index ' + result + '.')
    **else**
        print('Could not find key 27.')
```

# 动态类型化

Zen 是动态类型的，这有助于避免编写支持代码。然而，它被设计成在编译时检测许多编程错误，而其他动态类型语言在运行时报告这些错误。这为编译器提供了优化的机会。因此，您可以享受运行时效率的提高和开发人员的体验。

事实上，我创立 Zen 的前提是创造一种受 Python 和 Java 启发的编程语言。采用 Python 简单明了的语法来改善开发人员的体验。类似地，运行时架构受到 Java 的启发，以提高运行时效率。

假设是通过对语言的某些限制，生产力和效率都可以达到。语言施加的限制允许编译器利用源代码中可用的静态信息。例如，在 Zen 中，属性和方法不能动态地引入到对象中。此外，如果静态方法不能通过对象(如 C#)调用，编译器可以发出一条指令来调用静态函数。类似地，当方法调用同一个类中的其他方法时，编译器可以简单地发出一条指令，通过虚拟方法表调用目标方法。同样的技术可以应用于属性。你明白我想说什么吗？

# 便携:一次编写，随处运行

你用 Zen 编写的程序被编译成字节码，字节码以一种特殊的二进制格式编码，这种格式被称为**二进制实体格式(FEB)** 。当你运行你的程序时，虚拟机解释这些字节码。对于每个平台，都需要虚拟机的特定实现。然而，一旦实现完成，您的程序就可以无缝地在虚拟机上运行。

# 缺乏含蓄的习语

**未定义的值、真/假值和许多其他隐含的习惯用法在 Zen 中是不可用的。这个想法是为了限制你表达某事的方式。例如，布尔值总是从关系表达式和等式表达式中导出。没有对象到布尔值的隐式转换。这种受 Java 和 C#启发的设计选择允许您编写可读且安全的代码。**

我个人认为，相比其他类型的错误，更多的 bug 源于隐式习惯用法。此外，这样的错误很难追踪。例如，当编程语言将不同的对象视为相同时，当程序员试图使用它们时，会导致意外的行为。

这里有一个 JavaScript 的例子。虽然 JavaScript 在 ES6 发布之前不允许默认参数，但模拟默认参数是一种常见的模式，如下所示:

```
**function** example(value) {
    value = value || 1;
}
```

在本例中，当没有传递参数时，函数将`value`更新为`1`。然而，如果您试图将`0`作为参数传递，JavaScript 中的 truthy 测试将会失败，导致您的变量保存的是`1`而不是`0`。显然，有一种更好的写法，但是如果语言没有真/假值，我们就不会有这个问题。

# 并发

在 Python 和 Ruby 的参考实现 CPython 和 MRuby 中，分别存在一个全局解释器锁(GIL)。GIL 保护解释器内部免受可能破坏数据的竞争条件的影响。在多线程上下文中，这种锁在任何给定时间只允许一个线程执行代码。例如，如果您有四个线程在四核计算机上工作，那么在任何给定时间，只有一个线程和一个内核是活动的。

在 Zen 中，**虚拟机将线程实现为一等公民**。各种内部组件(包括垃圾收集器、JIT 编译器、类加载器)都是线程安全的。因此，全局解释器锁不存在。这意味着你的程序可以充分利用多核系统。

# 快速编译时间

Zen 在语法和语义方面的简单设计允许您快速编译源代码。即使编译器多次通过，这一点仍然成立。

此外，Zen 中的依赖管理非常优雅。编译器只处理直接导入的类。你用 Zen 编写的程序被编译成一种紧凑的二进制格式，称为**二进制实体格式(FEB)** 。当编译后的类从源代码导入时，编译器会使用一个简单的符号加载器，它会丢弃不必要的信息，只加载所需的符号。

# 结论

我知道这篇文章相当长。然而，它对 Zen 编程语言的一些最重要的特性进行了概述。这里讨论的许多特性现在在 Zen 中都不可用。然而，本文描述了 Zen 的整体愿景。

我相信创造禅值得一试。在最坏的情况下，我会享受三年学习编写编译器和虚拟机的时光。也许我会创造出一种别人欣赏的编程语言。最后，我最深的希望是，读完这篇文章后，你会有动力去探索禅宗，并发现它如何帮助你自己的项目。

需要说明的是，我不是编译器设计专家。我知道我在这篇文章中提出的论点很容易被击败。事实上，我提到的一些事情可能是错的。请在评论区畅所欲言。

感谢阅读。

如果你想联系我们或者愿意投稿，这是我的电子邮件地址:samuelrowe1999@gmail.com。