<html>
<head>
<title>Terraform, AWS, and Idempotency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地形、AWS和幂等性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/terraform-aws-and-idempotency-78220aaa5372?source=collection_archive---------16-----------------------#2022-06-27">https://betterprogramming.pub/terraform-aws-and-idempotency-78220aaa5372?source=collection_archive---------16-----------------------#2022-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="296d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Terraform里的bug？或者是对某一节的工作原理的误解？或者甚至是我们自己围绕Terraform的自动化？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/48bd5a269961565439d5562cff6bd2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7v8OxI51mSqfNuSU"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">詹姆斯·哈里森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这只是这个系列的第一部分，因为到目前为止还没有一个令人满意的结局，但仍然是一个值得分享的故事。我们在Terraform中遇到了一个短暂的错误，但似乎会自行消失，很可能是一些比赛条件。这篇文章将会讲述这个失败。这比我的一些其他帖子更具技术性，所以那些寻求领导思想的人可能会看呆了。您的里程可能会有所不同。</p><p id="27a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先简单介绍一下我们的部署流程。我们在我们的环境中使用<a class="ae kv" href="https://martinfowler.com/bliki/BlueGreenDeployment.html" rel="noopener ugc nofollow" target="_blank">蓝/绿部署策略</a>(不包括数据库)。围绕Terraform的自动化负责启动第二个应用程序堆栈并向其部署代码。在创建第二个堆栈的过程中，我们收到了一条从未遇到过的错误消息。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b41d" class="lx ly iq lt b gy lz ma l mb mc">Error: error creating EC2 Launch Template: IdempotentParameterMismatch: Client token already used before. <br/>  status code: 400, request id: 4c6edce7-7497-4884-ab63-f215f9b82f6e<br/>  on ../terraform-asg/main.tf line 33, in resource "aws_launch_template" "launch_template":<br/>  33: resource "aws_launch_template" "launch_template" {</span></pre><p id="9e6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一些事情需要研究。</p><h1 id="3dcc" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">幂等参数不匹配错误</h1><p id="e148" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">当一个动作是幂等的，这意味着它可以被多次执行，而不会改变最初应用之外的结果。我</p><p id="f292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，这通常意味着，如果我运行命令X，该命令知道它以前是否在这个上下文中运行过，并且可能跳过该命令的通常应用，而是返回一个状态或结果。一个简单的例子是使用-p标志时的<code class="fe mz na nb lt b">mkdir</code>命令(如果完整路径不存在，它告诉<code class="fe mz na nb lt b">mkdir</code>创建完整路径)。</p><p id="a4b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我在本地工作站上运行，会发生以下情况。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="3878" class="lx ly iq lt b gy lz ma l mb mc">mkdir -p /tmp/test<br/>ls -l /tmp/|grep test<br/>drwxr-xr-x  2 jeff.smith  wheel    64 Jun  9 06:31 test<br/>mkdir -p /tmp/test</span></pre><p id="884e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb lt b">mkdir</code>命令创建了路径<code class="fe mz na nb lt b">/tmp/test</code>，我们可以看到它被成功创建。当我再次运行该命令时，它成功完成，没有错误消息。</p><p id="bdf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得这个命令是幂等的。不管我运行这个命令多少次，我知道最终我会得到一个成功的结果，并且路径<code class="fe mz na nb lt b">/tmp/test</code>会存在。现在对比一下<code class="fe mz na nb lt b">mkdir</code>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d1c7" class="lx ly iq lt b gy lz ma l mb mc">mkdir /tmp/test2<br/>ls -l /tmp/|grep test2<br/>drwxr-xr-x  2 jeff.smith  wheel    64 Jun  9 06:35 test2<br/>mkdir /tmp/test2<br/>mkdir: /tmp/test2: File exists</span></pre><p id="2dfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在使用mkdir，在第二次执行时，我得到一个错误消息，这是一个不同于第一次执行的最终结果。目录存在，但是我得到的错误代码是不同的。这使得这成为一个非幂等运算。但是我们为什么要在乎呢？在第二个例子中，首先我需要做更多的错误处理。这是一个基本的例子。</p><p id="e184" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当做类似创建基础设施的事情时，可能会导致启动比预期更多的实例，这就是这个<code class="fe mz na nb lt b">IdempotentParameterMismatch</code>错误旨在防止的。</p><p id="87b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您调用AWS API来创建基础设施时，几乎每个端点(据我所知)都是以异步的方式进行的。这意味着您的API调用立即返回，但是实际创建您所请求的基础设施的工作仍在进行中。因此，您通常需要某种轮询机制来确定操作何时完成。</p><p id="6526" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几个AWS API端点<a class="ae kv" href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html" rel="noopener ugc nofollow" target="_blank">支持等幂</a>，这允许您指定一个客户机令牌来惟一地标识这个请求。如果您进行相同的API基础结构创建调用并使用相同的客户端令牌，而不是创建新的实例，它将返回先前请求的实例的状态。当以编程方式创建基础设施时，这可以是一个大的安全网，以避免创建相同基础设施的许多副本。这就是我们的错误所在。</p><p id="32ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该错误表明我们已经使用了客户端令牌。深入研究一下文档，更具体的意思是我们更改了请求中的参数，但是重用了客户端令牌，这意味着API不知道我们的实际意图是什么。我们需要具备这些参数的新基础设施吗？或者，我们是否期望现有的基础设施符合这些参数？为了安全起见，它抛出这个错误。</p><p id="b094" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户始终负责生成客户端令牌。但在这种情况下，用户实际上是Terraform。这让我们有些惊讶和宽慰，因为这意味着它很可能不是我们的任何包装自动化。但是我们仍然需要确定。我们做的第一件事是试图找出使用了什么客户端令牌，以及它是否实际上使用了两次。</p><p id="fb0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，这个错误给了我们一个<code class="fe mz na nb lt b">RequestId</code>,我们使用CloudTrail来查找它。在该请求的<code class="fe mz na nb lt b">requestParameters</code>字段中，我们能够找到所使用的ClientToken。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="6fa2" class="lx ly iq lt b gy lz ma l mb mc">"requestParameters": {<br/>      "CreateLaunchTemplateRequest": {<br/>        "LaunchTemplateName": "sidekiq-worker-green_staging02-launch_template20220510183630312700000005",<br/>        "LaunchTemplateData": {<br/>          "UserData": "&lt;sensitiveDataRemoved&gt;",<br/>          "SecurityGroupId": [<br/>            {<br/>              "tag": 1,<br/>              "content": "sg-0743bcbd08cadba1d"<br/>            },<br/>            {<br/>              "tag": 2,<br/>              "content": "sg-6daf421e"<br/>            },<br/>            {<br/>              "tag": 3,<br/>              "content": "sg-0818108e24803a418"<br/>            }<br/>          ],<br/>          "ImageId": "&lt;removed&gt;",<br/>          "BlockDeviceMapping": {<br/>            "Ebs": {<br/>              "VolumeSize": 100<br/>            },<br/>            "tag": 1,<br/>            "DeviceName": "/dev/sda1"<br/>          },<br/>          "IamInstanceProfile": {<br/>            "Name": "asg-staging02-20220510183628901400000003"<br/>          },<br/>          "InstanceType": "m4.2xlarge"<br/>        },<br/>        "ClientToken": "terraform-20220510183630312700000006"<br/>      }</span></pre><p id="44b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它看起来足够随机，与Terraform经常用来生成随机值的格式相同。</p><p id="4441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它显然不是我们制造的。然后，我们决定搜索这段时间内的所有请求，看看是否有任何请求具有相同的客户机令牌。</p><p id="5f9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">果然，第二个请求重用了相同的Terraform模块(我们编写的)来生成第二个ASG和启动模板。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="878f" class="lx ly iq lt b gy lz ma l mb mc">"requestParameters": {<br/>      "CreateLaunchTemplateRequest": {<br/>        "LaunchTemplateName": "biexport-worker-green_staging02-launch_template20220510183630312700000005",<br/>        "LaunchTemplateData": {<br/>          "UserData": "&lt;sensitiveDataRemoved&gt;",<br/>          "SecurityGroupId": [<br/>            {<br/>              "tag": 1,<br/>              "content": "sg-0743bcbd08cadba1d"<br/>            },<br/>            {<br/>              "tag": 2,<br/>              "content": "sg-6daf421e"<br/>            },<br/>            {<br/>              "tag": 3,<br/>              "content": "sg-0818108e24803a418"<br/>            }<br/>          ],<br/>          "ImageId": "&lt;removed&gt;",<br/>          "BlockDeviceMapping": {<br/>            "Ebs": {<br/>              "VolumeSize": 200<br/>            },<br/>            "tag": 1,<br/>            "DeviceName": "/dev/sda1"<br/>          },<br/>          "IamInstanceProfile": {<br/>            "Name": "asg-staging02-20220510183629183700000003"<br/>          },<br/>          "InstanceType": "m5.xlarge"<br/>        },<br/>        "ClientToken": "terraform-20220510183630312700000006"<br/>      }</span></pre><p id="c741" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，请求中存在差异，但是客户端令牌保持不变。现在我们开始抓狂，认为这可能是我们的代码，但我们仍然看不出是怎么回事。</p><h1 id="5ee4" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">生成客户端令牌</h1><p id="70e7" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">正如我前面提到的，从AWS的角度来看，生成客户机令牌是用户的工作。从我们的角度来看，那个用户是Terraform。我们的团队无论如何都不是围棋专家(尽管我们正在寻找一些好的项目来尝试一下)。我们有很多兴趣)。</p><p id="48d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为了理解客户机令牌是如何生成的，我们必须看一下Terraform源代码。经过一点挖掘，我们发现代码作为一个助手函数存在于<a class="ae kv" href="https://github.com/hashicorp/terraform-plugin-sdk/blob/main/helper/resource/id.go" rel="noopener ugc nofollow" target="_blank"> terraform-plugin-sdk </a>中。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d00d" class="lx ly iq lt b gy lz ma l mb mc">func PrefixedUniqueId(prefix string) string {<br/>    // Be precise to 4 digits of fractional seconds, but remove the dot before the<br/>    // fractional seconds.<br/>    timestamp := strings.Replace(<br/>        time.Now().UTC().Format("20060102150405.0000"), ".", "", 1)</span><span id="f0cb" class="lx ly iq lt b gy nc ma l mb mc">    idMutex.Lock()<br/>    defer idMutex.Unlock()<br/>    idCounter++<br/>    return fmt.Sprintf("%s%s%08x", prefix, timestamp, idCounter)<br/>}</span></pre><p id="52e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个函数中，作者生成精确到秒的时间戳。多个执行可能会在同一个第二时间跨度内命中，但是该值还会附加一个计数器。</p><p id="a68f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计数器在一个<a class="ae kv" href="https://gobyexample.com/mutexes" rel="noopener ugc nofollow" target="_blank">互斥体</a>中，所以<code class="fe mz na nb lt b">idCounter</code>的值在执行中共享，互斥体防止并发执行。这个函数不可能两次生成同一个客户端令牌。但这并不意味着调用客户机令牌的函数没有存储它，也没有可能重用它。</p><h1 id="3f81" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">包裹</h1><p id="a44f" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">我们的故事暂时到此结束。我们开始调查客户端令牌是如何以及在哪里被使用的，但是由于我们强烈地感觉到这将与某种类型的地形问题有关，我们必须改变解决方案。我们不打算运行定制补丁版本的Terraform。我们不会当场升级。我们不会等到公关获得批准、合并和发布，这样我们就走上了一条不同的补救之路。</p><p id="e081" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们当前的解决方案是为冲突的两个资源指定一个<code class="fe mz na nb lt b"><a class="ae kv" href="https://www.terraform.io/language/meta-arguments/depends_on" rel="noopener ugc nofollow" target="_blank">depends_on</a></code>参数。其他时候，当错误发生时，我们注意到总是这两个资源发生冲突，所以希望<code class="fe mz na nb lt b">depends_on</code>标志可以防止它们被并行创建。</p><p id="7d58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，这种希望得到了回报，我们没有在任何环境中再次看到错误。但是出于病态的好奇，我们计划继续研究这个问题。它可能会让我们发现Terraform中的一个bug，对某个特定节的工作方式产生误解，或者甚至是我们自己围绕Terraform的自动化。</p><p id="ca0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谁知道呢？如果我们找到了它，您一定会找到本文的第2部分！</p></div></div>    
</body>
</html>