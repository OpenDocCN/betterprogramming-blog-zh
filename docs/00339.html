<html>
<head>
<title>Terms You Need to Know as a JS Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为JS开发人员，您需要知道的术语</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/terms-you-need-to-know-as-js-developer-28c2adfd2bb5?source=collection_archive---------1-----------------------#2019-04-24">https://betterprogramming.pub/terms-you-need-to-know-as-js-developer-28c2adfd2bb5?source=collection_archive---------1-----------------------#2019-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ade5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">作为开发人员开始使用JavaScript术语</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/27cd58112138e792e430b689e45e2f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxEkHw1xewxOFjmGunb-Cw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.tutorialrepublic.com/" rel="noopener ugc nofollow" target="_blank"> Tutorialrepublic </a></p></figure><p id="58d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将特别关注作为一名JS开发人员，您需要了解的JavaScript知识。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="189f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">值和类型</h1><p id="7557" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript是动态类型的。这意味着变量可以保存任何类型的值，而无需任何类型强制。以下是可用的内置类型:</p><ol class=""><li id="4da8" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">string</code></li><li id="a727" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">number</code></li><li id="663d" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">boolean</code></li><li id="05d9" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">null</code>和<code class="fe ni nj nk nl b">undefined</code></li><li id="b16d" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">object</code></li><li id="ccc3" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">symbol</code>(ES6的新功能)</li></ol><p id="120c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript有<em class="nr">类型值</em>，没有类型变量——JavaScript中的变量可以包含任何数据。一个变量可以是一个字符串，也可以是一个数字。</p><pre class="kj kk kl km gt ns nl nt nu aw nv bi"><span id="61cc" class="nw md it nl b gy nx ny l nz oa">var a;<br/>typeof a;           // "undefined"</span><span id="76de" class="nw md it nl b gy ob ny l nz oa">a=5;<br/>typeof a;           // "number"</span><span id="ff26" class="nw md it nl b gy ob ny l nz oa">a="js"<br/>typeof a;           // "string"</span></pre><p id="1668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">typeof null</code>是一个有趣的例子，因为当您期望它返回<code class="fe ni nj nk nl b">null</code>时，它却错误地返回了<code class="fe ni nj nk nl b">object</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9c80" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目标</h1><p id="af35" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对象用于存储各种数据和更复杂实体的键控集合，您可以在其中设置保存其自身值的属性。<br/>可以使用点符号(即obj.a)或括号符号(即obj["a"])访问属性。点符号更短，通常更容易阅读。因此，如果可能的话，这是优选的。</p><pre class="kj kk kl km gt ns nl nt nu aw nv bi"><span id="9061" class="nw md it nl b gy nx ny l nz oa">var obj = {<br/> a: "js",<br/> b: 2<br/>}</span><span id="40c5" class="nw md it nl b gy ob ny l nz oa">obj.a;             // "js"<br/>obj["b"];          // 2</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="275e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">排列</h1><p id="9f4c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数组是保存值(任何类型)的对象。不是特别在命名属性/键中，而是在数字索引位置中。例如:</p><pre class="kj kk kl km gt ns nl nt nu aw nv bi"><span id="315d" class="nw md it nl b gy nx ny l nz oa">var arr = ["js", 2, true];</span><span id="ef57" class="nw md it nl b gy ob ny l nz oa">arr[0];            // "js" <br/>arr[1];            //  2<br/>arr[2];            //  true</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eb9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">内置类型方法</h1><p id="4505" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript提供不同的数据类型来保存不同类型的值。JavaScript中有两种数据类型:</p><ol class=""><li id="050d" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">原始值</li><li id="09a0" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">非原始值(对象引用)</li></ol><p id="7a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以拥有非原始值的属性和方法。但是我们如何使用长度作为属性，使用<code class="fe ni nj nk nl b">toUpperCase()</code>作为原始值的方法呢？</p><pre class="kj kk kl km gt ns nl nt nu aw nv bi"><span id="60e4" class="nw md it nl b gy nx ny l nz oa">const a = "hello world";</span><span id="9e77" class="nw md it nl b gy ob ny l nz oa">a.length;                   // 11<br/>a.toUpperCase();            // "HELLO WORLD"<br/>typeof a;                   // "string"</span></pre><p id="e280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用像<code class="fe ni nj nk nl b">a</code>这样的原始值作为对象时，通过引用属性或方法(例如，前面代码片段中的<code class="fe ni nj nk nl b">a.toUpperCase()</code>), JS会自动将值“装箱”到它的对象包装器对应物(隐藏在幕后)。</p><p id="c4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串值可以由string对象包装，数字可以由number对象包装，布尔值可以由boolean对象包装。</p><p id="6700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">装箱</strong>是将一个对象包装在一个原始值周围。例如，<br/> <code class="fe ni nj nk nl b">new Number(42)</code>为图元数42创建一个数字对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3bb1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">真实与虚假</h1><p id="5fd2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript中falsy值的具体列表如下:</p><p id="29b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">“ ”</code>(空字符串)<br/><code class="fe ni nj nk nl b">0</code><code class="fe ni nj nk nl b">-0</code><code class="fe ni nj nk nl b">NaN</code>(无效数字)<br/><code class="fe ni nj nk nl b">null</code><code class="fe ni nj nk nl b">undefined</code><br/><code class="fe ni nj nk nl b">false</code></p><p id="2d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何不在这个虚假列表上的值都是真实的。比如:<code class="fe ni nj nk nl b">[ ]</code>、<code class="fe ni nj nk nl b">[1,2,3]</code>、<br/>、<code class="fe ni nj nk nl b">{}</code>、<code class="fe ni nj nk nl b">hello</code>、<code class="fe ni nj nk nl b">2</code>、<code class="fe ni nj nk nl b">{a: 7}</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="99dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">平等</h1><p id="d02f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有四个等式运算符:<code class="fe ni nj nk nl b">==</code>、<code class="fe ni nj nk nl b">===</code>(等式)，以及<code class="fe ni nj nk nl b">!=</code>、<code class="fe ni nj nk nl b">!==</code>(不等式)。</p><p id="f339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">==</code>和<code class="fe ni nj nk nl b">===</code>的区别通常表现为:<code class="fe ni nj nk nl b">==</code>检查值相等，<code class="fe ni nj nk nl b">===</code>检查值和类型相等。然而，这是不准确的。描述它们的正确方式是，<code class="fe ni nj nk nl b">==</code>在允许强制的情况下检查值相等，而<code class="fe ni nj nk nl b">===</code>在不允许强制的情况下检查值相等。</p><p id="61ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">===</code>通常被称为<em class="nr">严格相等，</em>和<code class="fe ni nj nk nl b">==</code>则是<em class="nr">宽松相等</em>正因如此。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3f7a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">强迫</h1><p id="c2c0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">强制<strong class="lb iu"> </strong>是将值从一种类型转换为另一种类型的过程(比如字符串转换为数字，对象转换为布尔值等等)。它有两种形式——显性和隐性。</p><p id="d2e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显性胁迫的例子:</p><pre class="kj kk kl km gt ns nl nt nu aw nv bi"><span id="f1a7" class="nw md it nl b gy nx ny l nz oa">var a = “42”; <br/>var b = Number( a );</span><span id="3da5" class="nw md it nl b gy ob ny l nz oa">a;          // “42” <br/>b;         // 42 — the number!</span></pre><p id="2f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">隐式强制的示例:</p><pre class="kj kk kl km gt ns nl nt nu aw nv bi"><span id="2e0b" class="nw md it nl b gy nx ny l nz oa">var a = “42”; <br/>var b = a * 1;     // “42” implicitly coerced to 42 here</span><span id="dbb7" class="nw md it nl b gy ob ny l nz oa">a;  // “42” <br/>b; // 42 — the number!</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8b87" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不平等</h1><p id="8d42" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe ni nj nk nl b">&lt;</code>、<code class="fe ni nj nk nl b">&gt;</code>、<code class="fe ni nj nk nl b">&lt;=</code>和<code class="fe ni nj nk nl b">&gt;=</code>运算符用于不等式，在规范中称为<em class="nr">关系比较</em>。</p><p id="9cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们将与可比较的值一起使用，如数字。但是JavaScript字符串值也可以进行不相等的比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面不等式表达式的答案是什么？真的还是假的？</p><p id="2ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在找到解决方法之前，我们先来看看两个字符串，或者数字和字符串是如何比较的。</p><p id="98b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe ni nj nk nl b">&lt;</code>比较中的两个值都是字符串，就像<code class="fe ni nj nk nl b">b &gt; d</code>一样，那么比较是按字典顺序进行的(也就是像字典一样按字母顺序)。</p><p id="b29f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与相等运算符类似，强制也适用于不等运算符。如果其中一个或两个都不是字符串，就像<code class="fe ni nj nk nl b">a &lt; b</code>一样，那么两个值都被强制为数字，并且出现典型的数字比较。</p><pre class="kj kk kl km gt ns nl nt nu aw nv bi"><span id="220b" class="nw md it nl b gy nx ny l nz oa">a &lt; c       // true       convert "53" to 53,  42 &lt; 53<br/>a &lt; b;      // false	  convert "foo to NaN, 42 &lt; Nan<br/>a &gt; b;      // false      convert "foo to NaN, 42 &gt;Nan<br/>a == b;     // false      interpreted as 42 == NaN or "42" == "foo"<br/>b &gt; d;      // true       f come after b in alphabetic order</span></pre><p id="6841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当把<code class="fe ni nj nk nl b">foo</code>转换成一个数字时，我们得到<code class="fe ni nj nk nl b">invalid number value</code>(<code class="fe ni nj nk nl b">NaN</code>),<code class="fe ni nj nk nl b">NaN</code>既不大于也不小于任何其他值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b38" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">功能范围</h1><p id="f635" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<code class="fe ni nj nk nl b">var</code>关键字声明一个属于当前函数作用域的变量，或者声明一个全局作用域，如果它在任何函数之外的顶层。</p><p id="2bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有两个变量声明的关键字；<code class="fe ni nj nk nl b">let</code>和<code class="fe ni nj nk nl b">const</code>。它们是块范围。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="491f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">吊装</strong></h1><p id="a78c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当JavaScript编译所有代码时，所有使用<code class="fe ni nj nk nl b">var</code>的变量声明都被提升到它们的函数/局部作用域的顶部(如果在函数内声明)，或者提升到它们的全局作用域的顶部(如果在函数外声明)——不管实际声明是在哪里进行的。这就是我们所说的<em class="nr">吊装</em>的意思。</p><p id="db44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数声明也会被提升，但是它们会在最上面，所以会位于所有变量声明之上。</p><pre class="kj kk kl km gt ns nl nt nu aw nv bi"><span id="fae2" class="nw md it nl b gy nx ny l nz oa">console.log(myName);    <br/>var myName = ‘Sunil’;</span><span id="3d71" class="nw md it nl b gy ob ny l nz oa"><em class="nr">What will be the answer - <br/>1. Uncaught ReferenceError: myName is not defined<br/></em><em class="nr">2. Sunil<br/></em><em class="nr">3. </em>undefined</span></pre><p id="d289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，答案将是，“<code class="fe ni nj nk nl b">undefined</code>”。</p><p id="58ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？正如我们前面提到的，当JavaScript在运行时编译时，变量被移动到它们作用域的顶部。因此，当JavaScript被编译时，<code class="fe ni nj nk nl b">var myName</code>将被移到其作用域的顶部。</p><p id="f999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一移到顶部的是变量声明，而不是赋予变量的实际值。</p><p id="dd7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们得到了undefined，而不是一个<code class="fe ni nj nk nl b">ReferenceError</code>，因为变量是在作用域的顶部声明的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="608d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关闭</h1><p id="3157" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">闭包是JavaScript中最重要的概念之一，也是最不容易理解的概念。闭包是一个函数，定义在另一个函数(称为父函数)中，并且可以访问在父函数作用域中声明和定义的变量。</p><p id="b134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">闭包可以在三个范围内访问变量:</p><ul class=""><li id="05a8" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu oe nf ng nh bi translated">变量在自己的作用域中声明</li><li id="6dec" class="mz na it lb b lc nm lf nn li no lm np lq nq lu oe nf ng nh bi translated">父函数作用域中声明的变量</li><li id="0bec" class="mz na it lb b lc nm lf nn li no lm np lq nq lu oe nf ng nh bi translated">在全局命名空间中声明的变量</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="45ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用<code class="fe ni nj nk nl b">makeAdder(10)</code>时，我们得到一个对其内部<code class="fe ni nj nk nl b">add(..)</code>的引用，该引用将x记为10。我们称这个函数引用为<code class="fe ni nj nk nl b">plusTen(..)</code> —它把它的内部y( 3)加到被x( 10)记住的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0521" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">该标识符</h1><p id="3b07" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript中另一个经常被误解的概念是<em class="nr"> this </em>关键字。</p><p id="522f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个函数内部有一个<code class="fe ni nj nk nl b">this</code>引用，那么<code class="fe ni nj nk nl b">this</code>引用通常指向一个对象。但是它指向哪个对象取决于函数是如何被调用的。</p><p id="1baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要认识到<code class="fe ni nj nk nl b">this</code>不是指函数本身，这是最常见的误解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b6af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这意味着什么，你必须检查一下这个函数是如何被调用的。这将是上面显示的四种方式之一，然后将回答这是什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0fa7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">原型</h1><p id="1d4a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您引用一个对象的属性时，如果该属性不存在，JavaScript将自动使用该对象的内部原型引用来查找另一个对象以寻找该属性。如果属性丢失，您可以将此视为一种备用方法。</p><p id="a089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从一个对象到其后备的内部原型引用链接发生在创建对象的时候。说明这一点的最简单方法是使用一个名为<code class="fe ni nj nk nl b">Object.create(..)</code>的内置实用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们讨论的所有术语对于成为一名优秀的JS开发人员都是必要的，您需要熟悉这些术语。</p><p id="d5a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以开始阅读官方的JS文档来学习dept中的所有这些概念。</p><p id="5710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章对你有用。感谢阅读，继续学习！</p></div></div>    
</body>
</html>