<html>
<head>
<title>Building Mock APIs in Golang with Mocha</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Mocha在Golang中构建模拟API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-mock-apis-in-golang-with-mocha-ec13fd160385?source=collection_archive---------6-----------------------#2022-08-09">https://betterprogramming.pub/building-mock-apis-in-golang-with-mocha-ec13fd160385?source=collection_archive---------6-----------------------#2022-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ab9b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个用于存根和模仿API的新库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9525e86cebf3c521f6f004fb6b4388c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OxnpmR7y2_LhQx4g"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">替代代码</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8368" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发者们好！最近，我发布了<a class="ae kv" href="https://github.com/vitorsalgado/mocha" rel="noopener ugc nofollow" target="_blank"> Mocha </a>，这是一个用Go编写的库，用来构建模拟API，灵感来自Java世界的<a class="ae kv" href="https://github.com/wiremock/wiremock" rel="noopener ugc nofollow" target="_blank"> WireMock </a>。本文将对这个新项目进行简要概述。</p><p id="8042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理依赖于外部资源(如API)的代码是很常见的，在这些情况下编写有价值的测试可能具有挑战性。有一些方法可以做到这一点，比如我们可以模仿我们的API客户端，使用定制的<code class="fe ls lt lu lv b">http.Transport</code>，使用真实的服务器，比如具有定制行为的<code class="fe ls lt lu lv b">httptest.Server</code> <em class="lw">、</em>。</p><p id="186a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢使用实际的HTTP服务器的想法，比如来自Go标准库的<code class="fe ls lt lu lv b">httptest.Server</code>,因为我们可以在受控的测试环境中模拟真实的集成。使用真实服务器的另一个优点是我们不会被任何特定的客户端实现所束缚。但是对于中型/大型项目，使用基本的服务器实现来设置适当的请求断言和响应存根可能是一个问题。这就是摩卡能帮上忙的地方。<em class="lw"> Mocha </em>利用了<code class="fe ls lt lu lv b">httptest.Server</code>，并使得为特定的请求匹配创建响应存根变得更加容易。</p><h1 id="9e7d" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">该项目</h1><p id="6b24" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Mocha 是一个在Golang中构建模拟API的开源工具，其灵感来自Java的<a class="ae kv" href="https://github.com/wiremock/wiremock" rel="noopener ugc nofollow" target="_blank"> WireMock </a>。Mocha的工作原理是运行一个实际的HTTP服务器，并公开一个fluent API，您可以轻松地为特定请求配置响应存根。</p><h2 id="d11e" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">装置</h2><pre class="kg kh ki kj gt ng lv nh ni aw nj bi"><span id="e1ca" class="mu ly iq lv b gy nk nl l nm nn">go get github.com/vitorsalgado/mocha/v3</span></pre><p id="9154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要<strong class="ky ir"> Go 1.18+ </strong>。</p><h2 id="21b3" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">使用</h2><p id="326c" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">尽管Mocha可以在不同的场景中使用，但它的主要目的是用于Go测试。在典型的使用中，您可能需要导入这三个包:</p><ul class=""><li id="25d3" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated"><code class="fe ls lt lu lv b">github.com/vitorsalgado/mocha/v3</code>为核心部件</li><li id="75d2" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe ls lt lu lv b">github.com/vitorsalgado/mocha/v3/expect</code>实现匹配功能</li><li id="7e77" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe ls lt lu lv b">github.com/vitorsalgado/mocha/v3/reply</code>实现响应存根构建功能</li></ul><p id="11a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法通常如下例所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="596f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，使用<em class="lw"> Mocha创建了一个真实的模拟服务器，并且每次这个API接收到一个HTTP请求时都使用下面的配置:</em></p><pre class="kg kh ki kj gt ng lv nh ni aw nj bi"><span id="9194" class="mu ly iq lv b gy nk nl l nm nn"><em class="lw">GET /customers/super-id<br/>accept: application/json<br/>content-type: application/json</em></span></pre><p id="f408" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将回复:</p><pre class="kg kh ki kj gt ng lv nh ni aw nj bi"><span id="a29f" class="mu ly iq lv b gy nk nl l nm nn"><em class="lw">200 OK <br/>{id:”super-id”, name:”nice-name”}</em></span></pre><p id="c1c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在测试的处理程序使用一个需要基本URL的API客户机。我们需要将这个基本URL改为指向我们的模拟API。还可以断言模拟服务器是否收到了任何调用或特定数量的调用。</p><h2 id="92bd" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">配置</h2><p id="5878" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Mochas的函数接受第二个“可选”参数来定制实例。</p><pre class="kg kh ki kj gt ng lv nh ni aw nj bi"><span id="4a8b" class="mu ly iq lv b gy nk nl l nm nn">m := mocha.New(t, Configure().Addr("127.0.0.1:3000").Build())</span></pre><h2 id="bfef" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">延迟响应</h2><p id="d03a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Mocha可以通过添加延迟来模拟缓慢的响应。您可以指定Mocha在提供HTTP响应之前应该等待的时间。请参见下面的示例:</p><pre class="kg kh ki kj gt ng lv nh ni aw nj bi"><span id="a6f5" class="mu ly iq lv b gy nk nl l nm nn">m.AddMocks(mocha.Get(expect.URLPath("/test")).<br/>  Reply(reply.<br/>    Accepted().<br/>    Delay(5 * time.Second)))</span></pre><h2 id="1e20" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">回复</h2><p id="8d9f" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Mocha提供了不同的方法来构建响应，包括使用定制函数来构建响应序列、随机响应和模板。<br/>下面你可以看到一些回复的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="708a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有其他功能可用；有关更多详细信息，请查看项目文档和源代码:</p><div class="ol om gp gr on oo"><a href="https://github.com/vitorsalgado/mocha" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">GitHub-vitorsalgado/mocha:Golang的HTTP模仿和期望工具</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">围棋HTTP服务器模拟工具。Mocha创建一个HTTP服务器，并让您配置…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div></div></div>    
</body>
</html>