<html>
<head>
<title>Object Order in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的对象顺序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/objects-order-in-javascript-faed6b35de0e?source=collection_archive---------5-----------------------#2019-07-02">https://betterprogramming.pub/objects-order-in-javascript-faed6b35de0e?source=collection_archive---------5-----------------------#2019-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="82e7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简短的教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b787935b520259a9bf23cfb3e2eddb77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Q2RwLldV2Zqd1ldvlRZIg.png"/></div></div></figure><p id="1928" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一周前，我在JavaScript中做了一个依赖于对象顺序的算法。如果你来自一种没有预期对象顺序的语言，你可能会说“什么？!"就现在。</p><p id="1629" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您熟悉JavaScript及其特性，我仍然希望得到相同的回应，因为它有些细微差别，似乎并不广为人知。让我们来看看我使用的对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="fde6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太好了，我们按照定义的顺序收到了我们的对象。然后我们可以使用<code class="fe lp lq lr ls b">for (let coin in Coins) {/*do work*/}</code>遍历这个对象。如果我们通过返回时间顺序来分别定义每个键，这就可以了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="bda9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，有一个特定的情况是这个经验法则失效的:如果你试图使用符号或者整数值作为键(是的，甚至是解释的整数值)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="3151" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是您可以从为2015版Javascript制定的ES6标准的任何实现中期待的回报。</p><p id="3ed8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种行为上的变化是由于内部方法<code class="fe lp lq lr ls b">ownPropertyKeys</code>(保证顺序)的实现发生了变化，这些方法<code class="fe lp lq lr ls b">Reflect.ownKey</code>、<code class="fe lp lq lr ls b">Object.getOwnPropertyNames</code>和<code class="fe lp lq lr ls b">Object.keys</code>都使用但都有(不保证顺序)。枚举它们的方法是使用<code class="fe lp lq lr ls b">Reflect.enumerate</code>或<code class="fe lp lq lr ls b">for-in loop</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/a730822321c6d623fe77ce415bd69bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6q9GHx6w-y3onpRmpnWoA.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated"><a class="ae ly" href="http://www.ecma-international.org/ecma-262/8.0/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate" rel="noopener ugc nofollow" target="_blank">http://www . ECMA-international . org/ECMA-262/8.0/# sec-普通-对象-内部-方法-和-内部-插槽-枚举</a></p></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="f339" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">一些笔记…</h1><ul class=""><li id="e8c3" class="my mz iq kt b ku na kx nb la nc le nd li ne lm nf ng nh ni bi translated">虽然这是可预测和预期的行为，但用户可能正在使用旧版本的JavaScript，虽然这是一种常见的实现，但这并不是标准的。</li><li id="a025" class="my mz iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">为了更加灵活和健壮地处理键值对及其顺序，请尝试JavaScript的更新的<a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> Map对象</a>。</li></ul></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="2a3e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">资源</h1><ul class=""><li id="e16e" class="my mz iq kt b ku na kx nb la nc le nd li ne lm nf ng nh ni bi translated"><a class="ae ly" href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys" rel="noopener ugc nofollow" target="_blank">https://tc39.es/ecma262/#sec-ordinaryownpropertykeys</a></li><li id="d225" class="my mz iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><a class="ae ly" href="https://2ality.com/2015/10/property-traversal-order-es6.html#traversing-the-own-keys-of-an-object" rel="noopener ugc nofollow" target="_blank">https://2 ality . com/2015/10/property-traversal-order-es6 . html # traversing-the-own-keys-of-an-object</a></li><li id="aa3b" class="my mz iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><a class="ae ly" href="https://hackernoon.com/out-of-order-keys-in-es6-objects-d5cede7dc92e" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/out-of-order-keys-in-es6-objects-D5 cede 7 DC 92 e</a></li><li id="86e3" class="my mz iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Map</a></li></ul></div></div>    
</body>
</html>