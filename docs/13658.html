<html>
<head>
<title>Build Subscription-aware Flows in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kotlin中构建订阅感知流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/subscription-aware-flows-in-kotlin-aab4fb026e56?source=collection_archive---------12-----------------------#2022-09-14">https://betterprogramming.pub/subscription-aware-flows-in-kotlin-aab4fb026e56?source=collection_archive---------12-----------------------#2022-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ef92" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">订阅感知流可以允许开发者在现代反应式编程中无缝地使用带有注册回调的遗留API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d128993f1d960c2af9f43d3ed059d028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c94GRTwBkU71PLsHSodEKA.png"/></div></div></figure><p id="8851" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一段时间以前，Android开发者开始推广一种<a class="ae ln" href="https://developer.android.com/topic/libraries/architecture/lifecycle" rel="noopener ugc nofollow" target="_blank">生命周期感知组件</a>模式——基于活动或片段的当前生命周期状态自动调整其行为的组件。我们希望组件已经意识到这一点，而不是明确地告诉组件它处于这种或那种状态。</p><p id="a84e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将演示如何构建订阅感知组件的类似模式——类似于生命周期感知组件的组件可以根据它们的订阅状态做出决策。</p><h1 id="0699" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">例子</h1><p id="9891" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">获取某些组件更新的传统命令式方法如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9526" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在这里使用Android<a class="ae ln" href="https://developer.android.com/reference/android/content/SharedPreferences" rel="noopener ugc nofollow" target="_blank">shared preferences</a>作为例子，但是原则上这里没有什么是Android特有的:在普通的JVM世界中也有类似的<strong class="kt ir"/><code class="fe mn mo mp mq b">registerListener</code>/<code class="fe mn mo mp mq b">unregisterListener</code>API。</p><p id="9649" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着代码的发展，它们给开发人员带来了很多麻烦。我们必须小心内存泄漏:也许<code class="fe mn mo mp mq b">registerListener(listener)</code>会存储一个对监听器的引用，因此也是对定义它的类的引用。也许我们会忘记在某个地方注销它，或者如果没有，也许我们的同事会忘记这样做。</p><p id="71f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有些问题可以通过引入流程来自然解决:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3b31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以现在，我们可以告诉我们所有的同事只使用<code class="fe mn mo mp mq b">sharedPreferencesFlow</code>，忘记<code class="fe mn mo mp mq b">register</code> / <code class="fe mn mo mp mq b">unregister</code>回调。我们<a class="ae ln" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank">反转了控件</a>，我们可以不再关心谁订阅了<code class="fe mn mo mp mq b">sharedPreferencesFlow</code>以及订阅是如何被处理的:很难让它泄漏内存。</p><p id="d16e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，<strong class="kt ir">现在我们在范围</strong>上有了一个问题:不是让每个开发人员决定何时开始和停止更新数据(这在计算上可能有点昂贵)，我们现在为每个人做出决定，并且我们尽可能在最大范围内更新流程，以便每个人都得到保证的更新。</p><h1 id="1463" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">解决方案:订阅感知流程</h1><p id="6d72" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">幸运的是，有一个名为<code class="fe mn mo mp mq b"><a class="ae ln" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/subscription-count.html" rel="noopener ugc nofollow" target="_blank">subscriptionCount</a></code>的<code class="fe mn mo mp mq b"><a class="ae ln" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/subscription-count.html" rel="noopener ugc nofollow" target="_blank">MutableSharedFlow</a></code>字段。它代表许多订阅者，它本身是一个我们可以订阅的StateFlow。</p><p id="1d46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该字段在将<a class="ae ln" href="https://elizarov.medium.com/cold-flows-hot-channels-d74769805f9" rel="noopener">冷流</a>转换为<a class="ae ln" href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow#sharein" rel="noopener ugc nofollow" target="_blank">热流</a>的<code class="fe mn mo mp mq b"><a class="ae ln" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html" rel="noopener ugc nofollow" target="_blank">shareIn</a></code>方法下使用，用于定义开始行为策略:是否<code class="fe mn mo mp mq b">SharedFlow</code>应该工作<code class="fe mn mo mp mq b"><a class="ae ln" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-companion/-eagerly.html" rel="noopener ugc nofollow" target="_blank">Eagerly</a></code>(从声明的那一刻开始并且永不停止)<code class="fe mn mo mp mq b"><a class="ae ln" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-companion/-lazily.html" rel="noopener ugc nofollow" target="_blank">Lazily</a></code>(当某人开始订阅并且永远不停止)，或者<code class="fe mn mo mp mq b"><a class="ae ln" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-while-subscribed.html" rel="noopener ugc nofollow" target="_blank">WhileSubscribed</a></code>。但是在我们的例子中，我们必须手动使用它，因为我们正在调用遗留的<code class="fe mn mo mp mq b">register</code> / <code class="fe mn mo mp mq b">unregister</code>回调:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="86da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">瞧啊。我们有一个改变SharedPreferences的流程(以地图的形式呈现)。应用程序中的任何组件都可以简单地订阅它，当有任何东西订阅它时，更新就会被交付。，之后，资源将会自动释放。</p><p id="6038" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到Android世界，我们可以在一个可组合的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8fc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而且一旦<code class="fe mn mo mp mq b">SomeComposable</code>停止渲染，<code class="fe mn mo mp mq b">unregisterOnSharedPreferenceChangeListener</code>就会自动发生。轻松点。</p><p id="5937" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于代码的几点说明:</p><ul class=""><li id="740c" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated"><code class="fe mn mo mp mq b">applicationScope</code> —这是一个比片段、活动或视图模型更长久的范围。尽管不鼓励使用<a class="ae ln" href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices#global-scope" rel="noopener ugc nofollow" target="_blank">global scope</a>，但是创建自己的将贯穿整个应用程序生命周期的协同作用域并没有什么错。您可以在测试中轻松地覆盖或控制这个范围。</li><li id="ff07" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated"><a class="ae ln" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/" rel="noopener ugc nofollow" target="_blank">协程名称(标签)</a> —这只是出于礼貌，以便当您想知道在任何给定时刻正在执行什么协程，或者给定挂起函数的协程上下文是什么时，这个名称会在调试过程中对您有很大帮助。</li><li id="9233" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated"><a class="ae ln" href="https://dagger.dev/hilt/" rel="noopener ugc nofollow" target="_blank">匕首/刀柄</a>此处隐含使用。我将让读者来实现缺少的部分:-)</li></ul><h1 id="39eb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="73c0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">将遗留代码与新的模式和方法结合起来通常是一个挑战，但是订阅感知流允许我们在注册回调的遗留API和Kotlin流之间架起一座桥梁。这种模式不仅有助于这个遗留<code class="fe mn mo mp mq b">SharedPreferences</code>代码的例子，而且几乎有助于任何使用注册回调方法的代码。</p><p id="9fee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>