<html>
<head>
<title>The Coddfather: Relational Database Fundamentals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码父亲:关系数据库基础</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-coddfather-relational-database-fundamentals-533b96f87651?source=collection_archive---------10-----------------------#2019-09-03">https://betterprogramming.pub/the-coddfather-relational-database-fundamentals-533b96f87651?source=collection_archive---------10-----------------------#2019-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="27ad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索关系数据库及其无处不在的原因</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f536404594b4952a512a7000e56f92ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgxV4qWmiyuy97lDmARm5Q.jpeg"/></div></div></figure><p id="745f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在20世纪中期IBM时代——有一个人名叫Edgar F. Codd，又名“Ted ”,他对数据充满热情。他提出了关系数据库理论，50年后，它仍然是绝大多数网站和应用程序的主要数据存储架构。他的工作达到了顶峰，给我们带来了脸书、Snapchat、Instagram、LinkedIn、YouTube和所有其他基于用户的社交媒体网络应用的pie ce de resistance是一个强大的概念:自我连接表。</p><p id="980e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本系列是为那些对学习关系数据库的基础知识以及为什么它们无处不在感兴趣的人编写的。它还针对那些对自连接及其稍微高级一点的应用程序(比较三重连接)感兴趣的人。在接下来的两篇文章中，我将使用Ruby on Rails演示后者:</p><p id="ab57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lo" href="https://medium.com/@jdprince555/building-self-joins-and-triple-joins-in-ruby-on-rails-455701bf3fa7" rel="noopener"> <strong class="kt ir">在Ruby on Rails </strong> </a>中构建自连接和三连接。</p><p id="7c54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lo" href="https://medium.com/@jdprince555/movie-comparison-website-in-ruby-on-rails-4632f2e1dee2" rel="noopener"><strong class="kt ir">Ruby on Rails中的电影对比网站</strong> </a></p><p id="6e3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们开始吧！</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="d44e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">首先，基本面</h1><p id="c28d" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">想象你和我想要复制脸书。只不过这是20世纪60年代中期，在Ted的提议之前，我们所有的相关信息都必须存储在一个巨大的类似Excel的电子表格中。大概是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a3ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请记住，你和我刚刚开始复制脸书(24亿用户，<a class="ae lo" href="https://www.similarweb.com/website/facebook.com" rel="noopener ugc nofollow" target="_blank">过去6个月200亿次访问</a>)，这意味着它不是7列15行，而是10，000列和100，000，000，000行。(这需要滚动浏览超过2.5亿英里的数据。)</p><p id="fc61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:由于脸书的数据量深不可测，他们使用非关系数据库系统以及关系系统。非关系系统允许它们变得更加具体。然而，出于本文的目的，让我们回到21世纪初，假设他们仍然完全依赖关系系统。</p><p id="c517" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次你添加一个朋友，评论一个帖子或者添加一部电影到你的收藏夹——这些小信息(“贝基”或者“嘿，妈妈！!"或者“比尔和特德的精彩冒险”)被添加到Excel表格的新行的一个单元格中。这一添加将触发一系列自动计算，波及整个电子表格:“在我的‘朋友总数’一栏中加1”。</p><p id="ee02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，每次你想直接<em class="ln">改变</em>一些信息[“新的个人资料图片”或“编辑最后的评论”]，计算机将挖掘数十亿，可能数万亿行，加上几千列，找到并改变那一个，单个单元格。</p><p id="ed03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可能吗？当然可以。</p><p id="b799" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是数据大决战吗？是的。是的，它是。事实上，这是一场真正的噩梦。一场血腥、不可靠的数据噩梦。</p><p id="bffe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特德·科德带着激进的解决方案和整洁的小胡子走进来:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/018b353b8d3d638dfa17638add735417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*YQ3-STSsVV1qlmhc6sCwkw.jpeg"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">泰德·科德</p></figure><p id="914e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Ted的理论是，我们可以将这个巨大的电子表格分解成许多彼此“相关”的小电子表格。</p><p id="fe09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要将数据之间的“关系”概念化，请考虑家庭关系。我和父母有血缘关系，我的孩子和我有血缘关系。我们整个系列都有一些共同的特点。这些特征由一条独特的DNA链决定。DNA让我们成为一家人。</p><p id="d010" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想想这张家长表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/334222d79043d1399da7bc28123e67eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*nXUMI1XQNnLiUEqt35P1ag.png"/></div></figure><p id="d8f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些孩子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/562af1e32a039046ea6628652d1a4aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*B0CDrYBGbP7ovU9V4ciQfA.png"/></div></figure><p id="152b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">c<em class="ln">children</em>表保存了一条将孩子与父母联系起来的重要信息:与孩子相关联的父母的名字。通过在children表中查找所有孩子，我可以看到Janelle的所有孩子(Louis和Tanner ),她的名字出现在parent列中。</p><p id="ab40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是有意义的，也是有帮助的。然而，事实上，孩子并不是通过父母的<em class="ln">名字</em>与父母唯一联系在一起的。基于任意的、可变的因素将父母和孩子联系在一起，例如<em class="ln">名字</em>是灾难性的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/527efd23c479f8add0018b8c3abddbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*pWrj8ArQ0pw3b6rtIpKUKQ.png"/></div></figure><p id="20a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">突然，路易斯和坦纳的妈妈把自己克隆成了两个相距一千英里的人。…但是路易斯和坦纳是兄弟姐妹吗？也许他们只是碰巧有同名的母亲。那样的话，谁的妈妈是谁的？啊哦。</p><p id="809f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们需要每个人都有一个唯一的标识符。我们需要更像DNA的东西。更好的是，如果我们能得到数字形式的DNA呢？计算机特别喜欢这样。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="9c1d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><em class="nd">输入:唯一id！</em></h1><p id="a6a7" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">惟一id是关系数据库中信息存储的基础。下面是它们的使用方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/5f7a52a78a1a2078cc2269cc7b586057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*qb0oErDCsbGQ6k0U_n15Cg.png"/></div></figure><p id="14a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您会注意到children表中的“name”列现在完全没有用了。因此，我们删除该列，并将父代的<em class="ln"> id </em>(标识号)<em class="ln"> </em>保留在一个名为parent_id列的修订列中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/25f5b4ed1c4fde89abcf65d623d54366.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*EoeIxUS4QNLtAs1EAmUFfA.png"/></div></figure><p id="dbe5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只要我们确保没有父母拥有相同的id，id就可以有效地充当“DNA”他们是唯一的，<em class="ln"> </em>分配给每个父母的不可变因素，使得每个父母都是独一无二的。</p><p id="a5bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着身份识别系统的引入，我们现在可以绝对肯定地知道路易斯的母亲Janelle住在西雅图，而坦纳的母亲Janelle也住在阿尔伯克基:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/3e1cef7695916f6cf4e6525ae7436a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2iMplyfX-OmbJ47VUJGhbA.png"/></div></div></figure><p id="6007" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就像单链DNA包含了决定我们外表和行为的属性一样，每个id号包含了定义一个人的数据。因此，我们不需要后两列，<em class="ln"> parent_name </em>和<em class="ln"> parent_city — t </em>帽子信息隐含在<em class="ln"> parent_id中。</em></p><p id="7a98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最重要的是，我们的桌子非常简单！我们不会左右上下滚动来寻找我们需要的东西。我们有两个独立的表，分别负责数据库的一个方面:一个是孩子的，一个是父母的。</p><p id="10e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看实际情况。如果我们想发现一个父表的信息，我们在父表中搜索一个相关的行。在那里，我们可以看到父母的姓名、年龄、地点等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7f667442c03a42010078e824cbc9961a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*lIwvZz87SYE1nGQleQ_ZBg.png"/></div></figure><p id="3f00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们爱管闲事，所以我们也对查看父母的孩子的信息感兴趣(姓名、年龄、地点、学习)。这很简单:只需获取父id (1)，跳到子表，在<em class="ln"> parent_id </em>列中搜索所有匹配数字(1)的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/a6625a01f63073683737ae30b66015a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9IvQagzj2osX4nViFty3A.png"/></div></div></figure><p id="8df7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们只剩下精选的高度相关的数据。</p><p id="00db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，这就是关系数据库系统的优点和用处。它允许我们通过分离关注点来集中我们的活动。我们有两个表，处理非常不同的数据，但它们很容易与id相关联。</p><p id="7f29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在最初的例子中，我们被要求将我们所有的信息包含在一个单一的源中，这将迫使我们不断地重写和重新链接元素。有了Ted的关系系统和强大的惟一id，大量的工作得以避免。</p><h1 id="8d9e" class="lw lx iq bd ly lz ni mb mc md nj mf mg jw nk jx mi jz nl ka mk kc nm kd mm mn bi translated">脸书怎么样？</h1><p id="0890" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">让我们回到重建脸书的探索上来。现在，有了Ted的工具，我们可以通过把它分成许多更小的、高度集中的表格来管理我们的噩梦般的数据堆，每个表格关注更大画面的一个方面。用户、帖子、评论和喜欢现在是由一个简单的数字公分母链接在一起的单个表格:<em class="ln">唯一id</em>。</p><p id="aa82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们用用户(父)到帖子(子)的关系来想象一下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5e3f923d72078c181ada371b30e6121e.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*_oQMkhxjvW0lbB8mWCT3ow.png"/></div></figure><p id="07eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个用户有许多帖子，每个帖子有一个用户，所以我们说posts是子表，user是父表。为了正确设置这种关系，我们只需要确保每个帖子都包含用户的“DNA”，将两者不可分割地联系在一起:<em class="ln"> User_id </em>。</p><p id="539f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">帖子的每个实例包括帖子的id(T12)和一些数据(在本例中是文本(T16)和时间(T19)以及一个用户id(T20)和T21，它建立了与用户的关系</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e6acf23cb7f173a5590e18d6da6c46ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pj_Djq7Idga5BU2BhnEXEA.png"/></div></div></figure><p id="0f5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不错！尽管第一篇和第三篇帖子是在完全相同的时间发布的，并且包含完全相同的文本，但它们在id<em class="ln">和作者<em class="ln">方面是独一无二的，</em>由<em class="ln">用户id表示。</em>我们很确定的知道Janelle写了第一个帖子(<em class="ln"> id等于1)，</em>Ted写了第三个帖子(<em class="ln"> id等于3)。</em></em></p><p id="960a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，因为所有帖子数据都存在于单个表格中，所以我们可以轻松地从所有<em class="ln">帖子或所有<em class="ln">Ted的</em>帖子<em class="ln"> </em>中提取信息并分析数据，而不必先删除不相关的信息。</em></p><p id="3cd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最重要的是，我们没有重写任何东西。更干净。更清晰。少干活。错误更少。</p><p id="bbe5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">瞧啊。现在，评论和帖子通过帖子的DNA或唯一id(即父帖子)相关联。首先，我们的表中没有不必要的空白，定位数据的整体效率得到了极大的提高。</p><h1 id="7467" class="lw lx iq bd ly lz ni mb mc md nj mf mg jw nk jx mi jz nl ka mk kc nm kd mm mn bi translated">“喜欢”和这有什么关系？</h1><p id="63db" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">“喜欢”是社交媒体网站中一个有趣的功能。单个Like包含两个重要的信息位:<em class="ln">谁</em>创建了Like，以及<em class="ln">什么</em>接收了Like。</p><p id="f9c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们从一个表的角度来考虑这个问题，我们会看到每个Like都有一个用户。它<em class="ln">也</em>正好有一个职位。因此，赞是用户和帖子的<em class="ln">子</em>。它包含了他们每个人的DNA:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/837dcc0dd7b82b5788498cac7e6f93d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*K6AxpLLjWb_wpNB-G7o77w.png"/></div></figure><p id="7e46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们把这个描述为:一个喜欢的<em class="ln">属于</em>单个用户；那个同样喜欢也<em class="ln">属于</em>的单个帖子。它有两个父母。那些父母通过知道<em class="ln"> </em>单身的和<em class="ln">有关系的。</em></p><p id="2502" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过创建此表，我们意味着:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/d7191107e48c50c175d70de130f54c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hi_AJDwybmEbEQt3zVSrRg.png"/></div></div></figure><p id="1c6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">灰色列是不必要的，但它们说明了该表的行为:</p><p id="537c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Janelle的第一篇帖子(<em class="ln"> Post_id = 1 </em>)“我的第一篇帖子！”，写于2021 . 08 . 09晚上10:45，已经积累了两个赞。一封来自Janelle本人(<em class="ln">1</em>的User_id)，另一封来自Ted(<em class="ln">2</em>的User_id)。</p><p id="912c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种类型的关系经常出现在关系数据库中。之所以称之为<em class="ln">多对多关系</em> <strong class="kt ir">，</strong>是因为一个帖子可以有很多赞，而每个赞都有一个用户。因此，每个帖子可以有许多相关联的用户。同样，每个用户都有许多赞，每个赞都有一个帖子。因此，每个用户<em class="ln">都有许多相关联的p</em>ost。</p><p id="aa64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这种关系，我们就可以通过搜索like表中出现他的id ( <em class="ln"> 2 </em>)的所有实例来查找<em class="ln">Ted的所有like</em>。然后，我们可以很容易地分析泰德的偏好，这也是真正的脸书喜欢的。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="3f42" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">朋友呢？</h1><p id="4c3c" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">好的，所以我们在用户和帖子之间有一个<em class="ln">一对多</em>的关系，我们通过喜欢有一个<em class="ln">多对多</em>的关系。朋友呢？如果Janelle和我成为朋友，谁是父母，谁是孩子？答案是:都不是。我们都只是用户。我们都是通过友谊联系在一起的用户。</p><p id="5a3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与用户发帖模型不同，在这种模型中，一个用户有许多帖子，一个帖子有<em class="ln">一个用户，这种新的“友谊”挑战要求两个用户都有许多其他用户。Janelle <em class="ln">有很多</em>朋友(用户)。我<em class="ln">有很多</em>朋友(用户)。因此，我们只有一个表可以使用:users。</em></p><p id="aa23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们如何显示这些信息？我们可以创建一个“我的朋友”表，包含我所有的朋友和他们的唯一id，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/581dacde7d2f25f8177bd49c49fcb388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*oYO99RSurt3hntW7r9fUsQ.png"/></div></figure><p id="12c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们走这条路，我们必须为每个用户创建一个新的“我的朋友”表<em class="ln">。相反，我们想要一个包含所有友谊的表。为此，我们创建了所谓的<em class="ln">自连接</em>关系。</em></p><p id="9996" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建自连接表是为了将一个表连接到自身，即Janelle和我都是用户的实例，友谊是将我们连接在一起的表。所以，友情是一种自我加入，因为它把用户加入到自己身上。</p><p id="4cd0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自连接的优点在于它的简单性。我们仍然只需要三列:一列用于我的id(代表我和我的所有信息)，一列用于Janelle的id(代表她的所有信息)，还有一列用于描述友谊本身，它对我们来说是完全唯一的:一个友谊id。就是这样。它看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/f8b970a8f9c4f234eb4322dfa34f7346.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*9luYrpei9Zj6tGLdX1JVqQ.png"/></div></div></figure><p id="9fe6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们将此抽象为所有的友谊，而不仅仅是我的友谊，我们会看到这样的情况:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/b85e21c0d90c808177f32a7abafb4c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*lSWafLM0f2BE3kzS-e76uw.png"/></div></div></figure><p id="8580" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我现在可以很容易地看到我的id(在这个例子中是5)出现在friendships表的2行中。因此，我有两个朋友。我知道他们是哪些朋友，因为他们的id在相邻的列中(Ted 2和Dennis 3)。为了检索关于他们中任何一个的数据，我所要做的就是获取他们的id并在用户表中进行搜索。他们对我也是如此！</p><p id="e57b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这三个简单的栏目使得像脸书这样的社交媒体网站成为可能。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="92c3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">创建比较自连接和三连接！</h1><p id="2a84" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在上面的例子中，两个用户平等地分享一个友谊。我的id在第二列还是第三列没有区别。这种设计对脸书和LinkedIn这样的网站很有效。但在Twitter、Instagram和YouTube上，一个用户是“关注者”，而另一个用户是“被关注者”，这又是怎么回事呢？在这种情况下，第一个<em class="ln">用户id </em>变成“跟随者id”，第二个<em class="ln">用户id </em>变成类似“the_one_being_followed_id”</p><p id="857c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不确定这种类型的自连接关系的确切术语，但是“比较”自连接对我来说是有意义的，因为我们同时<em class="ln">链接</em>来自同一个表的两个元素并且<em class="ln">比较</em>它们:一个元素是X ( <em class="ln">追随者)</em>，另一个是Y ( <em class="ln">跟随)</em>。</p><p id="e553" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想实时看到这种使用Ruby on Rails创建的twitter风格的比较自加入，这里有两篇我在学习这个概念时不断回顾的优秀文章:</p><div class="nu nv gp gr nw nx"><a href="https://medium.com/@TheDickWard/self-referential-relationships-aka-self-joins-in-rails-64f8f36ac311" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">Rails中的自引用关系(也称为自连接)</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">在我学习web开发时，Rails关系是我最难以理解的事情之一…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/@jbmilgrom/active-record-many-to-many-self-join-table-e0992c27c1e" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">活动记录:多对多自联接表</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">从普通的到多对多的自连接表</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol kp nx"/></div></div></a></div><p id="e908" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想了解在我看来更直观的比较自加入的例子，请点击下面的链接:从头到尾演示如何创建一个电影比较应用程序。</p><p id="1752" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将通过一个比较表(自连接)将两部电影联系起来，然后将这个比较与一个特定的用户联系起来。结果是一个三重连接。</p><p id="3dd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">潜行高峰:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/88ddadd4aeb9ea2e9cd143bd50f438aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzLg4InmXMhgwG_ZAfSBxA.png"/></div></div></figure><p id="21ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据以上所述，我们推断当涉及到电影1、2和3时，用户1和用户2具有相反的偏好。</p><p id="1c04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太棒了。</p><p id="561e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你要离开这里，那么感谢你的阅读！否则，点击这里，我马上就来。</p><p id="b403" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lo" href="https://medium.com/@jdprince555/building-self-joins-and-triple-joins-in-ruby-on-rails-455701bf3fa7" rel="noopener"> <strong class="kt ir">在Ruby on Rails中构建自连接和三元连接</strong> </a></p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="3e55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为你干杯，泰德。</p><p id="6830" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">快乐编码</p><p id="027b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">杰克逊</p></div></div>    
</body>
</html>