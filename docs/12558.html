<html>
<head>
<title>Schedule Simple Go App Workloads Using Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Google云平台安排简单的Go应用程序工作负载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-scheduled-workloads-using-google-cloud-b23448a027ff?source=collection_archive---------15-----------------------#2022-06-13">https://betterprogramming.pub/simple-scheduled-workloads-using-google-cloud-b23448a027ff?source=collection_archive---------15-----------------------#2022-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1aaa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于使用GCP、Docker和Terraform的基础设施即代码来安排工作负载的简短教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/517e5005814b19934d73624b6fd608a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I93m2TIRkmztqUy8"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Towfiqu barb huya</a>拍摄的照片</p></figure><p id="f402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您需要定期运行一个作业。你会怎么做？</p><p id="a6f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">传统的方法是提供一个VM(在某个地方)，运行crontab，然后调用任何您想要的脚本/二进制文件。</p><p id="d9a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很简单，也很有效，但是有一些挑战…</p><ul class=""><li id="355d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果你的机器坏了怎么办？</li><li id="909b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">重新启动却停不下来怎么办？</li><li id="d927" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果有人拿到了怎么办？</li></ul><p id="3291" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我大概能想出十多个这样的问题。关键是这种方法有风险。</p><p id="def9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你只是不知道它什么时候会对你不利。迟早，它最终会发生，通常是在最不合适的时候！</p><p id="b361" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，您现在面临另一个问题:监控和警报。那通常是两个问题。复杂性不断扩大。</p><p id="aaf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然之前解决过很多次了，但是何必呢？正如他们所说，时间就是金钱！在当今世界，那句话更准确地表述为“时间有错失机会的成本！”</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="0025" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入谷歌云和手头的任务…</p><p id="f2ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我当前最喜欢的项目，我需要定期处理新文档。任务是什么无关紧要。重点在于调度和运行这些工作负载。</p><p id="7ff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过一番挖掘，我得出了以下结论:</p><ul class=""><li id="0915" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://cloud.google.com/run/docs/create-jobs" rel="noopener ugc nofollow" target="_blank">谷歌云运行乔布斯</a></li><li id="0099" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://cloud.google.com/scheduler/docs/schedule-run-cron-job" rel="noopener ugc nofollow" target="_blank">谷歌云调度器</a></li><li id="cf62" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://cloud.google.com/artifact-registry/docs" rel="noopener ugc nofollow" target="_blank">谷歌神器注册表</a></li></ul><p id="d8d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分为以下几个步骤:</p><ul class=""><li id="566b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">将代码推送到GitHubCI/CD(这部分我就不细说了，我在之前的<a class="ae kv" href="https://MihaiBojin.com/projects/golang/best-practices-vs-time?utm_source=Medium&amp;utm_medium=organic&amp;utm_campaign=rss" rel="noopener ugc nofollow" target="_blank">文章</a>里讲过一点)</li><li id="e439" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">构建代码</li><li id="8e96" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将二进制文件打包成Docker容器</li><li id="ae60" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将容器推送到Google工件注册表</li><li id="4cf3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将容器作为Google Cloud运行作业运行</li><li id="96da" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">定期运行作业以处理新工作</li></ul><p id="e932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里没有什么疯狂的，但是我想把这些都写下来也许有一天能帮助到某个人；从工作实例开始总是更容易！</p><blockquote class="mn mo mp"><p id="92cf" class="kw kx mq ky b kz la jr lb lc ld ju le mr lg lh li ms lk ll lm mt lo lp lq lr ij bi translated">开始之前，安装并配置<a class="ae kv" href="https://cloud.google.com/sdk/docs/install-sdk" rel="noopener ugc nofollow" target="_blank"> GCloud CLI </a>！</p></blockquote><h2 id="3c95" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated">构建Golang应用程序</h2><p id="8640" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">Golang是当今大多数工作负载的绝佳选择。它的生态系统欣欣向荣；你会发现一个几乎什么都有的图书馆；学习和编码都很简单；它非常适合生成静态链接库，从而产生小容器(例如，大约13MB，而不是Java应用程序的120MB以上)</p><h2 id="be8d" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated">把它归档</h2><p id="fe78" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">让你的容器尽可能小的最好方法是使用Docker的<a class="ae kv" href="https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>。</p><p id="66f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">粗略地说，这意味着在标准映像上构建应用程序，然后只将生成的工件复制到“scratch”(Docker对基本上“只是主机操作系统的内核”的名称)。</p><p id="696a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">docker文件如下所示:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="8815" class="mu mv iq nt b gy nx ny l nz oa"># syntax = docker/dockerfile:1.3<br/>FROM golang:1.18-buster as builder<br/><br/># Install and update root SSL certificates<br/>RUN apt-get update \<br/>     &amp;&amp; export DEBIAN_FRONTEND=noninteractive \<br/>     &amp;&amp; apt-get -y install --no-install-recommends \<br/>        ca-certificates \<br/>     &amp;&amp; apt-get clean -y \<br/>     &amp;&amp; update-ca-certificates<br/><br/># Cache go dependencies to avoid downloading them on every rebuild<br/>WORKDIR /app<br/>ENV CGO_ENABLED=0<br/>COPY go.* ./<br/>RUN go mod download<br/><br/># Copy local code to the container image.<br/>COPY . .<br/><br/># Build the binary using buildkit's cache to speed up rebuilds<br/># https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#example-cache-go-packages<br/>ARG TARGETOS<br/>ARG TARGETARCH<br/>RUN --mount=type=cache,target=/root/.cache/go-build GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -ldflags "-s -w" -v -o app .<br/><br/># Make the smallest possible container<br/># https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds<br/>FROM scratch<br/>COPY --from=builder /app/app /app/app<br/>COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/<br/>CMD ["/app/app"]</span></pre><p id="8478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于此步骤的几点注意事项:</p><ul class=""><li id="3bde" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">您可以定义一个更简单的Dockerfile文件；这实际上取决于您希望重新构建它的次数——因为这意味着在Google Cloud中运行，您可以假设远程构建过程将在每次提交时运行和重新部署，并且很可能没有预先存在的缓存，因此所有这些都是不必要的；在本地，这有很大的不同，这就是为什么我这样实现！</li><li id="bd14" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我的代码需要通过TLS连接到其他服务；“scratch”缺少<a class="ae kv" href="https://en.wikipedia.org/wiki/Root_certificate" rel="noopener ugc nofollow" target="_blank">根证书</a>；上面的定义通过安装<code class="fe ob oc od nt b">ca-certificates</code>包并确保包含最新的证书来添加它们(<code class="fe ob oc od nt b">update-ca-certificates</code>；最后，它通过<code class="fe ob oc od nt b">COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/</code>将它们包含在最终结果中</li><li id="bb93" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果你在M1 Mac上构建，记住<code class="fe ob oc od nt b">arm != x64</code>；因此，您的Docker构建命令应该针对您的预期运行时平台(在GCP，即<code class="fe ob oc od nt b">x86_64</code>)的正确架构，即:<code class="fe ob oc od nt b">docker build --platform linux/x86_64 ...</code></li></ul><h2 id="cf58" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated">将容器推送到工件注册表</h2><p id="01fd" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">第一，创建回购；我用Terraform来做这个。<strong class="ky ir"> IaaC FTW！</strong></p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="53f4" class="mu mv iq nt b gy nx ny l nz oa">variable "gcloud_region" {<br/>  default = "europe-west3" # your region of choice<br/>}<br/>variable "gcloud_project" {<br/>  default = "..." # your GCP project ID<br/>}<br/><br/># GCloud Run Jobs are not fully GA yet, and you need to use the beta provider for now<br/>provider "google-beta" {<br/>  project     = var.gcloud_project<br/>  region      = var.gcloud_region<br/>  zone        = format("%s-c", var.gcloud_region) # desired AZ, usually something like: 'europe-west3-c'<br/>}<br/><br/>resource "google_artifact_registry_repository" "containers" {<br/>  provider = google-beta<br/>  location = var.gcloud_region<br/>  repository_id = "containers" # the repo's name<br/>  format = "DOCKER"<br/>  lifecycle {<br/>    prevent_destroy = true # avoids accidentally deleting all published images<br/>  }<br/>}</span></pre><p id="7136" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定一个现有的存储库(在我的例子中是<code class="fe ob oc od nt b">REPO=containers</code>)，推送您的映像非常简单:</p><ul class=""><li id="6689" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">标记图像:<code class="fe ob oc od nt b">docker tag "${IMAGE}" "${REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${REPO}/${IMAGE}"</code>(显然，正确设置了上述变量)</li><li id="7049" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">配置Docker推送到GCP <br/> <code class="fe ob oc od nt b">gcloud auth configure-docker --project ${GCP_PROJECT_ID} --quiet ${REGION}-docker.pkg.dev</code></li><li id="5428" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">推送图像<br/> <code class="fe ob oc od nt b">docker push "${REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${REPO}/${IMAGE}"</code></li><li id="124c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">并且可选地，检查它是否被正确上传<br/> <code class="fe ob oc od nt b">gcloud artifacts docker images list "${REGION}-Docker.pkg.dev/${GCP_PROJECT_ID}/${REPO}/${IMAGE}"</code></li></ul><h2 id="b2c8" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated">将容器作为Google Cloud运行作业运行</h2><p id="76f3" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">我不会在这里涉及很多细节；这应该是不言自明的；运行一个<code class="fe ob oc od nt b">gcloud</code>命令来定义作业。</p><p id="59df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，<a class="ae kv" href="https://registry.terraform.io/providers/hashicorp/google/latest/docs" rel="noopener ugc nofollow" target="_blank"> GCP平台提供商</a>还不支持创造就业机会。</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="e7f9" class="mu mv iq nt b gy nx ny l nz oa">gcloud beta run jobs create ${JOB_NAME} \<br/>  --region "${REGION}" \<br/>  --image "${REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/containers/roles.tech/${APP_NAME}:latest" \<br/>  --tasks 1 \ # Only run one task<br/>  --max-retries 0 \ # Do not retry<br/>  --set-env-vars "KEY1=VALUE1,KEY2=VALUE2,..." # set any env vars required by the running code</span></pre><blockquote class="mn mo mp"><p id="5f94" class="kw kx mq ky b kz la jr lb lc ld ju le mr lg lh li ms lk ll lm mt lo lp lq lr ij bi translated">这里有一个小提示:如果您通过UI定义作业，它将使用当前可用的任何图像；使用<code class="fe ob oc od nt b">...:latest</code>总是运行最新的Docker镜像，避免每次代码重建都必须更新作业的定义！</p></blockquote><h2 id="5cb8" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated">使用CronJob触发定期执行</h2><p id="3225" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">再一次，地球形态来拯救我们了:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="ef54" class="mu mv iq nt b gy nx ny l nz oa"># retrieves the default service account<br/># this is an anti-pattern, and you're probably better off creating a dedicated service account<br/>data "google_compute_default_service_account" "default" {<br/>}<br/>variable "job_name" {<br/>  default = "..." # the name of your job ($JOB_NAME above)<br/>}<br/><br/>resource "google_cloud_scheduler_job" "cronjob-name" {<br/>  name             = "cronjob-name"<br/>  schedule         = "0 * * * *" # run every hour on the dot<br/>  time_zone        = "Etc/UTC" # UTC timezone<br/>  attempt_deadline = "15s"<br/><br/>  retry_config {<br/>    retry_count = 0 # do not retry, if the job fails<br/>  }<br/><br/>  # trigger the Cloud Run Job by calling its handler via HTTPS, with an empty body<br/>  http_target {<br/>    http_method = "POST"<br/>    uri         = format("https://%s-run.googleapis.com/apis/run.googleapis.com/v1/namespaces/%s/jobs/%s:run", var.gcloud_region, var.job_name, var.gcloud_project)<br/>    body        = ""<br/><br/>    # authenticate via OAuth using the specified service account<br/>    oauth_token {<br/>      service_account_email = data.google_compute_default_service_account.default.email<br/>    }<br/>  }<br/>}</span></pre><p id="3327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！如果你需要一个简单可靠的机制来周期性地执行代码，只需要看看<a class="ae kv" href="https://cloud.google.com/run/docs/create-jobs" rel="noopener ugc nofollow" target="_blank"> Google Cloud Run </a>和<a class="ae kv" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>就可以了。</p><p id="1f3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢大家！</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="27bf" class="mu mv iq nt b gy nx ny l nz oa"><strong class="nt ir">Want to Connect?</strong></span><span id="7d90" class="mu mv iq nt b gy oe ny l nz oa">Opinions and suggestions are always welcome (find me on <a class="ae kv" href="https://twitter.com/mihaibojin" rel="noopener ugc nofollow" target="_blank">Twitter</a>).</span></pre></div></div>    
</body>
</html>