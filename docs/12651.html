<html>
<head>
<title>Implementing a Component Overlay Loader With Angular CDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用角度CDK实现组件覆盖加载器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-component-overlay-loader-with-angular-cdk-21c071f53b30?source=collection_archive---------7-----------------------#2022-06-20">https://betterprogramming.pub/implementing-a-component-overlay-loader-with-angular-cdk-21c071f53b30?source=collection_archive---------7-----------------------#2022-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a7d3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过向您的组件添加加载程序来支持UX</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1e5b7a8d571c7655fa571f6f6ccd7256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*R7vTuZBklAOy0hK5yHJ1qw.gif"/></div></div></figure><p id="7afc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在大多数web应用程序中，数据是从服务器加载的。它可以是图像、视频、纯文本或任何其他类型的数据。在检索该信息时，用户需要被告知一个视觉指示器。</p><p id="2751" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在之前的一篇名为<a class="ae ln" href="https://medium.com/@lambda_dev/implementing-a-global-overlay-loader-with-angular-e31ab4665cb1" rel="noopener">“使用角度CDK实现页面覆盖加载器”</a>的文章中，我们构建了一个服务，在整个页面的顶部显示一个组件，以通知用户并防止加载时的交互。这种方法通过在屏幕中央显示一个加载器来通知用户，从而解决了这个问题。然而，这对于用户来说可能是令人讨厌的，因为它阻止了与其他内容的交互。</p><p id="dfc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么本文要在组件之上添加一个加载器来通知用户，并让用户在加载时与其他组件进行交互。</p><h1 id="41cf" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">重用我们的全局加载器</h1><p id="f0d0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了构建新的加载器，我们将重用我们之前构建的服务<a class="ae ln" href="https://medium.com/@lambda_dev/implementing-a-global-overlay-loader-with-angular-e31ab4665cb1" rel="noopener">，它负责显示和隐藏加载器，如下所示。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/b08e2028983ebe22a7e2a57e2a2fad54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uJw1f0J24Wk3jrf_X5EnXg.gif"/></div></div></figure><p id="ba6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你还没有阅读前一篇文章，不要担心，这是推荐的，但不是必需的。你只需要看看下面的服务，然后继续阅读。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a7bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们之前构建的服务。它负责显示和隐藏一个页面加载器，通过使用一个由角材料CDK提供的覆盖。</p><p id="7e53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">覆盖调用我们的<code class="fe mo mp mq mr b">LoaderComponent</code>，它是一个组件，封装了由<a class="ae ln" href="https://loading.io/css/" rel="noopener ugc nofollow" target="_blank"> loading.io </a>提供的CSS加载器动画。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="34cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了从页面覆盖切换到组件覆盖，我们需要目标组件的引用。一种方法是将我们的服务转换成附加到目标组件的属性指令。</p><p id="f145" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于那些不知道的人来说，属性指令是一个角度概念，“改变DOM元素和角度组件的外观或行为”。如果你想更多地了解这个话题，我建议你阅读官方文档。</p><h1 id="62af" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">获取组件引用</h1><p id="fb88" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了用指令替换我们的服务，我们必须改变角度配置，用<code class="fe mo mp mq mr b">@Directive</code>替换<code class="fe mo mp mq mr b">@Injectable</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c2c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们从一个服务中移出，我们需要在一个<code class="fe mo mp mq mr b">Module</code>中声明和导出我们的指令。我们可以在我们的<code class="fe mo mp mq mr b">AppModule</code>中完成，但是让我们创建一个专用的模块，以避免有一个大而不可维护的<code class="fe mo mp mq mr b">AppModule</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f117" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将指令附加到组件，并将可观察对象传递给指令，以便知道何时显示和隐藏加载程序。</p><p id="4973" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，我们将把指令附加到一个<a class="ae ln" href="https://material.angular.io/components/table/overview" rel="noopener ugc nofollow" target="_blank">角度材料表</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8ef7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，我们应该在指令中声明输入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8a77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在数据被请求时显示加载器，并订阅我们的observable，以了解数据何时被传递，从而隐藏加载器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="80f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们将可观察对象传递给指令，我们有两个订阅。一个订阅来自异步管道，另一个来自我们的指令。这导致了两次HTTP调用，每个订阅一次。</p><p id="a8ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了减轻这种副作用，我们可以使用RxJs运算符<code class="fe mo mp mq mr b">ReplaySubject</code>，将我们的可观测值从冷转变为热。如果你想深入了解这个话题，我建议你阅读本·莱什的文章<a class="ae ln" href="https://benlesh.medium.com/hot-vs-cold-observables-f8094ed53339" rel="noopener">热与冷的对比</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="15a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们最终将我们的服务转化为指令。一切如前所述，我们有了改变装载机位置策略的目标组件的参考。</p><h1 id="aeb6" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">改变定位策略</h1><p id="b8bd" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在我们使用了一个指令，我们可以注入组件引用来将加载器<code class="fe mo mp mq mr b">positionStrategy</code>从全局改为局部。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="021f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们使用带有中心位置的<code class="fe mo mp mq mr b">flexibleConnectedTo</code>将覆盖位置链接到<code class="fe mo mp mq mr b">elementRef</code>。此外，我们可以删除让用户与其他组件交互的<code class="fe mo mp mq mr b">hasBackdrop</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="23d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">恭喜你。最后，我们将页面加载器转换为组件加载器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1e5b7a8d571c7655fa571f6f6ccd7256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*R7vTuZBklAOy0hK5yHJ1qw.gif"/></div></div></figure><p id="58cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你现在可以把加载器附加到你想要的所有组件上，它会同样的渲染！</p><h1 id="ff90" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">修复剩余的问题</h1><p id="c0e8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">作为软件开发人员，我们倾向于认为当我们走过快乐的道路时，它就结束了。</p><p id="b05c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，为了生产高质量的软件，我们应该考虑并覆盖边缘情况。这就是为什么我们将看到加载器在滚动时的行为。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/a4afdcf16053dc54c289db7ef59041d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/1*kkDh9s43M2rgsfgP7NSDAw.gif"/></div></figure><p id="9155" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，当我们滚动时，组件在移动，但是加载器没有移动，它停留在初始位置。这不是预期的行为。事实上，当组件移动时，加载程序应该跟随组件。</p><p id="73d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们可以使用<code class="fe mo mp mq mr b">scrollStrategy</code>重新定位。这意味着当我们滚动时，它将重新定位覆盖图，以适应所提供的位置。</p><p id="32c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这还不够。如果我们滚动直到组件消失，加载器应该是隐藏的。为此，我们可以禁用名为<code class="fe mo mp mq mr b">withPush</code>的特性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="fad3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">滚动问题已修复，我们的加载程序正常工作！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/7e9c04a8904b207a3765f6d9a02e4109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/1*2kq1CZGsj4HYDRa9Oi78rw.gif"/></div></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="8657" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你不想在你的应用中维护这种逻辑，我们构建了<a class="ae ln" href="https://github.com/Silvere112/ngx-load" rel="noopener ugc nofollow" target="_blank"> ngx-load </a>，一个为你做这项工作的库。</p><pre class="kg kh ki kj gt nb mr nc nd aw ne bi"><span id="0b58" class="nf lp iq mr b gy ng nh l ni nj"><strong class="mr ir">Want to Connect?</strong></span><span id="74ce" class="nf lp iq mr b gy nk nh l ni nj">Follow me on <a class="ae ln" href="https://twitter.com/lambda_dev" rel="noopener ugc nofollow" target="_blank">Twitter</a> to read more about Angular!</span></pre></div></div>    
</body>
</html>