<html>
<head>
<title>Understand Copy-on-Write in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Swift 5中的写入时复制</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-copy-on-write-in-swift-5-52a4716165a3?source=collection_archive---------11-----------------------#2020-03-03">https://betterprogramming.pub/understand-copy-on-write-in-swift-5-52a4716165a3?source=collection_archive---------11-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="694f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">结构、值类型和黑魔法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c186569bec5a4fed2140131692ee625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRNlIrEgDCtBRjknh6W5sg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Giammarco Boscaro 在<a class="ae ky" href="https://unsplash.com/s/photos/library?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="48f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解什么是写时复制，以及为什么它绝对令人敬畏。我们还将了解它是如何工作的，以及如何用写时复制行为实现我们自己的定制对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="126b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是写入时复制？</h1><p id="1247" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">写时复制是值类型背后的魔力。首先，考虑下面这个简单的例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8aba" class="ne md it na b gy nf ng l nh ni">var x = ["a", "b", "c"]<br/>let y = x<br/>x.append("d")<br/>print(x) //<em class="nj">["a", "b", "c", "d"]</em><br/>print(y) //<em class="nj">["a", "b", "c"]</em></span></pre><p id="ba35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经知道，像Array这样的集合具有值语义。</p><p id="6f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着不同于引用类型，引用类型存储对象的引用，值类型存储对象的副本。在上面的例子中，<code class="fe nk nl nm na b">y</code>得到了<code class="fe nk nl nm na b">x</code>的一个副本。</p><p id="18bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次你给一个变量赋值的时候，都会产生一个副本。这听起来非常昂贵，这样的事情怎么会发生在Swift？</p><p id="d5d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了写入时复制，它实际上并不贵。</p><p id="deeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，这两个数组都包含对存储实际数组的内存位置的引用。此时，<code class="fe nk nl nm na b">x</code>和<code class="fe nk nl nm na b">y</code> <em class="nj"> </em>都指向同一个地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使<code class="fe nk nl nm na b">x</code>变异时，它首先检查它是否是那个内存位置的唯一所有者。如果是，那就不用担心，<code class="fe nk nl nm na b">x</code>可以安全变异。</p><p id="32ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果有其他拥有者，<code class="fe nk nl nm na b">x</code>会被复制到一个新的内存缓冲区，并且只有在完成后才会变异。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f18c" class="ne md it na b gy nf ng l nh ni">//Memory address of x and y after appending to x:<br/>print(MemoryAddress(of: x)) // <strong class="na iu">0x00007fb027b93740</strong><br/>print(MemoryAddress(of: y)) // <strong class="na iu">0x00007fb0254100b0</strong></span></pre><p id="1568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，有了写入时拷贝，我们可以两全其美。我们可以放心，同一内存位置的其他变量不会受到影响，并且通过只在必要时执行复制操作，我们在效率方面节省了很多。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2993" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">写入时拷贝的实际应用</h1><p id="8144" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在是时候动手创建我们自己的写时复制实现了。</p><p id="b389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写入时复制内置于Swift标准库的所有集合中，但如果您想要构建自己的具有变异功能并保留值语义的结构，则必须自己实现。这就是我们现在要做的！</p><p id="2092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种幼稚的方法是每次我们改变我们的价值观时都复制它。它确实可以实现价值语义，但是成本太高了。</p><p id="bec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们在一个<code class="fe nk nl nm na b">for</code>循环中改变这个值，而这个值实际上没有与任何东西共享它的内存位置，我们将会得到一堆不必要的副本。</p><p id="141a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功复制写入的关键魔法叫做<code class="fe nk nl nm na b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/2430721-isknownuniquelyreferenced" rel="noopener ugc nofollow" target="_blank">isKnownUniquelyReferenced(_:)</a></code>。</p><p id="a9e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传入一个类的实例，函数返回一个布尔值，表明该类是否只有一个强引用。对于<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" rel="noopener ugc nofollow" target="_blank"> Objective-C </a>类，它也返回false，所以应该小心。</p><p id="66c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们创建一个<code class="fe nk nl nm na b">Person</code>类，它将存储一个有名字的人。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c31d" class="ne md it na b gy nf ng l nh ni">final class Person {<br/>    var name: String</span><span id="a784" class="ne md it na b gy np ng l nh ni">    init(name: String) {<br/>        self.name = name<br/>    }<br/>}</span></pre><p id="7ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nk nl nm na b">Person</code>类有一个名为<code class="fe nk nl nm na b">name</code>的属性，它是我们创建并初始化的。</p><p id="832d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把这个<code class="fe nk nl nm na b">Person</code>类包装成一个<code class="fe nk nl nm na b">struct</code>，并赋予它写时复制的行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8c72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前为止一切正常。我们用一个包含person对象的新变量创建结构，并用一个名称值初始化它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">name属性的getter将简单地返回名称，在这种情况下，我们不必对它做任何复杂的事情。</p><p id="6066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神奇发生在我们的二传手身上。我们先用我们的咒语<code class="fe nk nl nm na b">isKnownUniquelyReferenced</code> <em class="nj"> </em>来判断是否有其他对象指向同一个内存位置。</p><p id="5826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有，我们分配一个新的对象给person。我们还打印了一条简单的消息，这对测试我们的代码很有帮助。</p><p id="d1ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果只有一个对我们对象的强引用，这意味着没有它的其他副本，所以我们可以安全地改变它。</p><p id="2034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。我们已经用几行代码实现了写时复制的工作实现。</p><p id="00dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个简单的例子来测试我们的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e97e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nk nl nm na b">for</code>循环运行四次，每次都修改<code class="fe nk nl nm na b">person1</code>。然而，我们的print语句只在第一次变异时打印一次。</p><p id="ec47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此之后，内存位置发生了变化，所以<code class="fe nk nl nm na b">isKnownUniquelyReferenced</code> <em class="nj"> </em>返回<em class="nj"> </em> <code class="fe nk nl nm na b">true</code>，所以我们可以简单地改变值而无需复制。</p><p id="746c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是该示例的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0adf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0f59" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们研究了什么是写时复制，它为什么有用，以及它是如何实现的。</p><p id="daf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写入时复制通过消除不必要的副本，提高了值类型的使用效率。它的知识有望对您的代码有所帮助。如果您发现自己在构建自己的结构，您应该始终注意该结构的复制行为。</p><p id="1824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你看了我的文章，希望你玩得开心。如果你有任何建议、想法或问题，请在下面的评论中留下。</p></div></div>    
</body>
</html>