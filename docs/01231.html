<html>
<head>
<title>Cleaner TypeScript With the Non-Null Assertion Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有非空断言运算符的更清晰的类型脚本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cleaner-typescript-with-the-non-null-assertion-operator-300789388376?source=collection_archive---------1-----------------------#2019-08-25">https://betterprogramming.pub/cleaner-typescript-with-the-non-null-assertion-operator-300789388376?source=collection_archive---------1-----------------------#2019-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7a39b756010fc8a182098a1ccd631888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPnsbYsfRrcPaDtsMX3ARQ.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片由<a class="ae kf" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank">杰洛特</a>在<a class="ae kf" href="https://www.needpix.com/" rel="noopener ugc nofollow" target="_blank"> Needpix </a>上拍摄</p></figure><p id="3e58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近，我了解了一个有用的类型脚本操作符:<a class="ae kf" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#non-null-assertion-operator" rel="noopener ugc nofollow" target="_blank">非空断言操作符</a>。它否定变量中的空类型和未定义类型。</p><p id="8656" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将解释如何以及何时使用这个操作符，并给出一些例子来说明它可以在什么地方帮助你。</p><p id="f83f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TL；DR:在变量后添加感叹号会忽略未定义或空类型。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="3e5d" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">如何使用非空断言运算符</h1><p id="9fed" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">非空断言操作符接受一个有类型的变量，并从中删除未定义的和空的类型。</p><p id="1ec6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用操作符就像添加一个感叹号一样简单。</p><ol class=""><li id="7104" class="mu mv it ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated">忽略变量的<code class="fe nd ne nf ng b">undefined | null</code>类型:</li></ol><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="52b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.执行函数时忽略<code class="fe nd ne nf ng b">undefined</code>类型:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="1123" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.当操作符的断言在运行时失败时，代码将充当常规的JavaScript代码。这可能会导致意外的行为。操作员不安全使用的例子:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="3c4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意:该操作符只有在<code class="fe nd ne nf ng b"><a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">strictNullChecks</a></code> <a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">标志</a>开启时才会生效。当标志关闭时，编译器不检查<code class="fe nd ne nf ng b">undefined</code>和<code class="fe nd ne nf ng b">null</code>类型赋值。</p><p id="6526" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我知道你在想什么…</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="ed86" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">我为什么要这么做？</h1><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/8ed3c285d57780d218962136eefb5f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*veGKkwAOfvRxg11P"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">持怀疑态度的吉娃娃由<a class="ae kf" href="https://www.flickr.com/photos/yiie/4865201576" rel="noopener ugc nofollow" target="_blank">陈熠</a>在<a class="ae kf" href="https://www.flickr.com/photos/yiie/4865201576" rel="noopener ugc nofollow" target="_blank"> Flickr </a>上</p></figure><p id="cc60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看非空断言操作符可以帮助解决的一些实际情况:</p><h2 id="1db6" class="ni ls it bd lt nj nk dn lx nl nm dp mb kr nn no mf kv np nq mj kz nr ns mn nt bi translated">带有React引用的事件处理程序</h2><p id="6158" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated"><a class="ae kf" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> React refs </a>用于访问一个元素的当前HTML节点。使用refs时，当前值可能为null(在被引用的元素被卸载的情况下)。</p><p id="5b49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在许多情况下，我们可以确定当前元件已安装，因此<code class="fe nd ne nf ng b">null</code>类型无关紧要。</p><p id="78e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的示例中，当单击按钮时，输入元素被滚动到视图中:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="2f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们知道当<code class="fe nd ne nf ng b">goToInput</code>被执行时，输入元素被挂载。我们可以有把握地假设<code class="fe nd ne nf ng b">ref.current</code>不为空:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="8e51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不使用断言操作符也可以解决编译错误。我们可以用<code class="fe nd ne nf ng b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_AND" rel="noopener ugc nofollow" target="_blank">Logical AND</a></code>:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="166f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这有点冗长。</p><p id="8ebd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用于链接的可选属性时，这变得特别麻烦。请看这个极端的例子:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><h2 id="5e49" class="ni ls it bd lt nj nk dn lx nl nm dp mb kr nn no mf kv np nq mj kz nr ns mn nt bi translated">使用React进行正确注射测试</h2><p id="5afa" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">下面的例子包含了一个用于prop测试的通用模式。我们有两个组成部分。</p><p id="aef8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个是可重用组件，可以是第三方库组件。它接收一个回调并在输入值改变时调用它。回调接收一个表单事件作为参数。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="38b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个组件叫做<code class="fe nd ne nf ng b">SpecificField</code>，它包含了<code class="fe nd ne nf ng b">SpecificInput</code>。<code class="fe nd ne nf ng b">SpecificField</code>知道如何提取当前值并将其传递给回调函数:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="15f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们想测试一下<code class="fe nd ne nf ng b">SpecificField</code>是否正确地调用了<code class="fe nd ne nf ng b">onChange</code>回调。<br/>这意味着<code class="fe nd ne nf ng b">SpecificField</code>得到一个<code class="fe nd ne nf ng b">onFieldChanged</code>回调，该回调打开事件值:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="9182" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe nd ne nf ng b">onFieldChanged</code>属性是可选的并且可能是未定义的，所以会出现编译错误。</p><p id="46f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们知道<code class="fe nd ne nf ng b">injectedCallback</code>是在错误发生的那一行定义的——我们已经测试过了。</p><p id="64ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是非空断言操作符可以提供帮助的地方:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="a9ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为比较，不使用运算符的一个可能的解决方案是使用if-else语句:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="3be2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这要冗长得多。</p><p id="5158" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这两个选项中，我更喜欢使用非空断言操作符。它更短，更简洁，样板文件更少。</p><h1 id="00d6" class="lr ls it bd lt lu nu lw lx ly nv ma mb mc nw me mf mg nx mi mj mk ny mm mn mo bi translated">编辑:可选链接呢？</h1><p id="5fad" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">有时我会被问到Null断言操作符和Javascript的可选链接之间的区别。<br/>虽然可选链接是一个非常有用的工具，但是它的用法和目的有点不同。考虑使用<code class="fe nd ne nf ng b">Array.find</code>函数的情况，其中<strong class="ki iu">知道</strong>将找到一个项目。让我们举一个过于简单的例子:</p><pre class="le lf lg lh gt nz ng oa ob aw oc bi"><span id="fa74" class="ni ls it ng b gy od oe l of og">const arr = [{value: 1}, {value: 2}];</span><span id="b55e" class="ni ls it ng b gy oh oe l of og">const item = arr.find(el =&gt; el.value === 2);</span><span id="aff4" class="ni ls it ng b gy oh oe l of og">const result = item.value + 1; //TS error, since item is (allegedly) possibly undefined</span></pre><p id="a9d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用可选的链接，将引发相同的错误— <code class="fe nd ne nf ng b">item?.value</code>仍然可能是<code class="fe nd ne nf ng b">undefined</code>，并且将发生编译错误。但是，如果您使用空断言操作符，错误将被否定。你可以<a class="ae kf" href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhgJwTAvDA2gbwG5wDYCuApgFwwCMAvgDQw77FkBMlAugNwBQoksAllCIBbVPCQA6AGZ8wAEwAURPKgB8MJeNyEiqFGiYBKLj2gwERCATyw0A4ZoY6A1BXYwA9O4AqAZXVIQBFoIGWAdOxE+CBh5fDwiAHMiWTwATwMYAAcQCBCAIzSYAjkiaTBkzm5wU3NLawB1AQALAHlMqD5wfFEIgH4HbRgXcjdPHw68ZTgwfwRAgEIYPoHiGCXo6D5JrJz8wuLZUpkKqt4zCysoRqhWzKIEOChAnsEheZXnVw93AEEm2hujwA5NEbjpwER5pwgA" rel="noopener ugc nofollow" target="_blank">在这里</a>看到完整的例子。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="ab44" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="95be" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">非空断言操作符是一个方便的小工具。使用时，切记小心轻放。误用会导致意外行为。</p><p id="4791" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，好处是很多的:它减少了在运行时无法发生的某些场景中的认知负荷。此外，与其他替代方案相比，它使您的代码不那么冗长。另外，它会让你觉得你在对编译器大喊大叫，这总是很有趣。</p><p id="ced2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接线员已经帮我几次了。我希望你会和我一样觉得它很有用。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><p id="2d28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">🕵️‍♂️ <em class="oi"> Psst… </em>如果你喜欢这个<em class="oi">，</em>在Twitter上关注我(<a class="ae kf" href="https://twitter.com/omril321" rel="noopener ugc nofollow" target="_blank">@ omril 321</a>)——我定期在Twitter上发布我学到的很酷的东西。</p></div></div>    
</body>
</html>