<html>
<head>
<title>Improving Performance With SQL Aggregate Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL聚合函数提高性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improving-performance-with-sql-aggregate-functions-e1e126464e93?source=collection_archive---------17-----------------------#2022-01-05">https://betterprogramming.pub/improving-performance-with-sql-aggregate-functions-e1e126464e93?source=collection_archive---------17-----------------------#2022-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提升应用程序的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/47b648aa73bedf503acc2a65716e0fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydJxqdHFXMpKKKxtSC21Ow.jpeg"/></div></div></figure><p id="4c80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，您将了解SQL聚合函数是如何以一种简单的方式显著提高应用程序性能的。主要是，您将看到他们如何在一个基于数据驱动的应用程序的真实世界场景中改变游戏规则，该应用程序是为体育行业的初创公司开发的。</p><p id="564c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们更深入地研究这个场景，了解为什么在数据科学中不能忽略SQL聚合函数。</p><h1 id="c513" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">场景</strong></h1><p id="6ccb" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我最近开发的应用程序旨在通过网络提供体育界的高级数据探索功能。特别是，它需要允许探索原始数据和聚合数据。由于数据库涉及数万亿字节的异构和非结构化数据，挑战主要在后端和数据库端。现在，让我们深入这个场景。</p><h2 id="67d2" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">技术、服务器规格和架构</h2><p id="b074" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们在Kotlin用<a class="ae mz" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a> <a class="ae mz" href="https://spring.io/blog/2021/07/22/spring-boot-2-5-3-is-now-available" rel="noopener ugc nofollow" target="_blank"> 2.5.3 </a>框架和<a class="ae mz" href="https://hibernate.org/" rel="noopener ugc nofollow" target="_blank">Hibernate</a>T8】5 . 4 . 32 . finalORM(<a class="ae mz" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">对象关系映射</a>)开发了后端。我们通过由<a class="ae mz" href="http://dokku.viewdocs.io/dokku/" rel="noopener ugc nofollow" target="_blank"> Dokku </a>管理的<a class="ae mz" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器将其部署在8GB 4 CPU <a class="ae mz" href="https://it.wikipedia.org/wiki/Virtual_private_server" rel="noopener ugc nofollow" target="_blank"> VPS </a>上。初始堆大小设置为2GB，限制为7GB，而我们将剩余的GB内存分配给基于Redis的缓存系统。我们构建web应用程序时考虑到了性能。具体来说，它基于这里<a class="ae mz" href="https://medium.com/swlh/designing-a-multi-layered-architecture-for-building-restful-web-services-with-spring-boot-and-a12ef85b77c9" rel="noopener">描述的</a>多层Spring Boot架构，并涉及多线程处理。</p><h2 id="0d7b" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">数据库结构</h2><p id="df52" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们将数据库实现为运行在8GB 2 CPU VPS上的MySQL服务器。我们在同一个服务器群中托管后端应用程序和数据库，但是它们不共享相同的VPS。由于体育数据简单但高度异构，该数据库的结构<a class="ae mz" href="https://arctype.com/blog/2nf-3nf-normalization-example/" rel="noopener ugc nofollow" target="_blank">避免重复</a>并鼓励标准化。这种结构就是我们选择关系数据库的原因。按照现在的情况，这个数据库涉及数百个表格，由于一个<a class="ae mz" href="https://en.wikipedia.org/wiki/Non-disclosure_agreement" rel="noopener ugc nofollow" target="_blank"> NDA </a>，我不能在这里全部展示。</p><p id="3ad8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，问题最多的表或多或少都有相同的结构。因此，只分析一个表就足够了。具体来说，PositionalData表如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5146" class="mn lr it nb b gy nf ng l nh ni">CREATE TABLE `PositionalData` (<br/>	`id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,<br/>	`area1` double DEFAULT NULL,<br/>	`area2` double DEFAULT NULL,<br/>	`area3` double DEFAULT NULL,<br/>	`area4` double DEFAULT NULL,<br/>	`area5` double DEFAULT NULL,<br/>...<br/>	`area140` double DEFAULT NULL,<br/>	`area141` double DEFAULT NULL,<br/>	`area142` double DEFAULT NULL,<br/>	`area143` double DEFAULT NULL,<br/>	`area144` double DEFAULT NULL,<br/>	`value` double DEFAULT NULL,<br/>	`parameterId` int(11) NOT NULL,<br/>	`gameId` int(11) NOT NULL,<br/>	`createdAt` datetime DEFAULT CURRENT_TIMESTAMP,<br/>	`createdBy` int(11) DEFAULT NULL,<br/>	`updatedAt` datetime DEFAULT CURRENT_TIMESTAMP,<br/>	`updatedBy` int(11) DEFAULT NULL,<br/>	`deletedAt` datetime DEFAULT NULL,<br/>	`deletedBy` int(11) DEFAULT NULL,<br/>	`active` tinyint(1) DEFAULT '1',<br/>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span></pre><p id="3b07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，它涉及100多个列，并且有四个以上的外部id。平均而言，每个表至少包含1500万行。</p><h2 id="a56d" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">性能问题</h2><p id="8cb4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">前端应用程序的一个关键功能是让用户分析来自一个或多个赛季的所有选定比赛的数百个不同运动参数(例如传球、投球、盖帽)的聚合值。我们开发了一个后端API来对前面提到的表执行查询以检索数据。这样的查询只不过是一个从10k到20k行返回的简单选择。然后，这个数据用多线程进程聚合，存储在<a class="ae mz" href="https://redis.io/topics/lru-cache" rel="noopener ugc nofollow" target="_blank"> Redis缓存</a>中，最后在JSON中序列化，返回给前端应用。从API收到命中的第一个时刻(因此，在Redis缓存中提供结果之前)到完成，用户必须等待两到四秒钟。</p><p id="0ffe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种拖延是不可接受的。</p><h1 id="7803" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">钻研性能问题</strong></h1><p id="c540" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在让我们来看看刚才介绍的方法有哪些缺点。</p><h2 id="a886" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">ORM数据转换瓶颈</h2><p id="e4d0" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">大多数高级ORM抽象了它们如何在数据库级别表示数据。换句话说，ORM执行查询，从数据库中检索所需的数据，并负责将其转换成应用程序级别的表示。这个数据转换过程发生在幕后，但它无疑代表了一种开销。尽管从性能的角度来看，这个过程通常可以忽略不计，但它很快就会成为数千行的瓶颈。</p><p id="7886" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用OO ( <a class="ae mz" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象</a>)语言时，这种减速尤其可能。此外，创建新的类实例需要时间和资源。限制对象大小和堆使用的一种方法可能是只选择严格必要的一组列。这种方法会使每个对象变得更轻，即使对象创建过程是主要的开销。所以执行这个转换过程所花费的时间不会有很大的变化。</p><h2 id="ed49" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">循环需要时间</h2><p id="06e2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">对包含数千个元素的对象数组执行简单的操作，如求和或求平均值，并不是没有性能的。尽管这比不上ORM转换数据所花费的时间，但它确实代表了额外的开销。幸运的是，Java支持许多线程安全集合并发执行操作。另一方面，打开和管理线程是复杂且耗时的任务。</p><p id="0370" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看几个SQL聚合函数是如何帮助我解决性能问题的。</p><h2 id="478e" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">什么是SQL聚合函数？</h2><p id="a231" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">SQL聚合函数允许您计算几行并获得一个结果值。尽管每种SQL语言都有自己的聚合函数，但最常见的有:</p><ul class=""><li id="5e04" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe ns nt nu nb b">COUNT()</code>:返回所选行数的计数</li><li id="f5d3" class="nj nk it kw b kx nv la nw ld nx lh ny ll nz lp no np nq nr bi translated"><code class="fe ns nt nu nb b">MIN()</code>:提取最小值</li><li id="ae33" class="nj nk it kw b kx nv la nw ld nx lh ny ll nz lp no np nq nr bi translated"><code class="fe ns nt nu nb b">MAX()</code>:提取最大值</li><li id="0760" class="nj nk it kw b kx nv la nw ld nx lh ny ll nz lp no np nq nr bi translated"><code class="fe ns nt nu nb b">SUM()</code>:执行求和运算</li><li id="56d9" class="nj nk it kw b kx nv la nw ld nx lh ny ll nz lp no np nq nr bi translated"><code class="fe ns nt nu nb b">AVG()</code>:执行平均运算</li></ul><p id="8667" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当与GROUP BY语句结合使用时，它们代表了一种有效且有用的工具。有了它，您可以首先对所需的数据进行分组，然后利用它们进行聚合。如果你想深入研究MySQL聚合函数，你可以在这里找到所有支持的<a class="ae mz" href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html" rel="noopener ugc nofollow" target="_blank">。我也推荐看看</a><a class="ae mz" href="https://learnsql.com/blog/sql-aggregate-functions/" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae mz" href="https://www.sqlshack.com/learn-sql-aggregate-functions/" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><h1 id="1437" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">用查询替换应用程序级操作</h1><p id="f596" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">虽然SQL聚合函数看起来很有前途，但在看到它们发挥作用之前，我不知道它们是否会有所不同。具体来说，应用程序级操作生成了一个数据结构，该数据结构包含value列上的平均值和每个<code class="fe ns nt nu nb b">areaX</code>(X从1到144)列上针对所选游戏选择的每个参数的总和。您可以在下面的查询中轻松地表示这一点:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="95bc" class="mn lr it nb b gy nf ng l nh ni">SELECT SUM(`area1`) as `area1`,  <br/>	SUM(`area2`) as `area2`, <br/>	SUM(`area3`) as `area3`,<br/>...<br/>	SUM(`area142`) as `area142`, <br/>	SUM(`area143`) as `area143`, <br/>	SUM(`area144`) as `area144`,<br/>	AVG(`total`) as `total`, `parameterId`<br/>FROM `PositionalData`<br/>WHERE `parameterId` IN (:parameterIds) AND `gameId` IN (:gameIds)<br/>GROUP BY `parameterId`</span></pre><p id="328d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，该查询利用SQL聚合函数在数据库级别返回聚合数据。同时在<code class="fe ns nt nu nb b">gameId</code>和<code class="fe ns nt nu nb b">parameterId</code>上使用IN语句过滤所需的数据，并根据相同的<code class="fe ns nt nu nb b">parameterId</code>对其进行分组。换句话说，首先根据赛季的选定比赛和需要分析的参数过滤数据。然后，结果信息按参数分组，并由SQL聚合函数聚合。</p><h2 id="78ad" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">定义正确的索引</h2><p id="3f5c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">由于该查询涉及GROUP BY、IN和SQL聚合语句，因此可能会比较慢。这种潜在的缓慢正是定义适当的索引如此重要的原因。具体而言，最关键和最有效的绩效指标如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="800c" class="mn lr it nb b gy nf ng l nh ni">ALTER TABLE `PositionalData` ADD INDEX `PositionalData_parameterId_gameId` (`parameterId`, `gameId`) USING BTREE;</span></pre><p id="324f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么你应该总是使用集合函数吗？这种方法的一些优点和缺点。</p><p id="1ff6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">赞成者</strong></p><ul class=""><li id="110b" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">数据库级聚合比在大型数组上循环时在应用程序级执行相同的聚合逻辑要快得多。</li><li id="f5fc" class="nj nk it kw b kx nv la nw ld nx lh ny ll nz lp no np nq nr bi translated">将涉及SQL聚合函数的查询与GROUP BY语句一起使用，可以大大减少返回的行数。具体来说，这让我从大约10k行增加到与所分析的参数数量相等的行数。因此，这使得ORM执行的数据转换过程与时间无关，从而避免了成为瓶颈。</li><li id="21a1" class="nj nk it kw b kx nv la nw ld nx lh ny ll nz lp no np nq nr bi translated">当运行相同的请求时，数据库级别的聚合允许您利用数据库缓存的性能优势。这种设置可以降低应用程序级缓存的重要性，从而简化架构。</li></ul><p id="912b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">缺点</strong></p><ul class=""><li id="424d" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">SQL聚合函数在选择时间运行。当处理强类型编程语言时，ORM需要知道结果的类型。并不是所有的ORM都允许您轻松定义，有时甚至会将SQL聚合函数限制在本地查询中。这种现实意味着失去ORM引入的抽象优势，并阻碍了它们的使用。</li><li id="2d80" class="nj nk it kw b kx nv la nw ld nx lh ny ll nz lp no np nq nr bi translated">涉及SQL聚合函数的提取所需数据的查询总是比涉及简单WHERE子句的SELECT慢。然而，执行时间应该保持在十分之一秒的数量级，并且无论如何，要比在应用程序级别执行相同的操作少得多。</li><li id="b14a" class="nj nk it kw b kx nv la nw ld nx lh ny ll nz lp no np nq nr bi translated">可用的SQL聚合运算通常被限制在一打以内，其中只有5或6个是数学运算。</li></ul><h1 id="71d0" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">性能对比</strong></h1><p id="bf45" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们比较一下调用相同的API(涉及数据聚合，没有缓存，参数相同)时的响应时间。</p><ul class=""><li id="567b" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">在应用程序级别执行聚合时的响应时间:~ 2–4秒</li><li id="73b6" class="nj nk it kw b kx nv la nw ld nx lh ny ll nz lp no np nq nr bi translated">在数据库级别执行聚合时的响应时间:~ 800毫秒</li></ul><h1 id="5d83" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">关于SQL聚合函数的最终想法</strong></h1><p id="95b2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在处理数据科学时，SQL聚合函数无疑是将性能提升到一个新水平的绝佳工具。使用它们既简单又有效，尽管并不是所有的ORM都完全或天生支持它们。无论哪种方式，知道如何利用它们可能对提高性能至关重要，我写这篇文章就是为了通过真实的案例研究来解释这一点！</p></div></div>    
</body>
</html>