<html>
<head>
<title>An Advanced Guide to GraphQL With Java, MySQL, and JPA Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java、MySQL和JPA实现的GraphQL高级指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-advanced-guide-to-graphql-with-java-mysql-and-jpa-implementation-83f791a1f676?source=collection_archive---------1-----------------------#2021-05-03">https://betterprogramming.pub/an-advanced-guide-to-graphql-with-java-mysql-and-jpa-implementation-83f791a1f676?source=collection_archive---------1-----------------------#2021-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">GraphQL是脸书在2012年开发的，目的是克服REST APIs的缺点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35677ff379c17ad7ea8e44eb1d723ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yMDW6lFmSN0xu02g"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迪伦·麦克劳德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="484e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL是一种从服务器检索数据的查询语言。在某种程度上，它是REST、SOAP或gRPC的替代品。</p><p id="bd32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL是一种新的API标准，为构建数据驱动的应用程序提供了一种革命性的方法。该项目最初是由脸书创建的，当时他们正在将其移动应用从HTML5转移到原生移动应用。</p><p id="17d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL遵循与REST APIs相同的约束集，但是它使用一个接口将数据组织成一个图。对象由节点表示(使用GraphQL模式定义)，节点之间的关系由图中的边表示。每个对象都由一个访问服务器数据的解析器支持。</p><p id="5e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论以下主题:</p><ol class=""><li id="2fea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">什么是GraphQL及其用例？</li><li id="117d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">REST和GraphQL的主要区别。REST API创建的GraphQL解决了哪些类型的问题？</li><li id="017e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为什么GraphQL日渐流行？</li><li id="fbe9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">博客服务器使用spring boot、JPA和MySQL数据库的GraphQL实现</li><li id="d71d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">与资源文件共享代码库</li></ol><p id="340a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要理解本文，您可能需要预先了解Spring boot、JPA和内存数据库。为此，你可以试试<a class="ae ky" href="https://mesukcse08.medium.com/spring-data-jpa-a-to-z-6c957ed17a66" rel="noopener">这篇文章</a>。</p><h1 id="7209" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">实施细节</h1><p id="e1da" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">今天我们将实现一个典型的博客服务器。其ER图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/e6649aa81a42b979666e18af1420be0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2xC2cyLIca5svXw2uumUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源—作者</p></figure><p id="8954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们有一个用户表和一个帖子表:</p><ul class=""><li id="dc54" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">用户表包含与用户相关的数据，如全名、电子邮件、性别、出生日期和地址</li><li id="0169" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">帖子表包含与帖子相关的数据，如标题、描述、发布日期和用户id。</li><li id="bb32" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">这里，post表中的<code class="fe ni nj nk nl b">user_id</code>是来自用户表的外键</li></ul><p id="1e3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">我们将向您展示如何实现下面的测试用例:</strong></p><ul class=""><li id="521c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">使用GraphQL创建用户</li><li id="50a3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">使用变量输出参数查看用户列表。使用相同的API查看用户和文章</li><li id="44b8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">基于用户创建帖子</li><li id="5a40" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">查看带有可变输出参数的帖子。使用相同的API查看受尊敬的作者的帖子</li><li id="3c37" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">基于帖子id删除用户帖子</li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="5d74" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">GraphQL是什么？</h2><p id="219c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">GraphQL是脸书在2012年内部开发的，2015年公开发布。2018年11月7日，GraphQL项目从脸书转移到新成立的GraphQL基金会，由非营利的Linux基金会托管。自2012年以来，GraphQL的崛起准确地遵循了GraphQL的创始人Lee Byron设定的采用时间表。</p><ul class=""><li id="b135" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">GraphQL是一种用于应用编程接口(API)的查询语言和服务器端运行时，它优先向客户端提供它们所请求的数据，而不是更多。</li><li id="9482" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">GraphQL不依赖于任何特定的数据库或存储引擎，而是由现有的代码和数据支持。</li><li id="7762" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">GraphQL旨在使API快速、灵活且对开发人员友好。它甚至可以部署在名为<a class="ae ky" href="https://github.com/graphql/graphiql" rel="noopener ugc nofollow" target="_blank"> GraphiQL </a>的集成开发环境(IDE)中。作为REST的替代方案，GraphQL允许开发人员在一个API调用中构造从多个数据源提取数据的请求。</li><li id="bee2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">GraphQL为您的API中的数据提供了一个完整且可理解的描述，让客户能够准确地要求他们需要的东西，仅此而已。这使得随着时间的推移开发API变得更加容易，并支持强大的开发工具。</li><li id="ac4b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">GraphQL查询不仅可以访问一个资源的属性，还可以平滑地跟踪它们之间的引用。</li><li id="f723" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">典型的REST APIs需要从多个URL加载，而GraphQL APIs可以在一个请求中获得应用程序需要的所有数据。使用GraphQL的应用程序即使在移动网络连接缓慢的情况下也能很快运行。</li><li id="68aa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">此外，GraphQL为API维护人员提供了在不影响现有查询的情况下添加或删除字段的灵活性。开发人员可以用他们喜欢的任何方法构建API，GraphQL规范将确保它们以对客户端可预测的方式运行。</li></ul><h1 id="5fce" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">GraphQL解决了哪些问题</h1><p id="e639" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当脸书开发人员在2012年构建他们的移动应用程序时，他们的REST API遇到了一些问题，这促使他们创建了GraphQL。在软件开发中，我们也会遇到相同类型的问题。</p><p id="8c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL的动机就是为了解决这些问题，所以了解这些问题很重要。已知问题如下:</p><p id="d09c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">很多端点</strong></p><p id="da88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获取REST API数据，CRUD系统运行良好。对于每个资源，我们必须实现CRUD(创建、读取、更新和删除)端点。</p><p id="978a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在现实世界的应用程序中，我们最终会有很多资源的很多端点。很难记住或控制这些终点。对于像脸书或Twitter这样的大规模应用来说，维护这些端点是非常困难的。</p><p id="0562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个大问题可以用GraphQL解决。在GraphQL中，您可以使用单个端点来完成所有这些工作。你只需要一个类型或突变来控制你的资源。</p><p id="0c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据的上取或下取</strong></p><p id="c631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在REST API中，过度提取或提取不足是一个性能问题。基本的REST APIs总是接受并返回固定的数据结构。我们应该获取我们需要的数据。使用GraphQL，我们可以最小化数据读取并提高REST API的性能，尤其是在网络连接速度较慢的情况下。</p><p id="9e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个信息提取不足的问题。为了获取关系数据，我们需要在服务器中有太多的请求，或者有不必要数据的大对象。这不仅会损害我们的应用程序性能，还会占用空间。</p><p id="fb1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，GraphQL可以帮助解决问题。GraphQL允许客户端指定他们需要的确切数据。因此，我们不会有数据提取不足和提取过多的问题。</p><p id="447c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">前端与后端紧密耦合</strong></p><p id="c421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在应用程序中开发一个新页面。当我们分析我们需要什么数据时，我们发现我们必须调用几个REST API端点来获取所有数据。</p><p id="d9a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，应用程序开发人员的团队和后端开发人员的团队必须耦合。他们应该与准备文档同步，并且知道端点、请求和响应。</p><p id="8fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当客户需要来自同一特性的额外数据时，问题就出现了。当这种情况发生时，两个团队必须坐在一起，分析现有API中的依赖关系，并创建新的文档。他们要么更新相同的API，要么提供新的API。这是最大的问题之一。</p><p id="61f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了GraphQL，这个问题就消失了。客户端可以在任何页面上获得他们需要的数据，而无需在后端进行任何更改。客户端唯一需要知道的是GraphQL API的模式。GraphQL模式定义了API提供的数据，客户端可以根据需要使用这些数据。</p><p id="b3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">API版本化的困难</strong></p><p id="da99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，REST API最大的问题之一就是版本控制。出于不同的原因，在添加新功能时，我们可能需要多次更改后端API。为了保持不可破解的前端和API用户，我们需要在REST API中进行版本控制。</p><p id="b64d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在GraphQL中不需要它，因为您是通过添加新类型或删除旧类型来获取API的。由于您正在获取数据，并且知道您需要多少数据，因此在大多数情况下它是不可破解的。<br/>此外，只有一个端点，因此您不需要如下所示的端点:</p><pre class="kj kk kl km gt of nl og oh aw oi bi"><span id="1726" class="nt mk it nl b gy oj ok l ol om">https://api.example.com/v1/users/12312<br/>https://api.example.com/v2/users/12312</span></pre><p id="701c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">文档问题</strong></p><p id="b0bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">REST不强迫你创建关于API的文档。有像Swagger这样的工具可以帮助开发人员创建REST APIs文档。然而，开发人员需要额外的工作来创建和维护它。因此，有很多REST APIs没有文档或者文档已经过时。</p><p id="e230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，GraphQL使用强类型系统，所以根据定义<strong class="lb iu">它是一种文档化语言</strong>。只有通过创建我们的GraphQL模式，我们才能生成我们的API文档。</p><p id="7069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">跟踪API使用情况</strong></p><p id="f3c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用REST，我们唯一可以跟踪客户端如何使用我们的API的是每个端点被调用的频率。</p><p id="ef03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用GraphQL，由于每个客户端都精确地指定了他们感兴趣的信息，我们可以了解哪些数据正在被使用，哪些没有被使用。此外，我们可以测量每个请求属性的性能，这提供了关于API性能的重要见解。</p><h1 id="3f56" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">GraphQL如何与Spring boot连线？</h1><p id="e830" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">下图显示了GraphQL如何与Spring boot连接:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/da5952be6d6c6fb73709e6b5c1ebf0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTWIXOf3NoiqY4Dk7Yh-iA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源—作者</p></figure><p id="ba6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在该图中，我们有一些组件，如下所示:</p><p id="d901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">图形模式文件:blog . Graph SQL</strong></p><p id="ff39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL最好的部分之一是它通过模式提供了API中可用数据的清晰定义。该模式描述了您可以查询的类型和字段，还包括这些类型之间的任何关系。</p><p id="9f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些文件需要用扩展名“保存。<strong class="lb iu"><em class="oo"/></strong>"并且可以出现在类路径上的任何地方。我们也可以根据需要拥有尽可能多的这些文件，因此我们可以根据需要将方案划分成模块。</p><p id="338f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模式文件将与客户端开发人员共享，他们将使用这个模式文件实现他们的客户端。</p><p id="8955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是GraphSQL实现的核心。它包含一个类列表、一个查询列表和一个变异列表。</p><p id="c1bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的graphsqls文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="58ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下部分来自此模式文件:</p><ul class=""><li id="85db" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">用户和发布块。这里，用户和帖子包含带有域/实体对象的映射。这里的字段名和类型必须相同。</li><li id="e8fd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">在查询块中，它包含查询列表。我们要实现的查询类型必须添加到这里。查询部分将与查询解析器类连接。在查询解析器类中，必须有一个具有相同名称和签名的方法</li><li id="6572" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">在变异块中，它包含带有请求参数的插入、更新、删除查询列表。该块将与变异解析器类连接。在变异解析器类中，必须有一个具有相同名称和签名的方法</li></ul><p id="f641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">查询和变异解析器</strong></p><p id="6fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与REST APIs相比，解析器类似于控制器。因此，业务逻辑不应该在解析器中实现，而应该在服务层中实现。</p><p id="feeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在resolver中，他们调用相关的服务层进行操作。在我们的系统中，我们有四个解析器:</p><ol class=""><li id="881a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用户查询和变异解析器</li><li id="ce06" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">后期查询和变异解析器</li></ol><p id="e310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">服务层</strong></p><ul class=""><li id="f3d6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">服务层处理应用程序逻辑</li><li id="55a1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">所有数据检查和访问验证都在这里完成</li><li id="08a9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">服务层调用存储库层与数据库层进行交互</li><li id="7e19" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">在我们的系统中，我们有两个服务——一个用于用户，一个用于post</li></ul><p id="106b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">储存库层</strong></p><ul class=""><li id="9b09" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">存储库层与数据库的交互</li><li id="e0ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">在我们的系统中，我们使用Java持久性API (JPA)来访问数据库</li></ul><h2 id="e261" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">GraphQL的Spring Boot实现</h2><p id="ba00" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">以下是build.gradle文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="62d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们为graphql添加了GraphQL和graph QL依赖项。</p><p id="a9d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还添加了MySQL和JPA依赖项。</p><p id="f42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实体类别如下所示:</p><p id="730c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">为用户实体类</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="100e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，</p><ul class=""><li id="fdcc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">id</code>是主键，这个键作为外键添加到Post表中。</li><li id="7924" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">所以，用户表与post表是一种一对一的关系，它的fetch类型是Eager</li></ul><p id="1bcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">岗位实体类</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="443a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，</p><ul class=""><li id="4de2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">id</code>是主键，自动增量。</li><li id="b2d3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">用户id是用户表中的外键。</li><li id="0a1e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">因此，post表与用户表是多对一的关系</li></ul><p id="6b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面给出了<strong class="lb iu">用户服务类别</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="d180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，</p><ul class=""><li id="affe" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">createUser</code>正在根据提供的数据创建用户。对于储蓄用户，调用<code class="fe ni nj nk nl b">User Repository</code>类</li><li id="4b72" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">findById</code>根据<code class="fe ni nj nk nl b">id</code>从表中查找用户</li><li id="b562" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">findAll</code>方法从数据库中返回所有用户列表。</li><li id="ec19" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">解析器类调用这个服务层</li></ul><p id="457a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">邮政服务</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="c5ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，</p><ul class=""><li id="ab19" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">createPost</code>方法获取用户和构建对象，然后使用post repository类保存数据</li><li id="f3c5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">findByPostId</code>方法根据帖子<code class="fe ni nj nk nl b">id</code>搜索帖子</li><li id="822a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">findByUserId</code>方法根据<code class="fe ni nj nk nl b">user-id</code>查找所有帖子</li><li id="afc0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">deletePostById</code>方法根据提供的帖子id删除帖子</li></ul><p id="ae5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">查询解析器</strong></p><p id="16dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我在同一个文件中显示了用户查询解析器和发布查询解析器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="131c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，</p><ul class=""><li id="abe3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">这两个类都实现了<code class="fe ni nj nk nl b">GraphQLQueryResolver</code>类。</li><li id="31e8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated"><code class="fe ni nj nk nl b">GraphQLQueryResolver</code>是一个标记接口，告诉底层库使用这个bean来解析查询，它会自动匹配<code class="fe ni nj nk nl b">userAll</code>、<code class="fe ni nj nk nl b">postAll</code>等。，模式方法。使其成为弹簧<code class="fe ni nj nk nl b">Service</code>(或<code class="fe ni nj nk nl b">Component</code>)也很重要。</li><li id="b1fb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">它们的方法必须以相同的名称和签名插入到模式文件查询块中</li><li id="68ac" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">从这个解析器类，它只是调用负责的服务类。</li></ul><p id="c523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">突变解析器类</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="a9ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，</p><ul class=""><li id="07ed" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">这两个类都实现了<code class="fe ni nj nk nl b">GraphQLMutationResolver</code>类。</li><li id="8832" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">如您所见，这也非常类似于我们的查询解析器。注意，实现了一个不同的标记接口，即<code class="fe ni nj nk nl b">GraphQLMutationResolver</code>接口。</li><li id="b1f2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">它们的方法必须以相同的名称和签名插入到模式文件变异块中</li><li id="4f34" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">从这个解析器类，它调用负责的服务类。</li></ul><h2 id="a599" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">测试应用程序</h2><p id="2b54" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们讨论了足够多的理论。现在是时候展示结果了。</p><p id="6f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用postman或GraphiQL工具来测试它。</p><p id="76c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从邮递员，你必须调用以下网址</p><blockquote class="or os ot"><p id="e597" class="kz la oo lb b lc ld ju le lf lg jx lh ou lj lk ll ov ln lo lp ow lr ls lt lu im bi translated"><a class="ae ky" href="http://localhost:8081/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/graph QL</a></p></blockquote><p id="1d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于图形，请在浏览器中输入以下URL</p><blockquote class="or os ot"><p id="a17d" class="kz la oo lb b lc ld ju le lf lg jx lh ou lj lk ll ov ln lo lp ow lr ls lt lu im bi translated"><a class="ae ky" href="http://localhost:8081/graphiql" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/graphi QL</a></p></blockquote><p id="9b99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建用户</strong></p><p id="6041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求和响应如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="386c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">邮递员图像如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/fdcb3ea2d4a62587445bc29ae386de77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXZUPeFm9tnwT2OjU7vpHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源—作者</p></figure><p id="108a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，</p><ul class=""><li id="55ae" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">我们使用带有所有必需参数的方法<code class="fe ni nj nk nl b">createUser</code>使用变异闭合器保存数据</li><li id="96b3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">还要求<code class="fe ni nj nk nl b">id</code>、<code class="fe ni nj nk nl b">fullName</code>和<code class="fe ni nj nk nl b">email</code>作为响应</li></ul><p id="1e93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">查看具有特定字段的所有用户</strong></p><p id="18d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求和响应如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="72d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">图形1</strong>请求屏幕如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/678befe863880544993b73bd80313a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PgguS7r2cBAbpPcL2n-Qdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源—作者</p></figure><p id="eb5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，</p><ul class=""><li id="46a9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">我们用用户的id、全名、电子邮件和性别字段调用查询块<code class="fe ni nj nk nl b">userAll</code>方法。</li><li id="1815" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">如果您在这个调用中需要更多的字段，只需添加那个字段名称；它会自动返回</li></ul><p id="6120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">通过ID获取用户</strong></p><p id="8755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求和响应如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="269c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，</p><ul class=""><li id="2bec" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">我们正在通过<code class="fe ni nj nk nl b">user-id = 9</code>获取用户详细信息，并获得用户的所有信息。</li><li id="24e3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">在这里，您可能会注意到URL没有改变。</li></ul><p id="e48d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建帖子</strong></p><p id="99e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求和响应如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="e35f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">得到所有帖子</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="e9d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里</p><ul class=""><li id="e169" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">我们正在获取所有帖子以及作者信息</li><li id="b53e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">此外，我们从客户端控制我们的响应字段</li></ul><p id="aec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">使用帖子id </strong>删除帖子</p><p id="7e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求和响应如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="3456" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">结论</h2><p id="6432" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">你可以从<a class="ae ky" href="https://github.com/mesuk/GraphQlSpringIntegration" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中查看源代码</p><p id="8ce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将数据库SQL脚本添加到资源文件夹中</p><h1 id="2b45" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">资源</h1><p id="f815" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">1.<a class="ae ky" href="https://developer.okta.com/blog/2020/01/31/java-graphql" rel="noopener ugc nofollow" target="_blank">https://developer.okta.com/blog/2020/01/31/java-graphql</a><br/>2。<a class="ae ky" href="https://piotrminkowski.com/2020/07/31/an-advanced-guide-to-graphql-with-spring-boot/" rel="noopener ugc nofollow" target="_blank">https://piotrminkowski . com/2020/07/31/an-advanced-guide-to-graph QL-with-spring-boot/</a><br/>3 .<a class="ae ky" href="https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d" rel="noopener">https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d</a>T8】4。<a class="ae ky" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener ugc nofollow" target="_blank">https://www . howtographql . com/basics/1-graph QL-is-the-better-rest/</a><br/>5 .<a class="ae ky" href="https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis#.YIp-NqnG-oU.twitter" rel="noopener ugc nofollow" target="_blank">https://www . rubrik . com/en/blog/technology/19/11/graphql-vs-rest-APIs #。YIp-NqnG-ou . Twitter</a>T14】6。<a class="ae ky" href="https://medium.com/@thisdotmedia/graphql-is-the-new-rest-part-1-6389c28f5026" rel="noopener">https://medium . com/@ this dot media/graph QL-is-the-new-rest-part-1-6389 c28f 5026</a><br/>7 .<a class="ae ky" href="https://www.redhat.com/en/topics/api/what-is-graphql" rel="noopener ugc nofollow" target="_blank">https://www.redhat.com/en/topics/api/what-is-graphql</a>T20】8。<a class="ae ky" href="https://dev.to/juliansci/graphql-what-is-it-and-what-does-it-solve-15p1" rel="noopener ugc nofollow" target="_blank">https://dev . to/Julian sci/graph QL-what-is-it-and-what-it-solve-15p 1</a></p><p id="165a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以尝试使用Java和网飞堆栈来实现微服务，使用我关于这些技术的文章。</p><p id="0f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。希望你喜欢这篇文章！</p></div></div>    
</body>
</html>