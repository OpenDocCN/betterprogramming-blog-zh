<html>
<head>
<title>3 Ways To Write Asynchronous Code in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript编写异步代码的3种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-ways-to-write-asynchronous-code-in-javascript-b8d17e60df06?source=collection_archive---------1-----------------------#2021-10-18">https://betterprogramming.pub/3-ways-to-write-asynchronous-code-in-javascript-b8d17e60df06?source=collection_archive---------1-----------------------#2021-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c05" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习JavaScript中的回调、承诺和异步/等待</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2083419d0578021031b27b4656739e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXtbJff8IFkJe6LtmGtp2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="http://www.arnoldcode.com" rel="noopener ugc nofollow" target="_blank">作者制作的图片</a>与❤</p></figure><p id="964f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么要用JavaScript？显然，为了使网站更加灵活。但是，有时，这种形式的灵活性不足以满足您的需求。</p><p id="d58d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，使用异步执行某些功能<em class="lv">的选项</em>是有意义的。您可能会因程序的给定代码执行而阻塞自己。幸运的是，这种语言提供了三种不同的实现方法。当然，你想了解它们以便专业地使用它们。</p><p id="22f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解如何正确使用它们；JavaScript中的函数是按照被调用的顺序激活的，而不是按照定义的顺序。</p><h1 id="6033" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">0.正常流程</h1><p id="4280" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">考虑以下常规执行顺序的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8b18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您执行JavaScript，控制台会打印出短语<code class="fe mv mw mx my b">Hello</code>和<code class="fe mv mw mx my b">… and a good night!</code>。</p><p id="6073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着功能<code class="fe mv mw mx my b">firstFunc()</code>首先被执行，然后是<code class="fe mv mw mx my b">secondFunc()</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ae86912c8f1b7ea95f338fb6cf83a3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*W5kPVMVoU4e5dFRqfBYvDw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">normalExecution.js的Console.log()语句</p></figure><blockquote class="na nb nc"><p id="232b" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">如果以相反的顺序调用这两个函数，单词hello将显示在浏览器中。</p></blockquote><p id="d4f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你在这里影响函数被调用的顺序。第一种方法是使用一个<em class="lv">回调</em>函数。</p><h1 id="7d28" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">1.复试</h1><p id="0720" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">通过使用回调，像砸锤子一样介入控制流。</p><p id="fc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回调是一个函数，另一个函数可以作为参数传递给它。它允许你用一个函数调用另一个函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/064886486f2e265f197521d3e7f7ca67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*eDfD-ty_pdll4aTHxyQR3A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">回调的原理</p></figure><p id="99a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的清单中，使用计算总和的函数示例(<code class="fe mv mw mx my b">calcFunc()</code>)完成了一次:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我做了什么？</p><ol class=""><li id="42ca" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">将计算的显示与计算本身分开。</li><li id="7ffa" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">实现了一个函数<code class="fe mv mw mx my b">displayFunc()</code>，它只输出一个值。</li><li id="ff0e" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">另一方面，实际工作是在函数<code class="fe mv mw mx my b">calcFunc()</code>中完成的。它接受计算所需的两个参数并执行加法。</li><li id="0487" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">此外，函数<code class="fe mv mw mx my b">calcFunc()</code>接受另一个参数，这具有特殊的意义。以便进一步处理。</li><li id="ce6a" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">作为最后一个参数，函数名<code class="fe mv mw mx my b">calcFunc()</code>被传递。</li></ol><p id="308a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦计算完成，就调用函数<code class="fe mv mw mx my b">displacFunc()</code>打印出计算结果。</p><blockquote class="na nb nc"><p id="b123" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">因此，回调非常适合用于异步编程。通常，回调函数与异步函数一起使用。</p></blockquote></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="2735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是超时后使用回调函数的另一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1d08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，函数名<code class="fe mv mw mx my b">myTimeOut</code>作为参数传递给<code class="fe mv mw mx my b">setTimeout</code>。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="6ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相应呼叫的变体:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mv mw mx my b">setTimeout</code>函数调用中调用了<code class="fe mv mw mx my b">randomFunction()</code>。</p><p id="d050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，匿名函数在<code class="fe mv mw mx my b">setTimeout</code>的函数调用中作为参数传递。因此两者都是异步的。</p><p id="f0d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前一个示例的主要区别在于，这里传递的不是函数名，而是一个完整的函数。如果这样做，就可以保存单独的函数声明和函数名的赋值。您在<code class="fe mv mw mx my b">setTimeout</code>中创建了一个匿名函数。</p><p id="d689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">这种方法只有在其他地方不需要该功能时才有意义。</em></p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="67b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以经常调用回调函数。</p><p id="10a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我演示一下如何在间隔的上下文中执行代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f05c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我将函数<code class="fe mv mw mx my b">cally()</code>作为参数传递给setInterval函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/91e32c6056d881ea21982ac89e9e9d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*SzvN68EUiRqSsPP-Rnbg-Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">cally.js中的Console.log()语句</p></figure><h1 id="4293" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">2.承诺</h1><p id="1123" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对未来的承诺。不像其他的承诺，用代码做的承诺是信守的，哈哈！</p><p id="0b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以读未来这个词。这只是承诺的同义词。在编程中，两者都指未知结果的占位符(代理)。</p><blockquote class="na nb nc"><p id="f794" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">通常，这种承诺指的是尚未完成处理的任务。</p></blockquote><p id="cee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在程序继续执行之前，复杂的计算必须首先被锁定。因此，承诺通常是异步函数调用的结果。与回调函数一样，当函数作为参数调用时，future作为参数传递。</p><p id="68e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是承诺的组成部分:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/30aa2e25f6cb6a5022b26e8757ebddec.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*Ko6ULabR1F0W1rVMOVhrGQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">承诺履行的原则</p></figure><p id="563a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它由两部分组成:</p><ol class=""><li id="d9e2" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">第一部分包含产生结果的代码。</li><li id="791f" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">第二部分根据结果决定如何继续处理。</li></ol><p id="e471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中Promise对象的基本结构如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时创建了Promise对象，处理任务的代码放在函数中。此外，成功或失败情况下将执行的函数被传递。</p><p id="66ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当承诺被执行时，第二部分得到它的实际决定。它根据承诺的结果决定处理如何进行(<code class="fe mv mw mx my b">success</code>或<code class="fe mv mw mx my b">error</code>)。</p><p id="07bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果promise返回<code class="fe mv mw mx my b">error</code>，错误处理函数将被调用。而不是下一个处理程序。看看<code class="fe mv mw mx my b">theUsualPromise.js</code>的评论。</p><p id="be2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我向你揭示一个实际的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="02ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码中，在开头创建了一个Promise promiseObj类型的新对象。然后它进入处理，在这个例子中包括将值<code class="fe mv mw mx my b">0</code>赋给变量<code class="fe mv mw mx my b">x</code>。</p><p id="881f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，检查代码执行。</p><p id="f0e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe mv mw mx my b">0</code>分配成功，则调用<code class="fe mv mw mx my b">resolve</code>函数。对于这个例子，情况总是如此。在承诺的<code class="fe mv mw mx my b">then</code>部分，函数被执行，它应该在成功的情况下被执行。</p><p id="47f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想要运行失败案例，您需要为<code class="fe mv mw mx my b">x</code>分配一个除<code class="fe mv mw mx my b">0</code>之外的值。</p><p id="e840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在为我们最后的新婚夫妇<code class="fe mv mw mx my b">async</code> &amp; <code class="fe mv mw mx my b">await</code>扔米。</p><h1 id="3ef0" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">3.异步和等待</h1><p id="5da1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">2017年，另一个有用的功能愉快地融入了ECMAScript标准的大家庭。关键词<code class="fe mv mw mx my b">async</code>和<code class="fe mv mw mx my b">await</code>。</p><blockquote class="na nb nc"><p id="9935" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">它就像一个承诺。一旦做出承诺，等待它解决或拒绝。在引擎盖下，这是一个承诺，但是语法更容易设置和理解。</p></blockquote><p id="6fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次使用这些命令使得异步编程变得非常容易。此示例旨在说明这两条指令的用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">功能<code class="fe mv mw mx my b">displayFunc()</code>已被插入。其特点是带有关键字<code class="fe mv mw mx my b">async</code>的标记。</p><p id="8464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用带有<code class="fe mv mw mx my b">async</code>的标记表示该函数将返回一个承诺对象。否则，函数的声明与上一个例子没有什么不同。</p><p id="f76b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">await</code>关键字用于函数的最后一行。许诺对象<code class="fe mv mw mx my b">promiseObj</code>用它做了标记。这确保了只有在前面的代码正确执行的情况下才显示内容。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="3cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://arnoldcode.medium.com/membership" rel="noopener"> <em class="lv">加入Medium </em> </a> <em class="lv">获取无穷无尽的web开发教程内容。</em></p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="2ec0" class="lw lx it bd ly lz od mb mc md oe mf mg jz of ka mi kc og kd mk kf oh kg mm mn bi translated">结论</h1><p id="3bc9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">既然您已经知道了JavaScript中的异步编程机制，那么相应应用程序的设计对您来说就不再是一个棘手的问题了。</p><p id="a24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方式可以非常灵活地开发网页和Web应用程序。</p><p id="5813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取26份备忘单，只研究你真正需要的东西，以获得你的第一份网络开发工作！ </p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/227a060a3bfa55f41fa795d5990e6032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nqyiu4c6K-mCxE9e.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> Arnold Code Academy 26网站开发者备忘单</a></p></figure></div></div>    
</body>
</html>