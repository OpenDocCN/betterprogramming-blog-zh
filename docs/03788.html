<html>
<head>
<title>How to Implement Migrations With the Room Persistence Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Room持久性库实现迁移</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-migrations-with-the-room-persistence-library-7f86602b28de?source=collection_archive---------11-----------------------#2020-03-04">https://betterprogramming.pub/how-to-implement-migrations-with-the-room-persistence-library-7f86602b28de?source=collection_archive---------11-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cd91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好的移动数据库迁移</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e0858cbfc2fbef2a3f9b4158caf32c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JKRrGSkdCS3hoSx5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">林赛·亨伍德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c92d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="f53d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在移动应用程序中使用本地数据库执行迁移总是让我觉得自己在拆除一个炸弹。但是<a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/room" rel="noopener ugc nofollow" target="_blank">房间库</a>使得处理数据库迁移变得更加简单。</p><p id="1a2f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">本地数据库是根据自己的业务逻辑设计的，遇到必须处理不同类型迁移的情况只是时间问题。</p><p id="95ac" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">与其寻找解决方案，不如尝试了解房间数据库中的迁移是如何工作的，这样您就可以在正确的位置打开正确的开关。</p><p id="2c7d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">使用Room，如果您更改数据库模式或添加新表，并且不升级数据库版本，您的应用程序将会崩溃。如果您已经升级了版本，但没有提供任何迁移规则，您的应用程序将会崩溃。</p><p id="385e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果正确的迁移规则不合适，数据库表将会丢失，用户将会丢失他们的数据。</p><p id="967e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我知道，这需要处理很多事情，但是一旦你了解了迁移是如何工作的，我相信你不会有同样的感觉。那么，事不宜迟，我们开始吧。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c196" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">历史</h1><p id="3108" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">房间是SQLite数据库的抽象层，这意味着房间必须在幕后处理SQLite。</p><p id="1d0c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">因此，如果您知道SQLite迁移是如何工作的，您就会理解为什么您需要对房间数据库做某些事情，比如升级版本、迁移规则等等，这些您将在本文的下一节中看到。</p><p id="5e31" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">SQLite数据库处理数据库版本的模式变化。更具体地说，每次添加、删除或更改数据库中的任何表或模式时，都必须增加数据库版本。</p><p id="d80b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后，当你打开应用程序时，SQLite首先处理版本迁移，只有在这之后，它才会打开数据库。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="db54" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">我们必须在房间里处理的事情</h1><p id="76f0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">让我们考虑一个简单的例子。我们有一个数据库，其中有一个名为<code class="fe mz na nb nc b">Movies</code>的表，表中有三个列id(主键)、名称和封面图片，数据类型分别为<code class="fe mz na nb nc b">Int</code>、<code class="fe mz na nb nc b">String</code>和<code class="fe mz na nb nc b">String</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5435" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在我们有了一个新需求，要在<code class="fe mz na nb nc b">Movies</code>表中添加一个<code class="fe mz na nb nc b">rating</code>列，所以我们在<code class="fe mz na nb nc b">Movies</code>数据类中添加了一个新变量，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4767" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">案例一。版本号未升级</h1><p id="da3c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在，您已经完成了数据库中的更改并运行了应用程序，当您尝试访问Room时，将会看到以下异常。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="2a6d" class="nj lh it nc b gy nk nl l nm nn">java.lang.<strong class="nc iu">IllegalStateException</strong>: Room cannot verify the data integrity. Looks like you've changed schema but forgot to update the version number. You can simply fix this by increasing the version number.</span></pre><p id="e540" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里，Room试图通过比较当前版本的身份散列和保存在<code class="fe mz na nb nc b">room_master_table</code>中的身份散列来检查数据库的身份。但是，没有身份哈希，应用程序会因<code class="fe mz na nb nc b">IllegalStateException</code>而崩溃。</p><p id="615c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在你知道了第一次崩溃的原因，让我们把它放在一个检查表中，以便在应用程序的每个版本中进行验证。</p><p id="0717" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们可以通过升级应用程序数据库类或用<code class="fe mz na nb nc b">RoomDatabase()</code>扩展的类中的数据库版本来解决这个问题，如下所示。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="a041" class="nj lh it nc b gy nk nl l nm nn">@Database(entities = arrayOf(DashboardCircularCategory::class,<br/>                             <strong class="nc iu">version = 2</strong>)<br/>@TypeConverters(Converters::class)<br/>abstract class ApplicationDatabase : <strong class="nc iu">RoomDatabase</strong>()  {</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7397" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">案例二。未提供任何迁移</h1><p id="9da0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在我们已经升级了数据库版本，您尝试访问数据库，应用程序将崩溃，并出现以下异常。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="351c" class="nj lh it nc b gy nk nl l nm nn">java.lang.<strong class="nc iu">IllegalStateException</strong>: A migration from 1 to 2 was required but not found. Please provide the necessary Migration path via RoomDatabase.Builder.addMigration(Migration ...) or allow for destructive migrations via one of the RoomDatabase.Builder.fallbackToDestructiveMigration* methods.</span></pre><p id="f1d5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">房间有一个名为<code class="fe mz na nb nc b">Migration</code>的类，它处理模式中的任何变化；它负责触发SQLite升级。因此，如果模式中有任何更改并且没有提供迁移，应用程序将会崩溃。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="17f0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">案例三。破坏性迁移</h1><p id="224f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">例外本身是显而易见的，我们需要在房间数据库构建器中实现迁移或使用<code class="fe mz na nb nc b">fallbackToDestructiveMigration</code>。为了简单起见，我们使用如下图所示的<code class="fe mz na nb nc b">fallbackToDestructiveMigration</code>。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="37f0" class="nj lh it nc b gy nk nl l nm nn"><strong class="nc iu">Room</strong>.databaseBuilder(context.getApplicationContext(),<br/>        ApplicationDatabase::class.java, "applicationDatabase.db")<br/>        .<strong class="nc iu">fallbackToDestructiveMigration</strong>()<br/>        .build()</span></pre><p id="a111" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，当您尝试访问房间数据库时，由于您已经升级了版本，房间将检查迁移。它找不到任何表，所以它将退回到销毁模式，删除数据库中的所有表，然后插入一个身份散列。</p><p id="0b28" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">因此，应用程序不会崩溃，但用户仍然会丢失所有数据。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7abb" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">带有模式更改的迁移</h1><p id="770e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">假设我们有这样一种情况，我们需要保留数据并插入新的模式更改。这就是优秀的迁移概念出现的地方。</p><p id="0647" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们一步一步地看看我们需要做的事情。</p><ol class=""><li id="9324" class="no np it ma b mb mu me mv mh nq ml nr mp ns mt nt nu nv nw bi translated">将数据库版本增加到3。</li></ol><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="251f" class="nj lh it nc b gy nk nl l nm nn">@Database(entities = arrayOf(DashboardCircularCategory::class,<br/>                             <strong class="nc iu">version = 2</strong>)<br/>@TypeConverters(Converters::class)<br/>abstract class ApplicationDatabase : <strong class="nc iu">RoomDatabase</strong>() </span></pre><p id="bc7a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">2.创建从版本2到版本3的迁移，包括版本2发布到生产环境后所做的所有更改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6d55" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">3.如下所示，将迁移添加到房间数据库构建器中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5cf0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，当你试图访问房间数据库时:</p><ol class=""><li id="c2e7" class="no np it ma b mb mu me mv mh nq ml nr mp ns mt nt nu nv nw bi translated">它会改变表格中的变化。</li><li id="1d5c" class="no np it ma b mb nx me ny mh nz ml oa mp ob mt nt nu nv nw bi translated">它更新了<code class="fe mz na nb nc b">identity_hash</code>。</li><li id="09b0" class="no np it ma b mb nx me ny mh nz ml oa mp ob mt nt nu nv nw bi translated">然后，尝试打开数据库。因为当前版本和保存的版本的身份hash是一样的，不会有什么问题。</li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e435" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">奖金</h1><p id="e0a2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">要了解有关房间数据库的更多信息，请阅读以下文章。</p><ul class=""><li id="49e2" class="no np it ma b mb mu me mv mh nq ml nr mp ns mt oc nu nv nw bi translated"><a class="ae ky" href="https://medium.com/mindorks/android-room-persistence-library-with-rxjava2-and-lesser-known-features-of-room-database-8b968261f9f0" rel="noopener"> Android房间持久化库，带有Rxjava2和鲜为人知的房间数据库特性</a></li><li id="fca3" class="no np it ma b mb nx me ny mh nz ml oa mp ob mt oc nu nv nw bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/android-room-persistence-library-kotlin-coroutines-26d53a09d384" rel="noopener"> Android Room持久性库— Kotlin协同程序</a></li></ul><p id="1b6d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>