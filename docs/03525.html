<html>
<head>
<title>Intersection Types and JavaScript Type Checking With Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用流检查交集类型和JavaScript类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-type-checking-with-flow-intersection-types-8f115659f4bb?source=collection_archive---------6-----------------------#2020-02-15">https://betterprogramming.pub/javascript-type-checking-with-flow-intersection-types-8f115659f4bb?source=collection_archive---------6-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0251" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看一下对象类型的交集</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bd3527e76e0be579106e8ab1a0f061f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZGu3-Gt29q0_9Kmf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@fin777?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Deb Dowd </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank"> Flow </a>是脸书制作的一个类型检查器，用于检查JavaScript数据类型。它有许多内置的数据类型，我们可以用它们来注释变量和函数参数的类型。</p><p id="c0e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看看如何使用交集类型来创建接受多种类型组合的变量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ea3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义交叉点类型</h1><p id="b455" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以通过用<code class="fe mz na nb nc b">&amp;</code>符号分隔多个类型来创建交集类型，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f3ac" class="nh md it nc b gy ni nj l nk nl">Type1 &amp; Type2 &amp; ... &amp; TypeN</span></pre><p id="e855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以用前导符号<code class="fe mz na nb nc b">&amp;</code>将上面的表达式分成多行:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="dfdd" class="nh md it nc b gy ni nj l nk nl">type Bar =<br/>  &amp; Type1<br/>  &amp; Type2<br/>  &amp; ...<br/>  &amp; TypeN</span></pre><p id="e732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以从其他交叉点类型创建交叉点类型:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b05a" class="nh md it nc b gy ni nj l nk nl">type A = Type1 &amp; Type2;<br/>type B = Type3 &amp; Type4;<br/><br/>type Foo = A &amp; B;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c52d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">交叉点类型的属性</h1><p id="7dae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们调用一个接受交集类型的函数时，我们必须传入包含所有这些类型的数据。但是在函数内部，我们可以将它们视为交集类型中的一种类型。</p><p id="3644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们定义以下函数:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bd1c" class="nh md it nc b gy ni nj l nk nl">type A = { a: number };<br/>type B = { b: boolean };<br/>type C = { c: string };<br/><br/>function foo(value: A &amp; B &amp; C) {<br/>  <br/>}</span></pre><p id="dfad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们可以将<code class="fe mz na nb nc b">value</code>视为<code class="fe mz na nb nc b">A</code>、<code class="fe mz na nb nc b">B</code>和<code class="fe mz na nb nc b">C</code>中的任意一个，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2f67" class="nh md it nc b gy ni nj l nk nl">function foo(value: A &amp; B &amp; C) {<br/>  let a: A = value;<br/>  let b: B = value;<br/>  let c: C = value;  <br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="76f7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不可能的交集类型</h1><p id="7d02" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以创造不可能的交集类型。例如，我们可以创建一个属于<code class="fe mz na nb nc b">string</code>和<code class="fe mz na nb nc b">boolean</code>交集的类型，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8814" class="nh md it nc b gy ni nj l nk nl">type StringBoolean = string &amp; boolean;</span></pre><p id="edfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种类型是无用的，因为没有值可以既是字符串又是布尔值，所以我们不能给它赋值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/2f80fc994b235893e6cd18b002daddbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wR2VfiCHhp_Hs6kn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Matthew LeJune 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3470" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对象类型的交集</h1><p id="4ce8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对象类型的交集意味着交集类型的对象必须具有两种类型的所有属性。</p><p id="4643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有以下交集类型:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="41e0" class="nh md it nc b gy ni nj l nk nl">type Foo = { foo: string };<br/>type Bar = { bar: boolean };</span><span id="2e14" class="nh md it nc b gy nn nj l nk nl">type FooBar = Foo &amp; Bar;</span></pre><p id="9205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建的类型为<code class="fe mz na nb nc b">FooBar</code>的变量必须具有<code class="fe mz na nb nc b">Foo</code>和<code class="fe mz na nb nc b">Bar</code>的所有属性:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="12c9" class="nh md it nc b gy ni nj l nk nl">let foobar : FooBar = {<br/>  foo: 'abc',<br/>  bar: true<br/>};</span></pre><p id="2f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当两个对象类型具有相同的属性名称但不同的类型时，那么当它们相交在一起时，具有相同名称的新属性将具有两种类型的交集作为新类型。</p><p id="ce82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a384" class="nh md it nc b gy ni nj l nk nl">type Foo = { foo: string };<br/>type Bar = { foo: boolean };</span><span id="82d5" class="nh md it nc b gy nn nj l nk nl">type FooBar = Foo &amp; Bar;</span></pre><p id="a791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe mz na nb nc b">foo</code>将拥有<code class="fe mz na nb nc b">string &amp; boolean</code>交集类型，这意味着不能给它设置任何值。</p><p id="8cfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用交集类型，我们可以创建具有构成交集类型的每种类型的所有属性的类型。我们也可以从原始类型中创建交集类型，但是它们是无用的，因为不能给这些类型的变量赋值。</p><p id="0cf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着交集类型主要对对象类型有用。</p></div></div>    
</body>
</html>