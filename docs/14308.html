<html>
<head>
<title>Recursive Matrix Determinant Calculation Using Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go进行递归矩阵行列式计算</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursive-matrix-determinant-calculation-using-go-53eb9a353829?source=collection_archive---------5-----------------------#2022-11-27">https://betterprogramming.pub/recursive-matrix-determinant-calculation-using-go-53eb9a353829?source=collection_archive---------5-----------------------#2022-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f84" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实现算法的实践方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b4cb3387aacce1cf5232b0aa857c218f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qsYuhQrI9-PasGDK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">沃洛季米尔·赫里先科在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9e8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前一段时间，当我试图学习<a class="ae kv" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank"> Go编程语言</a>时，我想到了记录我的旅程中一些有趣的方面。现在我来了，这是我在Medium上的第一篇文章，它是关于使用Go的打包思想实现一个递归方法来计算方阵的行列式。</p><p id="7484" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL；DR:这篇文章中讨论的项目可以通过这个<a class="ae kv" href="https://github.com/rapour/determinant" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>访问。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="0576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Determinant" rel="noopener ugc nofollow" target="_blank">行列式</a>仅在方阵上定义，并且可以在递归算法下导出，就像本<a class="ae kv" href="https://warwick.ac.uk/fac/sci/physics/research/condensedmatt/imr_cdt/students/david_goodwin/teaching/cis008-2/determinant_algorithm_cis008-2_lec_21.pdf" rel="noopener ugc nofollow" target="_blank">讲座</a>中讨论的那样，我们将在这里使用。</p><p id="b10b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不打算在这里遍历这个算法的细节，只关注实现本身。然而，熟悉它是我们在这里讨论的先决条件。</p><p id="d877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在研究矩阵的行列式之前，首先，我们需要对矩阵本身有一个概念。</p><p id="7166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Go是一种严格类型的语言，我们可以利用这一特性来模块化我们的代码。我们打算将矩阵概念的实现从主包中分离出来。</p><p id="d36c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们需要初始化一个Go模块。在项目根目录中使用以下命令初始化一个新模块:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="1e86" class="me mf iq ma b be mg mh l mi mj">go mod init "example/det"</span></pre><p id="833b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义了一个名为<code class="fe mk ml mm ma b">Matrix</code>的新类型，并把它放在一个<code class="fe mk ml mm ma b">matrix</code>包中，和我们的<code class="fe mk ml mm ma b">main</code>包放在一起，结构如下:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="af03" class="me mf iq ma b be mg mh l mi mj">├── main.go<br/>├── matrix<br/>│   ├── matrix.go<br/>├── go.mod</span></pre><p id="5d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的矩阵将是浮点数的二维切片。<code class="fe mk ml mm ma b">matrix.go</code>将如下所示:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="ad44" class="me mf iq ma b be mg mh l mi mj">package matrix<br/><br/>type Matrix [][]float64</span></pre><p id="080d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将为这种类型定义一些方法。Go允许在类型上定义操作，这种模式类似于OOP编程语言。由于行列式只为方阵定义，所以我们必须有一种方法来检查一个矩阵是否是方阵。让我们定义函数来获得一个<code class="fe mk ml mm ma b">Matrix</code>实例的行数和列数:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="9144" class="me mf iq ma b be mg mh l mi mj">func (m Matrix)Rows() int {<br/>  return len(m)<br/>}<br/><br/>// we assume the Matrix have the same number of elements in each row and<br/>// is not empy, which is true for all matrices<br/>func (m Matrix) Columns() int {<br/> return len(m[0])<br/>}<br/><br/>func (m Matrix) IsSquare() bool {<br/> return m.Columns() == m.Rows()<br/>}</span></pre><p id="01b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们在这一点上对矩阵的定义并没有强制一个<code class="fe mk ml mm ma b">Matrix</code>实例实际上是一个矩阵。我们可以定义一个<code class="fe mk ml mm ma b">Matrix</code>实例，不同的行有不同数量的元素；一个绝对不是矩阵的结构！我们稍后将讨论解决这个问题的方案，但是现在，我们需要一种方法来确认<code class="fe mk ml mm ma b">Matrix</code>确实是一个矩阵！检查一个<code class="fe mk ml mm ma b">Matrix</code>实例是否是一个矩阵，就是检查它是否为空，并且每行中的元素数量相同:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="cd73" class="me mf iq ma b be mg mh l mi mj">func (m Matrix) IsMatrix() bool {<br/><br/> if m.Rows() == 0 {<br/>  return false<br/> }<br/><br/> for _, row := range m {<br/><br/>  if len(m[0]) != len(row) {<br/>   return false<br/>  }<br/><br/> }<br/><br/> return true<br/>}</span></pre><p id="7fbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备开始写行列式计算的方法。首先，我们检查<code class="fe mk ml mm ma b">Matrix</code>实例是否是有效的方阵。随后，如果矩阵的大小为2×2，则可以使用以下表达式简单地计算行列式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/8825be79b08d9afbecc13ff97bac6467.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*5ysHJ2vL5YZcAuhbuA-n5A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2×2矩阵的行列式</p></figure><p id="34eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们此时的方法是:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="5b40" class="me mf iq ma b be mg mh l mi mj">func (m Matrix) Det() (float64, error) {<br/><br/> if !m.IsMatrix() || !m.IsSquare() {<br/>  return -1, <br/>  fmt.Errorf(<br/>    "determinant is not defined for the input [Matrix: %t][Square: %t]",<br/>    m.IsMatrix(), m.IsSquare())<br/> }<br/><br/> if m.Rows() == 2 {<br/>   return m[0][0]*m[1][1] - m[0][1]*m[1][0], nil<br/> }<br/><br/>  //TODO: calculate the determinant otherwise<br/>  return 0, nil<br/>}</span></pre><p id="9dc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于更大的矩阵，行列式可以递归计算。例如，3×3矩阵的行列式通过下面的表达式导出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/829ea6d39bd8f25640c0a99659fcd733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRRHR7twXW4XgeOqj4mPMQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">3×3矩阵的行列式</p></figure><p id="fdd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，要实现这一算法，我们需要计算子矩阵A、B和c。观察这些子矩阵后，您会发现它们是通过从原始矩阵中删除特定的行和列而创建的。</p><p id="c023" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种迭代方法可以推广到n×n矩阵，其中每次迭代的行列式表达式分解为一组子矩阵的行列式。由于算法是迭代工作的，所以每次迭代只需删除一行和一列就足够了。下面的函数将从矩阵中删除一列并返回结果矩阵。</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="93d2" class="me mf iq ma b be mg mh l mi mj">func InBetween(i, min, max int) bool {<br/> if (i &gt;= min) &amp;&amp; (i &lt;= max) {<br/>  return true<br/> } else {<br/>  return false<br/> }<br/>}<br/><br/><br/>func (m Matrix) ExcludeColumn(col_index int) (Matrix, error) {<br/><br/> if !InBetween(col_index, 1, m.Columns()) {<br/>  return Matrix{}, fmt.Errorf("input not in range")<br/> }<br/><br/> result := make(Matrix, m.Rows())<br/> for i, row := range m {<br/>  for j, el := range row {<br/>   if j == col_index-1 {<br/>    continue<br/>   }<br/>   result[i] = append(result[i], el)<br/>  }<br/> }<br/> return result, nil<br/>}</span></pre><p id="6561" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意函数<code class="fe mk ml mm ma b">InBetween</code>，它用于确保移除列的索引位于有效范围内。我们获取输入矩阵的每一行，并将元素复制到另一个矩阵中，除了<code class="fe mk ml mm ma b">col_index</code>列中的元素。排除一行也是以同样的思路实现的:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="3395" class="me mf iq ma b be mg mh l mi mj">func (m Matrix) ExcludeRow(row_index int) (Matrix, error) {<br/> if !InBetween(row_index, 1, m.Rows()) {<br/>  return Matrix{}, fmt.Errorf("input not in range")<br/> }<br/><br/> var result Matrix<br/> for i, r := range m {<br/>  if i == row_index-1 {<br/>   continue<br/>  }<br/>  result = append(result, r)<br/> }<br/> return result, nil<br/>}</span></pre><p id="5b26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们获取输入矩阵的每一行，并将整行添加到新矩阵中，除了<code class="fe mk ml mm ma b">row_index</code>行。现在我们准备完成我们的<code class="fe mk ml mm ma b">Det</code>功能。</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="a5e9" class="me mf iq ma b be mg mh l mi mj">func (m Matrix) Det() (float64, error) {<br/><br/> if !m.isMatrix() || !m.isSquare() {<br/>  return -1, fmt.Errorf("determinant is not defined for the input [Matrix: %t][Square: %t]",<br/>   m.isMatrix(), m.isSquare())<br/> }<br/><br/> if m.Rows() == 2 {<br/>  return m[0][0]*m[1][1] - m[0][1]*m[1][0], nil<br/> }<br/><br/> // if rows are more than 2<br/> // exclude the first row accoring to the algorithm<br/> partial_matrix, err := m.ExcludeRow(1)<br/> if err != nil {<br/>  return -1, err<br/> }<br/><br/> var temp float64 = 0<br/><br/> // iterate over the elements of the first row<br/> for i, el := range m[0] {<br/><br/>  // get the corresponding submatrix<br/>  reduced_matrix, err := partial_matrix.ExcludeColumn(i + 1)<br/>  if err != nil {<br/>   return -1, err<br/>  }<br/>  <br/>  // get the dterminant of the submatrix, recursively<br/>  partial_det, err := reduced_matrix.Det()<br/>  if err != nil {<br/>   return -1, err<br/>  }<br/><br/>  // determinant would be the sum of the determinant of <br/>  //the sumatrices multiplied by the right coefficients<br/>  temp = temp + partial_det*el*math.Pow(-1, float64(i))<br/> }<br/><br/> return temp, nil<br/>}</span></pre><p id="301a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，在我们的算法中，使用标准的<code class="fe mk ml mm ma b">math</code>包来计算每个乘法系数的符号。我们可以使用我们新策划的包来计算主包中矩阵的行列式:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="7d04" class="me mf iq ma b be mg mh l mi mj">package main<br/><br/>import (<br/> "example/det/matrix"<br/> "fmt"<br/> "log"<br/>)<br/><br/>func main() {<br/><br/>// sample matrix<br/> matrix := matrix.Matrix{<br/>  {3, 6, 2, 4},<br/>  {7, 1, 5, 3},<br/>  {9, 9, 1, 2},<br/>  {4, 6, 3, 2}}<br/><br/> det, err := matrix.Det()<br/> if err != nil {<br/>  log.Fatalf("Error in calculating the determinant: %v", err)<br/> }<br/><br/> fmt.Printf("The determinant is: %f", det)<br/><br/>}</span></pre><p id="c6e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出将是样本矩阵的真实行列式:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="3fdc" class="me mf iq ma b be mg mh l mi mj">The determinant is: -543.000000</span></pre><h1 id="19cc" class="mp mf iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated"><strong class="ak">矩阵验证</strong></h1><p id="c87f" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们最初的实现允许初始化数学上不是矩阵的<code class="fe mk ml mm ma b">Matrix</code>实例。</p><p id="48ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个实现问题，而不是数学问题。一个典型的解决方案是将<code class="fe mk ml mm ma b">Matrix</code>更改为未导出的类型，该类型只能通过您实现的实例化虚构来访问，并且将有足够的验证。</p><p id="151a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不打算详细介绍实现，但是结构应该是这样的:</p><pre class="kg kh ki kj gt lz ma mb bn mc md bi"><span id="0110" class="me mf iq ma b be mg mh l mi mj">package matrix <br/><br/>import "fmt"<br/><br/><br/>type matrix [][]float64<br/><br/><br/>func GenerateNewMarix(input [][]float64) (matrix, error){<br/>  <br/>  // do some validations on input argument and see if it passes the checks<br/>  passed := true<br/><br/>  if !passed {<br/>    return matrix{}, fmt.Errorf("error, not passed") <br/>  }<br/><br/>  <br/>  return matrix(input), nil<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="fe8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。感谢阅读。</p></div></div>    
</body>
</html>