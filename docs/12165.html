<html>
<head>
<title>Property-Based Testing Framework for Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于属性的节点测试框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/property-based-testing-framework-for-node-1ca702ad30bc?source=collection_archive---------18-----------------------#2022-05-16">https://betterprogramming.pub/property-based-testing-framework-for-node-1ca702ad30bc?source=collection_archive---------18-----------------------#2022-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a671" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过一个实例了解快速检查是如何工作的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0aa10ca355ab8a84c61a82587b974305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0vIaQCIhozBRhN0q"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@pinewatt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">派恩瓦特</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="34f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">务实的程序员</em>介绍了一种叫做基于属性的测试方法，其中用Python给出了一个例子，使用框架<a class="ae kv" href="https://hypothesis.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">假设</a>。</p><p id="1df0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设的使用非常直观和简单，并且完美地呈现了基于属性的测试的概念。所以我也想在Node中找到一个等价的替代品。其中有两个在Github上的星评很高，1.6K星的<a class="ae kv" href="https://github.com/jsverify/jsverify" rel="noopener ugc nofollow" target="_blank"> JSVerify </a>和2.8K星的<a class="ae kv" href="https://github.com/dubzzz/fast-" rel="noopener ugc nofollow" target="_blank">快查</a>。所以我花了一些时间稍微学习了一下，试图更贴近我的日常工作。</p><p id="d4f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章是一个回顾，一个简单的例子来记录经验。</p><h1 id="552e" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">为什么要进行基于属性的测试？</h1><p id="d962" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在提供例子之前，让我们解释一下为什么我们使用基于属性的测试。事实上，我不喜欢以财产为基础这个词。用我的话来说，就是“极高量”的测试。</p><p id="7d70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都知道测试金字塔如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/68ed50f42eaa2c39c3238dce01a10ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*nUdAvOUH7bhp9HG7.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试金字塔</p></figure><p id="6c23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我之前的文章中，我提到了<a class="ae kv" href="https://medium.com/interviewnoodle/whats-difference-between-unit-test-and-integration-test-aae6ef13220" rel="noopener">单元测试和集成测试的区别</a>。在金字塔的较低层次，需要更多的测试用例。</p><p id="0bab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即便如此，也很难产生大量的测试用例。我们通常会根据已知的条件或产品规格编写相应的测试，有时我们可能会记得编写边界测试(有时不会)，有时我们可能会依靠简单的随机验证功能，例如<a class="ae kv" href="https://fakerjs.dev/guide/" rel="noopener ugc nofollow" target="_blank"> faker </a>。</p><p id="04b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，一般来说，即使我们努力想出测试用例，我们也不能覆盖所有场景，我们把这种测试方法称为基于实例的测试。这是因为我们想出的测试用例基本上都是从某个例子延伸出来的，不能覆盖所有未知的上下文，也不能测试所有的边界条件。</p><p id="b55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我们希望有一个框架自动生成足够多的场景(合理或不合理的场景)来验证我们编写的代码，我们编写的测试用例只需要确保它们的“属性”是正确的。这就是基于属性的测试的起源。</p><h1 id="cc94" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">然而</h1><blockquote class="mv mw mx"><p id="24e7" class="kw kx ls ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">现实是，集成测试与单元测试大致相同。</p></blockquote><p id="951c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在很多机构工作过，从大型的民族企业到小型的创业公司。无论我是开发人员还是导师，从过去的经验来看，单元测试和集成测试一样重要。</p><p id="7f5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于大多数开发人员来说，正确划分单元测试和集成测试并不是一件容易的事情。为了能够完全拆分测试用例，他们需要具备设计模式、依赖注入、依赖倒置等技能。能够做好这件事。所以大部分测试环境都是基于特定的测试环境，比如使用<code class="fe lt lu lv lw b">docker-compose</code>生成一次性的数据库和测试数据，并在上面进行测试。</p><p id="8409" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">fast-check</code>的文档是基于单元测试的标准编写的，似乎只提供了验证布尔，也就是<code class="fe lt lu lv lw b">fc.assert</code>，所以我花了一些时间研究编写了一个接近日常使用的测试用例。</p><p id="dafc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般我需要几种能力。</p><ol class=""><li id="5be9" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">能够测试异步/等待。</li><li id="ab69" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">能够验证更多的上下文，比如<code class="fe lt lu lv lw b">assertEqual</code>。</li></ol><h1 id="4aba" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">快速检查简介</h1><p id="eeb9" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在我们开始编写测试用例之前，让我们来看看<code class="fe lt lu lv lw b">fast-check</code>的基本用法。</p><p id="6c27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先介绍一下<code class="fe lt lu lv lw b">fast-check</code>的结构。</p><ul class=""><li id="2b6c" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr np nh ni nj bi translated"><code class="fe lt lu lv lw b">Assertion (fc.assert)</code></li><li id="bf69" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr np nh ni nj bi translated"><code class="fe lt lu lv lw b">Properties (fc.property or fc.asyncProperty)</code></li></ul><p id="168c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">fc.assert</code>的作用是验证属性自动生成的所有测试都是正确的。需要这些属性来描述两个重要的块。</p><ul class=""><li id="8aec" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr np nh ni nj bi translated">跑步者</li><li id="79fd" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr np nh ni nj bi translated">套利</li></ul><p id="590e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Runner是要测试的上下文，即目标。另一方面，arbitraries是目标的输入参数，它是由属性自动生成的，我们所要做的就是为它们提供规则，例如，只有整数。</p><p id="b13f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个简单的例子。</p><pre class="kg kh ki kj gt nq lw nr ns aw nt bi"><span id="5146" class="nu ly iq lw b gy nv nw l nx ny">fc.assert(<br/>  fc.property(fc.integer(), fc.integer(), (i, j) =&gt; {<br/>    return i + j === add(i, j);<br/>  })<br/>);</span></pre><p id="fc02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个<code class="fe lt lu lv lw b">fc.integer()</code>是套利，后面的匿名函数是runner，带两个自变量<code class="fe lt lu lv lw b">i</code>和<code class="fe lt lu lv lw b">j</code>，对应前面的套利。我们要验证函数<code class="fe lt lu lv lw b">add</code>是否真的正确地对两个参数求和，所以<code class="fe lt lu lv lw b">add</code>的结果应该和<code class="fe lt lu lv lw b">+</code>一致。</p><p id="b8e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回顾一下我们刚刚提到的两个要求。</p><ol class=""><li id="37e6" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><code class="fe lt lu lv lw b">fast-check</code>能够测试async/await，runner可以是一个承诺，而<code class="fe lt lu lv lw b">fc.assert</code>本身也是一个承诺。</li><li id="afaf" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">虽然我们的测试目标是<code class="fe lt lu lv lw b">add</code>，但是在runner中很好地集成一些条件可以做出不仅仅是布尔的效果。</li></ol><h1 id="200e" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">快速检查示例</h1><p id="55ee" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">现在让我们来看一个更实际的例子。假设我有一个数据库表，其中有每个用户的钱。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/661e479cbe8439d26d0f9557318a0a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*Nque5NtvSpJSqQImeh-G0w.png"/></div></figure><p id="7f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个函数<code class="fe lt lu lv lw b">async function getMoney(limit)</code>，它将按升序对货币进行排序，并根据参数确定返回多少货币。</p><p id="f379" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们想测试这个黑匣子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f862" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我简单解释一下。</p><ol class=""><li id="7232" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">只是简单地验证功能是否真的有效，没有使用<code class="fe lt lu lv lw b">fast-check</code>。</li><li id="45fc" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">给定一个任意整数，返回结果的长度应该在0到10之间，因为我们在<code class="fe lt lu lv lw b">before</code>中只创建了十条记录。</li><li id="5491" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">给定一个整数范围，返回的长度应该等于给定的长度。</li><li id="36a5" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">验证整个数组的顺序确实是升序的。从这个runner可以看出，即使是非常复杂的条件也可以验证，但是要注意不要在测试用例中制造bug导致需要一个测试用例的测试用例。</li></ol><p id="d6c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果检测到问题，<code class="fe lt lu lv lw b">fast-check</code>还会告诉你它使用什么样的套利来检测问题。举个例子，</p><blockquote class="mv mw mx"><p id="7acc" class="kw kx ls ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated"><em class="iq">反例:[-1234567890] </em></p></blockquote><p id="32d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着测试用例在<code class="fe lt lu lv lw b">i = -1234567890</code>时失败。可能是负数没有被正确处理，或者“大”负数没有被正确处理。这是编写一个真正的单元测试(或集成测试)和验证的时候了-1234567890，这样一个失败的案例可以在以后用作回归测试。</p><h1 id="72f3" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="08b5" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">理想情况下，当像这样测试数据库行为时，我们将使用依赖注入等技术来隔离物理数据库，以便提高测试性能。但是正如我前面所说的，根据开发人员的经验和技能，将代码从外部依赖中恰当地分离出来并不容易。</p><p id="00b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以在许多组织中，我们仍然看到大多数测试用例不得不依赖物理数据库进行测试。但我不得不说这是不正确的。</p><p id="27b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我通过一个真实的例子解释了<code class="fe lt lu lv lw b">fast-check</code>的用法，以及它是如何贴近实际的。尽管如此，我还是希望我们不用再面对这个了，至少看完<a class="ae kv" href="https://medium.com/interviewnoodle/whats-difference-between-unit-test-and-integration-test-aae6ef13220" rel="noopener">我之前的文章</a>，让我们试着翻一翻那些不合理的测试案例。</p></div></div>    
</body>
</html>