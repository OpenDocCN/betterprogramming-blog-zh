<html>
<head>
<title>Network Requests in Swift Using the Result Type and Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中使用结果类型和类属的网络请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/network-requests-in-swift-using-result-type-and-generics-cfbcea464c1f?source=collection_archive---------6-----------------------#2019-11-26">https://betterprogramming.pub/network-requests-in-swift-using-result-type-and-generics-cfbcea464c1f?source=collection_archive---------6-----------------------#2019-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3542" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在提出网络请求时，如何利用Swift的<em class="kf">结果</em>类型和泛型</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/76d75b966a0ca20363762ce037221592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8wg4BPPavXP79C6jYEZCQ.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><a class="ae kw" href="https://unsplash.com/@gruu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安娜·格鲁</a>在<a class="ae kw" href="https://unsplash.com/s/photos/error?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0b57" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="lt"> </em> <code class="fe lu lv lw lx b">Result</code>是一个<code class="fe lu lv lw lx b">enum</code>，有两种情况:<code class="fe lu lv lw lx b">success</code>和<code class="fe lu lv lw lx b">failure</code> <em class="lt">，</em>，这两种情况都是使用泛型实现的。</p><p id="26c6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe lu lv lw lx b">Success</code>可以是任何东西，但是<code class="fe lu lv lw lx b">failure</code> <em class="lt"> </em>必须符合<code class="fe lu lv lw lx b">Error</code> <em class="lt"> </em>协议。(可以实现自己的错误类型，也可以直接用Swift的<code class="fe lu lv lw lx b">Error</code>。)</p><p id="1fbe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Swift中<code class="fe lu lv lw lx b">Result</code>类型的引入让我们有机会以更干净、更安全的方式处理异步函数的结果。</p><p id="ba98" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们看看在一个简单的网络请求例子中使用<code class="fe lu lv lw lx b">Result</code>和不使用<code class="fe lu lv lw lx b">Result</code>的好处，这个例子对<code class="fe lu lv lw lx b">success</code>和<code class="fe lu lv lw lx b">error</code>值都使用了泛型类型。</p><p id="f2e2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将从实现一个<code class="fe lu lv lw lx b">RequestError</code>类型和创建一个有两个功能的<code class="fe lu lv lw lx b">NetworkService</code> <strong class="kz ir"> </strong>类开始。</p><p id="0ed9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它们都负责发出URL请求，区别在于一个使用<code class="fe lu lv lw lx b">Result</code>来处理结果(双关语)，而另一个使用普通的完成处理程序。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ly lz l"/></div></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d18c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">正如你所看到的，使用<code class="fe lu lv lw lx b">Result</code>使得代码更容易阅读。</p><p id="1219" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最重要的是，完成处理程序方法容易出错，因为它的<code class="fe lu lv lw lx b">success</code>和<code class="fe lu lv lw lx b">error</code>值都是<code class="fe lu lv lw lx b">Optional</code>类型，因此，下面两个例子是有效的(就编译器而言)，这将我们带入一个奇怪的状态:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="e519" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用我们简单的网络请求实现不应该出现这种错误，但是随着代码变得更加复杂(或者被不同地使用),肯定会有出错的可能。</p><p id="4fbc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果我们看一看<code class="fe lu lv lw lx b">NetworkService</code>消费者使用这两个函数时，我们可以得出关于代码清晰性和安全性的类似结论。</p><p id="1dee" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">不仅使用<code class="fe lu lv lw lx b">Result</code>的函数更干净，而且如果使用完成处理器方法的函数中有一个bug，它有可能完全打乱我们应用程序的流程。</p><p id="f90f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，让应用程序处于停滞状态(当两个值都不存在时)，或者继续执行流程，同时显示错误警告(当两个值都存在时)。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ly lz l"/></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="11c8" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">具有泛型的结果类型</h1><p id="c9fa" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">上面的网络请求示例只在成功的情况下支持<code class="fe lu lv lw lx b">String</code>值。但是如果我们也想支持其他值类型呢？仿制药来拯救！</p><p id="3cd1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，我们需要修改<code class="fe lu lv lw lx b">makeUrlReqeust</code> <strong class="kz ir"> </strong>函数来支持泛型类型。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5b74" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，我们必须修改我们的客户端代码。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="8de1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在闭包内使用泛型类型的<code class="fe lu lv lw lx b">Result</code>要求在创建闭包时指定泛型类型，否则，编译器将抛出以下错误:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7d0399926fbdae4e57d1c9788af58a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*I4oAn3Pcf_jTzslnhDy4Aw.png"/></div></figure><p id="fd80" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，我们需要更改<code class="fe lu lv lw lx b">decodedData</code>函数，以支持解码为除了<code class="fe lu lv lw lx b">String</code>以外的其他值(查看下面一个可能的实现)，瞧，现在您可以使用任何您想要的值了！</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ly lz l"/></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="7b9b" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结论</h1><p id="e148" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">尽管本文中使用的例子很简单，但它清楚地展示了当我们处理网络请求的响应时,<code class="fe lu lv lw lx b">Result</code>类型如何使我们的生活变得更容易。</p><p id="862e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">感谢您的阅读，如果您有任何意见或问题，请告诉我！</p></div></div>    
</body>
</html>