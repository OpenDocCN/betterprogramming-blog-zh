<html>
<head>
<title>How to Authenticate Users With Tokens in a React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React应用程序中使用令牌认证用户</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-authentication-users-with-token-in-a-react-application-f99997c2ee9d?source=collection_archive---------1-----------------------#2022-09-21">https://betterprogramming.pub/how-to-authentication-users-with-token-in-a-react-application-f99997c2ee9d?source=collection_archive---------1-----------------------#2022-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="574d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保护用户数据的深入指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/759722638c6482a386e31574ec2b5c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QKzgCBExpYOtf0N35gDxA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="96ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">身份验证是每个涉及公共和私有页面的优秀应用程序的重要组成部分，因此了解如何实现身份验证及其执行流程非常重要。</p><p id="fe03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将解释什么是基于令牌的身份验证，身份验证流程如何工作，然后向您展示如何在React.js应用程序中设置基于令牌的身份验证。</p><p id="04c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文要求您对React.js中使用的重要术语有一些基本的了解，因此为了顺利理解，您应该对什么是自定义钩子、如何在React.js中使用条件操作以及如何使用内置的React.js钩子(如useState钩子)有所了解，或者至少有一些基本的了解。</p><p id="1b8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想看看完整的项目，看看是什么感觉，你可以在这里克隆库<a class="ae lr" href="https://github.com/Bishopukpai/react-auth" rel="noopener ugc nofollow" target="_blank">，然后使用<code class="fe ls lt lu lv b">npm start</code>在你的机器上运行它。请注意，您的服务器必须正在运行，因此您必须打开一个新的终端并运行一个节点<code class="fe ls lt lu lv b">server.js</code>来运行您的服务器并对其进行测试。</a></p><p id="9cbc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文将分为以下几个部分:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="bbc6" class="ma mb iq lv b gy mc md l me mf">What Is Token-Based Authentication<br/><a class="ae lr" href="#f1a0" rel="noopener ugc nofollow">How To Setup React.js Projects and Pages</a><br/><a class="ae lr" href="#6433" rel="noopener ugc nofollow">Setting Up Application’s Server for Generating Token</a><br/><a class="ae lr" href="#b418" rel="noopener ugc nofollow">How To Store User’s Token</a><br/><a class="ae lr" href="#1208" rel="noopener ugc nofollow">Conclusion</a></span></pre><h1 id="62c2" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">什么是基于令牌的身份验证</h1><p id="f877" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">基于令牌的身份验证是使用身份验证令牌在应用程序和网站之间安全地传输用户身份。该流程使组织能够提高其身份认证流程的效率。</p><p id="9e8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它只是一个生成加密且安全的安全令牌的过程，并允许用户在成功提交这些令牌后提出验证请求，这些令牌将被存储以供进一步的身份验证。</p><p id="25ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经过一段指定的时间后，一个好的身份验证令牌将到期。让身份验证令牌保持活动状态太久会使应用程序容易受到攻击，因为劫持程序可以利用这个缺陷劫持用户会话。</p><p id="3a16" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据上面的简单定义，您应该理解基于令牌的身份验证有五个执行步骤，它们是:</p><ol class=""><li id="1362" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated">用户通过提供必要的登录凭证来发出请求</li><li id="ca56" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">通过向用户授予访问令牌来处理和验证该请求</li><li id="5bea" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">然后将访问令牌提交给浏览器，以授权用户访问会话。</li><li id="66d2" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">将这些身份验证令牌存储在应用程序中以便进一步进行身份验证是很重要的，有许多方法可以做到这一点。我们将在本文后面的令牌存储部分讨论这一点。</li><li id="7cc4" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">最后，为了保护应用程序的用户免受网络攻击，有必要为生成的令牌设置一个超时期限。</li></ol><p id="c453" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有五种主要类型的令牌可用于识别和授予用户对设备或应用程序的访问权限。</p><p id="91bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些令牌可用于物理设备和软件应用程序，包括:</p><ol class=""><li id="6375" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated">软件令牌</li><li id="02cf" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">断开令牌</li><li id="7a5f" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">JSON Web令牌(JWT)</li><li id="0b3b" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">连接令牌</li><li id="5629" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">无接触代币</li></ol><p id="3d45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面提到的每个令牌都有特定的用例。</p><p id="2f08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">至此，我相信您已经很好地理解了什么是基于令牌的身份验证。在接下来的几节中，您将学习如何在React.js应用程序中设置基于令牌的身份验证，以及如何保护应用程序中的私有页面。</p><h1 id="f1a0" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">如何设置React.js项目和页面</h1><p id="be2a" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">为了开始这一部分，我将设置我的<code class="fe ls lt lu lv b">React.js</code>项目，并在我的项目中创建两个组件(<code class="fe ls lt lu lv b">HomePage</code>和<code class="fe ls lt lu lv b">Dashboard</code>)，然后在不同的页面上呈现这些组件，也称为路线。</p><p id="3f34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在您希望React.js项目所在的项目目录中，运行以下命令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d299" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将建立一个<code class="fe ls lt lu lv b">React.js</code>项目文件夹，包含运行它所需的所有必要文件和文件夹。</p><p id="e5f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在您想要使用的任何代码编辑器中打开您的<code class="fe ls lt lu lv b">React.js</code>项目。我用的是VS代码。</p><p id="b586" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">App.js</code>文件中，在src文件夹edit内，删除header标签，使您的<code class="fe ls lt lu lv b">App.js</code>文件看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5936" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您将在您的应用程序中安装一些包。首先，我使用tailwindcss来设计我的应用程序的样式。如果您想使用它，您可以通过以下过程快速安装它并为您的应用程序设置它:</p><p id="35f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在终端中运行下面的命令。导航到刚刚创建的React.js项目后，在应用程序的依赖项中安装tailwindcss、postcss和autoprefixer，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6636" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后运行下面的命令生成一个<code class="fe ls lt lu lv b">tailwind.config.js</code>文件和一个<code class="fe ls lt lu lv b">postcss.config.js</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a060" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过将下面的代码添加到<code class="fe ls lt lu lv b">module.exports</code>对象的内容数组来配置<code class="fe ls lt lu lv b">tailwind.config.js</code>文件。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6e29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码将为你的模板文件配置一个路径。从上面的代码中，注意到您要求tailwindcss在所有具有。js，。jsx，。ts，还有。<code class="fe ls lt lu lv b">src</code>文件夹内的tsx扩展名。</p><p id="ec02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过这条指令，您的tailwindcss样式将被添加到这些文件中，您可以在那里使用它们。</p><p id="367a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，用下面的代码在您的<code class="fe ls lt lu lv b">React.js </code>项目的<code class="fe ls lt lu lv b">index.css</code>文件中为您的应用程序的每一层添加<code class="fe ls lt lu lv b">@tailwind</code>指令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5c47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样。这就是在您的应用程序中设置tailwindcss所需的全部内容。让我们继续添加其他依赖项。</p><p id="0bf4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您将向我们的应用程序添加一个路由机制，因此您需要react-router-dom。您还需要cors在应用程序页面之间共享信息，还需要express为您的应用程序设置后端服务器应用程序。</p><p id="8d6a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行下面的命令来安装react-router-dom:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d646" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">cors</code>和<code class="fe ls lt lu lv b">express</code>将作为开发依赖项安装，所以运行下面的命令来安装它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fe7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您已经拥有了启动应用程序所需的一切，但是在运行启动脚本之前，让我们为应用程序添加一点样式。</p><p id="f529" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过修改<code class="fe ls lt lu lv b">index.css</code>文件中的代码，将应用程序的背景颜色改为黑色:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="185e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，运行启动脚本在<code class="fe ls lt lu lv b">localhost:3000</code>上查看您的应用程序。现在，您应该看到您的应用程序有一个完全黑色的背景。</p><p id="53c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">src</code>文件夹中，创建另一个名为<code class="fe ls lt lu lv b">Components</code>的文件夹。在<code class="fe ls lt lu lv b">Components</code>文件夹中，创建<code class="fe ls lt lu lv b">Homepage.jsx</code>和<code class="fe ls lt lu lv b">Dashboard.jsx</code>文件。</p><p id="85c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些文件将分别存放我们的<code class="fe ls lt lu lv b">Homepage</code>和<code class="fe ls lt lu lv b">Dashboard</code>组件。</p><p id="eee6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面显示了<code class="fe ls lt lu lv b">Homepage.jsx</code>的所有代码，因此您可以创建一个<code class="fe ls lt lu lv b">Homepage</code>组件来在浏览器中显示一条简单的<code class="fe ls lt lu lv b">Homepage</code>消息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d8f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">Dashboard.jsx</code>文件中，添加以下代码以创建<code class="fe ls lt lu lv b">Dashboard</code>组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e7c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，将这些组件导入到<code class="fe ls lt lu lv b">App.js</code>文件中，并放置在不同的页面上。</p><p id="b4fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从react-router-dom导入<code class="fe ls lt lu lv b">BrowserRouter</code>、<code class="fe ls lt lu lv b">Routes</code>和<code class="fe ls lt lu lv b">Route </code>。使用它们在单独的页面上设置这些组件，代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="abe2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你参观<code class="fe ls lt lu lv b">localhost:3000</code>，你应该会看到<code class="fe ls lt lu lv b">Homepage</code>的成分。</p><p id="9585" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你访问<code class="fe ls lt lu lv b">localhost:3000/Dashboard</code>，你也应该看到<code class="fe ls lt lu lv b">Dashboard</code>组件。</p><p id="a232" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，现在，你的<code class="fe ls lt lu lv b">Dashboard</code>组件不是私有的，每个人都可以访问它。它需要保密。</p><p id="8dc6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于访问<code class="fe ls lt lu lv b">Dashboard</code>页面的用户，他们需要在登录表单中提供用户名和密码，以请求获取身份验证令牌。因此，您也将使用这个表单创建一个<code class="fe ls lt lu lv b">Login</code>组件。</p><p id="2fe5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在应用程序的<code class="fe ls lt lu lv b">src</code>文件夹中再次创建一个文件夹，并将其命名为Login。</p><p id="dcde" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，并不是一定要创建一个新的文件夹来包装一个组件，但是作为一个好的习惯，最好将<code class="fe ls lt lu lv b">Components</code>分组到不同的文件夹中。因此，由于我们有功能相同的<code class="fe ls lt lu lv b">Homepage</code>和<code class="fe ls lt lu lv b">Dashboard</code>组件，我们将它们保存在同一个文件夹中。</p><p id="4cae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">Login</code>组件中，创建一个<code class="fe ls lt lu lv b">Login.jsx</code>文件，在这个文件中，创建一个<code class="fe ls lt lu lv b">Login</code>组件，并用下面的代码设置登录表单的样式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="dc29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">Dashboard</code>组件中设置一个逻辑，当用户试图访问<code class="fe ls lt lu lv b">Dashboard</code>页面而没有正确的身份验证(生成一个令牌)时，这个逻辑将向用户显示这个登录表单。</p><p id="4468" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">Dashboard.jsx</code>文件中，从React导入<code class="fe ls lt lu lv b">useState</code>钩子。这将用于存储生成的令牌，以便向用户授予访问权限。</p><p id="f06d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在此之后，如果用户没有令牌，则使用一个条件语句来呈现<code class="fe ls lt lu lv b">Login</code>表单。</p><p id="2f55" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，修改您的<code class="fe ls lt lu lv b">Dashboard</code>组件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4933" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">保存<code class="fe ls lt lu lv b">Login.jsx</code>和<code class="fe ls lt lu lv b">Dashboard.jsx</code>文件，在应用程序仍在运行的情况下打开浏览器，并导航至<code class="fe ls lt lu lv b">localhoast:3000/Dashboard</code>。您将看到登录表单，而不是<code class="fe ls lt lu lv b">Dashboard</code>页面。</p><p id="1080" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了！现在，您有一个受登录表单保护的私人页面，但现在的问题是您的登录表单不起作用。这是因为您没有为经过身份验证的用户生成令牌。</p><p id="1035" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是您已经成功地完成了使用令牌进行身份验证的第一步，即给用户一个在登录表单上发出请求的平台。</p><p id="a8a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下一节中，您将创建一个后端服务器，该服务器将创建一个生成的令牌并将其发送给经过身份验证的用户。</p><h1 id="6433" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">设置用于生成令牌的应用服务器</h1><p id="61fc" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">在上一节中，您在应用程序中创建了一个受登录页面保护的私有页面。</p><p id="c6cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本节中，您将在项目目录的根目录下创建一个<code class="fe ls lt lu lv b">server.js</code>文件。</p><p id="3c41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个文件中，您将使用express和cors创建一个服务器应用程序，该应用程序将向您的前端应用程序发送一个令牌，并在用户使用登录表单发出请求时授予用户访问权限。</p><p id="403c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在项目目录的根目录下创建一个<code class="fe ls lt lu lv b">server.js</code>文件。也就是说，在您创建了<code class="fe ls lt lu lv b">server.js</code>文件之后，您的项目文件夹结构应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/372fc4b7e511f8d25874092ab8943088.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*pCucKNnGyq4r9sW1tL19zg.png"/></div></figure><p id="2e3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个<code class="fe ls lt lu lv b">server.js</code>文件中，添加下面的代码来创建服务器应用程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2f39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据上面的代码，您执行了以下操作:</p><ul class=""><li id="9a81" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nt ni nj nk bi translated">导入了<code class="fe ls lt lu lv b">express</code>或必需的<code class="fe ls lt lu lv b">express</code>，并将其传递给第1行中一个名为<code class="fe ls lt lu lv b">express</code>的变量。</li><li id="063d" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">在第2行中，您需要<code class="fe ls lt lu lv b">cors</code>，并将其传递给一个<code class="fe ls lt lu lv b">cors</code>变量。</li><li id="4cd0" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">在第4行，您创建了一个<code class="fe ls lt lu lv b">app</code>变量，并将<code class="fe ls lt lu lv b">express</code>变量传递给它。</li><li id="5607" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">在第5行，您通过将<code class="fe ls lt lu lv b">cors</code>作为参数传递给<code class="fe ls lt lu lv b">app.use( )</code>方法，要求您的服务器应用程序使用<code class="fe ls lt lu lv b">cors</code>包。</li><li id="016c" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">从第7行到第11行，您请求服务器应用程序向您的应用程序的登录路由发送一个令牌对象</li><li id="c15f" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">在第13行，当您运行您的服务器应用程序时，您要求应用程序监听<code class="fe ls lt lu lv b">port 8080</code>并向控制台发送“API正在<code class="fe ls lt lu lv b">localhost:8080/login</code>上运行”消息。</li></ul><p id="60d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要查看这是否真的有效，在VS代码中打开另一个终端，并运行节点<code class="fe ls lt lu lv b">server.js</code>您应该会直接在终端中看到“API正在<code class="fe ls lt lu lv b">localhost:8080/login</code>上运行”。</p><p id="cf93" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了，你有一个正在运行的服务器。</p><p id="da9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您需要让您的<code class="fe ls lt lu lv b">Login</code>组件请求从您刚刚创建的后端服务器应用程序获取这个令牌。</p><p id="4f78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，通过添加<code class="fe ls lt lu lv b">PropType</code>来破坏从<code class="fe ls lt lu lv b">Login</code>组件中的<code class="fe ls lt lu lv b">Dashboard</code>组件传递的<code class="fe ls lt lu lv b">setToken</code>支柱，然后拉出<code class="fe ls lt lu lv b">setToken</code>支柱。因此，修改您的<code class="fe ls lt lu lv b">Login.jsx</code>文件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a069" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建一个向您创建的服务器应用程序发出<code class="fe ls lt lu lv b">POST</code>请求的函数。</p><p id="1c4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将是一个<code class="fe ls lt lu lv b">async</code>函数，它将凭证作为它的参数，然后使用POST请求调用一个fetch方法。</p><p id="2676" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，就在<code class="fe ls lt lu lv b">Login</code>组件之前，在所有导入之后，添加下面的代码来创建<code class="fe ls lt lu lv b">async</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0896" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，您将创建两个状态:一个保存用户名值，另一个保存密码值。此外，您需要添加一个handle submit函数，该函数将调用您刚刚创建的<code class="fe ls lt lu lv b">LoginUser</code>函数，设置用户令牌，并在登录表单的每个字段上添加<code class="fe ls lt lu lv b">onChange</code>事件。在此之后，您的应用程序将能够接受用户的输入。</p><p id="2f9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">修改您的登录表单，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="bd79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整个登录组件的代码应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b4ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">保存文件，返回浏览器，服务器应用程序仍在运行。输入一些登录凭证，您应该会被导航到<code class="fe ls lt lu lv b">Dashboard</code>组件。</p><p id="6366" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将令牌存储在应用程序的局部状态变量中，但这给我们带来了一个问题。现在，我们的应用程序将在用户每次刷新页面或打开新标签页时向他们显示登录表单。</p><p id="123c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据应用程序的需求，这可能不是一个很好的解决方案。为了解决这个问题，我们可以将令牌存储在一个<code class="fe ls lt lu lv b">localStorage</code>或<code class="fe ls lt lu lv b">sessionStorage</code>中。这样，即使用户刷新页面或打开新的选项卡，他们仍将保持登录状态。</p><p id="9c02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管在本地和会话存储中存储令牌有它们自己不同的安全含义，但我仍将向您展示如何在其中存储令牌，并在下一节解释它们的安全风险。</p><h1 id="b418" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">如何存储用户令牌</h1><p id="0eba" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">您创建了一个可以工作的登录表单，但是现在，您的应用程序不能长时间保持用户的会话。</p><p id="ebab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，如果用户应该刷新页面或在会话中打开一个新的选项卡，它将结束会话，用户将不得不再次提供他们的凭据。</p><p id="1110" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然您现在将用户的令牌存储在本地状态变量中，但是您也可以将令牌存储在会话存储中，以便用户能够根据需要保持登录状态。或者您可以决定将其存储在本地存储中。</p><p id="4bd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是存储在本地存储器中也有其缺陷，因为它使用户永远保持登录——直到令牌从本地存储器中被取走。</p><p id="9fd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，让我向您展示如何在会话和本地存储中存储用户令牌</p><h1 id="521d" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">会话存储</h1><p id="ff87" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">要使用会话存储，请删除仪表板页面中的令牌状态，并创建<code class="fe ls lt lu lv b">setToken</code>和<code class="fe ls lt lu lv b">getToken</code>函数。然后，将<code class="fe ls lt lu lv b">getToken</code>函数赋给一个令牌变量。</p><p id="77ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，您的仪表板组件的代码应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f522" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您将使用<code class="fe ls lt lu lv b">setToken</code>函数将用户生成的令牌保存到会话中。为此，您将使用<code class="fe ls lt lu lv b">setItem</code>方法。<code class="fe ls lt lu lv b">setItem</code>方法接受两个参数:一个键和一个字符串值。</p><p id="1e20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，如果您打算用<code class="fe ls lt lu lv b">setItem</code>方法设置用户令牌，那么您必须使用<code class="fe ls lt lu lv b">JSON.stringify</code>方法将令牌从JSON对象转换成字符串。</p><p id="6a6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用下面的代码调用<code class="fe ls lt lu lv b">setItem</code>方法并在会话中保存令牌:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="86d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样，您就成功地将用户令牌保存到了应用程序的会话存储中。但是您仍然需要从会话存储中检索这个令牌，并将其存储在您的应用程序中，以便您的应用程序可以使用它向用户呈现所需的页面。</p><p id="d119" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以使用<code class="fe ls lt lu lv b">getItem</code>方法从会话存储中获取令牌。<code class="fe ls lt lu lv b">getItem</code>方法将一个键值作为唯一的参数，然后返回一个字符串值。</p><p id="f6c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在<code class="fe ls lt lu lv b">getToken</code>函数中，添加<code class="fe ls lt lu lv b">getItem</code>方法，并使用下面的代码从会话存储中检索用户令牌:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f4e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是现在，当令牌检索成功时，您需要提醒您的应用程序。这使得用户即使提供了凭据也无法登录。</p><p id="46ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，创建一个带有令牌状态和<code class="fe ls lt lu lv b">setToken</code>函数的定制钩子，当成功检索到令牌时，它将触发应用程序的重新呈现。</p><p id="8d8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建一个新文件夹，命名为<code class="fe ls lt lu lv b">App</code>。在<code class="fe ls lt lu lv b">App</code>文件夹中，创建一个名为<code class="fe ls lt lu lv b">useToken</code>的新文件。</p><p id="0d17" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要创建一个定制的钩子，你必须使用前缀<code class="fe ls lt lu lv b">*use</code>，这就是为什么我们要使用<code class="fe ls lt lu lv b">useToken</code>。</p><p id="ac88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">useToken</code>文件中，导入<code class="fe ls lt lu lv b">useState</code>并创建一个令牌状态和<code class="fe ls lt lu lv b">setToken</code>函数。接下来，将<code class="fe ls lt lu lv b">getToken</code>函数复制粘贴到<code class="fe ls lt lu lv b">useToken</code>文件中，并将其更改为箭头函数。</p><p id="3f9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，从<code class="fe ls lt lu lv b">Dashboard</code>组件中复制<code class="fe ls lt lu lv b">setToken</code>函数，并将名称改为<code class="fe ls lt lu lv b">saveToken</code>，因为您已经有了一个名为<code class="fe ls lt lu lv b">setToken</code>的函数，它负责设置应用程序的令牌值。</p><p id="8d06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，您的<code class="fe ls lt lu lv b">useToken</code>代码应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="394d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后在<code class="fe ls lt lu lv b">Dashboard</code>组件中，导入，并使用<code class="fe ls lt lu lv b">useToken</code>钩子。</p><p id="8fab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您不再需要<code class="fe ls lt lu lv b">useState</code>钩子，因为您不再将令牌存储在本地状态变量中。你也不需要<code class="fe ls lt lu lv b">setToken</code>和<code class="fe ls lt lu lv b">getToken</code>函数，因为你的<code class="fe ls lt lu lv b">useToken</code>钩子中已经有了它们。</p><p id="84e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，将它们清除掉，并用下面的代码在<code class="fe ls lt lu lv b">Dashboard</code>组件中添加<code class="fe ls lt lu lv b">useToken</code>挂钩:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f095" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">保存文件，并在服务器应用程序仍在运行的情况下再次打开浏览器。您应该看到登录表单，这次应该可以正常工作了。</p><p id="0380" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您打开一个新的选项卡或刷新页面，您仍将登录到应用程序，并停留在<code class="fe ls lt lu lv b">Dashboard</code>页面上。</p><p id="78dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将会话令牌存储在应用程序的本地内存之外的安全风险在于，如果对应用程序的攻击成功，会将这些令牌暴露给恶意用户。此外，您需要实现一种在空闲一段时间后自动结束用户会话的方法，以避免会话劫持。</p><p id="4bf1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一种存储方法是使用本地存储。此方法遵循与会话存储相同的方法。</p><p id="00e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您只需将自定义钩子中的每个会话存储实例都改为<code class="fe ls lt lu lv b">localStorage</code>。</p><p id="b134" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您正在使用<code class="fe ls lt lu lv b">localStorage</code>，要知道用户将永远登录到应用程序中，即使您结束了应用程序，您仍将登录，直到您直接从<code class="fe ls lt lu lv b">localStorage</code>中清除令牌。</p><p id="8687" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些是存储用户生成的令牌的方法，也是在应用程序中实现基于令牌的身份验证的步骤</p><h1 id="1208" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="f251" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">身份验证在保护web应用程序用户免受攻击方面起着非常重要的作用。实现正确的身份验证对于防止公开私有页面非常重要。</p><p id="54fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我介绍了如何在React应用程序中使用令牌，在正确识别之后授予用户访问权限。我还向您展示了如何设置私有页面，并仅在进行了适当的身份验证和令牌发布之后才显示它们。</p><p id="af82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我向您展示了在应用程序中存储用户令牌的不同方法。有优点也有缺点，所以需要说明使用每种储存方法的风险和重要性。</p><p id="3bf9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>