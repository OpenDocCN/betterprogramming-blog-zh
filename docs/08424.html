<html>
<head>
<title>A Look at Concurrent Programming in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift并发编程一瞥</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-look-at-concurrent-programming-in-swift-ce886bd49c31?source=collection_archive---------8-----------------------#2021-04-28">https://betterprogramming.pub/a-look-at-concurrent-programming-in-swift-ce886bd49c31?source=collection_archive---------8-----------------------#2021-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="589b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用concurrentPerform轻松编写并行代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c7bbec173c50c854cce06fbceec224ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*38Y_JB5zi3M-c0b5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nathanareboucas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nathana rebou as</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="d25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你关注我的博客，你会知道我喜欢并发编程。我对同时运行不同的任务、收集结果并节省大量时间的想法非常着迷。</p><p id="d5e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本周，当我在我团队的当前项目中工作时，我发现了一个我并不知道的新API:<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue/2016088-concurrentperform" rel="noopener ugc nofollow" target="_blank">DispatchQueue.concurrentPerform</a></code>。这个小巧精致的API让我们可以一起运行批量工作，并为我们处理所有的并发性。</p><p id="5122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一起来探索一下。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="eccf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">理论上的并发执行</h1><p id="1d6f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当使用一个新的API时，首先要做的是阅读它的文档:</p><blockquote class="nd ne nf"><p id="cea9" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">该方法实现了一个<strong class="lb iu">高效并行</strong> for循环。分派队列执行提交的块指定的次数，并且<strong class="lb iu">在返回之前等待所有迭代完成</strong>。如果目标队列是并发队列，那么这些块并行运行，因此必须是可重入安全的。— <a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue/2016088-concurrentperform" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote><p id="4ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里强调了两条主要信息:</p><ol class=""><li id="a3fd" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">什么是T1:一个有效的并行T2循环。</li><li id="249a" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">它的行为:它等待所有的计算完成。</li></ol><p id="d445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二点特别有趣:我们不必为了等待所有生成的线程完成而弄乱锁、信号量、障碍和类似的工件。API为我们做了这些。然而，我们可能不得不使用这些控制机制来访问共享资源。</p><h2 id="4a3c" class="ny mh it bd mi nz oa dn mm ob oc dp mq li od oe ms lm of og mu lq oh oi mw oj bi translated">探索签名</h2><p id="50eb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个函数的特征是:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="079d" class="ny mh it ly b gy oo op l oq or">concurrentPerform(iterations: Int, execute work: (Int) -&gt; Void)</span></pre><p id="62f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">iterations</code>参数告诉<code class="fe lv lw lx ly b">DispatchQueue</code>模块<code class="fe lv lw lx ly b">execute</code>必须执行多少次。<code class="fe lv lw lx ly b">execute</code>模块将<code class="fe lv lw lx ly b">Int</code>作为参数。这是当前迭代的索引。</p><p id="8117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个参数对于决定我们想要操作集合中的哪个元素或部分很有用。例如，让我们分析这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="e9d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码为<code class="fe lv lw lx ly b">Array</code>类型添加了一个非常简单的特性:并发运行<code class="fe lv lw lx ly b">map</code>操作的可能性。让我们来看一下突出显示的步骤:</p><ol class=""><li id="32e6" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">检查我们是否需要运行一些操作。如果数组为空，<code class="fe lv lw lx ly b">mapping</code>将返回一个空数组。</li><li id="910f" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">准备要返回的数组。通过一个<code class="fe lv lw lx ly b">map</code>操作，我们知道返回的数组必须与输入的数组大小相同。我们通过将所有值预设为第一个元素的映射值来准备它。我们可以安全地这样做，因为我们知道数组不是空的。</li><li id="9885" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">使用<code class="fe lv lw lx ly b">concurrentPerform</code>对所有元件运行<code class="fe lv lw lx ly b">map</code>功能。迭代次数为<code class="fe lv lw lx ly b">self.count</code>。注意这个块的<code class="fe lv lw lx ly b">index</code>参数是如何被用来访问<code class="fe lv lw lx ly b">self</code>变量和索引目标数组的。</li></ol><p id="6cf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ng">注意:要返回的数组是在每次迭代中从不同的线程中访问的。这不是线程安全的。为此我们不得不引入</em> <code class="fe lv lw lx ly b"><em class="ng">os_unfair_lock</em></code> <em class="ng">来防止应用崩溃。</em></p><p id="37fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新功能的用法与标准的<code class="fe lv lw lx ly b">map</code>用法没有什么不同。我们使用<code class="fe lv lw lx ly b">concurrentMap</code>代替标准<code class="fe lv lw lx ly b">map.</code></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="89c0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">表演</h1><p id="17e5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在真正的问题是使用这种方法是否值得麻烦。</p><p id="6f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如在许多工程环境中一样，这取决于您的问题。让我们来看一些基准测试，在这些测试中，我们运行以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="d2e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们只取数组<code class="fe lv lw lx ly b">10</code>、<code class="fe lv lw lx ly b">100</code>、<code class="fe lv lw lx ly b">1_000</code>、<code class="fe lv lw lx ly b">10_000</code>、<code class="fe lv lw lx ly b">100_000</code>和<code class="fe lv lw lx ly b">1_000_000</code>并计算它们的平方——首先用一个<code class="fe lv lw lx ly b">concurrentMap</code>然后用一个连续的<code class="fe lv lw lx ly b">map</code>。结果时间为:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="97d7" class="ny mh it ly b gy oo op l oq or">// 10 elements:<strong class="ly iu"><br/>Concurrent Map time: 0.3299713134765625 ms<br/>Default Map time: 0.03802776336669922 ms</strong></span><span id="6f7e" class="ny mh it ly b gy ou op l oq or">// 100 elements:<br/><strong class="ly iu">Concurrent Map time: 0.09799003601074219 ms<br/>Default Map time: 0.04303455352783203 ms</strong></span><span id="c191" class="ny mh it ly b gy ou op l oq or">// 1000 elements:<br/><strong class="ly iu">Concurrent Map time: 0.3190040588378906 ms<br/>Default Map time: 0.46896934509277344 ms</strong></span><span id="69e6" class="ny mh it ly b gy ou op l oq or">// 10000 elements:<br/><strong class="ly iu">Concurrent Map time: 3.3109188079833984 ms<br/>Default Map time: 2.4089813232421875 ms</strong></span><span id="adec" class="ny mh it ly b gy ou op l oq or">// 100000 elements:<br/><strong class="ly iu">Concurrent Map time: 30.785083770751953 ms<br/>Default Map time: 23.782014846801758 ms</strong></span><span id="6eed" class="ny mh it ly b gy ou op l oq or">// 1000000 elements:<br/><strong class="ly iu">Concurrent Map time: 311.1530542373657 ms<br/>Default Map time: 246.08397483825684 ms</strong></span></pre><p id="8fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有点令人失望，不是吗？似乎我们并没有从使用并行方法中获得什么。另一方面，我们为线程跳跃支付了大量的开销。</p><p id="1d0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要原因是我们使用锁来避免崩溃。锁创建了一个单点同步，基本上将并发计算移回串行计算。另一点需要考虑的是，我们在<code class="fe lv lw lx ly b">execute</code>区块执行的工作速度极快。这只是一个简单的乘法，并且该操作不需要大量的CPU时间。</p><h2 id="7a88" class="ny mh it bd mi nz oa dn mm ob oc dp mq li od oe ms lm of og mu lq oh oi mw oj bi translated">繁重的作业</h2><p id="d1ca" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们试着稍微修改一下我们的代码，将<code class="fe lv lw lx ly b">square</code>操作转换成计算量更大的操作——也许添加一个<code class="fe lv lw lx ly b">0.01 sec</code>的<code class="fe lv lw lx ly b">sleep</code>。</p><p id="b144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基准测试代码现在看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="e3ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会注意到，我们刚刚在第8行和第15行添加了几个<code class="fe lv lw lx ly b">Thread.sleep</code>调用。</p><p id="2482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="f359" class="ny mh it ly b gy oo op l oq or">// 10 elements:<br/><strong class="ly iu">Concurrent Map time: 36.27192974090576 ms<br/>Default Map time: 114.11595344543457 ms</strong></span><span id="64c8" class="ny mh it ly b gy ou op l oq or">// 100 elements:<br/><strong class="ly iu">Concurrent Map time: 159.67702865600586 ms<br/>Default Map time: 1161.31591796875 ms</strong></span><span id="c5df" class="ny mh it ly b gy ou op l oq or">// 1000 elements:<br/><strong class="ly iu">Concurrent Map time: 1427.2420406341553 ms<br/>Default Map time: 11396.499037742615 ms</strong></span><span id="a33b" class="ny mh it ly b gy ou op l oq or">// 10000 elements:<br/><strong class="ly iu">Concurrent Map time: 13940.824031829834 ms<br/>Default Map time: 113169.63696479797 ms</strong></span></pre><p id="194b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ng">注意:使用</em> <code class="fe lv lw lx ly b"><em class="ng">100_000</em></code> <em class="ng">和</em> <code class="fe lv lw lx ly b"><em class="ng">1_000_000</em></code> <em class="ng">元素执行顺序代码需要很长时间。因此，我阻止了它。我们已经可以看到</em> <code class="fe lv lw lx ly b"><em class="ng">concurrentPerform</em></code> <em class="ng">即使在这么小的样本上也有多好了。</em></p><p id="4715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们正在使用一个繁重的操作，结果是显而易见的:<code class="fe lv lw lx ly b">concurrentMap</code>比标准的<code class="fe lv lw lx ly b">map</code>操作好一个数量级——即使只有几个元素！</p><h2 id="484d" class="ny mh it bd mi nz oa dn mm ob oc dp mq li od oe ms lm of og mu lq oh oi mw oj bi translated">定量</h2><p id="f0b3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">还有一个用例是<code class="fe lv lw lx ly b">concurrentPerform</code>优于标准的顺序方法。</p><p id="182c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过分析锁和并发性的问题，我们可以看到:</p><ol class=""><li id="0820" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">做一个手术。</li><li id="1349" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">拥有结果数组上的锁。</li><li id="d54c" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">设置结果。</li><li id="9b49" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">打开锁。</li></ol><p id="8a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们基本上是在为每一个操作支付锁定和解锁的成本。</p><p id="d5a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用并发能力的另一种方法是将多个操作成批处理，并且每批只获取一次锁，即使是少量操作也是如此。</p><p id="4ac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下这个例子，在这个例子中，我们对<code class="fe lv lw lx ly b">10_000_000</code>整数的平均值进行批处理计算:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="3d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们创建了一个包含1000万个整数的数组，然后首先使用标准的顺序方法，然后使用并发方法来计算平均值。</p><p id="250d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的部分在第17行和第33行之间。在这里，我们定义批处理大小并准备一个名为<code class="fe lv lw lx ly b">temp</code>的目标数组。</p><p id="60ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在该模块中，我们根据<code class="fe lv lw lx ly b">iteration</code>指数计算指定批次的平均值。例如，您可以看到第一次迭代计算了从<code class="fe lv lw lx ly b">0</code>到<code class="fe lv lw lx ly b">99_999</code>的元素的平均值。</p><p id="2cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将结果存储在<code class="fe lv lw lx ly b">temp</code>数组中，只为<code class="fe lv lw lx ly b">10_000</code>操作获取一次锁。基准的输出是:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="ab55" class="ny mh it ly b gy oo op l oq or">The sequential average is: <strong class="ly iu">0.0027276. </strong>It tooks <strong class="ly iu">2.6642 </strong>seconds<br/>The concurrent average is: <strong class="ly iu">0.0027276</strong>. It tooks <strong class="ly iu">1.4912</strong> seconds</span></pre><p id="20fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到并发平均时间大约是顺序平均时间的一半。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e0d7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="1b61" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在今天的文章中，我们探索了<code class="fe lv lw lx ly b">DispatchQueue.concurrentPerform</code> API。我在本周之前不知道它，我认为它是一项宝贵的知识，因为它可以加快我们的算法。</p><p id="65b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们研究了几个使用这种方法非常有效的用例:当处理繁重的操作时，以及当我们可以一起批处理快速操作时。</p></div></div>    
</body>
</html>