<html>
<head>
<title>3 Practical Uses of Object Destructuring in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中对象析构的3个实际应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-practical-uses-of-object-destructuring-in-javascript-a2c34ce3367b?source=collection_archive---------2-----------------------#2019-05-26">https://betterprogramming.pub/3-practical-uses-of-object-destructuring-in-javascript-a2c34ce3367b?source=collection_archive---------2-----------------------#2019-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5950" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些析构模式编写更干净的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba6e5f70dec373b77b05fd3aa2fa3f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2IQ-Z_PnAS_CEBa72s-5Q.png"/></div></div></figure><p id="d41d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，您可能已经非常熟悉JavaScript中的析构了！它在2015年的<a class="ae lq" href="https://www.ecma-international.org/ecma-262/6.0/#sec-destructuring-assignment" rel="noopener ugc nofollow" target="_blank"> ES6规范</a>中出现，但是如果你需要温习它，<a class="ae lq" href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/" rel="noopener ugc nofollow" target="_blank"> Mozilla有一篇关于它如何工作的很棒的深入文章</a>。</p><p id="22f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，知道析构如何工作并不等同于知道如何使用它。这里有三种析构模式，你可以用它们来使你的代码更干净、更健壮、更易读！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5f5a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">1.命名函数参数</h1><p id="9abd" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">命名参数是处理函数参数的另一种方法，而不是通过位置。您只需通过名称指定参数，而不是按照函数签名的顺序对参数进行排序。例如，在Python中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="30fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，参数的顺序并不重要——您只需通过名称来指定它们。与位置参数相比，命名参数的优势在于:</p><ol class=""><li id="885d" class="mx my it kw b kx ky la lb ld mz lh na ll nb lp nc nd ne nf bi translated">调用该函数时，可以省略一个或多个参数</li><li id="b9c0" class="mx my it kw b kx ng la nh ld ni lh nj ll nk lp nc nd ne nf bi translated">传入参数时，顺序并不重要。</li><li id="db40" class="mx my it kw b kx ng la nh ld ni lh nj ll nk lp nc nd ne nf bi translated">当调用可能存在于别处的函数时，代码更加可读</li></ol><p id="c0ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然JavaScript中不存在真正的命名参数，但我们可以使用析构模式来实现这三个相同的好处。下面是与上面相同的代码，但使用的是JavaScript:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7420" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种模式符合我们对命名参数的所有目标。我们可以省略参数<code class="fe nl nm nn no b">c</code>，顺序并不重要，我们通过引用它们的名称来分配我们的参数。这一切都是通过对象析构实现的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ebc2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">2.清晰地解析服务器响应</h1><p id="a1fa" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们通常只关心数据块，甚至是服务器响应的数据块中的一个特定值。如果是这样的话，你可以使用析构只获取那个值，而忽略服务器通常发送回来的许多其他东西。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4dc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种模式允许您在解析参数时从对象中提取值。你还可以免费设置默认值！这就引出了第三种模式…</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0656" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">3.在分配期间设置默认值</h1><p id="8d24" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在给变量或常量赋值时，一个常见的情况是，如果作用域中当前不存在其他值，就使用默认值。</p><p id="0c6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在进行析构之前，您可以像这样做来获得想要的行为:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="d646" class="nt lz it no b gy nu nv l nw nx">// old way of setting up default values<br/>var nightMode = userSettings.nightMode || false</span></pre><p id="71dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这需要为每项任务编写一行单独的代码。通过析构，你可以一次处理所有的赋值和它们的默认值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="babf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种析构模式可以应用于<a class="ae lq" href="https://medium.freecodecamp.org/the-basics-of-destructuring-props-in-react-a196696f5477" rel="noopener ugc nofollow" target="_blank">在React组件中设置状态！</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="4dab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望您能够将这些模式应用到您的代码中！查看下面的链接，了解更多关于析构的知识。</p><h2 id="be54" class="nt lz it bd ma ny nz dn me oa ob dp mi ld oc od mk lh oe of mm ll og oh mo oi bi translated">了解更多！</h2><div class="oj ok gp gr ol om"><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">ES6深度:解构- Mozilla黑客-网络开发者博客</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">ES6 In Depth是一个系列，介绍JavaScript编程语言在第6版中增加的新特性…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">hacks.mozilla.org</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://medium.freecodecamp.org/the-basics-of-destructuring-props-in-react-a196696f5477" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">学习React中析构道具的基础知识</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">当我第一次了解ES6时，我很犹豫要不要开始使用它。我听说了很多关于……</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.freecodecamp.org</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>