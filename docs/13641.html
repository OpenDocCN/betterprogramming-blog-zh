<html>
<head>
<title>Implementing Leader Election in Your Distributed Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在分布式系统中实现领导者选举</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-leader-election-in-your-distributed-systems-5422d3123cf3?source=collection_archive---------11-----------------------#2022-09-13">https://betterprogramming.pub/implementing-leader-election-in-your-distributed-systems-5422d3123cf3?source=collection_archive---------11-----------------------#2022-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a8a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无需重新发明轮子就能在系统中添加分布式共识的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d8edbfa5f5a6bb1f71416a286f56002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItasC8nu1_IFcrm28ZnVkA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自:<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">unsplash.com</a></p></figure><p id="ef00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算机科学中，系统变得越来越复杂。许多参与者经常相互沟通，以提供业务服务并为客户创造价值。最大的挑战之一是协调参与者(例如，业务专家、流程、应用程序或线程)。</p><p id="9821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决软件开发中的这个问题，我们过去依赖于操作系统同步原语，为我们的程序线程使用低级机制:</p><ul class=""><li id="c541" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">互斥锁(<a class="ae ky" href="https://github.com/torvalds/linux/blob/master/include/linux/mutex.h" rel="noopener ugc nofollow" target="_blank"> Linux </a> / <a class="ae ky" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-mutex-objects" rel="noopener ugc nofollow" target="_blank"> windows </a>):独占线程访问。</li><li id="28e2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">semaphore(<a class="ae ky" href="https://github.com/torvalds/linux/blob/master/include/linux/semaphore.h" rel="noopener ugc nofollow" target="_blank">Linux</a>/<a class="ae ky" href="https://docs.microsoft.com/en-us/windows/win32/sync/using-semaphore-objects" rel="noopener ugc nofollow" target="_blank">windows</a>):资源访问同步工具。</li><li id="8df0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">带有重试循环的spin lock(<a class="ae ky" href="https://github.com/torvalds/linux/blob/master/kernel/locking/spinlock.c" rel="noopener ugc nofollow" target="_blank">Linux</a>/<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/standard/threading/spinlock" rel="noopener ugc nofollow" target="_blank">windows</a>)线程锁。</li><li id="b843" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">barrier(<a class="ae ky" href="https://github.com/torvalds/linux/blob/master/kernel/sched/membarrier.c" rel="noopener ugc nofollow" target="_blank">Linux</a>/<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/standard/threading/barrier" rel="noopener ugc nofollow" target="_blank">windows</a>)不同相位的多线程同步。</li></ul><p id="b1f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些机制对于在同一台机器上同步线程都是理想的。</p><p id="ba29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，这不适用于分布式系统。CAP定理指出，在分布式系统中，您无法实现一致性(所有节点上的数据版本相同)、可用性(100%的请求得到响应)和分区容差(系统在少数节点关闭的情况下仍能工作)。</p><h1 id="8def" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">领导人选举</h1><p id="fb15" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">就像操作系统可以为线程提供额外的能力一样，在分布式系统中，我们需要一个健壮的机制来选择一个服务进行协调:一个领导者选举。</p><p id="32e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是领导人选举应该做的:</p><ul class=""><li id="e3c0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">选举应该终止。</li><li id="b3af" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">所有的参与者都应该认同领导者的身份。</li><li id="6011" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">领导者应该是独一无二的。</li></ul><p id="c2b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经实现了许多一致性算法来支持这种选择，这取决于拓扑(例如，网状对环形对完整网络)以及系统的假设和需求。</p><h1 id="b086" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">赫希伯格-辛克莱算法</h1><p id="4841" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在环形拓扑中(每个节点有两个邻居)，每个节点比较它们的id，在O(n log(n))个消息之后，最高的一个获胜。</p><h1 id="f266" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">恶霸算法</h1><p id="3196" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这个同步算法假设每个节点都有一个唯一的ID，并且知道所有的参与者ID。</p><p id="3f51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最高ID的节点通过向所有其他节点或较低ID的节点广播消息来宣布自己是“选举”的获胜者。然后，它等待响应，如果没有响应，它就宣布自己是赢家。</p><p id="5601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当高ID节点启动、领导者失败或心跳消息失败时，将调用选举。</p><h1 id="b441" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Raft算法</h1><p id="dedb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Raft算法允许协商一致(所有节点同意相同的信息)和领导者选举。每个节点可以是领导者、追随者或候选人(在选举期间)。</p><p id="9254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">领导者负责发送心跳消息和日志，供追随者复制。</p><p id="7c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在追随者超时期满之前没有接收到心跳，则追随者(成为候选人)可以触发新的领导者选举。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/c1b5ae20fb01315a97703f97b9f4f4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qNjGn396aIekP-HlX2p1Aw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">领袖S2坠机模拟(牛逼<a class="ae ky" href="https://raft.github.io/" rel="noopener ugc nofollow" target="_blank">raft.github.io/</a>筏选领袖模拟)</p></figure><h1 id="05bb" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">我如何在我的分布式服务中使用它？</h1><p id="e37d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于现实世界的实现，您可能更喜欢使用现有的实现领导者选举算法的分布式同步系统，而不是编写自己的实现。</p><p id="fae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将看到如何使用<a class="ae ky" href="https://github.com/apache/zookeeper" rel="noopener ugc nofollow" target="_blank"> Apache开源项目ZooKeeper </a>(由ZooKeeper原子广播算法提供支持)为您的节点实现领导者选举。</p><p id="acde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个应用程序，需要处理一个沉重的支付过程。有必要确保我们总是有一个应用程序准备好面对任务，但它永远不会做两次。</p><p id="6a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将定义我们的支付(占位符)业务场景和客户端，它将与ZooKeeper通信以触发选举并监控领导者的身份。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="00e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要一个工作人员将leader election客户端与我们的业务处理器连接起来，确保只有leader可以处理付款。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="43d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的分布式leader payment worker现在已经准备好接受测试:</p><ul class=""><li id="77f8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们将在一个小的<code class="fe nj nk nl nm b">Program.cs</code>中实例化我们的领导人选举、工人和支付处理器。</li><li id="3047" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用docker栈部署本地Zookeeper集群</li></ul><p id="b347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧！我们现在有了一个容错服务，可以通过部署和复制来管理我们的复杂用例，并在我们的应用节点之间进行可靠的协调。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="04cb" class="nr mk it nm b gy ns nt l nu nv">docker stack deploy -c stack.yml zookeeper</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="80bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">领导者选举是一个强大的工具，可以为您的分布式系统增加容错和一致性。</p><p id="ebc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像在软件工程中一样，我们总会有一个权衡。您的系统现在可能依赖于您必须维护的外部群集服务。新问题可能会影响你的系统(更复杂，分裂大脑的危险(网络分裂导致两个领导者)，以及时钟同步问题)。</p><p id="f8c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果成本太高，可以设想其他同步机制(幂等操作、乐观锁定、悲观锁定)</p><h1 id="3fd9" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">参考</h1><div class="nw nx gp gr ny nz"><a href="https://zookeeper.apache.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">阿帕奇动物园管理员</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">Apache ZooKeeper Apache ZooKeeper是一个致力于开发和维护开源服务器的项目，该服务器支持高度…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">zookeeper.apache.org</p></div></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://en.wikipedia.org/wiki/Bully_algorithm" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">恶霸算法—维基百科</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">在分布式计算中，恶霸算法是一种从群体中动态选举协调者或领导者的方法</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://en.wikipedia.org/wiki/Raft_%28algorithm%29" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">Raft(算法)—维基百科</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">Raft是一种共识算法，旨在替代Paxos系列算法。这意味着更多…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">en.wikipedia.org</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>