<html>
<head>
<title>Build a Realtime PWA with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React构建实时PWA</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-realtime-pwa-with-react-99e7b0fd3270?source=collection_archive---------0-----------------------#2018-04-08">https://betterprogramming.pub/build-a-realtime-pwa-with-react-99e7b0fd3270?source=collection_archive---------0-----------------------#2018-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个应用程序来显示BTC、LTC和ETH当前和过去的价格信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0e87f8b68afeb23a9b80d85d4840b1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ws4yYvsI2i4lYZNrbw7BA.jpeg"/></div></div></figure><p id="ac8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">渐进式网络应用程序(PWAs)是结合了网络和应用程序优点的体验。他们使用服务工人、HTTPS、清单文件和应用外壳架构向web应用提供本地应用体验。</p><p id="8fad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将构建一个名为PusherCoins的PWA。PusherCoins使用来自cryptocompare.com<a class="ae lq" href="http://cryptocompare.com/" rel="noopener ugc nofollow" target="_blank">的数据显示比特币(BTC)、莱特币(LTC)和以太币(ETH)的当前和过去价格信息。下面可以看到一个演示。当前的比特币、以太币和莱特币价格每10秒更新一次，实时变化，并通过</a><a class="ae lq" href="http://pusher.com/" rel="noopener ugc nofollow" target="_blank">推送器</a>连接到其他连接的客户端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/80eeca199ca57d51f9255b3f787e124e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5DOQ9kDKVAQWc7gl_5TXZw.gif"/></div></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="a7af" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用Create React应用程序构建PWA</h1><p id="f074" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们将在<a class="ae lq" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>的帮助下构建一个实时PWA。</p><p id="7991" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于刚刚开始使用React的开发人员来说，设置和配置他们的应用程序有困难是很常见的。<code class="fe mw mx my mz b">create-react-app</code>通过允许开发人员在很少或没有构建配置的情况下构建React应用，消除了所有这些问题。要获得一个可用的React应用程序，您只需安装npm模块并运行一个命令。</p><p id="64b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更重要的是,<code class="fe mw mx my mz b">create-react-app</code>的产品版本是一个全功能的渐进式Web应用程序。这是在集成到生产配置中的<code class="fe mw mx my mz b"><a class="ae lq" href="http://(https://github.com/goldhand/sw-precache-webpack-plugin)" rel="noopener ugc nofollow" target="_blank">sw-precache-webpack-plugin</a></code>的帮助下完成的。</p><p id="75ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们开始构建React应用程序。用以下命令安装<code class="fe mw mx my mz b">create-react-app</code>工具:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="cdc5" class="ne ma it mz b gy nf ng l nh ni">npm install -g create-react-app</span></pre><p id="69d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦安装过程完成，您现在可以使用命令<code class="fe mw mx my mz b">create-react-app pushercoins</code>创建一个新的React应用程序。</p><p id="13b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将生成一个新文件夹，其中包含运行React应用程序所需的所有文件和一个服务人员文件。在<code class="fe mw mx my mz b">public</code>文件夹中也创建了一个清单文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/e00e220fdf97feace920671bb1f0947f.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*A_T7AHHgtVLD_o1fe1s-RQ.png"/></div></figure><p id="5cc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mw mx my mz b">public</code>文件夹中的<code class="fe mw mx my mz b">manifest.json</code>文件是一个简单的JSON文件，它让你能够控制你的应用程序如何显示给用户，并定义它在启动时的外观。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="79ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们通过链接到<code class="fe mw mx my mz b">index.html</code>文件的第12行来通知应用程序<code class="fe mw mx my mz b">manifest.json</code>文件。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="691f" class="ne ma it mz b gy nf ng l nh ni">&lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json"&gt;</span></pre><p id="a27f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们浏览一下<code class="fe mw mx my mz b">registerServiceWorker.js</code>文件，看看服务工作者文件是如何工作的。服务人员文件可以在<a class="ae lq" href="https://github.com/yomete/pushercoins/blob/master/src/registerServiceWorker.js" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的<code class="fe mw mx my mz b">src</code>文件夹中看到。</p><p id="127b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">服务工作者代码基本上为React应用程序注册了一个服务工作者。我们首先通过将返回true或falsy值的<code class="fe mw mx my mz b">isLocalhost</code>常量值检查应用程序是否由本地主机提供。只有在React应用程序处于生产模式并且浏览器支持服务人员时，<code class="fe mw mx my mz b">register()</code>功能才有助于将服务人员注册到React应用程序。<code class="fe mw mx my mz b">unregister()</code>功能有助于取消服务人员的注册。</p><p id="360e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看服务人员是否真的工作。为此，我们需要为生产准备React应用程序，因为服务工作者代码只在生产模式下工作。<code class="fe mw mx my mz b">npm run build</code>命令对此有所帮助。</p><p id="444a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该命令将用于生产的应用程序构建到<code class="fe mw mx my mz b">build</code>文件夹中，并在生产模式下正确绑定React，并优化构建以获得最佳性能。它还注册服务人员。运行该命令，终端的输出应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ab2bed4cea6c44b702bd2e611f49fece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*QsrBtSRO_2HtrvZJgjN4iA.png"/></div></figure><p id="3f0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到React应用程序中文件的大小，最重要的是如何在静态服务器的帮助下运行应用程序。我们将使用<a class="ae lq" href="https://www.npmjs.com/package/serve" rel="noopener ugc nofollow" target="_blank"> serve </a> npm包来，等待它，serve(😀)的React应用。因此，使用以下命令在您的计算机上安装serve，并为应用程序设置静态服务器:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="6dfe" class="ne ma it mz b gy nf ng l nh ni">npm i serve -g</span><span id="c74b" class="ne ma it mz b gy nn ng l nh ni">serve -s build</span></pre><p id="31e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的应用程序应该在<a class="ae lq" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>上启动并运行。那么我们如何检查一个站点是否是PWA呢？我们可以通过检查开发人员工具中“应用程序”选项卡中的“服务人员”部分来做到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/ebd6cd81505ef36348ac353a5a228ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjlC2ilyEsqxFAsHY0wWsw.png"/></div></div></figure><p id="ae10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以使用<a class="ae lq" href="https://developers.google.com/web/tools/lighthouse/" rel="noopener ugc nofollow" target="_blank"> Lighthouse </a>工具进行检查。Lighthouse是一个<a class="ae lq" href="https://github.com/GoogleChrome/lighthouse" rel="noopener ugc nofollow" target="_blank">开源</a>，用于提高网页质量的自动化工具。它可以对性能、可访问性和渐进式Web应用程序进行审计。Lighthouse目前只作为谷歌Chrome浏览器的扩展和T21的npm包提供。</p><p id="810f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我使用Lighthouse扩展为生产中新创建的React应用程序生成了一个报告，并得到了以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/05199842f90eb28a5ef7efa90cf8eb83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKo4r4aXExehu2wMvfqf1Q.png"/></div></div></figure><p id="a6c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React应用程序在PWA部分获得了91分(满分为100分)，这并不算糟糕。所有的审计都通过了，只有一项与HTTPS有关，但现在无法实施，因为该应用程序仍在本地环境中。</p><p id="7a91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们知道了如何检查一个应用程序是否是PWA，让我们继续构建实际的应用程序。因为我们将使用React构建这个PWA，所以我们从React组件的角度来考虑非常重要。</p><p id="c965" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，React应用程序将分为三个组件。</p><ol class=""><li id="761f" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">包含显示BTC、瑞士联邦理工学院和长期资本公司过去价格所需的所有代码。</li><li id="ba76" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe mw mx my mz b">Today.js</code>包含显示BTC、瑞士联邦理工学院和长期资本公司当前价格所需的所有代码。</li><li id="c83e" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe mw mx my mz b">App.js</code>同时拥有<code class="fe mw mx my mz b">History.js</code>和<code class="fe mw mx my mz b">Today.js</code></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/2ac49b98d9a830b53b5bd34875b92554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9V3gkK0lmLWxQm120_FGeA.png"/></div></div></figure><p id="6334" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，让我们继续构建应用程序。我们需要在<code class="fe mw mx my mz b">src</code>文件夹中创建两个文件夹，<code class="fe mw mx my mz b">Today</code>和<code class="fe mw mx my mz b">History</code>。在新创建的文件夹中，分别创建文件<code class="fe mw mx my mz b">Today.js</code>、<code class="fe mw mx my mz b">Today.css</code>和<code class="fe mw mx my mz b">History.js</code>、<code class="fe mw mx my mz b">History.css</code>。您的项目目录应该如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b9af32f10c68d21e1de9678111aa2142.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*7bfrh4UetV88FuH3KZrjQA.png"/></div></figure><p id="6438" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始使用<code class="fe mw mx my mz b">Today</code>和<code class="fe mw mx my mz b">History</code>组件之前，让我们构建应用程序外壳。</p><blockquote class="od oe of"><p id="ccd7" class="ku kv og kw b kx ky ju kz la lb jx lc oh le lf lg oi li lj lk oj lm ln lo lp im bi translated"><em class="it">应用程序外壳是支持用户界面所需的最少HTML、CSS和JavaScript，当离线缓存时，可以确保用户在重复访问时获得即时、可靠的良好性能。你可以在这里</em>  <em class="it">阅读更多关于app炮弹</em> <a class="ae lq" href="https://developers.google.com/web/fundamentals/architecture/app-shell" rel="noopener ugc nofollow" target="_blank"> <em class="it">。</em></a></p></blockquote><p id="bf63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开<code class="fe mw mx my mz b">App.js</code>文件，用以下代码替换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c0cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应将<code class="fe mw mx my mz b">App.css</code>文件替换为以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="de8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还将使用布尔玛CSS框架，所以将下面的代码行添加到您的<code class="fe mw mx my mz b">public</code>文件夹中的<code class="fe mw mx my mz b">index.html</code>中:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="cf63" class="ne ma it mz b gy nf ng l nh ni">&lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.4.3/css/bulma.min.css<!-- -->"&gt;</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="80b7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创建反应组件</h1><p id="70ef" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">接下来，打开<code class="fe mw mx my mz b">Today.js</code>文件，因为我们很快就要为该组件编写代码了。那么这个组件是做什么的？</p><p id="540b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它负责从Cryptocompare API获取比特币、以太币和莱特币的当前价格，并将其显示在前端。让我们写代码。</p><p id="f109" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们做的第一件事是使用ES6 <code class="fe mw mx my mz b">import</code>导入React及其组件模块，我们还导入axios。Axios用于向Cryptocompare API发出API请求，可以通过在您的终端中运行<code class="fe mw mx my mz b">npm install axios</code>来安装</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="ba14" class="ne ma it mz b gy nf ng l nh ni">import React, { Component } from 'react';<br/>    import './Today.css'<br/>    import axios from 'axios'</span></pre><p id="d2c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来要做的是创建一个名为<code class="fe mw mx my mz b">Today</code>的<a class="ae lq" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"> ES6类</a>，它从<code class="fe mw mx my mz b">react</code>扩展了组件模块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3100" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码块中，我们从React导入了<code class="fe mw mx my mz b">react</code>和<code class="fe mw mx my mz b">component</code>类。我们还导入了将用于API请求的<code class="fe mw mx my mz b">axios</code>。在<code class="fe mw mx my mz b">componentWillMount</code>函数中，我们发送一个API请求来获取当前的加密货币汇率。来自API的响应将用于设置状态值。</p><p id="63b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不要忘记组件的CSS。打开<code class="fe mw mx my mz b">Today.css</code>并输入以下CSS代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bcfb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步是为<code class="fe mw mx my mz b">History.js</code>编写代码。该组件负责向我们显示过去五天的BTC、瑞士联邦理工学院和长期资本公司的价格。我们将使用<code class="fe mw mx my mz b">axios</code>包和<code class="fe mw mx my mz b">moment</code>包来格式化日期。Moment.js可以通过在您的终端中运行<code class="fe mw mx my mz b">npm install moment</code>来安装。打开<code class="fe mw mx my mz b">History.js</code>文件，我们做的第一件事是使用ES6 <code class="fe mw mx my mz b">import</code>导入React及其组件模块，我们还导入axios和<code class="fe mw mx my mz b">Moment.js</code>。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="a9d5" class="ne ma it mz b gy nf ng l nh ni">import React, { Component } from 'react';<br/>    import './History.css'<br/>    import axios from 'axios'<br/>    import moment from 'moment'</span></pre><p id="40a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像我们在<code class="fe mw mx my mz b">Today.js</code>组件中所做的一样，我们将创建一个名为<code class="fe mw mx my mz b">History</code>的<a class="ae lq" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"> ES6类</a>，它从<code class="fe mw mx my mz b">react</code>扩展了组件模块，并且还创建了一些将与<code class="fe mw mx my mz b">this</code>绑定的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="364a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如在上面的代码块中看到的，我们已经定义了state值，这些值将保存BTC、ETH和LTC过去五天的价格信息。我们还创建了向Cryptocompare返回API请求的函数。现在，让我们编写代码，利用上面的函数，在州中存储各种价格，并呈现它们。</p><p id="f6a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，Cryptocompare目前没有一个API端点，允许您获取价格信息的日期范围。您必须获得过去五天的时间戳，然后分别使用它们来获得所需的数据。一种变通方法是使用moment.js，通过使用<code class="fe mw mx my mz b">.subtract</code> <a class="ae lq" href="https://momentjs.com/docs/#/manipulating/subtract/" rel="noopener ugc nofollow" target="_blank">方法</a>和<code class="fe mw mx my mz b">.unix</code> <a class="ae lq" href="https://momentjs.com/docs/#/displaying/unix-timestamp/" rel="noopener ugc nofollow" target="_blank">方法</a>来获得您想要的特定日期的时间戳。举例来说，要获得两天前的时间戳，您应该这样做:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="38b9" class="ne ma it mz b gy nf ng l nh ni">moment().subtract(2, 'days').unix();</span></pre><p id="0440" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，让我们继续剩下的代码，写出获取过去5天的值的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2b83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们上面有五个函数，它们基本上只是使用<code class="fe mw mx my mz b">moment.js</code>来获取所需的日期，然后将该日期传递给我们上面首先创建的函数，以从Cryptocompare获取价格信息。我们使用<code class="fe mw mx my mz b">axios.all</code>和<code class="fe mw mx my mz b">axios.spread</code>，这是一种用回调处理并发请求的方式。这些功能将在<code class="fe mw mx my mz b">componentWillMount</code>功能中运行。</p><p id="11c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，对于<code class="fe mw mx my mz b">History.js</code>，我们将编写渲染函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5dcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以运行<code class="fe mw mx my mz b">npm start</code>命令在<a class="ae lq" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>查看应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/71e24e6a120eedcfb698c9ffd374d340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DsCGLXXKYhm2dBwUNcGiIg.png"/></div></div></figure><p id="5013" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以快速检查一下，看看这个应用程序作为PWA的当前状态如何。请记住，我们有一个服务工作者文件，它当前缓存了该应用程序所需的所有资源。因此，您可以运行<code class="fe mw mx my mz b">npm run build</code>命令将应用程序置于生产模式，并使用Lighthouse检查其PWA状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/7b682b1a9a635e2dfc535bc1cbeb85c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S04VDqdUvl2Yc6o1DZh4XA.png"/></div></div></figure><p id="deed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到了91/100的分数。哇哦！唯一没有通过的审核是HTTPS审核，因为该应用程序仍在本地服务器上，所以现在无法实施。</p><p id="9372" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的应用程序看起来不错，速度也很快(在&lt; 3s), let’s add real-time functionalities by adding Pusher.</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="b093" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Make It Real-time With Pusher</h1><p id="5036" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">By using Pusher, we can easily add real-time functionalities to the app. Pusher makes it simple to bind UI interactions to events that are triggered by any client or server. Let’s set up Pusher.</p><p id="dc08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Log into your <a class="ae lq" href="http://dashboard.pusher.com/" rel="noopener ugc nofollow" target="_blank">仪表板</a>上进行交互(或者<a class="ae lq" href="http://pusher.com/" rel="noopener ugc nofollow" target="_blank">如果你是新用户，创建一个新账户)并创建一个新的应用程序。复制你的<code class="fe mw mx my mz b">app_id</code>、<code class="fe mw mx my mz b">key</code>、<code class="fe mw mx my mz b">secret</code>和<code class="fe mw mx my mz b">cluster</code>，把它们存放在某个地方，因为我们以后会用到它们。</a></p><p id="d564" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要创建一个服务器来帮助触发Pusher事件，我们将使用Node.js创建一个服务器。在项目目录的根目录下，创建一个名为<code class="fe mw mx my mz b">server.js</code>的文件，并键入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0be9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个简单的Node.js服务器，使用Express作为它的web框架。Pusher使用仪表板凭证进行初始化，并且还定义了各种API路由。不要忘记安装正在使用的软件包:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="3632" class="ne ma it mz b gy nf ng l nh ni">npm install express body-parser pusher</span></pre><p id="37d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要在<code class="fe mw mx my mz b">package.json</code>文件中添加一行代码，以便允许API代理。由于我们将运行后端服务器，我们需要找到一种方法来运行React应用程序和后端服务器。API代理有助于解决这个问题。</p><p id="cef5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要告诉开发服务器将任何未知请求(<code class="fe mw mx my mz b">/prices/new</code>)代理到开发中的API服务器，请在<code class="fe mw mx my mz b">scripts</code>对象之后立即向<code class="fe mw mx my mz b">package.json</code>添加一个<code class="fe mw mx my mz b">proxy</code>字段:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="192e" class="ne ma it mz b gy nf ng l nh ni">"proxy": "http://localhost:5000"</span></pre><p id="0b63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只需要实时生成当前价格，这意味着我们将处理<code class="fe mw mx my mz b">Today</code>组件，所以打开文件。Pusher JavaScript库是必需的，所以运行<code class="fe mw mx my mz b">npm install pusher-js</code>来安装它。</p><p id="0d9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先要做的是导入<code class="fe mw mx my mz b">pusher-js</code>包:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="90e1" class="ne ma it mz b gy nf ng l nh ni">import Pusher from 'pusher-js'</span></pre><p id="0ae0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mw mx my mz b">componentWillMount</code>方法中，我们使用之前从仪表板获得的凭证建立到Pusher的连接:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="1b27" class="ne ma it mz b gy nf ng l nh ni">// establish a connection to Pusher<br/>    this.pusher = new Pusher('APP_KEY', {<br/>        cluster: 'YOUR_CLUSTER',<br/>        encrypted: true<br/>    });<br/>    // Subscribe to the 'coin-prices' channel<br/>    this.prices = this.pusher.subscribe('coin-prices');</span></pre><p id="3ee8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要每10秒钟查询一次API来检索最新的价格信息。我们可以使用<code class="fe mw mx my mz b">setInterval</code>函数每10秒发送一个API请求，然后将该API请求的结果发送给Pusher，这样就可以将它广播给其他客户端。</p><p id="0828" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在创建setInterval函数之前，让我们创建一个简单的函数，它接受一个参数并将其发送到后端服务器API:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="4740" class="ne ma it mz b gy nf ng l nh ni">sendPricePusher (data) {<br/>   axios.post('/prices/new', {<br/>       prices: data<br/>   })<br/>     .then(response =&gt; {<br/>         console.log(response)<br/>     })<br/>     .catch(error =&gt; {<br/>         console.log(error)<br/>     })<br/>}</span></pre><p id="0718" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建<code class="fe mw mx my mz b">setInterval</code>函数。我们需要创建一个<code class="fe mw mx my mz b">componentDidMount</code>方法，这样我们就可以将区间代码放入其中:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="6e25" class="ne ma it mz b gy nf ng l nh ni">componentDidMount () {<br/>    setInterval(() =&gt; {<br/>        axios.get('https://min-api.cryptocompare.com/data/pricemulti?fsyms=BTC,ETH,LTC&amp;tsyms=USD')<br/>            .then(response =&gt; {<br/>                this.sendPricePusher (response.data)<br/>            })<br/>            .catch(error =&gt; {<br/>                console.log(error)<br/>            })<br/>    }, 10000)<br/> }</span></pre><p id="b23c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以现在，应用程序每10秒钟查询一次API，并将数据发送给Pusher，但我们仍然没有使应用程序实时化。我们需要实现实时功能，以便连接到应用程序的其他客户端/用户可以实时看到价格变化。这将通过使用推动器的<a class="ae lq" href="https://pusher.com/docs/client_api_guide/client_events#bind-events" rel="noopener ugc nofollow" target="_blank">绑定方法</a>来完成。</p><p id="997f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mw mx my mz b">componentDidMount</code>方法中，紧接在<code class="fe mw mx my mz b">setInterval</code>函数之后添加下面的代码:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="3688" class="ne ma it mz b gy nf ng l nh ni">// We bind to the 'prices' event and use the data in it (price information) to update the state values, thus, realtime changes <br/>this.prices.bind('prices', price =&gt; {<br/>   this.setState({ btcprice: price.prices.BTC.USD });<br/>   this.setState({ ethprice: price.prices.ETH.USD });<br/>   this.setState({ ltcprice: price.prices.LTC.USD });<br/> }, this);</span></pre><p id="0200" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码块侦听来自Pusher的数据，因为我们已经订阅了该通道，并使用它获得的数据来更新状态值，因此是实时变化。我们现在有一个渐进的实时应用程序！请参见下面的演示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/80eeca199ca57d51f9255b3f787e124e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5DOQ9kDKVAQWc7gl_5TXZw.gif"/></div></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="95fe" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">离线策略</h1><p id="ab54" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">现在，如果我们离线，我们的应用程序将无法发出API请求来获取各种价格。那么，我们如何确保即使网络出现故障，我们仍然能够看到一些数据呢？</p><p id="d47f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种方法是使用客户端存储。这将如何工作？我们将简单地使用localStorage来缓存数据。</p><p id="d4d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">localStorage使得在浏览器中存储值成为可能，这些值可以在浏览器会话中继续存在。它是<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API" rel="noopener ugc nofollow" target="_blank"> Web存储API </a>的一种，这是一种用于在浏览器中存储数据的键值对的API。它有一个限制，只能存储字符串。这意味着任何存储的数据都必须使用<code class="fe mw mx my mz b">JSON.stringify</code>进行<em class="og">字符串化</em></p><p id="d8b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，还有其他类型的客户端存储，如会话存储、Cookies、IndexedDB和WebSQL。本地存储可以用于这样的演示应用程序，但在生产应用程序中，建议使用IndexedDB这样的解决方案，它提供了更多功能，如更好的结构、多个表和数据库以及更多存储。</p><p id="5274" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目标是显示从<code class="fe mw mx my mz b">localStorage</code>开始的价格。这意味着我们必须将各种API请求的结果保存到<code class="fe mw mx my mz b">localStorage</code>中，并将状态设置为<code class="fe mw mx my mz b">localStorage</code>中的值。这将确保当网络不可用并且API请求失败时，我们仍然能够看到一些数据，尽管是缓存的数据。我们就这么做吧。打开<code class="fe mw mx my mz b">Today.js</code>文件，编辑API请求的回调函数中的代码，用下面的代码获取价格:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fd91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们本质上是将从API请求中获得的值存储到<code class="fe mw mx my mz b">localStorage</code>中。有了<code class="fe mw mx my mz b">localStorage</code>中的值，我们需要将状态值设置为<code class="fe mw mx my mz b">localStorage</code>中保存的值。在<code class="fe mw mx my mz b">componentDidMount</code>方法内部，在<code class="fe mw mx my mz b">setInterval</code>代码之前，添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e3c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码只在浏览器离线时执行。我们可以使用<code class="fe mw mx my mz b">navigator.onLine</code>检查互联网连接。属性返回浏览器的在线状态。该属性返回一个布尔值，其中<code class="fe mw mx my mz b">true</code>表示联机，<code class="fe mw mx my mz b">false</code>表示脱机。</p><p id="4954" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们也为<code class="fe mw mx my mz b">History.js</code>实现localStorage。我们需要将这些函数中API的值(<code class="fe mw mx my mz b">getTodayPrice(), getYesterdayPrice(), getTwoDaysPrice(), getThreeDaysPrice(), getFourDaysPrice()</code>)保存到<code class="fe mw mx my mz b">localStorage</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="543e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们本质上是将从API请求中获得的值存储到<code class="fe mw mx my mz b">localStorage</code>中。有了<code class="fe mw mx my mz b">localStorage</code>中的值，我们还需要将状态值设置为<code class="fe mw mx my mz b">localStorage</code>中保存的值，就像我们在<code class="fe mw mx my mz b">Today</code>组件中所做的那样。创建一个<code class="fe mw mx my mz b">componentDidMount</code>方法，并在该方法中添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f0b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，当没有互联网连接时，我们的应用程序将显示缓存的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/fb33b6828e65478e60fb54ffd1ba4a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpf-9n6-2QUdjEuamK1D_w.png"/></div></div></figure><p id="283e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，该应用程序是时间敏感的。缓存时，对时间敏感的数据对用户来说并不真正有用。我们可以做的是，添加一个状态指示器，警告用户当他们离线时，正在显示的数据可能是陈旧的，需要互联网连接才能显示最新的数据。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="39a8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">将应用部署到生产中</h1><p id="5fec" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">现在我们已经完成了构建，让我们将应用程序部署到生产环境中，并进行最终的Lighthouse测试。我们将使用<a class="ae lq" href="http://now.sh/" rel="noopener ugc nofollow" target="_blank"> now.sh </a>进行部署，<code class="fe mw mx my mz b">now</code>允许您轻松地将您的JavaScript (Node.js)或Docker支持的网站、应用程序和服务带到云上。您可以在网站上找到安装说明。您还可以使用任何其他部署解决方案，我现在使用它是因为它简单。</p><p id="aac7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在终端中运行以下命令，为应用程序的生产做准备:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="5d23" class="ne ma it mz b gy nf ng l nh ni">npm run build</span></pre><p id="933c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将生产应用程序构建到<code class="fe mw mx my mz b">build</code>文件夹中。好了，接下来要做的是创建一个服务器，应用程序将在其中提供服务。在<code class="fe mw mx my mz b">build</code>文件夹中，创建一个名为<code class="fe mw mx my mz b">server.js</code>的文件，并输入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4bd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这基本上是我们在项目根目录下的<code class="fe mw mx my mz b">server.js</code>文件中编写的相同代码。这里唯一增加的是我们设置了home route来服务于<code class="fe mw mx my mz b">public</code>文件夹中的<code class="fe mw mx my mz b">index.html</code>文件。接下来，运行命令<code class="fe mw mx my mz b">npm init</code>为我们创建一个<code class="fe mw mx my mz b">package.json</code>文件，最后用下面的命令安装所需的包:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="2dc7" class="ne ma it mz b gy nf ng l nh ni">npm install express body-parser pusher</span></pre><p id="c125" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，您可以通过在<code class="fe mw mx my mz b">build</code>文件夹中运行<code class="fe mw mx my mz b">node server.js</code>来查看应用程序，您的应用程序应该在<a class="ae lq" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>上运行。</p><p id="b861" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">部署到<code class="fe mw mx my mz b">now</code>非常简单，你所要做的就是运行命令<code class="fe mw mx my mz b">now deploy</code>，然后<code class="fe mw mx my mz b">now</code>会自动生成一个活动的URL来处理一切。</p><p id="d8a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一切顺利的话，你的应用程序应该已经部署好了，在这里，<a class="ae lq" href="https://build-zrxionqses.now.sh/" rel="noopener ugc nofollow" target="_blank">https://build-zrxionqses.now.sh/</a>。现在自动为所有部署提供SSL，因此我们最终可以再次生成Lighthouse报告来检查PWA状态。现场灯塔报告可以在<a class="ae lq" href="https://googlechrome.github.io/lighthouse/viewer/?gist=4da584b2d889a4f7ce9e439659ea5441" rel="noopener ugc nofollow" target="_blank">这里</a>看到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/ac8076a70807ce1e3c6d6694986b6a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLwKhu1ri-_aWDO8LT14yA.png"/></div></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="ab63" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">应用安装</h1><p id="7cce" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">PWAs的功能之一是web应用程序安装横幅。那么这是如何工作的呢？仅当满足以下条件时，PWA才会安装web应用程序安装横幅:</p><ul class=""><li id="52f0" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp ol nu nv nw bi translated">有一个web应用程序清单文件，其中包含:</li><li id="9d19" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">A <code class="fe mw mx my mz b">short_name</code>(用于主屏幕)</li><li id="980d" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">一个<code class="fe mw mx my mz b">name</code>(用于横幅中)</li><li id="58c2" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">144x144 png图标(图标声明必须包含mime类型的<code class="fe mw mx my mz b">image/png</code>)</li><li id="9ce0" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">加载的一个<code class="fe mw mx my mz b">start_url</code></li><li id="f475" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">一名<a class="ae lq" href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" rel="noopener ugc nofollow" target="_blank">服务人员</a>在你的网站上注册</li><li id="e808" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">在<a class="ae lq" href="https://developers.google.com/web/fundamentals/security/encrypt-in-transit/why-https" rel="noopener ugc nofollow" target="_blank"> HTTPS </a>上服务(使用服务人员的要求)。</li><li id="ddd8" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">至少被探视两次，每次探视间隔至少五分钟。</li></ul><p id="9dc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mw mx my mz b">public</code>文件夹中的<code class="fe mw mx my mz b">manifest.json</code>文件符合上述所有要求，我们在网站上注册了一名服务人员，该应用程序在<a class="ae lq" href="https://build-zrxionqses.now.sh/" rel="noopener ugc nofollow" target="_blank">https://build-zrxionqses.now.sh/</a>的HTTPS提供服务。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="a192" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="d735" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在本教程中，我们看到了如何使用ReactJS、Pusher和service workers来构建一个实时PWA。我们看到了如何使用服务人员来缓存资产和资源，以减少加载时间，并确保应用程序即使在离线时也能工作。</p><p id="2c76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还看到了如何使用localStorage在本地保存数据，以防浏览器失去与互联网的连接。</p><p id="f74e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该应用程序可以在这里现场观看<a class="ae lq" href="https://build-zrxionqses.now.sh/" rel="noopener ugc nofollow" target="_blank">，你可以在这里</a>查看GitHub repo <a class="ae lq" href="https://github.com/yomete/pushercoins" rel="noopener ugc nofollow" target="_blank">。看看你是否能改变一些东西，也许能让应用程序加载得更快！</a></p></div></div>    
</body>
</html>