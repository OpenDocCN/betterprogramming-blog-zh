<html>
<head>
<title>A Comprehensive Guide to NumPy Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy数据类型综合指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-comprehensive-guide-to-numpy-data-types-8f62cb57ea83?source=collection_archive---------2-----------------------#2021-12-29">https://betterprogramming.pub/a-comprehensive-guide-to-numpy-data-types-8f62cb57ea83?source=collection_archive---------2-----------------------#2021-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ab3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">除了int32和float64还有什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18d6c46863d3bdb047512a3c663aa794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEiBECPHpFyio3-sCBtqQg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有图片来源:作者</p></figure><p id="efe5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy是数据科学和科学计算领域最受欢迎的Python库之一，它在数据类型方面非常全面。</p><p id="2b6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它有自己的一套“本地”类型，能够全速处理，但它也可以处理Python所知的几乎所有东西。</p><p id="ba12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章是作为我的<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/numpy-illustrated-the-visual-guide-to-numpy-3b1d4976de1d?sk=57b908a77aa44075a49293fa1631dd9b"> NumPy Illustrated </a>指南的补充而写的，分为七个部分:</p><ol class=""><li id="d7b8" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated"><a class="ae lv" href="#26eb" rel="noopener ugc nofollow">整数</a></li><li id="322e" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lv" href="#efc5" rel="noopener ugc nofollow">浮点数</a>(包括分数和小数)</li><li id="be64" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lv" href="#5156" rel="noopener ugc nofollow">布尔人</a></li><li id="15f4" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lv" href="#f4f8" rel="noopener ugc nofollow">琴弦</a></li><li id="a118" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lv" href="#c859" rel="noopener ugc nofollow">日期时间</a></li><li id="22f2" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lv" href="#e16e" rel="noopener ugc nofollow">其组合</a></li><li id="fcb0" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lv" href="#9d4a" rel="noopener ugc nofollow">型式检查</a></li></ol><h1 id="26eb" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">1.整数</h1><p id="2f54" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">NumPy中的整数类型表对于C/C++经验很少的人来说是微不足道的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/53cc11180be9c0064f31a6f71fea317b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDBcGPOkqTGd5C7DuRrAiw.png"/></div></div></figure><p id="6a6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像在C/C++中一样，“u”代表“无符号”，数字代表用于在内存中存储变量的位数(例如<code class="fe ni nj nk nl b">np.int64</code>是一个8字节宽的有符号整数)。</p><p id="fc64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你将一个Python <code class="fe ni nj nk nl b">int</code>输入NumPy时，它会被转换成一个原生的NumPy类型，叫做<code class="fe ni nj nk nl b">np.int32</code>(或者<code class="fe ni nj nk nl b">np.int64</code>，这取决于操作系统、Python版本和初始化器的数量):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/fdbde7404c383401526c83e412e1ec4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCxl3lnZWCRaphADlj4bpg.png"/></div></div></figure><p id="62ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您对NumPy为您选择的整数类型不满意，您可以通过' dtype '(=数据类型)参数显式地指定一个整数类型，该参数接受dtype对象<code class="fe ni nj nk nl b">np.array([1,2,3], np.uint8)</code>或字符串<code class="fe ni nj nk nl b">np.array([1,2,3], ‘uint8’)</code>。</p><p id="9b74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么需要非默认的数据类型？考虑以下示例(在Windows上):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/70a6d01788f4e8eb6676cd10032269e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TS1U4u4826hIrC23v5ksg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是怎么回事？</p></figure><p id="ca3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当数组元素的宽度固定时，NumPy工作得最好。它速度更快，占用的内存更少，但与普通Python <code class="fe ni nj nk nl b">int</code>(适用于任意精度的运算)不同，数组的值在超过相应数据类型的最大(或最小)值时会换行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/3e37f661d68be14ce13519a1adf00cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1wLD7Fd8Yeajtuyh0pGcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="np"> *严格来说，C标准只对</em> <strong class="bd nq"> <em class="np">无符号</em> </strong> <em class="np">整数定义了这种回绕；</em> <strong class="bd nq"> <em class="np">有符号</em> </strong> <em class="np">整数的溢出行为是未定义的，不能依赖(在C和NumPy中都是如此)。有符号整数现在被悄悄地包装起来，但不能保证它们会一直这样。</em></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/4d96fd54d74dec4ca7e66c7f4197ade1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9u-1oS-fkJ0W_A8ky8EIQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/public/lists/18966/61591" rel="noopener ugc nofollow" target="_blank"> int_wrapping.py </a></p></figure><p id="4480" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">—这里甚至没有一个警告！</p><p id="9bf1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于标量，情况就不同了:首先，NumPy尽力将值提升到更宽的类型，然后，如果没有类型，就触发溢出警告(为了避免警告淹没输出，只触发一次):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/c6067d2281d6cb4b847006718c3705c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3o8HDEgn1zrsw6b3h1aYYw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61593" rel="noopener ugc nofollow" target="_blank"> overflow_warning.py </a></p></figure><p id="a374" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种歧视背后的原因是这样的:</p><blockquote class="nt nu nv"><p id="b6a9" class="ky kz lu la b lb lc ju ld le lf jx lg nw li lj lk nx lm ln lo ny lq lr ls lt im bi translated">与真正的浮点错误(硬件FPU在执行溢出的原子操作时设置一个标志)不同，我们需要自己实现整数溢出检测。我们在标量上这样做，而不是在数组上，因为对于数组上的每个原子操作来说，这样做太慢了。(罗伯特·克恩，NumPy核心开发者之一)</p></blockquote><p id="f0b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以把它变成一个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/1a90a3935fb1eb36666e1ba91c24df27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JahWUKaOY9oqJPK8Df64A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61594" rel="noopener ugc nofollow" target="_blank"> overflow_error.py </a></p></figure><p id="ac55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者暂时抑制它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/94c2027e9875c187c7e422493ef1cc0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8rq547LzGzVEsRSqBHzyQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61595" rel="noopener ugc nofollow" target="_blank"> overflow_ignored.py </a></p></figure><p id="9a22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者完全:<code class="fe ni nj nk nl b">np.warnings.filterwarnings('ignore', 'overflow')</code></p><p id="d855" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是你不能指望它在处理任何数组的时候都能被检测出来。</p><p id="99d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到我们的例子，正确的做法是指定正确的dtype:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/471ab52e231551c724ca554e5100a44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdfH1L26CQP9xfPtWHX3Ug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Linux/MacOS上，默认情况下是np.int64</p></figure><p id="a12c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy也有一堆C风格的别名(例如，<code class="fe ni nj nk nl b">np.byte</code>是<code class="fe ni nj nk nl b">np.int8</code>，<code class="fe ni nj nk nl b">np.short</code>是<code class="fe ni nj nk nl b">np.int16</code>，<code class="fe ni nj nk nl b">np.intc</code>是一个int，具有int类型在C中的任何宽度，等等)，但它们正在逐渐被淘汰(例如<a class="ae lv" href="https://numpy.org/devdocs/release/1.20.0-notes.html#using-the-aliases-of-builtin-types-like-np-int-is-deprecated" rel="noopener ugc nofollow" target="_blank">在NumPy v1.20.0 </a>中对np.long的弃用)，因为“显式比隐式好”(但请参见下面<code class="fe ni nj nk nl b">np.longdouble</code>的现代用法)。</p><p id="4364" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一些更奇特的别名:</p><p id="97ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ni nj nk nl b">np.int_</code>在64位Windows上是<code class="fe ni nj nk nl b">np.int32</code>，但在64位Linux/MacOS上是<code class="fe ni nj nk nl b">np.int64</code>，用于指定‘默认’int。将<code class="fe ni nj nk nl b">np.int_</code>(或者只是int)指定为dtype意味着'<em class="lu">做你会做的事情，如果我根本没有指定任何dtype '</em>:<code class="fe ni nj nk nl b">np.array([1,2])</code>、<code class="fe ni nj nk nl b">np.array([1,2], np.int_)</code>和<code class="fe ni nj nk nl b">np.array([1,2], int)</code>都是一回事。</p><p id="dfcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ni nj nk nl b">np.intp</code>在32位Python上是<code class="fe ni nj nk nl b">np.int32</code>，但在64位Python上是<code class="fe ni nj nk nl b">np.int64</code>，在C语言中是≈ <code class="fe ni nj nk nl b">ssize_t </code>，在Cython中用作指针的类型。</p><p id="4142" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">偶尔，数组中的一些值显示异常行为或缺失，您希望在不删除它们的情况下处理数组(例如，其他列中有一些有效数据)。</p><p id="ac69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你不能把<code class="fe ni nj nk nl b">None</code>放在那里，因为它不适合连续的<code class="fe ni nj nk nl b">np.int64</code>值，也因为<code class="fe ni nj nk nl b">1+None</code>是不支持的操作。</p><p id="4cbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas对此有一个单独的数据类型，但是NumPy处理丢失值的方式是通过所谓的屏蔽数组:您用一个布尔掩码标记无效值，然后所有的操作都被执行，就好像这些值不存在一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/e011ceada5fc02c0458db4c2b32ab978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5M0lZzdeZtCwHJDK0oagHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61706" rel="noopener ugc nofollow" target="_blank"> masked_array.py </a></p></figure><p id="c348" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，如果出于某种原因，您需要ndarrays中的任意精度整数(Python<code class="fe ni nj nk nl b">int</code>s ), numpy也能够做到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ef2e97c935c38c03adf2b34c979c0374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKrRSBghHG98z_DQUKv1Iw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61596" rel="noopener ugc nofollow" target="_blank"> int_type.py </a></p></figure><p id="1b4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">—但没有通常的加速，因为它将存储引用而不是数字本身，在处理时保持装箱/取消装箱Python对象，等等。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="efc5" class="mk ml it bd mm mn ol mp mq mr om mt mu jz on ka mw kc oo kd my kf op kg na nb bi translated">2.漂浮物</h1><p id="d624" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">由于纯Python <code class="fe ni nj nk nl b">float</code>并没有偏离IEEE 754标准的C <code class="fe ni nj nk nl b">double</code>类型(注意命名上的差异)，浮点数从Python到NumPy的转换非常容易:Python <code class="fe ni nj nk nl b">float</code>直接兼容<code class="fe ni nj nk nl b">np.float64</code>和Python<code class="fe ni nj nk nl b">complex</code>——兼容<code class="fe ni nj nk nl b">np.complex128</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/56c0d26cb8cef181535226c6dfe7a77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXnGirp9NLC5oljJ5wGcyA.png"/></div></div></figure><p id="a789" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> *由</em> <code class="fe ni nj nk nl b"><em class="lu">np.finfo(np.float&lt;nn&gt;).precision.</em></code> <em class="lu">两个备选定义给出</em> <a class="ae lv" href="https://en.cppreference.com/w/cpp/types/numeric_limits/digits10" rel="noopener ugc nofollow" target="_blank"> <em class="lu"> 15 </em> </a> <em class="lu">和</em> <a class="ae lv" href="https://en.cppreference.com/w/cpp/types/numeric_limits/max_digits10" rel="noopener ugc nofollow" target="_blank"> <em class="lu"> 17 </em> </a> <em class="lu">位数为</em> <code class="fe ni nj nk nl b"><em class="lu">np.float64</em></code> <em class="lu">，6和9为</em> <code class="fe ni nj nk nl b"><em class="lu">np.float32</em></code> <em class="lu">等。</em></p><p id="2333" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> **从今天起，</em> <code class="fe ni nj nk nl b"><em class="lu">np.float128</em></code> <em class="lu">仅适用于Unix(不适用于Windows)。</em></p><p id="b9ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像整数一样，浮点也容易出现溢出错误。</p><p id="3df9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设你正在计算一个数组的sigmoid激活函数，它的一个元素恰好是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/777b66c11f96cbb90d57190c912ae45a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cljt7Pykv_2pTPA7ehSTeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61748" rel="noopener ugc nofollow" target="_blank"> float_overflow.py </a></p></figure><p id="386d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个警告试图告诉你的是NumPy知道从数学上讲<code class="fe ni nj nk nl b">1/(1+exp(-x))</code>永远不可能为零，但是在这个特殊的例子中，由于溢出，它是零。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/d0e4480887e026dc415ff40a103fd174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2JgQWh5pyz6d80BbT9_3Hg.png"/></div></div></figure><p id="12fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上面“整数”部分所述，这种警告可以通过<code class="fe ni nj nk nl b">errstate</code>或<code class="fe ni nj nk nl b">filterwarnings</code>被“提升”为异常或静音——对于这种特殊情况，这可能就足够了——但是如果您<em class="lu">真的</em>想要获得准确的值，您可以选择更宽的<code class="fe ni nj nk nl b">dtype</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/4fe5da9c6d3aa0a339443c01bf950393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqqdJBG4AeBXgdeU6m5VOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61749" rel="noopener ugc nofollow" target="_blank">float 128 . py</a>:NP . float 128目前在Linux/MacOS上可用，在Windows上不可用</p></figure><p id="571a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">区别浮点数和整数的一点是它们是不精确的。你不能用<code class="fe ni nj nk nl b">a == b</code>来比较两个浮点数，除非你确定它们被准确地表示为<em class="lu"/>。您可以期望floats精确地表示整数，但只能在特定级别以下(受有效位数的限制):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/6105a18cf37c61e690712e4618f67aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1OebmeYqGxi0wo0viCccw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61585" rel="noopener ugc nofollow" target="_blank">max _ continuous _ int . py</a></p></figure><p id="1d43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样可精确表示的是像0.5、0.125、0.875这样的分数，其中分母是2的幂(0.5=1/2、0.125=1/8、0.875 =7/8等)。任何其他分母都会导致舍入误差，因此0.1+0.2！=0.3.</p><p id="5c81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">处理这个问题(以及不精确的来源#2:计算结果的舍入)的标准方法是将它们与相对容差(比较两个非零参数)和绝对容差(如果其中一个参数为零)进行比较。对于标量，它由<code class="fe ni nj nk nl b">math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)</code>处理，对于NumPy数组，有一个向量版本<code class="fe ni nj nk nl b">np.isclose(a, b, rtol=1e-05, atol=1e-08)</code>。请注意，公差有不同的名称和默认值。</p><p id="6b7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于财务数据，<code class="fe ni nj nk nl b">decimal.Decimal</code>类型很方便，因为它不涉及任何额外的公差:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/ba0e6a29ca2d320fe9392db4c79b2184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZkUjjZiCOyra--rvv8YBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61597" rel="noopener ugc nofollow" target="_blank"> decimal.py </a></p></figure><p id="79c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是它不是银弹:它也有舍入误差(见上面的来源#2)。它解决的唯一问题是人类习惯的十进制数的精确表示。</p><p id="9015" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，它不支持任何比算术运算更复杂的操作(尽管支持对数和平方根)，并且运行速度比浮点运算慢。</p><p id="f2aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于纯数学计算，可以使用<code class="fe ni nj nk nl b">fractions.Fraction</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/c1612ef8aaccfa19cd11773463acbe70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRTyziX6OU6tjbiPxH_Nvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61598" rel="noopener ugc nofollow" target="_blank"> fractions.py </a></p></figure><p id="6d85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它可以精确地表示任何有理数<em class="lu">和</em>在计算过程中不受舍入误差的影响(来源#2 ),但是π和<em class="lu"> e </em>运气不好！如果你也需要它们，那么<a class="ae lv" href="https://www.sympy.org/en/index.html" rel="noopener ugc nofollow" target="_blank"> SymPy </a>就是你的朋友。</p><p id="8487" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ni nj nk nl b">Decimal</code>和<code class="fe ni nj nk nl b">Fraction</code>都不是NumPy的原生类型，但是它能够处理它们的所有细节，比如多维度和花哨的索引，尽管代价是处理速度比原生的<code class="fe ni nj nk nl b">int</code>或<code class="fe ni nj nk nl b">float</code>慢</p><p id="e3ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">复数的处理方式与浮点数相同。还有一些额外的方便函数，名字很直观，比如np。<a class="ae lv" href="https://numpy.org/doc/stable/reference/generated/numpy.real.html" rel="noopener ugc nofollow" target="_blank">实</a> (z)，np。<a class="ae lv" href="https://numpy.org/doc/stable/reference/generated/numpy.imag.html" rel="noopener ugc nofollow" target="_blank"> imag </a> (z)，np。<a class="ae lv" href="https://numpy.org/doc/stable/reference/generated/numpy.absolute.html" rel="noopener ugc nofollow" target="_blank"> abs </a> (z)，np。<a class="ae lv" href="https://numpy.org/doc/stable/reference/generated/numpy.angle.html" rel="noopener ugc nofollow" target="_blank">角度</a> (z)对标量和数组都起作用。与纯Python <code class="fe ni nj nk nl b">complex</code>，<code class="fe ni nj nk nl b">np.complex_</code>的唯一区别是不能处理整数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/6dbb6ef5985b57f0737e522aaad42dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-oNTd0L20iM_LvMHIKAsg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61684" rel="noopener ugc nofollow" target="_blank"> int_complex.py </a></p></figure><p id="e9ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像整数一样，在浮点(和复杂)数组中，有时将某些值视为“缺失”也是有用的。浮点更适合存储异常数据:它们有一个<code class="fe ni nj nk nl b">math.nan</code>(或<code class="fe ni nj nk nl b">np.nan</code>或<code class="fe ni nj nk nl b">float(‘nan’)</code>)值，可以与‘有效’数值一起存储。</p><p id="860e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是<code class="fe ni nj nk nl b">nan</code>具有传染性，因为所有使用<code class="fe ni nj nk nl b">nan</code>的算法都会产生<code class="fe ni nj nk nl b">nan.</code>大多数常见的统计函数都有一个抗nan版本(np.nansum、np.nanstd等)，但是对该列或数组的其他操作需要预过滤。掩码数组自动执行这一步:掩码只能构建一次，然后它被“粘贴”到原始数组，以便所有后续操作只看到未被掩码的值并对它们进行操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/82c73942de6c7eae076b2e15419fbaf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqVXiYU-h2mZ7Zio9iYokQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61710" rel="noopener ugc nofollow" target="_blank"> masked_floats.py </a></p></figure><p id="dedb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，<code class="fe ni nj nk nl b">float96</code> / <code class="fe ni nj nk nl b">float128</code>这两个名字也有些误导。在引擎盖下，它不是<code class="fe ni nj nk nl b">__float128</code>，而是在本地C++风格中的任何一个<code class="fe ni nj nk nl b">longdouble</code>的意思。在x86_64 Linux上，它是<code class="fe ni nj nk nl b">float80</code>(用零填充以进行内存对齐)，当然比<code class="fe ni nj nk nl b">float64</code>更宽，但这是以处理速度为代价的。此外，如果您不小心转换成Python <code class="fe ni nj nk nl b">float</code>类型，就有失去精度的风险。为了更好的可移植性，建议使用别名<code class="fe ni nj nk nl b">np.longdouble</code>而不是<code class="fe ni nj nk nl b">np.float96</code> / <code class="fe ni nj nk nl b">np.float128</code>，因为这是内部使用的别名。</p><p id="1ce8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关浮动的更多信息可以在以下资源中找到:</p><ul class=""><li id="301f" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt oy mc md me bi translated">简洁明了的“<a class="ae lv" href="https://observablehq.com/@rreusser/half-precision-floating-point-visualized" rel="noopener ugc nofollow" target="_blank">半精度浮点可视化</a>”(例如，正常数和次正常数之间有什么区别)</li><li id="bd59" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt oy mc md me bi translated">比较冗长但是很中肯，一个专门的网站'<a class="ae lv" href="https://floating-point-gui.de/" rel="noopener ugc nofollow" target="_blank">浮点指南</a>'(比如为什么0.1+0.2！=0.3)</li><li id="54d0" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt oy mc md me bi translated">长篇阅读，深入透彻的“<a class="ae lv" href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="noopener ugc nofollow" target="_blank">每个计算机科学家都应该知道的浮点运算</a>”(例如，灾难性的与良性的取消有什么区别)</li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="5156" class="mk ml it bd mm mn ol mp mq mr om mt mu jz on ka mw kc oo kd my kf op kg na nb bi translated">3.布尔人</h1><p id="c704" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">为了获得更好的性能，布尔值存储为单字节。<code class="fe ni nj nk nl b">np.bool_</code>是一个独立于Python的<code class="fe ni nj nk nl b">bool</code>的类型，因为它不需要任何纯Python类型所需的引用计数和到基类的链接。如果你认为用8位存储1位信息是多余的，看看这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/bf7cbbdc2436a36720ee38d2bac03ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1k71xIxx-1HrltquGGXuhQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61599" rel="noopener ugc nofollow" target="_blank"> size_of_bool.py </a></p></figure><p id="3310" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ni nj nk nl b">np.bool</code>的内存效率是Python的<code class="fe ni nj nk nl b">bool</code>的28倍——尽管在现实场景中，这一比率较低:当您将NumPy bools打包到一个数组中时，它们每个将占用1个字节，但是如果您将Python bools打包到一个列表中，它每次都会引用相同的两个值，实际上在x86_64上每个元素花费8个字节:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/e165c83c0626edcbf895b2b6ca29b94a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90_UB1w4kGr35f5n-Zs2mA.png"/></div></div></figure><p id="30a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ni nj nk nl b">bool_</code>、<code class="fe ni nj nk nl b">int_</code>等中的下划线是为了避免与Python的类型冲突。对其他事情使用保留的关键字是一个坏主意，但是在这种情况下，它有一个额外的优点，允许(通常不鼓励，但在极少数情况下有用)<code class="fe ni nj nk nl b">from numpy import *</code>而不隐藏Python <code class="fe ni nj nk nl b">bool</code>、<code class="fe ni nj nk nl b">int</code>等。到今天为止，<code class="fe ni nj nk nl b">np.bool</code>仍然可以工作，但是会显示一个弃用警告。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="f4f8" class="mk ml it bd mm mn ol mp mq mr om mt mu jz on ka mw kc oo kd my kf op kg na nb bi translated">4.用线串</h1><p id="d968" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">用Python字符串列表初始化NumPy数组，将它们打包成一个固定宽度的原生NumPy dtype，称为<code class="fe ni nj nk nl b">np.str_</code>。为每个元素保留适合最长字符串所需的空间可能看起来很浪费(特别是在固定的USC-4编码中，而不是在Python <code class="fe ni nj nk nl b">str</code>中“动态”选择UTF宽度)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/0f6641557525b38a587c09041120b1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVEAN95tJQ9L07Pk-8afqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61600" rel="noopener ugc nofollow" target="_blank"> dtype_str_。py </a></p></figure><p id="0041" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缩写'<u4 comes="" from="" the="" so-called="" array="" protocol="" introduced="" in="" it="" means="" class="ae lv" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.byteorder.html" rel="noopener ugc nofollow" target="_blank">little-endian<a class="ae lv" href="https://numpy.org/doc/stable/reference/arrays.interface.html#arrays-interface" rel="noopener ugc nofollow" target="_blank">USC-4编码字符串</a>，5个元素长'(<a class="ae lv" href="https://en.wikipedia.org/wiki/UTF-32" rel="noopener ugc nofollow" target="_blank"> USC-4 </a> ≈UTF-32，固定宽度，每字符4字节编码)。每个NumPy类型都有一个缩写——就像这个一样不可读——幸运的是，他们至少为最常用的数据类型采用了人类可读的名称。</u4></p><p id="14aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个选择是在对象的NumPy数组中保存对Python的引用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/289bb255cc9d518f93fbde4d16e7f2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRzZvjdtGAEoUTdJk6OEVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61601" rel="noopener ugc nofollow" target="_blank"> dtype_str.py </a></p></figure><p id="2654" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个数组内存占用量为164字节，第二个数组占用128字节+ 154字节用于三个Python <code class="fe ni nj nk nl b">str</code>的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/b7ea4fcc1a4a678fe6194c13de47d21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sxhz-3ezSJZ6Aks2mw-eg.png"/></div></div></figure><p id="1496" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据字符串的相对长度和重复字符串的数量，一种方法可能是一个重要的胜利。</p><p id="17ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你正在处理一个原始的字节序列，NumPy有一个Python <code class="fe ni nj nk nl b">bytes</code>类型的固定长度版本，叫做<code class="fe ni nj nk nl b">np.bytes_</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/019cab03734a0aa2bf9c90f440cd8aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktv9I3p-LwoBjv96Zpk3Zg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61602" rel="noopener ugc nofollow" target="_blank"> dtype_bytes_。py </a></p></figure><p id="8565" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的<code class="fe ni nj nk nl b">|S5</code>表示“<a class="ae lv" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.byteorder.html" rel="noopener ugc nofollow" target="_blank">字节顺序-不可弯曲的</a> <a class="ae lv" href="https://numpy.org/doc/stable/reference/arrays.interface.html#arrays-interface" rel="noopener ugc nofollow" target="_blank">字节序列</a> 5个元素长”。</p><p id="2f0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，另一种方法是将Python <code class="fe ni nj nk nl b">bytes</code>存储在NumPy对象数组中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/6d32cd70775b7c1e3ae48e304f811f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qS08vqVJ0QwM6ggNxtUfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61626" rel="noopener ugc nofollow" target="_blank"> dtype_bytes.py </a></p></figure><p id="0cd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这次第一个数组占用了124个字节，第二个同样是128个字节，对于数组本身+ 106个字节，对于三个Python <code class="fe ni nj nk nl b">bytes</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/35bea6cf9b342430b7b0e61de92ab160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkIJsoxFSIBS6KTKXDTsVA.png"/></div></div></figure><p id="7d1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看到<code class="fe ni nj nk nl b">str_</code>又变小了，然而对于更多样的长度<code class="fe ni nj nk nl b">str</code>可以获胜。</p><p id="b7b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至于原生的<code class="fe ni nj nk nl b">np.str_</code>和<code class="fe ni nj nk nl b">np.bytes_</code>类型，NumPy有一些常见的字符串操作。它们镜像Python的<code class="fe ni nj nk nl b">str</code>方法，驻留在<code class="fe ni nj nk nl b">np.char</code>模块中，并在整个数组上操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/baf8779db5536d0ee7c2c07f004cd091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vqN55yTnoIgopICZo_OvCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61603" rel="noopener ugc nofollow" target="_blank"> char_upper.py </a></p></figure><p id="8e91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于对象模式字符串，循环必须发生在Python级别:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/50f126604706d3fb20e8a682d555a649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*024aAui45BAUkchjynYKWA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61604" rel="noopener ugc nofollow" target="_blank">矢量化_upper.py </a></p></figure><p id="8b38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据我的基准测试，基本操作使用<code class="fe ni nj nk nl b">str</code>比使用<code class="fe ni nj nk nl b">np.str_</code>要快一些。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="c859" class="mk ml it bd mm mn ol mp mq mr om mt mu jz on ka mw kc oo kd my kf op kg na nb bi translated"><strong class="ak"> 5。日期时间</strong></h1><p id="bfa3" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">NumPy为datetimes引入了一种有趣的本地数据类型，类似于POSIX时间戳(又名Unix time，自1970年1月1日以来的秒数),但是能够以可配置的粒度计算时间——从年到阿秒——总是用一个数字<code class="fe ni nj nk nl b">int64</code>表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/3fa68d697e60842fc027a6b6c26b81c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*917CI5Ca7XcGfXGln4oT7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自官方<a class="ae lv" href="https://numpy.org/doc/stable/reference/arrays.datetime.html" rel="noopener ugc nofollow" target="_blank">文件</a>的表格</p></figure><ul class=""><li id="004b" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt oy mc md me bi translated">年粒度意味着“只计算年数”——与将年存储为整数相比，并没有真正的改进。</li><li id="c436" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt oy mc md me bi translated">天数粒度相当于Python的<code class="fe ni nj nk nl b">datetime.date</code>。</li><li id="bad8" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt oy mc md me bi translated">微秒Python的<code class="fe ni nj nk nl b">datetime.datetime</code>。</li></ul><p id="1e16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而下面的一切都是<code class="fe ni nj nk nl b">np.datetime64</code>独有的。</p><p id="7c87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当创建一个<code class="fe ni nj nk nl b">np.datetime64</code>的实例时，NumPy选择仍能保存此类数据的最粗粒度:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/8cce2efdd83f9f1326ba344a25e12ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQfZDt_VvLd2oATD7HdawQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61837" rel="noopener ugc nofollow" target="_blank">构造_dt64.py </a></p></figure><p id="bde7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，字符串初始值设定项不像<code class="fe ni nj nk nl b">pd.to_datetime</code>中那样宽松:它必须是这种精确的格式或其中最小的变化(参见<a class="ae lv" href="https://en.wikipedia.org/wiki/ISO_8601#General_principles" rel="noopener ugc nofollow" target="_blank"> ISO 8601 </a>维基百科页面的‘一般原则’)。</p><p id="7b46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当创建一个数组时，您可以决定是否接受NumPy为您选择的粒度，或者您坚持，比如说，纳秒或其他，它将为您提供2⁶等距时刻，以1970年1月1日的相应时间单位测量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/78c32b81820c3c12403ae1d1557ce7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SA1UCXNaiL9gOaMmRckeZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61605" rel="noopener ugc nofollow" target="_blank"> datetime64.py </a></p></figure><p id="53ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以有多个基本单元。例如，如果您只需要0.1秒的精度，则不一定需要存储毫秒:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/5557b33ad15fb09c4b9a58a86a1b5a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75ie4bNwhr2JcOYVCojbYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61839" rel="noopener ugc nofollow" target="_blank"> d64_100ms.py </a></p></figure><p id="0918" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在不解析dtype字符串的情况下获得机器可读的粒度表示，请执行以下操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/85541bf5b06d6f0cf4f009e9a3cf5585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1o9XE2O3oZ1_WUVY7cP5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61840" rel="noopener ugc nofollow" target="_blank">日期时间_数据. py </a></p></figure><p id="8265" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像在纯Python中，当你从一个<code class="fe ni nj nk nl b">np.datetime64</code>减去另一个<code class="fe ni nj nk nl b">np.datetime64</code>时，你会得到一个<code class="fe ni nj nk nl b">np.timedelta64</code>对象(也表示为一个具有可配置粒度的int64)。例如，要获得新年前的秒数，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/782d84eef45bb7f63bd34f9f62617707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5iTXRIZiHmS1TwFL654n4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61676" rel="noopener ugc nofollow" target="_blank"> new_year.py </a></p></figure><p id="d6e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者如果你不关心小数部分，简单地说</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/48181aa6fe2b7e085eff90806a13f1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24iH8cEppZL2lKx1MrJBYw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61677" rel="noopener ugc nofollow" target="_blank"> new_year1.py </a></p></figure><p id="c139" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦构造好了，就不能再对datetime或timedelta对象做什么了。为了提高速度，可用操作的数量保持在最低限度:只有转换和基本算术。例如，没有“年”或“日”帮助器方法。</p><p id="759e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要从datetime64/timedelta64标量中获取特定字段，可以将其转换为常规日期时间:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/9d29827dc63bd715a27ae8a99dbb231f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xkckDnIQ8W9SpgV9M4iwKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61842" rel="noopener ugc nofollow" target="_blank"> item.py </a></p></figure><p id="8bca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于像这样的阵列</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/b3fe1024923e5d352a864be76b43ce7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpInZ-tZq7PjU6QSbnJucQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61841" rel="noopener ugc nofollow" target="_blank"> arange.py </a></p></figure><p id="6569" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在<code class="fe ni nj nk nl b">np.datetime64</code>子类型之间进行转换(更快)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/1547b767a0701d4b7b83a71fe0a82e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0M3UgwmmqUgvAdBJErlH2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61844" rel="noopener ugc nofollow" target="_blank"> astype.py </a></p></figure><p id="7b62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者用熊猫(慢2-4倍):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/13ff59c101465ee07984432204382952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sbkurp3r6CSSbdpY9rFh0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61843" rel="noopener ugc nofollow" target="_blank"> to_datetime.py </a></p></figure><p id="2998" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个有用的<a class="ae lv" href="https://stackoverflow.com/a/56260054/237105" rel="noopener ugc nofollow" target="_blank">函数</a>，它将一个<code class="fe ni nj nk nl b">datetime64</code>数组分解成一个由7个整数列(年、月、日、小时、分钟、秒、微秒)组成的数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/99613d93c574b1d484b8a92d79130a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNf0kaOW60m3kgyAk-Ig5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61845" rel="noopener ugc nofollow" target="_blank"> dt2cal.py </a></p></figure><p id="c3b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">日期时间的几个问题:</p><ol class=""><li id="448c" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">尽管支持闰年，</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/8a8b284f22dff953666f61d877665427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yU5uZTmClUtNdFs5vmwcrA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61679" rel="noopener ugc nofollow" target="_blank">闰年. py </a></p></figure><p id="63df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lv" href="https://en.wikipedia.org/wiki/Leap_second" rel="noopener ugc nofollow" target="_blank">闰秒</a>(UTC和普通壁时的重要组成部分)不是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/dabe941e6ca347c0a32ffc28bac7fdae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jlRNuGrn9sMQiB82I8QGNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61680" rel="noopener ugc nofollow" target="_blank"> leap_seconds.py </a></p></figure><p id="cab2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">公平地说，无论是<code class="fe ni nj nk nl b"> datetime.datetime</code>还是<code class="fe ni nj nk nl b">pytz</code>都没有计算它们(尽管一般来说<a class="ae lv" href="https://stackoverflow.com/questions/19332902/extract-historic-leap-seconds-from-tzdata" rel="noopener ugc nofollow" target="_blank">可以用pytz提取关于它们的信息)。<code class="fe ni nj nk nl b">time</code>模块仅在形式上支持它们(接受60秒，但给出不正确的间隔)。</a></p><p id="c7f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前看来只有<a class="ae lv" href="https://www.astropy.org/" rel="noopener ugc nofollow" target="_blank">天文望远镜</a>能够正确处理它们，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/86166298ef779a615ad389f2279bcbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DP-GCKbnvUU4t9eh1SwULw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61847" rel="noopener ugc nofollow" target="_blank"> astropy.py </a></p></figure><p id="dfc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一些人则坚持使用公历<a class="ae lv" href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar" rel="noopener ugc nofollow" target="_blank">时间，每天精确86400国际单位制秒，自从1970年以来，由于地球自转的不规则性，它已经与墙上的时间相差了大约半分钟。</a></p><p id="3eb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用此日历的实际含义是:<br/>–计算包含一个或多个闰秒的时间间隔时出错<br/>–尝试从闰秒期间获取的时间戳构建datetime64时出现异常</p><p id="8c55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.由于<code class="fe ni nj nk nl b">np.datetime64</code>和<code class="fe ni nj nk nl b">np.timedelta64</code>具有相同的宽度，因此必须注意较大的时间差:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/5d1fd56a8da27693d2c1156a7a86ed39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWzCy7p-Dav-qT6J2h4RJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61683" rel="noopener ugc nofollow" target="_blank"> negative_timedelta.py </a></p></figure><p id="6760" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，请注意<code class="fe ni nj nk nl b">np.datetime64</code>中的所有时间都是“简单的”:它们不“知道”夏令时(因此建议以UTC存储所有日期时间)，并且不能从一个时区转换到另一个时区(使用pytz进行时区转换):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/5d791b24eb92da92cc118b91db92721a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M70aIHgE_gE8S6XOXao2Jw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61848" rel="noopener ugc nofollow" target="_blank"> datetime_as_string.py </a></p></figure></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="e16e" class="mk ml it bd mm mn ol mp mq mr om mt mu jz on ka mw kc oo kd my kf op kg na nb bi translated">6.它们的组合</h1><p id="484f" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">NumPy中的“结构化数组”是一个带有自定义<code class="fe ni nj nk nl b">dtype</code>的数组，由上述类型作为基本构建块组成(类似于C中的<code class="fe ni nj nk nl b">struct</code>)。一个典型的例子是RGB像素颜色:一种3字节长的类型(通常4字节用于对齐)，其中的颜色可以通过名称来访问:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/9dd76ad80b61de53110db1f2b27b1b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4d15BsKb_qaQWGnXplMJDA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61667" rel="noopener ugc nofollow" target="_blank">结构化_数组. py </a></p></figure><p id="dbd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了能够访问作为属性的字段，可以使用一个<code class="fe ni nj nk nl b">np.recarray</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/858539ce77389804ef15bc735c3fd519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLOZEX7EATIjWq5wJNPA1w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61668" rel="noopener ugc nofollow" target="_blank"> recarray.py </a></p></figure><p id="a7e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，它的工作方式类似于C++中的<code class="fe ni nj nk nl b">reinterpret_cast</code>,但是毫无疑问，recarray可以自己创建，而不是作为其他东西的视图。</p><p id="1fa5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结构化数组的类型不一定需要是同类的，甚至可以包括子数组。</p><p id="edb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过结构化数组和重新排列，可以获得基本Pandas数据框架的“外观和感觉”:</p><ul class=""><li id="f46a" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt oy mc md me bi translated">您可以按名称对列进行寻址，</li><li id="1c8a" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt oy mc md me bi translated">用它们做一些算术和统计计算，</li><li id="8ca2" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt oy mc md me bi translated">您可以有效地处理缺失值，</li><li id="de84" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt oy mc md me bi translated">NumPy的一些操作比熊猫快</li></ul><p id="db48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是他们缺乏:</p><ul class=""><li id="988d" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt oy mc md me bi translated">分组(itertools.groupby提供的除外)</li><li id="8144" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt oy mc md me bi translated">强大的熊猫指数和多重指数(所以没有数据透视表)和</li><li id="48b3" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt oy mc md me bi translated">其他细节，如方便分类等。</li></ul><p id="c5a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的问题是，尽管这种语法对于整体寻址特定的列很方便，但无论是结构化数组还是重排列都不是您想要在计算密集型代码的最内层循环中使用的东西:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/a9c7f324461ffd999e3fefc4c5f59f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cP08pKvLIpHTM1ZTuEw3gA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/62073" rel="noopener ugc nofollow" target="_blank"> recarray_benchmark.py </a></p></figure><p id="6979" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">注意:剖析python代码有时可能是反直觉的:根据x的性质，将x**2改为x*x可以使代码运行得更快或更慢1.5倍。</em></p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="9d4a" class="mk ml it bd mm mn ol mp mq mr om mt mu jz on ka mw kc oo kd my kf op kg na nb bi translated">7.类型检查</h1><p id="8c4e" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">检查NumPy数组类型的一种方法是对其元素运行<code class="fe ni nj nk nl b">isinstance</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/8e390f0e1238728d3eca4b924c0536b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5b-faQccFJx5Z4o9Hmh7cQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61606" rel="noopener ugc nofollow" target="_blank"> isinstance.py </a></p></figure><p id="7126" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有的NumPy类型都在文章顶部显示的继承树中相互连接(蓝色=抽象类，绿色=数字类型，黄色=其他类型),因此您可以编写更紧凑的类型检查，如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/10b2139d906857378cf035b93ee5f6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7i-qZECKMZqLorE3EPLFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61607" rel="noopener ugc nofollow" target="_blank">using _ abstract _ dtypes . py</a></p></figure><p id="3d62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个方法的缺点是它只对数组的一个<em class="lu">值</em>起作用，而不是对数组本身起作用。这在例如数组为空时是没有用的。检查<em class="lu">数组</em>的类型更加棘手。</p><p id="6f91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于基本类型,<code class="fe ni nj nk nl b">==</code>操作符完成单一类型检查的工作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/c95950d7c5baced93a6cb8eed826e321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgjKH0mgdLH5A0eKMd7gwg.png"/></div></div></figure><p id="942b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和<code class="fe ni nj nk nl b">in</code>运算符，用于检查一组类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/89da9be124b6ef77bc1ca49238095497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LgDDeuu5HPUiT6KEhq7yA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61609" rel="noopener ugc nofollow" target="_blank"> in.py </a></p></figure><p id="777f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是对于像<code class="fe ni nj nk nl b">np.str_</code>或<code class="fe ni nj nk nl b">np.datetime64</code>这样更复杂的类型，他们不会。</p><p id="e55b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">针对抽象类型检查<code class="fe ni nj nk nl b">dtype</code>的<a class="ae lv" href="https://github.com/numpy/numpy/issues/17325" rel="noopener ugc nofollow" target="_blank">推荐方式</a> ⁴为</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/6b67bf7685577cc5fad5e53d30432714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ma3LJtIkJmE9JK5RWu8zg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61610" rel="noopener ugc nofollow" target="_blank"> issubdtype.py </a></p></figure><p id="0576" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它适用于所有本机NumPy类型，但是这种方法的必要性看起来有些不明显:老式的<code class="fe ni nj nk nl b">isinstance</code>有什么问题吗？显然，<code class="fe ni nj nk nl b">dtypes</code>继承结构的复杂性(它们是‘动态’构建的)！)不允许他们按照最小惊讶原则去做。</p><p id="97f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您安装了Pandas，它的类型检查工具也可以处理NumPy dtypes:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/d048914828b52dfd7e9d395e3eb3dc2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EGq-MfBjURujdpYMW6jag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61704" rel="noopener ugc nofollow" target="_blank"> pd_api_types.py </a></p></figure><p id="f197" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一种方法是使用(未记录，但在SciPy/NumPy代码库中使用，如<a class="ae lv" href="https://github.com/numpy/numpy/blob/60b01f9c7bd6e992191f20b7f2d8fcdb13f3d474/numpy/polynomial/polyutils.py#L249" rel="noopener ugc nofollow" target="_blank">此处</a> ) <code class="fe ni nj nk nl b">np.typecodes</code>字典。它代表的树没有那么多分枝:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/bacb5993ed24215d29afd9fca512e625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pu_lEW1aiKxgFBlIKo9G7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61611" rel="noopener ugc nofollow" target="_blank"> typecodes.py </a></p></figure><p id="15fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它的主要应用是为测试目的生成具有特定数据类型的数组，但它也可用于区分不同的数据类型组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/8d07014896f1092dcbfc427a1ef0e32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQ9YfJee_jjrWzIuF9m3_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lv" href="https://snipit.io/lists/18966/61612" rel="noopener ugc nofollow" target="_blank"> char.py </a></p></figure><p id="7a73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">注意，用</em> <code class="fe ni nj nk nl b"><em class="lu">a.dtype.kind</em></code> <em class="lu">代替</em> <code class="fe ni nj nk nl b"><em class="lu">a.dtype.char</em></code> <em class="lu">是错误的:</em> <code class="fe ni nj nk nl b"><em class="lu">np.zeros(1, dtype=np.uint8).dtype.kind == ‘u’</em></code> <em class="lu">在</em> <code class="fe ni nj nk nl b"><em class="lu">np.typecodes</em></code> <em class="lu">中缺失，而</em> <code class="fe ni nj nk nl b"><em class="lu">&lt;…&gt;.char == ‘B’</em></code> <em class="lu">在那里列出。</em></p><p id="bb9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法的一个缺点是布尔值、字符串、字节、对象和空值('？'、' U '、' S '、' O '和' V '，在字典中没有专用的键。</p><p id="bce3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法看起来比<code class="fe ni nj nk nl b">issubdtype</code>更粗糙，但不那么神奇。</p><p id="1a0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我要感谢NumPy团队的成员，感谢他们帮助我解决了拼写错误，并对一些高级概念进行了富有成效的讨论。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h2 id="d693" class="pw ml it bd mm px py dn mq pz qa dp mu lh qb qc mw ll qd qe my lp qf qg na qh bi translated">参考</h2><ol class=""><li id="f4d6" class="lw lx it la b lb nc le nd lh qi ll qj lp qk lt mb mc md me bi translated">Ricky Reusser，<a class="ae lv" href="https://observablehq.com/@rreusser/half-precision-floating-point-visualized" rel="noopener ugc nofollow" target="_blank">半精度浮点，可视化</a></li></ol><p id="3c81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.浮点指南<a class="ae lv" href="https://floating-point-gui.de/" rel="noopener ugc nofollow" target="_blank">https://floating-point-gui.de/</a></p><p id="0df4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.大卫·戈德堡，<a class="ae lv" href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="noopener ugc nofollow" target="_blank">每个计算机科学家都应该知道的关于浮点运算的知识</a>，附录D</p><p id="afb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.NumPy问题<a class="ae lv" href="https://github.com/numpy/numpy/issues/17325" rel="noopener ugc nofollow" target="_blank"> #17325 </a>，增加了一个判断dtype是整数、浮点还是复数的规范方法。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h2 id="251b" class="pw ml it bd mm px py dn mq pz qa dp mu lh qb qc mw ll qd qe my lp qf qg na qh bi translated">许可证</h2><p id="3e1b" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated"><a class="ae lv" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank">CC BY-NC 4.0</a>(=只要给归属就分享改编，不从中赚钱，保持同一许可)。</p></div></div>    
</body>
</html>