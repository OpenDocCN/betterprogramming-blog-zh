<html>
<head>
<title>Standard Template Library (STL) in C++ — An Introduction to Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的标准模板库(STL)——容器介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stl-containers-be7bdaa222b0?source=collection_archive---------8-----------------------#2022-07-07">https://betterprogramming.pub/stl-containers-be7bdaa222b0?source=collection_archive---------8-----------------------#2022-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5082" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">现代有效的C++</h2><div class=""/><div class=""><h2 id="fa1a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">像专家一样介绍、理解、选择、使用和可视化容器！</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/97c7df6ed6faa491903c144603a4654f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JS6Zv0pRf2aB67VynLfI0g.png"/></div></div></figure><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="9815" class="li lj it le b gy lk ll l lm ln">· <a class="ae lo" href="#3e78" rel="noopener ugc nofollow">Overview</a><br/>  ∘ <a class="ae lo" href="#6c8b" rel="noopener ugc nofollow">Why use STL?</a><br/>· <a class="ae lo" href="#98fe" rel="noopener ugc nofollow">STL Containers</a><br/>  ∘ <a class="ae lo" href="#08f3" rel="noopener ugc nofollow">Container types</a><br/>  ∘ <a class="ae lo" href="#7914" rel="noopener ugc nofollow">Containers Visualized</a><br/>  ∘ <a class="ae lo" href="#af6e" rel="noopener ugc nofollow">Why use STL Containers?</a><br/>· <a class="ae lo" href="#e9a9" rel="noopener ugc nofollow">Container Specifications</a><br/>· <a class="ae lo" href="#659b" rel="noopener ugc nofollow">Sequential Containers</a><br/>· <a class="ae lo" href="#1fc7" rel="noopener ugc nofollow">Choosing the right container</a><br/>· <a class="ae lo" href="#f2ad" rel="noopener ugc nofollow">Conclusion</a><br/>· <a class="ae lo" href="#c5ec" rel="noopener ugc nofollow">References</a><br/>· <a class="ae lo" href="#3b99" rel="noopener ugc nofollow">Supplemental Material</a><br/>  ∘ <a class="ae lo" href="#42a9" rel="noopener ugc nofollow">Vectors</a><br/>  ∘ <a class="ae lo" href="#7f10" rel="noopener ugc nofollow">Deques</a><br/>  ∘ <a class="ae lo" href="#a5a2" rel="noopener ugc nofollow">Stacks</a><br/>  ∘ <a class="ae lo" href="#9974" rel="noopener ugc nofollow">Lists and forward lists</a><br/>  ∘ <a class="ae lo" href="#1cb0" rel="noopener ugc nofollow">Demo Code</a><br/>· <a class="ae lo" href="#b63a" rel="noopener ugc nofollow">Additional Resources: Dig Deeper</a><br/>· <a class="ae lo" href="#5cd2" rel="noopener ugc nofollow">Contact</a></span></pre><p id="fbf3" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">作为我们探索C++的<em class="ml">标准模板库</em> ( <em class="ml"> STL </em>)的一部分，我们接下来着手该库的一个关键方面，<em class="ml"> STL容器</em>。</p><p id="7bca" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">本教程结束时，您将理解以下内容。</p><ul class=""><li id="ebf9" class="mm mn it lr b ls lt lv lw ly mo mc mp mg mq mk mr ms mt mu bi translated">如何选择正确的<em class="ml">容器</em>以及这样做的重要性。</li><li id="1fbe" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk mr ms mt mu bi translated">STL提供的<em class="ml">容器</em>的类型，以及它们的优缺点。</li><li id="04a3" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk mr ms mt mu bi translated">给定算法的最佳数据结构(即<em class="ml">容器</em>)选择。</li></ul><p id="a4e3" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">首先，我们介绍<em class="ml">容器</em>以及它们在交付<em class="ml">有效c++</em>【1】中的重要性。</p><p id="f0c4" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">对于不熟悉<em class="ml"> STL </em>的读者，或者那些寻找完整故事的人，强烈建议回到第1部分。</p><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/a-standard-template-library-stl-tutorial-series-9379bcbcd2fb"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">标准模板库(STL)教程系列</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">第1部分:概述和动机</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">better编程. pub</p></div></div><div class="nm l"><div class="nn l no np nq nm nr lb nd"/></div></div></a></div><h1 id="3e78" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">概观</h1><p id="c720" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">与第一部分中的<a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/a-standard-template-library-stl-tutorial-series-9379bcbcd2fb?sk=a450fff61e254ecb6c5f2000f81eb8a2">一样，<em class="ml"> STL </em>包括如下所示的模块:</a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/2a7b5971178c41264805286fb764e1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diDK8Ib6Xdc5RdUWrsKJcQ.png"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated">图来源:<a class="ae lo" href="https://www.mygreatlearning.com/blog/standard-template-library-in-c/" rel="noopener ugc nofollow" target="_blank">https://www . mygreatlearning . com/blog/standard-template-library-in-c/</a></p></figure><p id="be06" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">每个孩子都是博客的主题。因此，<em class="ml"> STL </em>作为一个整体，将跨越多个部分。</p><h2 id="6c8b" class="li lj it bd nt ot ou dn nx ov ow dp ob ly ox oy od mc oz pa of mg pb pc oh iz bi translated">为什么要用<em class="pd"> STL </em>？</h2><p id="f0ca" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">STL为基本算法和数据结构提供了额外的功能，使用户受益。</p><ol class=""><li id="c1ea" class="mm mn it lr b ls lt lv lw ly mo mc mp mg mq mk pe ms mt mu bi translated">它经过了很好的测试和优化。</li><li id="71a5" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk pe ms mt mu bi translated">没有必要重新发明轮子。</li><li id="6f80" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk pe ms mt mu bi translated">它导致更短、更紧凑的源代码。</li></ol><p id="6a65" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">注:(2)假设动机是实际的或解决了研究或工业中的一个问题。当学习数据结构(如堆栈)的<em class="ml">和</em>时，一个有用的练习可能包括没有<em class="ml"> STL </em>的类实现；然而，我相信在学习这些概念的同时，还有更有效的方法来学习现成的STL。例如，作为C++入门课程或自学的一部分，重新实现<code class="fe pf pg ph le b">&lt;string&gt;</code>头文件也在核心C++中(参见<a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/a-standard-template-library-stl-tutorial-series-9379bcbcd2fb"> Part 1 </a>)。也许是未来的主题:)</p><p id="a816" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">此外，<em class="ml"> STL </em>作为一个整体，在相关算法和数据结构方面是可扩展的和高效的(参见<a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/a-standard-template-library-stl-tutorial-series-9379bcbcd2fb">第一部分</a>)。</p><p id="fb94" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">回忆。</strong>提供了<em class="ml"> M个容器</em>和<em class="ml"> N个算法</em>，当穷举运行组合时，通常会有<em class="ml">个NxM </em>个进程。然而，<em class="ml">迭代器是STL哲学的核心</em>和结构，将操作数量减少到了<em class="ml"> N </em> <em class="ml"> + </em> M。</p><div class="ks kt ku kv gt ab cb"><figure class="pi kw pj pk pl pm pn paragraph-image"><img src="../Images/e8d36b3df04b659cf9abae2587e1677e.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*bmULmJWym-YyatqxcsBbDQ.png"/></figure><figure class="pi kw po pk pl pm pn paragraph-image"><img src="../Images/d306c97d5a004436495d9d24e908d48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*xnhJ9WSB3uxzGrytWcij9g.png"/><p class="op oq gj gh gi or os bd b be z dk pp di pq pr translated">处理N个算法和M个容器通常需要NxM次操作(左图)；STL迭代器允许进程的数量急剧减少(即N + M，右)。作者创作的插图(<a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/a-standard-template-library-stl-tutorial-series-9379bcbcd2fb">第一部分</a>)。</p></figure></div><p id="9a27" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">包括<em class="ml">容器</em>、<em class="ml">算法</em>、<em class="ml">迭代器</em>或<em class="ml">函子</em>的头，后三个主题是未来博客的主题。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ps"><img src="../Images/7a6ab075a31ed233f12e7592966c1d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyT2-CwKq55EEWTsBV8msg.png"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated">作为标准C++的一部分，包含头文件以使用STL。由作者创作。</p></figure><p id="90d4" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在本系列结束时，将会很好地理解图(右)中所示的所有组件及其连接。所以现在让我们更深入地研究一下<em class="ml">STL</em>T26】容器。</p><h1 id="98fe" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">STL容器</h1><p id="74af" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">STL容器是具有各自功能的通用数据结构。为什么不实现我们自己的目标呢——上一节1–3中列出的动机非常简洁地总结了原因。让我们参考一位有效C++技术专家和领导者的话。</p><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="cafb" class="li lj it le b gy lk ll l lm ln">They’re simply better than their competition, regardless of whether that competition comes from containers in other libraries or is a container type you’d write yourself. STL containers aren’t just good. They’re really good. </span><span id="146d" class="li lj it le b gy pt ll l lm ln">— Scott Meyers</span></pre><h2 id="08f3" class="li lj it bd nt ot ou dn nx ov ow dp ob ly ox oy od mc oz pa of mg pb pc oh iz bi translated">容器类型</h2><p id="839e" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">在列出作为<em class="ml"> STL </em> API的一部分提供的具体数据结构之前，让我们从更高的层面来看一下它的内容。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/3794603cffd8ce44f7fb35b0775b8e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_WOIK7LtQYWI8OsZzIm5w.png"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated"><strong class="bd pv">顺序</strong>和<strong class="bd pv">关联</strong>容器类型。<strong class="bd pv">关联</strong>包含<strong class="bd pv"> <em class="pd">有序</em> </strong> <em class="pd">和</em> <strong class="bd pv"> <em class="pd">无序</em> </strong> <em class="pd">。作者创造了可视化。</em></p></figure><p id="5629" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">虽然我们将关注基于序列的数据结构的<em class="ml">容器</em>，但是让我们用每种类型的例子来重温前面的图。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/48fb4b8f4c9e35a33344f5419b379ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_NT-zs7Gt536q28CTIh3w.png"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated">STL提供的每个容器类型的例子。对于每个样本用例(列表的顶部)，其各自的容器类型可能是基础，特定的容器，如传统的命名和在STL API中，被列为项目符号(底部)。</p></figure><p id="7b5f" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这里是对<em class="ml">容器</em>类型的一个浏览，以及一个简短的描述。在阅读完这篇文章后，这张表以及其他一些内容将会变得清晰。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="px py l"/></div><p class="op oq gj gh gi or os bd b be z dk translated">STL容器名称、类型(即顺序、关联或适配器)和简要描述。</p></figure><h2 id="7914" class="li lj it bd nt ot ou dn nx ov ow dp ob ly ox oy od mc oz pa of mg pb pc oh iz bi translated">可视化容器</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/0e87d7a04ad510494cd9bcb1b731f21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdgEmmJ1yNDxyAI8qf6g2w.png"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated">每种类型的STL容器，描述每种容器的结构。图片由作者提供。</p></figure><h2 id="af6e" class="li lj it bd nt ot ou dn nx ov ow dp ob ly ox oy od mc oz pa of mg pb pc oh iz bi translated">为什么使用STL容器？</h2><p id="b2c8" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">在他的<em class="ml">现代有效的STL</em>【1】中，史蒂夫·迈耶选择了以下项目作为他的名著的开头。</p><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="ac29" class="li lj it le b gy lk ll l lm ln">ℹ️ <strong class="le jd">Item 1.</strong> Choose your containers with care.</span></pre><p id="ca44" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">正如我们将看到的，不同的<em class="ml">容器</em>最适合特定的场景。虽然<em class="ml"> STL </em>接口足够干净和一致，可以很容易地用一种类型替换另一种类型(如下面的示例代码所示)，但是容器的选择会极大地影响源代码的速度和清晰度。另外，<em class="ml">算法</em>对于<em class="ml">容器</em>中的选项不是不可知的。(即，当我们到达下面的<strong class="lr jd">项目2 </strong>时将被覆盖。</p><p id="a32f" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在采用一种手段选择最佳容器之前，让我们先来看一组<em class="ml">序列容器</em>。</p><h1 id="e9a9" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">容器规格</h1><p id="82ea" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">让我们首先阅读下表中列出的<em class="ml">类型</em>列(参见本博客后面的<em class="ml">描述</em>列，或者现在浏览一下)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="px py l"/></div><p class="op oq gj gh gi or os bd b be z dk translated">STL容器类型、描述和源(即构造函数签名)。顶部的表格列出了基于序列的容器，而底部的表格是关联容器。</p></figure><h1 id="659b" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">顺序容器</h1><p id="1b89" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">总之，对于基于序列的容器:</p><ul class=""><li id="0cac" class="mm mn it lr b ls lt lv lw ly mo mc mp mg mq mk mr ms mt mu bi translated">尺寸是静态的，而其他的都是动态的。</li><li id="eceb" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk mr ms mt mu bi translated"><code class="fe pf pg ph le b">array</code>和<code class="fe pf pg ph le b">array</code>序列分别包括<code class="fe pf pg ph le b">vector</code>和<code class="fe pf pg ph le b">deque</code>；<code class="fe pf pg ph le b">list</code>和<code class="fe pf pg ph le b">forward_list</code>使用双链表和单链表。</li><li id="5d35" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk mr ms mt mu bi translated">只有<code class="fe pf pg ph le b">list</code>和<code class="fe pf pg ph le b">forward_list</code>不支持随机接入而是分别支持前向/后向和前向。</li><li id="811c" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk mr ms mt mu bi translated">只有<code class="fe pf pg ph le b">list</code>和<code class="fe pf pg ph le b">forward_list</code>总是释放内存；<code class="fe pf pg ph le b">vector</code>和<code class="fe pf pg ph le b">deque</code>有方法<code class="fe pf pg ph le b">shrink_to_fit()</code>，后者有时会自己释放内存。</li><li id="0055" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk mr ms mt mu bi translated">最后，<code class="fe pf pg ph le b">vector</code>和<code class="fe pf pg ph le b">list</code>有内存预留，而<code class="fe pf pg ph le b">deque</code>和<code class="fe pf pg ph le b">forward_list</code>没有。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="px py l"/></div></figure><h1 id="c6b4" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">选择正确的容器</h1><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="9a68" class="li lj it le b gy lk ll l lm ln">ℹ️ <strong class="le jd">Item 2.</strong> Beware the illusion of container-independent code.</span></pre><p id="bc2a" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">让我们总结一个<em class="ml">的情况</em>和相应的<em class="ml">容器</em>最好交给<em class="ml">挑选。</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="px py l"/></div><p class="op oq gj gh gi or os bd b be z dk translated">RA表示随机访问(即查找)。</p></figure><p id="17ff" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">现在让我们利用不同类型的<em class="ml">容器</em>的特征，使用以下流程图中的逻辑来选择最佳容器。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qa"><img src="../Images/450e61978a5ecea8ec9c7bc1872b388e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxJSlAZzVVVcPfLowTyXkg.png"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated">一个流程图，它导致表示容器类型的叶子。请注意，图例根据上面列出的不同类别对容器进行分组。在<a class="ae lo" href="https://lucid.app/lucidchart/65b0aa00-dc28-4df6-9f9b-5c6c64e3e9f0/edit?viewport_loc=-2214%2C-2874%2C4379%2C1958%2C0_0&amp;invitationId=inv_77d799d9-49fa-4e91-9da7-85cbcfa32f65#" rel="noopener ugc nofollow" target="_blank"> LucidChart </a>上查看作者创建的原始图表。</p></figure><p id="5d05" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">然而，在问题中并不总是提供这样的逻辑。为了概括起见，让我们在下表中分解不同类型的big-O复杂性。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qb"><img src="../Images/71e222acc0349353b452db090dd48616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3RXIjKmJZ-x7npACkl2eA.png"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated">集装箱:操作复杂性。如果为空，则相应的操作(即方法)不包含在该容器的接口中。它是作者使用<a class="ae lo" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建的。</p></figure><p id="c8fe" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><a class="qc qd ep" href="https://medium.com/u/13cdd863b4c?source=post_page-----be7bdaa222b0--------------------------------" rel="noopener" target="_blank"> Mai Pham </a>在下面的博文中总结了Big-O的复杂性。</p><div class="na nb gp gr nc nd"><a href="https://medium.com/nerd-for-tech/the-big-o-18fea712ae6b" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">大O</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">理解Big-O符号的初学者指南</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="qe l no np nq nm nr lb nd"/></div></div></a></div><p id="fe1e" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">总之</strong></p><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="94e6" class="li lj it le b gy lk ll l lm ln">💡 Vector, list, and deque offer the programmer different complexity trade-offs and should be used accordingly; the vector is the type of sequence that should be used by default, and a list should be used when there are frequent insertions and deletions from the middle of the sequence, the deque is the data structure of choice when most insertions and deletions take place at the beginning or at the end of the sequence.</span></pre><h1 id="f2ad" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">结论</h1><p id="d187" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">STL容器是C++中存储数据的最佳方式。与其他方法(如数组)相比，它们有很多优点。我们已经了解了几种不同类型的容器及其用途。通过了解各种选项之间的权衡，可以确定给定算法的最佳容器。STL提供了一个易于使用的接口，使其成为大多数应用程序的最佳选择。我们现在知道STL容器为数据结构提供了各种各样的选择，都有不同的优点和缺点。最佳容器取决于具体的算法和目标数据。一般来说，STL容器是算法的最佳选择，因为它们高效且通用。</p><p id="232f" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">总之，STL容器是这项工作的最佳工具。它们为您的数据结构和算法选择完美的容器提供了广泛的选项。此外，STL经过了充分的测试，非常可靠，因此您可以确信您的代码将按预期工作。</p><h1 id="c5ec" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">参考</h1><p id="e461" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">[1]<a class="ae lo" href="http://www.uml.org.cn/c%2B%2B/pdf/EffectiveSTL.pdf" rel="noopener ugc nofollow" target="_blank">http://www.uml.org.cn/c%2B%2B/pdf/EffectiveSTL.pdf</a></p><p id="647a" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">[2]<a class="ae lo" href="https://www.abebooks.com/Effective-STL-Specific-Ways-Improve-Use/22536211326/bd" rel="noopener ugc nofollow" target="_blank">https://www . Abe books . com/Effective-STL-Specific-Ways-Improve-Use/22536211326/BD</a></p><div class="na nb gp gr nc nd"><a href="https://www.abebooks.com/Effective-STL-Specific-Ways-Improve-Use/22536211326/bd" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">9780201749625:有效的STL: 50种改善你使用标准模板库的具体方法…</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">评论:写给中级或高级C++程序员，著名的C++专家斯科特迈耶斯提供了基本的…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">www.abebooks.com</p></div></div></div></a></div><p id="7d50" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><a class="ae lo" href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/" rel="noopener ugc nofollow" target="_blank"><strong class="lr jd">【3】有效的现代C++ </strong> </a></p><div class="na nb gp gr nc nd"><a href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">有效的现代C++</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">掌握C++11和C++14不仅仅是熟悉它们引入的特性…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">www.oreilly.com</p></div></div><div class="nm l"><div class="qf l no np nq nm nr lb nd"/></div></div></a></div><h1 id="3b99" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">补充材料</h1><h2 id="42a9" class="li lj it bd nt ot ou dn nx ov ow dp ob ly ox oy od mc oz pa of mg pb pc oh iz bi translated">向量</h2><p id="c857" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">我们还没有讨论实现(例如，如何使用<em class="ml">容器</em> ) —这是有意的；这一系列的进程博客将会告诉我们这一点！但是，首先，我们必须理解<em class="ml">容器和</em>当面对实现细节时我们拥有的选项。</p><p id="78d7" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如上所述，不同的STL <em class="ml">容器</em>提供了接口的一致性。此外，应该已经很简单，并将继续变得越来越明显，对于底层结构中的差异，每个都有独特的特征:这是我们将在即将到来的博客中深入探讨的主题。</p><p id="cd28" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">让我们以<code class="fe pf pg ph le b">std::vector</code>为例，它类似于其他<em class="ml">容器</em>。</p><p id="1707" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><code class="fe pf pg ph le b">std::vector</code>模板提供了动态大小的基于堆的数组，而不需要显式的内存管理。</p><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="ace5" class="li lj it le b gy lk ll l lm ln">std::vector v; <br/>v.push_back(1); <br/>v.push_back(2); <br/>v.push_back(3); <br/>std::cout &lt;&lt; v[0] &lt;&lt;‘, ‘&lt;&lt; v[1] &lt;&lt;‘, ‘&lt;&lt; v[2] &lt;&lt; std::endl; <br/>// 1, 2, 3</span></pre><p id="4223" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">构造函数</strong></p><p id="e789" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">STL提供了多种构造函数。对于<code class="fe pf pg ph le b">std::vector</code>来说有以下几点:</p><ul class=""><li id="b916" class="mm mn it lr b ls lt lv lw ly mo mc mp mg mq mk mr ms mt mu bi translated"><em class="ml">默认构造函数:</em>创建一个空向量。</li><li id="5219" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk mr ms mt mu bi translated"><em class="ml">复制构造器:</em>创建一个现有向量的副本。</li><li id="3d25" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk mr ms mt mu bi translated"><code class="fe pf pg ph le b">vector v(<em class="ml">N</em>, <em class="ml">V</em>)</code>:用<code class="fe pf pg ph le b"><em class="ml">K</em></code>值设置的<code class="fe pf pg ph le b"><em class="ml">N</em></code>元素创建一个矢量。</li><li id="a4f3" class="mm mn it lr b ls mv lv mw ly mx mc my mg mz mk mr ms mt mu bi translated"><code class="fe pf pg ph le b">vector v(<em class="ml">N</em>)</code>:创建一个带有<code class="fe pf pg ph le b"><em class="ml">N</em></code>元素(零值)的矢量</li></ul><p id="a4fb" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">转换为数组</strong></p><p id="a7ad" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如果你有一个条目<code class="fe pf pg ph le b">v</code>的向量，但是需要通过函数调用<code class="fe pf pg ph le b">void f(int *a)</code>来传递它(也就是说，接受一个指向条目数组<code class="fe pf pg ph le b">*a</code>的指针)，你认为我们该怎么做呢？</p><p id="49e3" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><em class="ml">解决方案</em>:</p><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="de8e" class="li lj it le b gy lk ll l lm ln">void f(int *a); <br/>vector v; <br/>f(&amp;v[0]);</span></pre><p id="3009" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><em class="ml">解释</em>:</p><p id="5fbd" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">利用向量是数组的优势，将指向底层数组开头的指针传递给函数:</p><h2 id="7f10" class="li lj it bd nt ot ou dn nx ov ow dp ob ly ox oy od mc oz pa of mg pb pc oh iz bi translated"><strong class="ak">德克斯特</strong></h2><p id="5cc8" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated"><code class="fe pf pg ph le b">std::deque</code>模板是一个双端队列，与vectors的接口类似，但是在数据结构的前端和后端高效地插入和删除。<code class="fe pf pg ph le b">push_back()</code>和<code class="fe pf pg ph le b">pop_back()</code>，以及大多数其他<code class="fe pf pg ph le b">std::vector</code>操作也可用于deques还有，<code class="fe pf pg ph le b">std::deque</code>提供<code class="fe pf pg ph le b">push_front()</code>和<code class="fe pf pg ph le b">pop_front()</code>。</p><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="e801" class="li lj it le b gy lk ll l lm ln">💡 <strong class="le jd">Note.</strong> Deques are not guaranteed to be implemented internally as contiguous arrays.</span></pre><h2 id="a5a2" class="li lj it bd nt ot ou dn nx ov ow dp ob ly ox oy od mc oz pa of mg pb pc oh iz bi translated"><strong class="ak">堆栈</strong></h2><p id="3ea3" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">模板不是一个独立的数据结构。它是一个<em class="ml">适配器模板</em>——一个现有模板的专用接口。</p><p id="9bf0" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">默认情况下，<code class="fe pf pg ph le b">std::stack</code>是用<code class="fe pf pg ph le b">std::deque</code>实现的，但是用户可以指定使用<code class="fe pf pg ph le b">std::vector</code>或<code class="fe pf pg ph le b">std::list</code>。</p><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="3f82" class="li lj it le b gy lk ll l lm ln">💡 <strong class="le jd">Note.</strong> The pop method does not return the item that was popped. If you want this item, use the top method before the pop method.</span></pre><p id="97d6" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">堆栈提供了基本的堆栈操作:</p><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="f45a" class="li lj it le b gy lk ll l lm ln">stack s; if (!s.empty()) { <br/>// Test if empty<br/>    std::cout &lt;&lt; s.size() &lt;&lt; std::endl; // Size of the stack <br/>} <br/>s.push(4); // “push” operation <br/>std::cout &lt;&lt; s.top() &lt;&lt; std::endl; // top of stack <br/>s.pop(); // “pop” operation</span></pre><h2 id="9974" class="li lj it bd nt ot ou dn nx ov ow dp ob ly ox oy od mc oz pa of mg pb pc oh iz bi translated"><strong class="ak">列表和转发列表</strong></h2><p id="8960" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">基于链表的容器，<code class="fe pf pg ph le b">std::forward_list</code>和<code class="fe pf pg ph le b">std::list</code>在一些关键方面有所不同。首先，前者只包含一个到下一个元素的链接，而后者有两个与前一个组件相关的连接。两个链接在任一方向上高效地迭代列表，这带来了额外的内存开销，并且在插入和移除元素时会有轻微的时间开销。因此forward_list对象比<a class="ae lo" href="http://www.cplusplus.com/list" rel="noopener ugc nofollow" target="_blank"> list </a>对象更有效，尽管它们只是向前迭代。</p><p id="25b0" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">与其他基本的标准序列容器(<a class="ae lo" href="http://www.cplusplus.com/array" rel="noopener ugc nofollow" target="_blank">数组</a>、<a class="ae lo" href="http://www.cplusplus.com/vector" rel="noopener ugc nofollow" target="_blank">向量</a>和<a class="ae lo" href="http://www.cplusplus.com/deque" rel="noopener ugc nofollow" target="_blank">队列</a>)相比，forward_list在插入、提取和移动元素到容器中的任意位置方面更胜一筹。正如我们将在本系列的下一部分中讨论的，算法经常使用这些优势(例如，排序算法)。</p><h2 id="1cb0" class="li lj it bd nt ot ou dn nx ov ow dp ob ly ox oy od mc oz pa of mg pb pc oh iz bi translated">演示代码</h2><p id="3542" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated">让我们使用不同的<em class="ml">顺序容器</em>来存储滚动骰子的值。然后，我们将查看所有值的内存地址，以分析不同<em class="ml">容器</em>在内存分配中的时间和趋势。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="px py l"/></div></figure><p id="34bf" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">请注意，在已经分配内存的情况下，向量速度最快，但在由于空间不足而需要进行新分配的情况下，向量速度最慢(参见视频末尾的总结)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/a6a115cea8e2112563dcd93d60c7d1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9_bB46c5W5_Im6RIrZ-Rvg.gif"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated">向量。请注意，内存保持连续，因为当需要额外空间时，所有元素都会移动。点击观看原视频<a class="ae lo" href="https://drive.google.com/file/d/1nk6RP5qw-SDHfCEF4KY564Ay1SlDUwEC/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/0dd1c7d05af67d931ed18a18237ded39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z03aX3jN2MKmcdvTjUYbgQ.gif"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated"><strong class="bd pv">得缺。</strong>看原文视频<a class="ae lo" href="https://drive.google.com/file/d/1kzSFuQVhl3lghU2RXPBrGDqvx1NFHb4N/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/117566a03539d6e4b5fc7b92b0884396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jJ9I-5KZIDdwdpRs5fQ6fA.gif"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated"><strong class="bd pv">转发_列表</strong>。这里看原视频<a class="ae lo" href="https://drive.google.com/file/d/1cI3Iu7sB7a555j8hYiM9NgOrMmA4y4MP/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/c5d8e6de0f9c921768506dc2af82e8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*L_onqxnvfOYKaNS06QPWzQ.gif"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated"><strong class="bd pv">列表</strong>。这里看原视频<a class="ae lo" href="https://drive.google.com/file/d/12AU5ypMuv5rlxaBthjQNsQRbMBOHexlq/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></p></figure><h1 id="69ef" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">其他资源:深入挖掘</h1><p id="2acc" class="pw-post-body-paragraph lp lq it lr b ls oj kd lu lv ok kg lx ly ol ma mb mc om me mf mg on mi mj mk im bi translated"><em class="ml"> STL </em> <em class="ml">容器</em>有一个可选参数(即<code class="fe pf pg ph le b">Allocator()</code>)，允许控制内存(即管理)。王思然·尼万在这个话题上做得非常出色。</p><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-not-fragment-memory-when-using-c-stl-containers-b634adb76dc1"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">如何在使用C++ STL容器时不产生内存碎片</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">STL容器为什么会碎片化你的内存，如何避免。</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">better编程. pub</p></div></div><div class="nm l"><div class="qh l no np nq nm nr lb nd"/></div></div></a></div><p id="87f9" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">Abhishek Rathore写了一个涵盖STL所有组件的实用指南。</p><div class="na nb gp gr nc nd"><a href="https://abhiarrathore.medium.com/the-magic-of-c-stl-standard-template-library-e910f43379ea" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">C++ STL(标准模板库)完全实用指南</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">C++ STL是C++中竞争性编程的一个组成部分。如果你是…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">abhiarrathore.medium.com</p></div></div><div class="nm l"><div class="qi l no np nq nm nr lb nd"/></div></div></a></div><p id="2d54" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><a class="qc qd ep" href="https://medium.com/u/aee547023ab2?source=post_page-----be7bdaa222b0--------------------------------" rel="noopener" target="_blank">迈克·麦克米兰</a>深究<em class="ml">STL</em>T1】。</p><div class="na nb gp gr nc nd"><a href="https://levelup.gitconnected.com/learning-c-the-stl-and-the-vector-class-beead0ac745f" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">学习c++:STL和vector类</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">标准模板库中最流行的容器是vector类。向量正迅速成为…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nm l"><div class="qj l no np nq nm nr lb nd"/></div></div></a></div><p id="e6ee" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">还有<code class="fe pf pg ph le b">map</code>和<code class="fe pf pg ph le b">multimap</code>。</p><div class="na nb gp gr nc nd"><a href="https://levelup.gitconnected.com/learning-c-the-stl-and-maps-and-multimaps-993f5b931287" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">学习c++:STL、地图和多重地图</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">有许多应用程序要求数据以键值关系与其他数据相关联…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nm l"><div class="qk l no np nq nm nr lb nd"/></div></div></a></div><p id="877c" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><a class="qc qd ep" href="https://medium.com/u/c70e57fc0605?source=post_page-----be7bdaa222b0--------------------------------" rel="noopener" target="_blank"> Aditya Jain </a>演示了使用<em class="ml"> STL </em>容器来实现<em class="ml">树</em>和<em class="ml">图</em>结构。</p><div class="na nb gp gr nc nd"><a href="https://medium.com/the-programming-club-iit-indore/graphs-and-trees-using-c-stl-322e5779eef9" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">使用C++ (STL)的图形和树</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">入门研讨会(IITI PClub)</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="ql l no np nq nm nr lb nd"/></div></div></a></div><p id="38ed" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">斯科特迈耶的有效的STL高度启发了这个博客。Vanand Gasparyan对这本书的评价相当不错。</p><div class="na nb gp gr nc nd"><a href="https://medium.com/tech-book-reviews/effective-stl-90c2bebed852" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">有效STL</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">改进标准模板库使用的50种具体方法</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="qm l no np nq nm nr lb nd"/></div></div></a></div></div><div class="ab cl qn qo hx qp" role="separator"><span class="qq bw bk qr qs qt"/><span class="qq bw bk qr qs qt"/><span class="qq bw bk qr qs"/></div><div class="im in io ip iq"><p id="f906" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在我的(即<a class="qc qd ep" href="https://medium.com/u/8049fa781539?source=post_page-----be7bdaa222b0--------------------------------" rel="noopener" target="_blank">约瑟夫·罗宾逊，博士</a>)关于<em class="ml">智能指针</em>的博客中了解更多关于内存管理的知识，这是一个由三部分组成的系列。</p><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/smart-pointers-in-cpp-708486276526"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">理解C++中的智能指针</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">更聪明地工作，而不是更努力</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">better编程. pub</p></div></div><div class="nm l"><div class="qu l no np nq nm nr lb nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-smart-pointers-in-cpp-6c3854593503"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">现代C++:智能指针的近距离观察</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">《理解智能指针》续集betterprogramming.pub</h3></div></div><div class="nm l"><div class="qv l no np nq nm nr lb nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-smart-pointer-iii-909512a5eb05"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">通过直观的视觉效果解释C++智能指针</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">我的C++指针系列的第3部分</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">better编程. pub</p></div></div><div class="nm l"><div class="qw l no np nq nm nr lb nd"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qx"><img src="../Images/877c10855fff20171c633304a66faee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qtxNCWHz1kmXiKqlaGa2g.png"/></div></div></figure><h1 id="5cd2" class="ns lj it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">接触</h1><pre class="ks kt ku kv gt ld le lf lg aw lh bi"><span id="08fb" class="li lj it le b gy lk ll l lm ln"><strong class="le jd">Want to Connect? </strong>Follow Dr. Robinson on <a class="ae lo" href="https://www.linkedin.com/company/superannotate/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae lo" href="https://twitter.com/jrobvision" rel="noopener ugc nofollow" target="_blank">Twitter</a>, <a class="ae lo" href="https://www.facebook.com/superannotate" rel="noopener ugc nofollow" target="_blank">Facebook</a>, and <a class="ae lo" href="https://www.instagram.com/doctor__jjj/" rel="noopener ugc nofollow" target="_blank">Instagram</a>. Visit my homepage for papers, blogs, email signups, and more!</span></pre><div class="na nb gp gr nc nd"><a href="https://www.jrobs-vision.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">人工智能工程师|约瑟夫·p·罗宾逊</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">问候！我是Vicarious Surgical的人工智能工程师，致力于推进下一代外科机器人技术。我的…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">www.jrobs-vision.com</p></div></div><div class="nm l"><div class="qy l no np nq nm nr lb nd"/></div></div></a></div></div></div>    
</body>
</html>