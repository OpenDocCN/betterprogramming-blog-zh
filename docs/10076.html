<html>
<head>
<title>JWT: Ultimate How-To Guide With Best Practices In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JWT:JavaScript最佳实践终极指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/jwt-ultimate-how-to-guide-with-best-practices-in-javascript-f7ba4c48dfbd?source=collection_archive---------0-----------------------#2021-11-24">https://betterprogramming.pub/jwt-ultimate-how-to-guide-with-best-practices-in-javascript-f7ba4c48dfbd?source=collection_archive---------0-----------------------#2021-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cbaf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Node.js中的JSON Web Token从基础到代码示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c2ee1dd0b82c05658fdcb4b2a2bd8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOJ2xSloa0iv_zXgOvHLhw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者原创作品。</p></figure><p id="b2db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web Token (JWT) </a>是一个标准的<a class="ae lu" href="https://datatracker.ietf.org/doc/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>，用于交换加密签名的JSON数据。这可能是目前web上最流行的授权标准，尤其是对于微服务和分布式架构。</p><p id="8cbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一名开发人员，当您被要求实现一个现代的web应用程序时，您可能需要将其分解成独立的服务。独立服务和分布式架构有很多优点。您需要考虑的一件事是，您的服务如何知道用户被允许使用它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/ec670296cd7847a086f876abedc91f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*RcQ6eZMjeoHnlH9dXZQ3Zw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="de7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用有状态会话管理，您的解决方案将是创建一个在系统的所有部分之间共享的用户会话。但是随着分布式系统的发展，共享一个会话可能会很有挑战性。</p><p id="1835" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有状态会话管理的替代方法是传递一个无状态的JSON Web令牌，它将代表一个访问令牌或一个身份令牌。它将持有允许您的服务授权其用户的声明，并且它将使用密码学的魔力来确保令牌是可信的并且没有被篡改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/b14ae7e62a49174b441234bd02c4bb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*r2VcN90qhZd76GBsqWC1OQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="4db5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，您的服务不需要共享有状态会话，它们只需要信任提供给它们的令牌。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h1 id="12e8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">标准会议</h1><p id="18b8" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">如果你像我一样已经有一段时间了，你会知道web上的标准方法是使用会话和基于会话的cookies。</p><p id="0beb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用户将使用他们的凭证登录，服务器将返回一个带有他们的会话ID的cookie。然后，每次请求授权用户时，用户都会发送该cookie。</p><p id="f58d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如今，这个过程是如此自动化，你几乎不需要写任何代码来支持它，浏览器知道自动发送每个请求的会话cookie。超级方便。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/55c66558a902ace4d00ea322f68050c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Id6Y9v8aq4skybxZYqyzzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="673d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的图表应该感觉相当熟悉和简单，这是网站已经做了很长时间。</p><p id="2124" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现代web解决方案通常基于多个服务器或多个服务协同工作。如果您希望将会话用于这些目的，这意味着您将需要一些集中式存储，以便您的会话可用于需要授权访问的体系结构的所有部分。</p><p id="e341" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一个简单的网站，实现标准的会话管理要容易得多，服务器上的库和浏览器中的cookie管理都很好地支持标准的会话管理。</p><p id="1d48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JWT更难实现，需要一个有经验的团队来做一个架构良好的安全解决方案，即使使用像<a class="ae lu" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>这样的产品。</p><p id="c544" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不认为经典的会话管理已经死亡。我甚至会一直推荐使用它，直到您能够证明基于您的解决方案的分布式架构需要JWT。</p><p id="9101" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，因为JWT是一个具有挑战性和令人兴奋的话题，让我们深入它的复杂性，了解它的优势。</p><h1 id="fa59" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么是JWT？</h1><p id="b6b8" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">JWT只是一个签名的JSON，旨在供双方共享。签名用于验证令牌的真实性，以确保JSON数据没有被篡改。令牌本身的数据没有加密。</p><p id="ec4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">验证用户身份的方法不会因JWT而改变。您仍然可以使用用户名和密码(尽管您应该使用更安全的方法，如双因素身份验证或DID Auth)。区别仅在于如何管理用户授权(如何让您的服务知道用户有权限做某事)。</p><p id="5289" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在服务器上，验证令牌签名并直接访问JSON数据，这对于分布式架构来说要简单得多。</p><p id="b82c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您的web应用程序前端，您的代码需要管理令牌如何存储在浏览器中(cookie、会话存储或本地存储)以及它如何随请求传递到服务器(作为授权承载标头)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/1fa05ff097ca970a22b621561b57fa97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SrAa0GBdZF6Wh1IwEU_BVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="1d9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您比较基于会话的授权和JWT的图表，您会注意到原理非常相似。使用JWT的主要原因是客户端-服务器通信保持无状态。</p><p id="ba57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JWT之所以流行，是因为无状态使得设计独立的服务变得更加容易，而不必处理共享的会话管理。然而，无论是亚马逊网络服务、<a class="ae lu" href="https://azure.microsoft.com/es-es/blog/using-sql-azure-for-session-state/" rel="noopener ugc nofollow" target="_blank">微软Azure </a>还是<a class="ae lu" href="https://cloud.google.com/go/getting-started/session-handling-with-firestore" rel="noopener ugc nofollow" target="_blank">谷歌云</a>，每个云提供商都有管理会话的解决方案。在您自己的服务器上，您可以使用<a class="ae lu" href="https://redis.com/solutions/use-cases/session-management/" rel="noopener ugc nofollow" target="_blank"> Redis </a>作为会话存储的共享缓存。</p><p id="e09e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JWT通常被认为是比通用会话管理更安全的解决方案。然而，我认为这是很有争议的。这两种方法各有优缺点，为了方便用户，您必须做出妥协。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h1 id="e561" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用axios的Node.js的jsonwebtoken库</h1><p id="ab0a" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">Node.js有一个很棒的库，来自JWT的auth 0 guys:<a class="ae lu" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank">jsonwebtoken</a>，直接出现在<a class="ae lu" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT网页</a>上。</p><p id="5f2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建令牌，您只需拨打:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><p id="32eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个基本调用将使用一个秘密密钥加密JSON数据，这个秘密密钥通常存储为一个环境变量。没有其他参数，这是一个同步调用，将使用对称加密HS256 (HMAC与SHA-256)。</p><p id="2899" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的令牌可能如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5793" class="ne ma it na b gy nf ng l nh ni"><em class="nj">eyJhbGciOfJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkaWWiOiJka…afyMH0.WrIEBW5LNLjfGWqIA4XKsyIiuWzbIIpNadfZVkmA6hPs</em></span></pre><p id="a1aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">令牌只是Base64代码，解码后看起来像这样:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0195" class="ne ma it na b gy nf ng l nh ni">{"alg":"HS256","typ":"JWT"}{"id":"fo:%sk@lr"}�k��c~¶.�S��K�`ѱ</span></pre><p id="6cab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您在末尾看到的随机字符是允许您验证令牌真实性的签名，但是您添加的数据和声明不会被加密，除非您对它们进行加密，如您所见。</p><p id="d980" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将这个令牌作为服务器响应的一部分返回给前端应用程序。</p><p id="0787" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，前端应用程序需要将令牌添加到每个需要授权的请求的标头中。使用<a class="ae lu" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>库时，这样的调用可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><p id="d046" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意授权头，这是我们添加令牌的地方。</p><p id="cd32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们在服务器端验证令牌并访问其秘密:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><p id="c9ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是它的神奇之处。有了这些信息，你应该能够制定一个可行的解决方案。</p><p id="fc5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，对于您的实现，也有一些您应该考虑的事项。</p><p id="fee3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">HS512的完整实施如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><h1 id="9183" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Node.js中的jose库示例</h1><p id="6470" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">对于JWT来说，更好的Node.js库是jose。</p><p id="64fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它使用起来有点复杂，但它支持使用JWK，或JWE，以及与EdDSA签约，所以我会向您推荐它作为一个选项。</p><p id="1ada" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个使用带有EdDSA的库并导入PEM私有和公共密钥的示例(还要注意EdDSA密钥有多短，尽管提供了更好的保护):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><h1 id="b0ae" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">在JWT代币中存储什么？</h1><p id="5bf3" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">在我们的场景中，JWT代表一个身份令牌，它应该持有关于主体(用户)的声明。这意味着令牌包含用户标识符，比如:<code class="fe nk nl nm na b">{ "sub": "awWF#$512" }</code>。</p><p id="d694" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据您的应用程序，令牌还可以包含能力声明，例如，表明主题可以访问您系统的某些服务。</p><p id="f9b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您当然可以在cookie中存储其他信息，包括用户的电子邮件等等。但是，考虑一下您的服务真正需要什么样的用户信息，以及您在令牌中存储了什么，假设这些信息没有加密。用户标识符(主题权利要求)通常就足够了。</p><p id="945a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用JWT作为身份令牌，那么最重要的声明就是主题，因为您可以使用它来标识服务中的用户。</p><p id="8a59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用JWT作为访问令牌，那么您使用了一个声明，即该令牌的持有者被授权使用系统的某个部分。您可以使用受众声明来实现这一点，受众声明可以是单个uri或字符串记录，也可以是它们的数组。消费该令牌的服务然后可以验证它是在JWT中收听的观众之一。</p><p id="786f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JWT RFC 7519还建议在有效载荷中存储许多其他信息。这些可选索赔包括:</p><ul class=""><li id="abfb" class="nn no it la b lb lc le lf lh np ll nq lp nr lt ns nt nu nv bi translated"><strong class="la iu"> iss </strong>:发卡行字符串或URI，<br/>例如:<code class="fe nk nl nm na b">"iss": "https://didauth.meet-martin.com"</code></li><li id="914a" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><strong class="la iu"> sub </strong>:主题标识符字符串或URI，<br/>例如:<code class="fe nk nl nm na b">"sub": "OCfs425k"</code></li><li id="ee7f" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><strong class="la iu"> aud </strong>:观众字符串或者URI，或者这些的数组，<br/>例如:<code class="fe nk nl nm na b">"aud": "https://api.meet-martin.com"</code></li><li id="c84d" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><strong class="la iu"> exp </strong>，到期时间，超过该时间后令牌按NumericDate无效，<br/>例如:<code class="fe nk nl nm na b">"exp": "1630983721"</code></li><li id="2037" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><strong class="la iu"> nbf </strong>，not before标识在此之前令牌不能被接受的数字日期，<br/>例如:<code class="fe nk nl nm na b">"nbf": "1630983612"</code></li><li id="da9b" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><strong class="la iu"> iat </strong>，issue at包含令牌发布时的NumbericDate，<br/>例如:<code class="fe nk nl nm na b">"iat": "163983612"</code></li><li id="22c7" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><strong class="la iu"> jti </strong>，JWT，持有JWT的唯一标识符作为区分大小写的字符串，<br/>例如:<code class="fe nk nl nm na b">"jti": "fsg1R34"</code></li></ul><p id="8222" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，除非您自己提供额外的加密，否则这些声明都不会加密。如果你需要传输敏感数据，看看JWE标准。</p><p id="662c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Base 64解码的令牌如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ede0" class="ne ma it na b gy nf ng l nh ni">{"alg":"ES512","typ":"JWT"}{"iss":"<a class="ae lu" href="https://domain.tld" rel="noopener ugc nofollow" target="_blank">https://domain.tld</a>","sub":"martin@mail.tld","aud":"<a class="ae lu" href="https://domain.tld" rel="noopener ugc nofollow" target="_blank">https://domain.tld</a>","exp":1630986887,"nbf":1630983287,"jti":"asfasgsadg","iat":1630983287}☺ɱ��%�§�∟x��8�k��c~¶.�S��K�`ѱ���♣��►C∟�8����ϖ↔C�x�����&lt;����c♫♥���q/W�<br/>� �♂t�↑V�0�☼�4��<br/>�hG��Z��‼u�     �oU▬Q[L�hʒ‼�(♀�H</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h1 id="ead3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">在浏览器中哪里存储JWT令牌？</h1><p id="d774" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">你有三个选择。你要么使用cookies，web存储，要么在内存中。最常用的选项似乎是本地存储。</p><h2 id="df10" class="ne ma it bd mb ob oc dn mf od oe dp mj lh of og ml ll oh oi mn lp oj ok mp ol bi translated">饼干里的JWT</h2><p id="6a2d" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">Cookies的优点是它们会自动与每个请求一起发送，因此您不需要处理授权头。</p><p id="dd5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Cookies仍然容易受到跨站点请求伪造(CSRF)攻击，因此您还应该实现CSRF令牌。CSRF令牌是作为cookie随每个请求一起发送的随机字符串，并且它对于每个请求是不同的。</p><p id="c2a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还应该使用<code class="fe nk nl nm na b">httpOnly</code>标志使cookie只在服务器端可用。JavaScript <code class="fe nk nl nm na b">document.cookie</code> API无法访问具有<code class="fe nk nl nm na b">HttpOnly</code>属性的cookie它只发送到服务器。</p><p id="94e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">带有<code class="fe nk nl nm na b">Secure</code>属性的cookie仅通过HTTPS协议与加密请求一起发送到服务器(但是，仅在本地主机上，您仍然可以使用HTTP)。</p><p id="171a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是Nodej.js中Express的一个示例实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><p id="e304" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Express中，您可以使用<a class="ae lu" href="https://www.npmjs.com/package/csurf" rel="noopener ugc nofollow" target="_blank"> csurf中间件</a>，它会为您处理CSRF令牌。<a class="ae lu" href="https://www.npmjs.com/package/express-session" rel="noopener ugc nofollow" target="_blank"> express-session </a>使用默认为<code class="fe nk nl nm na b">httpOnly</code>的cookies，但是您需要通过一个参数使它们成为<code class="fe nk nl nm na b">secure</code>，正如您在代码中看到的。</p><h2 id="f7e5" class="ne ma it bd mb ob oc dn mf od oe dp mj lh of og ml ll oh oi mn lp oj ok mp ol bi translated">web存储中的JWT:本地存储与会话存储</h2><p id="2abc" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">这两者的区别在于本地存储更加持久。当用户关闭网站窗口时，会话存储被清除。必须显式删除本地存储数据。</p><p id="7f0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与cookies不同，本地存储被沙盒化到特定的域中，其数据不能被任何其他域(包括子域)访问。但是请记住，你仍然容易受到跨站脚本(XSS)。cookie和web存储解决方案都容易受到XSS的攻击。</p><p id="e7af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本地存储在JWT实施中使用最多。然而，会话存储在这里是更安全的选择。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><p id="5c4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用localStorage时，JWT不会随每个请求自动传递，您需要自己通过授权头将其传递给服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><h2 id="3ba5" class="ne ma it bd mb ob oc dn mf od oe dp mj lh of og ml ll oh oi mn lp oj ok mp ol bi translated">记忆中的JWT</h2><p id="53dd" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">这里最安全的解决方案是将JWT存储在单页应用程序的内存中。这意味着您最终将令牌存储在JavaScript的一个变量中，而没有额外的持久性。</p><p id="cbf1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这有一些限制。您不能实现单点登录(SSO ),浏览器中的每个选项卡或打开的窗口都需要自己的登录，因为JavaScript内存不是共享的。但是，共享问题可以通过使用刷新令牌来解决。</p><p id="a903" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，像所有其他解决方案一样，这种解决方案仍然容易受到跨站点脚本的攻击。</p><p id="fb0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您需要使用授权头为每个请求传递JWT，就像前面代码示例中的web存储一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h1 id="e3c4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">刷新令牌</h1><p id="fe3a" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">您的应用程序设计应该包括刷新令牌的提供。</p><p id="f9f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JWT代表一个短暂的访问令牌。这里的“短寿命”通常是指5分钟到24小时或几天，具体取决于您的应用。</p><p id="fbd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">刷新令牌是长期存在的，并且代表了一种用于静默认证的机制，以在没有任何用户动作的情况下获得新的访问令牌。长期存在的时间长短取决于用户的便利性，或者您希望用户在两次使用您的服务之间保持身份验证的时间长短。例如，如果您希望您的用户在两周未使用网站后访问您的网站，并且仍然发现他们已经过身份验证，那么两周就是您的刷新令牌到期日期。</p><p id="4a21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您的刷新令牌续订策略还取决于您的到期日期。</p><p id="f216" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，您可以设计您的系统来提供一个24小时过期时间的访问令牌。您还需要提供一个有2周过期时间的刷新令牌。但是，每次更新访问令牌时，您还需要提供一个新的刷新令牌。</p><p id="9fb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可能还希望在令牌中存储它的创建时间(<code class="fe nk nl nm na b">iat</code>)，以便可以使用该信息在所有旧令牌的原始到期时间之前集中使其失效。</p><p id="cf5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">刷新令牌通常只保存一个不透明的标识符，它或者存储为一个<code class="fe nk nl nm na b">httpOnly</code>、<code class="fe nk nl nm na b">secure</code> cookie，或者存储在web存储器中(如果您按照前面的建议将访问令牌存储在内存中，这两种方式都可以使您的网站在多个打开的标签中工作)。</p><h1 id="1e78" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">如何使用JWT访问令牌注销用户？</h1><p id="3815" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">用户可以在多个设备上登录，这意味着一个用户将拥有多个访问令牌和刷新令牌。这些东西中的任何一个都可能被一个邪恶的黑客所拥有。</p><p id="c83f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该在数据库中单独存储注销操作，并使用它来使所有刷新令牌失效。</p><p id="9275" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，我们依靠JWT到期，但JWT和刷新令牌可能会因其<code class="fe nk nl nm na b">id</code> ( <code class="fe nk nl nm na b">jti</code>)而失效。</p><p id="6398" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个简单的解决方案是在您的数据库中存储注销时间，并将该日期(<code class="fe nk nl nm na b">iat</code>)之前创建的所有JWT和刷新令牌视为无效。</p><p id="d1b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您的浏览器应用程序端，您应该简单地将JWT从其存储器(web存储器或内存)中移除。</p><h1 id="ed15" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">您应该使用什么加密？</h1><p id="2da2" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">JWT加密最常用的算法是HMAC和RSA。还支持其他算法，包括RSASSA-PKCS算法、RSASSA-PSS算法和ECDSA算法。默认的是HMAC，最流行的是RSA，最安全的是ECDSA。</p><h2 id="ce8f" class="ne ma it bd mb ob oc dn mf od oe dp mj lh of og ml ll oh oi mn lp oj ok mp ol bi translated">HMAC</h2><p id="569e" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">最简单和最不安全的选择是HS256，这是HMAC与SHA-256。这是一种对称算法，这意味着一个秘密用于签名和验证令牌。一个秘密的例子是:<code class="fe nk nl nm na b">Much$3cr3tS0S3cureVerySafe</code>。</p><p id="ed9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，身份验证服务以及所有需要授权的服务都需要访问同一个密钥，这就为通过API漏洞窃取密钥提供了更多的机会。</p><p id="4e36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常不建议在生产中使用。尽管如此，演示应用程序或代码示例更容易。</p><h2 id="9e5a" class="ne ma it bd mb ob oc dn mf od oe dp mj lh of og ml ll oh oi mn lp oj ok mp ol bi translated">南非共和国(Republic of South Africa)</h2><p id="dbe7" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">对于JWT，您的另一个选择是使用RS 256(SHA-256 RSA ),这是一种使用私钥和公钥的不对称加密算法。它也可能是web应用程序最常用的算法，因为许多开发人员都熟悉它，尽管它不是最安全或性能最好的选项。</p><p id="b0be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">身份验证服务使用私钥来生成原始令牌。然后，其他服务使用公钥来验证令牌。如果公钥被泄露，它可以用于读取数据，但不能用于创建其他令牌。建议在HMAC上使用RSA。</p><p id="772b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">公钥也可以对其他第三方消费者公开，这样任何人都可以使用它来访问令牌中的数据，并验证这些数据确实来自您，因为它们是由您的私钥签名的。</p><p id="bba2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过<code class="fe nk nl nm na b">openssl</code>生成您的RSA公钥和私钥:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><h2 id="c46e" class="ne ma it bd mb ob oc dn mf od oe dp mj lh of og ml ll oh oi mn lp oj ok mp ol bi translated">ECDSA</h2><p id="8bb9" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">使用<code class="fe nk nl nm na b">jsonwebtoken</code>节点库时，你的最佳选择是ES512，这是一种使用P-521曲线和SHA-512哈希算法的椭圆曲线数字签名算法(<a class="ae lu" href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" rel="noopener ugc nofollow" target="_blank"> ECDSA </a>)。ECDSA也被比特币使用。ECDSA是另一种类似RSA的非对称加密，被认为是更安全的选择。</p><blockquote class="om on oo"><p id="610b" class="ky kz nj la b lb lc ju ld le lf jx lg op li lj lk oq lm ln lo or lq lr ls lt im bi translated">椭圆曲线加密(ECC)比RSA更难破解(或者也许我们真的很擅长破解RSA)。因此，ECDSA可以使用比RSA短得多的密钥和短得多的签名。大约256位的短椭圆曲线(EC)密钥提供了与3072位RSA密钥相同的安全性。<br/>-<a class="ae lu" href="https://www.scottbrady91.com/JOSE/JWTs-Which-Signing-Algorithm-Should-I-Use" rel="noopener ugc nofollow" target="_blank">https://www . Scott Brady 91 . com/JOSE/JWTs-Which-Signing-Algorithm-Should-I-Use</a></p></blockquote><p id="a87f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的方法与RSA相同。作为身份验证的一部分，使用您的私钥对令牌进行签名，并在您的服务中使用公钥。</p><p id="6b3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过<code class="fe nk nl nm na b">openssl</code>生成您的ECDSA ES512公钥和私钥:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><p id="a4b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">美国商务部国家标准与技术研究所(NIST)已将ECDSA纳入FIPS 186–4数字签名标准(DSS):<a class="ae lu" href="https://csrc.nist.gov/publications/detail/fips/186/4/final" rel="noopener ugc nofollow" target="_blank">https://csrc.nist.gov/publications/detail/fips/186/4/final</a></p><h2 id="7b64" class="ne ma it bd mb ob oc dn mf od oe dp mj lh of og ml ll oh oi mn lp oj ok mp ol bi translated">埃德萨</h2><p id="83c1" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">如果您使用<code class="fe nk nl nm na b">jose</code>节点库，您还将获得Edwards-curve数字签名算法(<a class="ae lu" href="https://en.wikipedia.org/wiki/EdDSA" rel="noopener ugc nofollow" target="_blank"> EdDSA </a>)加密算法，这是JWT实现的<a class="ae lu" href="https://crypto.stackexchange.com/questions/60383/what-is-the-difference-between-ecdsa-and-eddsa" rel="noopener ugc nofollow" target="_blank">最终最佳选择。它使用SHA-512和曲线25519给出了Ed25519方法。</a></p><p id="183e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所猜测的，EdDSA是一种使用公钥和私钥的非对称算法，因此其用途与RSA或ECDSA相同。EdDSA比ECDSA具有更好的性能和更短的密钥，同时提供更好的安全性。</p><p id="4c24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过<code class="fe nk nl nm na b">openssl</code>生成您的EdDSA ed25519公钥和私钥:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ly l"/></div></figure><p id="8232" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">美国商务部国家标准与技术研究院(NIST)已将EdDSA纳入FIPS 186–5数字签名标准(DSS)草案:<a class="ae lu" href="https://csrc.nist.gov/publications/detail/fips/186/5/draft" rel="noopener ugc nofollow" target="_blank">https://csrc.nist.gov/publications/detail/fips/186/5/draft</a></p><p id="abaf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">FIPS 186–5自2019年10月以来一直处于草案状态，但尚未成为2021年11月发布的标准。</p><p id="1fd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果美国NIST不是您所关心的，那么EdDSA是您目前可以用于JWT签名的最安全和性能最好的选项。</p><h2 id="4d9c" class="ne ma it bd mb ob oc dn mf od oe dp mj lh of og ml ll oh oi mn lp oj ok mp ol bi translated">签名加密结论</h2><p id="9cb4" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">在您的应用程序中，尝试使用EdDSA。如果不可能，那么使用ES512。使用像HMAC这样的对称算法应该是你最后的选择。</p><p id="a042" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了比较密钥长度，运行示例<code class="fe nk nl nm na b">openssl</code>代码，RSA私钥是1674个字符，es512是308个字符，而ed25519只有64个字符。</p><p id="49f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在身份验证服务中使用私钥，在其他服务中使用公钥。为了增加安全性，还可以考虑密钥轮换。一段时间后生成新的密钥。</p><p id="2f8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要将加密密钥直接保存在代码中，或者保存在像git这样的代码版本控制系统中。您应该使用密钥管理系统或环境变量。</p><h1 id="c229" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">摘要:十大JWT建议</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/3394e827c818635e53de7e8fcd67d94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYquDbJcInrxaAGnEqZDzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><ul class=""><li id="bcac" class="nn no it la b lb lc le lf lh np ll nq lp nr lt ns nt nu nv bi translated">在JWT之前，您还需要考虑使您的身份验证过程安全。对您的用户或分散标识符使用双因素身份验证。只有用户名和密码不被认为是安全的解决方案。</li><li id="24f4" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">如果你正在建立一个标准的前端/后端网站，使用标准的会话管理。如果您正在构建带有服务的分布式系统，请实现JWT授权。</li><li id="6cf6" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">通过使用非对称加密算法的私钥签署JWT来创建访问令牌。对<code class="fe nk nl nm na b">jsonwebtoken</code> NPM图书馆使用ES512，对<code class="fe nk nl nm na b">jose</code> NPM图书馆使用Ed25519。</li><li id="6aea" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">使用<code class="fe nk nl nm na b">sub</code>主题声明存储用户ID，但除非必要，否则不要保存其他用户数据，因为存储在JWT中的所有内容都可以直接读取。数据没有加密。</li><li id="f707" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">创建具有长期过期日期的刷新令牌。</li><li id="a04a" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">在前端，将访问令牌存储在客户端JavaScript应用程序的内存中，并将刷新令牌存储在web商店中。</li><li id="14ad" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">将JWT访问令牌作为HTTP标头中的载体与每个需要授权的服务器请求一起发送。</li><li id="da94" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">使用公钥(对您的服务公开)验证服务器上的JWT。根据存储在JWT主题中的用户ID从数据库中加载用户数据。</li><li id="187d" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">当访问令牌过期时，使用刷新令牌再次对用户进行静默身份验证。</li><li id="f5fc" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">通过使用刷新令牌提供新的访问令牌和新的刷新令牌来执行静默认证。</li><li id="b10f" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">通过使连接到用户ID的所有访问令牌和请求令牌无效，将用户从所有设备注销。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h1 id="649f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="eaed" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">当您实现JWT逻辑时，您的解决方案决策应该考虑最佳实践、安全性以及用户便利性。</p><p id="37f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望我已经包含了你可能需要的所有必要信息。</p></div></div>    
</body>
</html>