<html>
<head>
<title>Two-Pan Layout for Larger Devices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适用于大型设备的双盘布局</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/two-pan-layout-for-larger-devices-d84cd5c5340e?source=collection_archive---------9-----------------------#2022-09-01">https://betterprogramming.pub/two-pan-layout-for-larger-devices-d84cd5c5340e?source=collection_archive---------9-----------------------#2022-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a705" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为定制尺寸创建的更简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/85ed57c654ecd0b68619521cac55d873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z-8uBHwQpNHEDWbZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@andriklangfield?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">和</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="df15" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="02c8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在当今时代，构建一个响应屏幕尺寸和美观的移动应用程序至关重要。移动设备和平板电脑的相同设计将不再适用。像Google-Nest，Byjus学习设备等新设备。，正在推出不同屏幕尺寸的定制Android版本。我们比以往任何时候都更需要开发能够适应不同屏幕尺寸的应用。</p><p id="95c9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">说到移动设备，大多数时候单个平面布局就足以获得更好的UX体验。但是对于大型设备，我们必须利用屏幕空间来获得更好的用户界面和UX体验。你会发现Android上的Gmail应用程序也有类似的方法。在移动和平板设备上尝试一下。</p><p id="3461" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，考虑移动设备上的聊天应用程序。如果我们在第一个屏幕上显示以前的聊天列表，在另一个屏幕上显示实际的聊天，效果会更好。但当涉及到更大的设备时，如果我们将它们并排显示，这将使用户体验更上一层楼，这就是所谓的双面板布局设计。先前的聊天列表将位于左侧面板，聊天详细信息将位于右侧面板。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/ce6f106e626929de99a76a41fffdb283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55dH5bA0c1GsdM6BdTnbWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">双锅布局设计。来源:Android开发者网站</p></figure><h1 id="bd64" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">技术方面</h1><p id="3cd5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">理论上，双锅布局增加了用户体验的价值，但当涉及到技术部分时，这是一个棘手的事情。我们不应该违反关注点分离的原则——这意味着我们必须根据逻辑和UI分别维护列表和细节屏幕。尽管如此，他们应该能够在一个屏幕上工作。</p><p id="c371" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下一个复杂性是在同一布局中使用两个片段。为此，我们必须使用<code class="fe mt mu mv mw b">SlidingPaneLayout</code>。<code class="fe mt mu mv mw b">SlidingPaneLayout</code>将是列表片段的根。<code class="fe mt mu mv mw b">SlidingPaneLayout</code>下面应该有两个孩子:</p><ol class=""><li id="d499" class="mx my it lt b lu mn lx mo ma mz me na mi nb mm nc nd ne nf bi translated">第一个孩子将充当左平移视图。在我们的例子中，它是一个显示项目列表的<code class="fe mt mu mv mw b">recyclerview</code>。</li><li id="413d" class="mx my it lt b lu ng lx nh ma ni me nj mi nk mm nc nd ne nf bi translated">第二个孩子将充当右平移视图。在我们的例子中，它是一个细节片段。</li></ol><p id="af08" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe mt mu mv mw b">SlidingPaneLayout</code>的优点是它使用两个窗格的宽度来决定是并排显示窗格还是重叠显示。假设，如果左、右全景的最小尺寸分别为<code class="fe mt mu mv mw b">250dp</code>和<code class="fe mt mu mv mw b">400dp</code>，那么只有当总屏幕尺寸等于或大于<code class="fe mt mu mv mw b">650dp</code>时，并排视图才会出现。</p><p id="4b3d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">理论说够了。让我们开始吧。</p><h1 id="f661" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><code class="fe mt mu mv mw b">SlidingPaneLayout</code>配置</h1><p id="c664" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们从父片段XML配置开始，它包含一个带有两个子片段的<code class="fe mt mu mv mw b">SlidingPaneLayout</code>根布局:</p><ol class=""><li id="f3d3" class="mx my it lt b lu mn lx mo ma mz me na mi nb mm nc nd ne nf bi translated"><code class="fe mt mu mv mw b">Recyclerview</code>代表物品清单。</li><li id="f66a" class="mx my it lt b lu ng lx nh ma ni me nj mi nk mm nc nd ne nf bi translated"><code class="fe mt mu mv mw b">FragmentContainerView</code>放大你选择的细节片段或导航图。</li></ol><p id="6a8f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="46f6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以在根或列表片段中扩展这个XML，您可以从数据源获取列表并通过<code class="fe mt mu mv mw b">recyclerview</code>发布它。</p><h1 id="53d8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">右平移功能</h1><p id="2c90" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦通过<code class="fe mt mu mv mw b">recyclerview</code>发布了列表数据，下一个工作就是每当用户点击任何列表项时，只更新右边的pan细节<code class="fe mt mu mv mw b">contrainerview</code>。</p><p id="7715" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当涉及到正确的pan时，有两种场景，要么开发人员可以膨胀单个片段，要么他们可以膨胀复杂实时用例的导航图。首先，让我们从一个简单的用例开始，膨胀一个单独的片段，每当用户点击列表项时更新它。</p><h2 id="b326" class="nn la it bd lb no np dn lf nq nr dp lj ma ns nt ll me nu nv ln mi nw nx lp ny bi translated">单一片段用例</h2><p id="8d85" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们首先创建一个名为<code class="fe mt mu mv mw b">openDetails</code>的函数，它只接受一个参数，即被单击项的数据类。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9b0e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这里，我们维护片段事务，而不使用任何导航组件，这很好，因为我们正在处理一个更简单的用例。请记住，我们使用<code class="fe mt mu mv mw b">replace</code>片段事务，而不使用任何<code class="fe mt mu mv mw b"><a class="ae ky" href="https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#addToBackStack(java.lang.String)" rel="noopener ugc nofollow" target="_blank">addToBackStack()</a></code>功能来避免有意构建<code class="fe mt mu mv mw b">backstack</code>。</p><h2 id="73d1" class="nn la it bd lb no np dn lf nq nr dp lj ma ns nt ll me nu nv ln mi nw nx lp ny bi translated">导航图用例</h2><p id="4f66" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有些情况下，开发人员想要集成一个流，这意味着一组片段，而不是单个片段。在这种情况下，我们可以创建一个导航图，并将其附加到details容器视图。所有的导航都可以发生在图形中。</p><p id="3d0b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">XML更改:</p><pre class="kj kk kl km gt nz mw oa ob aw oc bi"><span id="eb86" class="nn la it mw b gy od oe l of og">&lt;androidx.fragment.app.FragmentContainerView<br/>        android:id="@+id/two_pane_container"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        &lt;!-- The navigation graph for your detail pane.--&gt;<br/>        app:navGraph="@navigation/details_nav_graph" /&gt;</span></pre><p id="3fca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，每当用户点击列表项时，我们通过<code class="fe mt mu mv mw b">setPopUpTo</code>弹出图中所有嵌套的导航，并导航回起始目的地。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="a395" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用<code class="fe mt mu mv mw b">SlidingPaneLayout</code>配置系统返回点击</h1><p id="4ef5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当涉及到移动设备时，<code class="fe mt mu mv mw b">SlidingPaneLayout</code>将列表与细节片段重叠，因为屏幕尺寸将小于所需的最小宽度。在这种情况下，当用户单击系统back按钮时，期望是关闭details面板并移回列表。</p><p id="d41e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">处理向后导航是开发人员的责任。我们可以通过将<code class="fe mt mu mv mw b"><a class="ae ky" href="https://developer.android.com/reference/androidx/activity/OnBackPressedCallback" rel="noopener ugc nofollow" target="_blank">OnBackPressedCallback</a></code>与面板的当前状态联系起来来做到这一点。让我们从创建一个客户<code class="fe mt mu mv mw b"><a class="ae ky" href="https://developer.android.com/reference/androidx/activity/OnBackPressedCallback" rel="noopener ugc nofollow" target="_blank">OnBackPressedCallback</a></code>开始。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2796" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们需要使用<code class="fe mt mu mv mw b"><a class="ae ky" href="https://developer.android.com/reference/androidx/activity/OnBackPressedDispatcher#addCallback(androidx.lifecycle.LifecycleOwner,%20androidx.activity.OnBackPressedCallback)" rel="noopener ugc nofollow" target="_blank">addCallback()</a></code>将我们的自定义回压回调添加到<code class="fe mt mu mv mw b"><a class="ae ky" href="https://developer.android.com/reference/androidx/activity/OnBackPressedDispatcher" rel="noopener ugc nofollow" target="_blank">OnBackPressedDispatcher</a></code>中。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7a43" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还有一件事，我们需要注意的是移动设备上的滑动平移是锁定滑动行为，因为这是一个不同的移动UX屏幕。这完全基于您的用例。</p><pre class="kj kk kl km gt nz mw oa ob aw oc bi"><span id="678a" class="nn la it mw b gy od oe l of og">binding.slidingPaneLayout.lockMode = SlidingPaneLayout.LOCK_MODE_LOCKED</span></pre><h1 id="8a34" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">奖金</h1><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/8-common-mistakes-in-android-development-2edcf5179ec0"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">Android开发中的8个常见错误</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">构建优秀应用程序的陷阱</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">better编程. pub</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><p id="1ab1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读！</p></div></div>    
</body>
</html>