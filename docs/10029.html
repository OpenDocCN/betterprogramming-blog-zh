<html>
<head>
<title>How to Create Modern Command-Line Applications in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用C#创建现代命令行应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-modern-command-line-applications-in-c-c7bf02c3c64f?source=collection_archive---------4-----------------------#2021-11-16">https://betterprogramming.pub/how-to-create-modern-command-line-applications-in-c-c7bf02c3c64f?source=collection_archive---------4-----------------------#2021-11-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6036" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">命令行应用不一定很无聊！</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8fb9a4383bc45203c7a32e587ad721ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fr-Vu77Sk8UtH47h"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@danlefeb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹·列斐伏尔</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="0e7f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">命令行应用程序是有史以来最原始的应用程序。在一个时髦的、高度优化的web应用程序提供了出色的用户体验的世界里，CLI应用程序是初级的，容易出错，有时使用起来简直令人恼火。</p><p id="15b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你要么爱他们，要么恨他们。实际上没有任何中间立场。不管您的个人倾向如何，命令行应用程序在当今世界仍然非常普遍。无论您是使用<code class="fe lw lx ly lz b">kubectl</code>管理Kubernetes集群还是构建. NET应用程序，底层基础设施都是由命令行应用程序提供的。</p><p id="8425" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它们填补了一个重要的空白，因为它们不需要图形界面，因此非常适合在CI/CD管道中运行，甚至可以跨多个操作系统运行。尤其是在编写与交付管道紧密集成的代码时，编写自己的控制台应用程序可能非常有效。</p><p id="1beb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，你可以通过<code class="fe lw lx ly lz b">Console.Read</code>自己的方式获得胜利，应用一些基本的字符串拆分，然后<em class="ma">瞧</em>你就成功了！这是做这件事的一种方法。另一个是微软即将发布的<code class="fe lw lx ly lz b">System.CommandLine</code>库，它是驱动<code class="fe lw lx ly lz b">dotnet</code> CLI的库。</p><p id="da00" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将使用这个全新的库来创建可维护和可扩展的命令行应用程序。</p><h1 id="a3ec" class="mb mc iu bd md me mf mg mh mi mj mk ml ka mm kb mn kd mo ke mp kg mq kh mr ms bi translated">入门指南</h1><p id="53de" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">让我们编写一个简单的CLI应用程序，在构建管道的末尾，向跟踪我们的构建和发布的中央API发送一个web请求。这不是跟踪发行版的理想方式，但目前来说还可以。</p><p id="59d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从Visual Studio或命令行创建新的控制台应用程序:</p><pre class="kk kl km kn gu my lz mz na aw nb bi"><span id="158a" class="nc mc iu lz b gz nd ne l nf ng">&gt; mkdir BuildTracker &amp;&amp; cd BuildTracker<br/>&gt; dotnet new console</span></pre><p id="f089" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们将安装所需的软件包:</p><pre class="kk kl km kn gu my lz mz na aw nb bi"><span id="c637" class="nc mc iu lz b gz nd ne l nf ng">&gt; dotnet add package System.CommandLine --prerelease<br/>&gt; dotnet add package System.CommandLine.DragonFruit --prerelease</span></pre><p id="33ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">就这些了。让我们开始编写我们的第一个命令。</p><h1 id="1a00" class="mb mc iu bd md me mf mg mh mi mj mk ml ka mm kb mn kd mo ke mp kg mq kh mr ms bi translated">传递选项</h1><p id="b13a" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">我们的应用程序只是将一个版本发布到一个通过命令行参数传递的HTTP端点。在这个用例中没有太多的变化，也就是说，我们将向其发送消息的端点以及我们正在构建的应用程序的版本都可以作为一个选项发送到一个命令。</p><p id="a5a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这允许我们保持我们的程序相对简单。您可能已经注意到，我们已经在前面的部分安装了一个名为<code class="fe lw lx ly lz b">System.CommandLine.DragonFruit</code>的包。诚然，这是一个有点特殊和难以描述的名字，它允许我们极大地简化我们的控制台应用程序。</p><p id="e6de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">DragonFruit使我们能够直接从我们的<code class="fe lw lx ly lz b">Main</code>方法的参数中解释参数。它还可以将命令行参数直接映射到参数名，同时遵守命名约定。例如</p><pre class="kk kl km kn gu my lz mz na aw nb bi"><span id="a838" class="nc mc iu lz b gz nd ne l nf ng">&gt; foo.exe --do-something</span></pre><p id="ba82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe lw lx ly lz b">Main</code>的参数列表中被翻译成<code class="fe lw lx ly lz b">doSomething</code>——这允许我们定义最基本的控制台应用程序，接受如下两个命令行参数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div></figure><p id="6d44" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">DragonFruit为我们处理命令行参数到我们的<code class="fe lw lx ly lz b">Main</code>方法参数的映射。</p><p id="5a82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了进行试验，在Visual Studio中进入项目的属性，并选择<em class="ma"> Debug </em>选项卡。在<em class="ma">应用程序参数</em>部分，粘贴以下内容:</p><pre class="kk kl km kn gu my lz mz na aw nb bi"><span id="cd7b" class="nc mc iu lz b gz nd ne l nf ng">--endpoint "<a class="ae kz" href="https://somewhere.com" rel="noopener ugc nofollow" target="_blank">https://somewhere.com</a>" --build-version "1.0.0"</span></pre><p id="1601" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您没有使用Visual Studio，请在项目的<code class="fe lw lx ly lz b">Properties</code>文件夹中创建一个包含以下内容的<code class="fe lw lx ly lz b">launchSettings.json</code>文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div></figure><p id="8087" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请确保将占位符替换为项目的实际名称。之后，简单地调试程序就会将这些命令行参数传递给应用程序。如果一切顺利，您应该在调试应用程序时观察到以下输出:</p><pre class="kk kl km kn gu my lz mz na aw nb bi"><span id="d5d3" class="nc mc iu lz b gz nd ne l nf ng">Endpoint: <a class="ae kz" href="https://somewhere.com" rel="noopener ugc nofollow" target="_blank">https://somewhere.com</a><br/>Build Version: 1.0.0</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nj"><img src="../Images/c2c20c237ee57883e7d4d5c7ada7ba76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9omi_rK2IRbJN126"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">克拉克·范·德·贝肯在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="b432" class="mb mc iu bd md me mf mg mh mi mj mk ml ka mm kb mn kd mo ke mp kg mq kh mr ms bi translated">添加命令</h1><p id="1e7d" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">虽然DragonFruit应用程序模型提供了一种非常有效的入门方式，但是您可能会遇到这样的情况:您希望对传递给命令的选项进行更多的控制，或者甚至希望嵌套命令。</p><p id="64f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">幸运的是，<code class="fe lw lx ly lz b">System.CommandLine</code>附带了一个易于使用的、非常广泛的命令解析器。假设我们想要使用<code class="fe lw lx ly lz b">Command</code>语法来表达上一节中的简单控制台应用程序。</p><p id="cced" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是我们如何使用命令语法定义上一节中的应用程序:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div></figure><p id="840e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与之前的DragonFruit应用程序相比，这里发生了更多的事情。让我们仔细看看。</p><p id="8402" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们从定义一个<code class="fe lw lx ly lz b">RootCommand</code>开始，它构成了命令树的根节点。我们现在不接受命令行参数作为参数，而是通过与命令相关联的<code class="fe lw lx ly lz b">Option&lt;T&gt;</code>实例显式定义它们。</p><p id="1b22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为仅仅声明根命令对我们没有任何好处，所以我们附加了一个处理程序，它知道如何在命令被调用时处理它。请注意，委托接受两个命名参数。按照命令中声明的那样命名选项名称非常重要。如果这些名称不匹配，处理程序将无法正确绑定。</p><p id="8a6c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们在root命令上调用<code class="fe lw lx ly lz b">InvokeAsync</code>,并从命令行传递参数给它。然后，类似于我们之前的应用程序，输出我们调用应用程序时使用的参数。</p><p id="76e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，与DragonFruit应用程序模型相比，这要多得多的代码，也复杂得多。如果你正在编写一个只有一个命令的应用程序，我强烈建议你使用DragonFruit应用程序模型。如果您的应用程序支持多个命令，那么使用命令语法会更加有效。</p><h1 id="1a4d" class="mb mc iu bd md me mf mg mh mi mj mk ml ka mm kb mn kd mo ke mp kg mq kh mr ms bi translated">子命令</h1><p id="3e6a" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">既然我们已经简要介绍了根命令，我们应该看看子命令(通常称为<em class="ma">动词</em>)。从技术上讲，一个命令可以有任意数量的“子”命令。这允许您编写将命令“链接”在一起的命令行，就像<code class="fe lw lx ly lz b">dotnet sdk check</code>将<code class="fe lw lx ly lz b">sdk</code>和<code class="fe lw lx ly lz b">check</code>命令链接在一起。</p><p id="daa4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这与上一节中概述的命令结构非常相似。然而，我们没有将选项传递给根命令，而是为各个命令定义了选项。我们还在命令级别声明处理程序:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div></figure><p id="d32e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据应用程序是通过<code class="fe lw lx ly lz b">build --build-version &lt;v&gt; --endpoint &lt;e&gt;</code>还是<code class="fe lw lx ly lz b">release [...]</code>调用，输出会有所不同。当然，在现实世界中，您可能不会有两个如此相似的独立命令，但是您应该明白这一点。</p><p id="33b0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了这个API，可能性几乎是无限的。您可以嵌套命令，为每一个命令设置单独的处理程序，您甚至可以实现<a class="ae kz" href="https://github.com/dotnet/command-line-api/blob/main/docs/How-To.md#Middleware-Pipeline" rel="noopener ugc nofollow" target="_blank">路由和命令管道</a>来精细地控制应用程序的输入和输出流。</p><h1 id="94c6" class="mb mc iu bd md me mf mg mh mi mj mk ml ka mm kb mn kd mo ke mp kg mq kh mr ms bi translated">结论</h1><p id="4eae" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">微软在<code class="fe lw lx ly lz b">System.CommandLine</code>发布了一个非常强大的命令行界面库。正是这个库为<code class="fe lw lx ly lz b">dotnet</code>命令行界面提供了动力，而<a class="ae kz" href="https://github.com/dotnet/sdk/tree/main/src/Cli/dotnet" rel="noopener ugc nofollow" target="_blank">他们已经在它的基础上构建了相当广泛的CLI </a>。</p><p id="e1a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这篇文章仅仅是对<code class="fe lw lx ly lz b">System.CommandLine</code>的介绍——看看<a class="ae kz" href="https://github.com/dotnet/command-line-api" rel="noopener ugc nofollow" target="_blank">、官方知识库</a>以及其中可用的<a class="ae kz" href="https://github.com/dotnet/command-line-api/tree/main/samples" rel="noopener ugc nofollow" target="_blank">样本</a>和<a class="ae kz" href="https://github.com/dotnet/command-line-api/tree/main/docs" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="125c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望这篇文章能让您开始使用CLI应用程序，或者至少激起您的兴趣。如果有，请告诉我！</p></div></div>    
</body>
</html>