<html>
<head>
<title>Dynamic Programming Interview Questions (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划面试问题(三)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-programming-interview-questions-part-3-f7d15f37cecb?source=collection_archive---------8-----------------------#2020-06-25">https://betterprogramming.pub/dynamic-programming-interview-questions-part-3-f7d15f37cecb?source=collection_archive---------8-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6008" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">求最大连续子阵列和</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c496d8de87fe162cb9a49024a414cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qZiMJSwYU9MzV9L2s3YyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="15e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们在动态编程系列中的第二个问题(由<a class="ae lu" href="https://leetcode.com/problems/maximum-subarray/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>提供)！正如我所承诺的，这个将比上一个简单得多。</p><blockquote class="lv lw lx"><p id="0485" class="ky kz ly la b lb lc ju ld le lf jx lg lz li lj lk ma lm ln lo mb lq lr ls lt im bi translated">"给定一个整数数组<code class="fe mc md me mf b">nums</code>，找出具有最大和的连续子数组(至少包含一个数),并返回其和。</p><p id="8839" class="ky kz ly la b lb lc ju ld le lf jx lg lz li lj lk ma lm ln lo mb lq lr ls lt im bi translated">示例:</p><p id="897c" class="ky kz ly la b lb lc ju ld le lf jx lg lz li lj lk ma lm ln lo mb lq lr ls lt im bi translated">输入:[-2，1，-3，4，-1，2，1，-5，4]</p><p id="0882" class="ky kz ly la b lb lc ju ld le lf jx lg lz li lj lk ma lm ln lo mb lq lr ls lt im bi translated">产出:6</p><p id="e771" class="ky kz ly la b lb lc ju ld le lf jx lg lz li lj lk ma lm ln lo mb lq lr ls lt im bi translated">说明:[4，-1，2，1]的和最大= 6 "</p></blockquote><p id="f83d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很快，我们注意到这个问题和上一个问题的相似之处，因为我们必须考虑所有可能的相邻子数组(就像我们在上一个问题中必须考虑所有可能的子字符串)。同样，这意味着自下而上的方法效果最好。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="39ab" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">目标</h1><p id="bc13" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们的目标只是返回具有最大和的连续子数组的和。这意味着我们真正关心的是跟踪相邻子阵列的最大和。在这里使用自底向上的方法意味着我们需要从我们的基本案例中找出一个使用计算解决方案的结构来逐步向上。</p><p id="4803" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，我们如何使用之前在遍历数字数组时计算的和来计算新的和呢？</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="7650" class="no mo it mf b gy np nq l nr ns">sum[i+1] = function(sum[i])</span></pre><p id="fd86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质上，我们想要找出一个函数，这个函数将会计算上面给出的<code class="fe mc md me mf b">sum[i]</code>中的<code class="fe mc md me mf b">sum[i+1]</code>，这个函数之前已经计算过了。希望在这一点上，这个函数本质上应该是(其中<code class="fe mc md me mf b">arr</code>是我们的输入数组):</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="2892" class="no mo it mf b gy np nq l nr ns">function(sum[i]) {<br/>    if (sum[i] + arr[i+1] &lt; sum[i]) {<br/>        return sum[i]<br/>    } else {<br/>        return sum[i] + arr[i+1]<br/>    }<br/>}</span></pre><p id="7cd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数将正确返回整个连续子阵列的当前最大和，直到索引<em class="ly"> i </em>。既然我们已经了解了我们希望围绕代码构建的一般结构，我们就准备初始化我们的列表并建立基本案例。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="06d9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">表格</h1><p id="ea0d" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">因为我们只是简单地跟踪连续子数组的最大和，直到索引<em class="ly"> n-1 </em>，其中<em class="ly"> n </em>是我们的输入数组的长度，我们所需要的是一个长度为<em class="ly"> n </em>的1D数组。</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="2cbc" class="no mo it mf b gy np nq l nr ns"># initialize the array where we store our computed solutions<br/>max_sums = [float("-inf") for i in range(len(num_array))]</span></pre><p id="f0e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:我们用负无穷大值初始化数组。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="53da" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">基础案例</h1><p id="7843" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们可以简单地定义何时<em class="ly"> i = 0 </em>，因此这将是:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="2f1a" class="no mo it mf b gy np nq l nr ns">max_sums[0] = max(float("-inf"), num_array[0])</span></pre><p id="73a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这实际上可以简化为:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="7f4a" class="no mo it mf b gy np nq l nr ns">max_sums[0] = num_array[0]</span></pre><p id="3a97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们知道任何数都&gt;负无穷大。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="8f8c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">一路向上</h1><p id="5411" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">利用我们对一般结构的了解，我们可以用Python中的<code class="fe mc md me mf b">max()</code>函数将其缩短为一行。内置的<code class="fe mc md me mf b">max()</code>函数返回两个值中的最大值。最后，我们可以再次使用<code class="fe mc md me mf b">max()</code>函数返回总和的最大值。在这种情况下，<code class="fe mc md me mf b">max()</code>函数遍历数组并返回数组的最大值。</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="6e6b" class="no mo it mf b gy np nq l nr ns">for j in range(1, len(num_array)):<br/>    max_sums[j] = max(max_sums[j-1] + num_array[j], num_array[j])</span><span id="da48" class="no mo it mf b gy nt nq l nr ns">return max(max_sums)</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="115e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">额外挑战</h1><p id="05d3" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们完事了。作为一个额外的挑战，我试图使用动态编程来找到连续的子阵列和总和，但未能找到解决方案。不过，我确实找到了一个非DP解决方案:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="bbe9" class="no mo it mf b gy np nq l nr ns">def function(num_array):</span><span id="15a8" class="no mo it mf b gy nt nq l nr ns">    max_sum = float("-inf")<br/>    start = 0<br/>    end = 1</span><span id="ba81" class="no mo it mf b gy nt nq l nr ns">    for i in range(1, len(num_array)):<br/>        sum = 0<br/>        for j in range(i, len(num_array)):<br/>            sum += num_array[j]<br/>            if sum &gt; max_sum:<br/>                max_sum = sum<br/>                start = i<br/>                end = j + 1</span><span id="25b9" class="no mo it mf b gy nt nq l nr ns">    print("The array " + str(num_array[start:end]) + " has the largest sum of " + str(max_sum))</span></pre><p id="54f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随意分享您对这一额外挑战的解决方案。我希望看到不同的方法！</p></div></div>    
</body>
</html>