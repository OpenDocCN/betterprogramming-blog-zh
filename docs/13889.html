<html>
<head>
<title>Building Reverse Proxy (gRPC-Gateway)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建反向代理(gRPC-网关)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-reverse-proxy-grpc-gateway-621696b29b0?source=collection_archive---------3-----------------------#2022-10-10">https://betterprogramming.pub/building-reverse-proxy-grpc-gateway-621696b29b0?source=collection_archive---------3-----------------------#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8073" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带协议缓冲区的gRPC API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5133d5dbf6cccbe9c70d778c4a204317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zh131FGzYbx8M19v4niZtQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者组合的图像|右图像由<a class="ae ky" href="https://hub.docker.com/_/traefik" rel="noopener ugc nofollow" target="_blank"> traefik </a>，左图像由<a class="ae ky" href="https://go.dev/src/net/http/httputil/reverseproxy.go" rel="noopener ugc nofollow" target="_blank"> Go </a></p></figure><p id="41c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们为一个社交媒体应用程序构建了API设计。我们使用协议缓冲区为一篇文章编写了五个REST端点的定义以及每个端点的HTTP注释，我们还使用<a class="ae ky" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> grpc-gateway </a>插件生成了实现反向代理的代码。</p><p id="02a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将继续构建API，下一步是实现反向代理。</p><p id="83ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你错过了上一篇文章，我建议你按以下顺序阅读:</p><ol class=""><li id="334f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/go-api-design-with-protocol-buffers-and-grpc-991838e4852b">使用协议缓冲区和gRPC进行API设计</a></li><li id="1c9e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">构建反向代理(gRPC-网关)</li><li id="7da5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://yairfernando.medium.com/go-api-database-connection-d47e463cea37" rel="noopener"> Go API —数据库连接</a></li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="5679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用docker和docker-compose，所以我建议首先安装<a class="ae ky" href="https://docs.docker.com/desktop/install/mac-install/" rel="noopener ugc nofollow" target="_blank"> docker </a>和<a class="ae ky" href="https://docs.docker.com/compose/install/#install-compose" rel="noopener ugc nofollow" target="_blank"> docker-compose </a>，并确保您能够运行容器。</p><p id="236d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航到您的<code class="fe mq mr ms mt b">GOPATH</code>，如果您不知道您的go路径目录，您可以运行<code class="fe mq mr ms mt b">echo $GOPATH</code>，这将打印出正确的路径。在那里创建<code class="fe mq mr ms mt b">src/github/com/yaairfernando</code>文件夹结构，用你的GitHub句柄替换最后一个目录。在那里，创建以下项目结构:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="57d9" class="my mz it mt b gy na nb l nc nd">mkdir socialMedia<br/>cd socialMedia<br/>touch docker-compose.yaml</span></pre><p id="1cb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，让我们从定义docker-compose yaml文件开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的yaml文件中，我们定义了<code class="fe mq mr ms mt b">proxy</code>服务，从这个服务的配置中，我们可以看到容器名是<code class="fe mq mr ms mt b">proxy</code>，将要使用的映像是<code class="fe mq mr ms mt b">sma:proxy</code>，如果docker映像不存在，它将从<code class="fe mq mr ms mt b">./proxy</code>文件夹中构建它，我们还将传递一个GitHub访问令牌作为参数，这只有在您为上一篇文章中的API设计创建了私有repo时才是必要的。</p><p id="313b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是这样，您需要向docker映像传递一个GitHub访问令牌，以便能够从docker文件访问私有存储库。</p><p id="6651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还指定了一个命令和两个要运行的环境变量:一个用于指定服务器将要运行的rest端口，一个grpc URL指向代理将要代理请求的服务。</p><p id="f8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还指定该服务将公开的端口是<code class="fe mq mr ms mt b">9094</code>，在内部将是<code class="fe mq mr ms mt b">8081</code>。</p><p id="bd61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建一个代理文件夹和<code class="fe mq mr ms mt b">main.go</code>文件:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="f077" class="my mz it mt b gy na nb l nc nd">mkdir proxy<br/>cd proxy<br/>touch main.go</span></pre><p id="d0ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代理文件夹中，我们将运行这个命令来创建一个go模块</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="3b13" class="my mz it mt b gy na nb l nc nd">go mod init github.com/yaairfernando/proxy</span></pre><p id="98ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在代理文件夹下创建一个<code class="fe mq mr ms mt b">go.mod</code>文件。</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="2ac6" class="my mz it mt b gy na nb l nc nd">module github.com/yaairfernando/proxy</span><span id="340b" class="my mz it mt b gy ng nb l nc nd">go 1.18</span></pre><p id="7012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mq mr ms mt b">main.go</code>文件是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="848e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要功能只是通过<code class="fe mq mr ms mt b">grpcURL</code>、<code class="fe mq mr ms mt b">restPort</code>初始化一个新的服务器，调用服务器实例上的start方法。</p><p id="b0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看服务器文件是什么样子的。创建服务器文件夹和一个<code class="fe mq mr ms mt b">server.go</code>文件。</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="2cdc" class="my mz it mt b gy na nb l nc nd">mkdir server<br/>cd server<br/>touch server.go</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个服务器文件包含了为<code class="fe mq mr ms mt b">Posts</code>资源注册处理程序、添加一个简单的记录器、创建一个HTTP服务器和监听指定端口的所有逻辑。</p><ul class=""><li id="ac97" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">在第36行，我们创建了一个新的服务器mux</li><li id="fc0e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">在第38行，我们用一个简单的记录器包装了服务器</li><li id="bdd4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">在第40行，我们注册了所有的处理程序。在我们的例子中，目前我们只有一个用于<code class="fe mq mr ms mt b">Posts</code>资源的</li><li id="903b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">最后，在第45–49行，我们创建了一个HTTP服务器，传递处理程序并开始监听</li></ul><p id="a498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，这个文件中没有定义一些帮助函数。我将它们添加到一个<code class="fe mq mr ms mt b">utils</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在让我们创建<code class="fe mq mr ms mt b">Dockerfile</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会深入这个docker文件在做什么，但本质上它使用一个Golang映像作为构建器，设置一些go环境变量，设置工作目录，并复制<code class="fe mq mr ms mt b">go.mod</code>文件。之后，它下载所有的依赖项，复制其余的文件，最后设置入口点。</p><p id="ec0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是包含所有使用的包的<code class="fe mq mr ms mt b">go.mod</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="75b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是项目的最终文件夹结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/015414dd4a82e02c1b38edd6e417489c.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*qpD4reSx0g0jK87BBOlEUw.png"/></div></figure><p id="6d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们差不多完成了。现在，让我们通过在代理文件夹中运行以下命令来下载我们需要的go包:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="1fa7" class="my mz it mt b gy na nb l nc nd">go mod download<br/>go mod tidy</span></pre><p id="2073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，对于<code class="fe mq mr ms mt b">sma</code>包，我们指定我们想要来自该包的版本<code class="fe mq mr ms mt b">v0.1.0</code>，但是当我们构建API设计时，我们没有创建任何版本。就这么办吧。</p><h2 id="3427" class="my mz it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">生成Git标签</h2><p id="d75a" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">回到您拥有<code class="fe mq mr ms mt b">sma</code>项目的地方，让我们创建一个标签:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="5691" class="my mz it mt b gy na nb l nc nd">git tag v0.1.0</span></pre><p id="188f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将其推送到存储库:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="ef84" class="my mz it mt b gy na nb l nc nd">git push origin v0.1.0</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="0eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，回到<code class="fe mq mr ms mt b">proxy</code>文件夹，运行这个命令来下载那个版本的<code class="fe mq mr ms mt b">sma</code>包:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="3998" class="my mz it mt b gy na nb l nc nd">go get github.com/yaairfernando/sma@v0.1.0</span></pre><p id="41a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令将下载指定版本的<code class="fe mq mr ms mt b">sma</code>包。</p><p id="4c35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们构建服务之前，最后一件事是添加一个带有GitHub访问令牌的<code class="fe mq mr ms mt b">.env</code>文件，以防您对API设计的回购是私有的。</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="738c" class="my mz it mt b gy na nb l nc nd">GITHUB_ACCESS_TOKEN=your_gihub_access_token</span></pre><h1 id="dc0a" class="of mz it bd nj og oh oi nm oj ok ol np jz om ka ns kc on kd nv kf oo kg ny op bi translated">构建Docker服务</h1><p id="8cfc" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">我们现在可以通过在根文件夹中运行以下命令来构建代理服务:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="3844" class="my mz it mt b gy na nb l nc nd">docker-compose up --build -d proxy</span></pre><p id="8c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当运行这个命令时，你会得到一些错误，告诉你下载一些我们在<code class="fe mq mr ms mt b">go.mod</code>文件中指定的包。运行<code class="fe mq mr ms mt b">go mod download package_path</code>下载软件包即可。并重新运行docker-compose命令。</p><p id="340e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建完成后，我们应该能够看到容器正在运行。向<code class="fe mq mr ms mt b"><a class="ae ky" href="http://localhost:9094/v1/posts" rel="noopener ugc nofollow" target="_blank">http://localhost:9094/v1/posts</a></code>发送POST请求还不行，但是我们可以看到日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/cf1ff6d56a985fbeb2868447b3341584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhi8mjLei4D-vtzvyEpeCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代理运行</p></figure><p id="5243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是本文的全部内容。我们已经实现了反向代理。在下一篇文章中，我们将继续构建API。</p><p id="0173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">敬请期待，感谢您的阅读！</p></div></div>    
</body>
</html>