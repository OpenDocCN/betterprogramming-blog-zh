<html>
<head>
<title>Understanding Swift Strings, Emoji, Characters, and Scalars</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Swift字符串、表情符号、字符和标量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-swift-strings-characters-and-scalars-a4b82f2d8fde?source=collection_archive---------6-----------------------#2019-11-17">https://betterprogramming.pub/understanding-swift-strings-characters-and-scalars-a4b82f2d8fde?source=collection_archive---------6-----------------------#2019-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b930" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">使用表情符号作为一个有趣而简单的例子，了解Swift如何处理角色</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi kg"><img src="../Images/fd4e1c35183ae7745da7e9e23ae2c450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*qbavXbFy66SvDx9Nt0jq8A.png"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ks" href="https://unsplash.com/@iabzd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> iabzd </a>在<a class="ae ks" href="https://unsplash.com/s/photos/emoji?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a371" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">字符和字形之间的关系可能有点混乱。通过使用表情符号并观察Swift处理它们的方式，我们将深入这个主题。假设你想检查一个字符串是否包含一个或多个表情符号，你会怎么做？</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="6374" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">表情符号的一点背景</h1><p id="47bb" class="pw-post-body-paragraph kt ku iq kv b kw mo jr ky kz mp ju lb lc mq le lf lg mr li lj lk ms lm ln lo ij bi">The word comes from two Japanese words: 絵 meaning <em class="mt">picture</em> (e) and 文字 meaning <em class="mt">character </em>(moji/mohdzi). The fact the word might make you think of <em class="mt">emoticon</em> or<em class="mt"> emotion</em> is purely coincidental.</p><p id="41d4" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">它们存在的时间比你想象的要长。虽然它们在2010年左右在全球范围内流行，但自1997年以来，它们就已经在日本使用了。从不到80个符号开始，表情符号集已经发展到包含超过1200个图标。</p><p id="ef3a" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">2010年也是第一套表情符号被加入Unicode标准的一年。Unicode是一种行业标准，旨在统一文本的处理和表示。它还包含了一个来自世界各地书写系统的字符索引，包括现代和古代的。这个标准还在不断发展——在撰写本文时的最新版本(12.1)包含了将近138，000个字符。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/85361d661d0cacfbb2be522edf16d6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vyPqBKAVE7O36z6M800-A.png"/></div></div><p class="ko kp gj gh gi kq kr bd b be z dk translated">以下是Unicode标准中定义的一些字符示例</p></figure><p id="0827" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">该标准不仅包括世界各地字母表中的字符，还包括不可见且不能独立使用的特殊字符。我们稍后会谈到这一点。</p><p id="2286" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我强烈推荐查看一下<a class="ae ks" href="https://unicode-table.com/en/" rel="noopener ugc nofollow" target="_blank"> Unicode字符表</a>来了解一下它的规模。只需向下滚动主页上的表格，即可发现各种组合和可能性。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="e69d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">潜入水中</h1><p id="be96" class="pw-post-body-paragraph kt ku iq kv b kw mo jr ky kz mp ju lb lc mq le lf lg mr li lj lk ms lm ln lo ij bi translated">由Unicode标准定义的每个字符都有一个十六进制标识符(unicode number ),并且字符被分类成块，例如希伯来语或阿拉伯语。</p><p id="d420" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">理解字符、字形和标量之间的区别很重要。Unicode由Unicode数字指定的字符组成。一个字符可以在屏幕上显示，也可以不显示。此外，字符的组合可能导致一个字符出现在屏幕上。Swift通过稍微不同的定义来区分这三个术语。这是一个相当复杂的故事，但它的要点是:</p><ul class=""><li id="6c12" class="mz na iq kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated">字符串由字符组成</li><li id="d7f2" class="mz na iq kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated">字符由unicode标量组成</li><li id="1510" class="mz na iq kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated">每个Unicode标量代表一个Unicode字符</li></ul><p id="688f" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">回到Unicode字符。这里有一个例子:<a class="ae ks" href="https://unicode-table.com/en/1F600/" rel="noopener ugc nofollow" target="_blank">咧着嘴笑的脸</a>(😀)被标识为<code class="fe nn no np nq b">U+1F600</code>并且是表情块<em class="mt">的一部分。</em>您可以通过多种方式用Swift字符串表示表情符号:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="b818" class="nv lx iq nq b gy nw nx l ny nz">let smiley1 = “😀” <br/>let smiley2 = “\u{1F600}” // Hex code, also "😀"</span></pre><blockquote class="oa ob oc"><p id="abe0" class="kt ku mt kv b kw kx jr ky kz la ju lb od ld le lf oe lh li lj of ll lm ln lo ij bi translated">“这样我们就可以找到表情符号的unicode区块，并检查某个字符是否来自该区块？”</p></blockquote><p id="01e6" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">嗯，没有。</p><p id="7ecd" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">没有一个表情符号。有用于<a class="ae ks" href="https://unicode-table.com/en/blocks/transport-and-map-symbols/" rel="noopener ugc nofollow" target="_blank">运输和地图</a>、<a class="ae ks" href="https://unicode-table.com/en/blocks/supplemental-symbols-and-pictographs/" rel="noopener ugc nofollow" target="_blank">补充符号和象形图</a>的独立块，以及<a class="ae ks" href="https://unicode-table.com/en/blocks/miscellaneous-symbols-and-pictographs/" rel="noopener ugc nofollow" target="_blank">杂项符号和象形图</a>中的一大堆图标。即使我们确定了哪些区块或哪些字符列表是表情符号，它也有可能无法适应未来。该标准一直在发展和扩展。</p><p id="857e" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">但是如果你深入挖掘，你会发现最后一块也有奇怪的字符，例如:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi og"><img src="../Images/4b45a8f9eee1f25632a4297d6055bc9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:218/format:webp/1*ip_Uvn9NCY7u9G_9WA6sRg.png"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ks" href="https://unicode-table.com/en/1F543/" rel="noopener ugc nofollow" target="_blank"> <em class="kf">带三个点的凹口左半圆</em> </a></p></figure><p id="540c" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我不确定它应该是什么(除了Unicode给出的文字描述)，但我的浏览器肯定不知道如何显示它:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/38a462cec301d2981f7a8e101d36c6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:228/format:webp/1*AEtxllCeFL3m6-5ZF89XIQ.png"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated">我的浏览器如何呈现上述字符</p></figure><h2 id="3f3e" class="nv lx iq bd ly oi oj dn mc ok ol dp mg lc om on mi lg oo op mk lk oq or mm os bi translated">将此应用于代码</h2><p id="2405" class="pw-post-body-paragraph kt ku iq kv b kw mo jr ky kz mp ju lb lc mq le lf lg mr li lj lk ms lm ln lo ij bi translated">在Swift 4.2之前，我们只能通过检查Unicode编码是否属于某个预定义的Unicode块来判断一个字符是否是表情符号。</p><p id="0c89" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">但是Swift 5.0出现了，随之而来的是一个新的<code class="fe nn no np nq b"><a class="ae ks" href="https://developer.apple.com/documentation/swift/unicode/scalar/properties" rel="noopener ugc nofollow" target="_blank">Unicode.Scalar.Properties</a></code>类，给了我们一系列的标志来帮助我们弄清楚我们在处理什么。我们可以很容易地获取表示字符串的Unicode标量数组。</p><p id="58e5" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">无聊的谈话已经够多了——这里有一个例子:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="7211" class="nv lx iq nq b gy nw nx l ny nz">// Here's our emoji<br/>let smiley = "😀"</span><span id="439b" class="nv lx iq nq b gy ot nx l ny nz">// Get an iterable of the scalars in our String<br/>let scalars = smiley.unicodeScalars // UnicodeScalarView instance</span><span id="f254" class="nv lx iq nq b gy ot nx l ny nz">// We have one character, so we'll be getting that one<br/>let firstScalar = scalars.first // is 128512</span><span id="8fc2" class="nv lx iq nq b gy ot nx l ny nz">// Note that 128512 is actually the decimal <br/>// value for hexadecimal 1F600 (the unicode identifier for 😀)</span><span id="64d3" class="nv lx iq nq b gy ot nx l ny nz">// Get the properties<br/>let properties = firstScalar?.properties<br/><br/>// Check if it's an Emoji<br/>let isEmoji = properties?.isEmoji // = true</span></pre><h2 id="e9b4" class="nv lx iq bd ly oi oj dn mc ok ol dp mg lc om on mi lg oo op mk lk oq or mm os bi translated"><em class="kf">找到了！所以我们结束了？</em></h2><p id="ab6a" class="pw-post-body-paragraph kt ku iq kv b kw mo jr ky kz mp ju lb lc mq le lf lg mr li lj lk ms lm ln lo ij bi translated">不，不如这样:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="8f32" class="nv lx iq nq b gy nw nx l ny nz">// Strangely enough, this will return <strong class="nq ir">true</strong>:<br/>"3".unicodeScalars.first?.properties.isEmoji</span></pre><p id="59b8" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这是因为标量<code class="fe nn no np nq b">3</code> <em class="mt">可以</em>呈现为表情符号，尽管在这种特殊情况下它不是。物业<code class="fe nn no np nq b">isEmoji</code>这样真的是误导。幸运的是，还有另一个属性:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="4d40" class="nv lx iq nq b gy nw nx l ny nz">// This will return true like before:<br/>"😀".unicodeScalars.first?.properties.isEmojiPresentation</span><span id="dba0" class="nv lx iq nq b gy ot nx l ny nz">// And this will return false like we expect:<br/>"3".unicodeScalars.first?.properties.isEmojiPresentation</span><span id="c855" class="nv lx iq nq b gy ot nx l ny nz">// By the way, that 'Notched Left Semicircle with Three Dots'<br/>// also returns false, as we cannot actually render it:<br/>"🕃".unicodeScalars.first?.properties.isEmojiPresentation</span><span id="1059" class="nv lx iq nq b gy ot nx l ny nz">// Unfortunately, this doesn't hold true for all emoji:<br/>"🌶".unicodeScalars.first?.properties.isEmojiPresentation <em class="mt">// false<br/></em>"🌶".unicodeScalars.first?.properties.generalCategory == .some(.otherSymbol) <em class="mt">// true</em></span></pre><p id="5caf" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">好多了，对吧？但是我们还没到那一步。也有字符实际上由多个字形组成。请看我们如何用<code class="fe nn no np nq b">unicodeScalars.first? </code> <br/>考虑下面的例子:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="8e71" class="nv lx iq nq b gy nw nx l ny nz">"1️⃣".unicodeScalars.first?.properties.isEmojiPresentation <em class="mt">// false</em></span><span id="5704" class="nv lx iq nq b gy ot nx l ny nz">"♦️".unicodeScalars.first?.properties.isEmojiPresentation <em class="mt">// false</em></span><span id="d59a" class="nv lx iq nq b gy ot nx l ny nz">"👍🏻".unicodeScalars.first?.properties.isEmojiPresentation <em class="mt">// true</em></span><span id="9b58" class="nv lx iq nq b gy ot nx l ny nz">"👨‍👩‍👧‍👧".unicodeScalars.first?.properties.isEmojiPresentation <em class="mt">// true</em></span></pre><p id="2a3f" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">为了解释为什么会出现这种情况，我们来看看<code class="fe nn no np nq b">unicodeScalars</code>属性。属性<code class="fe nn no np nq b">unicodeScalars</code>返回一个<code class="fe nn no np nq b">UnicodeScalarView</code>的实例。</p><p id="1d26" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">它的<code class="fe nn no np nq b">debugDescription</code>将只产生原始字符串，所以直接检查内容(或记录)并不能提供太多的洞察力。幸运的是，<a class="ae ks" href="https://developer.apple.com/documentation/swift/string/unicodescalarview/3018490-map" rel="noopener ugc nofollow" target="_blank">有一个映射函数</a>将返回一个常规数组，所以我们最终得到了一个包含<code class="fe nn no np nq b"><a class="ae ks" href="https://developer.apple.com/documentation/swift/unicode" rel="noopener ugc nofollow" target="_blank">Unicode</a>.<a class="ae ks" href="https://developer.apple.com/documentation/swift/unicode/scalar" rel="noopener ugc nofollow" target="_blank">Scalar</a></code>元素的数组:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="54ca" class="nv lx iq nq b gy nw nx l ny nz">// This will create an UnicodeScalarView<br/>let scalarView = "1️⃣".unicodeScalars</span><span id="8546" class="nv lx iq nq b gy ot nx l ny nz">// Map the view so we get a regular array which we can inspect<br/>let scalars = scalarView.map { $0 }</span></pre><p id="7f50" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">结果包含三个值:</p><ul class=""><li id="92d2" class="mz na iq kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated">十进制49(十六进制U+0031):一个普通的旧<a class="ae ks" href="https://unicode-table.com/en/0031/" rel="noopener ugc nofollow" target="_blank">数字1 </a></li><li id="ba12" class="mz na iq kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated">十进制65039(十六进制U+FE0F): <a class="ae ks" href="https://unicode-table.com/en/FE0F/" rel="noopener ugc nofollow" target="_blank">变化选择器-16 </a></li><li id="a350" class="mz na iq kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated">十进制8419(十六进制U+20E3): <a class="ae ks" href="https://unicode-table.com/en/20E3/" rel="noopener ugc nofollow" target="_blank">组合封闭键帽</a></li></ul><p id="69d1" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我们之前提到过这些特殊的标量。所以这些字符的组合被用来形成表情符号，将一个普通的数字<code class="fe nn no np nq b">1</code>变成这个符号。第二个和第三个标量修改初始标量。澄清一下，您也可以使用十六进制unicode标识符来手动创建这个组合:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="4c54" class="nv lx iq nq b gy nw nx l ny nz">"\u{0031}" // turns into: 1</span><span id="49a1" class="nv lx iq nq b gy ot nx l ny nz">"\u{0031}\u{20E3}" // turns into: 1⃣</span><span id="0ded" class="nv lx iq nq b gy ot nx l ny nz">"\u{0031}\u{FE0F}\u{20E3}" // turns into: 1️⃣</span></pre><p id="f45e" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">同样，其他表情符号也可以组合使用:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="6a58" class="nv lx iq nq b gy nw nx l ny nz">// Black Diamond Suit Emoji<br/>"\u{2666}" // ♦</span><span id="5fed" class="nv lx iq nq b gy ot nx l ny nz">// Adding 'Variation Selector-16':<br/>"\u{2666}\u{FE0F}" // ♦️</span><span id="602f" class="nv lx iq nq b gy ot nx l ny nz"><br/>// Thumbs up sign:<br/>"\u{1F44D}" // 👍</span><span id="8f98" class="nv lx iq nq b gy ot nx l ny nz">// Adding 'Emoji Modifier Fitzpatrick Type-4':<br/>"\u{1F44D}\u{1F3FD}" // 👍🏽</span><span id="bc49" class="nv lx iq nq b gy ot nx l ny nz"><br/>// Man, Woman, Girl, Boy<br/>"\u{1F468}\u{1F469}\u{1F467}\u{1F466}" // 👨👩👧👦</span><span id="d7bf" class="nv lx iq nq b gy ot nx l ny nz">// Adding 'Zero Width Joiner' between each<br/>"\u{1F468}\u{200D}\u{1F469}\u{200D}\u{1F467}\u{200D}\u{1F466}" // 👨‍👩‍👧‍👦</span></pre><p id="99c8" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">是的，那是七个标量组合成一个字符。</p><p id="6433" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">最后，值得注意的是，并不是每个由多个标量组成的字符都是表情符号:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="896e" class="nv lx iq nq b gy nw nx l ny nz">"\u{0061}" <em class="mt">// Letter: a</em></span><span id="2914" class="nv lx iq nq b gy ot nx l ny nz">"\u{0302}" <em class="mt">// </em>Circumflex Accent<em class="mt">: </em>̂</span><span id="8266" class="nv lx iq nq b gy ot nx l ny nz">"\u{0061}\u{0302}" <em class="mt">// Combines into: â</em></span></pre><p id="fe9e" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated"><strong class="kv ir">小旁注:</strong>也许你在网上看到过看起来很乱的信息/文本(几乎就像是矩阵中的一个小故障)，看起来像这样:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/2100f15ab4c3efa040e93938587a7b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*oHzANv6CyNT1A2XVYuwhBQ.png"/></div></figure><p id="de80" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这通常被称为<a class="ae ks" href="https://zalgo.org" rel="noopener ugc nofollow" target="_blank"> Zalgo </a>，实际上只是由许多Unicode字符在屏幕上合并成单个字符:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="2600" class="nv lx iq nq b gy nw nx l ny nz"><br/>let lotsOfScalars = "E̵͉͈̥̝͛͊̂͗͊̈́̄͜"<br/></span><span id="633c" class="nv lx iq nq b gy ot nx l ny nz">let scalars = lotsOfScalars.unicodeScalars.map { $0 }<br/></span><span id="bf76" class="nv lx iq nq b gy ot nx l ny nz">// Merge into a string, adding spaces to see them individually<br/>// This will result in: E  ̵  ͛  ͊  ̂  ͗  ͊  ̈́  ̄  ͜  ͉  ͈  ̥  ̝<br/>let scalarList = scalars.reduce("", { "\($0)   \($1)" })<br/></span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="6295" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">获取正确的信息</h1><p id="79f5" class="pw-post-body-paragraph kt ku iq kv b kw mo jr ky kz mp ju lb lc mq le lf lg mr li lj lk ms lm ln lo ij bi translated">让我们结合这些信息，向字符和字符串类添加一些助手属性。我们将:</p><ul class=""><li id="0e3d" class="mz na iq kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated">检查一个字符是否正好是一个标量，将作为表情符号呈现</li><li id="83ea" class="mz na iq kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated">检查一个字符是否由多个标量组成，这些标量将被组合成一个表情符号</li></ul><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="1db7" class="nv lx iq nq b gy nw nx l ny nz">extension Character {<br/>  var isSimpleEmoji: Bool {<br/>    guard let firstScalar = unicodeScalars.first else {<br/>      return false<br/>    }<br/>    return firstScalar.properties.isEmoji &amp;&amp; firstScalar.value &gt; 0x238C<br/>  }</span><span id="d82c" class="nv lx iq nq b gy ot nx l ny nz">var isCombinedIntoEmoji: Bool {<br/>    unicodeScalars.count &gt; 1 &amp;&amp; unicodeScalars.first?.properties.isEmoji ?? false<br/>  }</span><span id="6d15" class="nv lx iq nq b gy ot nx l ny nz">var isEmoji: Bool { isSimpleEmoji || isCombinedIntoEmoji }<br/>}</span></pre><p id="2898" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">接下来，我们将向字符串添加一些计算属性，以访问我们的字符扩展:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="1f3d" class="nv lx iq nq b gy nw nx l ny nz">extension String {<br/>  var isSingleEmoji: Bool {<br/>    return count == 1 &amp;&amp; containsEmoji<br/>  }</span><span id="0722" class="nv lx iq nq b gy ot nx l ny nz">  var containsEmoji: Bool {<br/>    return contains { $0.isEmoji }<br/>  }</span><span id="9181" class="nv lx iq nq b gy ot nx l ny nz">  var containsOnlyEmoji: Bool {<br/>    return !isEmpty &amp;&amp; !contains { !$0.isEmoji }<br/>  }</span><span id="b313" class="nv lx iq nq b gy ot nx l ny nz">  var emojiString: String {<br/>    return emojis.map { String($0) }.reduce("", +)<br/>  }</span><span id="1349" class="nv lx iq nq b gy ot nx l ny nz">  var emojis: [Character] {<br/>    return filter { $0.isEmoji }<br/>  }</span><span id="14ab" class="nv lx iq nq b gy ot nx l ny nz">  var emojiScalars: [UnicodeScalar] {<br/>    return filter { $0.isEmoji }.flatMap { $0.unicodeScalars }<br/>  }<br/>}</span></pre><p id="375e" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">现在，检查我们的表情符号字符串变得非常简单:</p><pre class="kh ki kj kk gt nr nq ns nt aw nu bi"><span id="d76a" class="nv lx iq nq b gy nw nx l ny nz">"â".isSingleEmoji // false<br/>"3".isSingleEmoji // false<br/>"3️⃣".isSingleEmoji // true<br/>"3️⃣".emojiScalars // [51, 65039, 8419]<br/>"👌🏿".isSingleEmoji // true<br/>"🙎🏼‍♂️".isSingleEmoji // true<br/>"👨‍👩‍👧‍👧".isSingleEmoji // true<br/>"👨‍👩‍👧‍👧".containsOnlyEmoji // true<br/>"🏴󠁧󠁢󠁳󠁣󠁴󠁿".isSingleEmoji // true<br/>"🏴󠁧󠁢󠁥󠁮󠁧󠁿".containsOnlyEmoji // true<br/>"Hello 👨‍👩‍👧‍👧".containsOnlyEmoji // false<br/>"Hello 👨‍👩‍👧‍👧".containsEmoji // true<br/>"👫 Héllo 👨‍👩‍👧‍👧".emojiString // "👫👨‍👩‍👧‍👧"</span><span id="73f5" class="nv lx iq nq b gy ot nx l ny nz">"👫 Héllœ 👨‍👩‍👧‍👧".emojiScalars // [128107, 128104, 8205, 128105, 8205, 128103, 8205, 128103]<br/>"👫 Héllœ 👨‍👩‍👧‍👧".emojis // ["👫", "👨‍👩‍👧‍👧"]<br/>"👫 Héllœ 👨‍👩‍👧‍👧".emojis.count // 2</span><span id="63da" class="nv lx iq nq b gy ot nx l ny nz">"👫👨‍👩‍👧‍👧👨‍👨‍👦".isSingleEmoji // false<br/>"👫👨‍👩‍👧‍👧👨‍👨‍👦".containsOnlyEmoji // true</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="dd0f" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">总结一下</h1><p id="3951" class="pw-post-body-paragraph kt ku iq kv b kw mo jr ky kz mp ju lb lc mq le lf lg mr li lj lk ms lm ln lo ij bi translated">字符和标量之间有一个重要的区别:基本上，由定义标量的字符串和呈现它的系统来决定标量将产生哪些字符。</p><p id="5ab4" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">虽然Unicode将每个代码点定义为一个字符，但Swift实际上称这些<em class="mt">标量为</em>，并使用术语字符来表示标量的组合，这可能导致字符串中的单个字形。我说<em class="mt">可能是</em>，因为像控制字符(例如<code class="fe nn no np nq b"><a class="ae ks" href="https://unicode-table.com/en/0000/" rel="noopener ugc nofollow" target="_blank">null</a></code>和<code class="fe nn no np nq b"><a class="ae ks" href="https://unicode-table.com/en/0008/" rel="noopener ugc nofollow" target="_blank">backspace</a></code>)这样的东西会被算作单独的字符。</p><p id="ace9" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>