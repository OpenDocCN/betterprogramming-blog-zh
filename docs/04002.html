<html>
<head>
<title>8 Awesome React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">8个牛逼的反应钩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-awesome-react-hooks-2cb31aed4f3d?source=collection_archive---------2-----------------------#2020-03-18">https://betterprogramming.pub/8-awesome-react-hooks-2cb31aed4f3d?source=collection_archive---------2-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b86" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">usePrevious、useTimeout等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b2d059b20a00db6c437a3688782d437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSXvKKUA3khRDYvJDJyfUA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">科尔顿·迪安·马歇尔在<a class="ae ky" href="https://unsplash.com/s/photos/patterns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="cbd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章最初发表在智能编码器上。</p><p id="f5ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React.js是目前最受前端开发者欢迎的JavaScript库。由脸书发明，但作为一个开源项目，它被全世界的开发者和公司使用。</p><p id="9da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React真正改变了我们构建单页面应用程序的方式——它最伟大的特性之一就是钩子。钩子是去年引入的，它使我们能够在处理状态时使用功能组件而不是基于类的组件。除了内置挂钩，React还为我们提供了实现自定义挂钩的方法。</p><p id="8898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是一些我最喜欢的定制钩子及其实现的例子，你也可以在你的应用程序和项目中使用它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="56ff" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用超时</h1><p id="016d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有了这个钩子，我们可以使用声明性的方法实现<code class="fe mz na nb nc b">setTimeout</code>。首先，我们创建一个带有回调和延迟的定制钩子。然后我们使用<code class="fe mz na nb nc b">useRef</code>钩子为回调函数创建一个<em class="nd"> ref </em>。最后，我们两次使用<code class="fe mz na nb nc b">useEffect</code>。一次用于记住最后一次回调，一次用于设置超时和清理。</p><p id="2a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该示例显示了计时器的实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/7e04b8594ae23abf192e68858511ee69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3UtcCG-xaPfD5dGDqGmeA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7af8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用以前的</h1><p id="482e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是我们可以在应用程序中使用的另一个很棒的定制钩子。有了它，我们可以存储道具或者之前的状态。首先，我们创建一个接受值的定制钩子。然后我们使用<code class="fe mz na nb nc b">useRef</code>钩子为这个值创建一个<code class="fe mz na nb nc b">ref</code>。最后，我们用<code class="fe mz na nb nc b">useEffect</code>来记住最新的值。</p><p id="0442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该示例显示了计数器的实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/efabee4ccc4a51f7a6ed3660e87bda8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QnN9dlw1BoWrzZlm5Ey3w.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="426f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用单击内部</h1><p id="4d04" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您需要处理点击包装组件内部的事件，那么<code class="fe mz na nb nc b">useClickInside</code>钩子是您的正确选择。首先，我们创建一个定制钩子，它接受一个<em class="nd"> ref </em>和一个回调来处理click事件。然后我们利用<code class="fe mz na nb nc b">useEffect</code>来添加和清理点击事件。最后，我们使用<code class="fe mz na nb nc b">useRef</code>为被点击的组件创建一个<em class="nd">引用</em>，并将其传递给<code class="fe mz na nb nc b">useClickInside</code>钩子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/143121e0d623dc0d08dd9d26b7d0c33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByyuAQaOsxzpBXTG8aInuw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc91" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用单击外部</h1><p id="3426" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">useClickOutside</code>钩子与<code class="fe mz na nb nc b">useClickInside</code>钩子非常相似，但是它负责点击被包装组件的外部，而不是内部。因此，我们再次创建一个定制钩子，它接受一个<em class="nd"> ref </em>和一个回调来处理click事件。然后我们利用<code class="fe mz na nb nc b">useEffect</code>来追加和清理点击事件。最后，我们使用<code class="fe mz na nb nc b">useRef</code>为组件创建一个<em class="nd">引用</em>，并将其传递给<code class="fe mz na nb nc b">useClickOutside</code>钩子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/0d4dd9744bb8bbcc04eb760024cf05ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Igyy9IpmE5WDopoh31d6sg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6d5a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Fetch</h1><p id="cd97" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">useFetch</code>钩子可以用来以声明的方式实现<code class="fe mz na nb nc b">fetch</code>。首先，我们使用<code class="fe mz na nb nc b">useState</code>来初始化响应和错误状态变量。然后我们使用<code class="fe mz na nb nc b">useEffect</code>异步调用fetch并更新状态。最后，我们返回一个包含响应/错误变量的对象。</p><p id="b6f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该示例显示了一种从Star Wars API获取角色并呈现其名称的方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/810083e66c024d63f9a42fe49ffb308f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ksjc_579vPRjEFv20T4XzQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4720" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用间隔</h1><p id="da1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你想以声明的方式实现<code class="fe mz na nb nc b">setInterval</code>，你可以使用这个叫做<code class="fe mz na nb nc b">useInterval</code>的钩子。</p><p id="561c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们必须创建一个接受回调和延迟的定制钩子。然后我们使用<code class="fe mz na nb nc b">useRef</code>为回调创建一个<code class="fe mz na nb nc b">ref</code>。最后，我们使用<code class="fe mz na nb nc b">useEffect</code>来记住最近的回调，并设置间隔和清理。</p><p id="7c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该示例显示了一个自定义<code class="fe mz na nb nc b">ResourceCounter</code>的实现，例如，它可以在浏览器游戏中使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/9b1a688e825ebe24bfe1c0fa0dc88ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXS_PXg0dg22kGs-5GNDpA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6f9f" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">useComponentDidMount</h2><p id="0aeb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个钩子是一个小例子，展示了如何在组件安装后立即执行回调。对于第二个参数，我们简单地使用带有空数组的<code class="fe mz na nb nc b">useEffect</code>,一旦组件被安装，就执行所提供的回调。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/f09fd6fc4e670d739acbd05df8fbdbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yisVTio-IjBHEq8wCm07aA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="841a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">useComponentWillUnmount</h1><p id="aab9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">useComponentWillUnmount</code>类似于上面的例子，但是一旦组件被卸载就会执行回调。因此，我们再次使用<code class="fe mz na nb nc b">useEffect</code>,将一个空数组作为第二个参数，在清理之前执行所提供的回调</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/fa254df7b366424402c5685601ee08fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xguyD3BOywb7Dof33NpPQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是我最喜欢的自定义React挂钩的例子，你可以在你的应用程序中使用。</p></div></div>    
</body>
</html>