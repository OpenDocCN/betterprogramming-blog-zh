<html>
<head>
<title>Spotless Routing and Navigation in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter中完美的路由和导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/spotless-routing-and-navigation-in-flutter-995c647b9258?source=collection_archive---------6-----------------------#2020-01-23">https://betterprogramming.pub/spotless-routing-and-navigation-in-flutter-995c647b9258?source=collection_archive---------6-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c922" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在代码中处理路由和导航的最佳方式是什么？这里有一个完美的解决方案，你应该试试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c111df1fe07cbf9471fc142b22d2794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKrUSPP0IlhkW3oZs6drwg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@bogdan_karlenko?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">波格丹一世·卡伦科</a>在<a class="ae ky" href="https://unsplash.com/s/photos/routes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="bc22" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="de22" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦你完成了对Flutter基础知识的学习，并开始着手你的第一个项目，你会发现自己在问:</p><p id="5008" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">“处理路线和导航的最佳方式是什么？”</p><p id="2692" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">“我应该使用命名路由吗？我该不该用套餐？”</p><p id="4feb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不，我不是来说“这取决于你的需求。”</p><p id="afa2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我在一家软件服务公司工作，因此，我们每年开发许多应用程序。这就要求找到适合最多不同项目的解决方案。</p><p id="47ed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你做过原生移动开发，你就会知道路由总是成为一件严肃的事情。每当我周围的失败者，它是五分钟之前，我们讨论路由器，协调器，流量，及其利弊。对于Androiders，情况完全相同——只需用Jetpack Navigation、Cicerone或FragNav替换这些术语。似乎没有人对它完全满意。</p><p id="78c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果Flutter是你第一次涉足移动世界，请记住这些话:这不会是你最后一次谈论路由策略。</p><p id="c54e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在你绝望之前，给我一个机会让你看看我是怎么做到的。</p><p id="8c38" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我非常满意，我想你也会满意的。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="42e5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你曾经花时间思考过网页上的导航是如何进行的吗？</p><p id="1239" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我不是在谈论它是如何开发的或者类似的事情——我感兴趣的是你作为网站用户或者RESTful API消费者的体验。</p><p id="fc4a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">URL通常是围绕资源设计的，资源可以是一个集合，也可以是一个项目。例如:</p><p id="ca61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">想要访问电影列表吗？转到<code class="fe na nb nc nd b">${yourFavoriteMovieWebsite}/movies</code>。</p><p id="88b9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">想要查看您在列表中找到的特定电影的更多详细信息吗？转到<code class="fe na nb nc nd b">${yourFavoriteMovieWebsite}/movies/:picked_movie_id</code>。</p><p id="3b5c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你注意到参数化的id了吗？这是路径参数或URL参数。</p><p id="3ebc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">只看2020年上映的电影怎么样？没问题，只需向第一个端点传递一个名为<code class="fe na nb nc nd b">releaseYear</code>的查询参数:</p><p id="cb07" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe na nb nc nd b">${yourFavoriteMovieWebsite}/movies?releaseYear=2020</code></p><p id="d6c9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">顺便说一下，URL中包含参数的部分，以问号开头，就是我们所说的查询字符串。</p><p id="ae34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">延伸阅读:<a class="ae ky" href="https://restfulapi.net/resource-naming/" rel="noopener ugc nofollow" target="_blank"> REST资源命名</a>。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="e1c2" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">如果我们的应用程序也能做到这一点会怎么样？</h1><p id="f30c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">“我为什么要做这种事？”</p><p id="47ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">除了它惊人的直觉和组织性，我们只差一步就准备好深层链接了。</p><p id="7da8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">“深度链接？”</p><p id="3189" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你有没有在手机上打开一个链接，而不是打开一个网页，打开一个应用程序的特定页面？</p><p id="2955" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一个很好的例子是，当你收到来自messenger应用程序的推送通知并点击它时，它会将你带到特定的对话屏幕。</p><p id="36b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这就是深度链接的意义所在。这也是我们今天要说的全部内容——它很快会有自己的文章。</p><p id="1540" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我的观点是:如果我们迟早要考虑页面的URL路径，为什么不从一开始就考虑呢？即使你不打算在你的项目中支持深层链接，这仍然是最成熟的组织路线的方式。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="4c48" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了展示今天的文章，我决定我们需要开发一个真正的应用程序。为了让它成为可能，我花了一些时间寻找免费的HTTP APIs，这时我发现了伟大的<a class="ae ky" href="https://breakingbadapi.com" rel="noopener ugc nofollow" target="_blank">绝命毒师API </a>。</p><p id="d7c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它为我们提供了一系列关于绝命毒师和更好地呼叫索尔电视节目的信息。不过，我们的应用仅限于打破坏角色和它的显著报价。</p><p id="9e30" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就这样，我发现自己面临着最具挑战性的任务。决定应用程序的名称！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="1720" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">破碎的Bapp诞生了</h1><p id="b951" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">不要担心我的营销技巧——我不打算从事那个职业！还有，我向你保证我会尽我所能只在名字里保留“破坏”的部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/515a9d12aa0838dff5d90b1f06145e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/0*agbghXH5L04DM0-R.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">突破Bapp演练</p></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="4d21" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">资源思维</h1><p id="d799" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们已经说过，我们应该围绕我们提供的资源来设计我们的道路。你能想象如果我们谈论一个网站，URL会是什么样子吗？我做了那个练习:</p><ul class=""><li id="f5d5" class="nk nl it lt b lu mn lx mo ma nm me nn mi no mm np nq nr ns bi translated">字符列表:<code class="fe na nb nc nd b">characters</code></li><li id="a061" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">单个字符的详细信息:<code class="fe na nb nc nd b">characters/:character_id</code></li><li id="aada" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">报价清单:<code class="fe na nb nc nd b">quotes</code></li><li id="d2ce" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">报价作者详情:<code class="fe na nb nc nd b">quotes/authors?name=:quote_author_name</code></li></ul><p id="e1a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后一个是最棘手的。也许你想知道为什么<code class="fe na nb nc nd b">name</code>是查询参数而不是路径参数，或者为什么我们不使用引用的作者ID而不是他们的名字。</p><p id="4e10" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要回答这个问题，首先让我向您展示一个从API中检索的报价的JSON对象:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="7f12" class="oc la it nd b gy od oe l of og">{<br/>   "quote_id":1,<br/>   "quote":"I am not in danger, Skyler. I am the danger!",<br/>   "author":"Walter White"<br/>}</span></pre><p id="146a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，我们没有作者的ID，只有它的名字。由于<code class="fe na nb nc nd b">name</code>不是一个可靠的唯一标识符，并且推荐使用path params作为唯一标识符，我们能做的最好的事情就是想象我们正在查询作者的资源。</p><p id="a417" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过这样的设计，我可以教你如何使用查询字符串。</p><p id="6d33" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于那些不是《绝命毒师》粉丝的人来说，值得一提的是，引用作者只不过是这部剧的一个角色。因此，要获得这些信息，我们只需要使用字符细节端点——幸运的是，API允许我们通过名称而不是ID来查找字符。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="5890" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">在Flutter中导航是如何工作的？</h1><p id="2dd5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">导航只不过是转换到一个新的全屏小部件的简单行为，我们称之为页面或屏幕。为此，我们需要将这个新的小部件包装在一个<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>对象中，该对象描述了过渡应该如何发生，并将它推送到一个<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>。默认情况下，有两种方法可以做到这一点。</p><h2 id="14fc" class="oc la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated"><strong class="ak">第一种方法</strong></h2><p id="b5de" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">给<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>一个<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>对象。</p><p id="f533" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们来看看Bapp，这是<code class="fe na nb nc nd b">onTap</code>角色名单的回调:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="7df2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">(亲)极其易学；</p><p id="1e2f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">(Pro)强类型；</p><p id="be2b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">(缺点)如果你需要在应用程序的许多部分导航到同一个屏幕，会导致大量的代码重复；</p><h2 id="c6ad" class="oc la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated"><strong class="ak">第二种方法，又名命名路线</strong></h2><p id="efbe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">给<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>一个路由名和一个通用参数(可选)，它将被传递给一个函数，该函数将这两个参数映射到一个<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>。</p><p id="0f4c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你需要自己写那个函数，作为<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/material/MaterialApp-class.html" rel="noopener ugc nofollow" target="_blank">MaterialApp</a></code>的<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/material/MaterialApp/onGenerateRoute.html" rel="noopener ugc nofollow" target="_blank">onGenerateRoute</a></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="657e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">(缺点)不如第一种方法好学。</p><p id="ed7d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">(Pro)虽然看起来更冗长，但这实际上是推荐的方法，因为我们保持页面的实例化集中，避免了代码重复。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="fe18" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们仔细观察，命名路由方法相对来说更接近于我们试图完成的web任务。唯一的区别是，在web上，我们不需要这个参数对象(<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator/pushNamed.html" rel="noopener ugc nofollow" target="_blank">Navigator.pushNamed</a></code>的第三个参数)，因为我们将能够在路由名称内传递我们需要的每个参数<em class="ms">，或者作为路径参数，或者作为查询参数。</em></p><p id="9360" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们想这样做:<code class="fe na nb nc nd b">Navigator.of(context).pushNamed('characters/${character.id}');</code></p><p id="a6f3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">而不是这个:<code class="fe na nb nc nd b">Navigator.of(context).pushNamed('character-details', arguments: character.id);</code></p><p id="490e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，如果你试图马上这样做，它会让你头疼。在您的<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/material/MaterialApp/onGenerateRoute.html" rel="noopener ugc nofollow" target="_blank">onGenerateRoute</a></code>函数中，您将需要一种方法来通配符化角色的ID，这样<code class="fe na nb nc nd b">characters/11</code>和<code class="fe na nb nc nd b">characters/22</code>将采用相同的路线，只是参数不同。另一个问题是必须剥离和解析问号后面的内容作为查询参数。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="85d3" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated"><a class="ae ky" href="https://pub.dev/packages/fluro#-readme-tab-" rel="noopener ugc nofollow" target="_blank"> Fluro </a>包来救援</h1><p id="e113" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">根据他们的说法(我也倾向于同意)，Fluro是:</p><blockquote class="ou ov ow"><p id="ae79" class="lr ls ms lt b lu mn ju lw lx mo jx lz ox mp mc md oy mq mg mh oz mr mk ml mm im bi translated"><em class="it">最亮、最潮、最酷的Flutter路由器。</em></p></blockquote><p id="a4ae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在几个特征中，我要强调的是:</p><ul class=""><li id="6859" class="nk nl it lt b lu mn lx mo ma nm me nn mi no mm np nq nr ns bi translated">通配符参数匹配</li><li id="e28c" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">Querystring参数解析</li></ul><p id="d4d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们找到我们要找的人了！</p><p id="84af" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为我们的起点，我使用第一种路由方法(没有命名路由)构建了一个版本的Breaking Bapp，从这个版本开始，我们将使用Fluro开发一个优雅的解决方案。</p><p id="ef3c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不要担心我如何进行HTTP调用或者状态管理方法是什么。我设法让事情尽可能简单，这样就不会占用导航和路线的重点。</p><p id="ee08" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了涵盖有多个<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>的场景，我们有一个底部导航菜单结构。</p><p id="810b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我建议你查看一下<a class="ae ky" href="https://github.com/EdsonBueno/breaking_bapp" rel="noopener ugc nofollow" target="_blank"> Breaking Bapp的GitHub库</a>的<code class="fe na nb nc nd b">starting-point</code>分支，并相对熟悉它以获得更好的学习体验。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="f29b" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">逐步迁移到Fluro</h1><h2 id="c0c6" class="oc la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">1.安装氟</h2><p id="24ac" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">本文基于1.7.8版本。</p><p id="8949" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请不要使用更新的版本，直到你完成所有的步骤。我说不出这有多重要。</p><p id="4c58" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://pub.dev/packages/fluro#-installing-tab-" rel="noopener ugc nofollow" target="_blank">https://pub.dev/packages/fluro#-installing-tab-</a></p><h2 id="184b" class="oc la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">2.设置您的路线</h2><p id="b301" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">主Fluro的课叫<code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/documentation/fluro/latest/fluro/FluroRouter-class.html" rel="noopener ugc nofollow" target="_blank">FluroRouter</a></code>。我们将把它用于我们需要做的一切，除了推送页面，因为我们将继续为此使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>。你不需要自己实例化它，因为Fluro已经为我们提供了一个实例作为静态变量，只需通过<code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/documentation/fluro/latest/fluro/FluroRouter/appRouter.html" rel="noopener ugc nofollow" target="_blank">FluroRouter.appRouter</a></code>访问。</p><p id="39c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我们将开始使用一个名为<code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/documentation/fluro/latest/fluro/FluroRouter/define.html" rel="noopener ugc nofollow" target="_blank">define</a></code>的<code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/documentation/fluro/latest/fluro/FluroRouter-class.html" rel="noopener ugc nofollow" target="_blank">FluroRouter</a></code>函数，它的作用是<em class="ms">定义</em>一条路线。它接受三个参数:</p><ul class=""><li id="5642" class="nk nl it lt b lu mn lx mo ma nm me nn mi no mm np nq nr ns bi translated">表示路线路径及其预期的<em class="ms">路径</em>参数的字符串。查询不需要事先指定。</li><li id="4909" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">一个handler对象，用于保存页面的小部件生成器。</li><li id="f36d" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">一个可选的<code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/documentation/fluro/latest/fluro/TransitionType-class.html" rel="noopener ugc nofollow" target="_blank">TransitionType</a></code>，以防你想改变默认的路线过渡。</li></ul><p id="1a28" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我在主函数(<code class="fe na nb nc nd b">main.dart</code>)中完成了所有的路由设置，我建议你也这样做。</p><p id="701a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">仔细阅读下面的要点。我尽力评论你需要知道的一切。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="0ade" class="oc la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">3.将您的路由器连接到您的导航器</h2><p id="2e0d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们有了一个叫做<code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/documentation/fluro/latest/fluro/FluroRouter/appRouter.html" rel="noopener ugc nofollow" target="_blank">FluroRouter.appRouter</a></code>的特殊小家伙，它知道如何处理我们所有的网络状命名路由。但是我们还没有把它插在任何地方。因此，当我们<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator/pushNamed.html" rel="noopener ugc nofollow" target="_blank">Navigator.pushNamed</a></code>某个东西时，它仍然不会使用我们在上一步中刚刚完成的所有设置。</p><p id="6032" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还记得<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/material/MaterialApp/onGenerateRoute.html" rel="noopener ugc nofollow" target="_blank">MaterialApp.onGenerateRoute</a></code>构造函数参数吗？在讨论命名路由时，我们已经简单地讨论过了。我们需要为它提供一个接收推送的路由设置的函数，并使用它来构建一个具体的<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>。猜猜谁有这个？是的，<code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/documentation/fluro/latest/fluro/FluroRouter/appRouter.html" rel="noopener ugc nofollow" target="_blank">FluroRouter.appRouter</a></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="f576" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，每次我们使用我们的<em class="ms">根</em> <code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>导航时，一切都很好。</p><p id="fff5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">“你说的<em class="ms">根</em>导航器是什么意思？”</strong></p><p id="c34c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">默认情况下，在<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/material/MaterialApp-class.html" rel="noopener ugc nofollow" target="_blank">MaterialApp</a></code>中，我们被赋予了一个<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>来推送和弹出我们的页面小部件，这就是我们刚刚与<code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/documentation/fluro/latest/fluro/FluroRouter-class.html" rel="noopener ugc nofollow" target="_blank">FluroRouter</a></code>链接的那个。但是如果你的导航结构比那更复杂，例如如果你使用一个<a class="ae ky" href="https://material.io/components/bottom-navigation/" rel="noopener ugc nofollow" target="_blank">底部导航组件</a>，你可能有不止一个<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>。我们还需要把这些和氟罗联系起来。幸运的是，这是打破巴普的情况！</p><p id="113c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">“如何让Fluro与多个</strong> <code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">Navigator</strong></a></code> <strong class="lt iu">一起工作？”</strong></p><p id="9ba6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">简答</strong>:<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>的构造函数也有一个<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator/onGenerateRoute.html" rel="noopener ugc nofollow" target="_blank">onGenerateRoute</a></code>。只要在代码中实例化一个新的<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>时，给它相同的<code class="fe na nb nc nd b">FluroRouter.appRouter.matchRoute(context, settings.name, routeSettings: settings).route</code>，使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator/initialRoute.html" rel="noopener ugc nofollow" target="_blank">initialRoute</a></code>参数改变它的初始路径，然后跳到我们的第四步。</p><p id="6594" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">长回答</strong>:为此，我要给大家展示一下我在Breaking Bapp的底部导航中是怎么做到的。</p><p id="85b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你还没有关注我的<a class="ae ky" href="https://medium.com/swlh/bottom-navigate-like-the-pros-in-flutter-8a48bdd5fed4" rel="noopener">最新文章</a>，你就不容易明白这是怎么回事了。如果是这样的话，我强烈建议你满足于简短的回答，直接跳到第四步。我向你保证不会有任何损失！</p><p id="5eeb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 3.1。将您的路由器连接到您的附加导航器</strong></p><p id="a490" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的代码有一个名为<code class="fe na nb nc nd b"><a class="ae ky" href="https://github.com/EdsonBueno/breaking_bapp/blob/starting-point/lib/presentation/common/bottom_navigation/bottom_navigation_tab.dart" rel="noopener ugc nofollow" target="_blank">BottomNavigationTab</a></code>的类，它保存了构建应用程序底层导航流的所有依赖项。这包括要在菜单中显示的项目，它应该用于特定选项卡的<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>的<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/GlobalKey-class.html" rel="noopener ugc nofollow" target="_blank">GlobalKey</a></code>，以及每个选项卡的初始页面生成器。<code class="fe na nb nc nd b">initialPageBuilder</code>曾经在我们自己实例化路线时很有用(通过使用第一种导航方法)。但是现在我们使用命名的路径，我们不再喜欢页面生成器，只喜欢路径名，因为Fluro现在正在构建东西。</p><p id="90e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">区别在于:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="a1d3" class="oc la it nd b gy od oe l of og">class BottomNavigationTab {<br/>    const BottomNavigationTab({<br/>        @required this.bottomNavigationBarItem,<br/>        @required this.navigatorKey,<br/>-       @required this.initialPageBuilder,<br/>+       @required this.initialRouteName,<br/>    }) : assert(bottomNavigationBarItem != null),<br/>       assert(navigatorKey != null),<br/>-      assert(initialPageBuilder != null);<br/>+      assert(initialRouteName != null);<br/> <br/>    final BottomNavigationBarItem bottomNavigationBarItem;<br/>    final GlobalKey&lt;NavigatorState&gt; navigatorKey;<br/>-   final WidgetBuilder initialPageBuilder;<br/>+   final String initialRouteName;<br/>}</span></pre><p id="8dd4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于我们刚刚更改了<code class="fe na nb nc nd b">BottomNavigationTab</code>的定义，我们需要确定实例化它的位置:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="00a5" class="oc la it nd b gy od oe l of og">class HomeScreen extends StatefulWidget {<br/>  <a class="ae ky" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  _HomeScreenState createState() =&gt; _HomeScreenState();<br/>}</span><span id="c530" class="oc la it nd b gy pa oe l of og">class _HomeScreenState extends State&lt;HomeScreen&gt; {<br/>  final List&lt;BottomNavigationTab&gt; _bottomNavigationTabs = [<br/>    BottomNavigationTab(<br/>      bottomNavigationBarItem: BottomNavigationBarItem(<br/>        title: const Text('Characters'),<br/>        icon: Icon(Icons.people),<br/>      ),<br/>      navigatorKey: GlobalKey&lt;NavigatorState&gt;(),<br/>-     initialPageBuilder: (_) =&gt; CharacterListPage(),<br/>+     initialRouteName: 'characters',<br/>    ),<br/>    BottomNavigationTab(<br/>      bottomNavigationBarItem: BottomNavigationBarItem(<br/>        title: const Text('Quotes'),<br/>        icon: Icon(Icons.format_quote),<br/>      ),<br/>      navigatorKey: GlobalKey&lt;NavigatorState&gt;(),<br/>-     initialPageBuilder: (_) =&gt; QuoteListPage(),<br/>+     initialRouteName: 'quotes',<br/>    )<br/>  ];</span><span id="125d" class="oc la it nd b gy pa oe l of og"><a class="ae ky" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) =&gt; AdaptiveBottomNavigationScaffold(<br/>        navigationBarItems: _bottomNavigationTabs,<br/>      );<br/>}</span></pre><p id="53e2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还剩下两个地方，都在<code class="fe na nb nc nd b">material_bottom_navigation_scaffold.dart</code>中，因为那是我们子类化和实例化上述<code class="fe na nb nc nd b">BottomNavigationTab</code>的地方。</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="9fae" class="oc la it nd b gy od oe l of og">class _MaterialBottomNavigationTab extends BottomNavigationTab {<br/>  const _MaterialBottomNavigationTab({<br/>    <a class="ae ky" href="http://twitter.com/required" rel="noopener ugc nofollow" target="_blank">@required</a> BottomNavigationBarItem bottomNavigationBarItem,<br/>    <a class="ae ky" href="http://twitter.com/required" rel="noopener ugc nofollow" target="_blank">@required</a> GlobalKey&lt;NavigatorState&gt; navigatorKey,<br/>-   <a class="ae ky" href="http://twitter.com/required" rel="noopener ugc nofollow" target="_blank">@required</a> WidgetBuilder initialPageBuilder,<br/>+   <a class="ae ky" href="http://twitter.com/required" rel="noopener ugc nofollow" target="_blank">@required</a> String initialRouteName,<br/>    <a class="ae ky" href="http://twitter.com/required" rel="noopener ugc nofollow" target="_blank">@required</a> this.subtreeKey,<br/>  })  : assert(bottomNavigationBarItem != null),<br/>        assert(subtreeKey != null),<br/>-       assert(initialPageBuilder != null),<br/>+       assert(initialRouteName != null),<br/>        assert(navigatorKey != null),<br/>        super(<br/>          bottomNavigationBarItem: bottomNavigationBarItem,<br/>          navigatorKey: navigatorKey,<br/>-         initialPageBuilder: initialPageBuilder,<br/>+         initialRouteName: initialRouteName,<br/>        );<br/> <br/>  final GlobalKey subtreeKey;<br/>}</span><span id="752b" class="oc la it nd b gy pa oe l of og">void _initMaterialNavigationBarItems() {<br/>  materialNavigationBarItems.addAll(<br/>    widget.navigationBarItems<br/>        .map(<br/>          (barItem) =&gt; _MaterialBottomNavigationTab(<br/>            bottomNavigationBarItem: barItem.bottomNavigationBarItem,<br/>            navigatorKey: barItem.navigatorKey,<br/>            subtreeKey: GlobalKey(),<br/>-           initialPageBuilder: barItem.initialPageBuilder,<br/>+           initialRouteName: barItem.initialRouteName,<br/>          ),<br/>        )<br/>        .toList(),<br/>  );<br/>}</span></pre><p id="67e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，是时候确保我们额外的导航员将其路线生成委托给Fluro，并使用最新的<code class="fe na nb nc nd b">BottomNavigationTab</code>的<code class="fe na nb nc nd b">initialRouteName</code>。我在Android和iOS上使用了不同的底部导航菜单，所以我需要在两个文件中进行更改:</p><ol class=""><li id="ecbb" class="nk nl it lt b lu mn lx mo ma nm me nn mi no mm pb nq nr ns bi translated"><code class="fe na nb nc nd b">material_bottom_navigation_scaffold.dart</code></li></ol><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="9359" class="oc la it nd b gy od oe l of og">Widget _buildPageFlow(<br/>  BuildContext context,<br/>  int tabIndex,<br/>  _MaterialBottomNavigationTab item,<br/>) {<br/>  final isCurrentlySelected = tabIndex == widget.selectedIndex;<br/> <br/>  // We should build the tab content only if it was already built or<br/>  // if it is currently selected.<br/>  _shouldBuildTab[tabIndex] =<br/>      isCurrentlySelected || _shouldBuildTab[tabIndex];<br/> <br/>  final Widget view = FadeTransition(<br/>    opacity: _animationControllers[tabIndex].drive(<br/>      CurveTween(curve: Curves.fastOutSlowIn),<br/>    ),<br/>    child: KeyedSubtree(<br/>      key: item.subtreeKey,<br/>      child: _shouldBuildTab[tabIndex]<br/>          ? Navigator(<br/>              // The key enables us to access the Navigator's state inside the<br/>              // onWillPop callback and for emptying its stack when a tab is<br/>              // re-selected. That is why a GlobalKey is needed instead of<br/>              // a simpler ValueKey.<br/>              key: item.navigatorKey,<br/>-             // Since this isn't the purpose of this sample, we're not using<br/>-             // named routes. Because of that, the onGenerateRoute callback<br/>-             // will be called only for the initial route.<br/>-             onGenerateRoute: (settings) =&gt; MaterialPageRoute(<br/>-               settings: settings,<br/>-               builder: item.initialPageBuilder,<br/>-             ),<br/>+             initialRoute: item.initialRouteName,<br/>+             // RouteFactory is nothing but an alias of a function that takes<br/>+             // in a RouteSettings and returns a Route&lt;dynamic&gt;, which is<br/>+             // the type of the onGenerateRoute parameter.<br/>+             // We registered one of these in our main.dart file.<br/>+             onGenerateRoute: FluroRouter.appRouter<br/>+                 .matchRoute(context, settings.name, routeSettings: settings)<br/>+                 .route,<br/>            )<br/>          : Container(),<br/>    ),<br/>  );<br/> <br/>  if (tabIndex == widget.selectedIndex) {<br/>    _animationControllers[tabIndex].forward();<br/>    return view;<br/>  } else {<br/>    _animationControllers[tabIndex].reverse();<br/>    if (_animationControllers[tabIndex].isAnimating) {<br/>      return IgnorePointer(child: view);<br/>    }<br/>    return Offstage(child: view);<br/>  }<br/>}</span></pre><p id="28ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">2.<code class="fe na nb nc nd b">cupertino_bottom_navigation_scaffold.dart</code></p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="7321" class="oc la it nd b gy od oe l of og">Widget build(BuildContext context) =&gt; CupertinoTabScaffold(<br/>      // As we're managing the selected index outside, there's no need<br/>      // to make this Widget stateful. We just need pass the selectedIndex to<br/>      // the controller every time the widget is rebuilt.<br/>      controller: CupertinoTabController(initialIndex: selectedIndex),<br/>      tabBar: CupertinoTabBar(<br/>        items: navigationBarItems<br/>            .map(<br/>              (item) =&gt; item.bottomNavigationBarItem,<br/>            )<br/>            .toList(),<br/>        onTap: onItemSelected,<br/>      ),<br/>      tabBuilder: (context, index) {<br/>        final barItem = navigationBarItems[index];<br/>        return CupertinoTabView(<br/>          navigatorKey: barItem.navigatorKey,<br/>-         onGenerateRoute: (settings) =&gt; CupertinoPageRoute(<br/>-           settings: settings,<br/>-           builder: barItem.initialPageBuilder,<br/>-         ),<br/>+         onGenerateRoute: (settings) {<br/>+           // The [Navigator] widget has a initialRoute parameter, which<br/>+           // enables us to define which route it should push as the initial<br/>+           // one. See [MaterialBottomNavigationScaffold] for more details.<br/>+           //<br/>+           // The problem is that in the Cupertino version, we're not<br/>+           // instantiating the [Navigator] ourselves, instead we're<br/>+           // delegating it to the CupertinoTabView, which doesn't provides<br/>+           // us with a way to set the initialRoute name. The best<br/>+           // alternative I could find is to "change" the route's name of<br/>+           // our RouteSettings to our BottomNavigationTab's initialRouteName<br/>+           // when the onGenerateRoute is being executed for the initial<br/>+           // route.<br/>+           var routeSettings = settings;<br/>+           if (settings.name == '/') {<br/>+             routeSettings =<br/>+               settings.copyWith(name: barItem.initialRouteName);<br/>+             );<br/>+           } <br/>+           return FluroRouter.appRouter<br/>+               .matchRoute(<br/>+                 context,<br/>+                 routeSettings.name,<br/>+                 routeSettings: routeSettings,<br/>+               )<br/>+               .route;<br/>+         },<br/>        );<br/>      },<br/>    );</span></pre><h2 id="2e48" class="oc la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">4.航行</h2><p id="f33b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">到目前为止，我们所做的一切都是为了准备处理任何传入的类似网络的命名路由，但我们仍然没有使用它们。我们需要停止使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator/push.html" rel="noopener ugc nofollow" target="_blank">Navigator.push</a></code>，开始使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/Navigator/pushNamed.html" rel="noopener ugc nofollow" target="_blank">Navigator.pushNamed</a></code>。有两个地方可以改变这种情况:</p><ul class=""><li id="3276" class="nk nl it lt b lu mn lx mo ma nm me nn mi no mm np nq nr ns bi translated">当选择列表中的字符时。</li></ul><p id="9905" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe na nb nc nd b">character_list_page.dart</code></p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="042a" class="oc la it nd b gy od oe l of og">- Navigator.push(<br/>-   context,<br/>-   MaterialPageRoute(<br/>-     builder: (context) =&gt; CharacterDetailPage(<br/>-      id: character.id,<br/>-     ),<br/>-   ),<br/>+ Navigator.of(context).pushNamed(<br/>+   'characters/${character.id}',<br/>  );</span></pre><ul class=""><li id="8f4d" class="nk nl it lt b lu mn lx mo ma nm me nn mi no mm np nq nr ns bi translated">在列表中选择引用的作者时。</li></ul><p id="1f84" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe na nb nc nd b">quote_list_page.dart</code></p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="55a0" class="oc la it nd b gy od oe l of og">Navigator.of(<br/>    context,<br/>    rootNavigator: true,<br/>- ).push(<br/>-   MaterialPageRoute(<br/>-     fullscreenDialog: true,<br/>-     builder: (context) =&gt; CharacterDetailPage(<br/>-       name: quote.authorName,<br/>-     ),<br/>-   ),<br/>+ ).pushNamed(<br/>+   'quotes/authors?name=${quote.authorName}',<br/>  );</span></pre><p id="95d5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们都完了！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="0100" class="oc la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">边注</h2><p id="aa82" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我曾经读到有人认为，使用Fluro，我们无法将复杂的对象直接从一个页面传递到另一个页面。虽然我们可以找到晦涩的方法来做到这一点，但我不建议这样做。</p><p id="0ce2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我坚信我们不应该传递复杂的物体。我喜欢的另一种方法是给对象一个<code class="fe na nb nc nd b">id</code>并将它存储在数据层中。这样，我们只能在页面之间传递它的<code class="fe na nb nc nd b">id</code>。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="a3d2" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">奖金</h1><p id="1cf1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可能已经注意到，代码中的路由名称是重复的。这根本不是推荐的做法。它的目的是提高文章的可读性，但我不希望你在其他地方这样做。关于如何提取它的灵感，请查看<code class="fe na nb nc nd b">master</code>分支。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="5cb8" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">有用的链接</h1><ul class=""><li id="7ed0" class="nk nl it lt b lu lv lx ly ma pc me pd mi pe mm np nq nr ns bi translated"><a class="ae ky" href="https://github.com/EdsonBueno/breaking_bapp" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></li><li id="2b54" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated"><a class="ae ky" href="https://medium.com/swlh/bottom-navigate-like-the-pros-in-flutter-8a48bdd5fed4" rel="noopener">像专业玩家一样在底部导航</a></li><li id="46a1" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated"><a class="ae ky" href="https://breakingbadapi.com" rel="noopener ugc nofollow" target="_blank">绝命毒师API </a></li><li id="ea34" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated"><a class="ae ky" href="https://pub.dev/packages/fluro" rel="noopener ugc nofollow" target="_blank">氟包</a></li><li id="7e38" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated"><a class="ae ky" href="https://restfulapi.net/resource-naming/" rel="noopener ugc nofollow" target="_blank">休息资源命名</a></li></ul></div></div>    
</body>
</html>