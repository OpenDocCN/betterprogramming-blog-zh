<html>
<head>
<title>Here’s Why I’m Replacing html2canvas With html-to-image in Our React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这就是我在React应用中用html-to-image替换html2canvas的原因</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/heres-why-i-m-replacing-html2canvas-with-html-to-image-in-our-react-app-d8da0b85eadf?source=collection_archive---------1-----------------------#2021-04-20">https://betterprogramming.pub/heres-why-i-m-replacing-html2canvas-with-html-to-image-in-our-react-app-d8da0b85eadf?source=collection_archive---------1-----------------------#2021-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dea1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将React组件捕获为图像的两个库的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/400bf6882d5a6146059be8375a05d185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpyrgqwMjfclV2oN1U2VIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢克·切瑟在<a class="ae ky" href="https://unsplash.com/s/photos/graphs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="b517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近<a class="ae ky" href="https://javascript.plainenglish.io/export-react-components-as-images-15168b73b0eb" rel="noopener ugc nofollow" target="_blank">写了一篇关于将React组件捕获为图像的文章</a>，并在Reddit上分享了这篇文章。一位redditor 评论说，虽然这个库很强大，但他们使用了另一个他们认为性能更好的库:</p><blockquote class="lv lw lx"><p id="cb41" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“我最终使用的一个类似的库是<a class="ae ky" href="https://www.npmjs.com/package/html-to-image" rel="noopener ugc nofollow" target="_blank"> html-to-image </a>。快得多，不仅可以将组件转换为画布，还可以直接转换为png/blob/svg。”</p></blockquote><p id="a1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在应用程序的另一部分使用<code class="fe mc md me mf b"><a class="ae ky" href="https://www.npmjs.com/package/html2canvas" rel="noopener ugc nofollow" target="_blank">html2canvas</a></code>,我们需要下载多个可视化的独立图像，压缩它们，然后下载它们。它工作得很好，但我不得不说性能会变得相当慢。我从未听说过<code class="fe mc md me mf b">html-to-image</code>，但我想我应该去看看！</p><p id="8f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在试用之后，我认为它是<code class="fe mc md me mf b">html2canvas</code>的一个很好的轻量级替代品。在本文中，我们将介绍它是如何工作的，然后创建一个React应用程序来并排比较这两个库。</p><p id="5d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，安装软件包。与<code class="fe mc md me mf b">html2canvas</code>不同，它没有依赖关系:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="5daf" class="mk ml it mf b gy mm mn l mo mp">npm i html-to-image</span></pre><p id="ead0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在组件中导入它:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="e8c5" class="mk ml it mf b gy mm mn l mo mp">import * as htmlToImage from 'html-to-image';</span></pre><p id="b0c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以编写一个函数，从React应用程序中获取一个DOM元素，并将其转换为您指定的格式。为了简洁起见，我们将只在我们将要构建的应用程序中使用<code class="fe mc md me mf b">png</code>格式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在NPM文档中，提供的示例使用<code class="fe mc md me mf b">download</code>来处理下载。但是在本文中，我们将使用上一篇文章中的<code class="fe mc md me mf b">saveAs</code>函数。</p><p id="89a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在撰写本文时，下面是我在比较这两个库时使用的三个关键点(KPI)的值:解压缩大小、文件总数和依赖项。</p><h2 id="acb3" class="mk ml it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">html到图像</h2><ul class=""><li id="ac76" class="nj nk it lb b lc nl lf nm li nn lm no lq np lu nq nr ns nt bi translated">解压缩后的大小:183 kB</li><li id="edc8" class="nj nk it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">文件总数:66</li><li id="8cdd" class="nj nk it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">依赖项:0</li></ul><h2 id="1074" class="mk ml it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">html2canvas</h2><ul class=""><li id="a1d6" class="nj nk it lb b lc nl lf nm li nn lm no lq np lu nq nr ns nt bi translated">未封装的大小:2.96 MB</li><li id="8df3" class="nj nk it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">文件总数:476</li><li id="a1a7" class="nj nk it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">依赖关系:1</li></ul><p id="000f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe mc md me mf b">html2canvas</code>在解压缩大小(大约大16倍)和文件总数(大约大7倍)方面要大得多。它也有一个依赖项，而<code class="fe mc md me mf b">html-to-image</code>没有。一个依赖性并不值得注意，但它比你需要担心的<code class="fe mc md me mf b">html-to-image</code>多了一个依赖性。</p><p id="ee77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">较小的尺寸和缺乏依赖性对于试图保持他们的包较小并且没有无关库的开发人员来说是个好兆头。更小的捆绑包意味着更快的反应应用，更少的库意味着更少的潜在兼容性问题。</p><p id="2776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">撇开规格不谈，就实际性能而言，这两个库如何比较？<code class="fe mc md me mf b">html-to-image</code>真的是更快的库吗？为了自己看，让我们构建一个React应用程序，并排比较我们的库。首先，安装<code class="fe mc md me mf b">html2canvas</code>:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="b5bc" class="mk ml it mf b gy mm mn l mo mp">npm i html2canvas</span></pre><p id="2eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们为<code class="fe mc md me mf b">html2canvas</code>创建一个组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用<code class="fe mc md me mf b"><a class="ae ky" href="https://stackoverflow.com/questions/313893/how-to-measure-time-taken-by-a-function-to-execute" rel="noopener ugc nofollow" target="_blank">performance.now()</a></code>在函数开始时记录时间，然后在函数结束时再次记录时间。开始时间和结束时间之差表示函数完成任务所需的时间，以毫秒为单位。我们在<code class="fe mc md me mf b">html-to-image</code>组件中实现了类似的逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e5d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这两个组件，<code class="fe mc md me mf b">saveAs</code>是在<a class="ae ky" href="https://javascript.plainenglish.io/export-react-components-as-images-15168b73b0eb" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中使用的函数，用于下载我们新创建的图像。为简洁起见，我将不包括它(或<code class="fe mc md me mf b">Visualization.js</code>)的代码。然而，本文的所有代码都可以在<a class="ae ky" href="https://github.com/macro6461/html-to-image-demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="b442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您将需要种子数据。<code class="fe mc md me mf b">visualizations.js</code>是在我们的应用程序中可以看到的<code class="fe mc md me mf b">Visualization</code>对象的数组。见下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ab0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在设置了在各自的组件中捕获和下载React组件的函数之后，我能够看到<code class="fe mc md me mf b">html-to-image</code>实际上是任务的更快的库。见下文:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/f6267246b449308a06bef396754a9f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rou3fKx6nzepq-6nnsWzQQ.png"/></div></div></figure><p id="9cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">肉眼几乎察觉不到性能上的差异，但是如果你看看两个库处理和下载五个可视化效果的毫秒数，<code class="fe mc md me mf b">html2canvas</code>要慢57倍。事实上，在连续进行十次这种测试后，差距就更加明显了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a8f5c1c47eb1403550fea23a2999aee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oama6X-xHYD9AXJWCMbIrA.png"/></div></div></figure><p id="4a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">性能的平均差异是86.3985毫秒。这意味着平均而言，<code class="fe mc md me mf b">html-to-image</code>比<code class="fe mc md me mf b">html2canvas</code>快了将近71倍！</p><p id="6ce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">注意:虽然数据集只包含10个比较，但是两个库确实在相同的应用程序中使用相同的可视化在相同的时间段内执行。请随意进行更多的比较并分享您的结果！</em></p><p id="c307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么会这样？一个很大的原因是<code class="fe mc md me mf b">html-to-image</code>不需要先将元素转换成画布。从一个元素生成一个画布需要时间——这个时间<code class="fe mc md me mf b">html-to-image</code>不会发生。<code class="fe mc md me mf b">html-to-image</code>还可以通过其内置的<code class="fe mc md me mf b"><a class="ae ky" href="https://www.npmjs.com/package/html-to-image#toCanvas" rel="noopener ugc nofollow" target="_blank">toCanvas(</a>)</code>函数，灵活地将捕获的DOM元素转换成画布。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="73ca" class="oi ml it bd ms oj ok ol mv om on oo my jz op ka nb kc oq kd ne kf or kg nh os bi translated">摘要</h1><p id="8d43" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li ot lk ll lm ou lo lp lq ov ls lt lu im bi translated">虽然<code class="fe mc md me mf b">html2canvas</code>是一个健壮的库，但如果只是简单地将React组件导出为图像，可能会有些矫枉过正。与<code class="fe mc md me mf b">html-to-image</code>相比，它的安装量更大，并且需要依赖第三方。撇开规格不谈，<code class="fe mc md me mf b">html2canvas</code>的运行时间比<code class="fe mc md me mf b">html-to-image</code>慢(71倍)。我计划在我们的SaaS中用<code class="fe mc md me mf b">html-to-image</code>替换<code class="fe mc md me mf b">html2canvas</code>(等待团队审查和批准)，因为它能完成我们需要的，而且速度更快。</p><p id="a076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你对提到的两个图书馆有不同的体验吗？你更喜欢哪个，为什么？请在评论中告诉我你的想法！</p><p id="ae7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文附带的代码可以在<a class="ae ky" href="https://github.com/macro6461/html-to-image-demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="653d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此  <em class="ly">将你的免费中级会员升级为付费会员，每月只需5美元，你就可以获得数以千计作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="3916" class="oi ml it bd ms oj ow ol mv om ox oo my jz oy ka nb kc oz kd ne kf pa kg nh os bi translated">参考</h1><div class="pb pc gp gr pd pe"><a href="https://github.com/macro6461/html-to-image-demo" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">macro6461/html到图像演示</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">在GitHub上创建一个帐户，为macro6461/html-to-image-demo开发做出贡献。</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://javascript.plainenglish.io/export-react-components-as-images-15168b73b0eb" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">现在可以将React组件导出为图像</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">使用html2canvas</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pn l"><div class="pt l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://www.npmjs.com/package/html-to-image" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">html到图像</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">使用HTML5 canvas和SVG从DOM节点生成图像。</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">www.npmjs.com</p></div></div><div class="pn l"><div class="pu l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://stackoverflow.com/questions/313893/how-to-measure-time-taken-by-a-function-to-execute" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">如何测量函数执行所用的时间</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">我需要得到以毫秒为单位的执行时间。我最初是在2008年提出这个问题的。公认的答案是…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">stackoverflow.com</p></div></div><div class="pn l"><div class="pv l pp pq pr pn ps ks pe"/></div></div></a></div></div></div>    
</body>
</html>