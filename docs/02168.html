<html>
<head>
<title>Scalable Concurrency — Meet Non-Blocking I/O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可扩展的并发性—满足非阻塞I/O</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scalable-concurrency-meet-non-blocking-i-o-edb6b39c59d7?source=collection_archive---------13-----------------------#2019-11-11">https://betterprogramming.pub/scalable-concurrency-meet-non-blocking-i-o-edb6b39c59d7?source=collection_archive---------13-----------------------#2019-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们如何实施非阻塞I/O来提高应用程序的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d700ce162e369ddbee2cb33fd7e2849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVeTYeah-5D6K_PnZgwR5Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@vorosbenisop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">本杰明·沃罗斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/flow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="34df" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为什么非阻塞IO更具可扩展性？</h1><p id="6e22" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在几乎所有的现代web应用程序中，我们都有大量的I/O。我们与数据库对话，请求记录或插入/更新它们。更多的时候，我们从硬盘上访问一些文件，这也是一种I/O操作。</p><p id="3a24" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们正在与不同的第三方网络服务，如OAuth集成或其他东西。如今，许多web应用程序也作为微服务运行，它们必须通过HTTP请求与同一应用程序的其他部分进行对话。</p><p id="c78e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你用<a class="ae ky" href="https://www.ruby-lang.org/en/" rel="noopener ugc nofollow" target="_blank"> Ruby </a>、<a class="ae ky" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>或许多其他语言编写你的web应用程序，所有这些与I/O相关的任务在默认情况下都是阻塞的，这意味着进程会一直等到收到响应，然后继续执行程序。</p><p id="8256" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">另一方面，Node.js [1]默认使用非阻塞I/O。因此，流程可以继续在其他地方工作，并在请求完成时执行回调或承诺。</p><p id="a23e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这使得操作系统可以充分利用一个CPU内核。但是，非阻塞编程模型在其他编程语言中也是可能的吗？</p><p id="6416" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">是的，它是！在这篇博文中，我们将讨论如何利用(几乎)非阻塞I/O在Ruby中编写一个本地事件循环，然后看看如何改进这种设计。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9a81" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">原生实现</strong></h1><p id="e87f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">首先，让我们来看看一个正在工作的本机实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5271" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在讨论如何改进这个设计之前，让我们先简单讨论一下<code class="fe nb nc nd ne b">IO.select</code>方法，因为这是我们事件循环的核心。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b3a5" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak"> IO.select </strong></h1><p id="51c7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">正如注释中提到的，这种方法是跨平台的，可以在运行程序的任何地方使用。</p><p id="bea7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">它采用的第一个参数是程序想要读取的I/O描述符数组——文件描述符、Unix套接字或类似的东西。</p><p id="c2f6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">第二个数组也是一个I/O描述符数组，但这次是用于可写连接的。</p><p id="6553" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">第三个数组是一个错误数组。</p><p id="2dfb" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后，最后一个参数是超时。这是方法阻塞的最长时间。因此，在上面的例子中，我们可以说一个节拍至少是10 ms，这取决于数据处理所花费的时间。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7182" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">朴素事件循环的设计探讨</strong></h1><p id="b4de" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当我们看一看这段代码时，缺点是很明显的。并发性带来的复杂性与业务逻辑纠缠在一起，很难分离。</p><p id="02da" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">事件循环知道我们的业务逻辑，因为它马上调用方法。我们可以在处理所有读/写事件的寄存器的帮助下改进这一点。</p><p id="806e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">寄存器可以利用一个简单的散列和两个键<code class="fe nb nc nd ne b">read</code>和<code class="fe nb nc nd ne b">write</code>，并在那里保存回调。在Ruby中，回调可以是任何块、进程或lambdas。同样，一个简单的实现可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3ac6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，我们已经将业务逻辑从并发逻辑中分离出来。但是，这仍然会导致一种回调地狱。</p><p id="0825" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">JavaScript曾经有过很多这样的问题，但它通过承诺和最近的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步等待</a>特性解决了这个问题。这样，您可以编写并发运行的顺序代码。</p><p id="8bc5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">尽管如此，我们在这个设计中还有其他缺点。它仍然使用一组固定的描述符，我们没有地方在运行时配置它。此外，每一个回调都会得到每一个读取事件的通知，尽管我们可能不希望这样。</p><p id="a615" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们如何改进呢？符合反应器模式。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="af6c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">反应堆模式</strong></h1><p id="3baf" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Reactor_pattern" rel="noopener ugc nofollow" target="_blank">反应器模式</a>是大多数事件循环的基础。它将应用程序逻辑与交换实现完全分离，因此使代码更易于维护和重用。</p><p id="5fea" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">它由两个主要部分组成:一个事件多路复用器和一个调度器，并与另外两个部分——资源和请求处理程序——一起工作。</p><p id="5faa" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">反应器使用单线程事件循环，在事件多路复用器中注册资源，并在事件触发后分派给回调。</p><p id="450f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">正如我们在示例中看到的，这样就不需要阻塞I/O，因此进程可以最大限度地利用CPU内核。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e6d2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">实现</strong></h1><p id="828e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Ruby中著名的实现有<a class="ae ky" href="https://github.com/eventmachine/eventmachine" rel="noopener ugc nofollow" target="_blank"> EventMachine </a>、<a class="ae ky" href="https://celluloid.io/" rel="noopener ugc nofollow" target="_blank">赛璐珞</a>和<a class="ae ky" href="https://github.com/socketry/async" rel="noopener ugc nofollow" target="_blank"> async </a>。Python也有——至少有一个——非常好的实现，即<a class="ae ky" href="https://twistedmatrix.com/" rel="noopener ugc nofollow" target="_blank"> Twisted </a>。PHP有<a class="ae ky" href="https://reactphp.org/" rel="noopener ugc nofollow" target="_blank"> ReactPHP </a>，我很确定几乎所有其他语言也有一些很好的实现。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f0ab" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">缺点</strong></h1><p id="d368" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">和其他任何东西一样，反应器也有一些缺点，你必须意识到这些缺点，以做出一个好的决定，使用这种模式对你的用例是否有意义。</p><p id="6b7a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">主要的缺点是，如果其中一个回调函数很贪婪，并且占用了大量的时间，那么它将阻塞所有的回调函数，直到它结束。</p><p id="c1b8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">本质上，一个反应器是<em class="nf">类型的</em>协作并发。如上所述，反应器是单线程的，如果CPU在一次回调中被充分利用，那么其他的事情都必须等待。</p><p id="ea57" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">另一个限制是反应器模式很难调试，因为逻辑流程不是程序运行的方式。这也给开发人员带来了额外的麻烦。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="473d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">从这里开始</strong></h1><p id="572d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">对于并发I/O来说，反应器模式是最好的吗？</p><p id="664c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">实际上，不，仍然有改进的方法。如上所述，传统的反应器与解复用器同步调度事件，并且必须等待回调完成。我们也可以用<a class="ae ky" href="https://en.wikipedia.org/wiki/Proactor_pattern" rel="noopener ugc nofollow" target="_blank">前摄器模式来实现这种异步。</a></p><p id="20f9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您仍然需要更高的性能，请使用硬件！在某些时候，这是你最好的选择。如果你需要这样做，那么微服务架构就会派上用场，因为你可以独立地扩展应用程序的小部分。</p><p id="0246" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">[1] Node.js只是一个例子，因为这是使用非阻塞I/O作为默认的最常用的平台。</p></div></div>    
</body>
</html>