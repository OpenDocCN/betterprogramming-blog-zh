<html>
<head>
<title>Configuring Scheduled Notifications in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中配置预定通知</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scheduled-notifications-in-android-2055356fb4f5?source=collection_archive---------3-----------------------#2022-03-08">https://betterprogramming.pub/scheduled-notifications-in-android-2055356fb4f5?source=collection_archive---------3-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c7d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为Android 12及更高版本准备好您的应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fb3dd1b14470d9471aeecbe633d8408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ifxU0tAEvoVweigR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@synkevych?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Roman Synkevych </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="369c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用android中的警报管理器来实现预定通知。除此之外，我们还将探索android系统在通知和警报方面的行为变化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad91" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安排警报</h1><p id="e15f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从调度警报开始，<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager" rel="noopener ugc nofollow" target="_blank">AlarmManager</a></code>类帮助我们执行应用程序范围之外的基于时间的操作。假设您可以安排一个闹钟，提醒用户在一天中的特定时间服药。</p><p id="8ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以按选定的时间间隔安排重复提醒。这在各种情况下都很方便，比如提醒用户吃药或每隔一段时间补充水分。</p><h2 id="e779" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">一次性警报</h2><p id="9437" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从简单的一次性(非重复)警报开始。要设置警报，首先我们需要创建如下所示的<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager" rel="noopener ugc nofollow" target="_blank">AlarmManager</a></code>类实例:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="f36f" class="nd md it nc b gy nt nu l nv nw">private var alarmMgr: AlarmManager? = null</span><span id="df9b" class="nd md it nc b gy nx nu l nv nw">alarmMgr = context.getSystemService(Context.ALARM_SERVICE) as? AlarmManager?</span></pre><p id="54d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要创建一个调用<code class="fe mz na nb nc b">BroadcastReceiver</code>的待定意图，在这里我们可以执行期望的操作，比如在我们的例子中向用户显示通知。现在，让我们创建一个简单的名为<code class="fe mz na nb nc b">AlarmReceiver</code>的<code class="fe mz na nb nc b">BroadcastReceiver</code>，如下所示:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="2801" class="nd md it nc b gy nt nu l nv nw">class <strong class="nc iu">AlarmReceiver</strong> : BroadcastReceiver() {<br/><br/>    override fun onReceive(p0: Context?, p1: Intent?) {<br/>        <em class="ny">TODO</em>("Not yet implemented")<br/>    }<br/>    <br/>}</span></pre><p id="b843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候创建待定意图来触发<code class="fe mz na nb nc b"><strong class="lb iu">AlarmReceiver</strong></code> <strong class="lb iu">。</strong>看一看:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="e6c5" class="nd md it nc b gy nt nu l nv nw">val alarmIntent = Intent(this, <strong class="nc iu">AlarmReceiver</strong>::class.<em class="ny">java</em>)<br/>val pendingIntent = <strong class="nc iu">PendingIntent.getBroadcast</strong>(<br/>    context,<br/>    requestCode,<br/>    alarmIntent,<br/>    PendingIntent.<em class="ny">FLAG_UPDATE_CURRENT</em><br/>)</span></pre><p id="cd9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，是时候设置闹钟了。为此，我们需要三样东西，警报类型、以毫秒为单位的触发时间和未决意图。后两种大多不言自明，而对于报警类型，<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager" rel="noopener ugc nofollow" target="_blank">AlarmManager</a></code>提供了四种类型:</p><ul class=""><li id="4352" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager#ELAPSED_REALTIME" rel="noopener ugc nofollow" target="_blank">ELAPSED_REALTIME</a></code>—根据设备启动后的时间触发待定意向，但不唤醒设备。经过的时间包括设备睡眠期间的任何时间。</li><li id="b537" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager#ELAPSED_REALTIME_WAKEUP" rel="noopener ugc nofollow" target="_blank">ELAPSED_REALTIME_WAKEUP</a></code>—唤醒设备，并在设备启动后经过给定时间后触发待定意向。</li><li id="412b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager#RTC" rel="noopener ugc nofollow" target="_blank">RTC</a></code>—在给定时间触发未决意图，但不唤醒设备。</li><li id="73a6" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager#RTC_WAKEUP" rel="noopener ugc nofollow" target="_blank">RTC_WAKEUP</a></code>—在给定时间唤醒设备以调用未决意向。</li></ul><p id="38ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们设置一个一分钟后触发的闹钟。</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="86be" class="nd md it nc b gy nt nu l nv nw">alarmMgr?.<strong class="nc iu">set</strong>(<br/>        AlarmManager.ELAPSED_REALTIME_WAKEUP,<br/>        <strong class="nc iu">SystemClock.elapsedRealtime() + 60 * 1000</strong>,<br/>        alarmIntent<br/>)</span></pre><h2 id="9b5f" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">重复报警</h2><p id="1310" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">安排重复提醒与一次性提醒非常相似。唯一的区别是提及警报之间的间隔，并使用<code class="fe mz na nb nc b">setRepeating</code>而不是<code class="fe mz na nb nc b">set</code>。看一看:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="5db8" class="nd md it nc b gy nt nu l nv nw">alarmMgr?.<strong class="nc iu">setRepeating</strong>(<br/>        AlarmManager.RTC_WAKEUP,<br/>        <strong class="nc iu">SystemClock.elapsedRealtime() + 60 * 1000</strong>,,<br/>        <strong class="nc iu">1000 * 60 * 15,</strong><br/>        alarmIntent<br/>)</span></pre><p id="6f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面这段代码在一分钟后触发警报，并每隔15分钟重复一次警报。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9629" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">取消警报</h1><p id="5731" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在重复报警的情况下，取消报警是一个至关重要的功能。假设如果用户已经完成了这种药物的疗程，他不再需要提醒，那么在重复提醒的情况下，给用户一个取消选项是很重要的。</p><p id="b542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">取消任何警报非常简单，您需要调用cancel函数并传递我们不想再触发的未决意图。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="3d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b">getService</code>函数，我们可以获得我们不再想要触发的未决意图，如果未决意图不存在，这可能是<code class="fe mz na nb nc b">null</code>。请求代码对于确定正确的待定意向至关重要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f1ca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">计划通知</h1><p id="e8e7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经完成了闹钟的安排，系统将会在指定的时间触发<code class="fe mz na nb nc b">AlarmReceiver</code>，下一个任务是触发来自<code class="fe mz na nb nc b">BroadcastReceiver</code>的通知。</p><p id="84a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过创建待定意向时使用的意向来传递要在通知中显示的内容。然后在<code class="fe mz na nb nc b">onReceive</code>函数中，我们从参数中的意图中提取数据。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb2a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目标SDK — 31</h1><p id="9ba2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果应用针对android 12，那么开发者需要明确地处理一些情况，让我们开始<code class="fe mz na nb nc b">setExact</code>警报。</p><h2 id="8208" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">设置准确的警报类型</h2><p id="3392" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该系统会在未来某个精确的时刻触发精确的警报。如果目标是android 12，那么开发者需要在使用它们之前检查应用程序是否有“警报和提醒”权限，否则它会抛出<code class="fe mz na nb nc b">SecurityException</code>。</p><p id="e2f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为第一步，我们需要在应用程序标签内的android清单文件中声明<code class="fe mz na nb nc b">SCHEDULE_EXACT_ALARM</code> <strong class="lb iu"> </strong>权限。</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="9212" class="nd md it nc b gy nt nu l nv nw"><strong class="nc iu">&lt;uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM"/&gt;</strong></span></pre><p id="25bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要检查用户是否已经授予应用程序权限，为此我们需要检查两个条件:</p><ol class=""><li id="4ed2" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu op of og oh bi translated">如果OS版本是Android 12以上。</li><li id="16df" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu op of og oh bi translated">如果应用程序可以从报警管理器通过<code class="fe mz na nb nc b">canScheduleExactAlarms</code>访问。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="3cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">张贴我们使用<code class="fe mz na nb nc b">setExact</code>警报代替<code class="fe mz na nb nc b">set</code>，如下所示:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="7c37" class="nd md it nc b gy nt nu l nv nw">alarmMgr?.<strong class="nc iu">setExact</strong>(<br/>        AlarmManager.ELAPSED_REALTIME_WAKEUP,<br/>        SystemClock.elapsedRealtime() + 60 * 2000,<br/>        alarmIntent<br/>)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5a51" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">准确和不准确的警报</h1><p id="5734" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于不精确的警报，系统不能保证在精确的时间点发出警报。当它认为对电池最有效时，它会发出警报，通常它会在那个时候收集所有不准确的警报，并触发它们一次以保存电池健康。</p><p id="4b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Android 12和更高版本中，<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager#set(int,%20long,%20android.app.PendingIntent)" rel="noopener ugc nofollow" target="_blank">set()</a></code>、<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager#setInexactRepeating(int,%20long,%20long,%20android.app.PendingIntent)" rel="noopener ugc nofollow" target="_blank">setInexactRepeating()</a></code>或<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager#setAndAllowWhileIdle(int,%20long,%20android.app.PendingIntent)" rel="noopener ugc nofollow" target="_blank">setAndAllowWhileIdle()</a></code>可以在触发时间的60分钟内发出警报，除非有任何电池问题。如果要执行的任务优先级不高，最好使用不准确的警报。</p><p id="1555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于准确的警报，他们主要关注的是在准确的时间发出警报，而不考虑系统的健康状况。<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/android/app/AlarmManager#setExactAndAllowWhileIdle(int,%20long,%20android.app.PendingIntent)" rel="noopener ugc nofollow" target="_blank">setExactAndAllowWhileIdle()</a></code>在未来电池出现问题时，会在精确的时间发出警报。</p><p id="e366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强烈建议仅对面向用户的关键和时间敏感的中断使用精确警报。比如，如果你的应用程序是一个提醒或日历应用程序，通知用户即将发生的事件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b3f0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最佳实践</h1><ol class=""><li id="5b4f" class="nz oa it lb b lc mu lf mv li oq lm or lq os lu op of og oh bi translated">在<code class="fe mz na nb nc b">BroadcastReceive</code>中只做局部工作。</li><li id="ec92" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu op of og oh bi translated">对任何非面向用户的事件使用不准确的警报。</li><li id="6b1b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu op of og oh bi translated">小心使用精确报警，因为即使系统处于打盹模式，它们也能发出警报。</li><li id="cf48" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu op of og oh bi translated">不要不必要地唤醒系统。</li><li id="72fe" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu op of og oh bi translated">使用工作管理器执行任何重复的异步工作。</li></ol></div></div>    
</body>
</html>