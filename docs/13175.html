<html>
<head>
<title>Handling File Uploads With NestJS and MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NestJS和MySQL处理文件上传</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-file-uploads-with-nestjs-and-mysql-10c83c80ff96?source=collection_archive---------18-----------------------#2022-08-03">https://betterprogramming.pub/handling-file-uploads-with-nestjs-and-mysql-10c83c80ff96?source=collection_archive---------18-----------------------#2022-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2d8e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用TypeORM连接到MySQL数据库，创建一个实体，并将图像上传到Nestjs应用程序。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d22fbebafc64e5e38458b7f8b5d6891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z8Dp-YJpG-HYOwuK.png"/></div></div></figure><h1 id="dfa1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="1a5c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">许多开发人员鄙视处理文件上传。这可能是由于缺乏关于最佳方法的知识，或者难以确定如何配置Nest.js应用程序来处理文件上传。许多人可能希望将他们的文件直接保存到MySQL数据库，或者保存图像名称并将图像保存在磁盘存储上:这完全取决于他们的偏好和他们想要实现的目标。本教程将教你如何使用Nestjs和MySQL建立一个文件上传功能。</p><h1 id="89d6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">先决条件</h1><p id="e029" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在开始学习本教程之前，请确保您的系统满足以下要求:</p><ul class=""><li id="d9ae" class="mi mj it lo b lp mk ls ml lv mm lz mn md mo mh mp mq mr ms bi translated">您的系统正在运行版本14或更高版本的<a class="ae mt" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>。</li><li id="05c3" class="mi mj it lo b lp mu ls mv lv mw lz mx md my mh mp mq mr ms bi translated">您的系统安装了一个<a class="ae mt" href="https://www.mysql.com/downloads/" rel="noopener ugc nofollow" target="_blank"> MySQL数据库</a>。</li><li id="5134" class="mi mj it lo b lp mu ls mv lv mw lz mx md my mh mp mq mr ms bi translated">您已经安装了<a class="ae mt" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>。</li></ul><h1 id="6aa9" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">设置NestJS</h1><p id="c8d3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">满足上述要求后，继续安装Nestjs CLI，并通过运行以下命令创建一个新项目:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="46a5" class="ne kv it na b gy nf ng l nh ni">$ npm i -g @nestjs/cli<br/>$ nest new file-upload</span></pre><p id="008c" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">这些命令将安装Nestjs CLI，并使用下面的文件夹结构创建一个新的Nestjs项目。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9185" class="ne kv it na b gy nf ng l nh ni">📦file-upload<br/>┣ 📂src<br/>┃ ┣ 📜app.controller.spec.ts<br/>┃ ┣ 📜app.controller.ts<br/>┃ ┣ 📜app.module.ts<br/>┃ ┣ 📜app.service.ts<br/>┃ ┣ 📜image.entity.ts<br/>┃ ┗ 📜main.ts<br/>┣ 📂test<br/>┃ ┣ 📜app.e2e-spec.ts<br/>┃ ┗ 📜jest-e2e.json<br/>┣ 📜.eslintrc.js<br/>┣ 📜.gitignore<br/>┣ 📜.prettierrc<br/>┣ 📜README.md<br/>┣ 📜nest-cli.json<br/>┣ 📜package-lock.json<br/>┣ 📜package.json<br/>┣ 📜tsconfig.build.json<br/>┗ 📜tsconfig.json</span></pre><p id="8ee5" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">创建Nestjs项目后，继续下一步——通过运行以下命令安装应用程序所需的依赖项:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="de5d" class="ne kv it na b gy nf ng l nh ni">npm install --save @nestjs/typeorm typeorm mysql2</span></pre><p id="26e9" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">在上面的命令中，您已经安装了<a class="ae mt" href="https://typeorm.io/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>和<a class="ae mt" href="https://github.com/brianmario/mysql2" rel="noopener ugc nofollow" target="_blank"> mysql2 </a>模块:它们将使您能够将应用程序连接到mysql数据库并对其执行操作。</p><h1 id="d16a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">设置MySQL数据库</h1><p id="9205" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">安装了上述依赖项后，继续设置并连接到MySQL数据库。首先，用下面的代码片段将代码添加到<code class="fe nm nn no na b">app.module.ts</code>文件中。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a57e" class="ne kv it na b gy nf ng l nh ni">...<br/>import { TypeOrmModule } from '@nestjs/typeorm';<br/>import { Image } from './image.entity';<br/><br/>@Module({<br/>  imports: [TypeOrmModule.forRoot({<br/>    type: 'mysql',<br/>    host: 'localhost',<br/>    port: 3306,<br/>    username: 'root',<br/>    password: '1234',<br/>    database: 'blog',<br/>    entities: [Image],<br/>    synchronize: true,<br/>  }),<br/>  TypeOrmModule.forFeature([Image])<br/>  ],<br/>  ...<br/>})<br/>...</span></pre><p id="3b11" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">在上面的代码片段中，我们从之前安装的typeorm模块中导入了<code class="fe nm nn no na b">TypeOrmModule</code>。我们使用<code class="fe nm nn no na b">forRoot</code>方法将应用程序连接到MySQL数据库，并传递数据库凭证。这里要指出的另一件事是<code class="fe nm nn no na b">entities</code>属性，它允许我们在模块中指定实体，并让我们访问您将很快创建的<code class="fe nm nn no na b">Image</code>实体:我们还将<code class="fe nm nn no na b">synchronize</code>属性设置为<code class="fe nm nn no na b">true</code>来自动迁移数据库。</p><h1 id="5472" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建图像实体</h1><p id="1ed0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">接下来，让我们创建我们前面提到的图像实体。首先，在src目录中创建一个image.entity.ts文件，并添加下面的代码片段。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3666" class="ne kv it na b gy nf ng l nh ni">import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn } from 'typeorm';<br/><br/>@Entity()<br/>export class Image {<br/>    @PrimaryGeneratedColumn()<br/>    id: number;<br/><br/>    @Column()<br/>    name: string;<br/><br/>    @CreateDateColumn()<br/>    dateCreated: Date;<br/><br/>    @UpdateDateColumn()<br/>    dateUpdated: Date;<br/>}</span></pre><p id="051d" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">在上面的代码片段中，我们导入了创建实体所需的装饰器。使用这些装饰器，我们定义了实体的属性。我们有使用<code class="fe nm nn no na b">@PrimaryGeneratedColumn()</code>装饰器为数据库中的每条记录生成随机id的<code class="fe nm nn no na b">id</code>字段，存储将使用<code class="fe nm nn no na b">@Column</code>装饰器上传的图像名称的<code class="fe nm nn no na b">name</code>字段，保存使用<code class="fe nm nn no na b">@CreateDateColumn()</code>和<code class="fe nm nn no na b">@UpdateDateColumn()</code>创建和更新记录的日期的dateCreated和dateUpdate字段。</p><h1 id="6130" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建上传服务</h1><p id="3a37" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">创建图像实体后，让我们创建一个服务来执行CRUD操作，以处理文件上传。在<code class="fe nm nn no na b">app.service.ts</code>文件中，添加下面的代码片段。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2ccf" class="ne kv it na b gy nf ng l nh ni">import { Injectable } from '@nestjs/common';<br/>import { InjectRepository } from '@nestjs/typeorm';<br/>import { Repository } from 'typeorm';<br/>import { Image } from './image.entity';<br/><br/>@Injectable()<br/>export class AppService {<br/>  constructor(<br/>    @InjectRepository(Image)<br/>    private readonly imageRepository: Repository&lt;Image&gt;,<br/>  ) {}<br/><br/>  async getImages(): Promise&lt;Image[]&gt; {<br/>    return this.imageRepository.find();<br/>  }<br/><br/>  async createImage(image: Image): Promise&lt;Image&gt; {<br/>    return this.imageRepository.save(image);<br/>  }<br/><br/>  async getImage(id: number): Promise&lt;Image&gt; {<br/>    return this.imageRepository.findOneBy({ id });<br/>  }<br/><br/>  async deleteImage(id: number): Promise&lt;void&gt; {<br/>    await this.imageRepository.delete(id);<br/>  }<br/>}</span></pre><p id="9263" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">在上面的代码片段中，我们导入了<code class="fe nm nn no na b">injectRepository</code>装饰器，将<code class="fe nm nn no na b">imageRepository</code>注入到<code class="fe nm nn no na b">AppService</code>和<code class="fe nm nn no na b">Repository</code>中，这为您提供了在数据库上执行某些操作所需的方法。因此，对于<code class="fe nm nn no na b">createImage</code>图像服务，我们保存上传的图像名称，该名称将通过控制器传递。</p><h1 id="b7f6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建上传控制器</h1><p id="6b9b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在让我们创建控制器来使用服务。并添加下面的代码片段。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0ff6" class="ne kv it na b gy nf ng l nh ni">import { Injectable } from '@nestjs/common';<br/>import { InjectRepository } from '@nestjs/typeorm';<br/>import { Repository } from 'typeorm';<br/>import { Image } from './image.entity';<br/><br/>@Injectable()<br/>export class AppService {<br/>  constructor(<br/>    @InjectRepository(Image)<br/>    private readonly imageRepository: Repository&lt;Image&gt;,<br/>  ) {}<br/><br/>  async getImages(): Promise&lt;Image[]&gt; {<br/>    return this.imageRepository.find();<br/>  }<br/><br/>  async createImage(image: Image): Promise&lt;Image&gt; {<br/>    return this.imageRepository.save(image);<br/>  }<br/><br/>  async getImage(id: number): Promise&lt;Image&gt; {<br/>    return this.imageRepository.findOneBy({ id });<br/>  }<br/><br/>  async deleteImage(id: number): Promise&lt;void&gt; {<br/>    await this.imageRepository.delete(id);<br/>  }<br/>}</span></pre><p id="0856" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">在上面的代码片段中，我们导入了几个装饰器，如<code class="fe nm nn no na b">FileInterceptor</code>、<code class="fe nm nn no na b">UploadedFile</code>和<code class="fe nm nn no na b">UseInterceptors</code>。路由处理器的<code class="fe nm nn no na b">FileInterceptor()</code>拦截器使用<code class="fe nm nn no na b">@UploadedFile()</code>装饰器从请求中提取文件。<code class="fe nm nn no na b">FileInterceptor()</code>装饰器从<code class="fe nm nn no na b">@nestjs/platform-express</code>包中导出。<code class="fe nm nn no na b">@UploadedFile()</code>装饰器是从<code class="fe nm nn no na b">@nestjs/common</code>导出的。<code class="fe nm nn no na b">FileInterceptor()</code> decorator有两个参数，<code class="fe nm nn no na b">fieldName</code>是提供保存文件的HTML表单中的字段名称的字符串，<code class="fe nm nn no na b">options</code>是MulterOptions类型的可选对象。这是multer构造函数使用的同一个对象。</p><p id="99fc" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">关于<code class="fe nm nn no na b">createImage</code>函数，我们使用前面提到的decorators来处理文件上传，使用<code class="fe nm nn no na b">FileInterceptor()</code>传递图像的字段名，并且我们修改了<code class="fe nm nn no na b">FileInterceptor()</code>函数，通过使用<code class="fe nm nn no na b">multer</code>中可用的<code class="fe nm nn no na b">diskStorage</code>函数指定<code class="fe nm nn no na b">storage</code>属性来将图像上传到磁盘。然后，我们指定图像的位置，并为图像生成随机名称。此外，我们添加了一个<code class="fe nm nn no na b">filter</code>属性来限制某些图像格式的上传。现在我们使用<code class="fe nm nn no na b">@UploadedFile()</code> decorator提取文件，获取文件名并保存到数据库中。这样，我们可以使用每个图像的名称从存储位置获取图像。</p><p id="b79b" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">要使上述代码运行，您需要在终端中运行以下命令来安装multer:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f264" class="ne kv it na b gy nf ng l nh ni">npm i -D @types/multer</span></pre><p id="4d87" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">然后，您需要在<code class="fe nm nn no na b">app.module.ts</code>文件的导入数组中注册multer模块:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b332" class="ne kv it na b gy nf ng l nh ni">...<br/>import { MulterModule } from '@nestjs/platform-express';<br/><br/><br/>@Module({<br/>  ...<br/>  MulterModule.register({<br/>    dest: './files',<br/>  }),],<br/>  ...</span></pre><p id="6aee" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">上面的配置告诉multer处理文件上传和文件上传到的位置。最后但同样重要的是，我们应该在<code class="fe nm nn no na b">src</code>目录中创建一个<code class="fe nm nn no na b">files</code>文件夹来实际存储文件。</p><h1 id="1563" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">提供文件</h1><p id="bbe7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">要将上传到您应用程序上的图像实际提供给用户，您需要通过运行下面的命令来安装<code class="fe nm nn no na b">serve-static</code>模块。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a4f5" class="ne kv it na b gy nf ng l nh ni">npm install --save @nestjs/serve-static</span></pre><p id="6c0e" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">然后，用下面的代码片段将<code class="fe nm nn no na b">ServeStaticModule</code>注册到<code class="fe nm nn no na b">app.module.ts</code>文件的导入数组中。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ad17" class="ne kv it na b gy nf ng l nh ni">...<br/>import { ServeStaticModule } from '@nestjs/serve-static';<br/>import { join } from 'path';<br/><br/>@Module({<br/>  ...<br/>  ServeStaticModule.forRoot({<br/>    rootPath: join(__dirname, '..', 'files')<br/>  }),],<br/>  ...</span></pre><p id="e28b" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">在上面的代码片段中，您已经指定了文件所在的位置，并且可以从该位置提供服务。</p><h1 id="6eed" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">测试API</h1><p id="84ac" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在打开Postman，通过向端点<code class="fe nm nn no na b">localhost:4000/images</code>发送POST请求来测试应用程序，并将请求体中的有效负载作为表单数据传入。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/49a8f2c1d722ae5e5ccc7b086c021d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1tqceREo1M_ZrtTt.png"/></div></div></figure><p id="ebb6" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">如果您现在查看files文件夹，您应该会看到您上传的文件。请随意继续:测试并尝试其他路线。</p><h1 id="c16e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="f635" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">通过本教程，您已经学习了如何使用NestJS和MySQL处理文件上传。您已经学习了如何使用TypeORM连接到MySQL数据库，还创建了一个实体并将图像上传到Nestjs应用程序。</p><p id="0ea2" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">你已经成功地用NestJS和MySQL构建了一个文件上传特性:但是，对于你的数据库和应用程序的未来，请记住，持续关注你的应用程序和数据库不仅仅是为它们构建特性:<a class="ae mt" href="https://arctype.com" rel="noopener ugc nofollow" target="_blank">像Arctype </a>这样的SQL客户端将允许你编写SQL查询并优化它们，以及可视化数据库中当前存在的数据， 并且<a class="ae mt" href="https://arctype.com/blog" rel="noopener ugc nofollow" target="_blank">Arctype博客上的内容</a>将让您轻松地学习如何<a class="ae mt" href="https://arctype.com/blog/mysql-storage-engine-big-data/" rel="noopener ugc nofollow" target="_blank">优化所有MySQL实例的安全性、可用性和性能</a>，并为您提供关于整个数据库世界的许多见解。</p><p id="8b1f" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">如需进一步阅读，还可以在<a class="ae mt" href="https://docs.nestjs.com/techniques/file-upload" rel="noopener ugc nofollow" target="_blank"> Nestjs </a>中阅读更多关于上传文件的内容。对于额外的挑战，尝试通过保护删除和更新路由来扩展应用程序。你下一步会建什么？</p></div></div>    
</body>
</html>