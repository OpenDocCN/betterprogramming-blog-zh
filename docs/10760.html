<html>
<head>
<title>Stop Installing Node.js and Global Npm Packages, Use Docker Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止安装Node.js和全局Npm包，改用Docker</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-installing-node-js-and-global-npm-packages-use-docker-instead-42597990db13?source=collection_archive---------5-----------------------#2022-01-26">https://betterprogramming.pub/stop-installing-node-js-and-global-npm-packages-use-docker-instead-42597990db13?source=collection_archive---------5-----------------------#2022-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="939f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保护您的系统免受漏洞攻击</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/17e50286815582ecd9c2881bc90a4f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qLKQI8XGiXvaQo-u"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">汤姆·温克尔斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="548d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一种方法可以让我们的计算机免受恶意npm软件包和网络安全漏洞的影响。这几乎就像Node和npm将在一个孤岛上。</p><p id="05c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用Docker容器来运行Node.js并安装npm包。</p><h1 id="2cd5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是Docker容器，我们为什么要使用它们？</h1><p id="c718" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Docker是一种软件技术，它创建了一个在我们的计算机上运行的容器。容器就像是在我们的内部运行一台小型计算机，限制对我们文件的访问。</p><p id="b3f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的计算机上运行Node.js的问题是恶意npm包的增长。一些恶意行为者故意将恶意软件放入npm包中。他们创建名称相似的包(称为域名仿冒),希望我们安装不正确的版本，这样他们就可以传播恶意软件。</p><p id="c0ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些类型的npm攻击已经<a class="ae kv" href="https://threatpost.com/5-top-threatpost-stories-2021/177278/" rel="noopener ugc nofollow" target="_blank">显著增长</a>，并将继续<a class="ae kv" href="https://www.securityweek.com/cyber-insights-2022-supply-chain" rel="noopener ugc nofollow" target="_blank">成为2022年</a>和未来几年的一个问题。</p><p id="b671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们安装了一个恶意的npm包，我们可以限制损害的程度。这就是容器可以发挥作用的地方。</p><p id="4a3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们安装了一个<a class="ae kv" href="https://blog.sonatype.com/fake-npm-roblox-api-package-installs-ransomware-spooky-surprise" rel="noopener ugc nofollow" target="_blank">部署了勒索软件</a>的npm包。如果我们在电脑上运行Node.js，我们所有的文件都会成为勒索软件攻击的受害者。</p><p id="941d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们把它安装在一个容器里。正确配置的容器将限制对添加到容器中的文件的访问。理论上，只有那些特定的文件会被泄露，我们的个人文件应该受到保护。为了安全起见，我们可以停止容器，删除容器映像，清除与容器相关的所有文件，并运行防病毒扫描。假设我们将代码提交给一个软件库，我们可能只丢失了一点点代码。</p><p id="aaec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Docker容器运行Node.js就像将我们的代码隔离起来，这样感染就不会对整个计算机造成压力。</p><h1 id="e08f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何在我的机器上设置Node.js和npm？</h1><p id="cb36" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">从在我们的开发机器上安装<a class="ae kv" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker桌面</a>开始。我们还想创建一个Docker帐户，以利用我们稍后将讨论的Docker扫描功能。</p><p id="6acb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们安装它之后，去设置。</p><p id="e234" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在“通用”部分启用“Docker撰写V2”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/332ecce4a3b3b3b2256e0eda1b43d880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2ySRTki2cNRFqxWrVB3Bg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">常规设置。</p></figure><p id="a35c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在“资源高级”部分设置所需的资源负载。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/12e150fa6fedd3767538e35813d34eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lvClSTGtTv75Mps52e11w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">高级资源设置。</p></figure><p id="f564" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确保软件更新已启用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/0f3565ce9ea40830ae7c7259e4096f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brLtTXr8qDPczTyEisW4mg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">软件更新设置。</p></figure><p id="2dde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到我们的代码文件夹。在顶层目录中(或者在我们想要定制容器的每个文件夹中)创建一个名为“docker-compose.yml”的文件。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="ddf5" class="mx lt iq mt b gy my mz l na nb">version: "3"<br/>services:<br/>  dev:<br/>    image: "node:14.18.1-buster-slim"<br/>    user: "node"<br/>    working_dir: /home/node/dev<br/>    volumes:<br/>      - /var/run/docker.sock:/var/run/docker.sock<br/>      - ./:/home/node/dev</span></pre><p id="4a6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker合成文件创建并运行Docker容器，而无需构建它。</p><p id="8d0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">属性定义了节点容器。该示例使用了一个正式的Node.js容器映像。版本是根据Docker扫描的建议选择的。</p><p id="8dc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">属性将主目录定义为<code class="fe nc nd ne mt b">/home/node/dev</code>。(当我们启动容器时，它会将<code class="fe nc nd ne mt b">dev</code>显示为当前文件夹。)</p><p id="fbd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nc nd ne mt b">volumes:</code>属性允许在容器内运行Docker，并将所有文件放在<code class="fe nc nd ne mt b">docker-compose.yml</code>所在的位置，并将其挂载到容器内的<code class="fe nc nd ne mt b">/home/node/dev</code>目录。(如果我们不需要Docker在容器中运行，我们可以删除第一行。)</p><p id="03ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Circle中的另一个映像(例如<code class="fe nc nd ne mt b">circleci/node:14-bullseye</code>)提供了git和其他常见的Linux实用程序。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="36b0" class="mx lt iq mt b gy my mz l na nb">version: "3"<br/>services:<br/>  node:<br/>    image: "circleci/node:14-bullseye"<br/>    working_dir: /home/node/dev<br/>    volumes:<br/>      - /var/run/docker.sock:/var/run/docker.sock<br/>      - ./:/home/node/dev</span></pre><p id="534b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们计算机的终端中，运行以下命令来启动容器。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="aa75" class="mx lt iq mt b gy my mz l na nb">docker compose run --rm dev bash<br/># Or the following if Docker Compose v2 was not checked above<br/>docker-compose run --rm dev bash</span></pre><p id="d5fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在将在终端中看到类似<code class="fe nc nd ne mt b">node@502104098e72:~/code$</code>的提示。这意味着我们的终端现在位于Docker容器运行节点内部。</p><p id="8ba8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">好处:</strong>用<code class="fe nc nd ne mt b">PS1</code> Linux变量定制命令提示符，让它对你更有意义。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="38a5" class="mx lt iq mt b gy my mz l na nb">node@502104098e72:~/code$ PS1="MyProject:\w$ "<br/>MyProject:<!-- -->~/code<!-- -->$</span></pre><p id="7cd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">键入<code class="fe nc nd ne mt b">ls</code>命令来查看我们的文件。我们应该会看到目录中的文件。</p><p id="a45b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开Docker桌面，我们将看到我们的容器运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/c1e90d7e22ba2d4d063f4dba5c38defb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2l26uS52D2MyixqWZw0og.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">容器正在运行。</p></figure><p id="f882" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以在容器中运行<code class="fe nc nd ne mt b">npm i -g some_package_name</code>和<code class="fe nc nd ne mt b">npm ci</code>。</p><p id="8d9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(如果我们的机器上安装了节点，我们可以尝试在我们的容器中安装一个不同的全局npm包。我们打开一个新的终端窗口，尝试运行全局npm包，我们应该得到一个错误，因为它只安装在我们的容器中。)</p><p id="d35e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在容器的终端中，键入<code class="fe nc nd ne mt b">exit</code>命令。转到Docker桌面，我们应该不再看到容器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/dde6807e8b8c0d0ddc348c6d44f60d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbVQcnV2rhMy8FiXweY-KQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没有容器在运行。</p></figure><p id="1529" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nc nd ne mt b">docker compose run</code>命令中的<code class="fe nc nd ne mt b">--rm</code>标志告诉Docker在容器终止后删除它。这样我们可以保持我们的机器更干净。</p><h2 id="f5ab" class="mx lt iq bd lu nh ni dn ly nj nk dp mc lf nl nm me lj nn no mg ln np nq mi nr bi translated">保持Docker的更新和整洁</h2><p id="a148" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当Docker软件更新可用时，我们应该应用它们。</p><p id="730c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们应用更新后，我们应该用<a class="ae kv" href="https://docs.docker.com/engine/scan/" rel="noopener ugc nofollow" target="_blank"> Docker扫描</a>来扫描我们的容器的漏洞。</p><p id="1555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要接受许可证来开始Docker扫描。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="27cc" class="mx lt iq mt b gy my mz l na nb">docker scan --accept-license --version</span></pre><p id="0f17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用下面的命令扫描Node.js容器。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="435c" class="mx lt iq mt b gy my mz l na nb">docker scan node</span></pre><p id="68cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">扫描输出将推荐使用哪个容器图像。我们将更新<code class="fe nc nd ne mt b">docker-compose.yml</code>文件中的<code class="fe nc nd ne mt b">image:</code>属性，以获得推荐的图像。</p><p id="1d2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该时常清理图像。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/03cdbfe68defba0de0d7f1eb4b99d823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3qqXmycgW5OLCZAcgz_uA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清理图像。</p></figure><p id="736a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并删除旧卷。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/b2414b8b2137f9fed55502127ae21ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fx7gsLZXx80ItUW-Af8RnA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正在删除卷。</p></figure><h1 id="ff00" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="854e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用Docker容器是保护我们的计算机免受恶意npm包和Node.js漏洞攻击的一种方式，因为代码执行和运行时是与容器隔离的。</p><h2 id="1338" class="mx lt iq bd lu nh ni dn ly nj nk dp mc lf nl nm me lj nn no mg ln np nq mi nr bi translated">在你走之前</h2><p id="44d2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这些是你可能喜欢的其他文章。</p><div class="nu nv gp gr nw nx"><a href="https://javascript.plainenglish.io/add-typescript-to-nuxt-or-vue-in-3-easy-steps-360a356460b4" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">通过3个简单的步骤将TypeScript添加到Vue或Nuxt中</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">在Nuxt或Vue中使用TypeScript可能非常复杂。我只想做类型检查！仅此而已。我花了很长时间才…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/serverless-is-cool/finding-winning-stocks-with-serverless-d8d64d890fce" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">用网页抓取器和无服务器(AWS Lambda和DynamoDB)寻找获胜的股票</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">我和几个朋友聊股票，分享想法，互相鼓励。几个月前，我意识到我们需要…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://javascript.plainenglish.io/should-you-ditch-serverless-for-aws-cdk-fc5ac904688a" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">你应该放弃AWS CDK的无服务器吗？</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">无服务器框架是构建无服务器应用程序的最流行的框架，但是它与……</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="og l"><div class="on l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://miguelacallesmba.medium.com/if-you-build-it-you-should-break-it-25e06f2d53b6" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">如果你建立了它，你就应该打破它。</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">你可能听过，“你建了，他们就来了。”</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">miguelacallesmba.medium.com</p></div></div><div class="og l"><div class="oo l oi oj ok og ol kp nx"/></div></div></a></div></div></div>    
</body>
</html>