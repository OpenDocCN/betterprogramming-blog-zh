<html>
<head>
<title>Build a Radio Broadcast System With Node.js, React and Socket.IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js，React，Socket搭建一个电台广播系统。超正析象管(Image Orthicon)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-radio-broadcast-system-with-node-js-react-and-socket-io-1ae107a53639?source=collection_archive---------1-----------------------#2022-10-26">https://betterprogramming.pub/build-a-radio-broadcast-system-with-node-js-react-and-socket-io-1ae107a53639?source=collection_archive---------1-----------------------#2022-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a43d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从主麦克风流式传输音频，并将其广播给所有连接的听众</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c1075733e84bf5fe4e96125d7b9a23d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bvqp_gFPRq4jRCwelW-RBA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的封面图片</p></figure><p id="ff78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将向您展示如何使用Express和React构建一个无线电广播系统。</p><p id="5758" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的电台将由一名主持人和多名听众组成。主持人将他们的麦克风流式传输到服务器，服务器向每个听众广播。我们可以用<code class="fe lr ls lt lu b">socket.io</code>通过WebSockets来做这件事。此外，服务器从本地文件夹加载音乐，通过HTTP传输给听众。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/989336ea42119183438a145d745849d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k6pTDPWaGBr2b___"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者展示最终应用程序的图片</p></figure><h1 id="c401" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">构建后端</h1><p id="b4a4" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">要开始，我们需要从NPM安装以下软件包。</p><pre class="kg kh ki kj gt mt lu mu mv aw mw bi"><span id="a200" class="mx lx iq lu b gy my mz l na nb">npm i express react-feather jnaudiostream react-router-dom socket.io socket.io-client throttle uuid</span></pre><p id="f78c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在名为<code class="fe lr ls lt lu b">server</code>的新文件夹中创建一个<code class="fe lr ls lt lu b">index.js</code>文件。在这里，我们将设置一个Express应用程序，并在它周围包装一个<code class="fe lr ls lt lu b">socket.io</code>服务器。然后我们监听一个套接字连接，并定义一个客户端可以访问HTTP音乐流的路由。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="e718" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">实时音频流</h1><p id="a414" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们将创建一个<code class="fe lr ls lt lu b">Queue</code>类来处理音乐文件的打开，并以相同的速率将它们传输到每个客户端。为此，我们可以在同一个<code class="fe lr ls lt lu b">server</code>文件夹中创建一个名为<code class="fe lr ls lt lu b">queue.js</code>的文件。</p><p id="beee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们将实现的以TypeScript风格声明的所有方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="604a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们来分解一下。</p><h1 id="bfa1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">处理客户</h1><p id="076c" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们可以为每个客户端创建一个<code class="fe lr ls lt lu b">PassThrough</code>流，我们可以在其中写入音频数据，而客户端仍然可以读取它。</p><p id="3584" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还将定义一个方法，向每个连接的客户端写入一个数据块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="32e2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">加载文件</h1><p id="ef8e" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们需要一种方法来获取目录中所有MP3文件的名称，并获取它们的比特率。有了比特率，我们就可以控制音频流的速率。我们将使用<code class="fe lr ls lt lu b">Throttle</code>包，而不是自己处理计时。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5c22" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了获得比特率，我们将通过<code class="fe lr ls lt lu b">@dropb/ffprobe</code>包装器使用<code class="fe lr ls lt lu b">ffprobe</code>。我们必须将它与<code class="fe lr ls lt lu b">ffprobe-static</code>一起安装，后者将下载<code class="fe lr ls lt lu b">ffprobe</code>二进制文件并返回它们的位置。</p><pre class="kg kh ki kj gt mt lu mu mv aw mw bi"><span id="5da8" class="mx lx iq lu b gy my mz l na nb">npm i ffprobe-static @dropb/ffprobe</span></pre><p id="441e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用以下代码实现<code class="fe lr ls lt lu b">getTrackBitrate</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="0b66" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">获取下一首曲目</h1><p id="30a7" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们使用一个索引来知道我们下一步应该播放哪个曲目。默认情况下，索引为0。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="9680" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">创建文件流</h1><p id="3006" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们现在使用<code class="fe lr ls lt lu b">fs</code>从磁道的文件路径创建读取流。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="2509" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">壮观的流媒体</h1><p id="0496" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">现在我们将实例化一个新的<code class="fe lr ls lt lu b">Throttle</code>,我们将通过管道传输文件流。<code class="fe lr ls lt lu b">Throttle</code>的构造函数接受bps(每秒字节数),所以我们将比特率除以8。</p><p id="5e01" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们监听<code class="fe lr ls lt lu b">data</code>事件，并在收到每个数据块时调用<code class="fe lr ls lt lu b">this.broadcast</code>。我们使用<code class="fe lr ls lt lu b">data</code>事件将数据发送到多个流，因为只有一个可写事件可以消耗典型的<code class="fe lr ls lt lu b">.pipe</code>。</p><p id="91a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦没有更多的数据留下，我们再次开始加载下一个轨道，获得流，最后流。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="99e4" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">控制回放</h1><p id="69e1" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">要暂停播放，我们要做的就是结束油门。但是我们还必须删除<code class="fe lr ls lt lu b">end</code>监听器，以避免<code class="fe lr ls lt lu b">this.play(true)</code>被执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a96a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还需要一个guard子句来检查一个throttle是否存在，以及我们是否加载了一个track。</p><pre class="kg kh ki kj gt mt lu mu mv aw mw bi"><span id="dcc9" class="mx lx iq lu b gy my mz l na nb">started() {<br/>    return this.stream &amp;&amp; this.throttle &amp;&amp; this.currentTrack;<br/>}</span></pre><p id="7116" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，为了恢复回放，我们可以使用之前定义的调用<code class="fe lr ls lt lu b">start</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="29d7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">收尾</h1><p id="cb63" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们现在可以定义<code class="fe lr ls lt lu b">play</code>方法，它要么继续回放，要么开始播放下一首曲目。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="42a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">并且在文件中，我们可以导出<code class="fe lr ls lt lu b">Queue</code>的单例实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="6b91" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">服务器</h1><p id="13b7" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">回到我们的主服务器文件，我们可以导入我们的队列，加载轨道并实现<code class="fe lr ls lt lu b">/stream</code>路由，它通过管道将队列创建的<code class="fe lr ls lt lu b">PassThrough</code>发送到HTTP响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="4a6d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">前端路由</h1><p id="01d8" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">在<code class="fe lr ls lt lu b">main.jsx</code>文件中(如果您使用Vite)，我们使用<code class="fe lr ls lt lu b">react-router-dom</code>定义了三条路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="eb51" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">根组件</h1><p id="c5d8" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们的根组件很简单。我们放置一个标题，并创建按钮将用户带到其他页面。注意，我们使用<code class="fe lr ls lt lu b">react-feather</code>作为图标，使用TailwindCSS作为样式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="3e42" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">流式麦克风</h1><p id="be83" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">要将音频数据实时发送到服务器，我们可以使用<code class="fe lr ls lt lu b">jnaudiostream</code>，这是我在NPM上发布的一个包。</p><p id="c74a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以创建一个使用<code class="fe lr ls lt lu b">socket.io-client</code>与服务器通信的组件(<code class="fe lr ls lt lu b">MicrophoneButton</code>)。在效果内部，我们可以在收到缓冲区头和后续数据包时发送它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="108f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以向record按钮添加一个<code class="fe lr ls lt lu b">onClick</code>处理程序，它将切换记录器的状态。这里是<code class="fe lr ls lt lu b">MicrophoneButton</code>组件的最终代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="c636" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><a class="ae ne" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank">插座。IO </a>服务器</h1><p id="b638" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">在服务器端，我们可以监听<code class="fe lr ls lt lu b">bufferHeader</code>和<code class="fe lr ls lt lu b">stream</code>事件，并将数据广播给其他客户端。我们还监听了一个稍后会用到的<code class="fe lr ls lt lu b">control</code>事件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="843c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">音乐控制</h1><p id="9c80" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">除了记录麦克风，我们还需要按钮向<code class="fe lr ls lt lu b">socket.io</code>服务器发送命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="768c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">主机路由</h1><p id="a5e6" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">在路由的主要组件中，我们可以为<code class="fe lr ls lt lu b">socket.io</code>实例化一个客户端。我们连接到服务器的基本URL。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="cb29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顺便说一下，如果你的前端app和后端在不同的端口上(比如Vite在5173端口，Express app在3000端口)，你就需要在<code class="fe lr ls lt lu b">socket.io</code>服务器上设置一个CORS属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="892f" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">收听</h1><p id="5d68" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">为了完整地收听广播，用户需要从<code class="fe lr ls lt lu b">socket.io</code> <em class="nf">和</em>的HTTP流获得主持人的麦克风音频用于音乐。</p><p id="bfc3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了调谐到主麦克风，我们可以使用来自<code class="fe lr ls lt lu b">jnaudiostream</code>的<code class="fe lr ls lt lu b">AudioStreamer</code>类。然后我们监听<code class="fe lr ls lt lu b">bufferHeader</code>和<code class="fe lr ls lt lu b">stream</code>事件传递给streamer对象，类似于<a class="ae ne" href="https://github.com/WoolDoughnut310/jnaudiostream" rel="noopener ugc nofollow" target="_blank">存储库</a>中的一个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0fca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，一旦我们设置了标题缓冲区，就可以使用<code class="fe lr ls lt lu b">streamer.mediaBuffer</code>。</p><p id="73e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">而现在，在听HTTP音乐流的时候，我们只用了一个<code class="fe lr ls lt lu b">audio</code>元素。</p><p id="16e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">添加以下代码以创建最终的路由组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="015d" class="lw lx iq bd ly lz nn mb mc md no mf mg jw np jx mi jz nq ka mk kc nr kd mm mn bi translated">最终注释</h1><p id="cc4c" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">概括来说，我们从主机麦克风流式传输音频，并将其广播给所有连接的听众。然后我们创建了一个队列引擎来处理流向HTTP客户端的流媒体音乐。最后，我们构建了一个接口来将所有东西联系在一起。</p><p id="81c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是一些需要考虑的额外要点:</p><ul class=""><li id="c163" class="ns nt iq kx b ky kz lb lc le nu li nv lm nw lq nx ny nz oa bi translated">对主机的授权</li><li id="8f67" class="ns nt iq kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated">在队列中添加或移除曲目</li><li id="a8a4" class="ns nt iq kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated">显示当前曲目</li><li id="64a9" class="ns nt iq kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated">允许一个以上的队列(站)</li></ul><p id="3e80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在你离开之前，你可以在这里找到这个项目的全部代码。下次见。</p><h1 id="b62e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">参考</h1><ul class=""><li id="afc7" class="ns nt iq kx b ky mo lb mp le og li oh lm oi lq nx ny nz oa bi translated"><a class="ae ne" href="https://github.com/WoolDoughnut310/jnaudiostream" rel="noopener ugc nofollow" target="_blank">github.com/WoolDoughnut310/jnaudiostream</a></li><li id="f551" class="ns nt iq kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated"><a class="ae ne" href="https://socket.io/docs/v4/handling-cors" rel="noopener ugc nofollow" target="_blank">socket.io/docs/v4/handling-cors</a></li><li id="f929" class="ns nt iq kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated"><a class="ae ne" href="https://blog.logrocket.com/online-radio-server-pure-node-js" rel="noopener ugc nofollow" target="_blank">blog.logrocket.com/online-radio-server-pure</a></li><li id="192f" class="ns nt iq kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated"><a class="ae ne" href="https://github.com/michael-gillett/node-stream-player" rel="noopener ugc nofollow" target="_blank">github.com/michael-gillett/node-stream-player</a></li><li id="5ab0" class="ns nt iq kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated"><a class="ae ne" href="https://tailwindcss.com/docs/guides/vite" rel="noopener ugc nofollow" target="_blank">tailwindcss.com/docs/guides/vite</a></li><li id="22fc" class="ns nt iq kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated"><a class="ae ne" href="https://github.com/TooTallNate/node-throttle" rel="noopener ugc nofollow" target="_blank">github.com/TooTallNate/node-throttle</a></li></ul></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="19da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">原载于</em><a class="ae ne" href="https://cs310.hashnode.dev/build-a-radio-broadcast-system-with-nodejs-react-and-socketio" rel="noopener ugc nofollow" target="_blank"><em class="nf">https://cs 310 . hash node . dev</em></a><em class="nf">。</em></p></div></div>    
</body>
</html>