<html>
<head>
<title>Creating a Reusable Toggle Component in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中创建可重用的切换组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-creating-a-reusable-toggle-component-10fc485ca9e6?source=collection_archive---------9-----------------------#2020-07-13">https://betterprogramming.pub/react-creating-a-reusable-toggle-component-10fc485ca9e6?source=collection_archive---------9-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8efa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建您自己的自定义开关</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/10f25476e64aad35964ef975f9a5b65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2VZBmQCMQKYaY2DS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@oxaroxa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥克萨洛克萨</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="6e15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意:在我开始这篇文章之前，我想充分肯定升级教程及其关于</em> <code class="fe lt lu lv lw b"><em class="ls">render</em></code> <em class="ls">道具的三部分视频系列。查看YouTube上的视频</em><a class="ae kv" href="https://www.youtube.com/watch?v=5rAFpwfu5C4&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">。</em></p><p id="cf01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面，我们有两个文件:我们的父组件(<code class="fe lt lu lv lw b">App</code>)和它的子组件(<code class="fe lt lu lv lw b">Toggle</code>)。在<code class="fe lt lu lv lw b">App</code>内部，我们正在导入<code class="fe lt lu lv lw b">Toggle</code>文件，并使用JSX组件标签将<code class="fe lt lu lv lw b">Toggle</code>元素渲染到<code class="fe lt lu lv lw b">App</code>(或屏幕)。元素标签将让任何写在里面的JSX代码访问我们的逻辑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/28927508216e946511ec66a16f93956a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rj-lQ87373nzdbwS-PQ2Fg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/1f88a5921c16960fc27d9d074c515439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*ysRKR8s3tAJN6zXQAUGVjw.png"/></div></figure><p id="2791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将声明<code class="fe lt lu lv lw b">&lt;Toggle /&gt;</code>的一个属性或道具。我们可以随意命名这个属性，但是在这个例子中，我们将命名这个道具<code class="fe lt lu lv lw b">render</code>，因为它将呈现JSX元素:</p><pre class="kg kh ki kj gt lz lw ma mb aw mc bi"><span id="485f" class="md me iq lw b gy mf mg l mh mi">&lt;Toggle render={JSX} /&gt;</span></pre><p id="1d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了渲染出<code class="fe lt lu lv lw b">&lt;Toggle /&gt;</code>中的JSX元素，我们首先需要创建一个函数:</p><pre class="kg kh ki kj gt lz lw ma mb aw mc bi"><span id="827e" class="md me iq lw b gy mf mg l mh mi">&lt;Toggle render={() =&gt; ()} /&gt;</span></pre><p id="cf91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个匿名函数中，我们现在可以隐式地返回一个HTML元素——在本例中是一个<code class="fe lt lu lv lw b">div</code>——以及<code class="fe lt lu lv lw b">div</code>的子元素:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/b0ebf9e4dd7b27c1f94adc0e7a88c347.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*aHWmT7p6kfijWaVtMDLfyQ.png"/></div></figure><p id="ed82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以析构从<code class="fe lt lu lv lw b">Toggle</code>组件发送的道具对象:</p><pre class="kg kh ki kj gt lz lw ma mb aw mc bi"><span id="668c" class="md me iq lw b gy mf mg l mh mi">render={({ on, toggle }) =&gt; (</span></pre><p id="478d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这样做，我们能够在我们的<code class="fe lt lu lv lw b">&lt;Toggle /&gt;</code>元素中调用由<code class="fe lt lu lv lw b">on:</code>和<code class="fe lt lu lv lw b">toggle:</code>的键表示的逻辑。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="76b5" class="mr me iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated"><strong class="ak">看看切换文件</strong>里面的逻辑</h1><p id="ee85" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">首先，我们来看看我们的状态。我们将布尔值<code class="fe lt lu lv lw b">false</code>设置为关键字<code class="fe lt lu lv lw b">on</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f50608c92da58abae6e44bdc59ccf3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*4r1g6hOD0gq5fncddYrvIg.png"/></div></figure><p id="32a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们有一个名为<code class="fe lt lu lv lw b">toggle</code>的函数。在该函数中，我们使用<code class="fe lt lu lv lw b">setState()</code>函数，通过bang运算符将<code class="fe lt lu lv lw b">this.state.on</code>的值改为其相反的值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/96b07374a312561525f637e6fe96bc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*GDiasvWfV0DDJA-qirpYnQ.png"/></div></figure><p id="e826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将属性<code class="fe lt lu lv lw b">render</code>析构并设置为一个变量:</p><pre class="kg kh ki kj gt lz lw ma mb aw mc bi"><span id="8bf1" class="md me iq lw b gy mf mg l mh mi">const { render } = this.props;</span></pre><p id="a83f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得关键字<code class="fe lt lu lv lw b">render</code>可以在<code class="fe lt lu lv lw b">Toggle</code>文件中使用，并且是声明<code class="fe lt lu lv lw b">this.props.render</code>的另一种方式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0915db66d3416ca1b934af575b2a3eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*3avqo7eu7-qrI1V9X7UpXw.png"/></div></figure><p id="92f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为属性<code class="fe lt lu lv lw b">render</code>是一个函数，为了正确输出，需要用括号来调用它:</p><pre class="kg kh ki kj gt lz lw ma mb aw mc bi"><span id="05aa" class="md me iq lw b gy mf mg l mh mi">&lt;div&gt;{render()}&lt;/div&gt;</span></pre><p id="d76a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们要将<code class="fe lt lu lv lw b">Toggle</code>的状态和<code class="fe lt lu lv lw b">toggle</code>函数发送到<code class="fe lt lu lv lw b">App</code>文件。我们通过将这些设置为<code class="fe lt lu lv lw b">render</code>函数中的道具来实现这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a4aacc333b70bcde6d45e04508648ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*UnLseKmuU4D50IwEpGWY2g.png"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="733c" class="mr me iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated"><strong class="ak">返回app . jsx……</strong></h1><p id="50ad" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">所以现在我们明白了在<code class="fe lt lu lv lw b">Toggle</code>文件中到底发生了什么，我们可以在<code class="fe lt lu lv lw b">Toggle</code>元素中使用这个逻辑。</p><p id="54a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe lt lu lv lw b">render</code>道具中，我们在<code class="fe lt lu lv lw b">Toggle</code>文件中析构了从<code class="fe lt lu lv lw b">render</code>函数发送来的道具对象:</p><pre class="kg kh ki kj gt lz lw ma mb aw mc bi"><span id="98ef" class="md me iq lw b gy mf mg l mh mi">render={({ on, toggle }) =&gt; (</span></pre><p id="79a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在能够在JSX元素上使用<code class="fe lt lu lv lw b">on</code>和<code class="fe lt lu lv lw b">toggle</code>的道具以及附加到这些关键字的逻辑:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9edc44387f9f1a29ca1935836bcb8ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*Y_PdDLXbtJrrmWXWmtIUxg.png"/></div></figure><p id="feb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们看看<code class="fe lt lu lv lw b">button</code>元素。我们有一个调用我们的<code class="fe lt lu lv lw b">toggle</code>函数的<code class="fe lt lu lv lw b">onClick</code>函数。记住，我们的<code class="fe lt lu lv lw b">toggle</code>功能将状态从<code class="fe lt lu lv lw b">true</code>变为<code class="fe lt lu lv lw b">false</code>，从<code class="fe lt lu lv lw b">false</code>变为<code class="fe lt lu lv lw b">true</code>。</p><p id="2de1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们有了我们的<code class="fe lt lu lv lw b">on</code>关键字，它声明了<code class="fe lt lu lv lw b">Toggle</code>的状态。</p><p id="f637" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在代码片段中:</p><pre class="kg kh ki kj gt lz lw ma mb aw mc bi"><span id="8676" class="md me iq lw b gy mf mg l mh mi">{ on &amp;&amp; &lt;h1&gt;Show Me &lt;/h1&gt; }</span></pre><p id="9a72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">逻辑是声明如果<code class="fe lt lu lv lw b">on</code>和<code class="fe lt lu lv lw b">&lt;h1&gt;Show Me &lt;/h1&gt;</code>都是<code class="fe lt lu lv lw b">true</code>，那么渲染<code class="fe lt lu lv lw b">&lt;h1&gt;</code>元素。</p><p id="309d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以当点击按钮时，<code class="fe lt lu lv lw b">on</code>的布尔逻辑变为<code class="fe lt lu lv lw b">true</code>或<code class="fe lt lu lv lw b">false</code>。通过这样做，它创造了我们想要的切换效果。</p><p id="1a90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个阶段，我们现在有了一个完全可重用的<code class="fe lt lu lv lw b">Toggle</code>组件。在<code class="fe lt lu lv lw b">App</code>内部，我们现在可以渲染多个<code class="fe lt lu lv lw b">&lt;Toggle /&gt;</code>元素，每个元素都有自己的JSX代码。</p><p id="6b66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很好，但是我们可以通过一些调整来清理和减少代码中的一些噪音。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="5e66" class="mr me iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">使用this.props.children清理代码</h1><p id="d3fc" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">需要注意的是，<code class="fe lt lu lv lw b">this.props.children</code>是一个特殊的道具React语言给我们的道具。它让我们可以访问在<code class="fe lt lu lv lw b">App</code>中呈现的<code class="fe lt lu lv lw b">Toggle</code>元素中的JSX子元素。然而，不需要像在<code class="fe lt lu lv lw b">render={() =&gt; ()}</code>中那样在<code class="fe lt lu lv lw b">Toggle</code>元素中声明它。</p><p id="d720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请注意我们之前是如何在<code class="fe lt lu lv lw b">Toggle</code>标签中声明我们的JSX的:</p><pre class="kg kh ki kj gt lz lw ma mb aw mc bi"><span id="67cf" class="md me iq lw b gy mf mg l mh mi">&lt;Toggle prop={JSX} /&gt;</span></pre><p id="f63c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们清理过的代码中，我们改为在开始和结束的<code class="fe lt lu lv lw b">Toggle</code>标签之间写JSX:</p><pre class="kg kh ki kj gt lz lw ma mb aw mc bi"><span id="089a" class="md me iq lw b gy mf mg l mh mi">&lt;Toggle&gt;{JSX}&lt;/Toggle&gt;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/284c60a6f5e0a82c5f954898427386bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*_DbktuRq_jDwZauzY8TN2A.png"/></div></figure><p id="596c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这样做，我们在<code class="fe lt lu lv lw b">Toggle</code>中创建了一个子元素。现在我们可以访问<code class="fe lt lu lv lw b">Toggle</code>文件中的<code class="fe lt lu lv lw b">this.props.children</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/229350a075c71cbedf70b2c3b282cef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*aPoGDnGSg-qf7YGwki2oxw.png"/></div></figure><p id="d549" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们析构<code class="fe lt lu lv lw b">children</code>关键字，并为其设置属性，就像我们对<code class="fe lt lu lv lw b">render</code> prop函数所做的那样。</p><p id="6801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们有一个完全可重用的<code class="fe lt lu lv lw b">Toggle</code>组件。</p><p id="c68c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>