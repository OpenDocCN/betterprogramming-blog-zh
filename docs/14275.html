<html>
<head>
<title>Deploy and Run Hashicorp Vault With TLS Security in AWS Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS云中部署和运行具有TLS安全性的Hashicorp Vault</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deploy-and-run-hashicorp-vault-with-tls-security-in-aws-cloud-25541d02d182?source=collection_archive---------10-----------------------#2022-11-23">https://betterprogramming.pub/deploy-and-run-hashicorp-vault-with-tls-security-in-aws-cloud-25541d02d182?source=collection_archive---------10-----------------------#2022-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="5005" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">安全性和AWS</h2><div class=""/><div class=""><h2 id="2e27" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">在AWS中部署生产级存储库</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1eb710082b97e6a7e005532f5ecc44a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7kJTtZC827TduLj8"/></div></div></figure><p id="a96c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通常在软件工程中，当我们开发新功能时，我们会对某些敏感信息进行编码，如密码、密钥或令牌，以使我们的代码实现其预期的功能，这是一个非常常见的功能。IT领域的不同专业人员以不同的方式使用它，例如:</p><ul class=""><li id="c1fc" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">开发人员使用来自API令牌、数据库凭证或代码中其他敏感信息的秘密。</li><li id="211a" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">开发-运营工程师可能必须将某些值导出为环境变量，并将这些值写入YAML文件中，以便CI/CD管道高效运行。</li><li id="61ba" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">云工程师可能必须传递凭证、秘密令牌和其他秘密信息，以便他们访问各自的云(在AWS的情况下，即使我们将这些保存在一个<code class="fe mk ml mm mn b">.credentials</code>文件中，我们仍然必须在terraform块中传递文件名，这将表明凭证在计算机内本地可用。)</li><li id="fbfd" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">系统管理员可能需要向员工发送不同的登录名和密码，以便他们访问不同的服务</li></ul><p id="6f17" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是以纯文本形式编写或以纯文本形式共享它是一个相当大的安全问题，因为任何登录到代码库的人都可能访问这个秘密或发起中间人攻击。为了解决这个问题，在发展中国家，我们有不同的选择，比如从另一个文件中导入机密(YAML。py等。)或将它们导出为环境变量。但是这两种方法都有一个问题:能够访问一个单独的配置文件或机器的人可以回显密码(read print)。考虑到这些问题，如果我们能够部署一个单一的解决方案，为上面提到的所有it专业人员提供解决方案，这将是非常有用的。这是介绍跳马的理想场所。</p><h1 id="23fe" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">跳马——简介</h1><p id="363b" class="pw-post-body-paragraph la lb iq lc b ld ng ka lf lg nh kd li lj ni ll lm ln nj lp lq lr nk lt lu lv ij bi translated">HashiCorp Vault是一个基于用户身份的秘密和加密管理系统。如果我们必须将其与AWS进行比较，它就像一个IAM基于用户的资源管理系统(在此处阅读Vault ),可以保护您的敏感信息。这些敏感信息可以是API加密密钥、密码和证书。</p><p id="5bf1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">其工作流程如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/0d26b74a61c4db58c8e6c49888b181c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dBxylF87ub38Jzz_"/></div></div></figure><h1 id="88ef" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">保管库的托管成本</h1><ul class=""><li id="9342" class="lw lx iq lc b ld ng lg nh lj nm ln nn lr no lv mb mc md me bi translated">本地托管:如果秘密只由本地用户或在开发阶段访问，通常使用这种方法。如果这些秘密引擎必须与其他人共享，就必须避免使用这种方法。因为它在本地开发环境中，所以没有额外的部署投资。这可以直接托管在<a class="ae np" href="https://www.vaultproject.io/downloads" rel="noopener ugc nofollow" target="_blank">一台本地机器</a>上，或者通过它的<a class="ae np" href="https://hub.docker.com/_/vault/" rel="noopener ugc nofollow" target="_blank">官方docker镜像</a>来托管</li><li id="35fe" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">公共云托管(AWS中的EC2/Azure中的虚拟机):如果想法是建立Vault与不同地区的人共享，那么在公共云上托管是个好主意。虽然我们可以通过本地服务器实现同样的目标，但前期成本和可扩展性是一个很大的问题。对于AWS，我们可以通过在EC2实例中托管Vault并创建IPs可以访问EC2的安全组来轻松保护端点。如果您更喜欢冒险，您可以将它映射到一个域名，并从Route 53路由，以便最终用户可以在域上作为服务访问vault。在使用AWS定义的域托管EC2的情况下，成本为0.0116美元/小时。</li><li id="9647" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">Vault云托管(HashiCorp云平台):如果您不想在公共云环境中建立基础架构，可以选择由vault托管的云。我们可以将其视为一个基于SaaS的云平台，使我们能够在订阅的基础上使用Vault作为服务。由于hashicorp自己管理云，我们可以期待一致的用户体验。就成本而言，它有三个生产级<a class="ae np" href="https://cloud.hashicorp.com/products/vault/pricing" rel="noopener ugc nofollow" target="_blank">选项</a>:起步版0.50美元/小时，标准版1.58美元/小时，升级版1.84美元/小时(见2022年7月)。</li></ul><h1 id="215d" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">AWS云中的自托管示例</h1><p id="4397" class="pw-post-body-paragraph la lb iq lc b ld ng ka lf lg nh kd li lj ni ll lm ln nj lp lq lr nk lt lu lv ij bi translated">我们在这个项目中的目标是在EC2中创建一个Vault实例，并将静态秘密存储在Key-Value secrets引擎中。这些秘密稍后被检索到terraform脚本中，当应用时，该脚本将从Vault Secrets引擎中提取秘密，并使用它们在AWS中创建基础结构。</p><p id="a30c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">要创建一个随时可用的存储库，我们将遵循以下步骤:</p><ol class=""><li id="7e60" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv nq mc md me bi translated">用ssh密钥创建一个EC2 Linux实例来访问它。</li><li id="3f1b" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv nq mc md me bi translated">SSH到实例中，并安装Vault以启动并运行它</li><li id="2b65" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv nq mc md me bi translated">配置阀门机密管理器</li></ol><h2 id="a222" class="nr mp iq bd mq ns nt dn mu nu nv dp my lj nw nx na ln ny nz nc lr oa ob ne iw bi translated">步骤1:创建一个EC2 Linux实例，用ssh密钥来访问它</h2><p id="f871" class="pw-post-body-paragraph la lb iq lc b ld ng ka lf lg nh kd li lj ni ll lm ln nj lp lq lr nk lt lu lv ij bi translated">要创建EC2实例并通过SSH远程访问它，我们需要创建密钥对。首先，让我们通过AWS控制台创建一个SSH密钥。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/54b647e9fb28def23121268c9b55ac87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zK08qGxweS3xdEtt"/></div></div></figure><p id="418f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一旦键被创建并下载到本地工作台中，我们就创建一个EC2 (t2.micro) Linux实例，并将其与上述键相关联。EC2的大小可以根据您的要求来选择，但通常t2.micro就足够了。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/fb99d4d310eda472e3549093a88e6fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z1a6jrT_hiHBHPIe"/></div></div></figure><h2 id="244d" class="nr mp iq bd mq ns nt dn mu nu nv dp my lj nw nx na ln ny nz nc lr oa ob ne iw bi translated"><strong class="ak">第二步:SSH进入实例并安装秘密以启动并运行</strong></h2><p id="234b" class="pw-post-body-paragraph la lb iq lc b ld ng ka lf lg nh kd li lj ni ll lm ln nj lp lq lr nk lt lu lv ij bi translated">一旦EC2的状态变为running，打开保存SSH的目录(。pem)键。打开一个终端，输入<code class="fe mk ml mm mn b">ssh -i &lt;keyname.pem&gt; ec2-user @&lt;publicdns IP4&gt;</code>。一旦我们在Ec2实例中建立了成功的SSH会话，我们就可以使用以下命令安装Vault:</p><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="b72b" class="oh mp iq mn b be oi oj l ok ol">wget -O- &lt;https://apt.releases.hashicorp.com/gpg&gt; | gpg — dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg<br/><br/>echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] &lt;https://apt.releases.hashicorp.com&gt; $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list<br/><br/>sudo apt update &amp;&amp; sudo apt install vault</span></pre><p id="c9ba" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">以上命令将在EC2环境中安装vault。有时第二个命令会抛出一些错误。如果出现错误，将<code class="fe mk ml mm mn b">$(lsb_release -cs)</code>替换为<code class="fe mk ml mm mn b">jammy</code>。[通过在创建EC2实例时将上述命令复制到EC2用户数据中，可以自动完成整个过程]。</p><h2 id="7394" class="nr mp iq bd mq ns nt dn mu nu nv dp my lj nw nx na ln ny nz nc lr oa ob ne iw bi translated"><strong class="ak">第三步:配置Hashicorp阀</strong></h2><p id="8058" class="pw-post-body-paragraph la lb iq lc b ld ng ka lf lg nh kd li lj ni ll lm ln nj lp lq lr nk lt lu lv ij bi translated">在初始化存储库之前，让我们按照以下命令确保它已正确安装:</p><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="bb71" class="oh mp iq mn b be oi oj l ok ol">vault</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/42282a17f23147bfdd426c1757344069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fCiYgCMPYP9sKIYJ"/></div></div></figure><p id="ba0f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们确保没有名为<code class="fe mk ml mm mn b">VAULT_TOKEN</code>的环境变量。为此，请使用以下命令:</p><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="365f" class="oh mp iq mn b be oi oj l ok ol">$ unset VAULT_TOKEN</span></pre><p id="0cb8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一旦我们安装了存储库，我们需要配置存储库，这是使用HCL文件完成的。这些HCL文件包含诸如backed、listeners、cluster address、UI设置等数据。正如我们在vault的体系结构中所讨论的，存储数据的后端与vault引擎有很大不同，后者即使在Vault被锁定时也是持久的(有状态资源)。除此之外，我们需要指定以下细节:</p><ul class=""><li id="e5fa" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">监听器端口:Vault监听API请求的端口。</li><li id="cdc7" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">API地址:指定要通告的地址，以路由客户端请求。</li><li id="0a97" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">群集地址:指示用于群集中Vault节点之间通信的地址和端口。为了进一步保护它，我们可以使用基于TLS的通信。这一步是可选的，只有当您想进一步保护您的环境时才能尝试。TLS证书可以在Linux中使用openssl生成。</li></ul><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="9f71" class="oh mp iq mn b be oi oj l ok ol"># Installs openssl<br/>sudo apt install openssl<br/><br/>#Generates TLS Certificate and Private Key<br/>openssl req -newkey rsa:4096 -x509 -sha512 -days 365 -nodes -out certificate.pem -keyout privatekey.pem </span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/8e0efe8365f05d9b25169db836b91920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1nNQ1ahPwX2K-rue"/></div></div></figure><p id="43aa" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">将TLS证书和私钥文件路径插入侦听器“tcp”块中它们各自的参数中。</p><ul class=""><li id="b76f" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><code class="fe mk ml mm mn b">tls_cert_file</code>:指定PEM编码文件格式的TLS证书路径。</li><li id="ecc6" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe mk ml mm mn b">tls_key_file</code>:以PEM编码的文件格式指定证书私钥的路径。</li></ul><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="5a8b" class="oh mp iq mn b be oi oj l ok ol">#Configuration in config.hcl file<br/><br/>storage "raft" { <br/>path = "./vault/data" <br/>node_id = "node1" <br/>}<br/>listener "tcp" {<br/> address = "127.0.0.1:8200" <br/>tls_disable = "true"<br/>tls_cert_file = certificate.pem<br/>tls_key_file = privatekey.pem<br/>}<br/>disable_mlock = true<br/>api_addr = "http://127.0.0.1:8200" <br/>cluster_addr = "https://127.0.0.1:8201"<br/> ui = true</span></pre><p id="e3ae" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一旦创建了这些，我们就创建了我们的后端将存放的文件夹:vault/data。</p><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="4522" class="oh mp iq mn b be oi oj l ok ol">mkdir -p ./vault/data</span></pre><p id="8500" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">完成后，我们可以使用以下命令启动vault服务器:</p><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="e408" class="oh mp iq mn b be oi oj l ok ol">vault server -config=config.hcl</span></pre><p id="372d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">完成后，我们可以使用配置文件中提到的后端及其所有设置来启动我们的Vault实例。</p><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="867d" class="oh mp iq mn b be oi oj l ok ol">export VAULT_ADDR='http://127.0.0.1:8200'<br/><br/>vault operator init</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/1146f06fb74c9f948cca2df5df957ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QadewTz6h-gi9pYm"/></div></div></figure><p id="7d79" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">初始化之后，它会创建五个名为shamir密钥的解封密钥(其中三个在默认设置下用于解封Vault)和一个初始根令牌。这是迄今为止vault唯一一次知道所有这些数据，并且这些细节将被安全地保存以启封Vault。实际上，这些shamir密钥将在项目的关键涉众之间分发，并且密钥阈值应该以这样的方式设置，即当大多数人一致同意这样做时，可以打开保险库。</p><p id="8c18" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一旦我们创建了这些密钥和初始令牌，我们需要解封保险库:</p><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="a753" class="oh mp iq mn b be oi oj l ok ol">vault operator unseal</span></pre><p id="52b6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这里我们需要提供启封密钥的阈值数量。一旦我们提供了这个，密封状态就会变为false。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/c6cfcc403d21d71b22ca91cd23159099.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/0*JoxJ_Tb72HhlagdJ"/></div></figure><p id="3751" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后，我们使用初始根令牌登录到保险库。</p><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="2734" class="oh mp iq mn b be oi oj l ok ol">vault login</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/32ec2e7911cc2c3e0afb6d4ffb39abc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*Ciz6xJOfKQnkDQ9v"/></div></figure><p id="843c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一旦认证成功，您就可以轻松地探索不同的加密引擎，如Transit secrets引擎。这有助于加密传输中的数据，例如用于安全存储密钥-值对(如密码、凭证等)的密钥-值存储。</p><p id="19d9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">从这个过程中可以看出，Vault在加密方面非常健壮，只要以一种敏感的方式处理shamir密钥和初始令牌，我们就可以确保安全性和完整性</p><p id="4aec" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您有一个非常安全的Vault引擎(由它自己的shamir密钥保护)，运行在一个免费的AWS EC2实例上(反过来，由安全组保护)！</p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><pre class="kp kq kr ks gt od mn oe bn of og bi"><span id="28ed" class="oh mp iq mn b be oi oj l ox ol"><strong class="mn ja">Want to Connect?</strong><br/><br/>If you want to connect with me, you can do so on <a class="ae np" href="https://www.linkedin.com/in/krishnadutt/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>