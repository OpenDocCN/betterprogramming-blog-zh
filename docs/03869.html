<html>
<head>
<title>7 New Features Shipping With ES2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2020附带7项新功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-new-features-shipping-with-es2020-7a2721f710fb?source=collection_archive---------4-----------------------#2020-03-10">https://betterprogramming.pub/8-new-features-shipping-with-es2020-7a2721f710fb?source=collection_archive---------4-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="690c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">GlobalThis、可选链接、类中的私有字段、nullish合并运算符等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bd020a275f3ad9220923bd5c0f7fe913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6f9EcQnJQ5KjaVnA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托马斯·弗兰科斯基在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能知道，从2015年ES6开始，每年都会发布ECMAScript的新版本，由Ecma International的TC39。ECMAScript 2020是ECMAScript语言规范的第11版。</p><p id="2962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新的迭代有它自己的一批新特性——让我们来回顾一下！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6d23" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.' globalThis '</h1><p id="bd2d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript语言现在非常流行，可以在各种各样的环境中使用——当然是在web浏览器中，但是JavaScript也可以在服务器端、智能手机上、机器人上运行，等等。</p><p id="60b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个环境都有自己的对象模型和语法来访问全局对象。正因为如此，编写能在多种环境下工作的JavaScript代码可能会很困难:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3bf0" class="ne md it na b gy nf ng l nh ni">// browser environment<br/>console.log(<strong class="na iu">window</strong>);<br/><br/>// node.js environment<br/>console.log(<strong class="na iu">global</strong>);<br/><br/>// Service worker environment<br/>console.log(<strong class="na iu">self</strong>);</span><span id="517b" class="ne md it na b gy nj ng l nh ni">// ...</span></pre><p id="2428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，通过编写一个检查当前环境的函数来跨多个平台标准化它是可能的，但是这将不再需要了！</p><p id="d4c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm na b">globalThis</code>属性现在是跨环境以一致的方式访问全局对象的标准方式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be02" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.' Promise.allSettled()'</h1><p id="4797" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nk nl nm na b">Promise.allSettled()</code>方法返回一个承诺，该承诺在所有给定承诺都已解决或被拒绝后解决，并带有一个对象数组，每个对象通过status属性描述每个承诺的结果。这使得过滤它们变得更加容易。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c85f" class="ne md it na b gy nf ng l nh ni">const p1 = new Promise((res) =&gt; res("🍕"));<br/>const p2 = new Promise((res, rej) =&gt; rej("🍍"));<br/>const p3 = new Promise((res) =&gt; res("🍺"));</span><span id="b0d3" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">Promise.allSettled</strong>([p1, p2, p3]).then(data =&gt; console.log(data));<br/>// [<br/>//   { status: "fulfilled", value: "🍕" },<br/>//   { status: "rejected", value: "🍍" },<br/>//   { status: "fulfilled", value: "🍺" },<br/>// ]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="098b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.零融合算子</h1><p id="282f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在执行属性访问时，当试图提供默认值时，nullish合并运算符是工具箱中的一个新工具。它不同于在两个值之间用<code class="fe nk nl nm na b">||</code>符号化的<em class="nn">或</em>运算符，它处理空值的方式不同。</p><p id="5abb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过比较这两个操作符来看看它是如何工作的:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ddf4" class="ne md it na b gy nf ng l nh ni">const test = {<br/>  null: null,<br/>  number: 0,<br/>  string: '',<br/>  boolean: false<br/>};</span><span id="8375" class="ne md it na b gy nj ng l nh ni">const undefinedValue = test.dog || "Cat"; // "Cat"<br/>const undefinedValue = test.dog <strong class="na iu">??</strong> "Cat"; // "Cat"</span><span id="302f" class="ne md it na b gy nj ng l nh ni">const nullValue = test.null || "Default"; // "Default"<br/>const nullValue2 = test.null <strong class="na iu">??</strong> "Default"; // "Default"</span><span id="a415" class="ne md it na b gy nj ng l nh ni">const numberValue = test.number || 1; // 1<br/>const numberValue2 = test.number <strong class="na iu">??</strong> 1; // <strong class="na iu">0</strong></span><span id="c466" class="ne md it na b gy nj ng l nh ni">const stringValue = test.string || "Hello"; // "Hello"<br/>const stringValue2 = test.string <strong class="na iu">??</strong> "Hello"; // <strong class="na iu">""</strong></span><span id="23e7" class="ne md it na b gy nj ng l nh ni">const booleanValue = test.boolean || true; // true<br/>const booleanValue2 = test.boolean <strong class="na iu">??</strong> true; // <strong class="na iu">false</strong></span></pre><p id="9c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，当且仅当<code class="fe nk nl nm na b">??</code>左侧的表达式为<code class="fe nk nl nm na b">null</code>或<code class="fe nk nl nm na b">undefined</code>时，nullish coalsceing操作符才会选择右侧的值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6af8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.可选的链接运算符</h1><p id="9acc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，当查找深嵌套在对象中的属性值或使用返回object或null/undefined的API时，人们通常必须这样检查中间值:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1ff4" class="ne md it na b gy nf ng l nh ni">// Checking for intermediate nodes:<br/>const deeplyNestedValue = obj &amp;&amp; obj.prop1 &amp;&amp; obj.prop1.prop2;</span><span id="67bb" class="ne md it na b gy nj ng l nh ni">// Checking if the node exists in the DOM:<br/>const fooInputEl = document.querySelector('input[name=foo]');<br/>const fooValue = fooInputEl &amp;&amp; fooInputEl.value;</span></pre><p id="54b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可选的链接操作符允许我们以更方便的方式处理这些情况。重写上面的例子将给出:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bb14" class="ne md it na b gy nf ng l nh ni">// Checking for intermediate nodes:<br/>const deeplyNestedValue = obj<strong class="na iu">?</strong>.prop1<strong class="na iu">?</strong>.prop2;</span><span id="bdd8" class="ne md it na b gy nj ng l nh ni">// Checking if the node exists in the DOM:<br/>const fooValue = document.querySelector('input[name=foo]')<strong class="na iu">?</strong>.value;</span></pre><h2 id="3d8f" class="ne md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated"><strong class="ak">很高兴知道</strong></h2><p id="b103" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可选的链接操作符是short-circuiting，这意味着如果<code class="fe nk nl nm na b">?.</code>的左侧计算结果为空或未定义，它将停止计算该行:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f773" class="ne md it na b gy nf ng l nh ni">// x is incremented if and only if 'a' is not null or undefined<br/>a?.[++x]</span></pre><p id="0799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一点:可选的链接操作符也适用于函数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2973" class="ne md it na b gy nf ng l nh ni">func?.(...args) // optional function or method call</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="177d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.' BigInt '</h1><p id="75c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经有了用JavaScript表示数字的<code class="fe nk nl nm na b">Number</code>。问题是，人数最多的是2⁵。超过那个，就真的不靠谱了。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="084c" class="ne md it na b gy nf ng l nh ni">const x = Number.MAX_SAFE_INTEGER; // 9007199254740991<br/>const y = x + 1; // 9007199254740992 • equal to 2^53<br/>const z = x + 2; // 9007199254740992 • well, it's broken</span></pre><p id="fe0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的:<code class="fe nk nl nm na b">BigInt</code>是一个新的原语，提供了一种表示大于2 ⁵的数的方法。它是通过在一个整数的末尾追加一个<code class="fe nk nl nm na b">n</code>来创建的:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="25f6" class="ne md it na b gy nf ng l nh ni">const aBigInteger = 9007199254740993<strong class="na iu">n</strong>;<br/>// There is also a constructor:<br/>const evenBigger = BigInt(9007199254740994); // 9007199254740994<strong class="na iu">n</strong><br/>const fromString = BigInt("9007199254740995"); // 9007199254740995<strong class="na iu">n</strong></span></pre><h2 id="0560" class="ne md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated"><strong class="ak">很高兴知道</strong></h2><p id="c8db" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个<code class="fe nk nl nm na b">BigInt</code>与一个<code class="fe nk nl nm na b">number</code>的行为基本相同，但是它们不能在一个操作中一起使用:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6d82" class="ne md it na b gy nf ng l nh ni">let sum = 1n + 2, multiplication = 1n * 2;<br/>// TypeError: Cannot mix BigInt and other types, use explicit conversions</span></pre><p id="ff74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用构造函数<code class="fe nk nl nm na b">Number()</code>将一个<code class="fe nk nl nm na b">BigInt</code>转换成一个<code class="fe nk nl nm na b">Number</code>，但是在某些情况下，您可能会失去精度。因此，建议只在代码中需要大值时使用<code class="fe nk nl nm na b">BigInt</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1800" class="ne md it na b gy nf ng l nh ni">Number(900719925474099267n); // 900719925474099300 • 🤷‍♂️</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3f0e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.动态导入()'</h1><p id="823c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">导入模块<code class="fe nk nl nm na b">import module from './module'</code>的当前形式是静态的，只接受一个字符串。它也只在运行前作为一个链接过程工作。</p><p id="7f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态的<code class="fe nk nl nm na b">import(...)</code>允许开发者能够在运行时动态加载JavaScript应用程序的一部分。这带来了当前<code class="fe nk nl nm na b">import</code>不支持的多个优势:</p><ul class=""><li id="5034" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">加载用户的语言，而不是全部加载</li><li id="0619" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">延迟加载应用程序的路由(提高性能)</li><li id="5713" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果找不到模块，可以处理失败</li></ul><h2 id="6a96" class="ne md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">它是如何工作的？</h2><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6d0f" class="ne md it na b gy nf ng l nh ni">// Used as a function, import() returns a promise that can be handled the 2 usuals ways:</span><span id="ddbf" class="ne md it na b gy nj ng l nh ni">// Using callback<strong class="na iu"><br/>import(</strong>'/module.js'<strong class="na iu">)</strong><br/>  .then((module) =&gt; {<br/>    // Do something with the module.<br/>  });</span><span id="df4c" class="ne md it na b gy nj ng l nh ni">// Using async / await<br/><strong class="na iu">async</strong> function () {<br/>  let module = <strong class="na iu">await import(</strong>'/modules.js'<strong class="na iu">)</strong>;<br/>}</span></pre><p id="1392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与通常的<code class="fe nk nl nm na b">import</code>声明相比，以下是显著的区别:</p><ul class=""><li id="212f" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe nk nl nm na b">import()</code>可以在脚本中使用，而不仅仅是在模块中</li><li id="7219" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nk nl nm na b">import()</code>可以发生在任何地方任何高度，并且不被吊起</li><li id="3684" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nk nl nm na b">import()</code>接受任意字符串(运行时确定的模板字符串，如此处所示)，而不仅仅是静态字符串</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="219c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.' String.protype.matchAll '</h1><p id="1496" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nk nl nm na b">matchAll()</code>方法返回所有匹配正则表达式(<code class="fe nk nl nm na b">RegExp</code>)的结果的迭代器，工作方式如下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1333" class="ne md it na b gy nf ng l nh ni">const regexp = RegExp('[a-z]*ball','g');<br/>const str = 'basketball handball pingpong football';<br/>const matches = str.<strong class="na iu">matchAll</strong>(regexp);</span><span id="82fa" class="ne md it na b gy nj ng l nh ni">// Since it is an iterator, you can loop trought results this way:<br/>let match = matches.next();<br/>while (!match.done) {<br/> console.log(match.value);<br/> match = matches.next();<br/>}<br/>// ["basketball", index: 0, input: "basketb...", groups: undefined]<br/>// ["handball", index: 11, input: "basketb...", groups: undefined]<br/>// ["football", index: 29, input: "basketb...", groups: undefined]</span><span id="9c1e" class="ne md it na b gy nj ng l nh ni">// One can also get an array of all results<br/>let results = [...str.matchAll(regexp)];</span></pre><h2 id="328b" class="ne md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated"><strong class="ak">很高兴知道</strong></h2><p id="e95c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用全局<code class="fe nk nl nm na b">/g</code>标志时，<code class="fe nk nl nm na b">match()</code>方法不会返回捕获组，而<code class="fe nk nl nm na b">matchAll()</code>会。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f7a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="db32" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">今年到此为止！</p><p id="49ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Babel已经有了几乎所有这些特性的插件。如果您迫不及待地想在您的项目中使用它们，以下是链接:</p><ul class=""><li id="88d7" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><a class="ae ky" href="https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator" rel="noopener ugc nofollow" target="_blank">@ babel/plugin-proposal-nullish-coalescing-operator</a></li><li id="f6e5" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://babeljs.io/docs/en/babel-plugin-proposal-private-methods" rel="noopener ugc nofollow" target="_blank">@ babel/plugin-proposal-private-methods</a></li><li id="a0bc" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank">@ babel/plugin-proposal-optional-chaining</a></li><li id="667c" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://babeljs.io/docs/en/babel-plugin-syntax-bigint" rel="noopener ugc nofollow" target="_blank">@ babel/plugin-syntax-bigint</a></li><li id="2fc7" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import" rel="noopener ugc nofollow" target="_blank">@ babel/plugin-语法-动态-导入</a></li></ul><p id="600f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>