<html>
<head>
<title>Build An Article Reader Web App Using Free APIs and JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用免费的API和JavaScript构建一个文章阅读器Web应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-an-article-reader-web-app-using-free-apis-and-javascript-ce1100d43a21?source=collection_archive---------12-----------------------#2021-06-11">https://betterprogramming.pub/build-an-article-reader-web-app-using-free-apis-and-javascript-ce1100d43a21?source=collection_archive---------12-----------------------#2021-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f3e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">下面是我如何在一个下午构建一个web应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b40a2fa787316e41915b5d67bed6db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pu4lygfmLgmPP0CT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">西蒙·瑞在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f42e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我经历建立我的简历的漫长过程时，我决定开始建立一些我自己的个人项目。我以前已经开始这样做一百万次了，但是这一次，我实际上要完成其中的一些。</p><p id="1af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道，我知道…每个人都这么说。</p><p id="d7c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你猜怎么着？我已经完成一个了！接招吧，拖延症。</p><p id="c9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将带你经历我希望在未来几个月中建立的许多个人项目中的第一个。我希望你觉得这个项目有帮助，或者至少有点有趣。希望它能启发你自己的一些项目！</p><h1 id="77fb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">定义项目</h1><p id="32be" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我想建立一个可以放在我的文件夹中的项目——可以展示一些与我申请的开发人员工作相关的技能。我还希望构建一些有趣且有点用处的东西。</p><p id="6944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我思考这个问题时，我想到了两个我想解决的小而紧迫的难题:</p><ul class=""><li id="b226" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">我花了太多时间在手机上浏览无聊的内容。</li><li id="3f17" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">我没有花足够的时间阅读对我的课程有实际帮助的计算机科学材料。</li></ul><p id="2351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这两个痛点，我决定了一个解决方案。我会开发一个文章阅读器应用程序，只给我提供计算机科学研究和最近的科技相关新闻。这样，我就可以有东西可以无意识地滚动<em class="ng">和</em>可以更容易地获得有用的阅读材料。</p><p id="3510" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得这是个好主意，所以我决定试一试。</p><h1 id="9cec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤1:寻找免费的API</h1><p id="dc2d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">第一步是弄清楚从哪里获取文章以及如何获取。在Google上快速搜索免费的计算机科学内容后，我发现有许多免费的公共API可以让我访问我需要的内容。</p><p id="ef66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为参考，这里有两个很好的可用公共API列表。</p><ul class=""><li id="6ac1" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">公共API—免费API的集合列表</li><li id="9609" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://public-apis.io/" rel="noopener ugc nofollow" target="_blank">https://public-apis.io/</a></li></ul><p id="a29f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择只从一个API开始:arXiv API。arXiv在广泛的学术领域提供了大量严谨和前沿研究的免费访问，这对我的项目来说是完美的。</p><h1 id="a40c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">第二步:阅读API文档</strong></h1><p id="f319" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对我来说幸运的是，arXiv API维护得非常好，并且有很好的文档记录。这里可以找到<a class="ae ky" href="https://arxiv.org/help/api/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="84c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据文档，可以通过多种方式调用API。也许最简单的方法是通过对正确的URL发出HTTP GET或POST请求来从arXiv获取文章。使用这种方法，只需更改URL的参数，就可以确定您想要哪些文章。这是我采用的方法。</p><p id="3969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的第一个问题是如何建立我的网址。arXiv提供的基本URL如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="96be" class="nm lw it ni b gy nn no l np nq">http://export.arxiv.org/api/{method_name}?{parameters}</span></pre><p id="2f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种格式中，有两个重要的组成部分:我们想要使用的方法和我们想要定义的搜索参数。这些在url中由<code class="fe nr ns nt ni b">method_name</code>和<code class="fe nr ns nt ni b">parameters</code>表示。</p><p id="33f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于我的目的，从arXiv数据库中检索文章的最简单方法是使用query方法。arXiv为使用查询方法提供了一个简单的接口。所有需要做的就是将<code class="fe nr ns nt ni b">query</code>插入<code class="fe nr ns nt ni b">method_name</code>位置，就在<code class="fe nr ns nt ni b">?</code>的前面。这样做的时候，我的URL看起来像这样:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="af99" class="nm lw it ni b gy nn no l np nq">http://export.arxiv.org/api/query?{parameters}</span></pre><p id="7204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我需要弄清楚URL中包含哪些参数。为此，我将重点缩小到三个具体标准:</p><ul class=""><li id="83fd" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">我对学习更多关于计算机科学研究的一些特定领域感兴趣。我选择了机器学习、博弈论、数据结构和算法设计。</li><li id="74cd" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">我希望它们越近越好。</li><li id="17a7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">我只想要其中的一小部分——刚好够放在一个漂亮干净的饲料中。</li></ul><p id="cc20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了缩小搜索范围，只搜索符合这些标准的文章，arXiv允许用户将多个参数用一个<code class="fe nr ns nt ni b">&amp;</code>符号连接起来。</p><p id="5aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要的第一个参数是<code class="fe nr ns nt ni b">search_query</code>参数。此参数采用一个表示要搜索的特定条件的字符串。换句话说，API接口为用户提供了一组九个不同的“前缀”和“解释”，我们可以用它们来缩小搜索查询的范围。</p><p id="745a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，我在寻找三个特定类别的计算机科学文章:机器学习、博弈论、数据结构和算法设计。在arXiv API中，我可以通过将它们链接在一起来搜索所有这三个类别，如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b606" class="nm lw it ni b gy nn no l np nq">search_query=cat:cs.LG+AND+cat:cs.GT+AND+cat:cs.DS</span></pre><p id="148b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比看起来要简单得多，查询用连接器<code class="fe nr ns nt ni b">+AND+</code>链接了三个单独的<code class="fe nr ns nt ni b">prefix:explanation</code>对。在这三篇文章中，我都使用前缀<code class="fe nr ns nt ni b">cat</code>按类别搜索，后跟三个“解释”、“T10”(机器学习)、<code class="fe nr ns nt ni b">cs.GT</code>(博弈论)和<code class="fe nr ns nt ni b">cs.DS</code>(数据结构)，以搜索我的三个特定主题类别。</p><p id="57a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进一步过滤查询结果，我将几个参数连接在一起:</p><p id="7023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了按照最后更新日期对返回的文章进行排序，我使用了:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="469a" class="nm lw it ni b gy nn no l np nq">sortBy=lastUpdatedDate</span></pre><p id="5697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保文章从最近到最近显示，我使用了:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f8cb" class="nm lw it ni b gy nn no l np nq">sortOrder=descending</span></pre><p id="b500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是不必要的，但我甚至指定从第一篇最近的文章开始，而不是第三篇或第四篇最近的文章:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b177" class="nm lw it ni b gy nn no l np nq">start=0</span></pre><p id="5960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了确保我们一次只显示10篇文章，我还添加了:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b676" class="nm lw it ni b gy nn no l np nq">max_results=10</span></pre><p id="d4d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我的完整网址看起来像这样:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b55d" class="nm lw it ni b gy nn no l np nq">http://export.arxiv.org/api/query?search_query=cat:cs.GL&amp;sortBy=lastUpdatedDate&amp;sortOrder=descending&amp;start=0&amp;max_results=10</span></pre><h1 id="f0c6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤3:用XMLHttpRequest获取数据</h1><p id="5e48" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">定义了URL之后，我接下来需要关注如何将查询的数据拉入我的应用程序。</p><p id="7e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据arXiv文档，我发现将文章放入web应用程序的最佳方式是使用XMLHttpRequest。</p><p id="1333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不熟悉XMLHttpRequest (XHR)对象，它们是一种与web服务器交互的方法，允许您从URL检索数据。它们使用起来相当简单，是AJAX编程的一个常见方面。</p><p id="736c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想了解更多关于XMLHttpRequest对象的知识，这里有一些快速的文章可以帮助您快速入门:</p><ul class=""><li id="a290" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank">“XMLHttpRequest”——MDN Web Docs</a></li><li id="d7b6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank">“XMLHttpRequest”——维基百科</a></li></ul><p id="a8c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的项目中使用XHR非常简单。我所要做的就是在代码中定义一个XHR对象，并将其指向正确的URL。</p><p id="daab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要做的是使用构造函数方法<code class="fe nr ns nt ni b">XMLHttpRequest()</code>声明我的XHR对象的一个实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="aa65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">够简单！这一行简单地声明了一个新的XHR对象，我可以用它来查询数据。</p><p id="ee93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">XMLHttpRequests本身就是一个API，它为用户提供了一组有用的内置方法和属性。因此，我可以使用内置方法通过新的<code class="fe nr ns nt ni b">xhr</code>对象来提取数据。</p><p id="6b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我使用了<code class="fe nr ns nt ni b">.open()</code>方法来打开对我的URL的GET请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt ni b">.open()</code>方法简单地说:</p><ul class=""><li id="fe91" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><code class="fe nr ns nt ni b">GET</code>是我正在使用的HTTP方法。</li><li id="8702" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe nr ns nt ni b">http://export.arxiv.org/api/query?search_query=cat:cs.GL&amp;sortBy=lastUpdatedDate&amp;sortOrder=descending&amp;start=0&amp;max_results=10</code>是我请求的网址。</li><li id="631a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">该函数应该异步运行，由最后的布尔值<code class="fe nr ns nt ni b">True</code>指定。</li></ul><p id="9f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后,<code class="fe nr ns nt ni b">.open()</code>方法初始化HTTP请求。</p><p id="536f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦发出HTTP请求，我就可以指定如何处理返回的响应。</p><p id="7a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我可以使用XMLHttpRequest API提供的另一个内置属性，即<code class="fe nr ns nt ni b">.onreadystatechange </code>事件处理程序。每当我的<code class="fe nr ns nt ni b">xhr</code>对象的<code class="fe nr ns nt ni b">readyState</code>属性改变时，这个事件处理器执行一个回调函数。</p><p id="22f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt ni b">readyState</code>属性返回客户端请求的状态。我们可以在这里进行更详细的讨论，但是只需要注意到<code class="fe nr ns nt ni b">readyState</code>属性只有五种状态:<code class="fe nr ns nt ni b">UNSENT</code>、<code class="fe nr ns nt ni b">OPENED</code>、<code class="fe nr ns nt ni b">HEADERS_RECEIVED</code>、<code class="fe nr ns nt ni b">LOADING</code>或<code class="fe nr ns nt ni b">DONE</code>。特定的状态让我知道我的GET请求的状态。我的回调函数根据状态决定我如何处理GET请求返回的响应。</p><p id="37f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt ni b">.onreadystatechange</code>处理程序的基本语法是:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2286" class="nm lw it ni b gy nn no l np nq">XMLHttpRequest.onreadystatechange = callback;</span></pre><p id="006e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的项目环境中，我像这样设置处理程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="626d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决定如何在我的web页面上显示数据的实际代码最终放在了我的回调函数中。我马上会谈到这一点，但是首先，我需要将最后一个<code class="fe nr ns nt ni b">XMLHttpRequest</code>方法添加到我的代码中:方法<code class="fe nr ns nt ni b">.send()</code>。</p><p id="1f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt ni b">.send()</code>方法只是将我的请求发送给服务器。因为我的请求是异步发送的，所以这个方法将在<code class="fe nr ns nt ni b">.open()</code>方法执行后立即返回。在我的代码中是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b9a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也超级容易！此时，我的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="98bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用这段代码，我已经创建了:</p><ul class=""><li id="6690" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">一个<code class="fe nr ns nt ni b">XMLHttpRequest</code>对象。</li><li id="514b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">带有对象的<code class="fe nr ns nt ni b">GET</code>请求。</li><li id="616a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">用于<code class="fe nr ns nt ni b">GET</code>请求的事件处理程序。</li><li id="ac23" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">实际发送请求的send方法。</li></ul><p id="4abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">负责我项目的核心部分。现在我可以开始有趣的事情了:数据解析！</p><h1 id="a67e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤4:解析响应文本</h1><p id="c606" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">既然我已经构建了我的简单web应用程序的框架，我可以着手处理如何处理来自我的<code class="fe nr ns nt ni b">GET</code>请求的响应。</p><p id="b189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做的第一件事是检查我的请求是否正确完成。我还需要检查响应状态。</p><p id="3068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查我的请求是否正确完成，我需要检查<code class="fe nr ns nt ni b">readyState</code>是否返回了一个状态<code class="fe nr ns nt ni b">DONE</code>——如果它返回了其他的东西，这意味着我的函数还没有完成，所以不需要发生任何事情。</p><p id="5838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还需要检查返回的状态是否等于200，这表示请求成功了。</p><p id="b81d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现这两种检查，我的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5a5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我的响应是成功的，我应该能够看到响应数据。如果我想检查我的代码是否工作正常，我可以插入一个快速的<code class="fe nr ns nt ni b">console.log(this.responseText)</code>,其中“做一些有成功响应的事情”注释是为了查看返回的数据。这样做将在浏览器控制台中显示如下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API响应文本—摘自arXiv API用户手册的示例</p></figure><p id="2aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的响应文本是格式化的XML数据。具体来说，arXiv API使用一种称为Atom的XML语法。无需深究Atom的细节，只需知道Atom是一种用于发布web内容的流行方法，其功能类似于RSS提要。</p><p id="5918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于我的目的，我只需要知道如何访问以这种格式提供给我们的数据。这就是JavaScript代码的用武之地。</p><p id="eefa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应数据以XML字符串的形式提供给我们。然而，为了实际使用这个字符串，我需要某种方法来解析它。幸运的是，我没有手动这么做(尽管我确信那会很有趣)，而是做了一点小手脚，使用了另一个名为DOMParser的API来解析XML字符串。</p><p id="6703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像使用XMLHttpRequest API一样，我所要做的就是使用一个构造函数来创建一个新的DOMParser对象，我可以用它来为我做脏活:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="98d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我首先创建了一个名为<code class="fe nr ns nt ni b">domparser</code>的新DOMParser对象。接下来，我使用我的DOMParser对象来调用<code class="fe nr ns nt ni b">.parseFromString()</code>方法，该方法再次省略了细节，获取我的字符串并将其转换为XML对象。</p><p id="b193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析后的XML对象看起来与上面提到的字符串输出完全一样，但是现在我可以使用标准文档对象模型接口中可用的方法，通过标记名选择XML数据的单个元素。</p><p id="4041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于对XML响应的元数据不感兴趣，我接下来只专注于响应数据的<code class="fe nr ns nt ni b">&lt;entry&gt;</code>标记中的数据。为此，我只需使用<code class="fe nr ns nt ni b">.getElementsByTagName()</code>方法选择XML数据中的每个<code class="fe nr ns nt ni b">&lt;entry&gt;</code>标签。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="3c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行代码产生了一个由<code class="fe nr ns nt ni b">&lt;entry&gt;</code>数据组成的可迭代数组。条目数据包含我的文章阅读器所需的所有信息，并排除了不必要的元数据，如更新日期或版本号。</p><h1 id="2605" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤HTML标记</h1><p id="83a9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我有了要插入到应用程序中的数据，我需要编写一点HTML标记来确定在哪里插入我的文章。</p><p id="9577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只需要给文章阅读器页面一个简单的标题，并创建一个div，我可以在我的网页上显示文章。我的标记看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ac4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给了我一个简单得可笑的网页，作为我的文章提要的容器。鉴于我对简单性的偏好，页面看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/beb9d55cb11d4a13ed41582fe34937d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6t2w5oadC08GHuhyaJ2ASQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的网页</p></figure><p id="27ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我可以将我的文章提要直接插入到代码中有评论的页面中。</p><h1 id="6e31" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤6:用JavaScript显示信息</h1><p id="9966" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了决定如何显示文章提要，我从Medium和其他新闻提要中获得了一些灵感。通常，大多数文章提要如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/be015a8f6e53b181714726ec661a99ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*GdhPUqVT8G398qUQBwVk1g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">中等物品进给</p></figure><p id="5002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单明了，这些订阅源只显示关于每篇文章的一些信息——足以帮助读者判断文章是否值得一读。提要显示文章的标题(也可以作为文章的链接)、作者姓名、出版物名称、副标题和一些小的元数据，如发表的数据和文章的长度。</p><p id="b672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纯粹为了让我的文章阅读器尽可能简单，我决定只显示每篇文章的标题(带有文章pdf的链接)和一段400字符的文章摘要。这就是我需要的所有信息，来告诉我这篇文章是否值得一读。</p><p id="9fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这个期望的显示，我决定遍历我的<code class="fe nr ns nt ni b">&lt;entry&gt;</code>标签数组，并将每个链接、标题和摘要片段放入它们自己的数组中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给了我三个不同的数组:一个包含链接，一个包含标题，一个包含摘要。然后，我可以使用这三个数组将我的信息输入到我的网页中。</p><p id="a987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，首先，我还需要做一件事。因为摘要的长度不同，所以我需要对每个摘要应用一个映射函数，将它们缩减到400个字符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给了我一个包含10个摘要的数组，每个摘要不超过400个字符。</p><p id="a8d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我必须构建HTML来插入到我的文档中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="41b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我在一个名为parsed的新数组中创建了10个元素。每个元素都是一个div元素，代表一篇文章。每篇文章都包含一个标题，一个到实际pdf的链接，以及一个直接来自文章摘要的400个字符的摘要。</p><p id="2042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，JavaScript任务的最后一步是将每篇文章一篇接一篇地插入实际的网页。我通过遍历解析过的数组并使用DOM方法<code class="fe nr ns nt ni b">.insertAdjacentHTML()</code>将每篇文章插入到网页中来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="fae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确完成后，我的网页上的提要如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/3d77cdb0bb2b2f109a3489b781c0ea97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mw-PCea93MuwqdApAz9dKw.png"/></div></div></figure><p id="7191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是我想要的！我的feed给了我arXiv数据库中最近十篇机器学习、博弈论和数据结构文章的标题和摘要。此外，因为我将提要创建为我先前存在的portfolio网站上的一个页面，所以提要已经使用了一点CSS样式。</p><p id="3566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为参考，下面是我的全部JavaScript代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b2b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的就是添加更多的CSS。</p><h1 id="fc1d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤7:添加一些CSS</h1><p id="5db2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">因为这个项目更多的是学习如何使用API，所以我保持我的CSS非常简单。我只需要把文章隔开一点，把标题和摘要区分开来。</p><p id="ed87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我在我的个人网站中加入了这个项目，所以我使用了Sass并使用了一个变量<code class="fe nr ns nt ni b">$spacer</code>。这个项目非常简单，实际上并不需要预处理器，但这就是我所做的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加一些样式后，最终结果看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/7248c8358b302b995e514d231e468773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKe7_0YpSCHumkNVfPlhNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">成品阅读器</p></figure><h1 id="4059" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第七步:快乐阅读！</h1><p id="a477" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">就是这样！一个非常简单的文章阅读器，使用免费的API和一些简单的HTML、CSS和JavaScript。</p><p id="6e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个项目目前的形式非常简单——可能简单到无法真正调用一个应用程序——但将来我有很多方法可以扩展这个项目。例如，我可以很容易地添加一个输入表单，让用户定制他们的搜索，而不是将我的搜索查询直接硬编码到我的代码中。这将非常像一个典型的搜索栏，并增加了用户互动的元素，使其更像应用程序。</p><p id="6952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我想变得真正疯狂，我还可以添加其他免费API，并引入其他文章来源，使它更像一个典型的新闻提要。我甚至可以提供过滤文章的功能，这取决于那天我想读什么。</p><p id="bbf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，那是另一个项目。现在，我将继续享受我的简单项目！</p><p id="cbdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看完成的项目，你可以在我的网站<a class="ae ky" href="http://mattdemichele.co/article-reader" rel="noopener ugc nofollow" target="_blank">这里</a>看到它。这不是世界上最漂亮的项目，也不是最令人印象深刻的项目。但是，嘿，这是一个好的开始。更不用说，我现在有别的东西可以滚动，而不是愚蠢的狗TikToks！</p><p id="bb6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这个项目，并发现我的思考很有帮助。一如既往的感谢阅读！当然，感谢arXiv使用它的开放访问互操作性。</p></div></div>    
</body>
</html>