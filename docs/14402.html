<html>
<head>
<title>Exploring Next.js 13's Data Fetching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Next.js 13的数据提取</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-next-js-13-data-fetching-220d7cca8066?source=collection_archive---------3-----------------------#2022-12-09">https://betterprogramming.pub/a-deep-dive-into-next-js-13-data-fetching-220d7cca8066?source=collection_archive---------3-----------------------#2022-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4024" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Next.js 13测试版功能的快速概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17d93f8046e3e5ffdd39f8225f880b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2UY_URK4Q_uAeLnZ16GyQ.png"/></div></div></figure><p id="cef1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Next.js 13以一种有些令人困惑的方式登陆。增加了许多显著的东西；不过，好的部分还是Beta。尽管如此，Beta特性给了我们关于Next.js的未来将如何形成的重要信号，所以有很好的理由密切关注它们，即使你打算等待采用它们。</p><p id="bff9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文是关于Beta特性的系列体验的一部分。今天，让我们来看看最不成熟的部分——新的<strong class="kw iu">数据获取模式</strong>。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="eea4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Next.js 13之前，页面级数据获取模式非常简单:</p><ul class=""><li id="f4cc" class="lx ly it kw b kx ky la lb ld lz lh ma ll mb lp mc md me mf bi translated">如果您的页面(大部分)是静态的，那么实现一个<code class="fe mg mh mi mj b">getStaticProps</code>来获取数据，以便在构建时(以及在<a class="ae mk" href="https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration" rel="noopener ugc nofollow" target="_blank"> ISR </a>时)获取数据。</li><li id="2a96" class="lx ly it kw b kx ml la mm ld mn lh mo ll mp lp mc md me mf bi translated">如果您的页面是动态的，那么在服务器端实现一个<code class="fe mg mh mi mj b">getServerSideProps</code>来获取每个请求的数据。</li><li id="250a" class="lx ly it kw b kx ml la mm ld mn lh mo ll mp lp mc md me mf bi translated">对于依赖于用户交互的数据，在页面呈现后，在客户端的<code class="fe mg mh mi mj b">useEffect</code>钩子内提取。</li></ul><p id="da45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这在Next.js 13中得到了彻底的革新(如果你选择实验性的特性的话)。但是在我们看到新的东西之前，让我们反思一下旧世界的问题。</p><h1 id="d080" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">旧模式的问题</h1><h2 id="4345" class="ni mr it bd ms nj nk dn mw nl nm dp na ld nn no nc lh np nq ne ll nr ns ng nt bi translated">1.看起来不自然</h2><pre class="kj kk kl km gt nu mj nv bn nw nx bi"><span id="cf14" class="ny mr it mj b be nz oa l ob oc">export default function Page({ data }) {<br/>  // Render data...<br/>}<br/><br/>export async function getServerSideProps() {<br/>  const res = await fetch(`https://.../data`)<br/>  const data = await res.json()<br/>  return { props: { data } }<br/>}</span></pre><p id="9047" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mg mh mi mj b">getServerSideProps</code>的唯一目的是为<code class="fe mg mh mi mj b">Page</code>计算道具，然而你必须将它们作为两个独立的功能并排放置。我通常不反对基于约定的API，但是这种模式看起来不必要的冗长。</p><h2 id="124d" class="ni mr it bd ms nj nk dn mw nl nm dp na ld nn no nc lh np nq ne ll nr ns ng nt bi translated">2.这经常会导致“支柱钻探”</h2><p id="1cc5" class="pw-post-body-paragraph ku kv it kw b kx od ju kz la oe jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">“道具演练”是指当你在渲染树的某个很高的位置有一个复杂的状态对象，并且需要向下传递它的一部分(或全部)时。写起来既繁琐，读起来又费劲。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/f29646fe75928cc1aad35893ce870db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Lj9r7hpielQy_S5W.png"/></div></div><p class="oj ok gj gh gi ol om bd b be z dk translated"><a class="ae mk" href="https://blog.logrocket.com/solving-prop-drilling-react-apps/" rel="noopener ugc nofollow" target="_blank">https://blog . log rocket . com/solving-prop-drilling-react-apps/</a></p></figure><p id="f8b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然prop drilling不是SSR或SSG特有的，但是数据获取函数——<code class="fe mg mh mi mj b">getStaticProps</code>和<code class="fe mg mh mi mj b">getServerSideProps</code>——是它的自然来源。因为在采用SSR/SSG时，您希望在服务器端为一个页面获取所有可能的数据，而数据获取模式要求它发生在一个集中的地方；你将不得不沿着树传播一大块道具。</p><p id="f5e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有适当的补救措施，比如使用上下文API或<a class="ae mk" href="https://reactjs.org/docs/composition-vs-inheritance.html" rel="noopener ugc nofollow" target="_blank">组件组合模式</a>，但是这要么阻碍了组件的可重用性，要么要求你仔细设计它们。</p><p id="82ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，问题的根本原因是数据获取不能与使用数据的组件并置。</p><h2 id="ca76" class="ni mr it bd ms nj nk dn mw nl nm dp na ld nn no nc lh np nq ne ll nr ns ng nt bi translated">3.要么全有，要么全无</h2><p id="33ff" class="pw-post-body-paragraph ku kv it kw b kx od ju kz la oe jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">当使用<code class="fe mg mh mi mj b">getServerSideProps</code>时，无论页面加载是由浏览器重新加载还是客户端路由触发，新的页面内容都不会显示，直到数据提取完全完成(异步<code class="fe mg mh mi mj b">getServerSideProps</code>函数解析)。如果您的页面同时包含“快速数据”和“慢速数据”，这可能会有问题。例如，data dashboard就是一个典型的场景:一些卡可以瞬间加载，而其他卡可能需要很多秒。</p><h1 id="af56" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Next.js 13中有什么改进</h1><p id="50dd" class="pw-post-body-paragraph ku kv it kw b kx od ju kz la oe jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">Next.js 13中引入的新数据获取模式抛弃了您所熟悉的一切:<code class="fe mg mh mi mj b">getStaticProps</code>、<code class="fe mg mh mi mj b">getServerSideProps</code>，甚至对于客户端获取，还有一个新的<code class="fe mg mh mi mj b">use</code>钩子可能会取代<code class="fe mg mh mi mj b">useEffect</code>中的旧获取方式。</p><p id="71b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">新模式与React服务器组件深度耦合。如果您对它不熟悉，最好查看本系列的前一篇文章:</p><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/fun-with-next-js-13-server-components-fd5f886c31f3"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">探索Next.js 13服务器组件</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">Next.js 13测试版特性的快速概述</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">better编程. pub</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><p id="6d8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，这些新特性仍处于试验阶段，我不建议在生产中使用它们。</p><h2 id="f9fc" class="ni mr it bd ms nj nk dn mw nl nm dp na ld nn no nc lh np nq ne ll nr ns ng nt bi translated">异步服务器组件</h2><p id="1912" class="pw-post-body-paragraph ku kv it kw b kx od ju kz la oe jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">在过去，组件是同步的，你不能在组件的顶层<code class="fe mg mh mi mj b">await</code>。在Next.js 13中，默认情况下所有组件都是“服务器”，并且可以是异步的。最后，我们可以在React组件中使用我们熟悉的async/await语法。</p><p id="0818" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这使得数据获取更加容易和灵活。最好的事情是，您可以将服务器端获取逻辑分布到多个位置，并将它们与使用数据的组件放在一起。</p><p id="c72e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子，两个组件都从API获取随机报价:</p><pre class="kj kk kl km gt nu mj nv bn nw nx bi"><span id="ee44" class="ny mr it mj b be nz oa l ob oc">// app/server-async-fetching/page.js<br/><br/>// a page containing a fast-loading and a slow-loading components,<br/>// both are server components<br/><br/>import Quote from '../../components/server/Quote';<br/><br/>export default function AsyncLoading() {<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;Quote /&gt;<br/>            &lt;Quote slow={true} /&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><pre class="pf nu mj nv bn nw nx bi"><span id="53ab" class="ny mr it mj b be nz oa l ob oc">// lib/quote.js<br/><br/>// utility for fetching random famous quotes from API, allowing simulation of a<br/>// slow request<br/><br/>import sleep from 'sleep-promise';<br/><br/>export async function getQuote(delay = 0) {<br/>    if (delay) {<br/>        await sleep(delay);<br/>    }<br/>    return (<br/>        await fetch('https://api.quotable.io/random?tags=technology')<br/>    ).json();<br/>}</span></pre><pre class="pf nu mj nv bn nw nx bi"><span id="9bf4" class="ny mr it mj b be nz oa l ob oc">// components/server/Quote.js<br/><br/>import { getQuote } from '../../lib/quote';<br/>import os from 'os';<br/><br/>export default async function Quote() {<br/>    const quote = await getQuote(slow ? 2000 : 0);<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;p&gt;<br/>                {slow ? 'Slow' : 'Fast'} component rendered on<br/>                &lt;span&gt;${os.hostname()}&lt;/span&gt;<br/>            &lt;/p&gt;<br/>            &lt;blockquote&gt;<br/>                {quote.content}<br/>            &lt;/blockquote&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/f7cbfbba8b3df1ea4bfa9f28e9ca49bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ex3anFuWTt5Fuzw.gif"/></div></div><p class="oj ok gj gh gi ol om bd b be z dk translated">从API获取报价的运行结果</p></figure><p id="f6e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是可行的，有了更干净的异步/等待代码；然而，它仍然受到“全有或全无”问题的困扰。只有当快速和慢速组件都完成获取时，页面才会呈现。</p><p id="16f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过在组件周围添加<code class="fe mg mh mi mj b">&lt;Suspense /&gt;</code>来改进它。悬念最初是React为了支持<a class="ae mk" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank">代码拆分</a>而加入的；现在，它可以用于为尚未解析的异步组件提供后备UI，因此它们可以无阻塞地呈现:</p><pre class="kj kk kl km gt nu mj nv bn nw nx bi"><span id="5c89" class="ny mr it mj b be nz oa l ob oc">export default function AsyncLoading() {<br/>    return (<br/>        &lt;&gt;<br/>            &lt;div&gt;<br/>                &lt;Suspense fallback={&lt;p&gt;Fast component loading...&lt;/p&gt;}&gt;<br/>                    &lt;Quote /&gt;<br/>                &lt;/Suspense&gt;<br/><br/>                &lt;Suspense fallback={&lt;p&gt;Slow component loading...&lt;/p&gt;}&gt;<br/>                    &lt;Quote slow={true} /&gt;<br/>                &lt;/Suspense&gt;<br/>            &lt;/div&gt;<br/>        &lt;/&gt;<br/>    );<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/9cdcdbec4579d38fb0970f7848ebea6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fe9hfWhE8P0KSsiP.gif"/></div></div><p class="oj ok gj gh gi ol om bd b be z dk translated">从API获取报价的运行结果—改进。</p></figure><p id="a237" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在好多了。您可以看到页面及其两个子组件的呈现是完全异步的。React扩展了悬念的功能，支持任意的异步操作。它现在可以很好地与异步服务器组件一起工作。</p><p id="f9f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">悬疑的酷之处在于“取消挂起”组件不需要额外的API请求或WebSocket连接。相反，通过将虚拟DOM(包装在<code class="fe mg mh mi mj b">&lt;script/&gt;</code>中)附加到HTML文档，新的页面内容被传输到浏览器。这可以通过查看文档请求的时间来确认:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/56f8f072cb9093d8dc9c1541e599a7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gotAW5DqdZH_year.png"/></div></div><p class="oj ok gj gh gi ol om bd b be z dk translated">获取HTML文档的Chrome网络活动</p></figure><h2 id="473b" class="ni mr it bd ms nj nk dn mw nl nm dp na ld nn no nc lh np nq ne ll nr ns ng nt bi translated">自动重复数据删除<code class="fe mg mh mi mj b">fetch</code></h2><p id="b9aa" class="pw-post-body-paragraph ku kv it kw b kx od ju kz la oe jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">您可能已经注意到的另一件有趣的事情是，尽管快速组件和慢速组件分别发出API请求(使用fetch ),但是它们得到了相同的引用内容。这是由于React的另一个重要更新——fetch调用(在服务器端)会自动进行重复数据删除:</p><blockquote class="ph pi pj"><p id="1b48" class="ku kv pk kw b kx ky ju kz la lb jx lc pl le lf lg pm li lj lk pn lm ln lo lp im bi translated"><em class="it">如果您需要在一个树的多个组件中获取相同的数据(例如当前用户)，Next.js将自动在临时缓存中缓存具有相同输入的</em> <code class="fe mg mh mi mj b"><em class="it">fetch</em></code> <em class="it">请求。——</em><a class="ae mk" href="https://beta.nextjs.org/docs/data-fetching/fundamentals" rel="noopener ugc nofollow" target="_blank">https://beta.nextjs.org/docs/data-fetching/fundamentals</a></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/a7ab369c4c25a67889aaa32e54b5007d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9N7CCwD6JsYJRaXR.png"/></div></div><p class="oj ok gj gh gi ol om bd b be z dk translated"><a class="ae mk" href="https://beta.nextjs.org/docs/data-fetching/fundamentals#automatic-fetch-request-deduping" rel="noopener ugc nofollow" target="_blank">https://beta . nextjs . org/docs/data-fetching/fundamentals # automatic-fetch-request-dedupling</a></p></figure><p id="7435" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这有助于我们解决旧数据获取模式的另一个问题——道具钻取。通过自动提取重复数据删除，在渲染过程中提取相同的资源只会生成一个HTTP请求，因此您可以自由地在需要渲染数据的地方提取数据，而不必担心额外的成本。很酷，不是吗？</p><h2 id="d32f" class="ni mr it bd ms nj nk dn mw nl nm dp na ld nn no nc lh np nq ne ll nr ns ng nt bi translated">客户端数据提取</h2><p id="7716" class="pw-post-body-paragraph ku kv it kw b kx od ju kz la oe jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">在以前版本的Next.js(和React)中，客户端数据获取不在框架的考虑范围之内。你可以使用任何你想要的库，第三方工具如<a class="ae mk" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank"> SWR </a>和<a class="ae mk" href="https://react-query-v3.tanstack.com/" rel="noopener ugc nofollow" target="_blank">反应查询</a>很好地解决了这个问题。</p><p id="d89c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Next.js 13(应该更公平地说是最新的React)向前迈进了一步，提供了一个内置的<code class="fe mg mh mi mj b">use</code>钩子作为从承诺中解开数据的通用API。不如直接用<code class="fe mg mh mi mj b">async</code>/<code class="fe mg mh mi mj b">await</code>(React解释的<a class="ae mk" href="https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#why-cant-client-components-be-async-functions" rel="noopener ugc nofollow" target="_blank">)理想，但是让客户端抓取感觉足够接近服务器端。</a></p><p id="11a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过一个例子再次看看它是如何工作的(所有组件客户端组件，因为它们被标记为“使用客户端”):</p><pre class="kj kk kl km gt nu mj nv bn nw nx bi"><span id="4508" class="ny mr it mj b be nz oa l ob oc">// app/client-fetching/page.js<br/><br/>'use client';<br/><br/>import { useState, Suspense } from 'react';<br/>import Quote from '../../components/client/Quote';<br/><br/>export default function ClientFetching() {<br/>    // use a button to toggle the loading of components to make sure <br/>    // they're rendered on the client-side<br/>    const [show, setShow] = useState(false);<br/><br/>    return (<br/>        &lt;&gt;<br/>            &lt;h1&gt;Client Fetching&lt;/h1&gt;<br/>            &lt;button onClick={() =&gt; setShow(true)}&gt;<br/>                Show Components<br/>            &lt;/button&gt;<br/><br/>            {show &amp;&amp; (<br/>                &lt;&gt;<br/>                    &lt;div&gt;<br/>                        &lt;Suspense fallback={&lt;p&gt;Fast component loading...&lt;/p&gt;}&gt;<br/>                            &lt;Quote /&gt;<br/>                        &lt;/Suspense&gt;<br/><br/>                        &lt;Suspense fallback={&lt;p&gt;Slow component loading...&lt;/p&gt;}&gt;<br/>                            &lt;Quote slow={true} /&gt;<br/>                        &lt;/Suspense&gt;<br/>                    &lt;/div&gt;<br/>                &lt;/&gt;<br/>            )}<br/>        &lt;/&gt;<br/>    );<br/>}</span></pre><pre class="pf nu mj nv bn nw nx bi"><span id="5cf6" class="ny mr it mj b be nz oa l ob oc">// components/client/Quote.js<br/><br/>'use client';<br/><br/>import { getQuote } from '../../lib/quote';<br/>import { use } from 'react';<br/><br/>const quoteFetch = getQuote();<br/>const quoteFetchSlow = getQuote(2000);<br/><br/>export default function Quote({ slow }) {<br/>    const quote = use(slow ? quoteFetchSlow : quoteFetch);<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;p&gt;{slow ? 'Slow' : 'Fast'} component rendered&lt;/p&gt;<br/>            &lt;blockquote&gt;{quote.content}&lt;/blockquote&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/9143abb8ac50b4fcac8a75afba433b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qy2Dlnd6QEON6U5c.gif"/></div></div><p class="oj ok gj gh gi ol om bd b be z dk translated">使用“use”挂钩进行客户端提取的运行结果</p></figure><p id="42ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这比我们以前所做的更干净:取入<code class="fe mg mh mi mj b">useEffect</code>并将结果存储在一个状态变量中。它也足够接近它在服务器组件中的外观。</p><p id="434e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">谨慎的读者可能已经注意到结果看起来与我们在服务器组件中看到的不同。你说得对；这两个组件提供了两种不同的报价。这个<code class="fe mg mh mi mj b">fetch</code>调用在客户端是不重复的。我不知道这是设计好的还是需要修复的(我希望如此)。然而，由于<code class="fe mg mh mi mj b">use</code>钩子是通用的，并且可以在任何情况下工作，我想你可以在<code class="fe mg mh mi mj b">fetch</code>周围实现一个缓存层，没有问题。</p><h1 id="24ad" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">前路漫漫</h1><p id="ba7e" class="pw-post-body-paragraph ku kv it kw b kx od ju kz la oe jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">新的数据获取模式是一个巨大的变化，看起来令人兴奋，但同时也有点令人困惑。文档包含关于在多个地方什么可以做什么不可以做的模糊描述。Typescript支持也不完整。我认为这主要是因为它的基础——React的异步服务器组件和<code class="fe mg mh mi mj b">use</code>hook——太新了，还没有完善。在这部分产品投入生产使用之前，还有很长的路要走。</p><p id="76f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我喜欢异步服务器组件的想法。这是一种将更多计算转移到服务器端、减少客户端捆绑包大小以及保持跨网络边界的相对一致的编程模型的极好方法。然而，与此同时，当我开始认真地采用它时，我也预计会遇到许多困惑、反模式和神秘的错误。</p><p id="d5f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里找到演示项目代码<a class="ae mk" href="https://github.com/ymc9/nextjs-data-fetching" rel="noopener ugc nofollow" target="_blank">，在这里找到该系列的其他故事:</a></p><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/fun-with-next-js-13-server-components-fd5f886c31f3"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">探索Next.js 13服务器组件</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">Next.js 13测试版特性的快速概述</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">better编程. pub</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/an-overview-of-next-js-13-routing-system-1dcf73e2429f"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">Next.js 13路由系统概述</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">Next.js 13测试版功能的快速概述</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">better编程. pub</p></div></div><div class="oz l"><div class="po l pb pc pd oz pe ks oq"/></div></div></a></div><p id="7b69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p><pre class="kj kk kl km gt nu mj nv bn nw nx bi"><span id="ce6c" class="ny mr it mj b be nz oa l pp oc">Want to Connect?<br/><br/>I'm the creator of <a class="ae mk" href="https://zenstack.dev/?utm_campaign=medium&amp;utm_medium=organic&amp;utm_content=nextjs_data_fetching" rel="noopener ugc nofollow" target="_blank">ZenStack</a>, a toolkit that supercharges<br/>Prisma ORM with a powerful access control layer and<br/>unleashes its full potential for full-stack development.<br/>Our goal is to let you save time writing boilerplate code<br/>and focus on building what matters - the user experience.</span></pre></div></div>    
</body>
</html>