<html>
<head>
<title>JavaScript Booleans: Is Falsy Actually False?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript布尔值:Falsy实际上是假的吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-booleans-is-falsy-actually-false-1faec9a67df?source=collection_archive---------7-----------------------#2021-06-25">https://betterprogramming.pub/javascript-booleans-is-falsy-actually-false-1faec9a67df?source=collection_archive---------7-----------------------#2021-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对八种错误价值观的深入研究</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/151ad8b9ecb18d0c603112d6c019b807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmfwIRtSZK1AI7oER8uYIA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JavaScript布尔假值的图像</p></figure><p id="2186" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript布尔值是出了名的棘手。即使是经验丰富的程序员有时也不能把它们做对。它们是JavaScript语言中的主要陷阱之一。本文深入探讨了JavaScript布尔值以及如何更好地理解它们。</p><h1 id="573d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">真不是假，是吗？</h1><p id="1d4b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我认为，许多JavaScript开发人员对布尔值有这样的问题是因为JavaScript英语不同于普通英语。如果某事不是真的，那么它就是假的。那毫无例外。然而，在JavaScript中，情况并非总是如此。这种差异让JavaScript程序员感到困惑，尤其是那些语言新手。</p><p id="29be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">包括JavaScript在内的大多数编程语言的一个基本原则是，阅读代码就像大声朗读一样。但是，由于JavaScript对真和假的定义模糊不清，您阅读代码的方式很容易欺骗您。这很不幸，但并不意外。编程语言随着时间的推移而发展，就像口语一样，它们包含不规则性和异常。</p><p id="ea88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这种模糊性，JavaScript引入了真值和T2值的概念。这些对于JavaScript语言来说是必不可少的，甚至当你谈论JavaScript时，你也会用到它们。所以要掌握JavaScript，你需要流利地知道什么时候用truthy/falsy，什么时候用true/false。</p><h1 id="0308" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">八个虚伪的价值观</h1><p id="496a" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">JavaScript中有八个falsy值。其中三个是数字0的变体。变量是正值、负值和零值的BigInt类型。人们有时称它们为六，因为他们认为所有的零值为一。不管是哪一种，JavaScript开发人员都应该记住它们。有关这些的更多信息，请参考MDN <a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank"> falsy </a>或<a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank"> truthy </a>文档。八个falsy值是:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6c06" class="my lv it mu b gy mz na l nb nc">// The eight falsy values</span><span id="bbca" class="my lv it mu b gy nd na l nb nc">const theValueFalse = false;<br/>const theNumberZero = 0;<br/>const theNegativeNumberZero = -0;<br/>const theBigIntZero = 0n;<br/>const anEmptyString = '';<br/>const theNullObject = null;<br/>const anUndefinedValue = undefined;<br/>const theNotANumber = NaN;</span></pre><p id="a534" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当在一个<em class="mr"> if </em>语句中使用时，这些都将被评估为<em class="mr"> false </em>。以上任何一个的比较就是JavaScript所说的<em class="mr"> falsy </em>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2a87" class="my lv it mu b gy mz na l nb nc">if (oneOfTheEight) {<br/>  // The value is falsy<br/>} else {<br/>  // The value is truthy<br/>}</span></pre><h1 id="29e2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">假设情况</h1><p id="0029" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当布尔值独立存在时，它们并不复杂。当问题出现在条件语句中时——比较一个值和另一个值时——几乎总是会出现问题。当他们两岁或更多时，事情开始变得复杂。为了进一步理解<em class="mr">真</em>和<em class="mr">真</em>之间的区别，请看以下假设情况:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="43c4" class="my lv it mu b gy mz na l nb nc">// If something ...<br/>if (variable) {<br/>  // condition is truthy<br/>}</span><span id="34bd" class="my lv it mu b gy nd na l nb nc">// If something is true ...<br/>if (variable == true) {<br/>  // condition is true<br/>}</span><span id="168f" class="my lv it mu b gy nd na l nb nc">// If something is strictly true ...<br/>if (variable === true) {<br/>  // condition is strictly true<br/>}</span></pre><p id="e4dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，语言障碍又回来困扰我们。说白了，上面的条件表达式都是一样的。在对话中使用时，它们在逻辑上表示相同的意思。在英语口语中，除非是严肃的话题，否则人们很少会问某事是否真实。然而，在JavaScript中，这些语句并不相同。更糟糕的是，根据代码中使用的变量类型，它们会产生不同的结果。</p><p id="88cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个需要小心的情况是短路评估。短路评估仅仅是一种假设情况的变体。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a63f" class="my lv it mu b gy mz na l nb nc">maybeThisOne &amp;&amp; ifNotThenThisOne</span></pre><h1 id="2a2f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">虚假价值观的表现</h1><p id="6452" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">让我们看看<em class="mr"> falsy </em>价值观，以了解它们的行为方式以及为什么它们很难正确。开发者工具或NodeJS运行时中的控制台为我们提供了一个完美的实验平台。下面是NodeJS提示符的摘录。您可以运行这些示例，并在运行时使用它们。这样做是一种健康的锻炼。在编写JavaScript时，对八个falsy值以及它们的行为方式有所了解会有很大帮助。它使您更有准备在代码中的错误进入生产之前检测它们。</p><p id="4486" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">概括这八个值的一个简单方法是将它们全部放在一个数组中。这样做使得使用数组操作来观察它们的集体行为成为可能。下面是第一个元素为值<em class="mr"> false </em>的八个值。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4a70" class="my lv it mu b gy mz na l nb nc">const falsyValues = [false, 0, -0, 0n, '', null, undefined, NaN];</span></pre><p id="9cb8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们看看当我们在条件语句中使用它们时会发生什么。有关以下代码的更详细解释，请参考附录。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="91a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面可以得出几个结论:</p><ul class=""><li id="0824" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">所有的<em class="mr">假值</em>评估为<em class="mr">假值</em>。这个结果是意料之中的；毕竟，他们是虚伪的。</li><li id="ea97" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">严格比较将挑出<em class="mr">假</em>值，即值<em class="mr">假</em>是唯一严格等于<em class="mr">假</em>的值。它强调了<em class="mr">假</em>和<em class="mr">假</em>之间的区别，即一个值可以是<em class="mr">假</em>而实际上不是<em class="mr">假</em>。</li><li id="bda1" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">非严格的相等比较会产生混乱的结果。</li></ul><p id="501d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，你怎么知道什么时候用哪个呢？关键是要分离出八种错误价值观，并学会识别它们。使用<a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener ugc nofollow" target="_blank"> <em class="mr"> typeof </em> </a>运算符，我们可以更深入地挖掘并找出它们的类型。让我们使用数组操作<em class="mr">映射</em>来收集它们的类型。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="319a" class="my lv it mu b gy mz na l nb nc">&gt; falsyValues.map(v =&gt; typeof v)<br/>[ 'boolean', 'number', 'number', 'bigint', 'string', 'object', 'undefined', 'number' ]</span></pre><p id="b4cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">false值是八个值中唯一具有布尔类型的值。这实质上意味着我们可以使用值的类型来区分八个<em class="mr">假值</em>中的值<em class="mr">假值</em>。</p><p id="9d70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用布尔比较的一些经验法则:</p><ul class=""><li id="0740" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">小心直接比较。</li><li id="1300" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">使用严格的相等比较<code class="fe nu nv nw mu b">===</code> / <code class="fe nu nv nw mu b">!==</code>。</li><li id="3437" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">非严格平等一塌糊涂。看这里的完整表格:【https://dorey.github.io/JavaScript-Equality-Table/】T2</li></ul><h1 id="9631" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">API请求</h1><p id="428b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">程序员遇到的一个相对常见的情况是通过API传递布尔值。它可以是通过网络发送数据的客户端、库调用或类似情况。这里我们遇到两种可能的情况:</p><ol class=""><li id="463f" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nx nm nn no bi translated">通过API传递的值是纯布尔类型。它要么是严格的<em class="mr">真</em>要么是<em class="mr">假。</em></li><li id="f9cb" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nx nm nn no bi translated">值为<em class="mr">真、</em>T10】假或变量没有值，通常为<em class="mr">空</em>或<em class="mr">未定义。</em></li></ol><p id="c9de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种情况之间的差别是微妙但重要的。如果您只遇到前一种情况，它很容易欺骗您，让您相信隐式检查值以辨别参数是<em class="mr">真</em>还是<em class="mr">假</em>是没问题的。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="03d5" class="my lv it mu b gy mz na l nb nc">if (anArg) {<br/>  // true<br/>} else {<br/>  // false<br/>}</span></pre><p id="1603" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这在前一种情况下很好，在这种情况下，您知道该值严格地为<em class="mr">真</em>或<em class="mr">假</em>，但在后一种情况下就不行了。它具有欺骗性，因为所有的<em class="mr">假值</em>都以else-case结束，包括<em class="mr">空值</em>和<em class="mr">未定义值</em>。在这种情况下，通常最好先确保值为布尔类型。您应该通过严格的相等比较来检查这两个布尔值:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="afad" class="my lv it mu b gy mz na l nb nc">// Strict equality comparison<br/>if (anArg === true) {<br/>  // The argument has a "boolean" type, true<br/>} else if (anArg === false)<br/>  // The argument has a "boolean" type, false<br/>} else {<br/>  // The argument is either null or undefined<br/>}</span></pre><p id="e8e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者，您应该通过<em class="mr"> typeof </em>操作符来检查参数的类型。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0e13" class="my lv it mu b gy mz na l nb nc">if (typeof anArg === 'boolean’)  {<br/>  // The variable has a "boolean" type, true or false<br/>} else {<br/>  // The argument is either null or undefined<br/>}</span></pre><p id="b7f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:这两种方法在两种情况下都有效。</p><p id="ac50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们再来看看这些与八个虚假价值观的关系。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c833" class="my lv it mu b gy mz na l nb nc">// Checking with strict equality comparison<br/>&gt; falsyValues.map(v =&gt; v === true || v === false)<br/>[ true, false, false, false, false, false, false, false ]</span><span id="1b86" class="my lv it mu b gy nd na l nb nc">// Checking with typeof<br/>&gt; falsyValues.map(v =&gt; typeof v === 'boolean')<br/>[ true, false, false, false, false, false, false, false ]</span></pre><p id="d06f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，只有<em class="mr">假值</em>具有布尔类型。这种区别很重要，因为存在真实的用例，我们需要将布尔与其他类型区分开来。</p><h1 id="2adc" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">falsy对truthy</h1><p id="36ca" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">需要注意的一点是，正如我们在API请求中看到的:通过比较来寻找<em class="mr">假</em>值与通过比较来寻找<em class="mr">真</em>变量是不同的。原因是<em class="mr">真值</em>比较将排除无效值<em class="mr">未定义</em>、<em class="mr">空、</em>或<em class="mr"> NaN </em>，而假值比较将包括它们。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="bfeb" class="my lv it mu b gy mz na l nb nc">if (assumedToBeTrue) {<br/>  // truthy<br/>} else { <br/>  // falsy (e.g. null, undefined or NaN)<br/>}</span></pre><p id="440d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而不是</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="692d" class="my lv it mu b gy mz na l nb nc">if (assumedToBeFalse) {<br/>  // falsy (e.g. null, undefined or NaN)<br/>} else {<br/>  // truthy<br/>}</span></pre><p id="5e2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查错误值时要格外小心。</p><h1 id="f6d9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">其他几个案例</h1><p id="49de" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">最后，让我们看看其他一些案例以及八个错误值是如何表现的。</p><h2 id="6b20" class="my lv it bd lw ny nz dn ma oa ob dp me lh oc od mg ll oe of mi lp og oh mk oi bi translated">过滤</h2><p id="cfb1" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">筛选假值将删除属于八个假值之一的任何成员。因此，用所有falsy值过滤数组会得到一个空数组。这对于我们希望数组只有真值的情况很有用。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="03d6" class="my lv it mu b gy mz na l nb nc">&gt; [false, 0, -0, 0n, '', null, undefined, NaN].filter(Boolean)<br/>[]</span></pre><h2 id="025a" class="my lv it bd lw ny nz dn ma oa ob dp me lh oc od mg ll oe of mi lp og oh mk oi bi translated">传播虚假的价值观</h2><p id="bff9" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">使用spread运算符是有条件地将值包含在对象中的一个巧妙技巧。如果值为<em class="mr"> falsy </em>，即八个falsy值中的任何一个，则该成员被排除在对象之外。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8cf1" class="my lv it mu b gy mz na l nb nc">&gt; {...false &amp;&amp; { key: 'value' }}<br/>{}<br/>&gt; {...true &amp;&amp; { key: 'value' }}<br/>{ key: 'value' }</span></pre><p id="dec8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，八个falsy值中的任何一个都将排除条件值，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="38d3" class="my lv it mu b gy mz na l nb nc">&gt; [false, 0, -0, 0n, ‘’, null, undefined, NaN].map(v =&gt; ({<br/>  ...v &amp;&amp; { key: 'value' }<br/>}))<br/>[<br/> {}, {}, {}, {},<br/> {}, {}, {}, {}<br/>]</span></pre><h1 id="6c60" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">TLDR；</h1><ul class=""><li id="69d6" class="ng nh it la b lb mm le mn lh oj ll ok lp ol lt nl nm nn no bi translated">当你谈论布尔和比较时:说JavaScript英语而不是普通英语。用“真”和“假”来代替“真”和“假”(如果你没有明确表示值<em class="mr">真</em>或<em class="mr">假</em>)。</li><li id="5119" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">永远记住八个错误的价值观。如果有疑问，检查一下这八个人的行为。</li><li id="2f33" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">使用严格的相等比较，并对想要挑选出布尔值的情况保持警惕。</li></ul><p id="5f55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你做到了这一步，感谢你的阅读，祝你布尔比较好运！干杯！</p><h1 id="1c05" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">附录</h1><p id="9f8d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">本文使用数组操作来概述八个<em class="mr"> falsy </em>值的行为。MDN对<a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头函数</a>和数组函数<a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">映射</a>有相当全面的解释。</p><p id="3235" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是用于显示八个falsy值如何表现的映射函数的替换。它们都产生相同的结果:一个有八个假值的数组。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e5d4" class="my lv it mu b gy mz na l nb nc">&gt; falsyValues.map(Boolean)</span><span id="1c43" class="my lv it mu b gy nd na l nb nc">&gt; falsyValues.map(value =&gt; Boolean(value))</span><span id="4995" class="my lv it mu b gy nd na l nb nc">&gt; falsyValues.map(function(value) {<br/>  return Boolean(value);<br/>})</span><span id="f794" class="my lv it mu b gy nd na l nb nc">function isItTruthy(value) {<br/>  return Boolean(value);<br/>}<br/>&gt; falsyValues.map(isItTruthy);</span></pre></div></div>    
</body>
</html>