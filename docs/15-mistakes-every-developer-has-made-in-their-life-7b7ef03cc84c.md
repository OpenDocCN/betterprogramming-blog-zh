# 每个开发人员一生中都会犯的 15 个错误

> 原文：<https://betterprogramming.pub/15-mistakes-every-developer-has-made-in-their-life-7b7ef03cc84c>

## 你可能会联想到这些错误

![](img/bb596e19aac1e46b0177e33bccba030a.png)

克里斯·里德在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片。

犯错是人之常情，也是我们成长的原因。你不应该害怕犯错误。很有可能你已经犯了很多上面列出的错误。如果没有，那太好了。试着从其他开发人员所犯的错误中吸取教训，这样你就不必自己犯同样的错误了。

1.  长生命周期代码中的快速和肮脏的修复。快速和肮脏的解决方案的问题是，它们扼杀了代码库的质量。这样的解决方案很可能会增加不必要的技术债务。从长远来看，快速和肮脏的修补程序会回来咬你。在将来的某个时候，你可能会以重构你快速而肮脏的解决方案而告终。
2.  缺乏实践。众所周知，熟能生巧。所以如果你想成长为一个开发者，你需要多练习。你可能犯的最大错误是不偶尔学习任何新东西。如果你想学习新的东西，比如编程语言，你可能必须在日常工作之外去做。为了保持相关性，你必须对自己进行投资。
3.  低估工作量。估算工作量是软件开发中最困难的事情之一。在 Scrum 精化中，你有多经常听到“我可以在一个故事点中轻松实现这个特性”？事情很可能没有那么简单，你想要的解决方案也不会奏效。当涉及到评估时，确保你也为测试等事情计算时间——不仅仅是为开发人员。
4.  写明显的评论。我们以前都见过这样的评论。他们什么都不解释，只关注代码在做什么(例如，当有一个`foreach`循环时，一个类似“循环通过产品”的注释)。每当你处于这种情况下，不要写一个关注代码正在做什么的注释。重点放在这段代码的*为什么*上。
5.  注释掉代码块。我们都见过包含多个函数的整个代码块被注释掉。没有人知道为什么这段代码还在那里，或者它是否仍然相关。没有人删除这段代码的原因是，每个人都认为其他人可能需要它。只需删除注释掉的代码块。如果结果证明代码仍然是必要的，它将处于版本控制中。
6.  只是测试快乐路径的场景。当编写测试时，你应该考虑的不仅仅是快乐的路径。思考一些事情没有按照预期进行的场景。最坏的情况是什么？请确保也测试该场景。
7.  混乱的代码格式。这是没有经验的开发人员最常犯的错误。这使得代码更难阅读，也让其他必须阅读你的代码的开发人员感到沮丧。修复混乱的代码可以通过安装一个 linter 来格式化你的代码。
8.  不记录任何相关信息。有用的日志给开发者提供了很大的帮助。拥有日志消息可以让您深入了解代码中哪里出错了，并节省您大量的调试时间。好的日志消息提供了发生特定错误时用户正在做什么的上下文。
9.  重复发明轮子是因为缺乏知识。当开发人员不知道框架中已经有什么可用时，就会发生这种错误。由于这种知识的缺乏，开发人员实现了与框架中已经可用的方法几乎相同的新方法。
10.  在不知道解决方案的情况下开始编码。这可能一开始看起来很刺激，但它会回来咬你。规划和组织代码是编码的重要部分。你不应该没有计划就开始编码。思考你可能会发现的问题，以及如何解决它们。这让你更加意识到在编写代码之前有很多事情要考虑。
11.  编写错误提交消息的艺术。我们可能都犯过这个错误。“修复了一个错误”或“WIP”是*而不是*好的提交消息。拥有好的提交消息很重要，您应该花时间编写一个好的提交消息。一个好的提交消息提供了关于*什么*改变了以及*为什么*改变的有用信息。当事情真的变糟时，修订历史是一个很好的资源，可以快速找到问题到底出在哪里。
12.  在你的代码中有神奇的数字。幻数是具有无法解释的含义或多次出现的唯一值，可以并且应该用命名的常数替换。幻数的问题在于它们不可读，并且没有为开发人员提供任何上下文。最重要的是，幻数经常在一个程序的不同地方被多次使用，这使得它很容易出错。
13.  在一个函数中进行了太多的事情。试着让你的函数只做一件事。不要让函数获取、处理和输出数据。将所有这些职责分解成不同的职能。一个用于获取，一个用于处理，另一个用于输出数据。让一个功能专注于一个关注点是它更健壮的原因。
14.  不写自动化测试。最初，当你开始编写自动化测试时，它会比手工测试花费更多的时间。从长远来看，您会很高兴花时间来编写这些自动化测试。不得不手动测试所有的东西既无聊又耗时，而且人为因素使得它更容易出错。
15.  使事情变得不必要的复杂(也就是过度工程化)。实现某些设计模式是大多数开发人员都做过的事情。仅仅因为你看到了实现设计模式的机会，并不意味着你应该这样做。所有这些所完成的只是给代码库增加了更多的技术债务。