<html>
<head>
<title>How To Transform JavaScript Functions Into Memory-Efficient Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将JavaScript函数转换成节省内存的生成器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-transform-javascript-functions-into-memory-efficient-generators-e402af77cdc4?source=collection_archive---------1-----------------------#2021-07-22">https://betterprogramming.pub/how-to-transform-javascript-functions-into-memory-efficient-generators-e402af77cdc4?source=collection_archive---------1-----------------------#2021-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="90cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始在JavaScript中使用yield</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06ec41d301520eea53c30b1be09fdcb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YzH8wsFtI94J5zq2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@rcrazy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ricardo Rocha </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="c458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，<code class="fe lv lw lx ly b">yield</code>用于暂停函数的执行。当再次调用该函数时，从最后一条<code class="fe lv lw lx ly b">yield</code>语句继续执行。</p><p id="e39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">产生值的函数是生成器。下面是运行函数与运行生成器函数的对比图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/46b3edfad1ec619503657bddd4346247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rj8PuubSvLyLe4dL-Ke8Pg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JavaScript中的函数与生成器</p></figure><p id="6d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器返回一个生成器对象，它是一个迭代器。该对象一次生成一个值，然后暂停执行。它不存储值，所以它的内存效率很高。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c2d5" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">如何将一个函数变成一个生成器</h1><p id="fdc2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">要将函数转换为生成器:</p><ul class=""><li id="084a" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">在<code class="fe lv lw lx ly b">function</code>关键字后添加一个星号(<code class="fe lv lw lx ly b">*</code>)。</li><li id="03c9" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">用<code class="fe lv lw lx ly b">yield</code>代替<code class="fe lv lw lx ly b">return</code>。</li></ul><h2 id="80d9" class="ns mi it bd mj nt nu dn mn nv nw dp mr li nx ny mt lm nz oa mv lq ob oc mx od bi translated">例子</h2><p id="92c0" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们创建一个普通函数<code class="fe lv lw lx ly b">square()</code>，它对一个数字数组求平方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="a279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="d9be" class="ns mi it ly b gy ok ol l om on">[1, 4, 9, 16, 25]</span></pre><p id="a56d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这个函数变成一个生成器。</p><p id="9fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">yield</code>不是将方块加入一个数组，而是一次一个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="e891" class="ns mi it ly b gy ok ol l om on"><strong class="ly iu">: [object Generator]</strong></span></pre><p id="c2e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你还没有得到一个平方数的数组。这是因为结果<code class="fe lv lw lx ly b">squared_numbers</code>是一个生成器对象。这个生成器对象还没有进行任何计算。</p><p id="88fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何从生成器对象中获得平方数。</p><h2 id="179b" class="ns mi it bd mj nt nu dn mn nv nw dp mr li nx ny mt lm nz oa mv lq ob oc mx od bi translated">next()方法</h2><p id="5663" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">生成器不会在内存中存储数字。相反，它一次一个地计算并产生<strong class="lb iu"> </strong>。生成一个值后，生成器对象暂停，直到被要求生成下一个值。</p><p id="3a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得上例中的平方数，您需要使用<code class="fe lv lw lx ly b">next()</code>方法向generator对象请求下一个平方值。</p><p id="c5ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让生成器计算第一个平方数:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="4f6e" class="ns mi it ly b gy ok ol l om on">console.log(squared_numbers.next())</span></pre><p id="aa6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="373a" class="ns mi it ly b gy ok ol l om on">{<br/>  value:1,<br/>  done:false<br/>}</span></pre><p id="ae9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结果对象有两个属性:</p><ul class=""><li id="87c2" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><code class="fe lv lw lx ly b">value</code>—数字数组中第一个数字的平方结果。</li><li id="9dfe" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe lv lw lx ly b">done</code>—这表示发电机功能是否已经结束。</li></ul><p id="4cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，生成器对象在生成第一个平方数后暂停了执行。</p><p id="cabe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过再调用四次<code class="fe lv lw lx ly b">next()</code>让生成器计算其余的数字:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="a868" class="ns mi it ly b gy ok ol l om on">console.log(squared_numbers.next().value)<br/>console.log(squared_numbers.next().value)<br/>console.log(squared_numbers.next().value)<br/>console.log(squared_numbers.next().value)</span></pre><p id="ea2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="5f68" class="ns mi it ly b gy ok ol l om on">4<br/>9<br/>16<br/>25</span></pre><p id="3070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在生成器已经将所有的数字平方。如果你再叫一次<code class="fe lv lw lx ly b">next()</code>:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="4182" class="ns mi it ly b gy ok ol l om on">console.log(squared_numbers.next())</span></pre><p id="ce73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你得到一个对象，其中<code class="fe lv lw lx ly b">value</code>是<code class="fe lv lw lx ly b">undefined</code>，<code class="fe lv lw lx ly b">done</code>是<code class="fe lv lw lx ly b">true</code>。</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="36d0" class="ns mi it ly b gy ok ol l om on">{<br/>  value: <strong class="ly iu">undefined</strong>,<br/>  done: <strong class="ly iu">true</strong><br/>}</span></pre><p id="1b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为生成器已到达数组的末尾。这样，发电机就耗尽了。</p><p id="1d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您了解了生成器是如何工作的，以及如何让它计算值。</p><p id="c4ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在不使用烦人的<code class="fe lv lw lx ly b">next()</code>方法的情况下循环遍历这些值。</p><h2 id="f04a" class="ns mi it bd mj nt nu dn mn nv nw dp mr li nx ny mt lm nz oa mv lq ob oc mx od bi translated">去掉next()</h2><p id="daf8" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">next()</code>函数演示了生成器如何工作，但是您不需要调用它来处理生成器对象。相反，你可以使用一个<code class="fe lv lw lx ly b">for-of</code>循环——就像你如何遍历一个数字数组一样。</p><p id="df3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们使用一个<code class="fe lv lw lx ly b">for-of</code>循环重复上面的生成器示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="42aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="e557" class="ns mi it ly b gy ok ol l om on">1<br/>4<br/>9<br/>16<br/>25</span></pre><p id="5674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从语法上来说，这看起来就像是在一个常规的数字数组中循环。</p><p id="1b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也很方便，因为你不需要自己调用<code class="fe lv lw lx ly b">next()</code>。<code class="fe lv lw lx ly b">for-of</code>循环知道如何为你做。它还负责当没有更多的值需要平方时，生成器不调用<code class="fe lv lw lx ly b">next()</code>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2a7d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">生成器与数组—运行时比较</h1><p id="e64f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们对生成器和函数进行运行时比较。</p><p id="be3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，有一个由十个数字和两个函数组成的数组:</p><ul class=""><li id="01b7" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">从数组<em class="oo">中随机选择一个数字n次的<code class="fe lv lw lx ly b">data_array()</code>函数。</em></li><li id="3254" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">一个生成器函数<code class="fe lv lw lx ly b">data_generator()</code>，它也从数组<em class="oo">中随机选择一个数字n次</em>。</li></ul><p id="1efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码比较了使用这些函数构建一个1M随机选择数的集合的运行时。请不要担心实现细节:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cf7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="b583" class="ns mi it ly b gy ok ol l om on">Array creation took 121.39999997615814 milli seconds<br/>Generator creation took 0.10000002384185791 milli seconds<br/>The generator is <strong class="ly iu">1213.9997103214955</strong> times faster</span></pre><p id="ea80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个生成器比创建一组数字要快得多。这是因为数组必须在内存中存储所有1M的数字。生成器不会在内存中存储任何东西。在对它调用<code class="fe lv lw lx ly b">next()</code>方法之前，它甚至没有开始挑选数字。</p><p id="76ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>这个例子是有偏差的。发电机不使用<strong class="lb iu"/><strong class="lb iu">使用</strong><strong class="lb iu"/><strong class="lb iu">数据</strong>。因此，性能方面的比较是没有意义的。但是它很好地展示了如何创建一个生成器几乎不需要时间和内存。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="8be1" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">JavaScript中生成器的用例示例</h1><h2 id="a1d3" class="ns mi it bd mj nt nu dn mn nv nw dp mr li nx ny mt lm nz oa mv lq ob oc mx od bi translated">无限的溪流</h2><p id="de73" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">生成器对象(迭代器)不存储值。因此，使用生成器创建无限的价值流是可能的。</p><p id="8378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们创建一个无限生成器，它生成一个起点之后的所有数字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="ed53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该发生器产生从<code class="fe lv lw lx ly b">start</code>到无穷大的值。</p><p id="f7c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从<code class="fe lv lw lx ly b">10</code>开始运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是源源不断的数字从<code class="fe lv lw lx ly b">10</code>上来:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="afc8" class="ns mi it ly b gy ok ol l om on">10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>.<br/>.<br/>.</span></pre><p id="42b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从语法上看，似乎<code class="fe lv lw lx ly b">infinite_nums</code>真的是一个无限的数字数组。实际上，它只不过是一个无限循环的生成器。</p><h2 id="85e0" class="ns mi it bd mj nt nu dn mn nv nw dp mr li nx ny mt lm nz oa mv lq ob oc mx od bi translated">简化迭代器的创建</h2><p id="fac5" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果你熟悉编写自己的迭代器，你就知道这是一团糟。</p><p id="ecab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们创建一个输出三个字符串的迭代器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c59f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="9005" class="ns mi it ly b gy ok ol l om on">Hello<br/>World<br/>Its me</span></pre><p id="f32d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使它更清晰，您可以使用一个生成器函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="303e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="d8de" class="ns mi it ly b gy ok ol l om on">Hello<br/>World<br/>Its me</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9d69" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="98b4" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在JavaScript中，<code class="fe lv lw lx ly b">yield</code>是一个将函数变成生成器的关键字。</p><p id="3d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与数组不同，生成器不存储值。相反，它知道当前值以及如何获得下一个值。这使得生成器的内存效率更高。</p><p id="ff54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您循环访问一大组项目，并且不需要一次存储所有项目时，使用生成器非常有用。</p><p id="63cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。编码快乐！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="60a2" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">进一步阅读</h1><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/10-javascript-snippets-for-cleaner-looking-code-76f6e2cf6fc4"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">10个JavaScript代码片段让代码看起来更整洁</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">JavaScript简化使你的代码简洁明了</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://www.codingem.com/50-buzzwords-of-web-development-and-design-in-2021/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">2021年网络开发和设计的50多个流行语</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">学习创业公司使用的网页开发和网页设计语言。这篇文章是关于…的很好的入门读物</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">www.codingem.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>