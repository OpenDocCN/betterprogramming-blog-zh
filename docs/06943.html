<html>
<head>
<title>How to Use React Hooks Like a Professional</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何像专业人士一样使用React挂钩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-react-hooks-like-professional-573cc96fb79d?source=collection_archive---------0-----------------------#2020-11-19">https://betterprogramming.pub/how-to-use-react-hooks-like-professional-573cc96fb79d?source=collection_archive---------0-----------------------#2020-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8b1e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React挂钩的最佳实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/42e4b2ddff7c4549d55e1ad9f3422860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UcRHcd4McTDELhQA"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图德·巴休在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="d7c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React挂钩的引入从根本上改变了我们构建React应用程序的方式，将状态和生命周期功能暴露在基于类的组件之外。功能组件现在是React的一等公民，构成了React应用程序的主体。</p><p id="f663" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管React钩子非常强大，但也很容易被误用，在代码中引入意外的行为或错误。</p><p id="9b97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看使用React挂钩的一些最佳实践，以确保您正在编写干净、高效和可维护的代码。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1a46" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用钩子，因为它们应该被使用</h1><p id="99c7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">虽然这看起来很明显，但是我已经看到了一些非常不恰当的使用钩子的方法。React定义了下面的<a class="ae kv" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">钩子规则</a>。</p><h2 id="c4f5" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">只调用顶层的钩子</h2><p id="0914" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">不要在循环、条件和嵌套函数中调用钩子。让我们来看一个例子:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="fa22" class="mw ma iq nj b gy nn no l np nq">if (setStorage) {<br/>  useEffect(() =&gt; {<br/>    localStorage.setItem('item', 'example');<br/>  })<br/>}</span></pre><p id="1b87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe nr ns nt nj b">useEffect</code>是如何嵌套在<code class="fe nr ns nt nj b">if</code>语句中的。</p><p id="d7cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这应该被重构，以便我们在根处调用<code class="fe nr ns nt nj b">useEffect</code>:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="5cbf" class="mw ma iq nj b gy nn no l np nq">useEffect(() =&gt; {<br/>  if (setStorage) {<br/>    localStorage.setItem('item', 'example');<br/>  }<br/>})</span></pre><p id="6368" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以防止每次组件渲染时钩子没有以相同的顺序被调用，并让React在<code class="fe nr ns nt nj b">useState</code>和<code class="fe nr ns nt nj b">useEffect</code>调用中正确地保持状态。</p><h2 id="8c74" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">仅从功能组件调用挂钩</h2><p id="e33e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">虽然这似乎是显而易见的，但是不要在普通的JS代码中使用React钩子——只在组件中使用。这使得跟踪您在哪里修改和维护状态变得更加容易。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8222" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">React Hooks有一个ESLint插件——使用它</h1><p id="41ff" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">React发布了一个很棒的ESLint插件，名为<a class="ae kv" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank">ESLint-plugin-react-Hooks</a>，帮助开发者在他们的项目中以正确的方式编写钩子。甚至在运行应用程序之前，使用这个eslint插件来捕获和修复钩子错误。</p><p id="1dcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义了两个相对简单的规则:</p><ul class=""><li id="05af" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr nz oa ob oc bi translated"><code class="fe nr ns nt nj b">react-hooks/rules-of-hooks</code></li><li id="5e0d" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><code class="fe nr ns nt nj b">react-hooks/exhaustive-deps</code></li></ul><p id="f55e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一条规则只是强制您的代码遵守钩子规则，正如上一节所解释的。第二条规则确保在效果函数中引用的每个值都在<code class="fe nr ns nt nj b">dependencies</code>数组中。</p><p id="37ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这段代码将触发<code class="fe nr ns nt nj b">exhaustive-deps</code>警告，因为它正在访问一个不在<code class="fe nr ns nt nj b">dependencies</code>数组中的变量<code class="fe nr ns nt nj b">componentId</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8313" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这看起来很烦人，但它将帮助您避免一些与未列出的依赖项相关的奇怪错误。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c862" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">useState也可以用于对象！</h1><p id="d377" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">许多<code class="fe nr ns nt nj b">useState</code>示例用多个变量声明多个状态:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="e5c2" class="mw ma iq nj b gy nn no l np nq">const [userEmail, setUserEmail] = useState('')<br/>const [userName, setUserName] = useState('')<br/>const [isError, setIsError] = useState(true)</span></pre><p id="893f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这样做是可行的，但是当您开始在本地状态中维护更多的值时，可能会有点冗长。<code class="fe nr ns nt nj b">useState</code>也可以很好的保存数组和对象，为什么不使用它呢？</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="2a34" class="mw ma iq nj b gy nn no l np nq">const [state, setState] = ({<br/>  email: 'test@test.com',<br/>  userName: 'Name',<br/>  isError: false,<br/>})</span></pre><p id="a082" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里唯一需要注意的是，当设置状态来更新对象的单个值时，必须确保将旧状态正确地合并到新状态中:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="90e6" class="mw ma iq nj b gy nn no l np nq">setState((oldState) =&gt; ({<br/>  ...oldState,<br/>  userName: 'New Name',<br/>}))</span></pre><p id="f936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这确保了您获得的是最新的状态，而不是某个旧版本。</p><p id="b701" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，建议将状态<a class="ae kv" href="https://reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables" rel="noopener ugc nofollow" target="_blank">分割成多个状态变量，React基于这些变量一起改变值(主要是为了可读性)。但是对于像表单这样的状态，将状态分组在一起更简单。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="abac" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">定制挂钩超赞！</h1><p id="1887" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当您构建React应用程序时，您会开始注意到应用程序逻辑是跨许多组件共享的。</p><p id="16b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将组件的逻辑提取到许多可重用的函数中，如<a class="ae kv" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">自定义挂钩</a>，允许您在整个应用程序中创建类似的本地状态，从而使项目更具可重构性和可维护性。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3bdf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">不要使用支柱钻孔</h1><p id="c16a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">属性钻取是React应用程序中的一个常见问题，在React应用程序中，数据从一个父组件向下传递，直到到达正确的子组件，而一些嵌套组件实际上并不使用它们。</p><p id="83ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React Context是一个通过组件树向下传递数据的特性，而不必通过不手动使用它们的子组件传递数据。React上下文的值由父组件定义，可以在任何子组件中用<code class="fe nr ns nt nj b">useContext</code>钩子访问。这是维护全局状态的一个非常简单的方法。看一下文档中的<code class="fe nr ns nt nj b">useContext</code>挂钩<a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1f9f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="d8e9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">正确使用的话，React Hook API会非常强大。如果您遵循最佳实践，您将确保您拥有无bug且可维护的代码，这是一种乐趣。</p><p id="59e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>