<html>
<head>
<title>Reduce Response Times and Improve Performance with Redis Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redis缓存减少响应时间并提高性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-cache-api-requests-with-redis-and-node-js-cba883385e7?source=collection_archive---------0-----------------------#2022-07-19">https://betterprogramming.pub/how-to-cache-api-requests-with-redis-and-node-js-cba883385e7?source=collection_archive---------0-----------------------#2022-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bbc8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">减少查询数据时响应时间的初学者指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/96d58e11c5b4524523694aaa3c16f827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ePsJV7U18ki6sEV4"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">在<a class="ae ku" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ku" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>拍摄的照片</p></figure><p id="f331" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们生活在即时的时代，时间已经比金钱更有价值。而那个时代，再加上互联网的活力，让我们的观众每天的要求都更高。</p><p id="cb5a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你的网站内容可能很优秀，但是如果加载速度不好，人们会等着看吗？</p><p id="e198" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">根据几项研究，一半的用户等待时间不超过三秒。这对电子商务等网站来说是一个挑战，如果页面不能立即加载，用户可能会放弃页面，从而失去潜在的销售。</p><p id="a19a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">缓存您的web应用程序数据对于解决这个问题并在您扩展时提供高性能增益至关重要。</p><p id="7c87" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">近年来，Redis已经成为最受欢迎的缓存数据库，因为它允许网站通过在几毫秒内访问数据来大幅提高性能和工作效率。</p><h1 id="b08e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Redis是什么？</h1><p id="6433" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">远程字典服务器(<a class="ae ku" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>)是一个高性能的开源NoSQL数据库，主要用作各种类型应用程序的缓存解决方案。</p><p id="1f10" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Redis基于散列表结构，其中每个键都有一个关联值。与其他键值数据库相比，Redis允许使用更复杂、更灵活的结构，这为不同的业务应用程序需求提供了多种可能性。</p><p id="3451" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当访问速度和响应时间对业务解决方案至关重要时，强烈建议使用Redis。在处理实时应用程序时也需要使用它，实时应用程序需要快速访问数据以缩短响应时间。在最常见的使用案例中，我们可以找到:</p><ul class=""><li id="6d90" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">聊天和信息系统</li><li id="c036" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">最新项目列表</li><li id="ecf8" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">实时计数器和统计使用情况</li><li id="75b7" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">在线购物车管理</li><li id="4823" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">在应用程序中存储用户会话</li><li id="36bd" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">支持缓存网页</li></ul><h1 id="6daa" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是缓存？</h1><p id="20ef" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">缓存是将数据副本存储在内存中以允许应用程序更快地访问和检索数据的过程。</p><p id="fee5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">缓存的目标是比数据库或远程服务器更好地加速数据访问操作。对于高成本(及时)操作来说尤其如此。</p><p id="5316" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，如果我们的查询需要几个操作，比如从数据库中检索数据、执行计算、从其他服务中检索附加数据等等。，我们可以使用缓存。</p><p id="97ac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这样，我们只需处理一次数据，将其存储在缓存中，然后直接从缓存中检索，而无需执行所有这些代价高昂的操作。然后，我们将定期刷新缓存，以便用户可以看到更新的信息。</p><h1 id="920f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">使用Node.js和Redis进行缓存</h1><p id="2cd2" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">现在，我们将开始开发我们的应用程序，我们希望在本教程中实现的是对外部API执行查询，并测量响应时间。</p><p id="47f0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">之后，我们将在应用程序中实现Redis，将查询结果存储在缓存中。这样，我们将能够比较Redis前后的响应时间。</p><h1 id="fb2a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Redis设置</h1><p id="1319" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">本教程的第一件事是在我们的本地环境中安装Redis。为此，我们将遵循每个平台的安装指南。</p><p id="8280" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ku" href="https://phoenixnap.com/kb/install-redis-on-mac" rel="noopener ugc nofollow" target="_blank">在Mac上安装</a></p><p id="aee3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ku" href="https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04" rel="noopener ugc nofollow" target="_blank">安装在Ubuntu上</a></p><p id="0118" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ku" href="https://redis.com/blog/redis-on-windows-10/" rel="noopener ugc nofollow" target="_blank">在Windows上安装</a></p><h1 id="5edf" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Node.js设置</h1><p id="24a2" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们用创建<code class="fe nc nd ne nf b">package.json</code>的命令开始Node.js项目。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="1750" class="nk ls it nf b gy nl nm l nn no">npm init</span></pre><p id="1b46" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于我们的Node.js应用程序，我们需要使用以下命令安装以下依赖项:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="9dd7" class="nk ls it nf b gy nl nm l nn no">npm install express redis axios</span></pre><ul class=""><li id="a309" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated"><a class="ae ku" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank">快递</a>建立服务器</li><li id="8c46" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><a class="ae ku" href="https://www.npmjs.com/package/redis" rel="noopener ugc nofollow" target="_blank"> Redis </a>连接我们的应用程序和Redis并执行查询</li><li id="13d3" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><a class="ae ku" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>执行REST查询</li></ul><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="a036" class="nk ls it nf b gy nl nm l nn no">npm install nodemon response-time -D</span></pre><ul class=""><li id="9c79" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated"><a class="ae ku" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank"> nodemon </a>每次更改后自动唤醒我们的应用程序</li><li id="36d5" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated"><a class="ae ku" href="https://www.npmjs.com/package/response-time" rel="noopener ugc nofollow" target="_blank">响应时间</a>查看每个请求需要多长时间</li></ul><p id="6868" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们的<code class="fe nc nd ne nf b">package.json</code>文件中，我们将在“scripts”键中创建一个新的脚本，我们将使用它来启动我们的应用程序。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="b757" class="nk ls it nf b gy nl nm l nn no">"dev": "nodemon src/app.js"</span></pre><h1 id="b0ba" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">构建Node.js应用程序</h1><p id="4787" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">像这样为Node.js应用程序设置初始样板文件。我们创建一个<code class="fe nc nd ne nf b">app.js</code>文件，并在其中添加以下几行:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4f97" class="nk ls it nf b gy nl nm l nn no">const express = <em class="np">require</em>('express')<br/>const responseTime = <em class="np">require</em>('response-time')<br/>const redis = <em class="np">require</em>('redis')<br/>const axios = <em class="np">require</em>('axios')const app = express()</span><span id="e7d6" class="nk ls it nf b gy nq nm l nn no">app.listen(process.env.PORT || 3000, () =&gt; {<br/>    console.log("Node server started")<br/>})</span></pre><p id="3dbb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，如果我们执行该命令，我们就创建了Express服务器。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="ff3f" class="nk ls it nf b gy nl nm l nn no">npm run dev</span></pre><p id="73be" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将在控制台中看到消息<code class="fe nc nd ne nf b">"Node server started"</code></p><h1 id="a29f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">从外部API检索数据</h1><p id="33bd" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">对于我们的教程，我们将使用Rick和Morty API的REST版本，它为我们提供了以下端点:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="a238" class="nk ls it nf b gy nl nm l nn no">{<br/>  "characters": "https://rickandmortyapi.com/api/character",<br/>  "locations": "https://rickandmortyapi.com/api/location",<br/>  "episodes": "https://rickandmortyapi.com/api/episode"<br/>}</span></pre><p id="042f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，我们将使用axios向<code class="fe nc nd ne nf b">/character</code>端点发出请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1067" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于我们发出的这个请求，API返回给我们一个包含所有字符的对象，我们感兴趣的是这个请求所获取的<code class="fe nc nd ne nf b">response-time</code>。</p><p id="9179" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用我们作为中间件添加的响应时间，我们将能够在请求的报头中看到一个名为<code class="fe nc nd ne nf b">X-Response-Time</code>的新报头，它将指示我们更多的时间。</p><p id="f0dd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">此请求花费了238.831毫秒</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/23d7ec2fcb4d70fe05a51d178cd7695e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zs1kvTIOyxTXxzJnis_mhA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">/字符</p></figure><h1 id="17c2" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">为我们的端点实现Redis缓存</h1><p id="a4a7" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">现在，让我们看看如何通过缓存来提高应用程序的性能。</p><p id="872e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们需要通过应用程序连接到Redis服务器。我们使用安装的Redis包来完成这项任务。</p><p id="a0d1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">默认情况下，<code class="fe nc nd ne nf b"><a class="ae ku" href="https://github.com/NodeRedis/node-redis#rediscreateclient" rel="noopener ugc nofollow" target="_blank">redis.createClient()</a></code>会分别使用<code class="fe nc nd ne nf b">127.0.0.1</code>和<code class="fe nc nd ne nf b">6379</code>作为主机名和端口。如果您有不同的主机/端口，您可以像这样提供它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4ffa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，我们将向API发出相同的请求，并使用Redis客户端的<code class="fe nc nd ne nf b">set()</code>方法缓存响应，该方法接收我们想要保存的键的名称作为第一个参数。作为第二个参数，这个键的值，我们必须保存为一个字符串，所以我们必须将JSON解析为string。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a010" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一旦我们重新加载我们的应用程序，我们得到了查询的结果，我们就已经缓存了答案。</p><p id="4303" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了验证这一点，我们将使用<a class="ae ku" href="https://github.com/joeferner/redis-commander" rel="noopener ugc nofollow" target="_blank"> Redis-commander </a>。Redis-commander允许我们通过网络界面查看我们的Redis数据库。我们用以下命令安装它:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="b296" class="nk ls it nf b gy nl nm l nn no">npm install -g redis-commander</span></pre><p id="6722" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个包将为我们提供一个<code class="fe nc nd ne nf b">redis-commander</code>命令，当它被执行时，将在端口<code class="fe nc nd ne nf b">127.0.0.1:8081</code>上执行数据库web接口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/195a16b922378859263de40fdd10d817.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*l84foKYor73pesqe.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">redis-指挥官</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nz"><img src="../Images/a953fd4b51dd5dc227a1bcf58bc1f1f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXKzZ7Cu2YgKq6ZHTwQUtw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">redis-指挥官</p></figure><p id="27cf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们进入redis-commander时，我们会看到对我们的<code class="fe nc nd ne nf b">/character</code>请求的响应已经用我们分配给它的名称存储起来了。</p><p id="f096" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用Redis进行缓存的过程非常简单。当我们收到用户的请求时，我们首先检查请求的数据是否已经被缓存。如果是这样，我们可以快速从Redis检索数据并发送响应。</p><p id="0c97" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是，如果数据没有被缓存，我们称之为缓存未命中，我们必须首先从数据库或外部API检索数据，并将其发送给客户端。我们还确保将检索到的数据存储在缓存中，以便下次收到相同的请求时，我们可以更快地将缓存的数据发送给用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4397" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，我们正在从缓存中检索信息，响应时间大大减少到了4.230毫秒</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/35415df8826f3f9a268f558901e00c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLeC3YhWbeAx-sieK0wK9Q.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">/字符</p></figure><p id="4acd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">值得注意的是，我们在本教程中仅仅触及了皮毛，Redis提供的内容还远远不够。我强烈推荐查阅它的官方<a class="ae ku" href="https://redis.io/documentation" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="ef1f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是一个完整的脚本，还有一个端点接收参数的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="d4fb" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="d215" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">在本教程中，我们看到了Redis的快速介绍，并用它为Node.js应用程序创建了一个简单的缓存。</p><p id="efc4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，您可以使用Redis来缓存应用程序中频繁查询的数据，从而显著提高性能，特别是在每秒处理许多请求的项目中，Redis提供的性能变得非常重要。</p><h1 id="78cf" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">阅读更多:</strong></h1><div class="oa ob gp gr oc od"><a href="https://blog.bitsrc.io/how-to-create-instagram-filters-with-react-and-css-dce9f92753d0" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">如何用React和CSS创建Instagram滤镜</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">使用CSS Filter属性为HTML图像创建自定义滤镜</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">blog.bitsrc.io</p></div></div><div class="om l"><div class="on l oo op oq om or ko od"/></div></div></a></div><div class="oa ob gp gr oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/developing-a-crud-app-in-react-js-with-a-fake-api-rest-9f401bad5f04"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">用假的API Rest在React JS中开发CRUD应用</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">用JSON服务器添加CRUD功能</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">better编程. pub</p></div></div><div class="om l"><div class="os l oo op oq om or ko od"/></div></div></a></div><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="07af" class="nk ls it nf b gy nl nm l nn no"><strong class="nf iu">Want to Connect?<br/></strong>Love connecting with friends all around the world on <a class="ae ku" href="https://twitter.com/ljaviertovar" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>