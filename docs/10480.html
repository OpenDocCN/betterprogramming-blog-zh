<html>
<head>
<title>How to Use Swift Functions For Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Swift函数进行依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-functions-for-dependency-injection-in-swift-a885f38d8ed0?source=collection_archive---------9-----------------------#2022-01-10">https://betterprogramming.pub/use-functions-for-dependency-injection-in-swift-a885f38d8ed0?source=collection_archive---------9-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="34e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用协议的替代方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f259fe5051b7faea78c44503a9e71669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xm2UjqwKwJa4RCYsamEvSA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://undraw.co/search" rel="noopener ugc nofollow" target="_blank"> Undraw </a></p></figure><p id="58b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我写测试。</p><p id="7833" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢写测试。我喜欢有一个小按钮，在我修改代码后，它会告诉我是否出错了。通常它会说我搞砸了，但是，嘿，我是个人。</p><p id="7c88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，编写测试的一个关键技术是<em class="ls">依赖注入</em>。</p><p id="ff2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不确定什么是依赖注入？完全没问题。这里有一篇关于它的好的短文。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="e18b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我经常发现自己创建简单的协议来注入我需要在测试中控制的类型的实例(主要是因为随机性)，比如<code class="fe ma mb mc md b">UUID</code>或<code class="fe ma mb mc md b">Date</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="e057" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想知道，这些协议作为依赖项传递给需要<code class="fe ma mb mc md b">UUID</code>或<code class="fe ma mb mc md b">Date</code>实例的类。如果您想要控制创建哪个id或日期，则不能直接在类中创建这些实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ae01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我需要那种协议，因为我的测试需要它们。</p><p id="cda1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这些协议必须在产品代码中的某个地方实现。在这个例子中，我只需要这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="3c7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单。</p><p id="5a37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存根和测试呢？这些可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="f4bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我控制存根返回的<code class="fe ma mb mc md b">UUID</code>和<code class="fe ma mb mc md b">Date</code>的实例。我使用这些实例来创建一个预期的<code class="fe ma mb mc md b">Game</code>，用来与服务创建的游戏进行比较。</p><p id="3f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">利用依赖注入的简单测试。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a7cf" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">我不喜欢这种模式的地方是</h1><p id="2265" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我需要依赖注入来编写更好的测试。为了实现依赖注入，我创建了这些协议。</p><p id="fdc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我不喜欢创建和实现所有这些小协议所带来的样板文件。</p><p id="ed8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我需要注入的每一个依赖项，我必须创建一个协议，一个用于生产代码的真实实现，以及一个用于测试的存根实现。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="16bf" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用函数注入依赖关系</h1><p id="38a8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">通常，我为注入这些类型的对象而创建的协议被命名为<em class="ls">提供者</em>。比如<code class="fe ma mb mc md b">IdProvider</code>或者<code class="fe ma mb mc md b">WhateverYouNeedProvider</code>。一个例外是，如果我需要一个日期，那么协议被命名为<code class="fe ma mb mc md b">Clock</code>。</p><p id="58c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些协议往往只有一种不带参数的方法。<em class="ls">给我对象</em>方法。</p><p id="0704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我真正需要的协议只是一种方法。一个功能。</p><p id="c95d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数可以像任何其他对象一样作为参数传递(想想您一直在使用的那些完成处理程序)。</p><p id="7b5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我可以用一个行为类似于<code class="fe ma mb mc md b">provide() -&gt; UUID</code>方法的函数来替换类似于<code class="fe ma mb mc md b">IdProvider</code>的协议。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="4ddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协议被提供所需对象的函数所取代，如<code class="fe ma mb mc md b">getId: () -&gt; UUID</code>和<code class="fe ma mb mc md b">getDate() -&gt; Date</code>。</p><p id="46f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于没有协议，在生产代码上，我需要做的就是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="16bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以做一个测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="7598" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我不需要创建任何实现任何特定协议的类。没有更多的样板。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="be53" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">并非所有闪光的都是金子</h1><p id="6ada" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这种方法有利有弊。</p><p id="87f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，主要优势是您不再需要创建和实现多个协议。</p><p id="fa8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是就像上面的标题所说的，不是所有发光的都是金子。</p><p id="5f5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的一个缺点是依赖关系失去了一些声明性。这主要是因为我们丢失了命名参数。</p><p id="5730" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我有一个如下所示的日志协议:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="55fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个协议将被一个类型为<code class="fe ma mb mc md b">(String) -&gt; Void</code>的函数所取代。此处参数名称(<code class="fe ma mb mc md b">message:</code>)丢失。虽然这有点不方便，因为我们失去了一些声明性，但也没那么糟糕，不是吗？</p><p id="9b59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数可以作为<code class="fe ma mb mc md b">log: (String) -&gt; Void</code>注入，像<code class="fe ma mb mc md b">log("Some message")</code>一样使用。尽管缺少参数名(命名参数是我喜欢Swift的一个特性)，但是很容易推断出参数代表什么。</p><p id="5d7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果它需要两个参数呢？假设我们将文件名作为参数添加到我们的<code class="fe ma mb mc md b">Logger</code>协议中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="e895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，替换该协议的函数的类型为<code class="fe ma mb mc md b">(String, String) -&gt; Void</code>。如果没有更多的上下文，很难知道哪个参数是消息，哪个是文件名。</p><p id="64f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象使用这个协议作为一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="3d0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为在这种情况下最好还是遵守协议。因为没有命名参数，很难知道每个参数代表什么。</p><p id="5f14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以通过重命名变量来提供更多的参数信息。例如<code class="fe ma mb mc md b">logWithMessageAndFile: (String, String) -&gt; Void</code>有一点帮助。选择权在你。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6298" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">最后的想法</h1><p id="a6c8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">用功能代替协议是可能的。这是一种我喜欢用来避免样板代码的技术。但是我只在不影响代码可读性的时候才这么做。</p><p id="2078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是我工具箱中的一个很好的工具。希望你也觉得有用。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="e38e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢你能走到这一步！</p><pre class="kg kh ki kj gt nd md ne nf aw ng bi"><span id="90e5" class="nh mh iq md b gy ni nj l nk nl"><strong class="md ir">Want to Connect With the Author?</strong></span><span id="b2d1" class="nh mh iq md b gy nm nj l nk nl">You can find me on <a class="ae kv" href="https://twitter.com/pablomanuelli" rel="noopener ugc nofollow" target="_blank">Twitter</a> and <a class="ae kv" href="https://www.linkedin.com/in/pablo-manuelli/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>