<html>
<head>
<title>How I Built a Global Config-File Reader Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何构建一个全局配置文件阅读器包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-built-a-global-config-file-reader-package-5879f0e678ec?source=collection_archive---------8-----------------------#2020-03-29">https://betterprogramming.pub/how-i-built-a-global-config-file-reader-package-5879f0e678ec?source=collection_archive---------8-----------------------#2020-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2a48" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">按名称载入文件，不考虑扩展名</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/a46ad522f14d310bfc07c19b40906da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*OROfWr5J2ZaJjbRGzwl0Hw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">照片由<a class="ae kr" href="https://unsplash.com/@houcinencibphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">豪斯辛Ncib </a>在<a class="ae kr" href="https://unsplash.com/s/photos/reader?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4eaf" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">夜深了，我的孩子睡着了，我正在开发我最近构建的<a class="ae kr" href="https://github.com/alexcanessa/typescript-coverage-report" rel="noopener ugc nofollow" target="_blank">打字稿覆盖工具</a>(是的，我也写了一篇关于我如何构建它的<a class="ae kr" href="https://medium.com/better-programming/how-did-i-build-a-ts-coverage-report-tool-af34e110d02c" rel="noopener">文章)。</a></p><p id="c353" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">今晚我发现的一个问题是“<a class="ae kr" href="https://github.com/alexcanessa/typescript-coverage-report/issues/13" rel="noopener ugc nofollow" target="_blank">建议:添加配置文件</a>”</p><p id="8aea" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我去寻找我可以使用的选项，唯一可用的软件包是<a class="ae kr" href="https://www.npmjs.com/package/read-config" rel="noopener ugc nofollow" target="_blank"> read-config </a>、<a class="ae kr" href="https://www.npmjs.com/package/read-config-file" rel="noopener ugc nofollow" target="_blank"> read-config-file、</a>和<a class="ae kr" href="https://www.npmjs.com/package/config" rel="noopener ugc nofollow" target="_blank"> config </a>。但是没有一个能满足我的需求。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="ab7d" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">那么我需要什么？</h1><p id="553c" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">我指定了一个名称(例如，<code class="fe ms mt mu mv b">.eslintrc</code>)，工具会检查它的所有可能选项:</p><ul class=""><li id="9da1" class="mw mx iq ku b kv kw ky kz lb my lf mz lj na ln nb nc nd ne bi translated"><code class="fe ms mt mu mv b">.eslintrc</code></li><li id="bbf6" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated"><code class="fe ms mt mu mv b">.eslintrc.json</code></li><li id="ae51" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated"><code class="fe ms mt mu mv b">.eslintrc.yml</code></li><li id="45ba" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated"><code class="fe ms mt mu mv b">.eslintrc.yaml</code></li><li id="43de" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated"><code class="fe ms mt mu mv b">.eslintrc.js</code></li><li id="d145" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated"><code class="fe ms mt mu mv b">eslint.config.js</code>(特殊情况)</li><li id="e124" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated">并在<code class="fe ms mt mu mv b">package.json</code>中检查一个ESLint对象</li></ul><p id="fe7a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">第二个参数可能是<code class="fe ms mt mu mv b">options</code>，它允许您启用/禁用受支持的扩展——默认情况下都是活动的。</p><p id="dbff" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这就是我想的API:</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="86cc" class="no lw iq mv b gy np nq l nr ns">type Extension = "empty" | "json" | "yml" | "yaml" | "js" | "config.js" | "package";<br/>type Options = {<br/>  extensions: Record&lt;Extension, boolean&gt;;<br/>};</span><span id="974a" class="no lw iq mv b gy nt nq l nr ns">const getConfig(name: string, options: Options): object;</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="6ab2" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">设置</h1><p id="92b5" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">这不会花太长时间，但是让我们把我必须要做的事情列一个清单。</p><ol class=""><li id="5879" class="mw mx iq ku b kv kw ky kz lb my lf mz lj na ln nu nc nd ne bi translated">以打字打的文件</li><li id="8f7d" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nu nc nd ne bi translated">笑话和巴别塔</li><li id="eeb9" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nu nc nd ne bi translated">埃斯林特</li><li id="5f90" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nu nc nd ne bi translated">较美丽</li><li id="4b1a" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nu nc nd ne bi translated">和哈士奇一起上钩</li><li id="0225" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nu nc nd ne bi translated">问题模板</li><li id="f625" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nu nc nd ne bi translated">编辑器设置(<code class="fe ms mt mu mv b">.editorconfig</code>和<code class="fe ms mt mu mv b">.vscode/</code>)</li></ol><p id="0909" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我利用这个机会为任何类型脚本通用样板文件创建了一个GitHub模板repo。这就是<a class="ae kr" href="https://github.com/alexcanessa/template-generic-typescript" rel="noopener ugc nofollow" target="_blank">template-generic-typescript</a>看到光明的原因。</p><p id="cd37" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我不打算详细介绍我是如何研究单个技术的，因为有很多文章都是这样做的，但下面是最终的结构:</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="16af" class="no lw iq mv b gy np nq l nr ns">.<br/>├── .github/<br/>├── .vscode/<br/>├── dist/ # generated<br/>├── node_modules/ # generated<br/>├── src/<br/>├── .editorconfig<br/>├── .eslintignore<br/>├── .eslintrc.js<br/>├── .gitignore<br/>├── .npmignore<br/>├── .prettierrc.js<br/>├── README.md<br/>├── babel.config.js<br/>├── commitlint.config.js<br/>├── jest.config.js<br/>├── package.json<br/>├── tsconfig.json<br/>└── yarn.lock</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="4559" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">让我们编码</h1><p id="7c57" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">我喜欢的类型和我一开始想的差不多。但是现在我使用默认选项来构造<code class="fe ms mt mu mv b">Extensions</code>类型:</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="9592" class="no lw iq mv b gy np nq l nr ns">const defaultExtensions = {<br/>  empty: true, // e.g. .eslintrc<br/>  js: true,<br/>  "config.js": true,<br/>  json: true,<br/>  yml: true,<br/>  yaml: true,<br/>  package: true // for package.json<br/>};</span><span id="fac0" class="no lw iq mv b gy nt nq l nr ns">type Extensions = Record&lt;keyof typeof defaultExtensions, boolean&gt;;<br/>type Options = {<br/>  extensions: Extensions;<br/>};</span></pre><p id="da53" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我必须创建的第一个函数是遍历可用的扩展名并返回第一个可用的文件。优先级可以通过对象顺序来设置，但这并不重要。</p><p id="112b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为此，我需要将扩展名映射到实际文件名的东西:</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="6aa0" class="no lw iq mv b gy np nq l nr ns">const getFilename = (name: string, extension: Extension): string =&gt; {<br/>  if (extension === "package") {<br/>    return "package.json";<br/>  }</span><span id="71ff" class="no lw iq mv b gy nt nq l nr ns">if (extension === "empty") {<br/>    return name;<br/>  }</span><span id="3bed" class="no lw iq mv b gy nt nq l nr ns">if (extension === "config.js") {<br/>    return `${name.replace(/^\./, "").replace(/rc$/, "")}.${extension}`;<br/>  }</span><span id="3f3a" class="no lw iq mv b gy nt nq l nr ns">  return `${name}.${extension}`;<br/>};</span></pre><p id="ef47" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，我可以在我的<code class="fe ms mt mu mv b">findConfigurationFile</code>函数中使用它:</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="e3e4" class="no lw iq mv b gy np nq l nr ns">const findConfigurationFile = (name: string, extensions: Extensions): string =&gt;<br/>  Object.entries(extensions).reduce(<br/>    (filename, [extension, active]: [Extension, boolean]) =&gt; {<br/>      // I found the configuration file, no need to keep looking.<br/>      if (filename) {<br/>        return filename;<br/>      }</span><span id="57f2" class="no lw iq mv b gy nt nq l nr ns">      // The extension has been "disabled" in the options.<br/>      // Keep looking (filename is "" at this point).<br/>      if (!active) {<br/>        return filename;<br/>      }</span><span id="a84b" class="no lw iq mv b gy nt nq l nr ns">      // OK. Now I can look for it and, if exists I'll return it.<br/>      const completeFilename = getFilename(name, extension);</span><span id="ef0b" class="no lw iq mv b gy nt nq l nr ns">      if (fs.existsSync(completeFilename)) {<br/>        return completeFilename;<br/>      }</span><span id="76c5" class="no lw iq mv b gy nt nq l nr ns">      return "";<br/>    },<br/>    ""<br/>  );</span></pre><p id="fa52" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">最后，我可以使用<code class="fe ms mt mu mv b">getConfigFile</code>函数中的全部内容:</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="c29f" class="no lw iq mv b gy np nq l nr ns">const getConfigFile = (name: string, options?: Options): object =&gt; {<br/>  const extensions = Object.assign(<br/>    {},<br/>    defaultExtensions,<br/>    (options || {}).extensions<br/>  );<br/>  const foundFile = findConfigurationFile(name, extensions);</span><span id="f6c0" class="no lw iq mv b gy nt nq l nr ns">  return {};<br/>};</span></pre><p id="62c9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你可能已经注意到这个函数得到了<code class="fe ms mt mu mv b">foundFile</code>，但是返回了一个空的<code class="fe ms mt mu mv b">Object</code>。这是因为JSON和JS文件可能只是必需的，而YML和YAML文件有特殊的需求(所以这不是那么简单)。</p><p id="d384" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我很确定我用了一个包解决了这个问题。</p><h2 id="e06e" class="no lw iq bd lx nv nw dn mb nx ny dp mf lb nz oa mh lf ob oc mj lj od oe ml of bi translated">YAML问题</h2><p id="87d3" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">哦，是啊。现在我想起来了！这是必需的。但是现在，当我去寻找它时，我发现它上面有一个<code class="fe ms mt mu mv b">Deprecated</code> <strong class="ku ir"> </strong>标签，因为它所基于的一种节点技术已经过时了。</p><p id="cef8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是我们不要气馁。现在有了一个新的软件包，名字叫做——你猜怎么着？— require-yml。</p><p id="99d3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这非常好，因为无论您想加载YML还是JSON文件都没有关系:您可以使用带有任一扩展名的<code class="fe ms mt mu mv b">req()</code>函数。然而，如果我加载一个无扩展的配置(例如<code class="fe ms mt mu mv b">.eslintrc</code>)——可能是JSON或者YAML——这个函数不理解并返回<code class="fe ms mt mu mv b">undefined</code>。</p><p id="f849" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">好的。没问题。好像还有一个包:<code class="fe ms mt mu mv b"><a class="ae kr" href="https://www.npmjs.com/package/js-yaml" rel="noopener ugc nofollow" target="_blank">js-yaml</a></code>。就是这样！用法非常简单，我可以将它用于JSON和YAML。</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="e92a" class="no lw iq mv b gy np nq l nr ns">const getObjectFromConfigFile = (filename: string): object =&gt; {<br/>  const pathToFile = path.join(process.cwd(), filename);</span><span id="3795" class="no lw iq mv b gy nt nq l nr ns">  if (path.extname(filename) === ".js") {<br/>    return require(pathToFile);<br/>  }</span><span id="03b3" class="no lw iq mv b gy nt nq l nr ns">  return yaml.safeLoad(fs.readFileSync(pathToFile, "utf-8"));<br/>};</span></pre><p id="e312" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个软件包已经运行得相当好了；但是，我还是想改进一下。</p><p id="6aec" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我希望代码期待ESLint，并用<code class="fe ms mt mu mv b">.</code>和<code class="fe ms mt mu mv b">rc</code>检查所有选项。但不是现在。稍后我会创建一个问题，明天再做。</p><h2 id="676f" class="no lw iq bd lx nv nw dn mb nx ny dp mf lb nz oa mh lf ob oc mj lj od oe ml of bi translated">快到了</h2><p id="f035" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">我认为现在剩下的只是添加测试和一个README文件，然后我就可以开始使用我的全新工具了。</p><p id="2f9a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">嗯，只有一个公共函数，因此只有一个<code class="fe ms mt mu mv b">index.test.ts</code>文件。<br/>在我开始写测试之前，我列出了所有我想覆盖的<code class="fe ms mt mu mv b">it.todo</code>:</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="c5aa" class="no lw iq mv b gy np nq l nr ns">describe("globalConfigFile function", () =&gt; {<br/>  it.todo("loads a .json file");<br/>  it.todo("loads a .yml file");<br/>  it.todo("loads a .yaml file");<br/>  it.todo("loads an extension-free file");<br/>  it.todo("loads a .js file");<br/>  it.todo("loads a .config.js file");<br/>  it.todo("loads the package.json");<br/>  it.todo("throws an error if no files are found");<br/>  it.todo("throws an error if empty extensions are passed to options");<br/>});</span></pre><p id="288d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我发誓以前从没发生过这种事。为上述内容编写测试一次就覆盖了整个项目的100%。</p><p id="7d9c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我必须添加的一件事(测试指出了这一点)是一个<code class="fe ms mt mu mv b">root</code>选项。</p><p id="5a9f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">对于自述文件，这些天我按照<a class="ae kr" href="https://github.com/RichardLitt/standard-readme" rel="noopener ugc nofollow" target="_blank">标准自述文件</a>给它一点结构。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="041a" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="dadd" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">所以在几个小时内，我们制作了一个可以跨不同项目使用的功能工具(哦！我差点忘了我为什么要开始这个！).</p><p id="e452" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">总的来说，我强烈反对多此一举。我建议使用已经被使用、测试和改进过的包。</p><p id="af71" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然而，有时(很少)一部分功能或工具不在npm上，或者不适合我们的情况。也许使它工作所需的代码非常小，并被归入一个<code class="fe ms mt mu mv b">utils</code>函数。在这种情况下，我建议挑战自己，让它成为一个开源项目。</p><p id="9a69" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，我可以用我可以使用的新工具更新我的问题。</p></div></div>    
</body>
</html>