# 重新学习反应

> 原文：<https://betterprogramming.pub/relearning-react-3db1be5a3567>

## 从类到钩子

![](img/960de30f551ab87785033d06018a3d56.png)

照片由[莱因哈特朱利安](https://unsplash.com/@reinhartjulian?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

如果您开发 React 应用程序已经有一段时间了，那么您已经看到了 React 从类到函数的演变。但是即使在 Hooks 发布一年后，文档仍然主要以类为中心。经常听到开发人员问:“我如何用钩子做`componentDidUpdate`？”因为他们习惯于组件生命周期的基于类的范例。

既然钩子已经成熟，是时候让我们从基于类的范例转向功能性范例了。

尽管 React 的文档强调了一些不同之处，但它也附带提到了这些不同之处，并附有示例。本文深入探讨了哲学上的差异，以及它们如何改变我们对组件的看法。*

# 生命周期与任务

功能组件分解工作的方式不同于类组件。

## 类组件关注生命周期

基于类的组件在其生命周期的每一步都有成员方法:

*   **初始化:**
*   **效果图:** `render`
*   **副作用产生:** `componentDidMount` / `componentDidUpdate`
*   **清理:** `componentWillUnmount`

还有其他方法来转换数据和优化性能，但是这四个活动构成了组件的大部分功能。如果基于类的组件要在 React 应用程序中交互，它必须将其大部分功能附加到这些方法之一。

因为这五个方法是基于类的组件的主干，所以许多功能被组合在一起。在将一个组件分成这五种方法之前，通常要查看它需要做的所有事情。因此，基于类的组件是以生命周期为中心的。

## 功能组件专注于任务

从生命周期的角度来看，功能组件令人困惑。没有任何明显的生命周期，只有一个在渲染时运行的函数。功能组件从顶部开始，在底部结束，而不是组织所有必须在初始化、渲染、副作用生成和清理过程中运行的东西……就是这样。生命周期在哪里？

钩子让功能组件参与到组件生命周期中。但是钩子关注的不是生命周期，而是任务。

每次调用一个钩子，它都会产生某种任务。调用`useState`或`useReducer`返回一个状态和一个用新状态重新呈现组件的方法。调用`useEffect`或`useLayoutEffect`会产生一个任务，该任务在 DOM 可用时运行，并且可以选择在运行后清理。如果在调用`useMemo`或`useCallback`时一个依赖关系发生了变化，那么就会产生一个任务来返回一个对象或函数。

功能组件可以多次调用多个钩子。这使得功能组件是面向任务的。钩子让你创建小的、离散的工作单元，而不是把所有的东西都整合到一个单一的整体状态方法中。

## 为什么重要？

当构建基于类的组件时，自然要考虑需要做什么——做每件事需要什么步骤——然后将那些不相关的步骤组合成单一的方法。这可能会导致我们混淆不同任务的效果设置和拆卸，并忘记需要放在一起或应该分开的所有东西。

对于功能组件，每个钩子都可以是它自己的独立工作单元。甚至像`useState`这样简单的东西也可以让您将状态初始化和更新为单独的基于任务的单元，而不是将所有状态组合成`this.state`。

使用一个更复杂的钩子，比如`useEffect`，所有任务效果的设置和拆卸都在一个地方。我们可以将注意力集中在代码中的一个位置，来处理与给定任务相关的所有事情。我们甚至可以创建一个自定义钩子来封装整个轮询函数的设置、拆除和数据传播。

除了使组件更加基于任务之外，钩子还改变了组件主要功能的用途。最初，功能组件被描述为实现内容直接呈现的一种方式——将道具转换为表示的纯粹功能。

有了钩子，功能组件就变成了微型调度程序。main 函数从 props 收集数据，`useState` / `useReducer` / `useContext`为将来的渲染更新状态，用`useEffect` / `useLayoutEffect`创建和更新副作用，最后返回一个演示。它集中了组件的活动，允许自顶向下的行为流。

类迫使我们根据任务的功能来划分任务。钩子让我们把任务重新组合在一起。

# 字段与闭包

函数和类处理数据存储的方式也非常不同。

## 类组件依赖于字段

在一个班级里，一切都以`this`为基础。分别通过查看`this.props`和`this.state`来访问道具和状态。当副作用产生或者事件处理程序被添加到 DOM 元素时，它被绑定到`this`，这样它就可以引用那些属性和状态。

副作用和处理程序对对象的当前状态进行交互，而不是它们被创建时的状态。虽然这可能是您想要的，但这意味着您依赖可变数据。其他活动可以将数据从您的副作用下移出。

## 函数组件依赖于闭包中的常量

*闭包*是函数使用的所有外部变量和值的快照。每个函数都会创建一个，但通常，它是在函数被调用时创建的，在函数执行完毕时销毁。但是，如果该函数返回它创建的函数，则该函数将跟踪该快照:

功能组件大量使用闭包来跟踪信息。不是将变量和函数绑定到`this`，而是在主函数内部创建事件处理程序和效果。

当组件返回 JSX 或对效果进行排队时，事件处理程序和效果函数被传递到主函数之外，携带处理程序和函数需要的任何变量的冻结快照。

## 为什么重要？

功能组件变量不会改变，除非你让它们改变。当您调用由`useState`和`useReducer`返回的方法时，您告诉 React 以新的状态重新运行组件。这将使用新的闭包重新创建您的事件处理程序和副作用，并使用新的状态进行更新。

这可能很贵，取决于效果和处理程序的复杂程度。React 允许您定义对`useEffect` / `useLayoutEffect`的依赖关系，因此这些快照只在依赖关系改变时更新。这使您能够精确控制副作用更新的时间和方式。

但是你需要弄清楚什么需要改变。基于类的组件使得简单地从当前状态中提取值变得容易，但是使得很难知道当前状态如何同时与效果、状态和渲染交互。

您可以为一个用户创建副作用，切换用户，然后尝试为新用户清除副作用，而无需管理用户之间的切换。基于状态和属性的改变，变成了过渡、交换和移交效果的大漩涡。

对于功能组件，您需要真正了解您的状态和属性如何影响您的处理程序和副作用，因为您的效果将会被冻结，除非您确定它们的依赖关系。当你使用道具和状态而不考虑它时，ESLint 警告`react-hooks/exhaustive-deps`将是你追踪的朋友。

忽略或禁用它可能很有诱惑力。不要。如果你引用一个在每次渲染时创建的函数或对象，把这个函数/对象放在`useCallback` / `useMemo`中。

这使您可以跟踪这些项目中的任何依赖项，并防止每次都重新创建它们。您仍然希望将函数/对象标识为效果中的依赖项，但至少您知道它不会不必要地触发更新。

# 合成和重用

虽然功能性组件和基于类的组件都鼓励表示层的组合和依赖注入，但它们组合功能的方式不同。

## 类组件鼓励包装器和装饰器

React 不鼓励传统的基于 OOP 的继承模式和基于类的组件混合模式——这是正确的。它们创建了脆弱、不灵活和混乱的架构。

为了组合组件之间的功能，React 引入了高阶组件(hoc)的概念。hoc 将其他组件包装在一个生成新组件的函数中。这个新组件可以有自己的副作用，并为包装的组件引入新的属性。

hoc 鼓励基于类的组件参与包装器/装饰器架构。基于类的组件不是从不同的功能块构建一个组件，而是成为外部功能的接收者。

## 功能组件鼓励特性包含和封装

虽然功能组件可以与 hoc 一起使用，但它们通常会通过使用定制挂钩来鼓励特性包含。

自定义钩子以新的有趣的方式结合了基本的 React 钩子。比如`react-redux`，用`useContext`、`useEffect`、`useLayoutEffect`、`useReducer`、`useRef`来建立`useSelector`。

从这五个核心钩子中，`useSelector`让我们检索全局状态，并确保组件将在状态更新时重新呈现。它是如何做到的，在一个整洁的钩子中对我们是隐藏的。

定制挂钩允许组件挑选完成工作所需的专业任务。它们延续了基本钩子的基于任务的范例，但是隐藏了这些定制任务的复杂性。

## 为什么这很重要？

当基于类的组件*将*功能*应用到子组件*时，定制钩子*将*功能*注入到子组件*中。开发 hoc 是为了取代 mixins，但是开发 Hooks 是为了在需要的地方提供单独的任务。

这改变了如何重用功能的范例。hoc 的使用成本往往很高，需要为子组件所需的每种功能添加一个新的组件层。钩子在我们需要的地方增加了特定的功能。

这里有一个例子，说明我们如何编写一个简单的组件来重定向访问者。它从全局状态获取 URL。从那里，它还获得组件是否应该用新的 URL 替换当前的 URL，或者保持历史完整。它还让用户知道他们正在被重定向，带有国际化的消息。(这显然不是一个生产就绪的组件。这里只是演示一下构造上的区别。)

对于基于类的组件，这需要用三个独立的 hoc 包装我们的组件:一个用于全局状态，一个用于历史管理，一个用于翻译:

每当我们请求一个`<VisualRedirector/>`实例时，就会创建四个组件。

有了钩子，组件变得更加精简:

当功能组件包含外部功能时，它们是以有针对性的方式进行的。`useSelector`和`useHistory`拉取跟随它的效果要使用的特定数据，而`useTranslation`在需要的时候返回翻译函数。(注意，我们可以在这里这样做，因为整个组件是从上到下运行的。如果一个组件过早退出，所有钩子都需要出现在第一个退出点之前。)

钩子在它们的数据共享方面也更加明确。有了 hoc，属性就神奇地出现了。您可以看到基于类的组件访问了`history`、`redirect`、`t`和`url`——但不是它们来自哪里。然而，钩子在返回这些属性时会显式地标识。钩子更有迹可循。

# 把所有的放在一起

从基于类的范式转移到函数式范式需要一些思维上的转变，但这是值得的:

*   从生命周期到任务的转变让我们根据代码的目的来保持代码的完整性，而不是根据它应该在什么时候执行
*   跟踪闭包和依赖项而不是成员字段使得我们的数据跟踪更加明确和自文档化
*   使用定制钩子代替 hoc 让我们可以使用目标任务，而不是将我们的组件包装在其他组件中。

React 一直将函数式编程作为其范例。类很奇怪地适合这种范式。当您从类转移到函数时，您会发现其他函数式编程结构更容易适应这种范式，包括高阶函数、lambdas 和部分函数。你会发现自己更少考虑继承，更多考虑链接。

祝你好运！

*我最初开始了一个更长的系列来详细研究差异，但是它太长了。本文旨在更多地关注基于类和功能组件设计的思维模式和哲学，而不是深入本质。