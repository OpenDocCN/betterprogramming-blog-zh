<html>
<head>
<title>Loading Gists in a NextJS Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在NextJS应用程序中加载Gists</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/loading-gists-in-a-nextjs-application-cb60e3f9d523?source=collection_archive---------11-----------------------#2022-03-01">https://betterprogramming.pub/loading-gists-in-a-nextjs-application-cb60e3f9d523?source=collection_archive---------11-----------------------#2022-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="008b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何从NextJS博客的markdown页面加载GitHub Gists的教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e134dcec15f020709b827e2c776ca60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*poVqhn3nbvTSeNlajRO8yw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@synkevych?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗曼·辛克维奇</a>在<a class="ae ky" href="https://unsplash.com/s/photos/github?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="fd88" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="3ad2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我所有的博客文章都可以在我的个人网站上找到。在引擎盖下，它们被保存为降价文件。</p><p id="b522" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它让我可以轻松地写帖子，但是当我在其他平台上交叉发布时，我没有足够的时间来突出显示代码片段的语法和正确的颜色。</p><p id="990e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了让它在每个平台上都更漂亮，我使用了Github Gists。它在任何地方都表现得很好，但我不想在我的博客上有Github的代码块样式，但我更喜欢与我的网站设计相匹配的东西。为此，我必须修改我用来以我喜欢的方式加载和呈现来自gists的代码的markdown解析器。</p><p id="88a0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇文章中，我们将看到如何使用markdown文件创建一篇博客文章，如何创建和集成一个remark插件，用<code class="fe ms mt mu mv b">react-syntax-highlighter</code>突出显示恢复的代码，并尽可能保持良好的性能。</p><h1 id="d9f2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">初始情况:在NextJS页面中加载Markdown</h1><p id="a420" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在进入加载gists的代码之前，我们首先需要让blog加载markdown文件。为此，它需要两个不同的项目:</p><ul class=""><li id="d0f8" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated">包含博客文章的减价文件</li><li id="1429" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">包含markdown加载、解析和呈现的NextJS页面</li></ul><p id="a67a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们从降价文件开始</p><h2 id="4820" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">降价文件看起来像什么</h2><p id="2b9a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">markdown文件分为两个不同的部分:元数据和内容本身。</p><p id="cc65" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">元数据在这里给出作者、日期、使用的语言(我有法语和英语的帖子)、URL路径、标签等信息。</p><p id="e1e2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些信息通过开头的三个破折号<code class="fe ms mt mu mv b">——-</code>和结尾的三个破折号从内容中分离出来。</p><p id="2c19" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下是一篇博文的简单示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查“查看原始数据”链接</p></figure><p id="405a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">文件非常简单。如果你不熟悉markdown，你可以<a class="ae ky" href="https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax" rel="noopener ugc nofollow" target="_blank">从Github </a>阅读这篇文档开始:你将学习如何创建列表、链接、添加图片等等。</p><p id="f3fc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我的bog中，我有更多的元数据字段来处理规范链接、图像、标签等等。我把它们从那篇文章中删除了，因为它是这个主题不必要的噪音。</p><h2 id="a732" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">加载降价文件</h2><p id="b9c6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">呈现markdown文件的第一步是加载它。我们使用基本NodeJS代码来:</p><ul class=""><li id="657d" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated">查找文件夹中的所有文件</li><li id="6d32" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">仅筛选md/mdx文件</li><li id="2fcf" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">加载文件</li></ul><p id="3a12" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这可能有点过了，但是在我的博客上，我需要得到每一篇文章来找到与我当前文章最相似的文章，基于对它们的每一个公共标签的计算。无论如何，我将不得不加载每个帖子来找出答案。</p><p id="1162" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="47ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你正在创建一个简单的博客，你可能更喜欢直接加载正确的文件而不是所有的文件。为此，您只需使用<code class="fe ms mt mu mv b">fs.readFileSync</code>函数来获取您的文件。</p><p id="d0cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在帖子已经加载，我们需要在文件中搜索哪一个是适合我们当前页面的。</p><p id="ad86" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为此，我寻找与请求路径相同的帖子，但我首先需要解析我的markdown的元数据。我使用一个名为<code class="fe ms mt mu mv b">grey-matter</code>的包来获取它们。</p><p id="725d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="be81" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">loadGreyMatterPost</code>是一个函数，它以灰质格式返回一个表示我们降价的文件。我们仍然需要将它转换成HTML代码才能使用。如前所述，我还返回了所有的帖子，以便根据标签进行匹配。然而，这将不会在这篇文章中解释。</p><p id="d215" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为我使用的是NextJS，所以我现在可以使用包<code class="fe ms mt mu mv b">next-mdx-remote</code>将灰质格式转换成MDX格式。</p><p id="7e2d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="15d9" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">将加载的数据添加到NextJS路由中</h2><p id="43fe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了避免巨大而缓慢的负载，加载部分被添加到NextJS路由的<code class="fe ms mt mu mv b">getStaticProps</code>方法中。它将只在编译时解析文件，这对于markdown来说是可以的，并且尽可能快地提供静态页面。</p><p id="c38b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="173a" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">在页面中显示博客文章</h2><p id="67cc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们有了所有需要的信息，我们可以将它们包含在下一个JS页面中。</p><p id="069a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它需要两个外部组件:</p><ul class=""><li id="3ab5" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">MDXProvider</code>这是一个组件，可以处理每个子减价文件的默认信息</li><li id="b22f" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">MDXRemote</code>将MDX内容转换成HTML React组件</li></ul><p id="49db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="99b4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">完成了！我们现在能够编写markdown博客文章，并在我们的NextJS应用程序中将它们呈现为HTML！</p><h1 id="1030" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">创建备注插件</h1><h2 id="89a9" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">AST转换</h2><p id="8d85" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">备注插件是一个返回另一个函数函数。最后一个得到一个AST——抽象语法树——代表markdown文档。</p><p id="3687" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">AST可以获得许多字段，但这里有一个简单的typescript接口来说明它是如何构造的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b732" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用markdown时，代码的AST没有子元素或属性，而段落AST没有任何值。为了理解它是如何建立的，想象一下下面的降价:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查“查看原始数据”链接</p></figure><p id="4862" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相关的AST将是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d886" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">考虑到这一点，我们可以考虑如何包含我们的要点。</p><h2 id="02a1" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">从Github获取要点</h2><p id="d245" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我选择将要点包含在内嵌块代码中，前缀为<code class="fe ms mt mu mv b">gist:</code>，然后是用户名和ID。它看起来会像这样:</p><p id="60d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">`gist:brunosabot/00000000000000000000000000000000</code></p><p id="4f7b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当呈现这个内容时，生成的AST将由一个带有一个<code class="fe ms mt mu mv b">inlineCode</code>子节点的<code class="fe ms mt mu mv b">paragraph</code>节点组成。我们需要做的是替换从Github加载的代码中的段落。</p><p id="5589" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于我们需要来自Github的代码，我们也需要获取要点。要点可以由一个或几个文件组成:我们首先需要迭代文件列表，然后加载它们中的每一个。</p><p id="70df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0285" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一个fetch查询获取包含gist元数据的JSON，尤其是gist中的文件列表。</p><p id="64ae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当列表恢复后，我们迭代它们以文本形式加载与每个文件相关的代码。</p><h2 id="a512" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">访问和更新AST</h2><p id="0a39" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">gist插件应该改变原始AST的内容。我们将访问文档节点，并根据需要更新它。</p><p id="f106" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了访问不同的节点，我们使用了<code class="fe ms mt mu mv b">async-unist-util-visit</code>包。它将对每个匹配所请求类型的AST子节点应用一个方法。</p><p id="0205" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如前所述，我们将在<code class="fe ms mt mu mv b">paragraph</code>节点中寻找<code class="fe ms mt mu mv b">inlineCode</code>，从<code class="fe ms mt mu mv b">gist:</code>开始，然后解析它并加载要点。</p><p id="5873" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是让我们关注一下访问代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d5ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">需要注意的一件重要事情是，AST必须变异，不能返回。由于<code class="fe ms mt mu mv b">visit</code>是一个承诺，但不等待回调来解决，我们需要使用一个hack，将工作添加到承诺列表中，并在插件方法结束之前等待它们解决。</p><p id="149a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在代码片段中:</p><ul class=""><li id="18f4" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">node.children.some</code>方法在代码中寻找要点片段</li><li id="4f5c" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">Object.assign</code>方法是在不丢失引用的情况下更新对象内容的方法</li><li id="30b9" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">delete</code>不是强制的，但是我喜欢保持一个只有必填字段的清晰对象。</li></ul><p id="5568" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在插件中，我们使用了一个<code class="fe ms mt mu mv b">loadAndTransformGist</code>方法，当我们在代码中检测到一个要点片段时就会调用这个方法。</p><p id="5208" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如函数名中所写的，该方法将加载要点并进行适当的转换，以包含在AST中。</p><p id="9502" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是它的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="9e61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个代码片段中，第一部分是检查代码片段是否有效，这基本上是检查AST值是否为空。</p><p id="c88d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我可以再做一些检查，包括验证gist值是否正确。我选择不这样做，因为我经常检查我的帖子的渲染:我可以很快看到ID是错误的，因为应用程序要么崩溃，要么不显示任何东西。</p><p id="6f38" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后我提取要点ID，用之前创建的<code class="fe ms mt mu mv b">loadGist</code>方法加载它。</p><p id="e1dd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">那么，我有两种可能性:</p><p id="d01e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一，要点里只有一个文件。我将用一个方块样本替换当前段落。<code class="fe ms mt mu mv b">getGistAST</code>将给我代码AST，我将为调用方法返回该代码。</p><p id="77c0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第二，要点中有多个文件。我将对它们进行迭代，并将它们添加为段落节点的子节点。</p><p id="7d4c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">getGistAST</code>基本上是一个映射方法，代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e0de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">翻译成英语，这个AST节点是一个<code class="fe ms mt mu mv b">&lt;Gist&gt;</code>组件，具有:</p><ul class=""><li id="abd2" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated">代表文件名的文件属性</li><li id="e636" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">实际代码的代码属性</li><li id="a5b9" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">包含文件语言的阿郎属性，通过映射方法计算得出</li></ul><p id="41dd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是映射方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e0a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一切都完成了，我们只需要更新我们的<code class="fe ms mt mu mv b">transformGreyMatterToMDX</code>方法，添加插件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="b589" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用自定义呈现组件</h1><p id="09a0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在markdown能够读取要点片段，还有最后一步来进行实际的代码呈现:我们需要创建一个“要点”组件来进行适当的显示。</p><p id="8711" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为此，我将使用<a class="ae ky" href="https://www.npmjs.com/package/react-syntax-highlighter" rel="noopener ugc nofollow" target="_blank"> React语法荧光笔</a>包。</p><p id="275d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是组件的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f3b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们首先有一个div，如果文件名可以显示它的话。</p><p id="4b6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我们使用来自<code class="fe ms mt mu mv b">react-syntax-highlighter</code>的<code class="fe ms mt mu mv b">Prism</code>和以下属性:</p><ul class=""><li id="a63e" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">language</code>:代码片段所在的编程语言。如果不可用，我们设置<code class="fe ms mt mu mv b">text</code>为默认的非高亮语言</li><li id="e0c9" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">showLineNumbers</code>:侧面显示行号。如果是文字，最好不要有</li><li id="dc21" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">wrapLines</code>和<code class="fe ms mt mu mv b">wrapLongLines</code>:代码为<code class="fe ms mt mu mv b">text</code>换行时激活。我发现阅读高亮显示的代码并不容易。</li></ul><p id="2009" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要被识别，该要点组件需要包含在给予<code class="fe ms mt mu mv b">MDXProvider</code>的组件中</p><p id="e26a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e066" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另外，您可以看到我正在重写img组件以添加<code class="fe ms mt mu mv b">loading="lazy"</code>属性。我会帮助我的博客有更好的表现。</p><h1 id="9d31" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">尽可能保持好的表演</h1><p id="e3a9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">React Syntax Highlighter的一个问题是，它将加载大量您可能永远不需要的语言。</p><p id="bbf3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">希望有一种方法可以使用这个库的简化版本，但是它需要我们手动加载语言。</p><p id="0202" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下是加载系统的<code class="fe ms mt mu mv b">&lt;Gist&gt;</code>组件代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="27cc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="da65" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为NextJS博客创建一个Gist插件需要我们了解和操作AST格式，这可能不是小事。</p><p id="9947" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我希望这篇文章能帮助你理解它是如何工作的，以及你如何将你的gists文件添加到你的博客中。</p><pre class="kj kk kl km gt ny mv nz oa aw ob bi"><span id="95f3" class="nk la it mv b gy oc od l oe of"><strong class="mv iu">Want to Connect?</strong></span><span id="e923" class="nk la it mv b gy og od l oe of">If you want to learn more about JavaScript and React, feel free to follow me on <a class="ae ky" href="https://twitter.com/brunosabot" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>