<html>
<head>
<title>Getting Started With Vapor 4 —Learn By Building a Todo Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vapor 4入门—通过构建Todo应用程序来学习</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-vapor-4-part-1-3d731e64fb45?source=collection_archive---------8-----------------------#2022-03-24">https://betterprogramming.pub/getting-started-with-vapor-4-part-1-3d731e64fb45?source=collection_archive---------8-----------------------#2022-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f2d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解这一以Swift编写的服务器优先工具的基础知识(不那么基础)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e65d8681e5146783b12af4739dd82a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DuHsgJrzw6zc96EZQVUlRw.png"/></div></div></figure><h1 id="fb01" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="6dd7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我必须说，我在构建web应用程序方面没有太多经验，但作为一名iOS/macOS开发人员，我非常了解Swift。我以前听说过Vapor，但我从未深入研究过这个框架。我必须说，在花了一些时间通读他们的文件并试用之后，我很高兴。</p><p id="489c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这一系列文章中，我将解释Vapor必须提供的一些功能，同时我们将构建一个待办事项应用程序。这篇文章将主要关注于给出“什么是Vapor”的一点上下文，并且将覆盖一些基础知识，同时让我们接触这个框架。</p><p id="d0ee" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你可以在我的回购协议中找到完整的实现:</p><p id="8b90" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae mn" href="https://github.com/fermoya/vapor-tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/fermoya/vapor-tutorial</a></p><h1 id="3c31" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">概观</h1><h2 id="ff70" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">什么是蒸汽？</h2><p id="977e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="ae mn" href="https://vapor.codes" rel="noopener ugc nofollow" target="_blank"> Vapor </a>是用Swift编写的服务器端框架。它提供了一套工具来帮助您轻松地从头开始创建web应用程序和/或定义API来支持您的移动客户端。我们可以在其他著名的web应用程序框架中找到相似之处:</p><ul class=""><li id="050b" class="na nb it lo b lp mi ls mj lv nc lz nd md ne mh nf ng nh ni bi translated"><a class="ae mn" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjKvdbNg67wAhW5ahUIHSzsC1MQFjAAegQICBAD&amp;url=http%3A%2F%2Frubyonrails.org%2F&amp;usg=AOvVaw0epiqyAbLyZLd_L0nxpc1u" rel="noopener ugc nofollow" target="_blank">轨道上的红宝石</a>(红宝石)</li><li id="2e2e" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated">Django  (Python)</li><li id="7af8" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated"><a class="ae mn" href="https://symfony.com" rel="noopener ugc nofollow" target="_blank">交响乐</a> (PHP)</li><li id="ee4c" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated"><a class="ae mn" href="https://spring.io/projects/spring-framework" rel="noopener ugc nofollow" target="_blank"> Spring </a> (Java)</li></ul><h2 id="2ea7" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">为什么是蒸汽？</h2><p id="4289" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">经过一些研究，我发现Vapor被社区广泛接受。这是一个非常成熟的框架，提供了大量的可能性，易于使用，并且正是我所努力的。只需很少的配置，您就可以立即启动并运行它。</p><p id="e2d2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">另外，它是用我熟悉的Swift编写的，可以从Xcode使用，也可以从终端使用。不仅如此，Vapor可以在macOS和Linux上安装，甚至可以创建一个映像在Docker上运行。</p><h2 id="c9f5" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">它是唯一的服务器端Swift框架吗？</h2><p id="4678" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一点也不。目前，还有其他选择。还有<a class="ae mn" href="https://github.com/Kitura/Kitura" rel="noopener ugc nofollow" target="_blank">基图拉</a>和<a class="ae mn" href="https://www.perfect.org" rel="noopener ugc nofollow" target="_blank">完美</a>。然而，它们都没有像Vapor那样被广泛接受。</p><h1 id="6f0c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建你的第一个应用程序:TodoApp</h1><p id="1596" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果不是通过创建一个示例应用程序，告诉你什么是Vapor的最好方法是什么？让我们一起运行一个简单的例子来看看它是如何工作的。我们将创建一个待办事项应用程序，并使用您的终端、<a class="ae mn" href="https://www.postman.com" rel="noopener ugc nofollow" target="_blank"> Postman </a>或您可能喜欢的任何其他API客户端进行测试。</p><h2 id="a91b" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">装置</h2><p id="057e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果您还没有安装它，请继续运行<code class="fe no np nq nr b">brew install vapor</code>。确保您已经安装了<a class="ae mn" href="https://brew.sh" rel="noopener ugc nofollow" target="_blank"> Homebrew </a>，并且您的Swift版本是5.2+。</p><p id="d33f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">或者，如果你使用的是Linux，请遵循这里的说明<a class="ae mn" href="https://docs.vapor.codes/4.0/install/linux/" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="570d" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">新项目</h2><p id="a8ac" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">要从模板创建一个新项目，您只需要运行<code class="fe no np nq nr b">vapor new &lt;project_name&gt;</code>。默认情况下，Vapor会询问您是否愿意使用Leaf和/或Fluent(稍后会详细介绍)。用<code class="fe no np nq nr b">n</code>来回答这两个问题。或者，运行带有<code class="fe no np nq nr b">-n</code>选项的命令:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="d438" class="mo kv it nr b gy nw nx l ny nz">$ vapor new TodoApp -n</span></pre><h2 id="a3bf" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">项目结构</h2><p id="30fc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们快速看一下项目结构:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="8141" class="mo kv it nr b gy nw nx l ny nz">.<br/>├── Dockerfile<br/>├── Package.swift<br/>├── Sources<br/>│   ├── App<br/>│   │   ├── Controllers<br/>│   │   ├── configure.swift<br/>│   │   └── routes.swift<br/>│   └── Run<br/>│       └── main.swift<br/>├── Tests<br/>│   └── AppTests<br/>│       └── AppTests.swift<br/>└── docker-compose.yml</span></pre><p id="f2c2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您应该熟悉三个文件:</p><ul class=""><li id="9135" class="na nb it lo b lp mi ls mj lv nc lz nd md ne mh nf ng nh ni bi translated"><code class="fe no np nq nr b">main.swift</code>。这里是你的<code class="fe no np nq nr b">Application</code>被定义的地方。您可能希望这个文件基本上保持不变。</li><li id="9280" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated"><code class="fe no np nq nr b">configure.swift</code>。这是注册服务、配置数据库、定义一些中间件或启动队列系统等的最佳场所。您还可以更改HTTP配置(主机名、端口等)。</li><li id="54e8" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated"><code class="fe no np nq nr b">routes.swift</code>。使用此文件定义应用程序的端点和路由。在真实的应用程序中，您将处理数十个端点(如果不是更多的话)，因此，您会想要将相关的端点分组到<code class="fe no np nq nr b">Controllers</code>中。</li></ul><h2 id="5e59" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">运行应用程序</h2><p id="7a0d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">默认情况下，Vapor已经从一个模板创建了您的项目，因此您应该已经定义了几个端点(您可以在您的<code class="fe no np nq nr b">routes.swift</code>文件中仔细检查)。</p><p id="20a6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">运行应用程序有两种选择:</p><ul class=""><li id="2104" class="na nb it lo b lp mi ls mj lv nc lz nd md ne mh nf ng nh ni bi translated">从Xcode:在项目文件夹中运行<code class="fe no np nq nr b">vapor xcode</code>，然后运行⌘R。</li><li id="57fa" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated">从终端:运行<code class="fe no np nq nr b">vapor run serve</code></li></ul><p id="2d4d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">默认情况下，您的应用程序在<code class="fe no np nq nr b">127.0.0.1:8080</code>(或<code class="fe no np nq nr b">localhost:8080</code>)中运行。您可以使用以下命令轻松测试这一点:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="88da" class="mo kv it nr b gy nw nx l ny nz">$ curl localhost:8080/hello<br/>Hello, world!<strong class="nr iu">%</strong></span></pre><h1 id="616a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">待办事项列表:CRUD操作</h1><p id="94cf" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此时，我们的应用程序与待办事项列表唯一相关的就是项目名称。让我们通过让应用程序客户端创建一个新的待办事项列表来改变这一点。</p><h2 id="583c" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">Fluent和SQLite</h2><p id="b249" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="ae mn" href="https://docs.vapor.codes/4.0/fluent/overview/" rel="noopener ugc nofollow" target="_blank">流质</a>是在蒸汽中支撑的<a class="ae mn" href="https://en.wikipedia.org/wiki/Object–relational_mapping" rel="noopener ugc nofollow" target="_blank">形态</a>。它正式支持SQLite、MySQL、PostgreSQL和MongoDB。由于我们的应用程序处于早期阶段，我们将使用支持内存数据库的SQLite的驱动程序。在实际应用程序中，您可能希望使用持久数据库，但是对于本教程来说，内存数据库也可以。</p><p id="0813" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要配置Fluent和SQLite，请转到您的<code class="fe no np nq nr b">Package.swift</code>并添加Fluent和FluentSQLiteDriver。它应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/57aacc6c984875bbcd9f4789462802ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsvhCeK1YNxrnc5RvldsZw.png"/></div></div></figure><p id="83dc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">保持文件的其余部分不变。最后，在您的<code class="fe no np nq nr b">configure.swift</code>中，添加以下内容:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="eb1f" class="mo kv it nr b gy nw nx l ny nz">import Vapor<br/>import Fluent<br/>import FluentSQLiteDriver</span><span id="784c" class="mo kv it nr b gy ob nx l ny nz">public func configure(_ app: Application) throws {<br/>  app.databases.use(.sqlite(.memory), as: .sqlite)<br/>  try routes(app)<br/>}</span></pre><h2 id="3999" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">模型和迁移</h2><p id="8034" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe no np nq nr b">Model</code>是Fluent理解的实体，而迁移是负责创建/更新数据库表的代码。有点像所有变更的记录簿或版本控制(因此，它们添加的顺序很重要)。</p><p id="28b1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们从我们的<code class="fe no np nq nr b">Model</code>开始，定义我们的<code class="fe no np nq nr b">TodoList</code>将会是什么样子，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="83fe" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">目前，一个<code class="fe no np nq nr b">TodoList</code>将只包含一个<code class="fe no np nq nr b">name</code>。注意<code class="fe no np nq nr b">@ID</code>和<code class="fe no np nq nr b">@Field</code>的使用。前者指示哪个字段将被视为表查找键。后者用于定义表列的名称。也就是说，<code class="fe no np nq nr b">Model</code>定义了一个数据库表，因此它也通过定义<code class="fe no np nq nr b">schema</code>来定义其名称。</p><p id="7181" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一旦我们的模型被定义，我们唯一需要做的事情就是创建一个<code class="fe no np nq nr b">Migration</code>来创建表格，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="18e9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意这里迁移将如何创建一个包含两列的表:一个<code class="fe no np nq nr b">id</code>和一个<code class="fe no np nq nr b">name</code>。确保这些名称与模型中定义的名称相同。如果要恢复这个迁移，操作将是相反的:删除表。</p><p id="a3cf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，在您的<code class="fe no np nq nr b">configure.swift</code>中注册您的迁移，如下所示:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="869a" class="mo kv it nr b gy nw nx l ny nz">// after registering your database...<br/>app.migrations.add(TodoMigration(), to: .sqlite)</span><span id="76fe" class="mo kv it nr b gy ob nx l ny nz">try app.autoMigrate().wait()</span></pre><p id="8fd1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">注意:</strong>当我们使用内存数据库时，需要自动迁移。</p><h2 id="416f" class="mo kv it bd kw mp mq dn la mr ms dp le lv mt mu lg lz mv mw li md mx my lk mz bi translated">路线</h2><p id="adb4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此时，我们已经准备好开始定义一些端点。我们将考虑两种操作:</p><ul class=""><li id="70b7" class="na nb it lo b lp mi ls mj lv nc lz nd md ne mh nf ng nh ni bi translated">GET:我们将返回所有可用的<code class="fe no np nq nr b">TodoList</code></li><li id="6972" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated">帖子:我们将允许客户端创建一个新的<code class="fe no np nq nr b">TodoList</code></li></ul><p id="3bcc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">端点在<code class="fe no np nq nr b">routes.swift</code>中定义。打开它，您会注意到一个<code class="fe no np nq nr b">func routes(_:)</code>，它将一个<code class="fe no np nq nr b">Application</code>作为参数。该功能从<code class="fe no np nq nr b">configure.swift</code>调用，用于定义您的应用程序允许的所有路线。</p><p id="3b32" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">继续将下面的代码放入其中:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="4538" class="mo kv it nr b gy nw nx l ny nz">app.get("todo-lists") { req in<br/>  TodoList.query(on: req.db)<br/>    .all()<br/>    .encodeResponse(for: req)<br/>}</span></pre><p id="3ee7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是这段代码的作用:</p><ul class=""><li id="ddf5" class="na nb it lo b lp mi ls mj lv nc lz nd md ne mh nf ng nh ni bi translated">它定义了一个路径为<code class="fe no np nq nr b">todo-lists</code>的<code class="fe no np nq nr b">GET</code>路由/端点</li><li id="571e" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated">当被调用时，我们查询<code class="fe no np nq nr b">database</code>以返回所有可用的<code class="fe no np nq nr b">TodoList</code></li><li id="8380" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated">最后，返回数组<code class="fe no np nq nr b">[TodoList]</code>作为响应</li></ul><p id="74ac" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在继续之前，您会注意到一个编译器错误。这是因为，为了将实体编码为JSON响应以从请求中解码，实体/模型需要符合<code class="fe no np nq nr b">Content</code>:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="ed29" class="mo kv it nr b gy nw nx l ny nz">import Vapor</span><span id="d96b" class="mo kv it nr b gy ob nx l ny nz">extension TodoList: Content { }</span></pre><p id="0e5f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您定义的每个新端点都需要返回and <code class="fe no np nq nr b">EventLoopFuture</code>。这只是一个异步操作的包装器，每当您的端点被调用时都会运行。Vapor建立在SwiftNIO之上。</p><p id="fb6d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">注:</strong>从最新的Vapor版本开始，<a class="ae mn" href="https://docs.vapor.codes/4.0/async/" rel="noopener ugc nofollow" target="_blank"> Vapor支持</a> <code class="fe no np nq nr b"><a class="ae mn" href="https://docs.vapor.codes/4.0/async/" rel="noopener ugc nofollow" target="_blank">async/await</a></code>。这意味着先前定义的端点也可以表示如下:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="cce3" class="mo kv it nr b gy nw nx l ny nz">app.get("todo-lists") { req in<br/>  try await TodoList<br/>    .query(on: req.db)<br/>    .all()<br/>    .get()<br/>}</span></pre><p id="5ce8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了兼容，我们将坚持使用<code class="fe no np nq nr b">EventLoopFuture</code>的方式。</p><p id="1e4f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">类似地，我们可以定义一个<code class="fe no np nq nr b">POST</code>操作来创建一个<code class="fe no np nq nr b">TodoList</code>:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="b611" class="mo kv it nr b gy nw nx l ny nz">app.post("todo-lists") { req in<br/>  try req.content<br/>    .decode(TodoList.self)<br/>    .save(on: req.db)<br/>    .transform(to: Response(status: .created))<br/>}</span></pre><p id="c908" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这种情况下，我们使用<code class="fe no np nq nr b">post(_:use:)</code>来定义一个<code class="fe no np nq nr b">POST</code>操作，其中我们:</p><ul class=""><li id="8703" class="na nb it lo b lp mi ls mj lv nc lz nd md ne mh nf ng nh ni bi translated">尝试从请求内容中解码出一个<code class="fe no np nq nr b">TodoList</code></li><li id="3783" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated">我们将它保存在数据库中</li><li id="e32e" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated">我们将结果转换成一个<code class="fe no np nq nr b">HTTP 201 Created</code>响应</li></ul><p id="2606" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们试一试:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="c9c0" class="mo kv it nr b gy nw nx l ny nz">$ curl localhost:8080/todo-lists<br/>[]<strong class="nr iu">%<br/></strong>$ curl -X POST localhost:8080/todo-lists -H "Content-Type:application/json" --data "{ \"name\": \"My first TODO list\" }"<br/>$ curl localhost:8080/todo-lists | jq<br/>[<br/>  {<br/>    "id": "77D8FD15-D6C4-4EE1-9996-601370ED3329",<br/>    "name": "My first TODO list"<br/>  }<br/>]</span></pre><p id="5825" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">干得好，这真是太棒了！我们目前已经设置了创建读取操作。我将把更新和删除的实现作为完成所有CRUD的练习。提示:<code class="fe no np nq nr b">app</code>定义了一个<code class="fe no np nq nr b">put</code>(也是一个<code class="fe no np nq nr b">path</code>)和一个<code class="fe no np nq nr b">delete</code>方法。</p><h1 id="7b10" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="0557" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">至此，您将有希望有机会掌握Vapor，并像我一样热爱它。在后面的文章中，我们将继续扩展TodoApp并涵盖:</p><ul class=""><li id="0a9a" class="na nb it lo b lp mi ls mj lv nc lz nd md ne mh nf ng nh ni bi translated">高级路由</li><li id="58d5" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated">参数和查询参数</li><li id="6eb1" class="na nb it lo b lp nj ls nk lv nl lz nm md nn mh nf ng nh ni bi translated">模型关系</li></ul><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/getting-started-with-vapor-4-model-relationships-e6e73d6c2412"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">Vapor 4入门—模型关系</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">扩展待办事项应用程序，了解这一以Swift编写的服务器优先工具的更多高级功能</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">better编程. pub</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><p id="3974" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">感谢阅读！</p><p id="43b9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">祝你好运。</p></div></div>    
</body>
</html>