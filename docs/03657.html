<html>
<head>
<title>How to Create SSL Certificates for Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为开发创建SSL证书</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-ssl-certificates-for-development-861237235933?source=collection_archive---------1-----------------------#2020-02-25">https://betterprogramming.pub/how-to-create-ssl-certificates-for-development-861237235933?source=collection_archive---------1-----------------------#2020-02-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9920" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">自动生成SSL证书</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/09d42fe888fecc9b5ba670c2074e6087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjmW7PDHDjcxQQeBN4UaKA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">我如何看待证书，作者创造的形象</p></figure><p id="335a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">上周，我开始实现MQ遥测(MQTT)代理。MQTT 是一种轻量级发布-订阅协议，用于物联网(IoT)解决方案。这个代理必须接收传感器数据，并将其重新发送给其他MQTT客户机。通信必须安全。</p><p id="fed7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这种情况下，安全意味着使用证书。</p><p id="3727" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">好了，证件，哎，又来了。我通过我的鼻子呼气，并聚集自己。我从来不喜欢和证书打交道。我在网上搜索，找到了如何生成自签名证书。“我真的应该自动化这项工作，”我记得以前有过几次这样的想法…</p><p id="3c51" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是不知何故，我总是通过在终端中键入命令来创建证书。然后我继续这个项目，再也不回头。</p><p id="db57" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我对证书总是又爱又恨。我从来不明白它们是如何工作的，但在开发过程中偶尔需要它们。</p><p id="8296" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以，我最终创作了这篇文章。对我来说是未来的参考。它包含了从开发人员的角度理解证书的足够细节。</p><p id="b10f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">除此之外，我最终自动创建了一个本地信任的开发证书。见此<a class="ae lv" href="https://github.com/PatrickKalkman/Developer-SSL-Certificates" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><p id="c57d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">希望你会觉得有用。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c9bd" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">一点理论</h1><p id="8b4d" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">我保证，只会一点点。</p><p id="ad37" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们需要证书吗？</p><p id="ef09" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">是的，我们有。我们需要证书有两个主要原因。</p><ul class=""><li id="220d" class="na nb iu lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">数据的安全传输。</li><li id="d578" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">发送者或接收者的标识。</li></ul><h2 id="49bd" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">数据的安全传输</h2><p id="9fa2" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">您可以使用两种类型的加密来安全地传输数据，对称和非对称。两者各有利弊。稍后，我们将看到当浏览器使用HTTPS连接到网站时，浏览器会使用这两种类型的加密。</p><p id="88ec" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">对称加密和非对称加密有什么区别？</strong></p><p id="de9e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我发现<em class="oa">对称</em>加密最容易理解。发送方和接收方共享一个密钥。发送者使用这个密钥来改变要发送的消息。收件人使用相同的密钥来恢复原始邮件。</p><p id="5754" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对我来说，加密总感觉有点像魔法。在这种情况下，您创建了两个属于一起的键。第一个是公钥。你可以和任何想给你发信息的人分享。第二个密钥是秘密密钥。只有你需要知道。</p><p id="9caf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果使用公钥加密邮件，则只能使用私钥解密。此外，如果使用私钥加密消息，则只能使用公钥解密。纯粹的魔法。</p><p id="56ce" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用SSL时，两种类型的加密都会用到。</p><h2 id="7dbe" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">SSL通信(简化)</h2><p id="b40d" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">当浏览器连接到使用SSL的网站时，浏览器会执行以下步骤。</p><ol class=""><li id="21e8" class="na nb iu lb b lc ld lf lg li nc lm nd lq ne lu ob ng nh ni bi translated">您指示浏览器通过HTTPS连接到一个网站。浏览器要求web服务器标识自己。</li><li id="ad33" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu ob ng nh ni bi translated">web服务器将其证书的副本发送回浏览器。</li><li id="a353" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu ob ng nh ni bi translated">浏览器验证证书的身份。证书中的名称与域名匹配吗？我信任签署证书的证书颁发机构吗？</li><li id="8f22" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu ob ng nh ni bi translated">浏览器生成一个密码，并使用公钥对其进行加密。它从证书中检索公钥。这是不对称加密。浏览器将加密的密码发送到web服务器。</li><li id="7a77" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu ob ng nh ni bi translated">web服务器使用私钥解密密码。</li><li id="3271" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu ob ng nh ni bi translated">浏览器建立一个加密连接。双方都使用先前生成的密码加密和解密数据。这是对称加密。</li></ol><p id="5182" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">浏览器只使用非对称加密来传输密码的原因与非对称加密的性能有关。不对称加密比对称加密慢得多。</p><h2 id="0df1" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">发送者或接收者的身份</h2><p id="ce85" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">证书也用于识别。这样，您就可以确定您实际上连接到了正确的网站。</p><p id="23b3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">验证有两种方式。首先，浏览器验证web服务器返回的证书是否可信。这是通过确保证书由证书颁发机构(CA)签名来检查的。</p><p id="a49c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">设备的操作系统包含可信证书列表。</p><p id="bc22" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，请参见下面显示了<a class="ae lv" href="https://www.identrust.com/" rel="noopener ugc nofollow" target="_blank"> IdenTrust </a>根证书的截图。IdenTrust根证书是最常用的CA证书之一。主要是因为<a class="ae lv" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>证书是由IdenTrust交叉签名的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oc"><img src="../Images/da533152085986216762edd8fa40016d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5Zvc23YMcUP0Pdp58ywkg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">macOS上的“钥匙串访问”应用程序显示受信任的CA证书</p></figure><p id="d65e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">浏览器使用可信证书列表来验证收到的证书是否由列表中的CA签名。</p><p id="f58b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">第二种类型的身份验证是验证证书的通用名称是否与为该证书提供服务的域相对应。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj od"><img src="../Images/a27141c676d0deb0304f21e02e92f865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLCdhVIxH6Vx2PJzDGo98Q.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自www.google.com的证书，通用名*.google.com</p></figure><h2 id="80bb" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">证书文件格式</h2><p id="1bc8" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">存储证书有许多不同的格式。有时，我会看到文件格式使用不当。以下格式用于证书。</p><p id="4a64" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> PEM格式</strong></p><p id="da44" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">隐私增强邮件(PEM)格式是存储私钥证书的最常见格式。该文件的内容是Base64编码的ASCII。</p><p id="5481" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">文件可以有扩展名<code class="fe oe of og oh b">.pem</code>、<code class="fe oe of og oh b">.crt</code>、<code class="fe oe of og oh b">.key</code>或<code class="fe oe of og oh b">.ca-bundle</code>。为了确保该文件确实是一个PEM文件，打开它并检查它是否以<code class="fe oe of og oh b">BEGIN CERTIFICATE</code>或<code class="fe oe of og oh b">BEGIN RSA PRIVATE KEY</code>开头。</p><p id="985e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> P7B格式</strong></p><p id="b33b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">P7B或PKCS#7格式的文件也存储在Base64编码的ASCII中。</p><p id="4ea4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该文件的扩展名为<code class="fe oe of og oh b">.p7b</code>或<code class="fe oe of og oh b">.p7c</code>。P7B格式只能用于存储证书，不能用于存储私钥。该文件格式在Windows和Java Tomcat上使用。</p><p id="886e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> DER格式</strong></p><p id="9eb1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">可分辨编码规则(DER)格式以二进制格式存储证书和私钥。文件的扩展名为<code class="fe oe of og oh b">.der</code>或<code class="fe oe of og oh b">.cer</code>。DER格式经常在Java平台上使用。</p><p id="050b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> PKCS#12格式</strong></p><p id="2410" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">PKCS#12或PFX格式存储在二进制文件中。私钥和证书存储在一个文件中。</p><p id="8b30" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该文件的扩展名为<code class="fe oe of og oh b">.pfx</code>或<code class="fe oe of og oh b">.p12</code>。这些文件在Windows和macOS上用于导入和导出证书和私钥。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5d5f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">生成一次性自签名证书</h1><p id="d49f" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">自签名证书可以在任何计算机上生成。我用的是<a class="ae lv" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank">OpenSSL</a>1 . 1版本的macOS。OpenSSL是一个全功能的工具包和加密库。对于大多数操作系统来说，都有现成的OpenSSL二进制包。</p><p id="c9c2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">生成自签名证书需要以下步骤</p><ul class=""><li id="813f" class="na nb iu lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">生成私钥。</li><li id="bd05" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">创建证书签名请求。</li><li id="a479" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">生成证书。</li></ul><h2 id="6de3" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">1.生成私钥</h2><p id="3752" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">第一步是通过执行以下命令创建一个私钥。</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="dad4" class="no me iu oh b gz om on l oo op">openssl genpkey -algorithm RSA -des3 -out private-key.pem -pkeyopt rsa_keygen_bits:4096</span></pre><p id="5b6f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">genpkey</code> —在这种情况下，要执行的OpenSSL命令生成一个私钥</p><p id="beaf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">algorithm RSA</code> —使用哪个公钥算法。其他选项可用，如RSA-PSS、EC、X25519、X448、ED25519和ED448。</p><p id="8dcf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-des3</code> —该选项指定OpenSSL必须使用Triple-DES加密私钥。在执行命令时，它会询问使用哪个密码。</p><p id="4650" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">out privateKey.pem</code> — OpenSSL应该将私钥存储在一个名为<code class="fe oe of og oh b">privateKey.pem</code>的文件中。</p><p id="a444" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">pkeyopt rsa_keygen_bits:4096</code> —指定生成的密钥应该使用的位数。我用4096位。</p><p id="b0f3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">输出文件<code class="fe oe of og oh b">privateKey.pem</code>的格式默认为PEM文件。通过<code class="fe oe of og oh b">genpkey</code>，OpenSSL使用PKCS #8语法将密钥存储在文件中。</p><p id="3d26" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我使用<code class="fe oe of og oh b">genpkey</code>而不是<code class="fe oe of og oh b">genrsa</code>，因为它使用了更合理的默认值。</p><p id="c235" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，<code class="fe oe of og oh b">genrsa</code>的生成密钥的默认位数是512位。根据2015年ars TECHNICA的数据，使用一台75美元的亚马逊EC2可以在四个小时内破解。</p><h2 id="0e09" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">2.创建证书签名请求(CSR)</h2><p id="b0cb" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">CSR就像创建证书的订单。如果您需要官方SSL证书，您可以将其发送给官方证书颁发机构(CA)。他们使用CSR生成官方证书。</p><p id="6c28" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是，我们将使用这个请求自己生成一个证书，一个自签名证书。</p><p id="848a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">之前，我描述了使用证书的两个主要原因:加密和身份识别。OpenSSL会问一些问题，以了解在CSR中应该放入什么信息。</p><p id="5503" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">询问您<code class="fe oe of og oh b">Common Name</code>的问题对于识别身份非常重要。您应该回答要使用证书的完全限定域名。这也可以是内部域、本地主机或IP地址。</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="3ea5" class="no me iu oh b gz om on l oo op">openssl req -new -key private-key.pem -out csr.pem</span></pre><p id="ae39" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">req</code> —创建PKCS#10格式的证书请求。</p><p id="7a1f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-new</code> —生成新的证书请求。向用户询问所有需要的信息。</p><p id="7462" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-key</code> —要使用的私钥的文件名。私钥是在上一步中生成的。</p><p id="d3bf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-out</code> —创建的证书请求的文件名。</p><p id="f55a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">OpenSSL将询问以下问题:</p><ul class=""><li id="ae09" class="na nb iu lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">公用名:您希望使用证书保护的FQDN(完全限定的域名)。</li><li id="e31c" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">组织:您的组织的全名。仅对可信证书重要。</li><li id="9553" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">组织单元(OU):您的部门。仅对可信证书重要。</li><li id="2a16" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">城市或地区:您的组织所在的城市。</li><li id="6494" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">州或省:您的组织所在的州或省。</li><li id="d3de" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">国家/地区:您的组织所在的两个字母的官方国家/地区代码。</li></ul><h2 id="c023" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">3.创建自签名证书</h2><p id="61b5" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">使用第一步中的私钥和第二步中的证书请求，您可以创建一个自签名证书。以下OpenSSL命令创建证书。</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="3425" class="no me iu oh b gz om on l oo op">openssl x509 -in csr.pem -out certificate.pem -req -signkey private-key.pem -days 365</span></pre><p id="03ee" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">x509</code> —执行证书命令。</p><p id="efc9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-in</code> —表示证书签名请求(<code class="fe oe of og oh b">csr.pem</code>)。</p><p id="4439" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-out</code> —用于保存生成的证书的文件名。在这种情况下，<code class="fe oe of og oh b">certificate.pem</code>。</p><p id="ad08" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-req</code> —向OpenSSL指示输入是CSR。</p><p id="af06" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-signkey</code> —使用给定的<code class="fe oe of og oh b">private-key.pem</code>文件对证书请求进行自签名。</p><p id="b329" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-days</code> —生成的证书有效的天数。正常值为365、730和1095天，以指定一年、两年或三年的持续时间。</p><p id="7ab8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您现在有了一个可以用于本地开发的<code class="fe oe of og oh b">certificate.pem</code>文件。根据您的开发环境，您可能需要将证书转换为另一种格式。</p><p id="36d4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于Node.js开发，您可以直接使用<code class="fe oe of og oh b">certificate.pem</code>文件。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="b62d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">创建多个自签名证书</h1><p id="eefa" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">简单地生成一个自签名证书对于一个人的项目来说非常有用。如果您有多个项目或与一个开发团队合作，为每个项目创建所有这些自签名证书并将其导入每个开发人员的证书存储区会变得很麻烦。</p><p id="350f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当然，您可以创建脚本来生成它们，但是我认为自己创建一个认证机构(CA)是一个更好的解决方案。</p><p id="42e0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以通过创建CA证书来成为CA，并使用此证书来签署您的自签名证书。您的开发团队可以信任该CA证书，并将自动信任所有生成的用该CA证书签名的证书。</p><p id="1ce8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要成为证书颁发机构并签署自签名证书，您必须执行以下步骤:</p><ul class=""><li id="4086" class="na nb iu lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">为CA生成私钥。</li><li id="99d9" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">生成根证书。</li><li id="72cc" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">为证书创建私钥。</li><li id="d69a" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">创建证书签名请求。</li><li id="0881" class="na nb iu lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">创建一个证书并用CA私钥对其进行签名</li></ul><h2 id="cafa" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">1.为CA生成私钥</h2><p id="c4db" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">可以使用以下命令生成CA的私钥。</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="173e" class="no me iu oh b gz om on l oo op">openssl genpkey -algorithm RSA -des3 -out private-key-ca.pem -pkeyopt rsa_keygen_bits:4096</span></pre><p id="585d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该命令与为自签名证书生成私钥的命令没有什么不同。唯一的区别是文件名<code class="fe oe of og oh b">private-key-ca.pem</code>。</p><p id="90c6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该命令在当前目录下生成文件<code class="fe oe of og oh b">private-key-ca.pem</code>。</p><h2 id="cd48" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">2.生成根证书</h2><p id="b076" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">使用下面的命令，我们根据上一步中生成的私钥直接生成根证书。</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="a613" class="no me iu oh b gz om on l oo op">openssl req -x509 -new -key private-key-ca.pem -sha256 -days 3650 -out ca-certificate.pem</span></pre><p id="94e5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">OpenSSL再次询问私钥的密码短语，并询问在根证书中放入什么信息。</p><p id="18ec" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这种情况下，您提供的答案并不真正相关。我唯一推荐的是向其中一个字段添加信息，这样您就可以看到这是根证书。</p><p id="cef1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该命令在当前目录下生成文件<code class="fe oe of og oh b">ca-certificate.pem</code>。</p><h2 id="3a35" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">3.为证书创建私钥</h2><p id="a802" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">使用我们之前使用的以下命令，我们为这个特定的证书生成一个私钥。</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="0b62" class="no me iu oh b gz om on l oo op">openssl genpkey -algorithm RSA -des3 -out private-key.pem -pkeyopt rsa_keygen_bits:4096</span></pre><p id="8437" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该命令在当前目录下生成文件<code class="fe oe of og oh b">private-key.pem</code>。</p><h2 id="86a9" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">4.创建证书签名请求</h2><p id="da67" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">使用下面的命令，我们以前也使用过，我们生成证书签名请求。</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="00ed" class="no me iu oh b gz om on l oo op">openssl req -new -key private-key.pem -out csr.pem</span></pre><p id="4713" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">OpenSSL将再次询问一些问题以放入证书签名请求中。一个重要的问题是<em class="oa">的通用名称</em>。将此设置为您想要使用证书的域名或IP地址。</p><p id="bc5a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">较新的浏览器使用主题备用名称(SAN)来存储DNS名称或IP地址。请参阅本文后面关于SAN的部分。</p><h2 id="e664" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">5.创建一个证书并用CA私钥对其签名</h2><p id="1297" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">以下命令创建自签名证书，并用CA的私钥对其进行签名。</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="714f" class="no me iu oh b gz om on l oo op">openssl x509 -req -in csr.pem -CA ca-certificate.pem -CAkey private-key-ca.pem -CAcreateserial -out certificate.crt -days 3650</span></pre><p id="d0f3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">x509</code> —执行证书命令。</p><p id="406c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-req</code>—<code class="fe oe of og oh b">x509</code>命令需要一个证书作为输入。通过<code class="fe oe of og oh b">-req</code>，您表示您将提供一个证书请求作为输入。</p><p id="be7a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-in</code> —证书请求(<code class="fe oe of og oh b">csr.pem</code>)。</p><p id="5bdb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-CA</code> —用于签署创建的证书的CA的证书。(<code class="fe oe of og oh b">ca-certificate.pem</code>)</p><p id="da96" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-CAkey</code>—CA的私钥，用于对创建的证书进行签名。(<code class="fe oe of og oh b">private-key-ca.pem</code>)</p><p id="1631" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-CAcreateserial</code> —由CA颁发的每个证书必须包含唯一的序列号。OpenSSL将使用的序列号存储在一个文件中，该文件与带有<code class="fe oe of og oh b">.srl</code>扩展名的证书同名。在这种情况下，您的本地目录中会有一个<code class="fe oe of og oh b">ca-certificate.srl</code>。</p><p id="9ebc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-out</code> —要生成的证书的文件名(<code class="fe oe of og oh b">certificate.crt</code>)。</p><p id="bac0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oe of og oh b">-days</code> —生成的证书有效的天数(<code class="fe oe of og oh b">3650</code>)。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d1bb" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">自动创建本地CA和证书</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oq"><img src="../Images/f333109d07f40e041e0409de426de386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Rf82JKwkuvAf-mQp2RJUw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae lv" href="https://unsplash.com/@museumsvictoria?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">维多利亚博物馆</a>在<a class="ae lv" href="https://unsplash.com/s/photos/factory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ef64" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在前面的段落中，我向您展示了创建本地CA和证书所必需的OpenSSL命令。</p><p id="8f00" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果我不尝试自动化，我就不会是一个好的开发人员。</p><h2 id="cbcd" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">使用脚本</h2><p id="e4b2" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">我创建了两个独立的脚本。一个用于生成本地CA，另一个用于生成由本地CA签名的证书。两者都可以在<a class="ae lv" href="https://github.com/PatrickKalkman/Developer-SSL-Certificates" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中找到。</p><p id="0302" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Windows和macOS有不同的脚本。与前面段落中的命令的一个不同之处是，脚本使用配置文件来回答问题。</p><p id="33dd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，在生成CA证书时会使用以下配置文件。它指定了来自OpenSSL的各种问题的答案。你可以根据自己的喜好修改答案。同样类型的配置也可用于生成自签名证书。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">OpenSSL在生成本地ca时使用的ca.conf</p></figure><p id="11b5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">主题别名</strong></p><p id="4c92" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">之前，我描述了使用<em class="oa">通用名称</em>来存储完全限定的域名。从版本58开始，Chrome不再支持常用名检查。它将忽略该字段。</p><p id="6163" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">相反，SAN(主题备用名称)字段是指定您的域的正确位置。在GitHub存储库中，有一个名为<code class="fe oe of og oh b">certificate-ext.conf</code>的配置文件，其中包含放入SAN的域和IP地址。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">用于在证书中填充SAN的配置文件</p></figure><p id="4dd5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以更改此配置文件来添加您需要的域名和IP地址。</p><p id="43fc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用<code class="fe oe of og oh b">./generate-cert.sh</code>命令生成证书后，生成的证书将正确填充SAN。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/179bef049a12185922e4026b6c90fc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRBMesjaMFQVd_ZJIN2cDQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">生成的证书中的SAN字段，与“钥匙串访问”一起显示</p></figure><h2 id="c9dc" class="no me iu bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">使用mkcert</h2><p id="8031" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">如果您不能使用前面的脚本或者想要一个更广泛的解决方案，您可以使用<a class="ae lv" href="https://github.com/FiloSottile/mkcert" rel="noopener ugc nofollow" target="_blank"> mkcert </a>。Mkcert由<a class="ae lv" href="https://github.com/FiloSottile" rel="noopener ugc nofollow" target="_blank"> Filippo Valsorda </a>创建，他是<a class="ae lv" href="https://play.google.com/store/apps/details?id=com.google.android.apps.searchlite&amp;hl=en_US" rel="noopener ugc nofollow" target="_blank"> Google Go </a>团队的一员。</p><p id="4a90" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Mkcert是一个制作本地信任的开发证书的简单工具。它在Go中实现，不需要任何配置。它可以在Linux、Windows和macOS上运行。</p><p id="25c4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以通过执行以下命令在macOS上使用<a class="ae lv" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> brew </a>安装mkcert:</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="643b" class="no me iu oh b gz om on l oo op">brew install mkcert</span></pre><p id="bd36" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">安装后，我们可以使用该工具通过以下命令创建我们自己的CA:</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="34e7" class="no me iu oh b gz om on l oo op">mkcert -install</span></pre><p id="11df" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该工具创建一个新的CA，并将其直接安装在操作系统的根存储中。证书的名称以<code class="fe oe of og oh b">mkcert</code>开头，包含您用来执行mkcert的计算机的名称。</p><p id="c661" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">私有CA密钥和证书也存储在文件系统中。您可以通过执行以下命令来获取位置:</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="130c" class="no me iu oh b gz om on l oo op">mkcert -CAROOT</span></pre><p id="bd30" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">安装新的CA后。您可以使用<code class="fe oe of og oh b">mkcert</code>来生成由CA自动签名的证书。例如，以下命令:</p><pre class="kk kl km kn gu oi oh oj ok aw ol bi"><span id="ae54" class="no me iu oh b gz om on l oo op">mkcert dev.com *.dev.com localhost 127.0.0.1</span></pre><p id="21da" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">创建对给定名称有效的证书。Mkcert将给定的DNS名称和IP地址存储在证书的主题备用名称(SAN)部分。</p><p id="3e59" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">生成的私钥和证书位于运行该命令的目录中。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ou"><img src="../Images/8f5938830d184e21a3c646d2bed56d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95XGnKkRLruTm6ON9QM2mg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">导入生成的证书后，MacOs上“钥匙串访问”的屏幕截图</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1169" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">我仍然对SSL证书爱恨交加吗？</h1><p id="939e" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">在创建自动化脚本和撰写本文之后，我更加欣赏它们。我仍然不喜欢它们，但认为它们是稳固安全的必需品。</p><p id="dbf9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>