<html>
<head>
<title>TensorFlow Lite Model Maker: Build an Image Classifier for Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow Lite模型生成器:为Android构建图像分类器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tensorflow-lite-model-maker-build-an-image-classifier-for-android-cf5893f713a8?source=collection_archive---------6-----------------------#2020-04-08">https://betterprogramming.pub/tensorflow-lite-model-maker-build-an-image-classifier-for-android-cf5893f713a8?source=collection_archive---------6-----------------------#2020-04-08</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="0f5e" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">为边缘设备构建机器学习模型变得简单多了</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/2dde53b3d22450b6568bdee1e3c879a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eOy1tat0aNjkeYAq"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@evertonvila?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃弗顿维拉</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="de53" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">TensorFlow最近刚刚通过livestream 结束了一年一度的<a class="ae kw" href="https://heartbeat.comet.ml/tensorflow-dev-summit-2020-livestream-highlights-8b99f7006743" rel="noopener ugc nofollow" target="_blank">开发峰会(由于新冠肺炎全球疫情),发布了许多令人兴奋的公告，大多数都专注于将机器学习推向更高的高度。从核心TensorFlow平台(TF2.2)的强大新版本到新的</a><a class="ae kw" href="https://cloud.google.com/ai-platform/pipelines/docs?hl=nb" rel="noopener ugc nofollow" target="_blank"> Google Cloud AI平台管道</a>，使TensorFlow在生产中的使用更加简单，甚至更好。</p><p id="2b83" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但这不是这篇文章的重点。相反，我们将深入探讨今年的突破性公告之一，那就是:TensorFlow Lite模型制造商。</p><p id="845d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用内置于TF Lite支持库中的TF Lite Model Maker，为移动和边缘设备构建模型非常容易。此外，Android Studio 4.1(当前版本，金丝雀版本)具有针对TF Lite模型的新代码生成功能，可自动为TF Lite模型生成包装器Java类，从而简化移动机器学习开发人员的模型开发和部署流程。</p><p id="e6f9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">TensorFlow Lite是一个轻量级的跨平台解决方案，用于在移动和嵌入式设备上部署ML模型。如果您想了解今年TF Dev峰会上关于TensorFlow Lite的所有新闻和公告，我强烈建议您查看<a class="ae kw" href="https://heartbeat.comet.ml/tensorflow-dev-summit-2020-tensorflow-lite-19dde3153335" rel="noopener ugc nofollow" target="_blank">该资源</a>。</p><h1 id="3158" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">TensorFlow Lite模型生成器</h1><p id="305e" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">TF Lite Model Maker是一个Python API，使从头构建机器学习模型变得轻而易举。它只需要五行代码(不包括导入)，如下所示:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mq"><img src="../Images/176a34dd21e6d2d497e8bb03799bd7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBEzwJ6AbJIN7RgRnGXtPw.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">是的，我们将使用NSFW数据集。</p></figure><p id="944c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在上图中，我们正在加载一个数据集，并将其分成训练集和测试集。随后，我们训练、评估并导出TF Lite模型以及标签(从子文件夹中检索)。</p><p id="e01a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在幕后，Model Maker API使用迁移学习来用不同的数据集和类别重新训练模型。默认情况下，模型生成器API使用EfficientNet-Lite0作为基本模型。</p><p id="2d42" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><a class="ae kw" href="https://github.com/tensorflow/tpu/tree/master/models/official/efficientnet/lite" rel="noopener ugc nofollow" target="_blank"> EfficientNet-Lite </a>最近才发布，属于能够在边缘设备上实现最先进精度的图像分类模型家族。下图显示了EfficientNet-Lite型号的精度与尺寸对比，并将其与MobileNet和ResNet进行了对比。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mr"><img src="../Images/13ace8b20a4e97a3df091ddf022cd45c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YibVm5721XWCzCWCt4puA.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">来自<a class="ae kw" href="https://blog.tensorflow.org/2020/03/higher-accuracy-on-vision-models-with-efficientnet-lite.html" rel="noopener ugc nofollow" target="_blank">文档</a>。EfficientNet-Lite针对移动推理进行了优化</p></figure><p id="2d86" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">模型生成器API还允许我们切换底层模型。例如:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="968d" class="mx lu ir mt b gz my mz l na nb">model = image_classifier.create(train_data, <strong class="mt is">model_spec=mobilenet_v2_spec</strong>, validation_data=validation_data)</span></pre><p id="00c6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">或者，我们也可以从TensorFlow Hub传递托管模型，以及自定义的输入形状，如下所示:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="e259" class="mx lu ir mt b gz my mz l na nb">inception_v3_spec = ImageModelSpec(uri='tfhub_url_goes_here')</span><span id="f6ee" class="mx lu ir mt b gz nc mz l na nb">inception_v3_spec.input_image_shape = [299, 299]</span><span id="ca0f" class="mx lu ir mt b gz nc mz l na nb">//pass this spec into model_spec</span></pre><p id="329a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们还可以在ModelMaker API的<code class="fe nd ne nf mt b">create</code>函数中微调训练超参数，如<code class="fe nd ne nf mt b">epochs</code>、<code class="fe nd ne nf mt b">dropout_rate</code>和<code class="fe nd ne nf mt b">batch_size</code>。</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="e1f9" class="mx lu ir mt b gz my mz l na nb">model = image_classifier.create(train_data, epochs=10)</span></pre><p id="9f2b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们已经很好地了解了Model Maker API的核心功能，让我们来加强运行上述Python脚本所需的依赖关系。</p><h2 id="5129" class="mx lu ir bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">升级TensorFlow</h2><p id="9a0a" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">确保您运行的是Python3.6或更高版本，并在macOS上安装了最新的pip版本。TensorFlow 2包需要一个<code class="fe nd ne nf mt b"><strong class="kz is">pip</strong></code>版本&gt; 19.0。随后，pip安装以下程序来更新TensorFlow:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="fdec" class="mx lu ir mt b gz my mz l na nb">pip install --user --upgrade tensorflow</span></pre><blockquote class="nr ns nt"><p id="66d5" class="kx ky nu kz b la lb js lc ld le jv lf nv lh li lj nw ll lm ln nx lp lq lr ls ik bi translated">注意:建议在虚拟环境中安装Python包。使用虚拟环境，您可以测试不同版本的库。为了了解这个过程，你可以查看一下这个教程。</p></blockquote><p id="be62" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">从我们的终端，让我们使用以下命令快速测试我们是否安装了最新的TensorFlow版本:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="06c1" class="mx lu ir mt b gz my mz l na nb">python3 -c 'import tensorflow as tf; print(tf.__version__)'</span></pre></div><div class="ab cl ny nz hv oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ik il im in io"><h2 id="43a5" class="mx lu ir bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">安装模型生成器库</h2><p id="9050" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">在您的终端上运行以下命令来安装Model Maker库:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="b485" class="mx lu ir mt b gz my mz l na nb">pip3 install git+https://github.com/tensorflow/examples.git#egg=tensorflow-examples[model_maker]</span></pre><p id="50fe" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在一切都准备好了，这意味着是时候训练我们的模型了。只需从macOS终端运行Python脚本。对于这个演示，我们使用了来自Kaggle 的合适的<a class="ae kw" href="https://www.kaggle.com/drakedtrex/my-nsfw-dataset" rel="noopener ugc nofollow" target="_blank"> NSFW数据集。一旦我们的模型准备好了，就该导入到我们新的Android Studio项目中了。</a></p><h1 id="deca" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">为TensorFlow Lite模型设置梯度依赖关系</h1><p id="dcaa" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">Android Studio 4.1几乎没有针对TensorFlow Lite模型的新增强功能:</p><ul class=""><li id="4180" class="of og ir kz b la lb ld le lg oh lk oi lo oj ls ok ol om on bi translated">首先，它让我们直接从import菜单导入一个<code class="fe nd ne nf mt b">tflite</code>模型，并将它放在一个<code class="fe nd ne nf mt b">ml</code>文件夹中。只需进入<strong class="kz is">文件&gt;新建&gt;其他&gt; TensorFlow Lite模型</strong>。</li></ul><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/f470b70ae935c96e9cfad901396a7978.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*WTOLyPVI2EB790eJkI37FA.png"/></div></figure><blockquote class="nr ns nt"><p id="b296" class="kx ky nu kz b la lb js lc ld le jv lf nv lh li lj nw ll lm ln nx lp lq lr ls ik bi translated"><strong class="kz is">注意</strong>:在一个场景中，你不像上面那样导入模型，而是直接把它放在<code class="fe nd ne nf mt b">assets</code>文件夹中，模型绑定将被禁用，Android Studio的自动代码生成不会为分类器创建Java包装类——直到你把它移到<code class="fe nd ne nf mt b">ml</code>文件夹中。</p></blockquote><ul class=""><li id="bc94" class="of og ir kz b la lb ld le lg oh lk oi lo oj ls ok ol om on bi translated">其次，Android Studio现在有一个模型查看器，可以显示元数据摘要——输入和输出张量、对它们的描述以及示例代码，如下所示:</li></ul><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj op"><img src="../Images/93e226b6a2c1edfd029044496d4b763c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*fKo5HzI9tEsGB-U-1_2m9w.png"/></div></figure><p id="1b43" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">默认情况下，模型生成器API只生成最少的元数据，由输入和输出形状组成。为了扩展和添加更多的上下文，如作者、版本、许可证以及输入和输出描述，我们可以利用<a class="ae kw" href="https://www.tensorflow.org/lite/convert/metadata" rel="noopener ugc nofollow" target="_blank">新的扩展元数据</a>特性(目前处于试验阶段)。</p><h2 id="2660" class="mx lu ir bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">启用ML模型绑定</h2><p id="421c" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">尽管将<code class="fe nd ne nf mt b">tflite</code>模型放在了<code class="fe nd ne nf mt b">ml</code>目录中，但是模型绑定并没有自动启用。您需要在应用程序的<code class="fe nd ne nf mt b">build.gradle</code>脚本中添加<code class="fe nd ne nf mt b">buildFeatures</code>和<code class="fe nd ne nf mt b">aaptOptions</code>元素来启用它:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="7aab" class="mx lu ir mt b gz my mz l na nb">android{</span><span id="dab7" class="mx lu ir mt b gz nc mz l na nb"> buildFeatures <strong class="mt is">{<br/>        mlModelBinding true</strong><br/>    <strong class="mt is">}<br/>    </strong>aaptOptions <strong class="mt is">{<br/>        </strong>noCompress "tflite"<br/>    <strong class="mt is">}<br/>}<br/></strong></span></pre><p id="84c7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们的模型的分类器现在可供我们运行推理。是时候在<code class="fe nd ne nf mt b">build.gradle</code>文件中添加<code class="fe nd ne nf mt b">tensorflow-lite</code>依赖项了:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="192f" class="mx lu ir mt b gz my mz l na nb">dependencies <strong class="mt is">{<br/></strong><br/>  implementation 'org.tensorflow:tensorflow-lite:0.0.0-nightly'<br/>  implementation 'org.tensorflow:tensorflow-lite-gpu:0.0.0-nightly'<br/>  implementation 'org.tensorflow:tensorflow-lite-support:0.0.0-nightly'<br/>  implementation 'org.apache.commons:commons-compress:1.19'<br/><strong class="mt is">}</strong></span></pre></div><div class="ab cl ny nz hv oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ik il im in io"><h1 id="a10a" class="lt lu ir bd lv lw oq ly lz ma or mc md jx os jy mf ka ot kb mh kd ou ke mj mk bi translated">设置我们的活动布局</h1><p id="09ef" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">现在是时候在我们的活动中放置UI元素了。为了简单起见，我们的<code class="fe nd ne nf mt b">activity_main.xml</code>文件由一个RecyclerView和一个按钮组成:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ov ow l"/></div></figure><p id="528d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了填充RecyclerView的适配器，我们需要一个模型。下面的Kotlin数据类包含一个图像、预测文本和一个布尔标志，用于指示我们的输入图像是否是NSFW。</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="cdd6" class="mx lu ir mt b gz my mz l na nb">data class DataModel(var drawableID: Int, var isNSFW: Boolean, var prediction: String)</span></pre><p id="8b2d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下XML代码表示RecyclerView的每一行的布局:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="29cf" class="mx lu ir mt b gz my mz l na nb">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"<br/>    android:orientation="horizontal"<br/>    android:padding="10dp"&gt;<br/>    <br/>    &lt;ImageView<br/>        android:id="@+id/imageView"<br/>        android:layout_width="100dp"<br/>        android:layout_height="100dp"<br/>        android:scaleType="centerCrop" /&gt;<br/>    <br/>    &lt;TextView<br/>        android:id="@+id/tvPrediction"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:layout_gravity="center"<br/>        android:gravity="end|center_vertical"<br/>        android:textSize="20sp" /&gt;<br/><br/>&lt;/LinearLayout&gt;</span></pre><p id="b2bc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们已经创建了数据模型和视图，是时候将它们提供给RecyclerView的适配器了。</p><h1 id="1a6f" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">设置我们的RecyclerView适配器</h1><p id="3d75" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">以下代码创建了RecyclerView的<code class="fe nd ne nf mt b">Adapter</code>类:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ov ow l"/></div></figure><p id="c228" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们基于NSFW输出在<code class="fe nd ne nf mt b">ImageView</code>上设置了一个颜色过滤器(NSFW图像由于明显的原因被隐藏在黑色中)。</p><p id="a053" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最后，是时候深入我们的<code class="fe nd ne nf mt b">MainActivity.kt</code>了，在这里我们初始化上面的适配器，更重要的是，对一系列图像进行推理。</p></div><div class="ab cl ny nz hv oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ik il im in io"><h1 id="8183" class="lt lu ir bd lv lw oq ly lz ma or mc md jx os jy mf ka ot kb mh kd ou ke mj mk bi translated">运行TF Lite图像分类器</h1><p id="498b" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">为了运行模型，我们需要预处理输入以满足模型的约束。TensorFlow Lite内置了一堆图像预处理方法。要使用它们，我们首先需要初始化一个<code class="fe nd ne nf mt b">ImageProcessor</code>，然后添加所需的操作符:</p><h2 id="d50a" class="mx lu ir bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">预处理输入图像</h2><p id="09ec" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">在下面的代码中，我们将输入图像的大小调整为224乘224，这是模型输入形状的尺寸:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="b60c" class="mx lu ir mt b gz my mz l na nb">val imageProcessor = ImageProcessor.Builder()<br/>    .add(ResizeOp(224, 224, ResizeOp.ResizeMethod.BILINEAR))<br/>    .build()<br/><br/>var tImage = TensorImage(DataType.FLOAT32)<br/><br/>tImage.load(bitmap)<br/>tImage = imageProcessor.process(tImage)</span></pre><p id="cf35" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nd ne nf mt b">TensorImage</code>是提供给TensorFlow Lite模型的输入。但是在我们运行推理之前，让我们创建一个后处理器来归一化输出概率。</p><h2 id="d2af" class="mx lu ir bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">设置我们的后处理器</h2><p id="668d" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">后处理器基本上是一个将我们的结果去量化的容器:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="bacc" class="mx lu ir mt b gz my mz l na nb">val probabilityProcessor =<br/>    TensorProcessor.Builder().add(NormalizeOp(0f, 255f)).build()</span></pre><h2 id="9724" class="mx lu ir bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">运行推理</h2><p id="cc9f" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">以下几行代码实例化了从模型自动生成的分类器，传递输入张量图像，并在<code class="fe nd ne nf mt b">outputBuffer</code>中获得结果:</p><pre class="kh ki kj kk gu ms mt mu mv aw mw bi"><span id="49a8" class="mx lu ir mt b gz my mz l na nb">val model = NsfwClassifier.newInstance(this@MainActivity)<br/>val outputs =<br/>    model.process(probabilityProcessor.process(tImage.<em class="nu">tensorBuffer</em>))<br/>val outputBuffer = outputs.<em class="nu">outputFeature0AsTensorBuffer<br/></em>val tensorLabel = TensorLabel(labelsList, outputBuffer)</span></pre><p id="e7c9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nd ne nf mt b">TensorLabel</code>用于将关联概率与其标签进行映射。在我们的模型中，只有几个标签:“NSFW”和“SFW”。我们已经在<code class="fe nd ne nf mt b">labelsList</code>数组列表中设置了它们。在不同的场景中，您可以解析<code class="fe nd ne nf mt b">labels.txt</code>文件以获得所有类别，就像这里的<a class="ae kw" href="https://github.com/anupamchugh/AndroidTfLiteCameraX/blob/master/app/src/main/java/com/anupam/androidcameraxtflite/TFLiteClassifier.kt" rel="noopener ugc nofollow" target="_blank">所做的</a>。</p><p id="71c4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最后，使用<code class="fe nd ne nf mt b">mapWithFloatValue</code>函数，我们可以检索NSFW和SFW类别的概率。</p><p id="fa7f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nd ne nf mt b">MainActivity.kt</code>的完整代码如下。它对每个图像运行上述图像分类器，并相应地用数据更改更新RecyclerView适配器:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ov ow l"/></div></figure><p id="d1ed" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面是上述应用程序的实际输出:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj ox"><img src="../Images/493942f922591db6660cec0328482381.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/1*2JHeO3a743obv2G30UJTPQ.gif"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">仅显示SFW图像。</p></figure></div><div class="ab cl ny nz hv oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ik il im in io"><h1 id="f5b9" class="lt lu ir bd lv lw oq ly lz ma or mc md jx os jy mf ka ot kb mh kd ou ke mj mk bi translated">结束语</h1><p id="0424" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">可以说，Model Maker Python库已经存在，并将被希望在设备上快速部署ML模型的移动开发人员广泛使用。</p><p id="8cd2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于那些了解苹果机器学习技术的人来说，TF Lite模型生成器类似于Create ML，至少理论上是这样的。目前，Model Maker API仅支持图像和文本分类用例，预计对象检测和QR读取器将很快推出。</p><p id="dd7b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Android Studio对ML模型绑定和自动代码生成的支持消除了我们在之前的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/image-classification-on-android-with-tensorflow-lite-and-camerax-4f72e8fdca79"> TensorFlow Lite Android教程</a>中与<code class="fe nd ne nf mt b">ByteBuffer</code>交互的需要。</p><p id="6fb7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">扩展元数据(在撰写本文时处于实验阶段)还允许我们<a class="ae kw" href="https://www.tensorflow.org/lite/guide/codegen" rel="noopener ugc nofollow" target="_blank">生成定制的、特定于平台的包装代码</a>，从而进一步减少我们需要编写的样板代码的数量。我们将在以后的教程中研究定制代码生成以及更多内容。</p><p id="c2cb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">上述教程的完整源代码可以在这个<a class="ae kw" href="https://github.com/anupamchugh/AndroidTFLiteModelMaker" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到。</p><p id="75e5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这一个到此为止。感谢阅读。</p></div></div>    
</body>
</html>