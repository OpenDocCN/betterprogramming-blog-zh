<html>
<head>
<title>3 Common Git Scenarios and How to Deal With Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3种常见的Git场景以及如何处理它们</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-common-git-scenarios-and-how-to-deal-with-them-ee83c1c1b31e?source=collection_archive---------11-----------------------#2020-11-18">https://betterprogramming.pub/3-common-git-scenarios-and-how-to-deal-with-them-ee83c1c1b31e?source=collection_archive---------11-----------------------#2020-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d46" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重命名分支、覆盖Git历史和创建特性分支</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4f973de5d0ae202938cb4ae838afbd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LVC9CSrh3iCm7CDX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@brina_blum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Brina Blum </a>拍摄的照片。</p></figure><p id="42d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，我们大多数人在Git上花了相当多的时间来管理我们的版本控制。我们还使用Git与其他开发人员合作，跟踪bug修复、构建新特性、重构代码，等等。</p><p id="7a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我将与您分享您将面临或之前遇到的三种常见情况，以及如何处理它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a6fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重命名现有分支</h1><p id="7b45" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我不知道你怎么想，但是在我工作的地方，我是根据吉拉的门票进行开发的。这意味着我的所有<a class="ae ky" href="https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/about-pull-requests" rel="noopener ugc nofollow" target="_blank">拉取请求</a>将根据各自的票据编号命名其相应的分支。对于拉请求的第一次<a class="ae ky" href="https://github.com/git-guides/git-commit" rel="noopener ugc nofollow" target="_blank">提交</a>也是如此(即，它从票证编号开始，后跟提交消息)。这一切都是因为<a class="ae ky" href="https://www.atlassian.com/software/jira" rel="noopener ugc nofollow" target="_blank">吉拉</a>有一个很好的<a class="ae ky" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>集成，将所有的拉请求链接到票上。</p><p id="dd3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，这是我想讨论的第一个场景:</p><ul class=""><li id="cb06" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">你已经开始处理一张票。</li><li id="ec8a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">您已经创建了一个拉取请求，并根据票据编号命名了分支机构。</li><li id="0f6c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">你发现你的票号打错了，或者这张票已经和另一张票合并了，等等。</li><li id="356f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">您想要重命名本地分支和远程分支(假设您已经将它推送到远程存储库)。</li></ul><p id="c75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这是你，让我们看看如何解决这个问题并继续前进。</p><h2 id="19d6" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">查看当地的相关分支机构</h2><p id="bd10" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第一步是检查您想要重命名的分支:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="4679" class="nn md it oa b gy oe of l og oh">$ git checkout my-branch-to-rename</span></pre><h2 id="52a3" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">重命名本地分支</h2><p id="fe37" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，让我们将这个本地分支重命名为新名称:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="e7bf" class="nn md it oa b gy oe of l og oh">$ git branch -m my-new-branch-name</span></pre><p id="1fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的本地分支机构已成功从<code class="fe oi oj ok oa b">my-branch-to-rename</code>更名为<code class="fe oi oj ok oa b">my-new-branch-name</code>。</p><h2 id="6342" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">将新的本地分支推到远程</h2><p id="2468" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了更新我们的远程存储库，我们需要将这个重命名的分支推送到它的远程副本，这类似于我们刚刚创建一个新分支时的情况:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="ceee" class="nn md it oa b gy oe of l og oh">$ git push -u origin my-new-branch-name</span></pre><p id="af51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成这一步后，我们应该看到<code class="fe oi oj ok oa b">my-new-branch-name</code>在远程存储库中可用。</p><h2 id="cc22" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">删除远程分支的旧名称</h2><p id="df04" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您之前已经将<code class="fe oi oj ok oa b">my-branch-to-rename</code>推送到远程，那么您应该删除它以进行清理并避免混淆:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="6103" class="nn md it oa b gy oe of l og oh">$ git push origin --delete <!-- -->my-branch-to-rename</span></pre><p id="1283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。</p><p id="1be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ol">注意:我知道我上面提到我需要这样做的原因是因为我的公司开发工作流程。然而，我确信这也适用于许多其他情况。在命名事物时，我们会犯拼写错误，我们会改变主意，所以我希望这是有用的。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b6d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">覆盖Git提交历史</h1><p id="8cdb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在过去，我不得不多次覆盖我的远程分支提交历史。我不得不这样做的主要原因是因为我无意中或不知不觉地犯下了未使用的或糟糕的提交，后来才意识到这些提交是不需要的。</p><p id="ac98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当需求改变时，这种情况也会发生，我只能假设这种情况随时随地都会发生。作为开发人员，我们喜欢保持东西整洁，所以我们倾向于删除不必要的东西(至少我是这样做的)。</p><p id="7fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们看看如何清理我们的提交历史。</p><p id="7ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们假设我们只有一个提交(最新的一个)想要从历史中删除。</p><h2 id="dc09" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">将树重置为最新提交之前的提交</h2><p id="75b0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以将历史倒回到当前在本地和远程的最新提交之前的提交:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="32ce" class="nn md it oa b gy oe of l og oh">$ git reset HEAD^</span></pre><p id="8dd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这被称为软重置，这意味着我们想要从历史中删除的最新提交中的更改将被保留。如果您想使用某些更改，这很有用。</p><p id="9e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您根本不想使用最近提交的任何更改，那么您可以执行所谓的硬重置。请注意，硬重置不会保留最新提交的更改。换句话说，他们永远离开了。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="bd95" class="nn md it oa b gy oe of l og oh">$ git reset --hard HEAD^</span></pre><h2 id="67bf" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">移除远程中的最新提交</h2><p id="ba22" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们所做的只是在本地重置或删除最近的提交。如果最近的提交已经被远程推送，我们也要删除它:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="d303" class="nn md it oa b gy oe of l og oh">$ git push -f</span></pre><p id="e3a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oi oj ok oa b">-f</code>选项也被称为<code class="fe oi oj ok oa b">git push --force</code>，这意味着它将从本地分支复制所有提交，并将它们全部推送到远程对应方，删除不在本地分支中的所有提交。</p><p id="3503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其他情况下，我们可能需要从历史记录中删除多个提交。这些步骤非常类似于删除最近的提交。让我们过一遍。</p><h2 id="7254" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">将树重置为特定提交</h2><p id="e227" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Git记录所有已经完成的提交，并且每个提交都有一个惟一的提交ID。要获得提交列表，我们可以这样做:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="dade" class="nn md it oa b gy oe of l og oh">$ git log</span></pre><p id="b17c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="a817" class="nn md it oa b gy oe of l og oh">commit e1cc9ff850d36adc59a50c30685fb1d9414fd9e4 (HEAD -&gt; master, origin/master)<br/>Author: billydh &lt;<a class="ae ky" href="mailto:dharmawan.billy@gmail.com" rel="noopener ugc nofollow" target="_blank">someemail@gmail.com</a>&gt;<br/>Date:   Mon Mar 23 20:58:10 2020 +1100</span><span id="bf66" class="nn md it oa b gy om of l og oh">use then instead of flatMap when commiting</span><span id="7c7a" class="nn md it oa b gy om of l og oh">commit 8d4edb1b952cca32bebfefacb90307250a6c9891<br/>Author: billydh &lt;<a class="ae ky" href="mailto:dharmawan.billy@gmail.com" rel="noopener ugc nofollow" target="_blank">someemail@gmail.com</a>&gt;<br/>Date:   Mon Mar 2 21:05:00 2020 +1100</span><span id="272d" class="nn md it oa b gy om of l og oh">update readme</span><span id="de88" class="nn md it oa b gy om of l og oh">commit 80985dd486b6af62a649b89626891ac571258146<br/>Author: billydh &lt;<a class="ae ky" href="mailto:dharmawan.billy@gmail.com" rel="noopener ugc nofollow" target="_blank">someemail@gmail.com</a>&gt;<br/>Date:   Mon Mar 2 21:01:06 2020 +1100</span><span id="7d0b" class="nn md it oa b gy om of l og oh">restructure project</span></pre><p id="3c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要删除最后两次提交。我们可以这样做:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="fcc5" class="nn md it oa b gy oe of l og oh">$ git reset 80985dd486b6af62a649b89626891ac571258146</span></pre><p id="7f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要提醒的是，默认情况下<code class="fe oi oj ok oa b">git reset</code>会进行软复位，这意味着所有的更改都会被保留。如果你想一起删除它们，你可以在<code class="fe oi oj ok oa b">git reset</code>命令中添加<code class="fe oi oj ok oa b">--hard</code>选项。</p><p id="aa5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是删除最后两次提交或<code class="fe oi oj ok oa b">n</code>提交的另一种方法:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="dd98" class="nn md it oa b gy oe of l og oh">$ git reset HEAD~2 # replace 2 with `n` last commits you want to remove</span></pre><h2 id="9d8a" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">移除远程中的最新提交</h2><p id="b56d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，我们还需要做<code class="fe oi oj ok oa b">git push force</code>来覆盖远程分支中的历史:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="775f" class="nn md it oa b gy oe of l og oh">$ git push -f</span></pre><p id="c580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你要做的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1008" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建特征分支</h1><p id="fca2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">拥有一个将要存在一段时间的特性分支是很常见的。当我们想要构建一个新的特性，并确保它不会干扰当前产品本身的主要分支时，可能就是这种情况。</p><p id="d3fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，让我们直奔主题。</p><h2 id="31e4" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">创建特征分支</h2><p id="ff93" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先要做的是创建特性分支本身，它的基础来自于主分支。让我们检查一下主分支，找出所有最新的变化:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="01e8" class="nn md it oa b gy oe of l og oh">$ git checkout master</span><span id="453e" class="nn md it oa b gy om of l og oh">$ git pull</span></pre><p id="f084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此后，我们可以创建特征分支:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="d22a" class="nn md it oa b gy oe of l og oh">$ git checkout -b my-new-feature-branch</span></pre><h2 id="6eca" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">为新特性创建开发分支</h2><p id="b1bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于这是一个新特性，我们希望从主分支中单独开发它，所以我们需要创建基于特性分支的特性开发分支:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="c377" class="nn md it oa b gy oe of l og oh">$ git checkout -b my-development-branch-for-feature</span></pre><p id="e513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将处理新特性的更改，在本地提交它们，最后推送到远程上游分支:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="5612" class="nn md it oa b gy oe of l og oh">$ touch test.txt</span><span id="9270" class="nn md it oa b gy om of l og oh">$ git add .</span><span id="53d7" class="nn md it oa b gy om of l og oh">$ git commit -m "first feature branch commit"</span><span id="c32d" class="nn md it oa b gy om of l og oh">$ git push -u origin my-development-branch-for-feature</span></pre><p id="58e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成此操作后，它应该会给您一个链接，您可以在这里创建或查看远程存储库中的pull请求。继续点击链接。</p><p id="bb66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，GitHub允许我选择哪个分支应该作为我的开发分支的基本参考。在这里我们可以指定我们想要将我们的变更合并到特征分支<code class="fe oi oj ok oa b">my-new-feature-branch</code>而不是<code class="fe oi oj ok oa b">master</code>。因此，继续选择<code class="fe oi oj ok oa b">my-new-feature-branch</code>并点击“创建拉动请求”按钮:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/a637b5e1e2daeebfdaddce80c55af512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4TTr4s_30dOirrtvTzEMmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub打开一个拉取请求</p></figure><p id="fb15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里的例子使用GitHub，但是无论你使用什么版本控制软件，它应该或多或少是一样的。</p><p id="03d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，这就是你如何创建一个特性分支并在其上开发而不影响主分支的方法。一旦特性分支准备好了，您就可以将它合并到主分支来集成新特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d383" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="471e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢阅读。我希望我们讨论的三个场景对您有用。下次见！</p></div></div>    
</body>
</html>