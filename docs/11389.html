<html>
<head>
<title>Backtracking: N-Queen Problem and Sudoku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回溯:N皇后问题和数独</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/backtracking-n-queen-problem-and-sudoku-31974988bcb0?source=collection_archive---------8-----------------------#2022-03-15">https://betterprogramming.pub/backtracking-n-queen-problem-and-sudoku-31974988bcb0?source=collection_archive---------8-----------------------#2022-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2f96" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">逐步解决问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/b4907baf6cfd5ee4372dc4cd61cc3bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*gl4E1I54UStDlNclWNq21Q.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">约翰·摩根在<a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片|尺寸已更改</p></figure><h1 id="1fb5" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">概念</h1><p id="c3e7" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated"><a class="ae kr" href="https://en.wikipedia.org/wiki/Backtracking" rel="noopener ugc nofollow" target="_blank">回溯</a>法作为一种搜索算法，可以找到全部或部分解的通用算法，特别适用于约束满足问题，如N皇后、解数独等等今天的问题。</p><p id="8551" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">回溯采用<a class="ae kr" href="https://en.wikipedia.org/wiki/Trial_and_error" rel="noopener ugc nofollow" target="_blank">试错</a>的思路。它试图一步一步地解决问题。在一步一步解决问题的过程中，当它试图寻找已有的一步一步的答案都得不到有效正确的解时，它就会取消上一步甚至上一步的计算，然后通过其他可能的步骤。一步一步地再次尝试寻找问题的答案。</p><p id="870b" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">回溯法通常用最简单的<a class="ae kr" href="https://en.wikipedia.org/wiki/Recursion" rel="noopener ugc nofollow" target="_blank">递归</a>方法实现。重复上述步骤后，可能会出现两种情况:</p><ul class=""><li id="1894" class="ml mm iq lm b ln mg lq mh lt mn lx mo mb mp mf mq mr ms mt bi translated">找到一个可能的正确答案</li><li id="1ad0" class="ml mm iq lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">在尝试了每一种可能的循序渐进的方法后宣布这个问题没有答案</li></ul><p id="8d0c" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">在最坏的情况下，回溯导致指数时间复杂度的计算。</p><p id="7f82" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">回溯法实际上是一种DFS(深度优先搜索算法)。不同的是回溯法有剪枝的能力。下面用两个例子来详细分析回溯算法:</p><h1 id="a3e3" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">n皇后问题</h1><p id="cd53" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">N皇后问题是基于<a class="ae kr" href="https://en.wikipedia.org/wiki/Eight_queens_puzzle" rel="noopener ugc nofollow" target="_blank">八皇后难题</a>的进一步发展。如何将<code class="fe mz na nb nc b">n</code>个皇后放在<code class="fe mz na nb nc b">n*n</code>个棋盘上，让任何一个皇后都无法直接俘获其他皇后？要做到这一点，没有两个皇后可以在同一水平、垂直或对角线上。下图显示了八皇后难题的解决方案之一:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/1a37252d6d9b06679b32c2a482f7d7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*ddtmmZDjvEXGvxvAW5VeGQ.png"/></div></figure><p id="9a20" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">下面是对这个问题的分析:</p><p id="940f" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">棋盘上的每个位置包含两种状态:有女王和没有女王。列出所有不考虑约束的组合，我们会得到一棵深度<code class="fe mz na nb nc b">N * N</code>的二叉树。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/819099fbfd8d94262cfdbca53a95dfdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IqJqRQVff1VPpj6UPWX5hA.png"/></div></div></figure><p id="9c8c" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">上图描述了棋盘上最高两个位置的可能性。</p><p id="9260" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">最简单的方法就是穷举所有的可能性，然后筛选出匹配的解。这个二叉树可以用DFS算法遍历，一个<code class="fe mz na nb nc b">N * N</code>棋盘会有两个<code class="fe mz na nb nc b">N * N</code>次方的可能性，这显然是不能接受的。</p><p id="ecf4" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">但是我们可以通过规则来修剪。可以使用的规则如下:</p><ul class=""><li id="9861" class="ml mm iq lm b ln mg lq mh lt mn lx mo mb mp mf mq mr ms mt bi translated">总共需要放置<code class="fe mz na nb nc b">N</code>个女王</li><li id="ed55" class="ml mm iq lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">每行只能有一个女王</li><li id="8225" class="ml mm iq lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">每列只能有一个女王</li><li id="b667" class="ml mm iq lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">每条斜线只能有一个女王</li></ul><p id="de28" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">有了以上四个条件，我们就可以减去大部分路径了。</p><p id="c620" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">现在，回到回溯法来看这个问题。回溯法利用试错的思想一步步解决问题。</p><p id="a5d8" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">我们可以先假设皇后放在第一个位置，然后根据规则，找到第二个合法位置再放第二个。如果找不到合适的位置，就说明路径错了，回溯到上一个位置继续。</p><p id="bdc4" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">回溯的一个特点是使用数组或其他数据结构存储遍历信息，从而跳过非法路径。<br/>这个问题使用三个数组来存储列，左上到右下斜边，右上到皇后放置数据的坐斜边。</p><p id="8044" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">因为每行只能有一个皇后，所以我们逐行遍历，试图将皇后放在当前行的每个位置。然后跳到下一行继续。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="265b" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">复杂性分析</h1><ul class=""><li id="99c3" class="ml mm iq lm b ln lo lq lr lt nl lx nm mb nn mf mq mr ms mt bi translated">时间复杂度:<code class="fe mz na nb nc b">O(N!)</code>:第一个皇后有<code class="fe mz na nb nc b">N</code>的位置，第二个皇后必须和第一个不在一列，也不在一个倾斜的角度，所以第二个皇后有<code class="fe mz na nb nc b">N-1</code>的可能性，以此类推，时间复杂度为<code class="fe mz na nb nc b">O(N!)</code>。</li><li id="75d1" class="ml mm iq lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">空间复杂度:<code class="fe mz na nb nc b">O(N)</code>:需要使用数组保存信息。</li></ul><h1 id="5d3d" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">解决数独</h1><p id="e288" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">数独游戏是我们常见的解决数独的游戏。</p><ul class=""><li id="ba46" class="ml mm iq lm b ln mg lq mh lt mn lx mo mb mp mf mq mr ms mt bi translated">数字1-9在每一行中只能出现一次。</li><li id="6f7a" class="ml mm iq lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">数字1-9在每列中只能出现一次。</li><li id="410a" class="ml mm iq lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">数字1-9在每个由粗实线分隔的3x3框中只能出现一次。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/3fab63e48b7ae9a28f6cbcfcb92f71cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*JVKlgBaXEC6X5-kmhx0y-A.jpeg"/></div></figure><p id="68e8" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">这个想法和<code class="fe mz na nb nc b">N</code>女王是一样的。遍历所有的空格，将1–9的数组一个接一个的放在空格里，用规则判断是否合法，最后找到解。</p><p id="422f" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">这里再次定义了三个数组来保存遍历的数据:每行、每列和每个3x3单元格。</p><p id="ffb4" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">或者，如果<code class="fe mz na nb nc b">Sn</code>代表<code class="fe mz na nb nc b">nth</code> 3x3单元，则<code class="fe mz na nb nc b">Sn = (row / 3) * 3 + column / 3</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="d26b" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">复杂性分析</h1><ul class=""><li id="eb7b" class="ml mm iq lm b ln lo lq lr lt nl lx nm mb nn mf mq mr ms mt bi translated">时间复杂度</li></ul><p id="6445" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">这个问题的输入是一个固定的九格网格，所以直接计算实际的次数。</p><p id="b5f4" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">第一行有不超过九个空格要填充数字，而且由于这个不能重复，所以有<code class="fe mz na nb nc b">9!</code>种方法可以做到这一点，总共有九行，所以最多用<code class="fe mz na nb nc b">(9!)⁹ </code>次。</p><ul class=""><li id="2d0d" class="ml mm iq lm b ln mg lq mh lt mn lx mo mb mp mf mq mr ms mt bi translated">空间复杂性</li></ul><p id="fcee" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">我们定义了三个数组，每个数组有81个元素，总共3×81 = 243个元素。</p><p id="03bb" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">我已经把上面的代码放在GitHub上了，如果你需要的话，还有很多其他数据结构和算法相关的代码在里面:</p><p id="42f0" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated"><a class="ae kr" href="https://github.com/0xZhangKe/Algorithms/tree/master/src/com/zhangke/algorithms/leetcode" rel="noopener ugc nofollow" target="_blank">https://github . com/0x Zhangke/Algorithms/tree/master/src/com/张克/algorithms/leetcode </a></p></div></div>    
</body>
</html>