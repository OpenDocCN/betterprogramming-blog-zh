<html>
<head>
<title>Singly and Doubly-Linked Lists in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的单向和双向链表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/singly-and-doubly-linked-lists-in-javascript-7515f47c9f60?source=collection_archive---------0-----------------------#2020-01-18">https://betterprogramming.pub/singly-and-doubly-linked-lists-in-javascript-7515f47c9f60?source=collection_archive---------0-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="770a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">列表不仅仅是数组</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4069f530aa7ccbd0c797f0ef532c1495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqCGzgmJGRDq17CU_9AZlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不是那种链接…来源:<a class="ae ky" href="https://yattatachi.com/tbt-how-the-legend-of-zelda-was-kinda-its-own-genre" rel="noopener ugc nofollow" target="_blank">https://yattatachi . com/TBT-how-the-legend-of-zelda-was-kinda-its-own-genre</a></p></figure><p id="c8da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序员看到“列表”这个词，我们通常会马上想到“数组”。</p><p id="49b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组非常适合存储要迭代的数据，但是因为它们有编号索引，所以操作数组中的元素在时间和空间复杂度方面代价很高。</p><p id="e1c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想在一个100个元素的数组中的第10个索引处插入一个新元素，我们必须在插入后重新索引其他90个元素。</p><p id="4605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要处理一个不断更新的数据列表，我们可能想要使用一个被称为<em class="lv">链表</em>的数据结构。可以把链表想象成一条链，它是一组节点，有固定的头、尾和长度。</p><p id="776f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个节点包含一个值和一个指向链中下一个节点的指针。单向链表有指向列表中下一个节点的指针，而双向链表有指向链中上一个和下一个节点的指针。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/739d6c59ce24a9a80cee349d6201c814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*5wRMqVjLatOGX88VrZgacA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单链表和双链表的例子。</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="217f" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">创建单链表</h1><p id="de64" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">(我推荐跟随<a class="ae ky" href="https://visualgo.net/en/list" rel="noopener ugc nofollow" target="_blank"> Visualgo </a>的例子)。我们需要为一个<code class="fe nb nc nd ne b">Node</code>和一个<code class="fe nb nc nd ne b">List</code>创建类。请参见下面的每个属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/80ba06a6eb5b14dcad58f7ea7b136ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HlMnlX2X0_NQP1luY3PPhQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的链表类的基础</p></figure><p id="2a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了操作链表中的任何东西，我们需要遵循三条规则:</p><ol class=""><li id="81cd" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">添加或删除节点时，请确保增加或减少列表的长度。</li><li id="48eb" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">确保列表有正确的头部、尾部，并且所有节点都有准确的指针。</li><li id="0f52" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">删除时，确保指向已删除节点的所有指针都被切断，以确保该节点已从内存中正确删除。</li></ol><h2 id="e0c7" class="nu mf it bd mg nv nw dn mk nx ny dp mo li nz oa mq lm ob oc ms lq od oe mu of bi translated">推动和取消移动</h2><p id="2379" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">当我们向列表的任意一侧添加节点时，我们需要确保列表的头部和尾部是正确的。</p><p id="b423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于一个列表中一个节点的头部和尾部是相同的，我们需要在实现中考虑这种情况。看看下面的注释代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/26f397c064773589c16e5e7cc0d977dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*0Ymt-Ye3cAXRfRrCW3wYTg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">推送的实现</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/84ac4a6f14adc51363e6fd29fbd300b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyzBOIxCqbLerqMcxcV6zA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">unshift的实现</p></figure><h2 id="7791" class="nu mf it bd mg nv nw dn mk nx ny dp mo li nz oa mq lm ob oc ms lq od oe mu of bi translated">Pop和shift</h2><p id="85b4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">当我们从列表的任何一边移除一个节点时，我们需要考虑另外两件事——一个只剩下一个节点的列表(因为我们需要确保我们的尾部和头部是准确的),以及一个空列表(这样我们可以避免运行时错误)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/0eedbcafcb1dbbe4dc0a83500e300fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPllRZfSjjnbykMYZFnHMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">移位的实现</p></figure><p id="61de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据链表的性质，我们可以通过简单地检查当前头的指针来访问链表的新头。</p><p id="195b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们从列表中弹出时，我们需要遍历列表以找到新的尾部。我将使用一个助手方法，我们可以在我们的类<code class="fe nb nc nd ne b">getNodeAtIndex</code>的后面的方法中重用它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/f466eaedaec1b8c6a227ec8a2b758526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRULaTVIOkxq26vASv4y0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">getNodeAtIndex的实现</p></figure><p id="8419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数使用一个计数器并遍历列表，直到我们找到需要的节点的索引。在这种情况下，我们需要倒数第二个节点，或者列表长度减二。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/4cacac15ec951c299cee70f6b2b2cf3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D026fOiPEXd2rp-uk6dquA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pop的实施</p></figure><h2 id="bc45" class="nu mf it bd mg nv nw dn mk nx ny dp mo li nz oa mq lm ob oc ms lq od oe mu of bi translated">获取和设置</h2><p id="73e7" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">因为我们已经实现了上面的用于pop实现的<code class="fe nb nc nd ne b">get</code>方法，所以我们需要做的就是实现<code class="fe nb nc nd ne b">set</code>方法。</p><p id="fd5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此方法在指定的索引处查找一个节点，并将其值更改为传入的变量。它也将使用我们的getter方法。我们只需要处理没有找到节点的情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/2a984b1da83a9ca9fbb9eddc6103b929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4oksa5_Z-IK6u9tYz3oBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">setNodeAtIndex的实现</p></figure><h2 id="dce8" class="nu mf it bd mg nv nw dn mk nx ny dp mo li nz oa mq lm ob oc ms lq od oe mu of bi translated">插入和移除</h2><p id="16f1" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">通过我们刚刚编写的所有前面的方法，在链表中插入和移除条目变得更加容易。我们需要遵循以下步骤:</p><ol class=""><li id="fb9c" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">检查链表中是否存在该索引(如果不存在，返回<code class="fe nb nc nd ne b">false</code>)。</li><li id="2c0b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如果在列表的开头或结尾删除/添加，使用已经编写好的方法(不用再担心尾部/头部！).</li><li id="97c7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">获取插入/移除节点前后的节点，并正确分配它们的指针。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/e9f7811dcc45b5f48a5eb2eab1926ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lkoKImmmtRjG1gQP5vgOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">removeFrom和insertAt的实现</p></figure><p id="3f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在页面底部的GitHub gist中包含了完整的实现，以及一个打印测试节点的方法。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1762" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">双向链表</h1><p id="a46c" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">双向链表也有类似的实现，但是对链表中前一个和后一个节点的引用都有一些优点和缺点。</p><ol class=""><li id="cfa6" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">我们必须跟踪前一个的<em class="lv">和后一个<em class="lv">的</em>指针，并确保在改变列表时正确设置它们。</em></li><li id="abca" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">因为我们可以访问前面的节点引用，所以我们不再需要为<code class="fe nb nc nd ne b">pop</code>方法遍历列表。</li><li id="6c74" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">双向链表每个节点使用更多的内存，因为它们有两个指针，但是它允许我们双向遍历链表。</li><li id="8da7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">双向链表在已知位置插入和删除的时间是常数，而单向链表的时间是线性的。</li></ol></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="9c67" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">单链表的完整实现</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单链表的完整实现</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="b994" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">双向链表的完整实现</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">双向链表的完整实现</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="69a7" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">资源</strong></h1><div class="op oq gp gr or os"><a href="https://en.wikipedia.org/wiki/Linked_list#Linked_lists_vs._dynamic_arrays" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">链表</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在计算机科学中，链表是数据元素的线性集合，其顺序不是由它们的物理…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">en.wikipedia.org</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://www.tutorialspoint.com/difference-between-singly-linked-list-and-doubly-linked-list-in-java" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">Java中单链表和双链表的区别</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">单链表和双链表都是链表的实现，其中每个元素都是链表的一部分</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">www.tutorialspoint.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://medium.com/journey-of-one-thousand-apps/data-structures-in-the-real-world-508f5968545a" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">现实世界中的数据结构——链表</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">双向链表—音乐播放列表</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://medium.com/swlh/small-math-to-big-o-901a90998871" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">小数学到大O</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">谁害怕大坏蛋？</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pj l pd pe pf pb pg ks os"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk oo l"/></div></figure></div></div>    
</body>
</html>