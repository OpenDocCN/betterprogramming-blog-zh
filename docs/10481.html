<html>
<head>
<title>Capture Ether: Guess the Random Number on a Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">捕捉以太:猜测智能合约上的随机数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/capture-the-ether-guess-the-random-number-2ebb8c9c0347?source=collection_archive---------10-----------------------#2022-01-10">https://betterprogramming.pub/capture-the-ether-guess-the-random-number-2ebb8c9c0347?source=collection_archive---------10-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d28b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">送乙醚赚更多乙醚(如果答案正确)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3ee23b851964141886f76947d9967af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y1mMPV7RT6FZ_7l_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@moneyphotos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> olieman.eth </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b70b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在链上创建随机数是一项复杂的任务。事实上，有一些变通方法可以做到这一点，但一般来说，强烈建议离线完成，因为几乎每个可能用于熵的输入都是公开的和/或在某种程度上可以被操纵。</p><p id="8fae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我们来说幸运的是，这个挑战要求我们猜一个在链上创建的“随机”数字。这是怎么回事？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/e59e2baf43a9af2c0af181dd6fefd65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*GcFT58AvchxG6Sh3GN-JEg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">猜随机数挑战智能合约码</p></figure><p id="01d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">契约的第一行是一个uint8变量，<code class="fe lt lu lv lw b">answer</code>。记住<code class="fe lt lu lv lw b">uint8</code>变量包含多达256个可能的整数:0到255。</p><p id="7c9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个变量在构造函数中被分配给两个输入的<code class="fe lt lu lv lw b">keccak256</code>哈希:包含我们正在部署的事务的前一个块的block hash<em class="lx">(</em><code class="fe lt lu lv lw b">block.blockhash(block.number - 1)</code>，类型bytes32)和我们的块被挖掘时的时间戳<em class="lx"> ( </em> <code class="fe lt lu lv lw b">now</code> <em class="lx">，类型uint256) </em>。</p><p id="2698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，这个契约使用的是编译器版本<code class="fe lt lu lv lw b">^0.4.21</code>，从那以后一些语法发生了变化:<code class="fe lt lu lv lw b">block.blockhash()</code>现在是<code class="fe lt lu lv lw b">blockhash()</code>，而<code class="fe lt lu lv lw b">now</code>是<code class="fe lt lu lv lw b">block.timestamp</code>。我们将在后面看到这一点。</p><p id="41b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在那一行中看到的，<code class="fe lt lu lv lw b">keccak256</code>函数(一个bytes32固定大小的字节数组)然后被显式转换为uint8并赋给我们的变量。</p><p id="fa67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，这看起来很随意，对吧？我们如何猜测一个0到255之间的数字，这个数字来自于对某个块的散列应用散列函数，以及谁知道什么时候的时间戳？！</p><p id="06e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，很容易。请记住，区块链上的一切都是公开的。所以，让我们继续寻找我们需要的信息。</p><p id="a917" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的目标在函数<code class="fe lt lu lv lw b">guess</code>下，我们必须调用它并发送一个<code class="fe lt lu lv lw b">uint8</code>加<code class="fe lt lu lv lw b">1 ether</code>(我们已经在部署时发送了一个)，然后如果我们的<code class="fe lt lu lv lw b">uint8</code>等于<code class="fe lt lu lv lw b">answer</code>变量，契约将发送给我们2个醚，耗尽余额，因此<code class="fe lt lu lv lw b">isComplete()</code>函数将返回<code class="fe lt lu lv lw b">true</code>。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="32ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多种方式与合同交互，但我决定通过另一个合同来实现。这不是最简单的方法，在这种情况下，甚至没有必要，但肯定是我们可以利用更多的方法。</p><p id="9621" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我为解决这一挑战而编写的代码:</p><pre class="kg kh ki kj gt mf lw mg mh aw mi bi"><span id="82cb" class="mj mk iq lw b gy ml mm l mn mo">// SPDX-License-Identifier: No License<br/>pragma solidity ^0.8.0;</span><span id="6fa1" class="mj mk iq lw b gy mp mm l mn mo">interface IGuessTheRandomNumberChallenge {<br/>  function guess(uint8) external payable;<br/>}</span><span id="49d8" class="mj mk iq lw b gy mp mm l mn mo">contract GuessTheRandomNumberSolver {</span><span id="1720" class="mj mk iq lw b gy mp mm l mn mo">  IGuessTheRandomNumberChallenge public _interface;<br/>  bytes32 public previousBlockHash = 0x66bcdb5e320c9e0c04a9fdeaa15de33a4c8a040db342f4f955fa54f170dba9ce;<br/>  uint public previousTimestamp = 1641520092;</span><span id="9156" class="mj mk iq lw b gy mp mm l mn mo">  constructor(address _interfaceAddress) {<br/>    require(_interfaceAddress != address(0), "Address can not be Zero");<br/>    _interface = IGuessTheRandomNumberChallenge(_interfaceAddress);<br/>  }</span><span id="cad2" class="mj mk iq lw b gy mp mm l mn mo">  function solve() public payable {<br/>    uint8 answer = uint8(uint256(keccak256(abi.encodePacked(previousBlockHash, previousTimestamp))));<br/>    _interface.guess{value: 1 ether}(answer);<br/>  }</span><span id="de9a" class="mj mk iq lw b gy mp mm l mn mo">  function getBalance() public view returns(uint){<br/>    return address(this).balance;<br/>  }</span><span id="6be6" class="mj mk iq lw b gy mp mm l mn mo">  function withdraw() public {<br/>    payable(msg.sender).transfer(address(this).balance);<br/>  }</span><span id="9d8d" class="mj mk iq lw b gy mp mm l mn mo">  receive() external payable {}<br/>}</span></pre><p id="064c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编译器版本之后，你首先看到的是一个<a class="ae kv" href="https://docs.soliditylang.org/en/v0.8.10/contracts.html#interfaces" rel="noopener ugc nofollow" target="_blank">接口</a>。我们可以使用这些通过我们的代码与其他契约进行交互。它基本上是一个带有一些规则的更简单的契约:</p><ul class=""><li id="e350" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">它们不能从其他协定继承，但可以从其他接口继承。</li><li id="e7b7" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">所有声明的函数都必须是外部的。</li><li id="c00c" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">它们不能声明构造函数。</li><li id="a1a2" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">它们不能声明状态变量。</li><li id="829b" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">它们不能声明修饰符。</li></ul><p id="a893" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们只需要调用<em class="lx">‘guess’</em>函数，这是我们在接口中声明的唯一一个函数。</p><p id="3fc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在我们的<code class="fe lt lu lv lw b">GuessTheRandomNumberSolver</code>契约中，我们将声明一个<code class="fe lt lu lv lw b">_interface</code>变量，并通过我们的构造函数分配挑战的地址(在CTE部署它时获得的地址)。</p><p id="4aaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们现在在部署的挑战中调用函数所需要的全部内容，所以让我们继续收集信息来重新创建与它一起部署的<code class="fe lt lu lv lw b">random</code>号。</p><p id="fd63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些都可以在<code class="fe lt lu lv lw b"><a class="ae kv" href="https://ropsten.etherscan.io/" rel="noopener ugc nofollow" target="_blank">etherscan</a></code>中找到，我们只需要找到我们挑战的地址。</p><p id="a155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">Blockhash(block.number - 1)</code>:要获取此信息，请转到<em class="lx">内部事务</em>选项卡，点击同一行上的模块编号，显示<em class="lx">合同创建。</em>在我的例子中，阻塞是<code class="fe lt lu lv lw b">#11766860</code> <em class="lx"> : </em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b9c5a498c305da521c0e7be7dad9519d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*6baKE_Y_HR7NCrULvpamBQ.png"/></div></figure><p id="b90e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以看到关于该模块的许多信息，但我们需要访问上一个模块，所以请继续查找。我的情况是<code class="fe lt lu lv lw b">#11766859</code>。</p><p id="b017" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面下来我们可以看到<code class="fe lt lu lv lw b">hash</code> <em class="lx">。那是我们需要的第一条信息。</em></p><p id="55fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">Block.timestamp</code> <strong class="ky ir"> <em class="lx"> : </em> </strong>回到我们的块，你会在第二行看到<em class="lx">时间戳</em>。但是等等，这是人类可读的格式，我们需要它的格式是<a class="ae kv" href="https://en.wikipedia.org/wiki/Unix_time" rel="noopener ugc nofollow" target="_blank"> <em class="lx"> Unix时间戳</em> </a>。那是什么？基本上就是从1970年1月1日开始过去的秒数。这是测量时间的标准方式。在写作的时候，这是一个10位数。</p><p id="c891" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将这个<em class="lx">人类可读的</em>时间戳转换成<em class="lx"> Unix时间</em>，我使用了一个非常方便的网站，名为<code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.epochconverter.com/" rel="noopener ugc nofollow" target="_blank">epochconverter</a></code>。有了这个数字，我们终于有了最后一块拼图，我们可以打电话来解决挑战。</p><p id="898b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到<code class="fe lt lu lv lw b">GuessTheRandomNumberSolver</code>契约，让我们创建一个<code class="fe lt lu lv lw b">solve</code> <em class="lx"> </em>函数，我们将调用它来联系我们的挑战契约。</p><p id="3f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于可读性的目的，我还创建了两个新变量:</p><ul class=""><li id="845f" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe lt lu lv lw b">bytes32 public previousBlockHash</code></li><li id="b571" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe lt lu lv lw b">uint public previousTimestamp.</code></li></ul><p id="b848" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建它们，但是给它们分配<em class="lx">你的</em>挑战值。</p><p id="e868" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在我们的<code class="fe lt lu lv lw b">solve</code> <em class="lx"> </em>函数中，我们将创建<code class="fe lt lu lv lw b">uint8 answer</code>变量并为其赋值:</p><pre class="kg kh ki kj gt mf lw mg mh aw mi bi"><span id="6ebb" class="mj mk iq lw b gy ml mm l mn mo">uint8(uint256(keccak256(abi.encodePacked(previousBlockHash, previousTimestamp))))</span></pre><p id="84f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">语法和格式的变化是因为我们使用的是编译器版本<code class="fe lt lu lv lw b">^0.8.0</code>，而挑战使用的是版本<code class="fe lt lu lv lw b">^0.4.21</code>。</p><p id="1822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经将答案赋给了变量，我们只需要通过接口调用挑战。这就是下一行要做的:</p><pre class="kg kh ki kj gt mf lw mg mh aw mi bi"><span id="8479" class="mj mk iq lw b gy ml mm l mn mo">_interface.guess{value: 1 ether}(answer)</span></pre><p id="ef33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我假设您正在使用remix，那么继续，通过<em class="lx"> Injected Web3 </em>环境连接您的metamask wallet，并部署您的契约，指定您的挑战地址以分配给您的接口。</p><p id="5333" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，用<em class="lx"> </em> <code class="fe lt lu lv lw b">value</code> <em class="lx"> </em>中的<em class="lx"> 1乙醚</em>输入继续并调用<code class="fe lt lu lv lw b">guess</code> <em class="lx"> </em>功能。</p><p id="3dac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我增加了几个功能:</p><ul class=""><li id="76a6" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe lt lu lv lw b">getBalance()</code></li><li id="c514" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe lt lu lv lw b">withdraw()</code></li><li id="c5b0" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe lt lu lv lw b">receive()</code></li></ul><p id="4b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为挑战的<code class="fe lt lu lv lw b">msg.sender</code>将是我们的<code class="fe lt lu lv lw b">GuessTheRandomNumberSolver</code>合同，而不是我们的EOA——所以我们需要接收2个以太，并能够将它们发送到我们的EOA。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e36f0eb9a610665ffe3ea957a5a8eff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*F9GFgvlOMZr_A0IXGOW2Dw.png"/></div></figure><p id="7df4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我们将解决“猜测新数字”的挑战。</p></div></div>    
</body>
</html>