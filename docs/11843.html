<html>
<head>
<title>Write Cleaner Swift Using MVVM With Property Wrappers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带有属性包装器的MVVM的写清洁器Swift</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cleaner-swift-mvvm-with-property-wrapper-bf38e2e5f298?source=collection_archive---------3-----------------------#2022-04-21">https://betterprogramming.pub/cleaner-swift-mvvm-with-property-wrapper-bf38e2e5f298?source=collection_archive---------3-----------------------#2022-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac06" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我如何制作<code class="fe kf kg kh ki b">@VMState</code>属性包装器</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/564bdb0ff5d66e588da133d4267ae360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eTDAo_4G9ktAFAFa"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Clode </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="798d" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我见过很多构建在模型-视图-视图模型<strong class="lc ir"> (MVVM) </strong>设计模式之上的iOS代码。虽然具体实现可能会有所不同，但是有一个子模式是每个人都遵循的，这是MVVM的一个事实原则:</p><blockquote class="lw lx ly"><p id="712f" class="la lb lz lc b ld le jr lf lg lh ju li ma lk ll lm mb lo lp lq mc ls lt lu lv ij bi translated"><strong class="lc ir"> <em class="iq">状态绑定；</em> </strong>它是关于从<strong class="lc ir">视图模型</strong>状态到<strong class="lc ir">视图的绑定。</strong></p></blockquote></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="a420" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们来看一个<code class="fe kf kg kh ki b">QuantifierView</code>的例子:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/b85611a347a6053600200d7a1438de4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/1*CxtXXxm190nHvpnmalj6KQ.gif"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">量化视图</p></figure><p id="64b3" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">将视图投影到视图模型表示中将产生以下功能和状态:</p><p id="1390" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ir">功能:</strong></p><ol class=""><li id="6f64" class="ml mm iq lc b ld le lg lh lj mn ln mo lr mp lv mq mr ms mt bi translated"><em class="lz">增加</em></li><li id="48a8" class="ml mm iq lc b ld mu lg mv lj mw ln mx lr my lv mq mr ms mt bi translated"><em class="lz">减少</em></li></ol><p id="47c1" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ir">状态</strong>:</p><ol class=""><li id="42d9" class="ml mm iq lc b ld le lg lh lj mn ln mo lr mp lv mq mr ms mt bi translated"><em class="lz">数量</em></li><li id="959e" class="ml mm iq lc b ld mu lg mv lj mw ln mx lr my lv mq mr ms mt bi translated"><em class="lz">错误</em></li></ol><p id="47b8" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在让我们关注状态实现。</p><p id="f7c4" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">使用vanilla Swift实现这一点的最直接的方法是在我们的ViewModel中为每个状态创建两个属性。</p><p id="a181" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">第一个是状态本身，另一个是一个观察器，它监听状态的变化，从而得到一个闭包。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">QuantifierViewModel</p></figure><p id="d6d7" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后把<code class="fe kf kg kh ki b">QuantifierViewModel</code>和<code class="fe kf kg kh ki b">QuantifierView</code>这样绑定:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">QuantifierView中的绑定部分</p></figure><p id="f5de" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这项工作的方式相当简单，每次<code class="fe kf kg kh ki b">QuantifierView</code>从按钮上调用<code class="fe kf kg kh ki b">increase</code>和<code class="fe kf kg kh ki b">decrease</code> <em class="lz"> </em>函数时，它会变异<code class="fe kf kg kh ki b">QuantifierViewModel</code>中的<code class="fe kf kg kh ki b">quantity</code>和<code class="fe kf kg kh ki b">error</code> <em class="lz"> </em>状态，然后调用观察者来更新视图标签。</p><p id="903b" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">注意<code class="fe kf kg kh ki b">QuantifierViewModel</code> <strong class="lc ir"> </strong>是如何花费大量代码来定义一个状态及其观察者的。定义非常重复。如果Swift确实有某种机制来包装这种重复行为，并在我们的视图模型中的所有状态中重用它，这不是很好吗？</p><blockquote class="lw lx ly"><p id="7e90" class="la lb lz lc b ld le jr lf lg lh ju li ma lk ll lm mb lo lp lq mc ls lt lu lv ij bi translated">嗯，是的，它是！</p></blockquote><p id="2cce" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">幸运的是，从Swift 5.1开始，有一个称为属性包装器<strong class="lc ir"> </strong>的特性，可以用来抽象出可爱的<code class="fe kf kg kh ki b"><strong class="lc ir">@</strong></code>符号背后的属性的额外行为。结合泛型的强大功能，我们可以将状态的公共行为封装在名为<code class="fe kf kg kh ki b">@VMState</code>的新属性包装器中:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7b88" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">请注意，我显然只是将视图模型中的状态定义复制粘贴到VMState中。</p><p id="e040" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在我们新的属性包装器中，有两个主要部分需要让每个人都知道，以便理解这个想法。</p><p id="fa4a" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">第一个是<code class="fe kf kg kh ki b">wrappedValue</code>，它基本上是属性(或状态)，另一个是<code class="fe kf kg kh ki b">projectedValue</code>，它是包装我们的状态行为的包装器。</p><p id="c5e5" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">它们一起成为属性包装器。</p><p id="5749" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了访问<code class="fe kf kg kh ki b">projectedValue</code>(或包装器),我们可以在我们的属性前使用<code class="fe kf kg kh ki b">$</code>符号。</p><pre class="kk kl km kn gt nb ki nc nd aw ne bi"><span id="901b" class="nf ng iq ki b gy nh ni l nj nk">@VMState var myState: Int // definition</span><span id="7ae4" class="nf ng iq ki b gy nl ni l nj nk">// invocation<br/>print(type(of: myState)) // Int<br/>print(type(of: $myState)) // VMState&lt;Int&gt;</span></pre><p id="7697" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有了它，我们可以在我们的<code class="fe kf kg kh ki b">QuantifierViewModel</code> <strong class="lc ir"> </strong>中利用它来清除我们的状态定义中的重复代码:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0006" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后我们可以访问<code class="fe kf kg kh ki b">projectedValue</code>来为我们的<code class="fe kf kg kh ki b">QuantifierView</code>中的状态(绑定)分配观察者。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bd08" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">虽然我们的<code class="fe kf kg kh ki b">@VMState</code>很有魅力，但它仍然只是冰山一角。我们还可以做很多改进，比如给状态分配多个观察器，删除特定的观察器(就像<code class="fe kf kg kh ki b">NotificationCenter</code>中的<code class="fe kf kg kh ki b">removeObserver</code> <strong class="lc ir"> </strong>)，忽略重复值的观察器调用，等等。</p><p id="2d78" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">此外，请注意，Apple已经有一个内置的类似方法，这是SwiftUI模块的<a class="ae kz" href="https://developer.apple.com/documentation/swiftui/state/" rel="noopener ugc nofollow" target="_blank">状态</a>。如果您一直在对SwiftUI代码进行切片或使用Combine的功能，您可能会发现VMState非常熟悉。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="7b1e" class="nm ng iq bd nn no np nq nr ns nt nu nv jw nw jx nx jz ny ka nz kc oa kd ob oc bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="f3fc" class="ml mm iq lc b ld od lg oe lj of ln og lr oh lv mq mr ms mt bi translated"><a class="ae kz" href="https://medium.com/@abhilash.mathur1891/mvvm-in-ios-swift-aa1448a66fb4" rel="noopener">https://medium . com/@ abhi lash . mathur 1891/mvvm-in-IOs-swift-aa 1448 a 66 FB 4</a></li><li id="e2da" class="ml mm iq lc b ld mu lg mv lj mw ln mx lr my lv mq mr ms mt bi translated"><a class="ae kz" href="https://nshipster.com/propertywrapper" rel="noopener ugc nofollow" target="_blank">https://nshipster.com/propertywrapper</a></li><li id="afdb" class="ml mm iq lc b ld mu lg mv lj mw ln mx lr my lv mq mr ms mt bi translated"><a class="ae kz" href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift" rel="noopener ugc nofollow" target="_blank">https://www . swiftbysundell . com/articles/property-wrappers-in-swift</a></li></ol></div></div>    
</body>
</html>