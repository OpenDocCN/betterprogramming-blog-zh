<html>
<head>
<title>Dynamic Programming in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的动态规划</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-programming-in-go-a95d32ee9953?source=collection_archive---------0-----------------------#2020-09-20">https://betterprogramming.pub/dynamic-programming-in-go-a95d32ee9953?source=collection_archive---------0-----------------------#2020-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce55" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在围棋中把问题分解成子问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f75a1a8885d1a1324415b425abd2fef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfCFZg4qoAo1-lFPElrMhg.png"/></div></div></figure><h1 id="650f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="fb17" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">动态编程可以被认为是一种将复杂问题分解为子问题，一次性解决每个子问题，并保存解决方案以备后用的方法。正如我们将在本文后面看到的，这种方法比其他方法提供了更高的效率和模块化优势，我们将很快对此进行探讨。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1ff9" class="ku kv it bd kw kx mp kz la lb mq ld le jz mr ka lg kc ms kd li kf mt kg lk ll bi translated">动态编程技术</h1><p id="1f0b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当我们谈论动态编程时，我们还必须讨论以下技术:</p><ul class=""><li id="61b5" class="mu mv it lo b lp mw ls mx lv my lz mz md na mh nb nc nd ne bi translated"><code class="fe nf ng nh ni b">Memoization</code>:不要与<code class="fe nf ng nh ni b">Memorization</code>混淆，<code class="fe nf ng nh ni b">Memoization</code>是一种提高递归函数/算法性能的技术。换句话说，它通过存储昂贵的函数调用的解决方案，并在相同的输入再次提供给程序时返回缓存的解决方案，提供了加速程序的优化。</li><li id="ab48" class="mu mv it lo b lp nj ls nk lv nl lz nm md nn mh nb nc nd ne bi translated">也被称为自底向上技术，这是另一种在动态编程中使用的优化技术。正如您可能猜到的那样，这种技术采用表格方法，首先填写表格，然后根据表格中填写的解决方案解决原始问题。</li></ul><p id="afd4" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">在本文中，我们只看记忆化，不看列表。</p><p id="8450" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">既然我们已经讨论了动态编程及其技术，让我们进入编码阶段。我们将以斐波那契数列问题为例，用三种不同的方法来解决它。如果你第一次听说斐波纳契数列，它是一系列的数字，其中下一个数字是通过将前面的两个数字相加得到的。例如，序列<code class="fe nf ng nh ni b">[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code>构成了斐波那契数列的前十项。按照这种解释，一个<code class="fe nf ng nh ni b">Fibonacci(10)</code>将导致55。</p><p id="4c61" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">开始任何方法的第一步是定义一个函数来帮助我们跟踪我们将要展示的每个解决方案的执行时间:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="4fe7" class="nv kv it ni b gy nw nx l ny nz">// for tracking program's execution time<br/>func trackTime(<strong class="ni iu">start</strong> time.Time, <strong class="ni iu">result</strong> int, <strong class="ni iu">name</strong> <strong class="ni iu">string</strong>) {<br/>	elapsed := time.Since(<strong class="ni iu">start</strong>)<br/>	log.Printf("---&gt; %s solution | result: %v | took: %s", <strong class="ni iu">name</strong>, <strong class="ni iu">result</strong>, elapsed)<br/>}</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="4320" class="ku kv it bd kw kx mp kz la lb mq ld le jz mr ka lg kc ms kd li kf mt kg lk ll bi translated">递归</h1><p id="3ddd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当面对斐波那契数列问题时，一种可能想到的方法是使用递归。让我们来看看这种方法的实现及其效率:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="a6ab" class="nv kv it ni b gy nw nx l ny nz">// the recursive function approach definition<br/>func <strong class="ni iu">expensiveFib</strong>(n <strong class="ni iu">int</strong>) <strong class="ni iu">int</strong> {<br/>  <strong class="ni iu">if</strong> n &lt; 2 {<br/>  	<strong class="ni iu">return</strong> n<br/>  }<br/><br/>  result := expensiveFib(n-1) + expensiveFib(n-2)<br/><br/>  <strong class="ni iu">return</strong> result<br/>}</span></pre><p id="896c" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">运行输入为<code class="fe nf ng nh ni b">50</code>的递归解决方案将产生执行时间大约为<code class="fe nf ng nh ni b">1m and 6.413943065s</code>的<code class="fe nf ng nh ni b">12586269025</code>。为什么需要这么长时间？简单来说就是由于函数的递归调用。我们正在检查输入是否小于2。如果是这样，我们返回输入并移动到函数调用的下一个堆栈。在这种情况下，返回的输入将是1或0。另一方面，如果2不大于输入，我们调用该函数两次——一次使用输入1，第二次使用输入2，并将两次调用的结果相加。下图描述了该过程(使用输入值5):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/3801b0fe1f944950b1980b52cae2f625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*dif3p73c4-FYB4dTMgrVhw.png"/></div></figure><h1 id="813a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">环</h1><p id="4446" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">另一种方法是使用循环。让我们来看看这种方法的实现及其效率:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="308a" class="nv kv it ni b gy nw nx l ny nz">// the loop approach definition<br/>func <strong class="ni iu">fibByLoop</strong>(n <strong class="ni iu">int</strong>) <strong class="ni iu">int</strong> {<br/>	fibBox := []<strong class="ni iu">int</strong>{0, 1}</span><span id="0903" class="nv kv it ni b gy ob nx l ny nz">	<strong class="ni iu">for</strong>  i := 0; i &lt; n; i++ {<br/>		v := fibBox[i] + fibBox[i+1]<br/>		fibBox = append(fibBox, v)<br/>	}</span><span id="2fc3" class="nv kv it ni b gy ob nx l ny nz">	result := <strong class="ni iu">int</strong>(fibBox[n])<br/>	defer trackTime(time.Now(), result, "Loop")<br/>	<br/>	<strong class="ni iu">return</strong> result<br/>}</span></pre><p id="b449" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">运行输入为<code class="fe nf ng nh ni b">50</code>的<code class="fe nf ng nh ni b">Loop</code>解决方案将得到执行时间大约为12.406秒的<code class="fe nf ng nh ni b">12586269025</code>，这似乎比递归方法快得多——53.393639181秒。令人印象深刻！</p><p id="1948" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">那么，这个解决方案背后的算法是什么？答案是，我们使用了迭代方法。让我们回顾一下这些步骤:</p><ul class=""><li id="2096" class="mu mv it lo b lp mw ls mx lv my lz mz md na mh nb nc nd ne bi translated">我们创建并初始化一个数组，即<code class="fe nf ng nh ni b">fibBox</code>的值为<code class="fe nf ng nh ni b">0</code>和<code class="fe nf ng nh ni b">1</code>(这是斐波那契数列的起点)。</li><li id="4098" class="mu mv it lo b lp nj ls nk lv nl lz nm md nn mh nb nc nd ne bi translated">在循环中，我们创建了另一个变量<code class="fe nf ng nh ni b">i</code>，并将其初始化为<code class="fe nf ng nh ni b">0</code>。这在每次迭代中被用作索引<code class="fe nf ng nh ni b">fibBox</code>。</li><li id="0255" class="mu mv it lo b lp nj ls nk lv nl lz nm md nn mh nb nc nd ne bi translated">我们迭代参数<code class="fe nf ng nh ni b">n</code>并检查<code class="fe nf ng nh ni b">i &lt; n</code>是否。只要<code class="fe nf ng nh ni b">i &lt; n</code>，我们就递减<code class="fe nf ng nh ni b">n</code>。</li><li id="0ccd" class="mu mv it lo b lp nj ls nk lv nl lz nm md nn mh nb nc nd ne bi translated">在每次迭代中，我们对<code class="fe nf ng nh ni b">fibBox</code>(例如<code class="fe nf ng nh ni b">fibBox[i] + fibBox[i+1]</code>)中当前和下一个索引的值求和，并将结果附加到<code class="fe nf ng nh ni b">fibBox</code>。一旦循环运行完毕，我们返回<code class="fe nf ng nh ni b">fibBox[n]</code>的值；这是我们得到的输入的斐波那契数列的结果。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ef81" class="ku kv it bd kw kx mp kz la lb mq ld le jz mr ka lg kc ms kd li kf mt kg lk ll bi translated">记忆化</h1><p id="5950" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">另一种方法是记忆化。让我们看看这种方法的实现和效率。如上所述，内存化提高了递归的性能，这意味着我们应该首先实现一个递归函数(我们将使用上面定义的函数)，然后，我们通过在缓存中存储和重用解决方案来提高它的效率。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="3eba" class="nv kv it ni b gy nw nx l ny nz">// we made a few changes to the one used used above in the Recursion solution<br/>func <strong class="ni iu">refinedExpensiveFib</strong>(n <strong class="ni iu">int</strong>, cache map[<strong class="ni iu">int</strong>]<strong class="ni iu">int</strong>) <strong class="ni iu">int</strong> {<br/>	<strong class="ni iu">if</strong> n &lt; 2 {<br/>		cache[n] = n   // n is either 0 or 1<br/>		<strong class="ni iu">return</strong> n<br/>	}</span><span id="c68d" class="nv kv it ni b gy ob nx l ny nz">	// check cache before calling the function recursively<br/>	<strong class="ni iu">if</strong> _, ok := cache[n-1]; !ok {<br/>		// we haven't come across n-1 before<br/>		cache[n-1] = refinedExpensiveFib(n-1, cache)<br/>	}<br/>	// At this point, n-1 is in the cache. You could log n-1</span><span id="e7bd" class="nv kv it ni b gy ob nx l ny nz">	<strong class="ni iu">if</strong> _, ok := cache[n-2]; !ok {<br/>		// we haven't come across n-1 before<br/>		cache[n-2] = refinedExpensiveFib(n-2, cache)<br/>	}<br/>	// At this point, n-2 is in the cache. You could log n-2</span><span id="d4f9" class="nv kv it ni b gy ob nx l ny nz">	// returns the summed up cache<br/>	<strong class="ni iu">return</strong> cache[n-1] + cache[n-2]<br/>}</span></pre><p id="82c7" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">最后，我们定义一个<code class="fe nf ng nh ni b">memoize()</code>，它将<code class="fe nf ng nh ni b">refinedExpensiveFib()</code>:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="a221" class="nv kv it ni b gy nw nx l ny nz">// the memoize approach definition<br/>func <strong class="ni iu">memoize</strong>(n <strong class="ni iu">int</strong>) <strong class="ni iu">int</strong> {<br/>    cache := make(map[<strong class="ni iu">int</strong>]<strong class="ni iu">int</strong>)<br/>    result := make([]<strong class="ni iu">int</strong>, n)<br/><br/>    <strong class="ni iu">for</strong> i := 1; i &lt;= n; i++{<br/>		result[i-1] = refinedExpensiveFib(i, cache)<br/>	}<br/><br/>	<strong class="ni iu">return</strong> result[n-1]<br/>}</span></pre><p id="4376" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">运行输入为<code class="fe nf ng nh ni b">50</code>的记忆化解决方案将导致<code class="fe nf ng nh ni b">12586269025</code>的执行时间大约为42.571秒。这比递归解决方案要快得多，也更有效。除了性能提升之外，我们还可以灵活地将解决方案模块化并提高可读性。</p><p id="6117" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">完整的程序(我建议您单独运行每个解决方案):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="5b4f" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">运行<code class="fe nf ng nh ni b">main()</code>将导致:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="af79" class="nv kv it ni b gy nw nx l ny nz">2020/09/19 21:44:40 ---&gt; Recursion solution   | result: 12586269025 | took: <!-- -->53.393639181s<br/>2020/09/19 21:42:22 ---&gt; Loop solution        | result: <!-- -->12586269025<!-- --> | took: <!-- -->12.406µs<br/>2020/09/19 21:44:40 ---&gt; Memoization solution | result: 12586269025 | took: <!-- -->42.571µs</span></pre><p id="6982" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">记忆化提供了比递归方法更好的模块化和代码可读性；我们看到了我们如何在<code class="fe nf ng nh ni b">expensiveFib()</code>(我们将其命名为<code class="fe nf ng nh ni b">refinedExpensiveFib()</code>)中改进/提炼逻辑，然后我们在<code class="fe nf ng nh ni b">memoize()</code>中将其命名为。然而。环路解决方案仍然被证明是最快的。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="38f4" class="ku kv it bd kw kx mp kz la lb mq ld le jz mr ka lg kc ms kd li kf mt kg lk ll bi translated">结论</h1><p id="508e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本文中，我们探索了三种解决斐波那契数列问题的方法。我们权衡了每种方法的效率、可读性和模块化。您可以在本文中阅读更多关于内存化的内容:<a class="ae oe" href="https://blog.john-pfeiffer.com/dynamic-programming-and-memoization-and-the-compute-versus-storage-tradeoff/" rel="noopener ugc nofollow" target="_blank">动态编程和内存化以及计算与存储的权衡</a></p><p id="a45d" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">我希望你能像我写这篇博客一样喜欢通读。</p><p id="f374" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">让我们继续前进！</p></div></div>    
</body>
</html>