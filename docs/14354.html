<html>
<head>
<title>Build a Cross Platform CLI Application With Go and Cobra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go和Cobra构建跨平台CLI应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cross-platform-cli-application-with-go-and-cobra-35945894fe68?source=collection_archive---------4-----------------------#2022-12-02">https://betterprogramming.pub/cross-platform-cli-application-with-go-and-cobra-35945894fe68?source=collection_archive---------4-----------------------#2022-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4e8f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为多个目标构建Go应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd6b47406de7def59ec35d5b4c965ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5KuCKOwN4clYkBvOm2bLg.png"/></div></div></figure><p id="9bc4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文将介绍使用Go编程语言构建一个<a class="ae ln" href="https://en.wikipedia.org/wiki/Command-line_interface" rel="noopener ugc nofollow" target="_blank">命令行界面(CLI) </a> [1]应用程序的过程和相关组件。我们将涵盖所需的库、目录结构、配置文件、测试和跨平台构建过程。</p><h1 id="7468" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">命令行解释器(CLI) </strong></h1><p id="5726" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">CLI代表<a class="ae ln" href="https://en.wikipedia.org/wiki/Command-line_interface" rel="noopener ugc nofollow" target="_blank">命令行界面</a>【1】。CLI应用程序接收来自用户的输入，执行一些计算任务并生成输出。与<a class="ae ln" href="https://en.wikipedia.org/wiki/Graphical_user_interface" rel="noopener ugc nofollow" target="_blank">图形用户界面(GUI)</a>【2】相比，CLI应用需要更少的系统资源，因为与它的交互不涉及图形。</p><p id="2fc9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CLI应用程序的一个很酷的地方(至少在我看来)是，当设计时考虑到组合并有一个定义良好的输入/输出接口。这些应用程序可以组合在一起(类似于功能组合)作为一个解决方案。</p><p id="af8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果我们有两个CLI应用程序，A和B，我们可以创建一个A.B的组合解决方案，输入A，输出B。</p><h1 id="2c6e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">跨平台</strong></h1><p id="fcad" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">跨平台[5]应用程序被设计成可以在多个计算平台上运行。例如，我们可以构建相同的软件，但在Linux、Windows和Android设备上运行。这些应用程序也被称为多平台、平台无关或平台独立的。</p><p id="ef67" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个非常酷的概念。因为谁想维护比需要更多的软件呢？但在软件设计中也需要考虑。跨平台应用程序需要考虑任何操作系统(OS)细节。在下面几节中，我们将在处理本地文件系统时看到它的例子。</p><h1 id="78b2" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak"> CLI项目设置</strong></h1><p id="a61f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们将使用<a class="ae ln" href="https://cobra.dev/" rel="noopener ugc nofollow" target="_blank">Cobra</a>【3】<strong class="kt ir">CLI</strong>框架。<strong class="kt ir"> Cobra </strong>是一个非常强大的、可扩展的、令人愉快的框架。你不会后悔的，我保证！</p><p id="8498" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用的Go版本:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="a370" class="mq lp iq mm b be mr ms l mt mu">$ go version<br/>go version go1.19 darwin/arm64</span></pre><p id="cadf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">初始化我们的项目:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="05ef" class="mq lp iq mm b be mr ms l mt mu">$ go mod init github.com/Pavel-Durov/cli-demo<br/>go: creating new go.mod: module github.com/Pavel-Durov/cli-demo</span></pre><p id="dacc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安装<code class="fe mv mw mx mm b">Cobra</code>和<code class="fe mv mw mx mm b">CobraCLI</code>。<code class="fe mv mw mx mm b">CobraCLI</code>将创建我们的应用程序并添加CLI命令。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="13c3" class="mq lp iq mm b be mr ms l mt mu">$ go get -u github.com/spf13/cobra/cobra<br/>$ go install github.com/spf13/cobra-cli@latest</span></pre><p id="c28f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以使用<code class="fe mv mw mx mm b">CobraCLI</code>来初始化我们的<code class="fe mv mw mx mm b">CLI</code>应用程序:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="6945" class="mq lp iq mm b be mr ms l mt mu">$ cobra-cli init</span></pre><p id="9cb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样。我们有一个可用的应用程序！它应该具有以下结构:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="77bb" class="mq lp iq mm b be mr ms l mt mu">$ tree<br/>├── cmd<br/>│ └── root.go<br/>├── go.mod<br/>├── go.sum<br/>└── main.go</span></pre><p id="bb34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有<code class="fe mv mw mx mm b">main.go</code>文件，这是我们应用程序的主要入口点。一个叫做<code class="fe mv mw mx mm b">root</code>的<code class="fe mv mw mx mm b">CLI</code>命令是Cobra框架的主要入口点。将Go项目的应用程序入口点放在<code class="fe mv mw mx mm b">cmd</code>目录中也是一种惯例。</p><p id="e26c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行我们全新的<code class="fe mv mw mx mm b">CLI</code>应用程序:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="2dd3" class="mq lp iq mm b be mr ms l mt mu">$ go run ./main.go<br/>A longer description that spans multiple lines and likely contains<br/>examples and usage of using your application. For example:<br/>Cobra is a CLI library for Go that empowers applications.<br/>This application is a tool to generate the needed files<br/>to quickly create a Cobra application.</span></pre><p id="308f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还没有匹配的内容可看；我们得到默认消息。让我们添加一些功能。</p><p id="2dcf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这个演示，我们将构建一个计算器<code class="fe mv mw mx mm b">CLI</code>应用程序。我知道，很刺激！</p><p id="9ba9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加我们的第一个命令</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="f6bc" class="mq lp iq mm b be mr ms l mt mu">//file: ./cmd/add.go<br/>package cmd<br/><br/>import (<br/> "github.com/spf13/cobra"<br/>)<br/><br/>var addCmd = &amp;cobra.Command{<br/> Use:   "add",<br/> Short: "Add operator",<br/> Long:  `Add operator, adds two integers and prints the result.`,<br/> Run: func(cmd *cobra.Command, args []string) {<br/>  num1, _ := cmd.Flags().GetInt32("n1")<br/>  num2, _ := cmd.Flags().GetInt32("n2")<br/>  cmd.Printf("%d + %d = %d\n", num1, num2, num1+num2)<br/> },<br/>}<br/><br/>func init() {<br/> addCmd.Flags().Int32("n1", 0, "--n1 1")<br/> addCmd.Flags().Int32("n2", 0, "--n1 2")<br/> addCmd.MarkFlagRequired("n1")<br/> addCmd.MarkFlagRequired("n2")<br/>}</span></pre><p id="ce96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们也可以为此使用<code class="fe mv mw mx mm b">CobraCLI</code>。但我决定手动操作。</p><p id="ccb5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们定义了<strong class="kt ir">使用</strong>属性，这意味着为了使用<code class="fe mv mw mx mm b">add</code>命令，我们需要在我们的<code class="fe mv mw mx mm b">CLI</code>参数中指定第一个<code class="fe mv mw mx mm b">add</code>。</p><p id="088b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe mv mw mx mm b">CLI</code>命令连接在一起:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="35d0" class="mq lp iq mm b be mr ms l mt mu">//file: ./cmd/root.go<br/>package cmd<br/><br/>import (<br/> "os"<br/><br/> "github.com/spf13/cobra"<br/>)<br/><br/>var rootCmd = &amp;cobra.Command{<br/> Use:   "[command]",<br/> Short: "A CLI calculator",<br/> Long:  `A CLI calculator that can add and subtract two numbers.`,<br/>}<br/><br/>func Execute() {<br/> err := rootCmd.Execute()<br/> if err != nil {<br/>  os.Exit(1)<br/> }<br/>}<br/><br/>func init() {<br/> rootCmd.AddCommand(addCmd) // adding add command to root<br/>}</span></pre><p id="c6d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们的命令是同一个包<code class="fe mv mw mx mm b">cmd</code>的一部分，所以导入和配置非常简单。</p><p id="6b36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重新运行我们的命令，这次使用<code class="fe mv mw mx mm b">-h</code>标志:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="6081" class="mq lp iq mm b be mr ms l mt mu">$ go run ./main.go  -h<br/>A CLI calculator that can add and subtractwo numbers.<br/><br/>Usage:<br/>  calc [command]<br/><br/>Available Commands:<br/>  add         Add operator<br/>  completion  Generate the autocompletion script for the specified shell<br/>  help        Help about any command<br/><br/>Flags:<br/>  -h, --help   help for calc<br/><br/>Use "calc [command] --help" for more information about a command.</span></pre><p id="a5d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，cobra为我们做了很多工作。它确实配置了如何解析标志、帮助消息等。</p><p id="d4d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用指定的参数运行实际命令:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="3767" class="mq lp iq mm b be mr ms l mt mu">$ go run ./main.go  add --n1=1 --n2=3<br/>1 + 3 = 4</span></pre><p id="ecac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有一个成熟的<code class="fe mv mw mx mm b">CLI</code>应用程序，可以将两个数字相加，并将结果打印到<code class="fe mv mw mx mm b">stdout</code>。</p><p id="251b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们添加另一个命令！这次我们将添加替换。</p><p id="d7cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很简单:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="ec0b" class="mq lp iq mm b be mr ms l mt mu">//file: ./cmd/sub.go<br/>package cmd<br/><br/>import (<br/> "github.com/spf13/cobra"<br/>)<br/><br/>var subCmd = &amp;cobra.Command{<br/> Use:   "sub",<br/> Short: "Sub operator",<br/> Long:  `Sub operator, subtracts two integers and prints the result.`,<br/> Run: func(cmd *cobra.Command, args []string) {<br/>  num1, _ := cmd.Flags().GetInt32("n1")<br/>  num2, _ := cmd.Flags().GetInt32("n2")<br/>  cmd.Printf("%d - %d = %d\n", num1, num2, num1-num2)<br/> },<br/>}<br/><br/>func init() {<br/> subCmd.Flags().Int32("n1", 0, "--n1 1")<br/> subCmd.Flags().Int32("n2", 0, "--n1 2")<br/> subCmd.MarkFlagRequired("n1")<br/> subCmd.MarkFlagRequired("n2")<br/>}</span></pre><p id="a44f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同前，添加新命令到<strong class="kt ir">根</strong>:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="6ef4" class="mq lp iq mm b be mr ms l mt mu">...<br/>rootCmd.AddCommand(subCmd)<br/>...</span></pre><p id="73bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">试一试:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="1a46" class="mq lp iq mm b be mr ms l mt mu">$ go run ./main.go sub - n1=10 - n2=4<br/>10–4 = 6</span></pre><p id="3d26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它完全按照预期工作！您可以想象如何使用相同的过程来进一步扩展我们的CLI应用程序。</p><h1 id="948b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">添加测试</h1><p id="0115" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我喜欢测试，我想你也应该喜欢。在Go中添加单元测试非常简单；然而，测试像Cobra这样的CLI命令可能有点棘手。这就是为什么我想演示如何做。</p><p id="b1fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将测试添加到root CLI命令:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="ad2e" class="mq lp iq mm b be mr ms l mt mu">// file: cmd/root_test.go<br/>func TestTypeLocal(t *testing.T) {<br/> buf := new(bytes.Buffer)<br/> rootCmd.SetOut(buf)<br/> rootCmd.SetArgs([]string{"sub", "--n1=10", "--n2=4"})<br/><br/> err := rootCmd.Execute()<br/> if err != nil {<br/>  fmt.Println(err)<br/> }<br/> if buf.String() != "10 - 4 = 6\n" {<br/>  t.Errorf("Expected 10 - 4 = 6, got %s", buf.String())<br/> }<br/>}</span></pre><p id="00ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们为cobra命令设置了一个缓冲区作为输出流，并传递了<strong class="kt ir"> CLI </strong>参数(也称为标志)，然后我们断言输出结果——没什么特别的。</p><p id="8029" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行测试:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="ff1d" class="mq lp iq mm b be mr ms l mt mu">$ go test ./…<br/>ok github.com/Pavel-Durov/cli-demo/cmd 0.207s</span></pre><h1 id="ac1b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">添加配置文件/设置</strong></h1><p id="07dd" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如果我们想要跨会话存储应用程序配置，或者我们想要在应用程序代码之外定义API密钥之类的秘密，我们该怎么做？不管什么原因，眼镜蛇会保护你的！实际上，<a class="ae ln" href="https://github.com/spf13/viper" rel="noopener ugc nofollow" target="_blank">毒蛇</a>【4】挺你。Viper是一个用于Go应用程序的配置管理工具。毒蛇和眼镜蛇配合得很好。</p><p id="9d1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安装<em class="my">毒蛇:</em></p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="c1b8" class="mq lp iq mm b be mr ms l mt mu">$ go get github.com/spf13/viper</span></pre><p id="de7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的init函数中配置Viper，root cmd:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="4473" class="mq lp iq mm b be mr ms l mt mu">// file: cmd/root.go<br/>func initConfig() {<br/>    home, err := os.UserHomeDir()<br/> cobra.CheckErr(err)<br/> viper.AddConfigPath(home)<br/> viper.SetConfigType("yaml")<br/> viper.SetConfigName(".calc")<br/> viper.ReadInConfig()<br/>}<br/><br/>func init() {<br/> cobra.OnInitialize(initConfig)<br/>    ...<br/>}</span></pre><p id="b026" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们在我们的<code class="fe mv mw mx mm b">$HOME</code>目录中创建一个名为<code class="fe mv mw mx mm b">.calc</code>的本地<code class="fe mv mw mx mm b">YAML</code>文件(因为这是我们配置的),其内容为:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="64d9" class="mq lp iq mm b be mr ms l mt mu">$ cat ~/.calc<br/>username: kimchi</span></pre><p id="9022" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以在应用程序中读取这些值:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="e68f" class="mq lp iq mm b be mr ms l mt mu">username := viper.Get("username")<br/>if username != nil {<br/>    fmt.Println("Hello", username)<br/>}</span></pre><p id="9adf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不必使用<code class="fe mv mw mx mm b">YAML</code>或<code class="fe mv mw mx mm b">$HOME</code>目录；这种设置可以通过多种方式进行配置。</p><h2 id="1434" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated"><strong class="ak">关于$HOME目录的说明</strong></h2><p id="f32e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">注意我们如何使用<code class="fe mv mw mx mm b">os.UserHomeDir()</code>来获取用户的主目录。如果我们想要构建一个<a class="ae ln" href="https://en.wikipedia.org/wiki/Cross-platform_software" rel="noopener ugc nofollow" target="_blank">跨平台</a>【6】的应用程序，这是很重要的。我们可以硬编码文件的路径。但是我们为什么要这样做呢？Go拥有强大的平台无关库支持— <code class="fe mv mw mx mm b">os.UserHomeDir()</code>将返回特定于运行它的机器的<code class="fe mv mw mx mm b">$HOME</code>目录的路径，而无需我们更改一行代码！</p><ul class=""><li id="7648" class="nl nm iq kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">在Unix(包括macOS)上，它返回<code class="fe mv mw mx mm b">$HOME</code>环境变量</li><li id="a09f" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm nq nr ns nt bi translated">在Windows上，它返回<code class="fe mv mw mx mm b">%USERPROFILE%</code></li><li id="d0d5" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm nq nr ns nt bi translated">在计划9中，它返回环境变量<code class="fe mv mw mx mm b">$HOME</code></li></ul><h1 id="a4eb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">构建我们的CLI应用</strong></h1><p id="bdd7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Go有一个令人难以置信的构建系统，它提供了我们需要的一切。</p><p id="24d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以轻松地为多种架构和操作系统(OS)构建我们的应用程序:</p><h2 id="3dae" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated"><strong class="ak"> Linux目标构建</strong></h2><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="fe7c" class="mq lp iq mm b be mr ms l mt mu">$ CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o out/linux-arm64-calc -ldflags="-extldflags=-static" # linux, arm64 arch<br/>$ CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o out/linux-amd64-calc -ldflags="-extldflags=-static" # linux, amd64 arch</span></pre><h2 id="c26e" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated"><strong class="ak"> Mac(又名达尔文)目标构建</strong></h2><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="50f1" class="mq lp iq mm b be mr ms l mt mu">$ CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build -o out/darwin-arm64-calc -ldflags="-extldflags=-static" # mac, arm64 arch<br/>$ CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -o out/darwin-amd64-calc -ldflags="-extldflags=-static" # mac, amd64 arch</span></pre><h2 id="adb1" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated"><strong class="ak"> Windows目标版本</strong></h2><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="7c2c" class="mq lp iq mm b be mr ms l mt mu">$ CGO_ENABLED=0 GOOS=windows GOARCH=arm64 go build -o out/windows-arm64-calc -ldflags="-extldflags=-static" # windows, arm64 arch<br/>$ CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o out/windows-amd64-calc -ldflags="-extldflags=-static" # windows, amd64 arch</span></pre><p id="329c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们运行所有这些构建命令，我们将得到这些二进制文件:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="cd17" class="mq lp iq mm b be mr ms l mt mu">$ ls -l ./out/<br/>-rwxr-xr-x  1 ... darwin-amd64-calc<br/>-rwxr-xr-x  1 ... darwin-arm64-calc<br/>-rwxr-xr-x  1 ... linux-amd64-calc<br/>-rwxr-xr-x  1 ... linux-arm64-calc<br/>-rwxr-xr-x  1 ... windows-amd64-calc<br/>-rwxr-xr-x  1 ... windows-arm64-calc</span></pre><h2 id="d6bb" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated"><strong class="ak">环境变量</strong></h2><p id="3db3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><strong class="kt ir"> GOOS </strong></p><p id="dd60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能已经注意到，构建目标之间唯一改变的是<code class="fe mv mw mx mm b">GOOS</code>环境变量。这就是你使用go-build工具所需要改变的一切！它真的很容易使用！</p><p id="c9ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mv mw mx mm b">GOARCH</code></p><p id="3bb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们指定我们的目标<strong class="kt ir"> CPU </strong>架构的地方。</p><p id="b6d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看所有支持的<code class="fe mv mw mx mm b">GOOS</code>和<code class="fe mv mw mx mm b">GOARCH</code>组合:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="35ca" class="mq lp iq mm b be mr ms l mt mu">$ go tool dist list<br/>aix/ppc64<br/>android/386<br/>android/amd64<br/>android/arm<br/>android/arm64<br/>darwin/amd64<br/>....The list goes on</span></pre><h2 id="a316" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated"><strong class="ak">CGO _启用</strong></h2><p id="fd06" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们还使用了<code class="fe mv mw mx mm b">CGO_ENABLED</code>环境变量。<code class="fe mv mw mx mm b">CGO_ENABLED=1</code>带来更快更小的构建——它允许动态加载主机操作系统的本地库。但是，它依赖于主机操作系统，这是我们希望避免的依赖！否则，如果我们的代码依赖于主机库，我们的代码行为可能会因机器而异。</p><h2 id="8078" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated"><strong class="ak">链接器标志— ldflags </strong></h2><p id="f9c9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们使用名为<code class="fe mv mw mx mm b">ldflags</code> — <code class="fe mv mw mx mm b">ld</code>的标志代表<a class="ae ln" href="https://pkg.go.dev/cmd/link" rel="noopener ugc nofollow" target="_blank">链接器</a> [6】，因此<code class="fe mv mw mx mm b">ldflags</code>代表链接器标志。链接器是一个将编译后的源代码片段“链接”成二进制结果的程序。我们将<code class="fe mv mw mx mm b">extldflags</code>传递给我们的链接器。根据链接工具文档，这些标志被传递给外部链接器。简而言之，我们使用这些标志来指示Go build工具将所有依赖项包含到二进制文件中，而不依赖于运行环境提供的依赖项。我们将标志设置为<code class="fe mv mw mx mm b">-static</code>，表示二进制文件应该包含它的所有依赖项。如果没有指定，我们的二进制文件将被动态链接。出于与<code class="fe mv mw mx mm b">CGO_ENABLED</code>相同的原因，我们想在这里避免它。</p><h1 id="b7ae" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">总结</strong></h1><p id="2f29" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们已经看到了如何从头开始设置基于Cobra的CLI应用程序。我们讨论了跨平台的应用程序属性，比如平台无关的文件系统路径。我们添加了测试，并简要概述了具有不同目标配置的链接器和Go build工具。</p><p id="da42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦掌握了基础知识，为多个目标构建Go应用程序就变得简单而有趣。</p><p id="e8c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章是为了我自己理解和组织我的想法，因为它是关于知识分享的。我希望它对你有帮助</p><p id="cd96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的源代码可以在<a class="ae ln" href="https://github.com/Pavel-Durov/blog/tree/main/src/cross-platform-cli-apps-with-go-and-cobra/examples" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="4f14" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">参考文献</strong></h1><p id="9aa6" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">[1]<a class="ae ln" href="https://en.wikipedia.org/wiki/Command-line_interface" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Command-line_interface</a></p><p id="5205" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[2]<a class="ae ln" href="https://en.wikipedia.org/wiki/Graphical_user_interface" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Graphical_user_interface</a></p><p id="9aad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://cobra.dev/" rel="noopener ugc nofollow" target="_blank">https://cobra.dev/</a></p><p id="0fc9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/spf13/viper" rel="noopener ugc nofollow" target="_blank">https://github.com/spf13/viper</a></p><p id="573e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://en.wikipedia.org/wiki/Cross-platform_software" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cross-platform_software</a></p><p id="533c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://pkg.go.dev/cmd/link" rel="noopener ugc nofollow" target="_blank">https://pkg.go.dev/cmd/link</a></p></div></div>    
</body>
</html>