<html>
<head>
<title>Controlling Data Streams in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以角度控制数据流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/controlling-data-streams-in-angular-3e43484bedb3?source=collection_archive---------15-----------------------#2020-02-17">https://betterprogramming.pub/controlling-data-streams-in-angular-3e43484bedb3?source=collection_archive---------15-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="116a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在大型角度应用程序中的工作模式和查看模式之间切换</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f7b335bf07bc9561dee8175278828c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7vIRTI2h62CZKXVM5hmtwg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格雷格·罗森克在<a class="ae ky" href="https://unsplash.com/s/photos/streams?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在Angular中开发前端应用程序，那么你肯定会以某种方式使用<a class="ae ky" href="https://angular.io/guide/rx-library" rel="noopener ugc nofollow" target="_blank"> RxJS </a>。在这篇文章中，我想谈谈我在开发严重依赖RxJS的大规模应用程序时遇到的一个问题，以及我解决这个问题的步骤。</p><p id="e066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需求很简单:允许应用程序在两种模式下工作:工作模式和查看模式。当处于工作模式时，组件之间的每种通信都应该发生(相应地处理每个键盘和鼠标事件)，并且应该触发适当的动作。在查看模式下，应该禁用事件处理程序，这样就不会触发任何键盘或鼠标事件(否则感兴趣的订阅者应该无法听到)。最后，允许从一种模式切换到另一种模式的按钮也应该是可用的。</p><p id="a690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我希望对这个场景提供一个简单的解释，这个解决方案初看起来可能非常简单。当单击切换模式按钮(工作模式)时，事件发射器的每个订阅者都应该取消订阅，当切换到查看模式时，每个旧订阅者都应该再次重新订阅以侦听鼠标和键盘事件。</p><p id="ac13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象这样一个场景，您有多个对键盘或鼠标事件感兴趣的组件。当更多不同的事件发生时，比如HTTP调用、套接字订阅等等，会发生什么呢？将上述解决方案应用于每个用例是不合适的，也是不可扩展的。</p><p id="71d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要的是一个集中的地方，我们可以通过切换它发出的值来控制数据流。每个感兴趣的组件都可以订阅受控数据流，并且只在数据流活动时接收值。另一方面，包含模式切换按钮的组件将启用或禁用受控数据流。</p><p id="6fa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用Angular编写一个简单的应用程序来展示这个场景。为了集中数据流控制，我们创建了一个可以注入到任何感兴趣的组件中的服务。出于演示的目的，我只使用了一个切换工作模式并订阅数据流的组件。让我们来看看这个应用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="eba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要焦点是集中服务DataService，它提供对控制器数据流的访问。有两个主要组件，一个<code class="fe lx ly lz ma b">toggleObservable</code>和一个<code class="fe lx ly lz ma b">dataObservable</code>。</p><p id="1ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lx ly lz ma b">toggleObservable</code>负责模式切换按钮事件流。它还控制如何将数据流中的值发送给感兴趣的订阅者。</p><p id="dde0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe lx ly lz ma b">dataObservable</code>负责由鼠标和键盘事件产生的数据流。</p><p id="03e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的主要代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb lw l"/></div></figure><p id="757f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将受到模式切换影响的每个组件都将订阅由函数<code class="fe lx ly lz ma b">getControllableDataStream()</code>返回的可观察值。它从<code class="fe lx ly lz ma b">toggleObservable</code>发出的值开始(可选地，它从<code class="fe lx ly lz ma b">true</code>值开始)。只有当发出的值是<code class="fe lx ly lz ma b">true</code>时，它才能通过使用<code class="fe lx ly lz ma b"><a class="ae ky" href="https://rxjs-dev.firebaseapp.com/api/operators/concatMap" rel="noopener ugc nofollow" target="_blank">concatMap</a></code>将发出的布尔值映射到<code class="fe lx ly lz ma b">dataObservable</code>来返回由<code class="fe lx ly lz ma b">dataObservable</code>发出的值。</p><p id="98f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们还没有完成，因为对于由<code class="fe lx ly lz ma b">toggleObservable</code>发出的每个后续值，订阅者仍然会收到数据，即使它是关闭的(应用程序处于预览模式)。我们最终需要的是允许<code class="fe lx ly lz ma b">dataObservable</code>发出所有值，直到<code class="fe lx ly lz ma b">toggleObservable</code>发出一个<code class="fe lx ly lz ma b">false</code>值。我们通过使用<code class="fe lx ly lz ma b"><a class="ae ky" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/takeuntil" rel="noopener ugc nofollow" target="_blank">takeUntil</a></code>操作符来做到这一点，当下一次<code class="fe lx ly lz ma b">toggleObservable</code>发射发生时，该操作符将取消对<code class="fe lx ly lz ma b">dataObservable</code>的订阅。</p><p id="8267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟在<code class="fe lx ly lz ma b">AppComponent</code>中给出，每次模式切换(点击按钮)后都会发出数值，接收到的数据记录在控制台中。您可以通过几次点击<em class="mc">开/关</em>进行试验，并在控制台中查看结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb lw l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="d6e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能帮助你在处理不同的基于RxJS的应用时选择正确的方法。<br/> <br/>保重。</p></div></div>    
</body>
</html>