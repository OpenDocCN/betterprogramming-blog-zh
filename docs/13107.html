<html>
<head>
<title>SwiftUI View is also a View Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI视图也是一个视图模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-view-is-also-a-view-model-7b434316b5fa?source=collection_archive---------5-----------------------#2022-07-29">https://betterprogramming.pub/swiftui-view-is-also-a-view-model-7b434316b5fa?source=collection_archive---------5-----------------------#2022-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d8aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">与WPF框架的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ca6a0dc9e78a07f9dc70f14f156ae96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXn7Aoz5Qz3bhkxmLQ3BqA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@lili_popper?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Lili Popper </a>在<a class="ae ky" href="https://unsplash.com/s/photos/path?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b23a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将介绍SwiftUI视图不仅是一个视图，还是一个视图模型。我们将它与WPF框架进行比较，看看SwiftUI如何在视图中内置对ViewModel的支持。这意味着在大多数情况下，您不需要为每个屏幕创建一个额外的视图模型层。</p><h1 id="d192" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Windows演示基础</h1><p id="1729" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">很久以前，当我还是一名. NET开发人员时，在一个遥远的星系中，我参与了几个WPF (Windows演示基础)项目。WPF用于构建Windows应用程序，它是Windows窗体的继承者。</p><p id="f0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WPF使用XAML (UI语言)来构建应用程序的用户界面。XAML看起来类似于HTML和XML，但也能够引用C#甚至VB.NET文件中的类。绑定内置于XAML文件中，这意味着XAML的文本框可以绑定到C#视图模型。当用户在文本框中键入文本时，它会自动填充视图模型的属性。</p><p id="4b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">XAML用户界面代码的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="915c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文本框包含<code class="fe mu mv mw mx b">BindingContext</code>，它定义了绑定的上下文。文本框绑定被设置为<code class="fe mu mv mw mx b">CustomerViewModel</code>。TextBox的Text属性绑定到<code class="fe mu mv mw mx b">CustomerViewModel</code>的Name属性。</p><p id="7880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">CustomerViewModel</code>如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><blockquote class="my mz na"><p id="f2ce" class="kz la nb lb b lc ld ju le lf lg jx lh nc lj lk ll nd ln lo lp ne lr ls lt lu im bi translated">以上代码用于演示目的。但是工作的XAML和C#代码与上面提到的非常相似。</p></blockquote><p id="d496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当用户在XAML声明的文本框中键入内容时，由于XAML的绑定特性，CustomerViewModel <code class="fe mu mv mw mx b">Name</code>属性会自动填充。现在，让我们在SwiftUI应用程序中实现相同的场景。</p><p id="0f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI中，实现非常简单，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要像<code class="fe mu mv mw mx b">CustomerViewModel</code>这样单独的视图模型来绑定TextField的值。SwiftUI视图已经支持数据绑定特性，如<code class="fe mu mv mw mx b">@State</code>、<code class="fe mu mv mw mx b">@Binding</code>等。这意味着SwiftUI视图不仅是一个视图，还是一个视图模型。尽管您可以以视图模型的形式添加另一个抽象层，但在大多数情况下并不需要。</p><p id="2f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是WPF和SwiftUI的对比:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/b42b79df485b4010d9961bfa2a09cd97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6or5qSg8sTYuNR_WLjhm8Q.png"/></div></div></figure><p id="3e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本的客户端验证，如必填和匹配字段，可以在您的视图中执行。对于更复杂的客户端验证，我建议实现某种类型的<code class="fe mu mv mw mx b">RulesEngine.</code></p><p id="51ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种体系结构，视图充当视图和视图模型。该模型成为业务层(特别是对于没有服务器组件的应用程序)。这意味着如果您创建一个<code class="fe mu mv mw mx b">NetworkService</code>，它可以直接从视图中被调用，这也是一个视图模型。我个人创建一个聚合根模型对象，然后从那里调用web服务层。这允许我在我的聚合根模型或者它托管的模型中处理业务逻辑。下面你可以找到来自苹果<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app" rel="noopener ugc nofollow" target="_blank">文章</a>的截图，也证实了在构建SwiftUI应用时，大多数场景下不需要视图模型。这是因为数据绑定特性被嵌入到视图中，而视图也是一个视图模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/34772b2d89c9b685a7e091f52099c22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6tpOmcXHGtfz3Vjto28Fg.png"/></div></div></figure><p id="ec02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使你阅读苹果文档或观看WWDC视频，你也永远不会听到MVVM这个术语，或者你永远不会看到苹果工程师使用另一个抽象层。他们通常会实现StoreManagers或StoreService，然后直接从视图(ViewModel)中调用它，并填充全局状态，这样他们就可以维护单一的真实来源。</p><p id="e0c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说了这么多，还是有一些情况需要更扁平的模型。一个很好的例子是，如果你使用MKLocalSearch，它会返回<code class="fe mu mv mw mx b">MKPlacemark</code>。您可能希望向视图公开一个更精简的对象，而不是<code class="fe mu mv mw mx b">MKPlacemark</code>实例。</p><p id="22ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在ViewModel中遇到的最大问题之一是跟踪<code class="fe mu mv mw mx b">EnvironmentObject</code>的变化。是的，您可以将<code class="fe mu mv mw mx b">EnvironmentObject</code>传递给ViewModel，或者您可以使用依赖注入框架来注入它，但是为什么要让事情变得如此复杂呢？为什么不在视图(ViewModel)中使用<code class="fe mu mv mw mx b">EnvironmentObject</code>,就像它应该被使用的那样？</p><blockquote class="my mz na"><p id="9aeb" class="kz la nb lb b lc ld ju le lf lg jx lh nc lj lk ll nd ln lo lp ne lr ls lt lu im bi translated">没有一种架构能满足所有需求。下次编写SwiftUI应用程序时，考虑一下为每个屏幕添加一个ViewModel。它会给你带来好处还是会成为你申请的障碍。</p></blockquote><h1 id="6274" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">资源</h1><ol class=""><li id="799c" class="nh ni it lb b lc mn lf mo li nj lm nk lq nl lu nm nn no np bi translated"><a class="ae ky" href="https://azamsharp.com/2022/07/17/2022-swiftui-and-mvvm.html" rel="noopener ugc nofollow" target="_blank">我错了！MVVM不是构建SwiftUI应用的好选择</a></li><li id="7760" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://youtu.be/LVx93PfGjdo" rel="noopener ugc nofollow" target="_blank">停止在SwiftUI中使用MVVM</a></li><li id="814a" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://youtu.be/YOCZuZz4vAw" rel="noopener ugc nofollow" target="_blank">使用状态模式(不使用MVVM)在SwiftUI中使用JSON API</a></li><li id="54fe" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://youtu.be/j2x7GylAnmE" rel="noopener ugc nofollow" target="_blank">客户端服务器SwiftUI App使用状态模式</a></li></ol></div></div>    
</body>
</html>