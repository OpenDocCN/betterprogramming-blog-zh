<html>
<head>
<title>Implementing an ALU in TypeScript’s Type System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript的类型系统中实现ALU</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-an-alu-in-typescripts-type-system-18d560706e2c?source=collection_archive---------11-----------------------#2022-11-01">https://betterprogramming.pub/implementing-an-alu-in-typescripts-type-system-18d560706e2c?source=collection_archive---------11-----------------------#2022-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dcce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用您自己的类型计算斐波纳契数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/5821d668f5621a7a667d1db48147cb92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Cle7j9G9gbsd8rv4izJOKw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">稳定扩散生成</p></figure><p id="2bdb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们给出了一个<a class="ae ln" href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit" rel="noopener ugc nofollow" target="_blank"> ALU </a>的示例实现。我们将实现的一些操作是<code class="fe lo lp lq lr b">bitwise</code>操作，如<code class="fe lo lp lq lr b">shifts </code>和<code class="fe lo lp lq lr b">arithmetic</code>操作，如<code class="fe lo lp lq lr b">addition</code>和<code class="fe lo lp lq lr b">subtraction</code>。</p><p id="ae8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们将看到如何使用这些操作来实现一个可以计算<code class="fe lo lp lq lr b">fibonacci</code>数的类型。</p><p id="90f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用的所有构造都是ts类型，所有计算都是在构建时完成的。没有JS运行我们的类型。我们依靠打字系统来做计算。</p><p id="47ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记住这一点，让我们开始吧。</p><h1 id="421e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基本类型</h1><p id="64c3" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们需要一种方法来表示一点。为此，我们从表示一个位可能具有的两种状态(0或1)开始。</p><p id="9ece" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步是将一个位定义为两个状态的联合类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">位的类型声明</p></figure><p id="433e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这个，我们可以继续定义一个字节。为此，我们将使用<a class="ae ln" href="https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types" rel="noopener ugc nofollow" target="_blank">元组</a>。</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="cff1" class="mv lt iq lr b gy mw mx l my mz">type Byte = [Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit];</span></pre><p id="e99c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是TS类型系统中一个字节的一个非常简单的表示，但是它足以开始我们的ALU操作。</p><p id="15f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以定义一些可以使用的助手类型。</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="534d" class="mv lt iq lr b gy mw mx l my mz">type ZERO_BYTE = [Zero, Zero, Zero, Zero, Zero, Zero, Zero, Zero]<br/>type ONE_BYTE  = [Zero, Zero, Zero, Zero, Zero, Zero, Zero, One]</span></pre><h1 id="59ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">位运算</h1><p id="e8cf" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">有了bit的类型，让我们看看如何实现bit的<code class="fe lo lp lq lr b">not</code>、<code class="fe lo lp lq lr b">and</code>、<code class="fe lo lp lq lr b">or</code>和<code class="fe lo lp lq lr b">xor</code>。</p><p id="6cec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此将大量使用<a class="ae ln" href="https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints" rel="noopener ugc nofollow" target="_blank">约束泛型</a>和<a class="ae ln" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">条件类型</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">位运算</p></figure><p id="9999" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一下实现细节:</p><p id="edc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">比特否定是最简单的一种。我们约束<code class="fe lo lp lq lr b">T</code>为<code class="fe lo lp lq lr b">Bit</code>，然后检查它是否为<code class="fe lo lp lq lr b">Zero</code>。如果是这种情况，我们将类型定义为<code class="fe lo lp lq lr b">One</code>。否则，我们将类型定义为<code class="fe lo lp lq lr b">Zero</code>。</p><p id="aeab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着我们现在可以像这样使用<code class="fe lo lp lq lr b">BitNot</code>。</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="2d66" class="mv lt iq lr b gy mw mx l my mz">type OneNegated = BitNot&lt;One&gt;</span></pre><p id="0641" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而那个类型实际上会是<code class="fe lo lp lq lr b">Zero</code>。</p><p id="2510" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们做一些类似于<code class="fe lo lp lq lr b">BitAnd</code>的事情，但是这一次我们需要定义它有两个通用类型:<code class="fe lo lp lq lr b">LHS</code>和<code class="fe lo lp lq lr b">RHS</code>。我们使用条件类型来实现类型系统内部的分支。定义<code class="fe lo lp lq lr b">AND</code>最简单的方法是检查它们是否都扩展了<code class="fe lo lp lq lr b">One</code>并在那种情况下返回<code class="fe lo lp lq lr b">One</code>。</p><p id="e72a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这与下面的代码非常相似:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="a6ca" class="mv lt iq lr b gy mw mx l my mz">if (LSH === One) {<br/> if (RHS === One) {<br/>   return One <br/> } else {<br/>   return Zero<br/> }<br/>} else {<br/> return Zero<br/>}</span></pre><p id="e620" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于条件类型的性质，所有分支都必须解析为一种类型。这就是我们有<code class="fe lo lp lq lr b">Zero</code>出现两次的原因。这使得这个实现更加冗长。</p><p id="4697" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们为<code class="fe lo lp lq lr b">BitOr</code>做类似的事情。</p><p id="b886" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">BitXor</code>有点冗长，因为没有办法简化评估，所以我们必须考虑所有四种可能性。</p><h1 id="cc94" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">字节操作</h1><p id="3546" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们现在已经拥有了实现字节操作所需的一切。</p><p id="0a6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从现在开始，我们将严重依赖<a class="ae ln" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types" rel="noopener ugc nofollow" target="_blank">在条件类型</a>内进行推断。我们需要一种方法来遍历元组并将操作应用到每个组件。实现这一点的一种方法是对条件类型使用泛型，并只推断元组的一部分。我们可以做类似的事情:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="6f07" class="mv lt iq lr b gy mw mx l my mz">type Walkable&lt;T extends Byte&gt; = T extends [infer U extends Bit, ...infer R extends Bit[]] ? U : []</span></pre><p id="6ea2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是很难一次完成的，所以让我们看一下。</p><p id="5534" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们正在指定<code class="fe lo lp lq lr b">T extends Byte</code>。这意味着它是由8个<code class="fe lo lp lq lr b">Bit</code>组成的元组。</p><p id="9d49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步是使用conditional with <code class="fe lo lp lq lr b">extends</code>来拆分元组，并能够引用元组的头。在本文中，<code class="fe lo lp lq lr b">the head of the tuple</code>指的是<code class="fe lo lp lq lr b">Byte</code>中的第一个<code class="fe lo lp lq lr b">Bit</code>。</p><p id="ac85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以在条件真分支上引用类型<code class="fe lo lp lq lr b">U</code>。这同样适用于<code class="fe lo lp lq lr b">R</code>，它是一个元组类型，包含所有剩余的<code class="fe lo lp lq lr b">Bits</code>。</p><p id="630a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以实现的最简单的操作是<code class="fe lo lp lq lr b">ShiftLeft</code>和<code class="fe lo lp lq lr b">ShiftRight</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">左移和右移</p></figure><p id="1e74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们仔细看看<code class="fe lo lp lq lr b">ShiftLeft</code>是怎么回事。我们正在为最左边的<code class="fe lo lp lq lr b">Bit</code>推断类型，然后我们创建一个新的类型，忽略它，解包<code class="fe lo lp lq lr b">R</code>并添加<code class="fe lo lp lq lr b">Zero</code>。这实质上是将最低最高7位向左移动。</p><p id="5654" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以这样使用它:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="2f22" class="mv lt iq lr b gy mw mx l my mz">ShiftLeft&lt;[Zero, Zero, Zero, One, Zero, Zero, Zero, One]&gt;</span></pre><p id="a23b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者使用我们之前定义的助手:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="e3fd" class="mv lt iq lr b gy mw mx l my mz">ShiftLeft&lt;ONE_BYTE&gt;</span></pre><p id="ac7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那将会是:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="b693" class="mv lt iq lr b gy mw mx l my mz">[Zero, Zero, One, Zero, Zero, Zero, One, Zero]</span></pre><p id="a8ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似的事情也发生在<code class="fe lo lp lq lr b">ShiftRight</code>身上。</p><h1 id="dd8b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">字节非和异或</h1><p id="43df" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">为字节实现<code class="fe lo lp lq lr b">not</code>和<code class="fe lo lp lq lr b">xor</code>使用了类似的技术，但是有点复杂。</p><p id="c5de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之所以更多地涉及到<code class="fe lo lp lq lr b">not</code>和<code class="fe lo lp lq lr b">xor</code>，与一个字节的<code class="fe lo lp lq lr b">head</code>和<code class="fe lo lp lq lr b">tail</code>拆分后，我们需要对<code class="fe lo lp lq lr b">tail</code>再次应用同样的规则有关。问题是<code class="fe lo lp lq lr b">tail</code>不再是<code class="fe lo lp lq lr b">Byte</code>，因为它是一个只有<code class="fe lo lp lq lr b">7</code>元素的<code class="fe lo lp lq lr b">tuple</code>。解决这个问题的方法是使用另一个允许任何<code class="fe lo lp lq lr b">Bit[]</code>的<code class="fe lo lp lq lr b">type</code>定义。</p><p id="b15f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是<code class="fe lo lp lq lr b">Not</code>的一个小实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">ByteNot实现</p></figure><p id="2861" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里发生的是，我们使用<code class="fe lo lp lq lr b">BitNot</code>来翻转磁头。然后，我们再次应用该类型，但这次是针对字节中的剩余位。这实际上是尾递归的一种形式，我们将在未来的操作中更多地使用它。</p><p id="fb95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以这样使用它:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="15a4" class="mv lt iq lr b gy mw mx l my mz">type Flipped = ByteNote&lt;[Zero, One, One, Zero, One, One, One, Zero]&gt;</span></pre><p id="6612" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而<code class="fe lo lp lq lr b">Flipped</code>实际上将是:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="aa81" class="mv lt iq lr b gy mw mx l my mz">[One, Zero, Zero, One, Zero, Zero, Zero, One]</span></pre><p id="1c47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">XOR有点复杂，因为我们需要2个<code class="fe lo lp lq lr b">Byte</code>来创建运算。但是我们可以使用和以前一样的概念:</p><ul class=""><li id="c1ff" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">受约束的泛型</li><li id="92a2" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">条件类型</li><li id="7c66" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">使用推断和尾部递归遍历字节</li></ul><p id="e4c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们有两个操作符，并且我们需要条件类型来推断<code class="fe lo lp lq lr b">Byte</code>的<code class="fe lo lp lq lr b">head</code>和<code class="fe lo lp lq lr b">tail</code>，所以代码更难阅读。但是使用的技术是一样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">异或运算</p></figure><p id="d5a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于实现需要注意的一点是，我们通过返回一个空数组<code class="fe lo lp lq lr b">[]</code>来停止递归。这样做的原因是，如果在<code class="fe lo lp lq lr b">extends</code>子句中<code class="fe lo lp lq lr b">TS</code>不能再进行推理，它将选择另一条路线。在这种情况下，使用<code class="fe lo lp lq lr b">empty tuple</code>作为类型。</p><h1 id="823e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">算术运算</h1><p id="3141" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们现在已经具备了开始实现算术运算的所有条件。我们的目标是能够得到<code class="fe lo lp lq lr b">add</code>和<code class="fe lo lp lq lr b">subtract</code>字节。</p><h2 id="dc34" class="mv lt iq bd lu no np dn ly nq nr dp mc la ns nt me le nu nv mg li nw nx mi ny bi translated">增量</h2><p id="757a" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们首先可以建立的是<code class="fe lo lp lq lr b">increment</code>的能力。这意味着我们想要将<code class="fe lo lp lq lr b">1</code>添加到<code class="fe lo lp lq lr b">Byte</code>中。</p><p id="c54f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在实现这些操作时，您会经常看到这种情况:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="61fc" class="mv lt iq lr b gy mw mx l my mz">T extends [...infer U extends Bit[], infer R extends Bit]</span></pre><p id="c42e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这一次，我们需要从尾部开始处理<code class="fe lo lp lq lr b">Byte</code>，所以我们将使用相同的<code class="fe lo lp lq lr b">infer</code>技术，但是我们将捕获最后一个<code class="fe lo lp lq lr b">Bit</code>，然后对剩余的位使用递归。</p><p id="f51c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要检查<code class="fe lo lp lq lr b">R</code>是否有值<code class="fe lo lp lq lr b">One</code>。</p><p id="7cd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为什么这很重要？</p><p id="de45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<code class="fe lo lp lq lr b">R</code>是<code class="fe lo lp lq lr b">Zero</code>，那么我们把它改成<code class="fe lo lp lq lr b">One</code>，打开<code class="fe lo lp lq lr b">U</code>，我们就完成了。另一方面，如果<code class="fe lo lp lq lr b">R</code>是<code class="fe lo lp lq lr b">One</code>，那么我们需要将其改为<code class="fe lo lp lq lr b">Zero</code>，然后<code class="fe lo lp lq lr b">continue</code>将<code class="fe lo lp lq lr b">One</code>添加到下一个<code class="fe lo lp lq lr b">Bit</code>。这是递归部分。</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="95e2" class="mv lt iq lr b gy mw mx l my mz">T extends [...infer U extends Bit[], infer R extends Bit] ? R extends One ? [...PartialAddOne&lt;U&gt;, Zero] : [...U, One] : []</span></pre><p id="067b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">增量</p></figure><p id="eb3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以这样使用它:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="40b3" class="mv lt iq lr b gy mw mx l my mz">type ONE = AddOne&lt;[Zero, Zero, Zero, Zero, Zero, Zero, Zero, Zero]&gt;</span></pre><p id="4c55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果将是:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="92c6" class="mv lt iq lr b gy mw mx l my mz">[Zero, Zero, Zero, Zero, Zero, Zero, Zero, One]</span></pre><p id="2c53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，我们最后得到的数字是它的<code class="fe lo lp lq lr b">Byte</code>表示，而不是我们习惯意义上的数字。</p><p id="5e54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以生成一个正数(实际上，我们可以生成任何<code class="fe lo lp lq lr b">Byte</code>表示，因为它是否为正数是一个语义问题)。</p><p id="d774" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有这些现在都是有效的操作:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="3b00" class="mv lt iq lr b gy mw mx l my mz">type ZERO = [Zero, Zero, Zero, Zero, Zero, Zero, Zero, Zero]</span><span id="3362" class="mv lt iq lr b gy nz mx l my mz">type ONE = AddOne&lt;ZERO&gt;<br/>type TWO = AddOne&lt;ONE&gt;<br/>type THREE = AddOne&lt;AddOne<br/>type FOUR = AddOne&lt;THREE&gt;</span></pre><h2 id="8fcb" class="mv lt iq bd lu no np dn ly nq nr dp mc la ns nt me le nu nv mg li nw nx mi ny bi translated">用进位相加</h2><p id="fdac" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">在我们开始实现2个<code class="fe lo lp lq lr b">Bytes</code>之间的完整<code class="fe lo lp lq lr b">add</code>之前，我们需要能够保持<code class="fe lo lp lq lr b">bits</code>之间的<code class="fe lo lp lq lr b">carry</code>加法。</p><p id="fec6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">alu通常必须携带可用于此目的的标志(<code class="fe lo lp lq lr b">CF</code>)。但是从这个角度来看，<code class="fe lo lp lq lr b">TS</code>并没有全局状态。所以我们不能把它存放在某个地方，以后再用。我们需要总是能够传递它。</p><p id="e202" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们创建了一些类型来帮助我们:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="9438" class="mv lt iq lr b gy mw mx l my mz">type CarryFlag = Bit;<br/>type BitWithCarry = {<br/>    cf: CarryFlag<br/>    value: Bit<br/>}</span></pre><p id="c435" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以在需要的时候参考<code class="fe lo lp lq lr b">BitWithCarry</code>旗。</p><p id="662f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就像我们实现<code class="fe lo lp lq lr b">Bit</code>逻辑操作一样，这样我们可以稍后通过使用<code class="fe lo lp lq lr b">tail recursion</code>在<code class="fe lo lp lq lr b">Byte</code>上使用它们，我们现在将做同样的事情。</p><p id="2e10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要实现将2位相加的能力，存储结果<code class="fe lo lp lq lr b">Bit</code>和<code class="fe lo lp lq lr b">carry value</code>的值。</p><p id="55cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以查看该操作的真值表来指导我们的实现:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="8629" class="mv lt iq lr b gy mw mx l my mz">+------+------+------+------+------+<br/>| Bit1 | Bit2 |  CF  | BitR |  CR  |<br/>+------+------+------+------+------+<br/>| 1    | 1    | 1    | 1    | 1    |<br/>+------+------+------+------+------+<br/>| 1    | 1    | 0    | 0    | 1    |<br/>+------+------+------+------+------+<br/>| 1    | 0    | 1    | 0    | 1    |<br/>+------+------+------+------+------+<br/>| 1    | 0    | 0    | 1    | 0    |<br/>+------+------+------+------+------+<br/>| 0    | 1    | 1    | 0    | 1    |<br/>+------+------+------+------+------+<br/>| 0    | 1    | 0    | 1    | 0    |<br/>+------+------+------+------+------+<br/>| 0    | 0    | 1    | 1    | 0    |<br/>+------+------+------+------+------+<br/>| 0    | 0    | 0    | 0    | 0    |<br/>+------+------+------+------+------+</span></pre><p id="94d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在需要在<code class="fe lo lp lq lr b">TS</code>中使用条件类型来实现这一点。这是一项艰巨的任务，但我们最终得到了类似的结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="974f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这些，我们可以开始为<code class="fe lo lp lq lr b">bytes</code>实现<code class="fe lo lp lq lr b">add</code>操作。</p><p id="cc5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用与之前相同的技术:</p><ul class=""><li id="26d8" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">推断最后一位</li><li id="ca97" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">在最后一位使用<code class="fe lo lp lq lr b">AddBitsWithCarry</code></li><li id="040b" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">对头位使用辅助类型</li><li id="51f7" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">将<code class="fe lo lp lq lr b">cf</code>的值传递给辅助类型，因为其余的位需要它</li></ul><p id="cf53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们最终会得到类似的结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">ByteAdd实现</p></figure><p id="1700" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要注意的几件事:</p><ul class=""><li id="0acf" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">我们在这里使用了通用参数的默认值<code class="fe lo lp lq lr b">CH extends CarryFlag = Zero</code>。在我们的例子中，这是强制性的，但是它确实使<code class="fe lo lp lq lr b">PartialAdd</code>更加灵活。</li><li id="eb00" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">当递归引用类型时，我们调用<code class="fe lo lp lq lr b">AddBitsWithCarry</code>两次。首先，获取<code class="fe lo lp lq lr b">value</code>，然后获取<code class="fe lo lp lq lr b">cf</code>，即使我们传递的是相同的参数。这也是因为在<code class="fe lo lp lq lr b">TS</code>类型系统中没有全局状态。</li></ul><h2 id="090e" class="mv lt iq bd lu no np dn ly nq nr dp mc la ns nt me le nu nv mg li nw nx mi ny bi translated">减法和乘法</h2><p id="8471" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">现在我们已经完成了基础工作，实现其他操作就容易多了。</p><p id="346f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于减法，我们将使用<a class="ae ln" href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="noopener ugc nofollow" target="_blank"> 2的补码</a>。简而言之，我们需要否定<code class="fe lo lp lq lr b">Byte</code>然后再否定<code class="fe lo lp lq lr b">add</code>一个。对于我们拥有的所有类型，这非常容易做到:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="64f4" class="mv lt iq lr b gy mw mx l my mz">type Byte2Complement&lt;T extends Byte&gt; = AddOne&lt;ByteNot&lt;T&gt;&gt;</span></pre><p id="4ecf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在减法变得非常容易。我们需要计算<code class="fe lo lp lq lr b">RHS</code>的二进制补码，然后将其加到<code class="fe lo lp lq lr b">LHS</code>中:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="ba1b" class="mv lt iq lr b gy mw mx l my mz">type Subtract&lt;LHS extends Byte, RHS extends Byte&gt; = Add&lt;LHS, Byte2Complement&lt;RHS&gt;&gt;</span></pre><p id="a1de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一个方便的操作，我们可以实现<code class="fe lo lp lq lr b">decrement</code>:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="f772" class="mv lt iq lr b gy mw mx l my mz">type SubtractOne&lt;LHS extends Byte&gt; = Subtract&lt;LHS, ONE_BYTE&gt;</span></pre><p id="59f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以着手实现<code class="fe lo lp lq lr b">multiply</code>了。我们需要把乘法看作是重复的<code class="fe lo lp lq lr b">addition</code>。我们将再次执行<code class="fe lo lp lq lr b">recursion</code>，并递减<code class="fe lo lp lq lr b">LHS</code>，直到它达到<code class="fe lo lp lq lr b">One</code>。</p><p id="37ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到达<code class="fe lo lp lq lr b">One</code>是这个递归的停止条件。</p><p id="7358" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要迎合<code class="fe lo lp lq lr b">LHS</code>实际上是<code class="fe lo lp lq lr b">Zero</code>的情况，因此我们有一个特殊的条件。最后，我们以这个结束:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="aefd" class="mv lt iq lr b gy mw mx l my mz">type Mul&lt;<br/>  LHS extends Byte,<br/>  RHS extends Byte,<br/>  Result extends Byte = RHS<br/>&gt; = ONE_BYTE extends LHS<br/>  ? Result<br/>  : ZERO_BYTE extends LHS<br/>  ? ZERO_BYTE<br/>  : Mul&lt;SubtractOne&lt;LHS&gt;, RHS, Add&lt;Result, RHS&gt;&gt;;</span></pre><p id="9f97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意<code class="fe lo lp lq lr b">Result</code>如何默认为<code class="fe lo lp lq lr b">RHS</code>。这就是为什么我们涵盖了由于递归而停止和<code class="fe lo lp lq lr b">LHS</code>实际上是<code class="fe lo lp lq lr b">One</code>的两种情况。</p><p id="1bba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以这样使用它:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="5c23" class="mv lt iq lr b gy mw mx l my mz">Mul&lt;ONE_BYTE, ZERO_BYTE&gt;<br/>Mul&lt;[Zero, Zero, Zero, Zero, Zero, Zero, One, Zero], [Zero, Zero, Zero, Zero, Zero, Zero, One, Zero]&gt;</span></pre><p id="3799" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第二种情况下，结果会是:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="f298" class="mv lt iq lr b gy mw mx l my mz">[Zero, Zero, Zero, Zero, Zero, One, Zero, Zero]</span></pre><h1 id="6786" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">比较实现</h1><p id="09cc" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">如果没有一些比较实现，我们的ALU将是不完整的(实际上，我们也可以使用一些除法，但我们将在稍后进行)。</p><p id="90a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:所有的比较操作都是以无符号的方式完成的。</p><h2 id="4b7c" class="mv lt iq bd lu no np dn ly nq nr dp mc la ns nt me le nu nv mg li nw nx mi ny bi translated">情商</h2><p id="a4ad" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们可以实现的第一个比较，也是最简单的，是<code class="fe lo lp lq lr b">EQ</code>。我们想看看2 <code class="fe lo lp lq lr b">Bytes</code>是否相等。我们可以通过从另一个中减去一个<code class="fe lo lp lq lr b">Byte</code>并检查它是否为零来轻松做到这一点。在我们的语言中，我们可以这样写:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="45be" class="mv lt iq lr b gy mw mx l my mz">type EQ&lt;LHS extends Byte, RHS extends Byte&gt; = ZERO_BYTE extends ByteXOR&lt;LHS, RHS&gt; ? true : false</span></pre><h2 id="5bcf" class="mv lt iq bd lu no np dn ly nq nr dp mc la ns nt me le nu nv mg li nw nx mi ny bi translated">LT(小于)</h2><p id="7c60" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">为了实现<code class="fe lo lp lq lr b">LT</code>，我们首先需要一些帮助。实现这一点的主要思想是从左到右(从最高有效位到最低有效位)遍历字节，并决定不同的第一位。</p><p id="8ca3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当位相同时，当前操作为<code class="fe lo lp lq lr b">undecided</code>。这意味着我们需要移动到下一对。</p><p id="22bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了帮助完成这一步，将创建一个助手类型，它将返回<code class="fe lo lp lq lr b">true</code>、<code class="fe lo lp lq lr b">false</code>或<code class="fe lo lp lq lr b">undecided</code>。这将对以后的打字有很大帮助。现在，让我们来看看实际情况:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="ae6d" class="mv lt iq lr b gy mw mx l my mz">type BitLTB&lt;LHS extends Bit, RHS extends Bit&gt; = Zero extends LHS<br/>  ? One extends RHS<br/>    ? true<br/>    : "undecided"<br/>  : One extends RHS<br/>  ? "undecided"<br/>  : false;</span></pre><p id="b33e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以开始完整的实现了。想法和以前一样:</p><ul class=""><li id="f695" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">从两个操作数中推断头部和尾部</li><li id="4580" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">使用<code class="fe lo lp lq lr b">BitLTB</code>来看看我们是否可以调用，然后我们是否可以返回那个值</li><li id="e96f" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">如果值为<code class="fe lo lp lq lr b">undecided</code>，则转到下一位</li></ul><p id="704a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">和以前一样，实现有点难以理解:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">LT实施</p></figure><p id="7a29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，因为我们没有全局状态，所以我们需要多次调用<code class="fe lo lp lq lr b">BitLTB</code>。如果我们检查一下<code class="fe lo lp lq lr b">boolean extends BitLTB</code>，我们可能会让这个更短一点。</p><p id="e14f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以这样使用它:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="277e" class="mv lt iq lr b gy mw mx l my mz">LT&lt;ZERO_BYTE, ONE_BYTE&gt; // will result in true<br/>LT&lt;ONE_BYTE, ZERO_BYTE&gt; // will result in false</span></pre><p id="b84f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了<code class="fe lo lp lq lr b">LT</code>的实现，剩下的比较操作就很容易实现了:</p><h2 id="3a21" class="mv lt iq bd lu no np dn ly nq nr dp mc la ns nt me le nu nv mg li nw nx mi ny bi translated">长期演进</h2><p id="7eb7" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">不外乎<code class="fe lo lp lq lr b">LTE</code>或者<code class="fe lo lp lq lr b">EQ</code></p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="c39b" class="mv lt iq lr b gy mw mx l my mz">type LTE&lt;LHS extends Byte, RHS extends Byte&gt; = true extends LT&lt;LHS, RHS&gt; ? true : EQ&lt;LHS, RHS&gt;</span></pre><h2 id="8d9c" class="mv lt iq bd lu no np dn ly nq nr dp mc la ns nt me le nu nv mg li nw nx mi ny bi translated">大型旅行车</h2><p id="f102" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">仅仅是<code class="fe lo lp lq lr b">LT</code>，但是交换了操作数。</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="7f6a" class="mv lt iq lr b gy mw mx l my mz">type GT&lt;LHS extends Byte, RHS extends Byte&gt; = LT&lt;RHS, LHS&gt;</span></pre><h2 id="6c2a" class="mv lt iq bd lu no np dn ly nq nr dp mc la ns nt me le nu nv mg li nw nx mi ny bi translated">GTE</h2><p id="1d61" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">同样的，但是有了<code class="fe lo lp lq lr b">LTE</code>的帮助。</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="f501" class="mv lt iq lr b gy mw mx l my mz">type GTE&lt;LHS extends Byte, RHS extends Byte&gt; = LTE&lt;RHS, LHS&gt;</span></pre><h1 id="efec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">分开</h1><p id="d05d" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们要实现的最后一个操作是带余数的除法。</p><p id="88f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用<code class="fe lo lp lq lr b">LT</code>和<code class="fe lo lp lq lr b">Subtraction</code>来完成这个任务。我们将返回一个有两个数量的类型:</p><ul class=""><li id="67b0" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">商</li><li id="0f78" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">剩余物</li></ul><p id="78f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们确实需要考虑<code class="fe lo lp lq lr b">division by zero</code>。因此，我们将对后续的<code class="fe lo lp lq lr b">subtraction</code>使用内部类型，而对<code class="fe lo lp lq lr b">zero</code>检查使用主类型。我们最终会得到这样的结果:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="b257" class="mv lt iq lr b gy mw mx l my mz">type DivInternal&lt;LHS extends Byte, RHS extends Byte, Q extends Byte = ZERO_BYTE&gt; = true extends LT&lt;LHS, RHS&gt; ? {<br/>    q: Q,<br/>    r: LHS<br/>} : DivInternal&lt;Subtract&lt;LHS, RHS&gt;, RHS, AddOne&lt;Q&gt;&gt;</span><span id="a6c1" class="mv lt iq lr b gy nz mx l my mz">type Div&lt;LHS extends Byte, RHS extends Byte&gt; = ZERO_BYTE extends RHS ? "Division by 0" : DivInternal&lt;LHS, RHS&gt;</span></pre><p id="30a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">主<code class="fe lo lp lq lr b">Div</code>类型检查<code class="fe lo lp lq lr b">RHS</code>是否为<code class="fe lo lp lq lr b">Zero</code>并返回一个<code class="fe lo lp lq lr b">"Division by 0"</code>字符串。</p><p id="f955" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe lo lp lq lr b">RHS</code>不是<code class="fe lo lp lq lr b">0</code>的情况下，我们遵从<code class="fe lo lp lq lr b">DivInternal</code>。它从<code class="fe lo lp lq lr b">LHS</code>中减去<code class="fe lo lp lq lr b">RHS</code>，直到<code class="fe lo lp lq lr b">LHS</code>小于<code class="fe lo lp lq lr b">RHS</code>。我们知道这是可以实现的，因为<code class="fe lo lp lq lr b">RHS</code>不为零。我们现在可以这样使用它:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="87ca" class="mv lt iq lr b gy mw mx l my mz">Div&lt;TWO, ONE&gt; // we get {q: TWO, r: ZERO_BYTE}<br/>Div&lt;ONE, ZERO_BYTE&gt; // we get "Division by 0"<br/>Div&lt;[Zero, Zero, Zero, Zero, One, Zero, One, Zero], TWO&gt; // we get {q:[Zero, Zero, Zero, Zero, Zero, One, Zero, One], r: ZERO_BYTE}</span></pre><h1 id="74a8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">斐波那契实现</h1><p id="d73f" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">所有这些把我们带到了可以实现<code class="fe lo lp lq lr b">fibonacci</code>数字的地方。</p><p id="5138" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种实现的思想建立在与以前相同的原则之上:</p><ul class=""><li id="92ea" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">泛型约束类型</li><li id="3ca5" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">条件类型</li></ul><p id="1f6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们定义了一个有三个泛型参数的<code class="fe lo lp lq lr b">FIBONACCI</code>类型</p><ul class=""><li id="2d0f" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated"><code class="fe lo lp lq lr b">C</code>当前指数在计算中</li><li id="2c5a" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><code class="fe lo lp lq lr b">A</code>序列中的当前编号</li><li id="c21f" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><code class="fe lo lp lq lr b">B</code>序列中的前一个数字</li></ul><p id="d803" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们只需<code class="fe lo lp lq lr b">decrement C</code>计算一个新的<code class="fe lo lp lq lr b">A</code>作为<code class="fe lo lp lq lr b">A</code>和<code class="fe lo lp lq lr b">B</code>的和，将新的<code class="fe lo lp lq lr b">B</code>改为旧的<code class="fe lo lp lq lr b">A</code>。我们还需要有一个停止条件。这在<code class="fe lo lp lq lr b">C</code>为1或2时表示。让我们来看看实际情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">斐波纳契</p></figure><p id="da1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这些，我们可以通过传递数字的二进制表示来计算<code class="fe lo lp lq lr b">fibonacci</code>序列号。</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="3ae4" class="mv lt iq lr b gy mw mx l my mz">FIBONACCI&lt;[Zero, Zero, Zero, Zero, Zero, One, One, One]&gt;</span></pre><p id="83e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它将计算斐波纳契数列中的第7个值，即:</p><pre class="kg kh ki kj gt mr lr ms mt aw mu bi"><span id="6313" class="mv lt iq lr b gy mw mx l my mz">[Zero, Zero, Zero, Zero, One, One, Zero, One] // 13</span></pre><h1 id="2d7b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结束语</h1><p id="b488" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们展示了一种使用TypeScript的类型系统实现简单ALU的方法。</p><p id="5d52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用的主要技术有:</p><ul class=""><li id="8e59" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">泛型约束类型</li><li id="a86c" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">实现分支的条件泛型</li><li id="02db" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">引用自身来实现循环的条件泛型(递归)</li></ul><p id="9399" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个<a class="ae ln" href="https://github.com/hades2510/TS-TypingSystem-ALU" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中可以找到它的完整实现。回购协议还包括一系列用于验证操作的测试。</p><p id="8391" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你喜欢读这篇文章。下一篇文章再见。</p></div></div>    
</body>
</html>