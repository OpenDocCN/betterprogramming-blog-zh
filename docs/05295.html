<html>
<head>
<title>Quicksort in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的快速排序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/quick-sort-in-javascript-5a13cc6c2ed4?source=collection_archive---------9-----------------------#2020-06-26">https://betterprogramming.pub/quick-sort-in-javascript-5a13cc6c2ed4?source=collection_archive---------9-----------------------#2020-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8c40" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在您的代码库中实现快速排序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4ff9ea759402d1d551cde76a7f145db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XYg1Z3oG8FvYjKUZ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@edgr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">edu·格兰德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="4166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只想要密码？向下滚动到代码的两个版本:</p><ol class=""><li id="cada" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">不带注释(即插即用)。</li><li id="5bcd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过注释来更好地理解代码。</li></ol></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e674" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">什么是快速排序？</h1><p id="d08e" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">快速排序是一种排序算法，它将一个问题分解成两个或更多类似的子问题，直到最初的问题变得足够简单，可以直接解决。它遵循分而治之的方法。</p><p id="8b72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快速排序是任何编程语言中最流行和最常用的算法之一。编码中的许多内置排序方法都使用了Quicksort的变体。</p><p id="2435" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快速排序的工作方式是首先找到一个元素作为主元素，然后从数组的两端(左右两侧)与主元素进行比较。接下来，它对它们进行排列，使小于枢轴元素的元素位于左侧，而大于枢轴的元素位于右侧。</p><p id="d462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nk">注意:如果你想让数组从最大到最小排序，你可以反向操作。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8c0888630fe0adcb767a1610cf60871a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/0*Yk4FBUo_6rJri_ZC.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://qnaplus.com/implement-quick-sort-c/" rel="noopener ugc nofollow" target="_blank"> QnA加</a>。</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="d8b8" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">使用快速排序的步骤</h1><p id="7f8e" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">实现快速排序需要某种形式的递归。</p><ol class=""><li id="8f04" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">找到枢纽元素。</li><li id="ff70" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对数组重新排序，使所有小于pivot元素的数字位于左侧，所有大于pivot元素的数字位于右侧。</li><li id="c494" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对pivot元素左侧和右侧的所有元素重复步骤1和2。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b78281092ea283df5a32f219b46e685e.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/0*U_TEqWRubNxJERlO.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GIF来自<a class="ae kv" href="https://en.wikipedia.org/wiki/File:Sorting_quicksort_anim.gif" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="eeb6" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">JavaScript中的快速排序</h1><p id="f28e" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在开始之前，我们需要注意Quicksort是一个破坏性函数，因为它会修改您放入其中的数组。如果您不想修改原始数组，请确保在注入这个排序算法之前使用spread操作符创建一个新变量。</p><p id="a569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从函数的排序部分开始。这部分将找到pivot元素并对数组进行排序，使较小的数字在左边，较大的数字在右边:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/a8ed03a75a44214e1271f3a37826c326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtV2Hnvv57eWRaOv1riZ8A.png"/></div></div></figure><p id="4e91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们传入数组本身——这部分排序开始的左索引和这部分结束的右索引。</p><p id="8b6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，找到pivot元素。找到这个元素可能非常棘手，因为有些人喜欢使用最后一个元素作为枢纽，而有些人喜欢使用第一个元素。我更喜欢使用数组中间的元素。这样，在大部分排序或已经排序的数组中，函数需要运行的步骤更少。</p><p id="88b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从左右指针开始，分别作为数组的第一个和最后一个元素。然后，我们将左边指针上的元素与pivot元素进行比较。我们这样做，直到我们找到一个比支点大的数。接下来，我们对右指针做同样的事情，找到一个比主指针小的数字。</p><p id="8826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们找到了两个数字，我们就可以互相交换值，并将两个指针都移动一步。继续这样做，直到两个指针相遇，我们将其中一个指针返回，作为递归发生的新中心(支点)。</p><p id="c55f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我创建了一个小函数来交换这两个元素。你不需要在一个单独的函数中写这个。我这样做只是为了更好地组织我的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/b6d09ea1c70a351a340ea7ec555d5cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T62HzoQ8MWgCzg4RrLquhw.png"/></div></div></figure><p id="36a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经知道了如何将数组排列在左边和右边，我们现在需要找到如何将它放入一个递归中，这样它将继续划分数组，并在那部分上执行快速排序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/71e09774578b08ebc4342ff4636ca4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQzUqjAXbF749ASkpxAvzw.png"/></div></div></figure><p id="fe57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，检查它的长度，看它是否只有一个元素。如果是这样，我们就忽略这个数组，因为没有什么要做的了。</p><p id="fabd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我们将首先使用轴心点对数组进行排序，然后返回轴心索引，这样我们就知道在哪里划分数组。</p><p id="f911" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，把数组分成左右两边，把它们放回函数中，因为这是我们的递归操作。</p><p id="04e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当调用快速排序算法时，我们希望传递数组、左边的索引以及快速排序要执行的最后一个索引。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/955f86e462864c9c6c3b5f00a15e71f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*vNQ9JOd7XB1l-KB6xyA-1w.png"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="8664" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">就为了密码吗？</h1><h2 id="3a6a" class="nr mo iq bd mp ns nt dn mt nu nv dp mx lf nw nx mz lj ny nz nb ln oa ob nd oc bi translated">版本1:只有函数，没有任何注释</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="f2cc" class="nr mo iq bd mp ns nt dn mt nu nv dp mx lf nw nx mz lj ny nz nb ln oa ob nd oc bi translated">版本2:带注释</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure></div></div>    
</body>
</html>