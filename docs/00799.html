<html>
<head>
<title>SQL GROUP BY in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的SQL分组依据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sql-group-bys-in-python-547f526eeb41?source=collection_archive---------10-----------------------#2019-07-15">https://betterprogramming.pub/sql-group-bys-in-python-547f526eeb41?source=collection_archive---------10-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="834e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用神奇宝贝数据练习GROUP BY子句</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c27eef0a10c13714d9d5587e4ec214a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLgyvyOMre6A2AwJaaFbog.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@filmape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jay </a>在<a class="ae ky" href="https://unsplash.com/search/photos/pokemon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这个博客中使用的代码可以在我的GitHub上找到。</p><p id="6832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们已经知道如何用SQL进行基本查询(如果您没有或需要复习，请阅读:"<a class="ae ky" href="https://medium.com/better-programming/a-gentle-introduction-to-sql-basics-in-python-b137651ed1ff" rel="noopener">Python中SQL基础知识的简明介绍</a>")，我们可以开始利用SQL提供的越来越多的工具。</p><p id="f253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQL中，<code class="fe lv lw lx ly b">GROUP BY</code>子句是一个非常有用的工具。有了它，我们可以更深入地研究我们的数据，并使用一些函数将相同的数据分组。</p><p id="9f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个列在不同的行中有相同的值，它会将这些行放在一个单独的桶中。</p><p id="c683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">GROUP BY</code>子句有三个要点:</p><ol class=""><li id="1f5d" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">GROUP BY</code>与<code class="fe lv lw lx ly b">SELECT</code>语句一起使用。</li><li id="6e29" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">在查询中，<code class="fe lv lw lx ly b">GROUP BY</code>位于<code class="fe lv lw lx ly b">WHERE</code>子句之后。</li><li id="ab22" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">在查询中，<code class="fe lv lw lx ly b">GROUP BY</code>放在<code class="fe lv lw lx ly b">ORDER BY</code>之前(如果使用的话)。</li></ol><p id="7aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经制定了一些规则，让我们来设置笔记本吧！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a1d6" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">安装</h1><p id="852a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">对于这些例子，我们将使用来自<a class="ae ky" href="https://www.kaggle.com/abcsds/pokemon" rel="noopener ugc nofollow" target="_blank"> Kaggle数据集</a>的神奇宝贝数据。</p><p id="2f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是为了给SQL增添趣味，但这些例子可以很容易地应用于更商业化的解决方案，比如按年龄组、收入水平、位置等分组。</p><p id="dede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从导入我们需要的库并加载Python中的CSV文件开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6f37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们开始清理数据，然后将它移入一个<a class="ae ky" href="https://www.sqlite.org/" rel="noopener ugc nofollow" target="_blank"> SQLite </a>实例:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="b1eb" class="nx mv it ly b gy ny nz l oa ob"><strong class="ly iu">#find NaN values</strong><br/>nan_rows = df[df.isnull().T.any().T]<br/>nan_rows.head()</span></pre><p id="1247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将找到任何空值并返回其中的一些(如果有的话)。</p><p id="cda4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为所有的空值都存在于type2列中，所以我们将所有这些空值都改为<code class="fe lv lw lx ly b">‘none’</code>。</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="802a" class="nx mv it ly b gy ny nz l oa ob"><strong class="ly iu">#change all Type 2 NaN values to 'None':</strong><br/>df['type2'] = df['type2'].fillna('none')</span></pre><p id="d491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，由于SQL对表中的字符串非常明确(行中的大小写很重要)，我们将把所有内容都设置为小写。</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="b185" class="nx mv it ly b gy ny nz l oa ob"><strong class="ly iu">#change all strings within the dataframe to lower case</strong><br/>df = df.astype(str).apply(lambda x: x.str.lower())</span></pre><p id="bca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备将它设置为一个SQL数据库！</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="b5da" class="nx mv it ly b gy ny nz l oa ob"><strong class="ly iu">#set the database for pokemon</strong><br/>df.to_sql('pokemon', con=cnx, if_exists='append', index=False)</span><span id="7a88" class="nx mv it ly b gy oc nz l oa ob"><strong class="ly iu">#function for the SQL queries below</strong><br/>def sql_query(query):<br/>    return pd.read_sql(query, cnx)</span></pre><p id="40cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了，我们可以开始运行一些SQL查询了！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9940" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">GROUP BY的一般语法</h1><p id="8574" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">GROUP BY函数的一般语法是:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="f603" class="nx mv it ly b gy ny nz l oa ob">SELECT column_name(s), function_name(column_name)<br/>FROM table_name<br/>WHERE condition<br/>GROUP BY column_name(s)<br/>ORDER BY column_name(s);<br/><br/><strong class="ly iu">function_name</strong>: SUM(), AVG(), MIN(), MAX(), COUNT().<br/><strong class="ly iu">table_name</strong>: name of the table. In this example, there is only the pokemon table<br/><strong class="ly iu">condition</strong>: condition used.</span></pre><p id="d867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个，我们可以重新组织和操作数据，以便我们可以找到更好的见解。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="cfbf" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">简单分组依据</h1><p id="4b12" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">比方说，我们只想找到具有最高(最大)统计值的传奇神奇宝贝的名称、类型和总统计值。我们将从一个简单的<code class="fe lv lw lx ly b">MAX()</code>查询开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将输出Mega Mewtwo X，一个精神/战斗神奇宝贝，总属性令人印象深刻的780！</p><p id="c90c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想知道最大值最高的神奇宝贝，但在每个类型1类别中呢？这就是<code class="fe lv lw lx ly b">GROUP BY</code>子句派上用场的地方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6b88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，不是只有一个神奇宝贝作为输出(Mega Mewtwo X)，而是有14个传说中的神奇宝贝。</p><p id="6d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL查询查找所有传奇神奇宝贝，并根据type1列将它们分组到单独的存储桶中。</p><p id="425a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它把它们分成黑暗、龙、电、仙等。，则查询返回每个桶中神奇宝贝的名称、类型1、类型2和总统计数据。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a8b5" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">GROUP BY和HAVING子句</h1><p id="1087" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们使用<code class="fe lv lw lx ly b">WHERE</code>子句在列上放置条件，但是在组上放置条件呢？介绍<code class="fe lv lw lx ly b">HAVING</code>条款！</p><p id="013e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">WHERE</code>关键字不能与聚合函数一起使用，所以我们使用带有<code class="fe lv lw lx ly b">GROUP BY</code>的<code class="fe lv lw lx ly b">HAVING</code>子句</p><p id="1918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">HAVING</code>子句来输入条件，以确定哪个组将成为最终结果的一部分。</p><p id="b1bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，聚合函数不能受<code class="fe lv lw lx ly b">WHERE</code>子句的影响。<strong class="lb iu"> </strong>相反，如果我们想要应用条件，那么<code class="fe lv lw lx ly b">HAVING</code>子句与聚合函数<strong class="lb iu"> </strong>一起使用。</p><h2 id="e3bf" class="nx mv it bd mw od oe dn na of og dp ne li oh oi ng lm oj ok ni lq ol om nk on bi translated"><strong class="ak">HAVING子句的一般语法</strong></h2><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="ad14" class="nx mv it ly b gy ny nz l oa ob">SELECT <em class="oo">column_name(s)</em><br/>FROM <em class="oo">table_name</em><br/>WHERE <em class="oo">condition</em><br/>GROUP BY <em class="oo">column_name(s)<br/></em>HAVING <em class="oo">condition<br/></em>ORDER BY <em class="oo">column_name(s);</em></span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="17ca" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">GROUP BY With HAVING子句示例</h1><p id="f1be" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">假设我们想要找到单个神奇宝贝的数量、类型1、最小和最大总统计值以及按类型1分组的所有神奇宝贝的平均HP，并且只包括总HP高于4000的神奇宝贝组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="77cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有助于我们确定哪组神奇宝贝在他们的职业中有最高的血量，同时剔除低于我们设定的4000上限的组。</p><p id="74ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想选择高HP的神奇宝贝，我们会选择普通类型1的，因为它们有最高的平均HP (77.28)，肯定会受到一两次打击。</p><p id="79c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">HAVING</code>子句确实有助于将我们的数据精简为更有用、更有洞察力的东西！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="37f1" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="cefe" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">写这篇博客帮助我理解了如何利用<code class="fe lv lw lx ly b">GROUP BY</code>的，我希望它也能帮助你！敬请关注即将发布的下一篇SQL博客！</p></div></div>    
</body>
</html>