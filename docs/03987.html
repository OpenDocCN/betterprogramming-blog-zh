<html>
<head>
<title>TypeScript With Fewer Types?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型较少的TypeScript？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-with-fewer-types-f7fa636476db?source=collection_archive---------8-----------------------#2020-03-17">https://betterprogramming.pub/typescript-with-fewer-types-f7fa636476db?source=collection_archive---------8-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c0b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么我们应该尽可能避免手写打字</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67a7283dd4819feb349e4149e3ec96e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GB15tyDll337Xt_bnv8osA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="1e21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本月早些时候，我写了一篇文章，回顾了打字稿和流 <em class="lv">之间的一些<a class="ae lu" href="https://medium.com/better-programming/please-put-typescript-down-for-a-moment-103f15378d34" rel="noopener">权衡。</a></em>我试图公正地评价自己，但正如我所料，有相当多的人站出来为TypeScript辩护。</p><p id="8870" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">特别是，当我在文章中做了如下概括性声明时，有一个人不太高兴:</p><blockquote class="lw"><p id="ab44" class="lx ly it bd lz ma mb mc md me mf lt dk translated">“使用TypeScript和Flow的讽刺之处在于，手工打字并不是一件好事！”</p></blockquote><p id="8608" class="pw-post-body-paragraph ky kz it la b lb mg ju ld le mh jx lg lh mi lj lk ll mj ln lo lp mk lr ls lt im bi translated">这让我思考:虽然这可能是一个笼统的说法，但它是正确的吗？在这篇文章中，我将论证“是”</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9d70" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">主要问题</h1><p id="1e9d" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">首先，您的体验将高度依赖于您使用的库。例如，我将TypeScript(和Flow)与React + Redux(以及libs)一起使用。因此，我的观点可能与主要在Express中工作的人不同。</p><p id="18c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，一般来说，手写输入很容易成为一个容易出错且耗时的过程。</p><p id="9795" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问自己以下问题:</p><ul class=""><li id="7581" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">您有多少次因为过时的类型定义而遇到错误(在处理API时最常见)？</li><li id="4d8c" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">你花了多少时间来更新你自己的类型定义(特别是React + Redux)？</li><li id="e0a2" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">你花了多少时间操作或扩展第三方库的类型定义(希望不要太多)？</li><li id="9032" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">你花了多少时间调试非平凡代码中的类型错误(不包括组件上的无效属性类型，因为这些通常是最容易修复的)？</li></ul><p id="c015" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些问题通常都有解决方案，具体取决于具体的场景。</p><p id="5778" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是重点。花时间管理类型，特别是在上面列出的场景中，通常是没有效率的。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="72c5" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">过时的API类型定义</h1><p id="186b" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">假设你在一个名为团队Alpha的前端团队中(因为前端团队就是Alpha…开玩笑),你正在使用一个由团队Bravo创建的API。</p><p id="b986" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您的团队很大，所以您使用TypeScript并为特定的API端点设计了一些类型定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0f75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧，酷。我们不仅有类型安全，而且很容易理解API端点的输入和输出。</p><p id="80f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">快进一周，Bravo团队对<code class="fe of og oh oi b">/user</code>端点进行了更改。他们在Slack上的<code class="fe of og oh oi b">api-news</code>频道发送了一条消息。阿尔法小组有人看到了，有人没看到。突然，你的前端坏了，你不知道为什么。以下是所做的更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5447" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您编写的保护您的类型正在导致大量的调试问题，因为它们已经过时了。</p><p id="78f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在短暂的碰壁之后，你要么终于看到了Bravo团队的更新，要么自己找到了问题的根源。</p><p id="6c8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也许第一次没什么大不了的。你更新类型，继续你的生活。</p><p id="501f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是你要调试、更新和重构多少次呢？可能永远。</p><h2 id="250e" class="oj mt it bd mu ok ol dn my om on dp nc lh oo op ne ll oq or ng lp os ot ni ou bi translated">理想溶液</h2><p id="efc5" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">如果可能的话，一个很好的“自动”解决方案是为您的API模式使用类型生成器。如果您使用GraphQL，那么您很幸运，因为类型生成器(GraphQL代码生成器、Apollo codegen等)有可靠的选项。</p><p id="d764" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，当API发生变化时，您可以运行一个命令来下载请求和响应类型的变化。例如，如果您有时间，您可以在每次API repo更新时自动触发下载。这样，你就可以一直保持最新状态。</p><p id="3e8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您在客户机和服务器上都使用TypeScript，那么我认为利用这一事实并在下游共享类型是明智的。只要不在客户机上编写请求和响应类型，方式并不重要。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="fc18" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">复杂类型</h1><p id="da29" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">不是所有类型都写的一样！使用React时，常见的情况是编写某种HOC(高阶组件)来增强其他组件。</p><pre class="kj kk kl km gt ov oi ow ox aw oy bi"><span id="3bf3" class="oj mt it oi b gy oz pa l pb pc">function trivialHOC&lt;Config: {}&gt;(<br/>  Component: React.AbstractComponent&lt;Config&gt;<br/>): React.AbstractComponent&lt;Config&gt; {<br/>  return Component;<br/>}</span></pre><p id="17c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是心流的基本例子。如果你知道这里发生了什么，还不算太坏。</p><p id="0839" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您有一个将道具注入包装组件的HOC时会发生什么？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e625" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，如果你知道发生了什么，这可能不会太难。然而，真实世界的组件往往更加复杂。想一想正确写出这个需要多少时间。</p><p id="55a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最重要的是，如果其他人需要修改它，而创建这个组件的人已经不在了，怎么办？现在其他人不得不花费开发时间来完成类型定义。</p><p id="dccb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您不使用React，这并不一定会将您从类似这样的潜在情况中解救出来(尽管这种情况可能远不常见)。我们仍然应该尽我们的努力来避免这种情况。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="38fd" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">这不仅仅是开发价值的问题</h1><p id="04c7" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">开发人员经常认为，从长远来看，类型有助于减少技术债务和错误。我强烈推荐<a class="ae lu" href="https://medium.com/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3" rel="noopener">阅读这篇文章</a>，这篇文章解释了静态类型并不一定意味着更少的错误。</p><p id="1a65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使它确实减少了错误，你花费在管理类型定义上的时间仍然是一项商业成本<em class="lv">。</em></p><p id="9fcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开发人员花在管理类型上的每一个额外的小时，都是没有用于特性开发的额外的一个小时。</p><p id="cd7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这真的可以归结为:什么是成本收益比？与管理类型定义(以及与类型相关的错误)所花费的时间相比，在错误修复上节省了多少时间？</p><p id="cd4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有一个打字专家团队，收益可能会超过成本。如果有一个打字专家领导一个由初级和中级JavaScript开发人员组成的混合团队，那么成本收益比可能就不会那么向右倾斜了。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="0c60" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">我们如何最好地利用TypeScript？</h1><p id="634e" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">到目前为止，我所说的一切将会招致大量的憎恨和批评。我想说清楚，我认为打字稿是坏蛋。静态类型不是一件坏事。我只是不喜欢类型的存在突然意味着你的代码更安全或更好的想法。这件事还得<em class="lv">做好</em> <em class="lv">。</em></p><p id="64ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我认为我们自己编写的类型越少(同时仍然具有100%的类型安全性)，TypeScript将为我们提供更好的服务，我们的代码也将更干净。</p><p id="9f1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不想听到类型安全弥补可读性的论调。不应该是一个对另一个！</p><p id="65be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们是程序员，该死的。从代码的角度来看，我们喜欢控制，不喜欢妥协。</p><p id="afc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，这里有一些我认为可以减少手写字体的方法:</p><ul class=""><li id="4149" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">让TypeScript尽可能多地推断类型。TypeScript在这方面相当擅长，我们应该利用这一点！不要显式编写TypeScript已经可以自己解决的内容。</li><li id="570a" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">如果可能的话，为API使用类型生成器。这并不总是可能的，但好处是巨大的。如果你使用GraphQL，你已经有了一些惊人的选择。如果没有，这是一个值得与您的后端团队讨论的问题，以便合作制作一个(如果可能的话)。</li><li id="18cb" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">真正更深层次的了解TS类型。有时，你可以使用奇特的泛型和帮助函数来编写一个有趣的类型定义或抽象，这将使你免于编写重复和脆弱的类型。问题是我们中的大多数人只在表面水平上学习如何编写类型，因为我们90%的时间只需要基本的。</li><li id="2bbb" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">如果可能，坚持使用有TS支持的库。<strong class="la iu"> </strong>如果库本身是用TS写的，那就更好了。同样，这并不总是可能的，但是使用的缺乏TS支持的库越多，您自己要管理的类型就越多。</li><li id="17ea" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">完全避免TS和Flow。这不是一个受欢迎的选择，但是如果你发现TS真的阻碍了你或者你的团队的生产力，那么放弃它。我知道人们会说缺乏技能不是一个好的借口。说真的，别说了。他们的老板为他们有利可图的产出支付薪水，而不是他们写代码所用的语言。如果有人在香草JS中更有效率，那么他们应该坚持香草JS，并在空闲时间玩TS。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="ea72" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="ae70" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">写类型怎么可能是好事？我知道我们<em class="lv">不得不</em>去做这件事，但是如果我们能最小化它——同时保持类型安全——那不是一个理想的世界吗？</p><p id="de8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将总是不得不写类型…然而我们并不总是不得不写类型。你明白吗？</p><p id="b73d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与其盲目地追求类型安全，不如让我们追求类型安全和<em class="lv"> </em>干净、可管理的代码。</p><p id="b83a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住那句老话:最好的代码是你从来没有写过的代码。</p><p id="f1bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有问题、想法或顾虑，请留下评论！我不会坐在这里宣称我的观点是事实<em class="lv"> </em>，因为事实并非如此。我很乐意就这个问题进行反复讨论。请随意尝试改变我的想法！</p></div></div>    
</body>
</html>