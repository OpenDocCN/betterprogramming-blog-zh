<html>
<head>
<title>10 Tips and Tricks to Boost Your React App’s Performance in 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年提升React应用性能的10个技巧和诀窍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-tips-and-tricks-to-boost-your-react-apps-performance-in-2020-9388159f6ebf?source=collection_archive---------1-----------------------#2020-08-31">https://betterprogramming.pub/10-tips-and-tricks-to-boost-your-react-apps-performance-in-2020-9388159f6ebf?source=collection_archive---------1-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4848" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更快的应用，更快乐的用户</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1094083a872ee0c77fd7d2a328fd8cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QnCh603gbVipMpq2-QxaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.flaticon.com/authors/freepik" rel="noopener ugc nofollow" target="_blank"> Freepik </a>在<a class="ae ky" href="https://www.flaticon.com/" rel="noopener ugc nofollow" target="_blank"> flaticon </a>上的图标。</p></figure><p id="8a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于编程来说，解决同一个问题有不同的方法——无论是JavaScript、React、Python还是任何其他语言。当你研究别人的代码时，总会有新的东西可以学习。</p><p id="8db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React每天都在发展，有各种方法可以用来解决我们在应用程序中遇到的任何问题。让我们来看看在使用React时肯定会对您有所帮助的十个提示和技巧。请将这些技巧视为应用程序的性能助推器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b19e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 1。暂停控制台调试器</strong></h1><p id="1200" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您肯定遇到过这样的情况，您想要调试dropdown的样式，或者当您尝试右键单击元素并单击“Inspect element”时自动关闭的其他样式</p><p id="7f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的解决方案:</p><ol class=""><li id="3b7a" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">从浏览器打开您的控制台。</li><li id="0105" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">键入以下命令:</li></ol><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="44dc" class="ns md it no b gy nt nu l nv nw">setTimeout(() =&gt; {debugger;}, 5000)</span></pre><p id="4549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.然后打开您想要调试的下拉菜单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">停止调试器—信用:<a class="ae ky" href="https://twitter.com/ralex1993" rel="noopener ugc nofollow" target="_blank"> ralex1993 </a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4422" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.使用函数进行状态惰性初始化</h1><p id="e9ae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时候，我们需要从某个变量或返回值的函数中设置状态的初始值。</p><p id="ebda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的例子:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="39bd" class="ns md it no b gy nt nu l nv nw">const initialState = someFunctionThatCaluclatesValue(props)</span><span id="ebd4" class="ns md it no b gy nz nu l nv nw">const [count, setCount] = React.useState(initialState)</span></pre><p id="ea20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们的函数在主体中，所以每次重新渲染时，这个函数都会被调用，即使不需要它的值(我们只在初始渲染时需要它)。</p><p id="e7ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何用函数惰性初始化<code class="fe oa ob oc no b">useState</code>:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="290f" class="ns md it no b gy nt nu l nv nw">const getInitialState = (props) =&gt; someFunctionThatCaluclatesValue(props)</span><span id="8c25" class="ns md it no b gy nz nu l nv nw">const [count, setCount] = React.useState(getInitialState)</span></pre><p id="c9b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个函数非常快。React只会在需要初始值的时候调用函数(也就是组件最初渲染的时候)。所以即使这个函数花费了很多时间，它也只是在初始渲染时会很慢。这被称为“惰性初始化”这是一种性能优化。</p><p id="f9bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这张GIF图，了解一下它的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5229588480d400246ea70f9eafaab261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*olNPRZhQD0tPDXLNRfLkrw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">懒惰函数与普通函数</p></figure><p id="8f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来玩一下上面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">关于<a class="ae ky" href="https://codesandbox.io/s/usestate-lazy-initialization-j1wvm?file=/src/App.js" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>的示例</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="acf4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.利用定制挂钩</h1><p id="099f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用钩子，我们没有一些工具可以帮助我们得到回调，就像在<code class="fe oa ob oc no b">setState</code>的情况下一样。</p><p id="a421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们在状态中得到回调。一旦状态被设置，我们通常使用回调函数:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="108e" class="ns md it no b gy nt nu l nv nw">this.setState({<br/>    "name" : "Harsh"<br/>}, () =&gt; {<br/>     // Hey that state is set successfully what do you<br/>     // want to do, I'm callback your friend 😄<br/>})</span></pre><p id="0125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何用一个自定义钩子实现类似的行为，这个钩子只在状态改变时被调用，而在初始渲染时不被调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of ny l"/></div></figure><p id="ce22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多简单易懂的鱼钩食谱，请查看<a class="ae ky" href="https://twitter.com/gabe_ragland" rel="noopener ugc nofollow" target="_blank">加布·拉格兰</a>。</p><div class="og oh gp gr oi oj"><a href="https://usehooks.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">使用挂钩</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">这个钩子使得订阅Firestore数据库中的数据变得非常容易，而不必担心状态…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">usehooks.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5447" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.监控应用程序中不必要的渲染</h1><p id="028a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们面临的一个常见问题是评估应用程序中对性能有不良影响的必要渲染。</p><p id="2d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有不同的方法来评估它们，以避免在几分钟内进行不必要的渲染</p><h2 id="6659" class="ns md it bd me oy oz dn mi pa pb dp mm li pc pd mo lm pe pf mq lq pg ph ms pi bi translated">你为什么渲染</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/e16ca35d3fb26389ee41b0c8b95fc03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*godtZ4RYy0FqXenYFEM1Ew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片鸣谢:<a class="ae ky" href="https://github.com/welldone-software/why-did-you-render" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></figure><p id="db8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据其文档，<a class="ae ky" href="https://github.com/welldone-software/why-did-you-render" rel="noopener ugc nofollow" target="_blank">why-do-you-render</a>“monkey patches做出反应，通知您可避免的重新渲染。”这将显示应用程序中发生的不必要的渲染，以便您可以对它们采取措施。</p><h2 id="a97e" class="ns md it bd me oy oz dn mi pa pb dp mm li pc pd mo lm pe pf mq lq pg ph ms pi bi translated">React开发工具</h2><p id="163b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如<a class="ae ky" href="https://www.debugbear.com/blog/measuring-react-app-performance" rel="noopener ugc nofollow" target="_blank">调试员</a>所述:</p><blockquote class="pk pl pm"><p id="9d5e" class="kz la pn lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated"><a class="ae ky" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank"> "DevTools </a>为我们展示一下您的应用性能。要看到这一点，请确保您在开发模式下运行React，在浏览器中打开DevTools，然后转到“Performance”选项卡。</p><p id="c850" class="kz la pn lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated">您可以从页面加载后的某个时间点或从页面加载开始记录应用程序的性能。DevTools对话框的左上角有两个按钮:"</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/f6ffa90c03cefb90cf9b1444f6772c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/format:webp/0*IJDX8eKwX6K7O7tn.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">开始录音</p></figure><p id="2674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦停止录制，您将能够看到一个图形，显示渲染的不同组件以及渲染它们所用的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/1969a05f155593f11b10f021886fdcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBoSRC7PAkSoo1HDt-qnJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">渲染信息</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6a14" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.使用React.memo和useMemo</h1><p id="16f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据<a class="ae ky" href="https://reactjs.org/docs/react-api.html" rel="noopener ugc nofollow" target="_blank"> React的官方文档</a>:</p><blockquote class="pk pl pm"><p id="948a" class="kz la pn lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated">“<code class="fe oa ob oc no b">React.memo</code>是高阶分量。</p><p id="64d9" class="kz la pn lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated">如果您的函数组件使用相同的属性呈现相同的结果，您可以将其封装在一个调用中进行反应。在某些情况下，记忆结果会提高性能。这意味着React将跳过对组件的渲染，并重用上次渲染的结果。"</p></blockquote><p id="3e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc no b">React.memo</code>开箱进行浅层比较，避免渲染。堆栈溢出用户<a class="ae ky" href="https://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react" rel="noopener ugc nofollow" target="_blank">将浅层比较</a>定义为“当被比较对象的属性使用<code class="fe oa ob oc no b">===</code>或严格相等完成时，不会对属性进行更深入的比较。”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/c3f2f4c5571d1b6b14be75b3ee70e6f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3vSSAUgCHUPpH9Ku6M4AQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这将导致重新渲染。</p></figure><p id="64e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pn">注意:在上面的例子中，</em> <code class="fe oa ob oc no b"><em class="pn">true</em></code> <em class="pn">意味着组件将再次渲染，尽管值是相同的。</em></p><p id="cf25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有时您需要进行深度比较，这意味着您想要比较对象数组中的嵌套属性。我们如何做到这一点？让我们开始下一个魔术。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="025e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.shouldComponentUpdate中的深度比较</h1><p id="d1b2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我们在上面的例子中看到的，如果你的值很简单，<code class="fe oa ob oc no b">React.memo</code>只能帮助你避免重新渲染。但是如果你有一个嵌套的对象数组，你就不能开箱即用地比较它们。</p><p id="cd4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用深度相等:</p><div class="og oh gp gr oi oj"><a href="https://www.npmjs.com/package/deep-equal" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">深度相等</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">作为独立模块的节点的assert.deepEqual()算法。这个模块比包装快大约46倍…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">www.npmjs.com</p></div></div><div class="os l"><div class="pu l ou ov ow os ox ks oj"/></div></div></a></div><p id="211b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较两个对象，并根据递归相等算法返回它们是否相等。</p><blockquote class="pk pl pm"><p id="4a47" class="kz la pn lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated">“如果<code class="fe oa ob oc no b">opts.strict</code>是<code class="fe oa ob oc no b">true</code>，用严格等式(<code class="fe oa ob oc no b">===</code>)比较叶节点。默认情况下使用强制相等(<code class="fe oa ob oc no b">==</code>)，因为这就是<code class="fe oa ob oc no b">assert.deepEqual()</code>默认的工作方式。”— <a class="ae ky" href="https://github.com/inspect-js/node-deep-equal" rel="noopener ugc nofollow" target="_blank">深度相等</a></p></blockquote><p id="6a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pn">注意:有很多这样的包可以帮助你比较两个嵌套的对象数组，避免通过比较来重新渲染。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="677c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.反应窗口</h1><p id="2de1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于应用程序的大部分工作都是以列表的形式呈现数据，因此当列表变长时，就像一种毒药正在慢慢进入应用程序，对性能产生不良影响。它也开始消耗浏览器中的大量内存。因为所有的列表项都在DOM中，所以当你滚动列表时会有延迟。</p><p id="3d71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何才能只呈现列表中当前在屏幕上可见的部分项目呢？利用React窗口:</p><div class="og oh gp gr oi oj"><a href="https://github.com/bvaughn/react-window" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">bvaughn/react窗口</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">React组件可以有效地呈现大型列表和表格数据，React window只需呈现一个</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="pv l ou ov ow os ox ks oj"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe ny l"/></div></figure><p id="cb93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管你的列表有多大(比如1000个条目)，它在DOM中只会显示20-30个条目，这取决于你的窗口的大小，这是完全可定制的，可以提高性能！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f12c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.反应查询</h1><p id="f296" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过React中用于获取、缓存和更新异步数据的钩子，使用React Query管理服务器状态比以往任何时候都更容易。</p><p id="c19b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是<a class="ae ky" href="https://github.com/tannerlinsley/react-query" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上列出的功能:</p><ul class=""><li id="07d4" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu pw nf ng nh bi translated">传输/协议/后端不可知的数据获取(REST、GraphQL、promises等等！)</li><li id="9763" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pw nf ng nh bi translated">自动缓存+重新提取(失效时重新验证、窗口重新聚焦、轮询/实时)</li><li id="d1f8" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pw nf ng nh bi translated">并行+相关查询</li><li id="3a3e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pw nf ng nh bi translated">突变+反应式查询重取</li><li id="f79a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pw nf ng nh bi translated">多层缓存+自动垃圾收集</li><li id="0700" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pw nf ng nh bi translated">分页+基于光标的查询</li><li id="aea6" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pw nf ng nh bi translated">带滚动恢复的Load-More +无限滚动查询</li><li id="bef3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pw nf ng nh bi translated">请求取消</li><li id="6d45" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pw nf ng nh bi translated"><a class="ae ky" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">反应暂停</a> +渲染时提取查询预取</li><li id="d8a2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pw nf ng nh bi translated"><a class="ae ky" href="https://github.com/tannerlinsley/react-query-devtools" rel="noopener ugc nofollow" target="_blank">专用开发工具(React Query Devtools) </a></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://github.com/tannerlinsley" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的示例。</p></figure><div class="og oh gp gr oi oj"><a href="https://github.com/tannerlinsley/react-query" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">tannerlinsley/react-查询</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">React中用于获取、缓存和更新异步数据的钩子喜欢这个库吗？尝试整个TanStack！反应…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="px l ou ov ow os ox ks oj"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dec4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">9.惰性加载React组件(带有React.lazy和suspension)</h1><h2 id="9f88" class="ns md it bd me oy oz dn mi pa pb dp mm li pc pd mo lm pe pf mq lq pg ph ms pi bi translated">React.lazy()是什么？</h2><p id="b73a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如<a class="ae ky" href="https://blog.bitsrc.io/lazy-loading-react-components-with-react-lazy-and-suspense-f05c4cfde10c" rel="noopener ugc nofollow" target="_blank">所写，Lotanna </a>，<code class="fe oa ob oc no b">React.lazy</code>是:</p><blockquote class="pk pl pm"><p id="5605" class="kz la pn lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated">“React中的一个新功能，允许您通过代码分割来延迟加载React组件，而无需任何其他库的帮助。延迟加载是一种技术，首先只呈现需要的或关键的用户界面项目，然后悄悄地展开非关键项目。”</p></blockquote><h2 id="3fad" class="ns md it bd me oy oz dn mi pa pb dp mm li pc pd mo lm pe pf mq lq pg ph ms pi bi translated">悬念是什么？</h2><blockquote class="pk pl pm"><p id="08ac" class="kz la pn lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated">"<code class="fe oa ob oc no b">Suspense</code>是lazy函数所需要的组件，基本上是用来包装lazy组件的。借助于<code class="fe oa ob oc no b">Suspense</code>组件，可以包装多个惰性组件。它还带有一个回退属性，该属性将接受您希望在加载惰性组件时呈现的React元素。— <a class="ae ky" href="https://blog.bitsrc.io/lazy-loading-react-components-with-react-lazy-and-suspense-f05c4cfde10c" rel="noopener ugc nofollow" target="_blank">谁是洛塔娜</a></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe ny l"/></div></figure><p id="dad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://codesandbox.io/s/react-lazy-suspense-n15rs" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>上查看相关代码。</p><p id="6626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以在应用程序的页面上识别任何大型组件，这些组件只在特定的用户交互中呈现(如单击按钮、切换等)。分割这些组件将最小化您的JavaScript有效负载，并帮助您提高性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1fa6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">10.一个更新多个输入状态值的函数</h1><p id="9f03" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是保持同一个函数来更新多个输入值的常见用例。我们大多数人都知道这种有助于减少代码并完成工作的方法。这在表单中有多个输入的情况下很有用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of ny l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cdcf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b0ae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你知道这些把戏吗？感谢阅读这篇文章。我希望你学到了新的东西！</p></div></div>    
</body>
</html>