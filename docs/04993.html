<html>
<head>
<title>Why You Should Avoid Using Primitive Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该避免使用基本类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-should-avoid-using-primitive-types-cb55857baa39?source=collection_archive---------6-----------------------#2020-05-28">https://betterprogramming.pub/why-you-should-avoid-using-primitive-types-cb55857baa39?source=collection_archive---------6-----------------------#2020-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3fca" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基本类型隐藏了领域的重要细节</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3b1199ad333340d0f1b9d5f9726b2ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZaQKncsPhSmdOhwJ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">劳伦·里奇蒙在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="749a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你好，欢迎光临！</p><p id="d9ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我将谈论为什么你应该避免在你的代码中使用基本类型。</p><p id="b5d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原语类型<em class="ls"> </em>是编程语言提供的基本类型。基本类型的例子包括<code class="fe lt lu lv lw b">Int</code>、<code class="fe lt lu lv lw b">String</code>、<code class="fe lt lu lv lw b">Dictionary</code>和<code class="fe lt lu lv lw b">Array</code>。这些是我们每天使用的基本类型。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="aad2" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">所以我不应该使用原始类型？</h1><p id="bdbd" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">不要误解我。基本类型本身并不坏。它们是我们创建计算机程序的基本构件。我们需要他们。</p><p id="4045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们倾向于滥用原始类型——尤其是在我们的域对象中。例如，注意银行账户的下一个实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/7af4c29f4696ce26f3e7d240bec88d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyhWFwZNcEsROFQ-9e5mCw.png"/></div></div></figure><p id="f822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看它的属性。考虑可能适用于这些属性的业务规则。</p><p id="9d48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可能会问自己以下问题:</p><ul class=""><li id="ec25" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">任何一个<code class="fe lt lu lv lw b">String</code>都是有效的id吗？它应该有特定的格式吗？是数字还是字母数字？</li><li id="c135" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">账户类型可以用任意<code class="fe lt lu lv lw b">String</code>表示吗？空的<code class="fe lt lu lv lw b">String</code>怎么办？存在哪些类型的账户？</li><li id="f7eb" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">余额中使用什么货币？美元？欧元？或许是比索？分币呢？</li></ul><p id="1d88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用基本类型来表示这些属性，我们错过了关于领域及其业务规则的重要信息。基元类型是导致错误的歧义的主要来源。</p><p id="6c50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，与这些属性相关的领域概念可以遍布整个代码库。如果您需要知道什么规则适用于银行帐户ID，您会去哪里找？</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="47c2" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">用值对象增强明确性</h1><p id="adc3" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">原始类型是不够的。我们需要新的类型来表示领域逻辑，并使隐式显式化。</p><p id="8b7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过将基本类型包装成值对象来实现这一点。值对象是一种对描述性属性进行建模的类型。它是一个测量、量化或描述领域中某些事物的概念。</p><p id="8a5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再次看看银行账户的例子，但是我们将用值对象替换基本类型<code class="fe lt lu lv lw b">String</code>和<code class="fe lt lu lv lw b">Int</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/0c4e727377c259580a63009095b9983a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-53Tsf0Fu0cZY9l-1G0GA.png"/></div></div></figure><p id="5b42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型<code class="fe lt lu lv lw b">AccountId</code>、<code class="fe lt lu lv lw b">AccountType</code>和<code class="fe lt lu lv lw b">Money</code>是值对象的例子。</p><p id="e0cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值对象包装基本类型(或其他值对象)以增强模型的表达能力。仅仅拥有一个命名领域概念的类是值得的。想想吧。<code class="fe lt lu lv lw b">Money</code>比<code class="fe lt lu lv lw b">Int</code>提供更多信息。</p><h2 id="ad60" class="nq mf iq bd mg nr ns dn mk nt nu dp mo lf nv nw mq lj nx ny ms ln nz oa mu ob bi translated">行为丰富</h2><p id="ca10" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">值对象不是名字好听的简单数据结构。相反，他们应该将所有与他们所代表的领域概念相关的行为紧密地组合在一起。</p><p id="0d66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个特性使得值对象成为一个非常有用的工具。</p><p id="dd6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次检查上面的例子。<code class="fe lt lu lv lw b">AccountId</code>类包含与银行账户ID相关的业务规则。在这个(虚构的)例子中，ID由十个十进制数字组成。</p><p id="cb96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此信息并非来自代码中的注释或我们可能从银行领域获得的知识。这些信息来自模型本身。您不需要在整个代码库中跟踪与帐户ID相关的业务规则。他们在<code class="fe lt lu lv lw b">AccountId</code>班。</p><h2 id="73ac" class="nq mf iq bd mg nr ns dn mk nt nu dp mo lf nv nw mq lj nx ny ms ln nz oa mu ob bi translated">创建边界</h2><p id="2814" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我看到的使用值对象的另一个好处是，你创建了一个边界，减少了变化的影响。</p><p id="1070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们使用一个<code class="fe lt lu lv lw b">String</code>来表示一个银行账户ID。在银行领域，这个概念在系统中被广泛使用。</p><p id="1e9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但出于某种原因，我们被迫改变所使用的类型。现在需要一个更复杂的结构，比如一个<code class="fe lt lu lv lw b">Array</code>。我们必须搜索帐户id的所有引用，用<code class="fe lt lu lv lw b">Array</code>替换<code class="fe lt lu lv lw b">String</code>，并修复任何可能的问题。</p><p id="c4ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这项任务既耗时又容易出错。</p><p id="ee84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用一个值对象来表示ID，比如一个<code class="fe lt lu lv lw b">AccountId</code>类，可以最小化变化的影响。我们需要做的就是在<code class="fe lt lu lv lw b">AccountId</code>类中将<code class="fe lt lu lv lw b">String</code>改为<code class="fe lt lu lv lw b">Array</code>，并解决那里的任何问题。应用程序的其余部分不应改变。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="269a" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">价值对象的特征</h1><p id="1d17" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在本文中，我将重点放在值对象上，它们是增加模型表达能力的元素。它们包装了与它们所代表的概念相关的基本类型和组行为。</p><p id="04a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是值对象不仅仅如此。先说价值对象的一些特征。</p><h2 id="1de8" class="nq mf iq bd mg nr ns dn mk nt nu dp mo lf nv nw mq lj nx ny ms ln nz oa mu ob bi translated">价值平等</h2><p id="07bf" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">如果两个值对象持有相同的值，则认为它们相等。如果它们是不同的对象，这并不重要。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/b432cd99327a72df6e98cc7ded002a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idiyuZgP3kkSYFDSlkMEOw.png"/></div></div></figure><h2 id="2ac0" class="nq mf iq bd mg nr ns dn mk nt nu dp mo lf nv nw mq lj nx ny ms ln nz oa mu ob bi translated">不变的</h2><p id="d0f8" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">值对象不能变异。如果某个值需要更改，将使用所需的值创建value对象的新实例。</p><p id="bbbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得值对象更容易测试，并且避免了副作用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/22fec3034559aa1157c2d7ad143ea009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRgmD8JsfriiYqeBIKAMfg.png"/></div></div></figure><h2 id="b3a3" class="nq mf iq bd mg nr ns dn mk nt nu dp mo lf nv nw mq lj nx ny ms ln nz oa mu ob bi translated">没有身份</h2><p id="3b03" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">由于“按值相等”属性，如果两个值对象持有相同的值，则无法区分它们。由于不可变的属性，值对象的实例是可丢弃的，因为当值需要改变时会创建新的实例。</p><p id="39f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这些特征，将标识分配给值对象是没有意义的。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="297e" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">包扎</h1><p id="082f" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">基本类型是我们拥有的基本构件，但是我们不应该过度使用它们。基本类型不是表示重要领域概念的好选择。</p><p id="1281" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值对象包装了一个基本类型，增强了它的表达能力，并对相关的域行为进行了分组。</p><p id="065d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让原始类型休息一下。使用值对象。</p><p id="dae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>