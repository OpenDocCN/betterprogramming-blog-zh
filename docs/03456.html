<html>
<head>
<title>An Introduction to TypeScript Property Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript属性装饰器简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-typescript-property-decorators-1c9db23b6ca1?source=collection_archive---------9-----------------------#2020-02-11">https://betterprogramming.pub/an-introduction-to-typescript-property-decorators-1c9db23b6ca1?source=collection_archive---------9-----------------------#2020-02-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="539f" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">对TypeScript装饰器的深入探究</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f3fc354bb9ced74ccc8f94b2b4d53c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypxYKNA2e3VeqE7UcNhXkg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@brookelark?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布鲁克·拉克</a>在<a class="ae kz" href="https://unsplash.com/s/photos/cake?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="la lb l"/></div></figure><p id="11c1" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">在上一篇文章中，我们探讨了TypeScript类装饰器。这一次，我们将深入到财产装饰。属性装饰者可以改变来自类属性的值。</p><p id="17e1" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">如果你还没有读过我关于类装饰器的文章，我建议你先读一读。它包含有助于您跟进的重要信息。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="478f" class="mf mg iu bd mh mi mj mk ml mm mn mo mp ka mq kb mr kd ms ke mt kg mu kh mv mw bi translated">装饰类型</h1><p id="e93c" class="pw-post-body-paragraph lc ld iu le b lf mx jv lh li my jy lk ll mz ln lo lp na lr ls lt nb lv lw lx in bi translated">为了描述decorators在TypeScript中做什么，我们需要更深入地研究每种类型。有几个不同的:</p><ul class=""><li id="7bcb" class="nc nd iu le b lf lg li lj ll ne lp nf lt ng lx nh ni nj nk bi translated"><a class="ae kz" href="https://medium.com/me/stats/post/afb996af0763" rel="noopener">类装饰器</a>(上一张)</li><li id="bc7b" class="nc nd iu le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">属性装饰器(当前片段)</li><li id="4670" class="nc nd iu le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">方法装饰器(稍后会出现)</li><li id="304c" class="nc nd iu le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">访问器装饰器(稍后会出现)</li><li id="7a6e" class="nc nd iu le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">参数装饰器(稍后会出现)</li></ul></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="c352" class="mf mg iu bd mh mi mj mk ml mm mn mo mp ka mq kb mr kd ms ke mt kg mu kh mv mw bi translated">物业装饰</h1><p id="9bad" class="pw-post-body-paragraph lc ld iu le b lf mx jv lh li my jy lk ll mz ln lo lp na lr ls lt nb lv lw lx in bi translated">使用属性装饰器，您可以在运行时更改属性中的值。属性装饰器是在属性声明之前声明的。它不能在声明文件中使用，也不能与<code class="fe nq nr ns nt b">declare</code> <a class="ae kz" href="https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html" rel="noopener ugc nofollow" target="_blank">语句</a>结合使用。</p><p id="8c71" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">这是使用属性装饰器的方式:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu lb l"/></div></figure></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="532a" class="mf mg iu bd mh mi mj mk ml mm mn mo mp ka mq kb mr kd ms ke mt kg mu kh mv mw bi translated">如何创建一个属性装饰器</h1><p id="b26d" class="pw-post-body-paragraph lc ld iu le b lf mx jv lh li my jy lk ll mz ln lo lp na lr ls lt nb lv lw lx in bi translated">当您创建一个属性装饰函数时，您需要有两个参数。</p><ol class=""><li id="e286" class="nc nd iu le b lf lg li lj ll ne lp nf lt ng lx nv ni nj nk bi translated"><code class="fe nq nr ns nt b">target</code>，它指的是正在使用装饰器的类的构造函数或原型。</li><li id="846c" class="nc nd iu le b lf nl li nm ll nn lp no lt np lx nv ni nj nk bi translated"><code class="fe nq nr ns nt b">key</code>，它指的是您正在使用装饰器的类属性。</li></ol><p id="6bdc" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">当使用<code class="fe nq nr ns nt b">target[key]</code>时，您将获得属性内部的值(该类实例的值)。这个超级有用！</p><p id="c9f6" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated"><code class="fe nq nr ns nt b">Class decorator</code>函数不能访问任何属性值。这就是为什么类装饰器更适合添加属性。对于修改属性值来说不是很有用。这是可能的，但会带来副作用。</p><p id="5fca" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">让我们创建我们的球员姓名表情符号装饰器，根据球员类型在球员姓名后添加表情符号:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu lb l"/></div></figure></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="b6b5" class="mf mg iu bd mh mi mj mk ml mm mn mo mp ka mq kb mr kd ms ke mt kg mu kh mv mw bi translated">吸气剂</h1><p id="cae2" class="pw-post-body-paragraph lc ld iu le b lf mx jv lh li my jy lk ll mz ln lo lp na lr ls lt nb lv lw lx in bi translated"><code class="fe nq nr ns nt b">getter</code>函数用于获取使用属性装饰器的类的属性值。</p><p id="1f13" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">在这个函数中，我们可以访问这个类的实例。在return语句中，我们返回<code class="fe nq nr ns nt b">val</code>，它包含该属性的值。接下来，我们调用<code class="fe nq nr ns nt b">getEmoji(this.type)</code>，它根据玩家类型给出正确的表情符号。</p><p id="16d0" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">如果我们试图在不传递<code class="fe nq nr ns nt b">this</code>变量的情况下访问<code class="fe nq nr ns nt b">getEmoji()</code>函数中的<code class="fe nq nr ns nt b">this</code>，我们会得到一个错误。这是因为我们只能访问<code class="fe nq nr ns nt b">getter</code>函数中<code class="fe nq nr ns nt b">PlayerCharacter</code>的实例。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="543d" class="mf mg iu bd mh mi mj mk ml mm mn mo mp ka mq kb mr kd ms ke mt kg mu kh mv mw bi translated">作曲者</h1><p id="135d" class="pw-post-body-paragraph lc ld iu le b lf mx jv lh li my jy lk ll mz ln lo lp na lr ls lt nb lv lw lx in bi translated">使用<code class="fe nq nr ns nt b">setter</code>，我们可以改变类属性实例的值。在这种情况下，我没有改变它，但增加了一个表情符号。</p><p id="82ac" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">当我们试图在那里添加表情符号时，我觉得这听起来很合理，但我们会得到一个错误。这是因为我们无法访问<code class="fe nq nr ns nt b">setter</code>中类的整个实例。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="1ddd" class="mf mg iu bd mh mi mj mk ml mm mn mo mp ka mq kb mr kd ms ke mt kg mu kh mv mw bi translated">定义属性</h1><p id="b588" class="pw-post-body-paragraph lc ld iu le b lf mx jv lh li my jy lk ll mz ln lo lp na lr ls lt nb lv lw lx in bi translated">最后，我们在属性装饰器中有一个访问器描述符<code class="fe nq nr ns nt b">Object.defineProperty()</code>。这个描述符将描述我们的属性在类中的行为。注意:我强烈推荐阅读这篇文章，因为它非常强大。</p><p id="a6b8" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">在描述符内部，我们有一个<code class="fe nq nr ns nt b">getter</code>和<code class="fe nq nr ns nt b">setter</code>方法。当你想得到或改变它的值时，它们将被执行。接下来，我们将<code class="fe nq nr ns nt b">enumerable</code>设置为<code class="fe nq nr ns nt b">true</code>。这将确保它在相应对象的枚举过程中是可见的。</p><p id="ddf5" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">根据<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank"> MDN web文档</a>，“访问器描述符是由getter-setter函数对描述的属性。”</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="8604" class="mf mg iu bd mh mi mj mk ml mm mn mo mp ka mq kb mr kd ms ke mt kg mu kh mv mw bi translated">错误</h1><p id="764d" class="pw-post-body-paragraph lc ld iu le b lf mx jv lh li my jy lk ll mz ln lo lp na lr ls lt nb lv lw lx in bi translated">我猜你们中的很多人以后都会犯一些错误。(<em class="nw">喜欢我</em>😉)希望这些解决方案能进一步帮助您。</p><h2 id="b5f1" class="nx mg iu bd mh ny nz dn ml oa ob dp mp ll oc od mr lp oe of mt lt og oh mv oi bi translated">不影响这个</h2><p id="fcb9" class="pw-post-body-paragraph lc ld iu le b lf mx jv lh li my jy lk ll mz ln lo lp na lr ls lt nb lv lw lx in bi translated">可能会出现这样的错误。<a class="oj ok ep" href="https://medium.com/u/dd2a1653ff14?source=post_page-----1c9db23b6ca1--------------------------------" rel="noopener" target="_blank">纳撒尼尔可能</a>在<a class="ae kz" href="https://medium.com/@nathaniel.may22/any-idea-how-to-handle-the-errors-related-to-the-noimplicitthis-tsconfig-json-complieroption-62b527add101" rel="noopener">评论</a>中问过这个问题。</p><pre class="kk kl km kn gu ol nt om on aw oo bi"><span id="1a97" class="nx mg iu nt b gz op oq l or os">'this' implicitly has type 'any' because it does not have a type annotation.</span></pre><p id="3a22" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">一个快速但肮脏的解决方法是在tsConfig.json中将<code class="fe nq nr ns nt b">noImplicitThis</code>设置为<code class="fe nq nr ns nt b">false</code>。</p><p id="bc72" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">潜在的问题是，你在你的一个<code class="fe nq nr ns nt b">Class</code>方法中使用了一个<code class="fe nq nr ns nt b">function</code>，并且想要拥有一个<code class="fe nq nr ns nt b">Class</code>的属性。</p><p id="ef4a" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">这个问题的解决方案是使用一个箭头函数，因为它们没有自己的<code class="fe nq nr ns nt b">this</code>。<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头中的<code class="fe nq nr ns nt b">this</code>函数</a>是指它的父函数。</p><p id="041f" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">希望这将修复您的错误。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="2850" class="mf mg iu bd mh mi mj mk ml mm mn mo mp ka mq kb mr kd ms ke mt kg mu kh mv mw bi translated">结论</h1><p id="fa7a" class="pw-post-body-paragraph lc ld iu le b lf mx jv lh li my jy lk ll mz ln lo lp na lr ls lt nb lv lw lx in bi translated">感谢阅读！</p><p id="d5ac" class="pw-post-body-paragraph lc ld iu le b lf lg jv lh li lj jy lk ll lm ln lo lp lq lr ls lt lu lv lw lx in bi translated">现在，您可以在您的类中使用属性装饰器的全部功能了。如果你有任何问题，请让我知道，这样我可以帮助你。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="d03f" class="mf mg iu bd mh mi mj mk ml mm mn mo mp ka mq kb mr kd ms ke mt kg mu kh mv mw bi translated">从我这里读更多</h1><div class="ot ou gq gs ov ow"><a href="https://medium.com/better-programming/2-ways-to-resolve-duplication-in-javascript-arrays-and-objects-e377e1bdc5e1" rel="noopener follow" target="_blank"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">解决JavaScript数组和对象重复的两种方法</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">你知道如何处理重复吗？</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk kt ow"/></div></div></a></div><div class="ot ou gq gs ov ow"><a href="https://itnext.io/what-is-the-scope-in-javascript-a2add52bf9d8" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">JavaScript中的作用域是什么</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">关于全局范围内的变量、常量、Let、函数、对象和类的行为的解释。</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">itnext.io</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk kt ow"/></div></div></a></div><div class="ot ou gq gs ov ow"><a href="https://medium.com/the-human-programmer/top-5-favourite-medium-javascript-posts-6549c9a5c2e1" rel="noopener follow" target="_blank"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">最受欢迎的5篇中型JavaScript文章</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">我最喜欢的2020年2月关于JavaScript开发的帖子</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">medium.com</p></div></div><div class="pf l"><div class="pm l ph pi pj pf pk kt ow"/></div></div></a></div><div class="ot ou gq gs ov ow"><a href="https://medium.com/better-programming/make-your-javascript-objects-more-predictable-by-creating-maps-20ac1a795442" rel="noopener follow" target="_blank"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">通过创建地图使您的JavaScript对象更加可预测</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">不再有未定义的属性</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">medium.com</p></div></div><div class="pf l"><div class="pn l ph pi pj pf pk kt ow"/></div></div></a></div><div class="ot ou gq gs ov ow"><a href="https://medium.com/better-programming/7-steps-to-dockerize-your-angular-9-app-with-nginx-915f0f5acac" rel="noopener follow" target="_blank"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">使用Nginx对Angular 9应用程序进行分类的7个步骤</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">在Docker环境中设置Angular 9应用程序，并立即进行部署</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">medium.com</p></div></div><div class="pf l"><div class="po l ph pi pj pf pk kt ow"/></div></div></a></div></div></div>    
</body>
</html>