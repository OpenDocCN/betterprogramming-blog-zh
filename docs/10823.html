<html>
<head>
<title>Asp.Net Web Api Exception Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Asp.Net Web Api异常处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/elegan-handling-dependency-fails-9aef523e3b0f?source=collection_archive---------17-----------------------#2022-01-28">https://betterprogramming.pub/elegan-handling-dependency-fails-9aef523e3b0f?source=collection_archive---------17-----------------------#2022-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5df8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">集中错误处理。网络应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/833148d7f6e2fb69a46e0915c1ff1a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTI8ocsJ5KB8wsYjscRf8g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Polina Zimmerman 在<a class="ae ky" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>上拍摄的照片</p></figure><p id="7dac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Web服务或web APIs是当今与web或移动应用程序通信的最常见方式之一。通常，服务依赖于其他服务、微服务或API来处理信息并将其返回给调用者，当这些依赖失败时，我们可能会向调用者返回一个错误。</p><p id="188e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然调用者不需要关于错误的任何技术细节，但返回一条信息是非常重要的，这条信息允许开发团队快速找出哪个依赖项失败了，并且在主体中返回自定义错误代码以及响应状态代码是实现这一点的好方法。</p><p id="3a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多使用这种方法的应用程序将所有错误代码集中在一个类中，并在依赖失败时返回它们。这种方法很好，但是它强制改变错误代码类，总是包括一个新的依赖项，或者如果任何错误代码需要更新。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="6e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了改善这种情况，我们可以使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原则</a>，该原则规定实体应该对扩展开放，但对修改关闭。我们也可以使用Robert c . Martin<a class="ae ky" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">在《干净的代码》一书中解释的“优先选择异常而不是返回错误代码”的建议</a></p><p id="4cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我将详细描述如何实现一个集中错误处理的策略，然后如何使用上面介绍的内容来改进它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="ecf3" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">错误列表类</h2><p id="89b6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">通常，它是一个非常简单的类，就像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">错误代码. cs</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="aa81" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">自定义异常</h2><p id="dfd9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">从Exception继承并公开错误代码属性的简单类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通用异常. cs</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="0dff" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">全局错误处理</h2><p id="7055" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">创建一个新类，从<code class="fe nc nd ne nf b">ExceptionFilterAttribute</code>继承，覆盖<code class="fe nc nd ne nf b">OnException</code>方法，最后将它添加到<code class="fe nc nd ne nf b">Startup</code>类中的<code class="fe nc nd ne nf b">ConfigureService</code>方法上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">globalexceptionhandlerfilter . cs</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="efed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nc nd ne nf b">OnException</code>被覆盖的方法中，我们可以定制错误体响应的格式。</p><p id="25ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，<code class="fe nc nd ne nf b">InternalErrorResponse</code>只有<code class="fe nc nd ne nf b">ErrorCode</code>属性，该属性将保存由定制的一般异常引发的定制错误代码，或者为所有未处理的异常保存500。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Startup.cs</p></figure><p id="730a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是使用我们想要识别的API的定制错误代码抛出定制异常</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="c60b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">依赖关系失败时抛出异常</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CustomErrorCodesController.cs</p></figure><p id="04cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当请求数据时，响应将是状态代码500和响应主体上的自定义错误代码</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b7294b6abd450a58a0e371fd14ae1c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*vUEuIRY-hFTsA4IKKn5ZIA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb84" class="nh md it bd me ni nj nk mh nl nm nn mk jz no ka mn kc np kd mq kf nq kg mt nr bi translated">改进解决方案</h1><p id="1d8a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在，我没有使用一般的异常类，而是创建了一个基本的异常类，它必须被扩展，必须暴露一个新的自定义错误代码。</p><p id="015e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有一个虚拟属性<code class="fe nc nd ne nf b">ErrorCode</code>,必须被子类覆盖</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">BaseException.cs</p></figure><p id="17f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个服务异常类仅设置自定义错误代码，但它们也可以自定义错误消息或覆盖其他方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FirstServiceException.cs</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SecondServiceException.cs</p></figure><p id="48f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要将异常过滤器改为查找基本异常扩展类，而不是查找一般异常，这样它就可以获得自定义错误代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">globalexceptionhandlerfilter . cs</p></figure><p id="2c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有异常到达的单个点也是调用日志方法的一个很好的候选点，基于此，我们可以向异常类添加额外的信息，例如请求属性，或者甚至覆盖<code class="fe nc nd ne nf b">ToString</code>方法以在日志中使用它。</p><p id="e15d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们只需要引发自定义异常，而不是只引发带有自定义错误代码的一般异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户异常控制器</p></figure><p id="0834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会有同样的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c07652884eedaddaf0e94117042734f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*yYlr99HIU3j5x3EqD21BVw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a71f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://github.com/edsondiasalves/api-exception-handler" rel="noopener ugc nofollow" target="_blank">库</a>中找到完整的代码。我希望你喜欢它，并且它能在你的项目中帮助你。</p><p id="506e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，下次再见。</p></div></div>    
</body>
</html>