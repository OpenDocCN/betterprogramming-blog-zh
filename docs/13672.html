<html>
<head>
<title>How To Avoid Hitting API Rate Limits Using TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用TypeScript避免达到API速率限制</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-avoid-hitting-api-rate-limits-using-typescript-8f6ab20aaa69?source=collection_archive---------10-----------------------#2022-09-15">https://betterprogramming.pub/how-to-avoid-hitting-api-rate-limits-using-typescript-8f6ab20aaa69?source=collection_archive---------10-----------------------#2022-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="06cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建TypeScript类以批量发送请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14a174b7d5a733433abe90695c8a2f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzCuyNC25q7K-kJto6AlpQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/ja/@aronvisuals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aron视觉效果</a>在<a class="ae ky" href="https://unsplash.com/s/photos/limit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">速率限制是API安全性的重要组成部分，有助于防止恶意活动并减少服务器资源的压力。然而，对于API用户来说，它们也会带来麻烦——不仅仅是不完美的代码会带来问题。如果没有适当的策略，合法流量的峰值也会导致可怕的<code class="fe lv lw lx ly b">429 "Too Many Requests"</code>错误状态。</p><p id="0005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何确保我们没有发送太多的请求呢？在本文中，我们将研究一个简单的模式，该模式将帮助我们将异步请求分批到间隔中，这些间隔可以配置为我们正在使用的API的特定速率限制。下面的示例是使用TypeScript编写的。</p><h1 id="ed56" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">构建类构造函数</h1><p id="e4ca" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当使用速率限制时，我们通常会被限制在某个时间段内的某个数量的请求:比方说，每五秒钟二十个请求。类语法为管理我们的请求提供了一种有用的方式，并允许我们为可能使用的每个API创建一个单独的实例。</p><p id="c55a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至少，我们的类应该允许我们设置给定时间间隔内允许的请求数量以及每个时间间隔持续的时间(以毫秒为单位)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们还创建了一个属性<code class="fe lv lw lx ly b">queuedRequests</code>，我们可以用它来跟踪给定时间间隔内排队的请求数量。</p><p id="13fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这种方式构建<code class="fe lv lw lx ly b">RequestScheduler</code>类将允许我们创建具有不同API需求的多个实例。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="d9cf" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">添加计划方法</h1><p id="4aa2" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">接下来，让我们创建一个<code class="fe lv lw lx ly b">schedule</code>方法，该方法接受一个函数，如果该函数超过了给定间隔中允许的最后一个函数，则通过<code class="fe lv lw lx ly b">setTimeout</code>添加一个延迟，以等待新的间隔开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="e1f2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">最后一堂课</h1><p id="6152" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们的整个类可能看起来像这样。在下面的代码片段中，我还为构造函数添加了一个<code class="fe lv lw lx ly b">debugMode</code>选项，这样我们就可以记录一些关于函数何时被触发的有用信息——以确保该方法正在工作！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="6188" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">测试它的工作情况</h1><p id="e9ab" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们测试一下我们的代码吧！首先，我们将用相对较少的请求在调试模式下创建一个新的类实例，这样更容易看到发生了什么。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="4a62" class="nc ma it ly b gy nd ne l nf ng">const requestScheduler = new RequestScheduler({<br/>  requestsPerInterval: 3,<br/>  intervalTime: 5000,<br/>  debugMode: true,<br/>});</span></pre><p id="58d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我将创建一个异步函数来模拟HTTP请求。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="937f" class="nc ma it ly b gy nd ne l nf ng">async function mockHttpRequest() {<br/>  return new Promise((<em class="nh">resolve</em>) =&gt; {<br/>    resolve("Hello World");<br/>  });<br/>}</span></pre><p id="24de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我将尝试执行这个函数11次，将每次执行包装在<code class="fe lv lw lx ly b">schedule</code>方法中。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="7be5" class="nc ma it ly b gy nd ne l nf ng">(async () =&gt; {<br/>  for (let i = 0; i &lt; 11; i++) {<br/>    await requestScheduler.schedule(mockHttpRequest);<br/>  }<br/>})();</span></pre><p id="b750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这段代码，我们会看到类似如下的日志:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="e114" class="nc ma it ly b gy nd ne l nf ng">RequestScheduler: 0.818ms #1  mockHttpRequest<br/>RequestScheduler: 3.459ms #2  mockHttpRequest<br/>RequestScheduler: 4.751ms #3  mockHttpRequest<br/><em class="nh">--- RequestScheduler: Wait 5000ms ---<br/></em>RequestScheduler: 5.007s  #4  mockHttpRequest<br/>RequestScheduler: 5.010s  #5  mockHttpRequest<br/>RequestScheduler: 5.012s  #6  mockHttpRequest<br/><em class="nh">--- RequestScheduler: Wait 5000ms ---<br/></em>RequestScheduler: 10.014s #7  mockHttpRequest<br/>RequestScheduler: 10.017s #8  mockHttpRequest<br/>RequestScheduler: 10.019s #9  mockHttpRequest<br/><em class="nh">--- RequestScheduler: Wait 5000ms ---<br/></em>RequestScheduler: 15.021s #10 mockHttpRequest<br/>RequestScheduler: 15.024s #11 mockHttpRequest</span></pre><p id="42e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功！如果你想自己玩这个代码，请查看<a class="ae ky" href="https://codepen.io/BretCameron/pen/ZEoLOgQ" rel="noopener ugc nofollow" target="_blank">这个代码笔</a>。(一定要打开控制台看日志！)</p><h1 id="f40c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">真实世界的用例</h1><p id="21f1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这种模式的强大之处部分在于我们可以用它来协调应用程序中的请求。我发现这种方法有用的一个真实例子是在Next.js应用程序的构建步骤中，我在构建时静态生成HTML，部分依赖于第三方API。</p><p id="9698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的网站有一个第三方内容管理系统(用于托管博客文章)和第三方申请人跟踪系统(用于托管工作列表)。每个API都有自己的速率限制，对每个API发出请求的查询可以在许多不同的文件中找到。此外，Next.js在幕后控制了很多关于何时以及如何构建页面的信息。</p><p id="e3af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理这个问题，我导出了下面的<code class="fe lv lw lx ly b">RequestScheduler</code>实例:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="79c9" class="nc ma it ly b gy nd ne l nf ng">export const cmsScheduler = new RequestScheduler({<br/>  requestsPerInterval: 10,<br/>  intervalTime: 1_000,<br/>});</span><span id="604a" class="nc ma it ly b gy ni ne l nf ng">export const atsScheduler = new RequestScheduler({<br/>  requestsPerInterval: 50,<br/>  intervalTime: 10_000,<br/>});</span></pre><p id="93d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在页面的构建步骤中，我可以调用，例如:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="c8a7" class="nc ma it ly b gy nd ne l nf ng">const blogPosts = await <!-- -->cmsScheduler.schedule(<!-- -->getBlogPosts);<br/>const jobListings = await <!-- -->atsScheduler.schedule(<!-- -->getJobListings);</span></pre><p id="aeb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，随着网站的扩展，我不再需要担心达到我们的第三方API的速率限制！</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="2f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nh">感谢阅读！敬请关注更多内容。</em></p></div></div>    
</body>
</html>