# 每天都应该遵循的 7 个软件开发原则

> 原文：<https://betterprogramming.pub/7-software-development-principles-that-should-be-embraced-daily-c26a94ec4ecc>

## 《吻》、《干》、《YAGNI》等等

![](img/f5c858c42077d1d1e2af03da124471e1.png)

丹尼尔·麦卡洛在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

成为一名优秀的程序员是技能和一些常识的结合。这是关于务实和知道什么是更适合你的问题的解决方案。当面临挑战时，有一些软件原则将指导您选择最正确的方法。

这些是每个开发人员都应该知道并不时重温的一套准则。编程的时候把它们当做你的秘方吧。

坚持应用这些原则会让你从中级到高级软件工程师的转变更加容易。你可能会发现(很可能)你在凭直觉应用其中的一些。

有很多原则。我们将只关注七个最重要的问题。拥抱这些会帮助你提高，成为一个更好的程序员。

# 1.你不会需要它的——YAGNI

这很简单，不言自明——但不是每个人都遵循它。当添加代码时，确保它是立即需要的。不要因为你认为以后可能会有用而让代码挂起。

这适用于重构。如果你重构一个方法/类/文件，你不应该不愿意移除任何被挂起的方法。即使它们在过去有用，现在也不再有用了。

可能有一天会再次需要它们，您可以使用 git 存储库让它们起死回生。

# 2.不要重复你自己——干

这个概念最初是由安迪·亨特和迪夫·托马斯的书*《实用程序员:从熟练工到大师》提出的。*

这个想法围绕着拥有一个单一的真理来源。那到底是什么？

> “在信息系统设计和理论中，单一真理源(SSOT)是构造信息模型和相关数据模式的实践，使得每个数据元素只在一个地方被掌握(或编辑)。… SSOT 系统提供真实、相关和可参考的数据。”
> 
> —维基百科

保持一个单一的真实来源将有助于拥有一个更加坚实和更加自我解释的代码库。

拥有重复的代码是一种浪费。你必须在两个地方保持相同的逻辑，在两个地方做测试，当一个地方改变时，你必须记得改变另一个地方。

大多数时候，代码重复是由于缺乏对系统的了解。在编码任何东西之前，务实一点:四处看看。也许这个特性是在其他地方实现的。也许这种商业逻辑已经存在于其他地方。重用代码总是一个明智的选择。

# 3.简单点，笨蛋——接吻

这个设计原则是美国海军早在 1960 年就注意到的设计原则。这一原则表明，越简单的系统工作得越好，越可靠。

你会发现这一原则与 20 世纪 70 年代的“重新发明轮子”有许多相似之处。它被用作商业和广告的隐喻。

应用于软件开发，意思就是——不要过度工程化。有时候最聪明的解决方案也是最简单的。构建简单高效的代码是美好的。

如今，一个最常见的错误是仅仅因为新工具闪闪发光就试图使用它们。开发人员不应该仅仅因为他们是新的就去使用最新的技术，而是因为他们适合这项工作。

# 4.预先的大设计

这种软件开发方法是至关重要的——并且经常被忽视。在进入实现部分之前，请确保一切都经过深思熟虑。

> “很多时候，预先考虑好事情可以让我们在以后的开发中避免严重的问题。…在规范中进行这一更改需要一两个小时。如果我们在代码中做了这样的改变，它将会增加几周的时间。我无法告诉你我有多相信预先的大设计，极限编程的支持者认为这是一种诅咒。通过使用 BDUF，我一直在节省时间并做出更好的产品，我很自豪使用它，不管 XP 狂热者怎么说。他们在这一点上是错误的，我对此再清楚不过了。”
> 
> —乔尔·斯波尔斯基

很多开发人员觉得还没开始编码就没有进步。这是错误的。通过制定一个具体的计划，你可以避免可能不得不从零开始。

有时候，其他人需要参与到设计的缺陷中。这些对话越早开始，对每个人都越好。

一个非常常见的反驳观点是，解决问题的成本低于计划问题所需的时间。这当然不是真的。用户面临的错误/矛盾越少，他们的体验就越好。你可能再也没有机会得到它们了。

# 5.固体

这是最著名的软件原理。Solid 是以下单词的首字母缩写:

## s)单一责任原则

它的重要性怎么强调都不为过。每个对象、类和方法都需要有一个单一的职责。如果你的对象/类/方法做得太多，你最终会得到众所周知的意大利面条代码。这里有一个例子:

这种方法看起来无害，但它做得太多了:

1.  将对象保存在 BE 中
2.  处理 UI 通知
3.  一些导航

另一个副作用是测试。测试纠缠在一起的功能更加困难。

## 笔关闭原理

软件实体应该对扩展开放，但对修改关闭。我的意思是，我们不应该仅仅通过添加更多我们需要的功能来覆盖方法/类。

继承是一个很好的方法。在 JavaScript 中，这主要是通过组合来完成的。

💁一个经验法则:如果你修改一个实体使其可扩展——你第一次就违背了这个原则。

## **L) L** 伊斯科夫替代原理

这个原则说，超类的对象必须可以被它们的子类的对象替换，并且应用程序应该仍然像预期的那样工作。

## **I) I** 界面偏析原理

这个原则是罗伯特·c·马丁在为施乐咨询时定义的，这是显而易见的。

> *“客户不应该被迫依赖他们不使用的接口。”*
> 
> 罗伯特·马丁

软件应该被分割成多个独立的部分。应尽可能减少副作用，以确保独立性。

确保你没有强迫对象实现他们永远不需要的方法。这里有一个例子:

不是所有的动物都可以`fly`、`walk`或`swim`，所以这些方法不应该是接口的一部分，或者应该保持可选。

## **D) D** 依赖反转原理

这个原则怎么强调都不为过。我们应该依靠抽象，而不是具体的实现。软件要低耦合，高内聚。

你不应该关心事物是如何建造的，而应该关心它们是如何工作的。一个简单的例子是在 JavaScript 中使用日期。您可以构建自己的抽象层。这样，如果您改变了`Date`提供商，您将只有一个地方需要改变，而不是一千个。

有时，构建抽象层需要一些努力，但从长远来看，这是值得的。

作为一个例子，check [date-io](https://github.com/dmtrKovalenko/date-io) ，它创建了一个抽象层，使您能够与多个`Date`供应商一起使用它。

# 6.避免过早优化

过早优化是鼓励开发人员在证明有必要之前执行不必要的优化的做法。我认为如果你申请亲吻和 YAGNI，你不应该爱上这个。

不要误解我的意思，尝试预测一些不好的事情会发生是好的，但是在进入实现细节之前，你需要检查那些优化是否真的有用。

一个非常简单的例子是缩放。你不会购买 40 台服务器，因为你认为你的新应用会成为病毒。相反，您需要做的是根据需要添加服务器。

过早的优化会导致代码延迟，从而增加特性上市的时间成本。

许多人认为过早的优化是万恶之源。

# 7.奥卡姆剃刀

> “奥卡姆剃刀、奥卡姆剃刀、奥查姆剃刀([拉丁文](https://en.wikipedia.org/wiki/Latin_language) : *诺瓦库拉奥卡姆*)，或者简约法则([拉丁文](https://en.wikipedia.org/wiki/Latin_language) : *lex parsimoniae* )就是“实体没有必要就不应该相乘”的解题[原则](https://en.wikipedia.org/wiki/Principle)、[【1】](https://en.wikipedia.org/wiki/Occam%27s_razor#cite_note-1)[【2】](https://en.wikipedia.org/wiki/Occam%27s_razor#cite_note-2)或者更简单地说，最简单的解释通常是正确的解释。”
> 
> 维基百科(一个基于 wiki 技术的多语言的百科全书协作计划ˌ也是一部用不同语言写成的网络百科全书ˌ 其目标及宗旨是为全人类提供自由的百科全书)ˌ开放性的百科全书

在编程界是什么意思？不要创建不需要的实体。务实一点——考虑是否需要这些，因为它们可能会增加代码库的复杂性。

# 包裹

这些原理不是很复杂。事实上，它们的简单正是它们如此美丽的原因。如果你不知所措，不要这样。现在，试着提高你的意识，试着把它们一次一个地纳入你的日常生活中。

坚持一些基本但强大的原则将帮助你成为一名更好的程序员，并对你为什么做事情有一个更清晰的想法。

如果你直觉地运用了其中的大部分，那么有一个顿悟的时刻是很好的，在这个时刻你会明白为什么你要以某种方式做事。

更多的编程内容将很快出现在你面前。

感谢阅读。

你不是中等会员吗？在这里支持我[成为其中一员](http://dioxmio.medium.com/membership)。

# 相关文章

[](/7-habits-of-productive-developers-bce60d880907) [## 高效开发人员的 7 个习惯

### 建立正确的习惯来保持每天的工作效率

better 编程. pub](/7-habits-of-productive-developers-bce60d880907) [](/typescript-a-gentle-introduction-to-mapped-types-f65e45fa2598) [## TypeScript:映射类型的简明介绍

### 学习构建自己的一套 TypeScript 工具

better 编程. pub](/typescript-a-gentle-introduction-to-mapped-types-f65e45fa2598)