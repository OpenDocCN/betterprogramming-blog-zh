# 以下是我的团队正在使用的 MySQL 开发规范

> 原文：<https://betterprogramming.pub/here-are-the-mysql-development-specifications-my-team-is-using-b7537469d0f1>

## 来提升我们的结构设计！

![](img/a935e2cee36d253b22eea948a5def258.png)

Arnel Hasanovic 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 数据库对象命名约定

## *1.1 数据库对象*

数据库对象是数据库的组成部分，常见的有:表、索引、视图、图表、默认值、规则、触发器、存储过程、用户等。

命名约定是指数据库对象的命名约定，如`SCHEMA`、`TABLE`、`INDEX`、`CONSTRAINTS`等。

## *1.2 数据库对象全局命名约定*

*   用有意义的英文单词命名，单词之间用下划线隔开。
*   名称只能使用英文字母、数字下划线，并且以英文字母开头。
*   避免使用备份、调用、组等 MySQL 保留字。
*   所有数据库对象都使用小写字母。事实上，可以在 MySQL 中设置区分大小写。为了确保一致性，我们在这里将所有小写表示标准化。

## *1.3 数据库命名约定*

*   数据库名称应尽可能不超过 30 个字符。
*   数据库命名一般是项目名称+代表库含义的缩写，比如 IM 项目的工作流数据库，可以是`im_flow`。
*   创建数据库时，必须添加默认字符集和归类子句。默认字符集是 UTF8 (dumbo 已经迁移到使用 utf8mb4)。
*   名称应该是小写的。

## *1.4 表格命名约定*

*   常规表的表名以 t_ 开头，t 代表表的含义。命名规则为 t + module(含 module 含义的缩写)+ table(含 table 含义的缩写)，如用户模块的教育信息表:`t_user_eduinfo`。
*   临时表(RD、QA 或 DBA 用于临时数据处理的表)，命名规则:temp 前缀+ module + table + date 后缀:`temp_user_eduinfo_20220101`。
*   备份表(用于保存和归档历史数据或灾难恢复的数据)命名规则，bak 前缀+模块+表+日期后缀:`bak_user_eduinfo_20220101`。
*   同一模块的表尽量使用相同的前缀，表名尽量表达意思。
*   由下划线分隔的多个单词`_`。
*   常规表的表名尽量不要超过 30 个字符。`temp`表和`bak`表要尽量短，名字要小写。

## *1.5 字段命名约定*

*   字段名要求有代表其实际意义的英文单词或缩写，单词之间用下划线`_`连接，如`service_ip`、`service_port`。
*   表之间含义相同的字段必须有相同的名称。比如`A`表和`B`表有一个创建时间，应该统一为 create_time，不一致会很混乱。
*   由下划线分隔的多个单词`_`。
*   字段名尽量不要超过 30 个字符，名称要小写。

## *1.6 索引命名约定*

*   使用`uni` +字段名:`create unique index uni_uid on t_user_basic(uid)`来命名唯一索引。
*   非唯一索引使用`idx` +字段名:`create index_idx_uname_mobile on t_user_basic(uname,mobile)`命名。
*   多个单词用下划线分隔`_`。
*   索引名称应尽可能不超过 50 个字符。名称应该是小写的。索引字段的组合不能太多，否则不利于查询效率的提高。
*   对于由多个单词组成的列名，尽可能取代表含义的缩写，如`test_contact`表的`member_id`和`friend_id`上的组合索引:`idx_mid_fid`。
*   了解组合索引的最左前缀原则，避免重复索引构造。如果`(a,b,c)`成立，就相当于`(a), (a,b), (a,b,c)`成立。

## *1.7 视图命名约定*

*   视图名称以`v`开头，表示视图，完整的结构是`v`的缩写+视图内容含义。
*   如果视图仅来自单个表，则为`v`+表名。如果视图关联多个表，用 v+下划线`_`连接多个表名，视图名尽量不要超过 30 个字符。缩写用于 30 个以上的字符。
*   如果没有特殊需要，严禁开发人员创建视图。
*   名称应该是小写的。

## *1.8 存储过程命名约定*

*   存储过程的名称以`sp`开头，表示存储过程(存储过程)。之后多个单词用下划线`_`连接。存储过程的名称应该反映其功能。存储过程名称应尽可能不超过 30 个字符。
*   存储过程中的输入参数以`i_`开头，输出参数以`o_`开头。
*   名称应该是小写的。

```
create procedure sp_multi_param(in i_id bigint,in i_name varchar(32),out o_memo varchar(100))
```

## *1.9 函数命名约定*

*   函数名以`func`开头，表示函数。之后多个单词用一个下划线`_`连接，函数名要体现其功能。函数名尽量不要超过 30 个字符。
*   名称应该是小写的。

```
create function func_format_date(ctime datetime)
```

## *1.10 触发器命名约定*

*   触发器以`trig`开头，表示一个触发器。
*   基本部分描述由触发器添加的表。触发器名称应尽可能不超过 30 个字符。
*   后缀(`_i`、`_u`、`_d`)表示触发条件的触发方式(插入、更新或删除)。
*   名称应该是小写的。

```
DROP TRIGGER IF EXISTS trig_attach_log_d;CREATE TRIGGER trig_attach_log_d AFTER DELETE ON t_dept FOR EACH ROW;
```

## *1.11 约束命名约定*

*   唯一约束:uk_tablename_field name。`uk`是唯一键的缩写。例如，为一个部门的部门名添加一个唯一约束，以确保没有重名，如下:`alter table t_dept add constraint un_name unique(name)`。
*   外键约束:fk_table name，后跟外键所在的表名和对应的主表名(不包括`t_`)。子表名和父表名由下划线`_`分隔。如下:`alter table t_user add constraint fk_user_dept foreign key(depno) references t_dept(id)`。
*   非空约束:如无特殊需要，建议所有字段默认为非空，不同数据类型必须给出默认值。
*   出于性能考虑，如果没有特殊需要，建议不要使用外键。引用完整性由代码控制。这也是我们的惯例，从程序角度进行完整性控制，但如果不注意，也会产生脏数据。
*   名称应该是小写的。

```
`id` int(11) NOT NULL,
`name` varchar(30) DEFAULT '',
`deptId` int(11) DEFAULT 0,
`salary` float DEFAULT NULL,
```

## *1.12 用户命名惯例*

*   生产中使用的用户命名格式是 code_application。
*   只读用户的命名规则是 read_application。

# 数据库对象设计规范

## *1.1 如何选择存储引擎*

如果没有特殊要求，必须使用 InnoDB 存储引擎。

当前默认引擎可以用`show variables like 'default_storage_engine`查看。主要有 MyISAM 和 InnoDB，从 5.5 版本开始默认使用 InnoDB 引擎。

基本区别在于:MyISAM 类型不支持高级处理，比如事务处理，而 InnoDB 类型支持。

MyISAM 类型表强调性能，它比 InnoDB 类型执行得更快，但不提供事务支持，而 InnoDB 提供事务支持和高级数据库特性，如外键。

## *1.2 字符集的选择*

除非另有规定，否则必须使用 utf8 或 utf8mb4。

在中国，选择支持中文和各种语言的 utf8 格式是最好的方式。MySQL 在 5.5 之后增加了 utf8mb4 编码。mb4 表示大部分字节 4，它是专门为与四字节 unicode 兼容而设计的。

所以，utf8mb4 是 utf8 的超集，除了将编码改为 utf8mb4 之外，不需要其他转换。当然，为了节省空间，通常使用 utf8 就足够了。

您可以使用以下脚本来查看数据库的编码格式。

```
SHOW VARIABLES WHERE Variable_name LIKE 'character_set_%' OR Variable_name LIKE 'collation%';-- orSHOW VARIABLES Like '%char%';
```

## *1.3 表格设计规范*

*   应尽可能减少不同应用对应的数据库表之间的关联，不允许外键在表之间关联，以确保组件对应的表之间的独立性，并为重构系统或表结构提供可能性。当前的行业实践通常通过过程来控制引用完整性。
*   从表格设计的角度来看，数据库设计不应该是针对整个系统进行的而是应该按照系统架构中的组件进行划分，数据库设计应该按照每个组件所处理的业务进行。
*   该表必须有主键。主键的优点是唯一标识、有效引用、高效检索，所以一般情况下尽量有主键字段。
*   一个字段只有一个含义。
*   该表不应有重复的列。
*   复杂数据类型(数组、自定义等)的使用。)是禁止的。JSON 类型的使用取决于具体情况。
*   需要连接的字段(连接键)的数据类型必须绝对一致，以避免隐式转换。例如，关联字段都是 Int 类型。
*   设计至少要满足第三范式，尽量减少数据冗余。一些特殊场景允许非规范化设计，但是冗余字段的设计需要在项目评审期间进行解释。
*   文本字段存储为大量文本，必须放在单独的表中，并通过 PK 与主表关联。如果没有特殊需要，禁止使用文本和 BLOB 字段。
*   需要定期删除(或转移)过期数据的表可以通过子表来解决。我们的做法是将操作频率较低的历史数据按照 2/8 规则迁移到历史表中，并按照时间或 Id 制作切割点。
*   单个表格的字段数量不要太多，建议最多不超过 50 个。过宽的表对性能也有很大的影响。
*   当 MySQL 处理大型表时，性能开始显著下降。因此，建议单个表的物理大小限制在 16GB 以内，表中的数据行数控制在 2000W 以内。
*   行业内的规则是，超过 2000W 后，性能开始显著下降。不过这个值是有弹性的，你可以根据实际情况来判断。比如阿里的标准是 500W，百度的确实是 2000W。事实上，无论表格是否宽，单行数据所占的空间都起着作用。
*   如果数据量或数据增长很大程度上在前期规划，那么在设计评审中就要加入表拆分策略，会有专门的文章来分析数据拆分方法:垂直拆分(垂直拆分和垂直子表)、水平拆分(子库子表和内部子表)。
*   没有特殊要求，严禁使用分区表。

## *1.4 现场设计规范*

*   `INT`:如无特殊需要，使用`UNSIGNED INT`存储整数。整数字段后的数字表示显示长度。例如，`id int(11) NOT NULL`
*   `DATETIME`:所有需要精确到时间(时、分、秒)的字段都使用`DATETIME`而不是`TIMESTAMP`类型。
*   对于`TIMESTAMP`，它将当前时区的写入时间转换为 UTC(通用标准时间)进行存储。查询时，将其转换为客户端的当前时区并返回。而对于`DATETIME`，不做任何改动，输入输出基本保持原样。
*   另外，`DATETIME`储存的范围也比较大:
*   时间戳可以存储的时间范围是:`1970–01–01 00:00:01.000000’ to ‘2038–01–19 03:14:07.999999`。
*   `DateTime`可以存储的时间范围是:`1000–01–01 00:00:00.000000’ to ‘9999–12–31 23:59:59.999999`。
*   但在特殊情况下，`TIMESTAMP`更适合跨时区的业务。
*   `VARCHAR`:所有的动态长度字符串都使用`VARCHAR`类型，类似于 status 等有限类别的字段，也使用能清楚表示实际意义的字符串，不应该用`INT; VARCHAR( N)`等数字代替
*   `N`代表字符数，不是字节数。例如`VARCHAR(255)`最多可以存储 255 个字符(字符包括英文字母、汉字、特殊字符等。).但是`N`要尽量小，因为一个 MySQL 表中所有`VARCHAR`字段的最大长度是 65535 字节，存储的字符数由选择的字符集决定。
*   如果 UTF8 存储一个最多三个字节的字符，那么`varchar`在存储长度占三个字节的字符时，不应该超过 21845 个字符。同时，在进行排序、创建临时表等内存操作时，会使用`N`的长度来申请内存。(如无特殊需要，原则上单个 varchar 类型字段不允许超过 255 个字符)
*   `TEXT`:只有当字符数可能超过 20000 时，才能使用`TEXT`类型存储字符数据，因为所有 MySQL 数据库都会使用 UTF8 字符集。
*   所有使用`TEXT`类型的字段都必须从原表中拆分出来，用原表的主键组成另一个表进行存储，与大文本字段隔离的目的是。如无特殊需要，请勿使用`MEDIUMTEXT`、`TEXT`或`LONGTEXT`类型
*   精确的浮点数据存储需要`DECIMAL`，严禁使用`FLOAT`和`DOUBLE`。
*   如果没有特殊需要，尽量不要使用 BLOB 类型
*   如果没有特殊需要，建议对字段使用`NOT NULL`属性，可以用默认值代替`NULL`
*   自动递增字段的类型必须是整数，并且必须是`UNSIGNED`。推荐类型为`INT`或`BIGINT`，自动递增字段必须是主键或主键的一部分。

## *1.5 指标设计规范*

*   指数歧视。
*   必须在具有高索引选择性(区分)的列上创建索引。选择性计算为`selectivity = count(distinct c_name)/count(*)`；如果判别结果小于 0.2，不建议使用该列在顶部创建索引，否则，很可能会降低 SQL 的执行速度。
*   遵循最左边的前缀。
*   为了确定需要形成复合索引的多个字段，建议在设计时将具有高选择性的字段放在第一位。使用时，复合索引的第一个字段必须在 where 条件中，并且需要根据最左边的前缀规则进行匹配。
*   外键是被禁止的，完整性可以在程序级别被约束。
*   如果需要为文本类型字段创建索引，必须使用前缀索引。
*   单个表中的索引数量理论上应控制在 5 个以内。经常会有大批量的插入和更新操作表，应该尽量少建立索引。理论上，索引建立的原则是多读少写。
*   需要在索引后添加`ORDER BY`、`GROUP BY`和`DISTINCT`字段，形成覆盖索引。
*   正确理解和计算指标字段的区分度。文中有计算规则。区分度高的索引可以快速定位数据。如果区分度太低，指数就不能得到有效利用。可能需要扫描大量数据页，而不使用它。索引没有区别。
*   正确理解和计算前缀索引的字段长度。文中有判断规则。合适的长度必须确保高度的区分度和最合适的索引存储容量。只有达到最优状态，才能保证有效率的指标。
*   对于关节索引注意最左边的匹配原则:必须按照从左到右的顺序进行匹配。MySQL 会一直向右匹配索引，直到遇到范围查询(`>`、`<`、`between`、`like`)，然后停止匹配。
*   比如`depno=1`和`empname>"`和`job=1`。如果(depno，empname，job)订单的索引已建立，则作业将不会使用该索引。
*   按需获取策略。查询记录时，不要一出现就使用`*`，只取需要的数据。如果可能，尽量只使用索引覆盖，这样可以减少表返回操作，提高效率。
*   正确判断是否使用联合索引(上面关于联合索引使用的章节描述了判断规则)，还可以进一步分析索引下推(IPC)，减少返回表的操作，提高效率。
*   避免索引失效的原则:禁止在索引字段上使用函数和运算符，这会使索引失效。这其实就是保证指标对应的字段“干净”的需要。
*   避免不必要的类型转换。当使用数值比较字符串字段时，索引将无效。
*   模糊查询“%value%”将使索引无效，并将其转换为全表扫描，因为无法确定扫描的范围，但“value%”可以有效地使用索引。
*   索引覆盖排序字段，可以减少排序步骤，提高查询效率
*   尽可能扩展索引，除非必要，否则不要创建索引。比如表中已经有一个 an 的索引，现在需要增加一个`(a, b)`的索引，那么只需要修改原来的索引就可以了。

例如:比如一个品牌表，建立的索引如下，主键索引，唯一索引。

```
PRIMARY KEY (`id`), UNIQUE KEY `uni_brand_define` (`app_id`,`define_id`)
```

当你同事的业务代码中的检索语句如下时，你应该马上得到警告，即没有覆盖索引，也没有遵循最左前缀原则:

```
select brand_id,brand_name from ds_brand_system where status = ? and define_id = ? and app_id = ?
```

建议更改为:

```
select brand_id, brand_name from ds_brand_system where app_id = ? and define_id = ? and status = ?
```

## *1.6 受限设计规范*

*   PK 应该是有序的和无意义的，由开发人员定制，尽可能短，并在一个自动递增的序列。
*   如果表中除 PK 外还有唯一约束，可以在数据库中创建前缀为`uk_`的唯一约束索引。
*   不允许更新 PK 字段。
*   禁止创建由程序控制的外键约束。
*   如果没有特殊需要，所有字段都必须添加一个非空约束，即不能为空。
*   如果没有特殊需要，所有字段都必须有默认值。

# SQL 使用规范

## *1.1 选择检索的规范性*

*   尽量避免使用`select *`。在 join 中使用`select *`，语句可能会导致只需要访问索引就能完成的查询需要返回表中取数据。
*   一个是检索大量不必要的数据，对于宽表来说是灾难；
*   严禁在没有任何条件的情况下使用`select * from t_name`。道理是一样的，会变成全表全场扫描。
*   MySQL 中的文本类型字段存储:(a .)不与其他普通字段一起存储，因为读取效率低，而且还会影响其他轻量级字段的访问效率。(b .)如果不需要文本型字段，使用`select *`，执行会消耗大量 IO，效率很低。
*   可以使用相关函数来检索字段，但应尽量避免使用`now(), rand(), sysdate()`等结果不确定的函数。严禁在 Where 条件中的筛选条件字段上使用任何函数，包括数据类型转换函数。大量的计算和转换会导致效率低下，这在索引中也有描述。
*   所有分页查询语句都需要有排序条件，否则，很容易造成混乱。
*   将`or`换成`in() / union()`，效率会更好，注意 ins 数量少于 300
*   严禁使用`%`前缀进行模糊前缀查询:如:`select a,b,c from t_name where a like '%name';`，可以使用`%`模糊后缀查询如`select a, b from t_name where a like 'name%';`。
*   避免使用子查询，可以将子查询优化为`join`操作。

通常情况下，当子查询在子句中，并且子查询是简单 SQL(不包括`union, group by, order by, limit`的子句)时，子查询可以转换为关联查询进行优化。

子查询性能不佳的原因:

*   子查询的结果集不能使用索引。通常，子查询的结果集将存储在临时表中。内存临时表和磁盘临时表都没有索引，所以查询性能会受到一定程度的影响。
*   尤其是对于返回大结果集的子查询，对查询性能的影响更大。
*   由于子查询将生成大量临时表，并且没有索引，因此它将消耗太多的 CPU 和 IO 资源，从而导致大量缓慢的查询。

## *1.2 规范操作*

禁止使用没有字段列表的 INSERT 语句。

例如:`insert into values ('a', 'b', 'c');`应使用`insert into t_name(c1, c2, c3) values ('a', 'b', 'c');`。

大容量写操作(更新、删除、插入)需要多个批处理操作。

大批量操作可能会导致严重的主-次延迟，尤其是在主-次模式下，大批量操作可能会导致严重的主-次延迟，因为次映像需要从主映像的 bin-log 中读取日志以进行数据同步。

当 bin 日志采用行格式时，会生成大量日志。

*感谢您阅读本文。*

*继续关注更多信息。*