<html>
<head>
<title>A Practical Introduction to Dynamic Programming for People Who Hate Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为讨厌动态编程的人提供的动态编程实用介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-practical-introduction-to-dynamic-programming-for-people-who-hate-dynamic-programming-765fa91642f1?source=collection_archive---------12-----------------------#2020-01-27">https://betterprogramming.pub/a-practical-introduction-to-dynamic-programming-for-people-who-hate-dynamic-programming-765fa91642f1?source=collection_archive---------12-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f9f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">DP和5个清晰解释的示例问题的介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5951b31ffa09764c9f7584894545d357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNpbA269B023T5MGrCc-DQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一张与我相似的凌乱的桌子——来自Unsplash。</p></figure><p id="9dc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在所有的编程基础中，我发现动态编程是最难的。有什么比写文章更好的学习方法呢？我们先跳进去简单介绍一下，然后解决几个问题！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="fc40" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是动态编程？</h1><h2 id="d706" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">一堂历史课</h2><p id="7bc0" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">动态规划(DP)是由兰德公司的理查德·贝尔曼开发的一种优化技术。在20世纪50年代，数学研究并不是优先考虑的事情——尤其是贝尔曼的老板。</p><p id="ec5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，DP正是如此。为了向雇主隐瞒贝尔曼正在进行数学研究的事实，贝尔曼选择了“动态编程”这个名字。引用贝尔曼自己的话:</p><blockquote class="nk"><p id="6e36" class="nl nm it bd nn no np nq nr ns nt lt dk translated">"这甚至不是一个国会议员可以反对的事情。"</p></blockquote><h2 id="f872" class="mt mc it bd md mu nu dn mh mw nv dp ml lh nw mz mn ll nx nb mp lp ny nd mr ne bi translated">为什么是DP？</h2><p id="cf41" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">动态规划用于解决传统技术难以解决的某一子类问题。它比暴力破解更快更有效。让我们用一个示例问题来解释暴力破解和动态编程解决方案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/06ce207051794355a59e8087d346161c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*-KrLQdoLnZBiulsPpxRq1Q.jpeg"/></div></figure><p id="17ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你有三枚硬币，价值分别是V₁ = 1，V₂ = 3，V₅ = 5。找出最小数量的硬币<strong class="la iu"> </strong>，使它们的总和为S =11。你可以重复硬币任意次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/2b9f01b984dd8aaa2e2936614d83bb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*-pIdCWqMu4N91m2JbrcGtg.jpeg"/></div></figure><p id="761d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对人类来说，一开始解决这个问题相当简单。马上就会弹出一个解决方案:5+5+1，也就是三个硬币。这是这个问题的最佳解决方案。</p><p id="1e94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果你有1000个硬币，你要求和到S = 12390呢？一个最佳的解决方案可能不会马上出现在你面前，需要一些反复试验。</p><p id="1b43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你怎么能确定这是最优解？你可以找到这些硬币的每一个组合，并看到解决方案是最小的一个。你要不断选择各种组合，看看它们是否等于S，以及是否是硬币的最小数目。</p><p id="02cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是所谓的暴力方法。随着<em class="ob"> N </em>(硬币数量)值的增加，手动求解变得越来越困难。随着<em class="ob"> N </em>越来越高，即使使用计算机来做这件事也会非常慢。</p><p id="047e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是像DP这样的优化技术可以用来快速解决问题的地方。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5ca5" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">DP是如何工作的？</h1><p id="8472" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">假设我们的任务是解决问题“I ”,我们需要找到这个问题的最优解。我们称这个问题为Sᵢ，并认为它太难直接解决。</p><p id="9425" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，我们试着解决一个子问题，Sⱼ，这里j &lt; i，我们发现这也太难了。我们重复这个过程，直到我们达到一个可以解决的基本情况S₀。</p><p id="6d93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们找到了S₀的解，我们就可以用它来找到S1，然后S2等等。直到我们找到Si。这正是DP的工作原理。这也被称为自下而上的方法！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/6e9ced2c8984ced19a6ae61b3f89936c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLQ4yw7ZybXwyFHnLovbwA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DP的状态转换图</p></figure><p id="f6e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使用DP，我们需要将问题分成称为“状态”的子问题，以便我们可以找到这些状态之间的关系，称为<em class="ob">递归关系</em>。</p><p id="2e8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能听起来很难，但是我会用从简单到困难的例子来解释清楚。然后，如果你重新阅读上面的文章，它应该对你更有意义。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8750" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">简单的问题</h1><h2 id="947a" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">问题1:硬币零钱</h2><p id="cd66" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">让我们用DP解决我上面描述的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/077d2ee3ee86bad2713f9146cdf053b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIZVB3Ja1XB1Lz34ASyq5w.jpeg"/></div></div></figure><p id="ee97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们把这个问题分成子问题，进入状态<em class="ob"> i </em>其中<em class="ob"> i </em>是硬币需要加起来的值。对于每一个硬币<em class="ob"> j </em>其中<em class="ob"> Vⱼ ≤ i </em>，看在此之前有解的子问题，即用<em class="ob"> i-Vⱼ </em>求和的状态。</p><p id="2c2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设解为代表最优解(最小硬币数)的“m”。如果<em class="ob">m+1</em>&lt;<em class="ob">s</em><em class="ob"/>的当前值，那么<em class="ob"> Sᵢ = m + 1 </em>(其中<em class="ob"> m </em>是状态为和<em class="ob"> i-Vⱼ </em>的最优解，我们加1包括硬币<em class="ob"> j </em>)。</p><p id="47a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了以编程方式解决这个问题，我们首先将所有状态Sᵢ初始化为无穷大，将状态0初始化为0，因为0个硬币的总和为0。</p><p id="c24b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，基本情况:<strong class="la iu"> </strong> S₀ = 0。</p><p id="3bf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">S₁ = 1。只有硬币V₁ = 1具有小于或等于状态I的值，其中i = 1。现在，S₁ ₋ ᵢ = S₁ ₋ ₁ = S₀ = 0。所以m = 0，因此，S₁ = 0+1 = 1。因此，S₁的解是一枚价值为1的硬币。</p><p id="0cf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">S₂ = 2。同样，只有一个硬币V₁ = 1的值小于或等于状态I，其中i = 2。现在，S₂ ₋ ᵢ = S₂ ₋ ₁ = S₁ = 1。所以m = 1，因此，S₂ = 1+1 = 2。因此，S₂的解是两个价值为1的硬币。</p><p id="09f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">S₃ = 1。这次有两个有效硬币V₁ = 1和V₂ = 3，它们的值小于或等于状态I，其中i = 3。现在，对于价值为1的硬币，S₃ ₋ ᵢ = S₃ ₋ ₁ = S₂ = 2。所以m = 2，因此，S₃ = 2+1 = 3。</p><p id="c00e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，对于价值为3的硬币，S₃ ₋ ᵢ = S₃ ₋ ₃= S₀ = 0。所以m = 0，因此，S₃ = 0+1 = 1。由于1小于3，我们覆盖S₃值为1。这是S₃.的最佳解决方案</p><p id="9557" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个过程一直持续到S₁₁，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/13ee7a6cacbbc8cb1c39d980de90491c.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*-OLScaB5--fXo7VnstKj-g.jpeg"/></div></div></figure><p id="a0b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们发现S₁₁的最优解是3个硬币。从表中我们可以看出:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="7fbd" class="mt mc it og b gy ok ol l om on">S11 = S8 + coin with value 3 <br/>S8 = S5 + coin with value 3 <br/>S5 = coin with value 5<br/>Therefore, S11 = coin with value 5 + coin with value 3 + coin with value 3! 5, 5, 1 is also a valid solution.</span></pre><p id="994a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用在S₁₁之前找到的最优子解，我们保证能找到S₁₁.的最优解</p><p id="7504" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么DP如此擅长不用蛮力的方法找到解决方案！它可以直接得到最优解，一旦我们得到最终状态的答案，我们就不必再做进一步的检查。</p><h2 id="85c0" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">密码</h2><p id="e61a" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">下面是解决这个问题的Python代码。如果找到，它返回最终的最优解，否则，它返回-1。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="4045" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">问题2:到1的最少步骤</h2><p id="0660" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">给定一个数“n”和以下三个运算:</p><ol class=""><li id="5ab0" class="oq or it la b lb lc le lf lh os ll ot lp ou lt ov ow ox oy bi translated">如果n能被2整除，那么你可以执行n = n/2。</li><li id="2cfc" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated">如果<em class="ob"> n </em>能被3整除，那么你可以执行n = n/3。</li><li id="a25d" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated">可以执行n = n-1。</li></ol><p id="6b48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这三种运算中的任何一种，将n变成1最少需要多少步？</p><p id="6d28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:n = 5。</p><ul class=""><li id="c813" class="oq or it la b lb lc le lf lh os ll ot lp ou lt pe ow ox oy bi translated">n = n-1 = 5–1 = 4</li><li id="54bd" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt pe ow ox oy bi translated">4能被2整除，所以4/2 = 2</li><li id="c059" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt pe ow ox oy bi translated">2能被2整除，所以2/2 = 1</li><li id="f406" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt pe ow ox oy bi translated">因此，从5到1需要三个步骤。</li></ul><p id="9cf3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，这个问题与前一个问题非常相似，我们可以将这个问题分成子问题，然后先解决较简单的子问题，以找到最优解。当值为1时，基本情况是S1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/1c60b900e93c4dc83241b5a89dbefad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRAT8AgQd7EeVIcYqODACg.jpeg"/></div></div></figure><h2 id="41a0" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated"><strong class="ak">代码</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="1011" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">问题3:增长最长的子序列</h2><p id="fd08" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">给定一个数列A = [1，2，3，7，4，5]，求这个数列中增长最长的子序列的长度。A的解是5，由[1，2，3，4，5]给出。</p><p id="a4fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">列表的最优解由最长的子序列给出。把这个问题分成几个子问题，这样Sᵢ就是一个Vᵢ值的状态，如果我们考虑前“I”个元素，这就是最优解。</p><p id="9765" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，基本情况下，S₀ = 1。这是因为我们只考虑列表A中的第一个元素1，并且最长的递增子序列的长度为1。</p><p id="0702" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">S₁ = 2。在这种状态下，我们考虑元素1和2。因为2大于1，所以值V₁ = V₀ + 1 = 2。</p><p id="5591" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">继续这样做，直到列表结束。我们使用的条件是:</p><ol class=""><li id="521a" class="oq or it la b lb lc le lf lh os ll ot lp ou lt ov ow ox oy bi translated">当前数字是否大于前一个数字？</li><li id="9322" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated">当前数字的状态值是否大于前一个数字的状态值？</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/31f597d3e7f10434752348b84521c3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NxfW3C_MTCoQ9lu1xaMxw.jpeg"/></div></div></figure><h2 id="3c18" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated"><strong class="ak">代号</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b3a1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">中等问题</h1><h2 id="5d52" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">问题1:背包问题</h2><p id="fdda" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">背包问题是一个著名的优化问题，给你一组重量为w，值为v，最大背包大小为w的项目。</p><p id="67ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定w = [1，2，3]，v = [60，100，120]，W = 4，找出项目的最佳组合，使我们最大化背包的价值，并使项目适合背包。</p><p id="65bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">变种1:背包中的物品可以重复</strong></p><p id="2a38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果允许我们重复物品，这个问题就很像硬币找零问题。</p><p id="8e7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本情况:dp[0]= 0。</p><p id="4cd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">递归关系:<strong class="la iu"> </strong>对于wts中的每个w:如果w ≤ i则dp[i] = max(dp[i]，dp[w] + dp[i-w])。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/79e5b0c28ab5fd36c7b543336199952a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOBeMmaLwJbXddXQtVkezA.jpeg"/></div></div></figure><p id="eebc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">代码</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="50ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">变型2:项目不重复</strong></p><p id="3ad1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题稍微有点挑战性，因为我们现在需要跟踪背包中的物品。要做到这一点，我们可以利用二维数组代替一维数组，我们已经利用了所有上述问题。</p><p id="f8fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">符号:<em class="ob"> dp </em>是一个2d表格，其行索引代表索引为<em class="ob"> u </em>的物品，列索引代表背包的重量<em class="ob"> wᵢ </em>范围从0到w，<em class="ob"> wtᵤ </em>代表该物品的重量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/d70679013147677dde65ed0cd2a2a462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OhphIlZrasVFWZAj8Spk1w.jpeg"/></div></div></figure><p id="d19c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基础案例:</p><ol class=""><li id="b493" class="oq or it la b lb lc le lf lh os ll ot lp ou lt ov ow ox oy bi translated">dp[0，w]= 0-项目0没有权重或值，因此所有值都是0。</li><li id="819d" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated">dp[i，0] = 0 —当背包重量为0时，不能添加任何物品，因此值为0。</li></ol><p id="e4d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重复关系:</p><p id="6beb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果物品<em class="ob"> u </em>的重量小于或等于当前背包的重量，那么<em class="ob"> dp </em>的值是物品<em class="ob">重量= wᵢ - wtᵤ </em>的背包的vᵤ+最优值(因为该物品已经加入背包减去它)或没有前一行计算的物品的背包的最优值中的最大值。</p><p id="2994" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这由下式给出:</p><p id="c96e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果wtᵤ ≤ wᵢ: dp[u，wᵢ] = max(dp[u - 1，wᵢ - wtᵤ] + vᵤ，dp[u - 1，wᵢ])</p><p id="861e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">否则，项目<em class="ob"> u </em>不适合具有权重wᵢ的背包，因此我们只放置在先前状态找到的最优值。</p><p id="84eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">否则:dp[u，wᵢ] = dp[u - 1，wᵢ]</p><p id="fc73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用该算法的最终表格如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/0dfcdde62d9fdad018a5d957b5d64ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1jjbnzPFMf9gJimtrGAEg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">程序结束时的DP</p></figure><p id="76bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">代码</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="9f1d" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated"><strong class="ak">问题2:编辑距离</strong></h2><p id="73f5" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">给定两个字符串s1和s2，找出使s1 = s2的最少编辑次数。可能的编辑是:插入字符、删除字符、替换字符。</p><p id="974b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例1 <strong class="la iu"> : </strong> s1 = "cat "</p><p id="b7fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">s2 = "狗"</p><p id="d841" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">【猫】--&gt;<em class="ob">替换</em>-&gt;-【cot】-&gt;-<em class="ob">替换</em>-&gt;-【圆点】- &gt; <em class="ob">替换</em>-&gt;-【狗狗】= &gt; 3编辑</p><p id="c023" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例2: s1 = "ducky "</p><p id="a0ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">s2 = "鸭子"</p><p id="f99c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">【ducky】--&gt;<em class="ob">插入</em>--&gt;&gt;" ducksy " =&gt;1编辑</p><p id="e5a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，我们如何以DP的方式实现这一点呢？</p><p id="2797" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以再次利用一个2d DP表，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/ba1bdb4db6b2223cb877ee9aed772d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZ15aaoBAYudsOEJ1-F0Rw.jpeg"/></div></div></figure><p id="f749" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此表中，#代表无字符。每个单元格都是一个子问题，最优解是编辑次数。s1用于索引列，s2用于索引行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/a415bfdc6efac0f84719c41fc7bf64b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*q84-qhL-_KnEiu9qjpQU0A.jpeg"/></div></figure><p id="c5f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑红色阴影的单元格。此单元格需要填充从“c”到空字符串“”的编辑次数。蓝色代表“ca”，绿色代表“cat”。</p><p id="8773" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从“c”到“”，我们知道需要1次编辑，即删除“c”。类似地，对于“ca”和“cat ”,分别需要2次和3次编辑。同样，我们可以填充第一列，从“”到“d”、“do”和“dog”。</p><p id="61ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由此可见，如果i = 0，那么dp[i，j] = j，如果j = 0，dp[i，j] = i就是我们初始化数组的方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/52eead2c9c0d7a6fd085879f7d5561df.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*5o0mn2Ykrwj3VZqX5HL3VA.jpeg"/></div></figure><p id="66ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们可以看到如何初始化DP表。现在，考虑具有行“d”和列“c”的单元格。此单元格表示从“c”到“d”的最小编辑次数。</p><p id="2a9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有三个选择:</p><p id="d588" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">a.删除c(向后移动一列)，然后添加d。</p><p id="f48d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">b.添加d，然后删除c(向下移动一行)。</p><p id="13dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">c.将c替换为d(向后移动一列，向下移动一行)。</p><p id="0583" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选项a和b的编辑距离为2，而c的编辑距离为1。因此，选择选项c。我们可以在这里看到一个模式！</p><p id="96c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">dp[i，j] = min(dp[i-1，j] + 1，dp[i，j-1] + 1，dp[i-1，j-1] + 1)</p><p id="0f0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果字符相同，则最小值为0。</p><p id="7856" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整的表格将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/08ac01f00637a16fd5d6b74110c53133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*z36aamDSCFViVvAihdPQaA.jpeg"/></div></figure><p id="db29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，从“猫”到“狗”的最小编辑次数是3。</p><h2 id="a8b5" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">密码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7b43" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="64a8" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我希望通过这些问题，你可以看到DP是有趣的，好玩的，有用的！随着我解决更多的DP问题，我将在本文中添加更多有趣的问题。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d6a0" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">来源</h1><p id="308e" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">这些都是对理解动态编程和撰写本文非常有价值的资料。</p><ol class=""><li id="4507" class="oq or it la b lb lc le lf lh os ll ot lp ou lt ov ow ox oy bi translated"><a class="ae po" href="https://pubsonline.informs.org/doi/pdf/10.1287/opre.50.1.48.17791" rel="noopener ugc nofollow" target="_blank">理查德·贝尔曼论动态编程的诞生</a></li><li id="47f8" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><a class="ae po" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">动态编程—维基百科</a></li><li id="4070" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><a class="ae po" href="https://www3.cs.stonybrook.edu/~algorith/video-lectures/1997/lecture12.pdf" rel="noopener ugc nofollow" target="_blank">斯通布鲁克演讲</a></li><li id="5eb4" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><a class="ae po" href="https://www.codechef.com/wiki/tutorial-dynamic-programming#Problem_:_Longest_Increasing_subsequence" rel="noopener ugc nofollow" target="_blank">代码厨师——最长递增子序列</a></li><li id="f490" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><a class="ae po" href="https://www.topcoder.com/community/competitive-programming/tutorials/dynamic-programming-from-novice-to-advanced/" rel="noopener ugc nofollow" target="_blank">动态编程从新手到进阶</a></li><li id="5020" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><a class="ae po" href="https://www.geeksforgeeks.org/edit-distance-dp-5/" rel="noopener ugc nofollow" target="_blank">极客对极客——编辑距离</a></li><li id="1352" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><a class="ae po" href="https://algorithms.tutorialhorizon.com/dynamic-programming-edit-distance-problem/" rel="noopener ugc nofollow" target="_blank">动态编程编辑距离问题</a></li></ol></div></div>    
</body>
</html>