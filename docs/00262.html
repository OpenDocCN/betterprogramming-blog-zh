<html>
<head>
<title>Getting Data From MongoDB &amp; Creating an API Key ValidationMiddleware in Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从MongoDB获取数据&amp;在Express中创建API密钥验证中间件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-data-from-mongodb-creating-an-api-key-validation-middleware-in-express-944382205d3e?source=collection_archive---------0-----------------------#2019-01-09">https://betterprogramming.pub/getting-data-from-mongodb-creating-an-api-key-validation-middleware-in-express-944382205d3e?source=collection_archive---------0-----------------------#2019-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/819b7836fc392e3746d0ddeaaf0bc11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T79HTxFDEByzlgT7HArRMA.png"/></div></div></figure><p id="a0eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文是<a class="ae kz" href="https://medium.com/@pankaj.panigrahi/list-of-node-js-articles-ededa6dd304b" rel="noopener">系列文章</a>的第5篇，它将帮助您掌握Node.js背后的不同概念，并使您能够创建生产就绪的应用程序。</p><p id="3831" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章期望读者了解巴别塔以及如何设置它。如果你需要知道如何做，请阅读这篇文章。</p><p id="0fa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将学习使用官方的<a class="ae kz" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>驱动程序，<a class="ae kz" href="https://www.npmjs.com/package/mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>从Mongo数据库获取数据。</p><p id="3ed6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先安装驱动程序。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="47ff" class="lj lk it lf b gy ll lm l ln lo">npm install mongodb --save</span></pre><p id="7977" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，根据官方文档，这是我们连接到实例的方式:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="70c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在每条路线中，我们现在都可以连接到数据库并获取数据。但是这种方法效率很低。对于路由，我们必须打开一个连接，然后关闭它。这会使我们的API变慢。</p><p id="6101" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上一篇文章中学习，让我们编写一个中间件函数，它将在请求对象中为我们提供DB连接。</p><p id="bf3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用与上次相同的项目，并编辑<code class="fe lr ls lt lf b">app.js</code>文件。将此代码放在文件的顶部:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="f0f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们导入Mongo客户端，并将数据库连接设置为一个全局变量<code class="fe lr ls lt lf b">mongoClient</code> <em class="lu">。</em></p><p id="31ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后注入一个中间件函数来修改请求对象以拥有DB实例。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="da17" class="lj lk it lf b gy ll lm l ln lo">app.use((req,res,next)=&gt;{<br/>   req.db = mongoClient.db('test');<br/>   next();<br/>})</span></pre><p id="dbad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们的API停止时，我们需要关闭DB连接。在底部添加以下代码:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="2367" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的<code class="fe lr ls lt lf b">app.js</code>长这样:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="9a3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe lr ls lt lf b">services</code>文件夹<em class="lu">内创建一个文件<code class="fe lr ls lt lf b">UserService.js</code>。</em>在文件中写下下面的代码。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="b120" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们导出一个函数<code class="fe lr ls lt lf b">getUserDetails</code>，它带有两个参数<code class="fe lr ls lt lf b">db</code>和<code class="fe lr ls lt lf b">username</code>，并返回一个<code class="fe lr ls lt lf b">promise</code>，其中用户记录与用户名相匹配。</p><p id="3725" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们将修改旧的<code class="fe lr ls lt lf b">routes/user.js</code> <em class="lu"> </em>文件，代码如下<em class="lu">。</em></p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="8614" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在route方法中，我们将DB实例和用户名传递给服务方法，然后在响应数据中设置用户详细信息。</p><p id="3b8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的数据库中有以下记录。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lv"><img src="../Images/98e3258c1d14b4d5ebf20ac8d70df49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlxZMRyfSk_RiCGKOUalXQ.png"/></div></div></figure><p id="b10c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行代码，并使用Postman调用API。我们将尝试在API响应中从MongoDB检索显示的数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lw"><img src="../Images/b24f12771322aef3529f92a32111bba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_mFLVg7Mq2aqukwEQn3zw.png"/></div></div></figure><p id="bae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">恭喜你。我们刚刚制作了第一个从MongoDB获取数据的API。</p><p id="79fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们将向express API添加客户端API密钥验证中间件。为什么我们需要这样的中间件？在一个真实的项目中，我们可能有50-60个API执行不同的任务。但是每个API可能都需要一些通用的功能，比如客户端API密钥验证、认证检查、用户角色验证等。</p><p id="cd7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本教程中，我们将看到如何添加客户端API密钥验证。这将确保我们的API可以被那些已经获得唯一API密匙的人调用。这也有助于限制来自客户端的请求数量，并为特定客户端创建API命中分析。</p><p id="8585" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，在<code class="fe lr ls lt lf b">services</code>文件夹中创建另一个服务文件<code class="fe lr ls lt lf b">ClientService.js</code>，并编写以下代码:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="e465" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它类似于我们之前写的<code class="fe lr ls lt lf b">getUserDetails</code>方法。它搜索带有匹配API键的客户记录，并返回一个承诺。</p><p id="d4a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe lr ls lt lf b">common</code>文件夹中创建一个文件<code class="fe lr ls lt lf b">authUtils.js</code>。</p><p id="e3a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里导入<code class="fe lr ls lt lf b">getClientDetails</code>方法。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="a99e" class="lj lk it lf b gy ll lm l ln lo">import {getClientDetails} from '../services/ClientService';</span></pre><p id="92de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个中间件函数，如图所示。这个函数有三个参数:<code class="fe lr ls lt lf b">req</code>、<code class="fe lr ls lt lf b">res</code>、<code class="fe lr ls lt lf b">next</code>。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="12a6" class="lj lk it lf b gy ll lm l ln lo">export const clientApiKeyValidation = async (req,res,next) =&gt; {<br/>   let clientApiKey = req.get('api_key');<br/>}</span></pre><p id="c528" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<code class="fe lr ls lt lf b">express</code>给出的<code class="fe lr ls lt lf b">req.get()</code>方法得到头<code class="fe lr ls lt lf b">api_key</code> <em class="lu"> </em>。让我们为缺失的<code class="fe lr ls lt lf b">api_key</code>添加一个验证。即使<code class="fe lr ls lt lf b">res.send()</code> <em class="lu"> </em>结束了流，我们也编写<code class="fe lr ls lt lf b">return res.send()</code>来避免任何进一步的代码执行。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ca45" class="lj lk it lf b gy ll lm l ln lo">if(!clientApiKey){<br/>   return res.status(400).send({<br/>      status:false,<br/>      response:"Missing Api Key"<br/>   });<br/>}</span></pre><p id="06d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，一旦我们在头中传递了<code class="fe lr ls lt lf b">api_key</code>，我们将调用之前导入的<code class="fe lr ls lt lf b">getClientDetails</code>方法。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="7da1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们尝试获取<code class="fe lr ls lt lf b">clientDetails</code>——在成功的查询中，我们通过调用<code class="fe lr ls lt lf b">next()</code>、<strong class="kd iu"> <em class="lu"> </em> </strong>来允许流程继续进行，否则我们停止API流程并发送<code class="fe lr ls lt lf b">invalid API key</code>响应。</p><p id="a64a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的<code class="fe lr ls lt lf b">common/authUtils.js</code>文件应该是这样的:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="c369" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，将这个中间件注入到我们的express对象中。打开<code class="fe lr ls lt lf b">app.js</code>文件，导入上述方法。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="540b" class="lj lk it lf b gy ll lm l ln lo">import {clientApiKeyValidation} from './common/authUtils';</span></pre><p id="dd58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Mongo客户端实例之后注入方法，因为我们需要Mongo实例。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="668e" class="lj lk it lf b gy ll lm l ln lo">app.use((req,res,next)=&gt;{<br/>   req.db = mongoClient.db('test');<br/>   next();<br/>});</span><span id="ef9b" class="lj lk it lf b gy lx lm l ln lo">app.use(clientApiKeyValidation);</span></pre><p id="d1d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行代码，打API没有任何<code class="fe lr ls lt lf b">api_key</code>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/d375686eb45245d9b833c05470a729bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_yVMtLjoLjD5B8ocdxAAQ.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">我们得到了缺失的验证响应</p></figure><p id="8f39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尝试用不正确的API键点击API。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/003701f87dcecf7b9f855c4e61ded626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuvvCaEwE_srw9xdERGviw.png"/></div></div></figure><p id="e940" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，使用正确的API密钥:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/1d7b46f0cf02a10f72c8970f8e40617e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-MgpaAN7HfrmztY6-Fpxg.png"/></div></div></figure><p id="aee1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们编写自定义中间件方法的方式。在express中构建API时，这是一个非常强大的工具。我们可以使用相同的方法进行授权检查并创建响应处理程序。</p><p id="d226" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望你喜欢这篇文章！在下一篇文章中，我们将看到如何使用Redis和自定义授权模块实现身份验证。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="cd63" class="mm lk it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">密码</h1><p id="97c2" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated"><a class="ae kz" href="https://github.com/pankaj805/medium-05_mongo_client" rel="noopener ugc nofollow" target="_blank">https://github.com/pankaj805/medium-05_mongo_client</a></p><p id="a629" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章，请留下评论并与他人分享。</p></div></div>    
</body>
</html>