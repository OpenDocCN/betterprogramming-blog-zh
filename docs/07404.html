<html>
<head>
<title>Functional Programming, Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化的函数式编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simplified-functionaldd-programming-fdc07b4b1084?source=collection_archive---------3-----------------------#2021-01-12">https://betterprogramming.pub/simplified-functionaldd-programming-fdc07b4b1084?source=collection_archive---------3-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d9a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">函数式编程的可视化介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b73d4c2b1fe852db088209b729d7a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RVIto2rF6jJvW_v2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jacksonjost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰克森·乔斯特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a27c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是函数式编程？</h1><p id="74f4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">函数式编程是纯函数的流水线。</p><p id="15c8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">那是什么意思？</p><p id="ebc1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了理解这个定义，我们将使用一个真实的例子。让我们假设我们有一个运输仓库和一个包含各种产品(书籍、衣服、某些罐头食品、家用电器等)的大型商店。).</p><p id="43d8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们仓库里的东西是如何工作的？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/ee05d2b56cfda8e05aee4407550fb049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYu_5mZCBIVNTZZ7-JzaPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仓库内部——作者图片</p></figure><p id="e960" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们的工作流是一系列小的处理步骤，每个元素的输出都是下一个元素的输入:流水线。每个步骤只存在一次。</p><p id="ec28" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">功能代码的工作单位是函数。每个功能都是独一无二的(单责干——不要重复自己)。</p><p id="2435" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">函数式编程使用管道作为其独特的构建方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/d7b32bf944c80e5674cdd47c8908254e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfCAKSyfWwGapyCFm6Jdww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数管道—图片由作者提供</p></figure><p id="df77" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在数学中，函数是一个连接输出和输入的简短公式。相同的输入总是产生相同的输出。在短公式中，变体和行为在单个短关系中恢复。</p><p id="2ff1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">函数式编程是声明性的(<em class="nb">什么</em>比<em class="nb">如何</em>更重要)。</p><p id="6f50" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们来看看这两种将数组中的元素加倍的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><ul class=""><li id="f054" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated"><code class="fe nn no np nq b">double1</code>是一个<em class="nb">命令式</em>代码，它一步一步地详细说明了如何将数组的每个元素加倍。</li><li id="f5a6" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated"><code class="fe nn no np nq b">double2</code>是一个<em class="nb">声明性的</em>简洁的代码，它将函数的结构简化为最重要的部分(一个公式)。</li></ul><p id="e15b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在仓库工作流程中，产品是否发生了变化？</p><p id="2bfe" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不要！从一个阶段到另一个阶段，我们在不改变或改变原有产品的情况下增加新的配件。</p><p id="ad67" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">例如，在分类步骤中，我们将订购的产品分组放在一个包装内，然后进行称重步骤。当最终用户收到订单并打开包装时，他们将能够获得没有突变或损坏的产品。</p><p id="2b3f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这就是函数式编程的工作方式:组合函数来转换输入而不改变它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/f2d56ac2dac9fae740447e5cbfb37e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpIl-5Fc2d4yFBASoz4QNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过函数转换的不可变输入—作者图片</p></figure><p id="a0fd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一个函数从不改变它的输入变量，而是创造新的、丰富的输出。不改变输入的函数是纯函数。</p><h2 id="3777" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">概述</h2><ul class=""><li id="3a4c" class="ne nf it ma b mb mc me mf mh oj ml ok mp ol mt nj nk nl nm bi translated">功能代码的工作单位是函数。</li><li id="fa08" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">函数式编程是纯函数的流水线。</li><li id="ecb0" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">函数式编程是声明性的(<em class="nb">什么</em> &gt; <em class="nb">如何</em>)。</li></ul><p id="c94c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这样的后果是什么？</p><h2 id="43d1" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">隔离并替换</h2><p id="3724" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们仓库中的每个阶段都独立于其他阶段，并且不知道它们的存在(之前或之后)。类似地，每个函数只依赖于它的输入。没有共享状态或外部依赖性。</p><p id="84c4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果出现任何问题，我们可以很容易地检测出问题的根源，并隔离有缺陷的组件，以快速恢复。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/29717f9056aa10335c7cbd9d3d0ac6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*woyhd3GV5Hl3faBDQ4EBiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">易于隔离错误并更换有缺陷的组件—图片由作者提供</p></figure><p id="7469" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果我们能容易地隔离一个函数，我们就能容易地对它进行单元测试！</p><p id="197a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">每个功能都充当独立和隔离的微服务。</p><p id="e665" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">函数类似于数学函数:</p><ul class=""><li id="9993" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">一个函数只依赖于它的输入。</li><li id="e985" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">一个函数不会产生任何副作用。例如，<em class="nb"> f(x) </em>不会改变输入<em class="nb"> x </em>但是会产生一个新值。</li></ul><h2 id="3fa2" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">可扩展且易于重新排列</h2><p id="8056" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果我们想在称重和装载之间增加一个称为自动监控的新步骤，以检查包装内的所有物品(质量改进)，该怎么办？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/10a572fd3bbbe1bc51c5df6011abeff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKBwZurXKMJf4hCZEHVp0w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">增加了自动监督步骤——图片由作者提供</p></figure><p id="a897" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了有效操作，步骤的输入和输出必须兼容:</p><ul class=""><li id="aa85" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">称重的输出应与自动监控的输入兼容。</li><li id="d8ec" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">自动监控的输出应与加载的输入兼容。</li></ul><p id="f01d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">仅此而已！我们不需要知道每一步内部是如何工作的(弱耦合)！</p><p id="3084" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果我们想添加一个函数，以便在<code class="fe nn no np nq b">double</code>和<code class="fe nn no np nq b">sort</code>函数之间只保留大于4的项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/6047f0e66397455ea054a7dbd3d437cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWyQGTUQHm5YH0FJAY47yQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">插入新功能—作者图片</p></figure><p id="11f6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">函数输入和输出必须在类型和arity上兼容:</p><ul class=""><li id="9a83" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">类型—一个函数返回的类型必须与接收函数的参数类型相匹配。</li><li id="74fe" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">Arity —接收函数必须声明至少一个参数，以便处理从前面的函数调用返回的值。</li></ul><p id="6c11" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">连接函数必须在arity和类型方面兼容。</p><p id="242d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当它们的类型和arity兼容时，我们也可以很容易地重新排列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/cf1315e413e6bbba16da2b2ae9d60ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aR3oiCoz5jaikjXLPdgIUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重新排列—作者的图像</p></figure><h2 id="6515" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">可预测和确定性</h2><p id="884a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在函数式编程世界中:</p><ul class=""><li id="5600" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">没有共享状态。</li><li id="231e" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">函数是纯的(不变性)。</li><li id="52f6" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">每个功能都作为一个独立和隔离的微服务(没有副作用)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/87e142d4eac5ecbfecd16c0a48fc8e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2O6ng-ZsvyQMtq6vDycHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数式编程过滤掉了所有外部噪音——图片由作者提供</p></figure><p id="d618" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果不稳定因素被过滤掉，我们可以很容易地预测任何时候的产量。</p><p id="8168" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们可以创建一个时间机器，让我们在程序的生命周期中前进或后退:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/19d91e3c092b7c4804d6a95d01c36b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZKtcaTmKDpkG7J9bpug2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可预测的行为—作者的图像</p></figure><p id="6789" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">可预测性、确定性和隔离是好的单元测试所需要的代码质量！</p><h2 id="9c76" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">降低复杂性</h2><p id="76ac" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">函数式编程是简短的、单一职责的、纯函数的组合。</p><p id="cbfd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这是什么意思？让我们看一个例子。</p><p id="eefa" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">怎么才能算出<em class="nb"> (2x+3) </em>？</p><ul class=""><li id="b3a6" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">第一步，计算<em class="nb"> (2x+3) </em>。</li><li id="b14e" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">然后平方输出。</li></ul><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="67d4" class="nx lh it nq b gy ot ou l ov ow">f(x) = (2x+3)</span><span id="163e" class="nx lh it nq b gy ox ou l ov ow">g(x) = x²</span><span id="f719" class="nx lh it nq b gy ox ou l ov ow">h(x) = (g º f)(x) =  g(f(x)) = (2x+3)²</span></pre><p id="c220" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">复杂的数学函数是由简单的小函数组合而成的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/d7b32bf944c80e5674cdd47c8908254e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfCAKSyfWwGapyCFm6Jdww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合成以降低复杂性—图片由作者提供</p></figure><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="24bd" class="nx lh it nq b gy ot ou l ov ow">const finalOutput <br/>= double º sort º display <br/>= display(sort(double(array)))</span></pre><ul class=""><li id="5e99" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">计算<code class="fe nn no np nq b">double(array)</code>。</li><li id="39b1" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">然后通过管道将结果排序。</li><li id="7583" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">然后通过管道显示结果。</li></ul><p id="335a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">关键是组成小步骤，而不是拥有一个做所有事情的函数。</p><p id="78ee" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们从中获得了什么？很容易隔离、调试和测试！</p><p id="dc2e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">构图有很多种。最重要的是高阶函数和链接。</p><p id="679a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们开始吧！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7ca0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">高阶函数</h1><blockquote class="oy"><p id="2128" class="oz pa it bd pb pc pd pe pf pg ph mt dk translated">对其他函数进行运算的函数，无论是将它们作为参数还是返回参数，都称为高阶函数— <a class="ae ky" href="https://eloquentjavascript.net/05_higher_order.html" rel="noopener ugc nofollow" target="_blank">雄辩的JavaScript </a></p></blockquote><p id="fc14" class="pw-post-body-paragraph ly lz it ma b mb pi ju md me pj jx mg mh pk mj mk ml pl mn mo mp pm mr ms mt im bi translated">那是什么意思？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/3d56b1871e1da622ad4cfc09225d4b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWKoxjCKTojTzdNU-Xgo7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">高阶函数——作者图片</p></figure><p id="8fca" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">transform</code>是以<code class="fe nn no np nq b">f</code>为自变量的高阶函数。</p><p id="bb65" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为什么？我们来看看<code class="fe nn no np nq b">transform</code>可以怎么写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="daec" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">transform</code>是纯粹的:我们返回一个副本，而不是突变原始数组。</p><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="262f" class="nx lh it nq b gy ot ou l ov ow">const data = [1, 4, 2, 8];</span><span id="4a2e" class="nx lh it nq b gy ox ou l ov ow">const double = x =&gt; x * 2;<br/>const plusOne = x =&gt; x + 1;</span><span id="a1b7" class="nx lh it nq b gy ox ou l ov ow">console.log('double array : ', transform(data, double));<br/>console.log('plus one array : ', transform(data, plusOne));</span></pre><p id="85ce" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">transform</code>包含迭代数组并将函数应用于其项目的重复代码。</p><p id="7af1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这是重用代码的一种方式！</p><p id="a5b7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们不是重复相同的代码，而是创建一个通用的高阶函数(抽象)。</p><p id="d737" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们会发现<code class="fe nn no np nq b">transform</code>是在编程语言中实现的，还是仅仅是一个数学概念？</p><p id="e1f7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们看看。</p><h2 id="3afa" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">JavaScript中的高阶函数</h2><p id="8e8e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在JavaScript世界中，我们有以下几种可用的方法:</p><ol class=""><li id="5473" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt po nk nl nm bi translated"><code class="fe nn no np nq b">map</code>要转换一个数组:</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/f0eca2652d7158761d076aaf38aac66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxNtC_1qWtRFZTQM5SVNZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">映射以转换数组—图片由作者提供</p></figure><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="18de" class="nx lh it nq b gy ot ou l ov ow">const sequence = [1, 2, 3, 4, 5];<br/>const doubleSequence = sequence.map((item) =&gt; item * 2); // [2,4,6,8,10]</span></pre><p id="ed22" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">map</code>:</p><ul class=""><li id="4ecf" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">返回一个不影响原数组的新数组(纯无副作用)。</li><li id="08f6" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">输入数组长度<strong class="ma iu"> = </strong>输出数组长度。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/c7419b987594cdfbdb7d079bc83bcdc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiKt9oG9ngLL86EAzMNxHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JS地图如何工作—图片由作者提供</p></figure><p id="b3a0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">2.<code class="fe nn no np nq b">filter</code>要过滤一个数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/a455f8df84b8e8b94720b122234a0ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gsep_GDI___uLokHv_hiWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过滤一个数组-作者图片</p></figure><p id="befc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">f</code> <strong class="ma iu"> </strong>是谓语功能。</p><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="a235" class="nx lh it nq b gy ot ou l ov ow">const <strong class="nq iu">isString</strong> = value =&gt; typeof value === 'string';</span><span id="608e" class="nx lh it nq b gy ox ou l ov ow">const values = [12, 'Hi', 1, 'Sun', 'Sky', 8];</span><span id="8277" class="nx lh it nq b gy ox ou l ov ow">const valuesMatched = values.<strong class="nq iu">filter(isString)</strong>;</span><span id="5b9a" class="nx lh it nq b gy ox ou l ov ow">console.log('valuesMatched : ', valuesMatched); <br/>// "valuesMatched : ", ["Hi", "Sun", "Sky"]</span></pre><p id="1442" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">filter</code>:</p><ul class=""><li id="dbc1" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">返回一个不影响原数组的新数组(纯无副作用)。</li><li id="c4bd" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">输出数组长度取决于有多少元素匹配谓词(max =输入数组长度)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/79b4c6a05e11cb31d2d45b14d6d12ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5x0D7AMyV8fcTl4caPeVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JS滤镜如何工作—图片由作者提供</p></figure><p id="deff" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">3.<code class="fe nn no np nq b">every</code>和<code class="fe nn no np nq b">some</code>。</p><p id="5f6d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">every</code>测试数组的所有元素是否满足条件:</p><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="08a5" class="nx lh it nq b gy ot ou l ov ow">[12, 5, 8, 130, 44].every(elem =&gt; elem &gt;= 10); // false<br/>[12, 54, 18, 130, 44].every(elem =&gt; elem &gt;= 10); // true<br/>[{a:1, b:2}, {a:1, b:3}].every(elem =&gt; elem.a === 1); // true<br/>[{a:2, b:2}, {a:1, b:3}].every(elem =&gt; elem.a === 1); // false</span></pre><p id="0bf1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">some</code>测试数组中是否至少有一个元素通过条件:</p><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="ead0" class="nx lh it nq b gy ot ou l ov ow">[2, 5, 8, 1, 4].some(elem =&gt; elem &gt; 10); // false<br/>[12, 5, 8, 1, 4].some(elem =&gt; elem &gt; 10); // true (12)</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9b51" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">如何链接函数</h1><p id="fd54" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">链接函数为您提供了组合小行为以获得复杂结果的可能性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/d807b30d3b290f9fda9e4a1554a58159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xbi5sJlwPopc4XMyd4M1BQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链接小函数—作者图片</p></figure><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="10e3" class="nx lh it nq b gy ot ou l ov ow">const complexArray = [6, 2, 4, 8]<br/>.map(x =&gt; x * 2)<br/>.map(x =&gt; x + 1)<br/>.filter(x =&gt; x &gt; 10);</span><span id="5d42" class="nx lh it nq b gy ox ou l ov ow">console.log('complexArray : ', complexArray); <br/>// "complexArray : ", [13, 17]</span></pre><p id="b17c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">连接函数必须在arity和类型方面兼容。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="287a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">函数式编程的安全性</h1><h2 id="35c8" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">函子</h2><p id="692a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">让我们看看下面的代码:</p><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="ae64" class="nx lh it nq b gy ot ou l ov ow">const increment = v =&gt; v + 1</span><span id="fce9" class="nx lh it nq b gy ox ou l ov ow">increment('5') // '51'</span><span id="2b14" class="nx lh it nq b gy ox ou l ov ow">increment({ v: 5 }) <strong class="nq iu">// "[object Object]1"</strong></span></pre><p id="32f0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">怎么了?<strong class="ma iu"> </strong> <code class="fe nn no np nq b">{v: 5}</code>是一个对象。</p><p id="25fa" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们如何保护我们的功能？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="68ea" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在让我们添加一个计算数字双精度的函数:</p><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="271c" class="nx lh it nq b gy ot ou l ov ow">const double = (v) =&gt; {<br/>  if (typeof v !== 'number') {<br/>    return NaN<br/>  }<br/>  return v * 2<br/>}</span></pre><p id="c432" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">怎么了?<strong class="ma iu"> </strong>在<code class="fe nn no np nq b">increment</code>和<code class="fe nn no np nq b">double</code>之间有<strong class="ma iu"> </strong>重复编码。</p><p id="7b86" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">有没有更好的办法？让我们看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="aef8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">神奇！让我们来了解发生了什么:</p><ul class=""><li id="fd6d" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">对于给定的输入，我们检查它是否是一个数字。</li><li id="1b89" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">如果是，那么<code class="fe nn no np nq b">NumberBox</code>可以应用函数<code class="fe nn no np nq b">(fn)</code>并将结果传递给下一个函数。</li><li id="e0bc" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">否则，该函数不被应用，并且<code class="fe nn no np nq b">Nan</code>被传送到下一个函数。</li><li id="dbf8" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">上下文保存在<code class="fe nn no np nq b">applyFunction</code>(管道)之间。</li><li id="a20b" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">相同的检查一直持续到最后一个映射，其中<code class="fe nn no np nq b">NumberBox</code>返回上下文中最后保存的值。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/8360021606288882504d7069203f3677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nUEkZeIIQQ6QlVTvy2q_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数字盒子背后的魔法——作者的图像</p></figure><p id="e82f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们没有将值传递给函数，而是将函数传递给值。</p><p id="a506" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们可以对我们的<code class="fe nn no np nq b">NumberBox</code>做一个小小的改变:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9b1d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们用<code class="fe nn no np nq b">map</code>替换<code class="fe nn no np nq b">applyFunction</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="837e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">是的，这就是我们的<code class="fe nn no np nq b">map</code>，这就是我们如何在函数之间安全地链接！</p><p id="7cf4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">那什么是函子？</p><blockquote class="pv pw px"><p id="7153" class="ly lz nb ma b mb mu ju md me mv jx mg py mw mj mk pz mx mn mo qa my mr ms mt im bi translated">本质上，函子只不过是一种数据结构，您可以映射函数，目的是将值提升到包装器中，修改它们，然后将它们放回包装器中。这是一种设计模式，定义了fmap应该如何工作的语义。— Luis Atencio，<a class="ae ky" href="https://livebook.manning.com/concept/javascript/functor" rel="noopener ugc nofollow" target="_blank">JS中的函数式编程</a></p></blockquote><p id="0fc9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">完美！</p><blockquote class="pv pw px"><p id="7274" class="ly lz nb ma b mb mu ju md me mv jx mg py mw mj mk pz mx mn mo qa my mr ms mt im bi translated">它们的实际目的是创建一个上下文或抽象，允许您安全地操作和应用操作到值，而不改变任何原始值。这在map将一个数组转换成另一个数组而不改变原始数组的方式中显而易见；这个概念同样适用于任何容器类型。—路易斯·阿坦西奥，<a class="ae ky" href="https://www.htmlgoodies.com/beyond/javascript/js-ref/javascript-functors-explained.html" rel="noopener ugc nofollow" target="_blank">JS中的函数式编程</a></p></blockquote><p id="a84a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这就是我们想要的！安全链接！</p><p id="ae56" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">函子充分吗？</p><p id="8cf1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不为什么不呢？</p><p id="140a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当出错时，仿函数安全地继续执行，直到最后一个<code class="fe nn no np nq b">map</code>并返回上下文中最后保存的值:</p><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="7da6" class="nx lh it nq b gy ot ou l ov ow">const safeResult = NumberBox({<br/>  v: 5})<br/>.<strong class="nq iu">map</strong>(v =&gt; v * 2) // -&gt; executed<br/>.<strong class="nq iu">map</strong>(v =&gt; v + 1) // -&gt; executed<br/>.value // NaN</span></pre><p id="04cf" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">即使出现错误，仿函数也会安全地继续执行(<code class="fe nn no np nq b">map</code>)。</p><p id="5f60" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们将通过使用称为单子的函子的高级版本来解决这个问题。</p><p id="aa44" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们看看！</p><h2 id="4965" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">可能单子</h2><p id="e4a6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如何写一个<code class="fe nn no np nq b">Maybe</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ff14" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一个神奇的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0c7e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一个<code class="fe nn no np nq b">Maybe</code>单子是一个函子，因为我们也<code class="fe nn no np nq b">map</code>这个函数。</p><p id="d415" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然而，当<code class="fe nn no np nq b">Maybe</code>遇到问题时，它不会继续。它跳过并转到默认语句:<code class="fe nn no np nq b">getOrElse</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/aa623d63bb154adc116bdea174f45713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSouF_NbonXqOs8KZ-WE9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函子与可能—作者图片</p></figure><p id="e834" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">没错，是魔法！</p><p id="70b4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一个<code class="fe nn no np nq b">Maybe</code>有两个流程:一个成功，一个失败。相比之下，仿函数只有一个流:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/f71b74e4454d29dd271c92e021c94f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyuNMLPwIvi3E9nLDJRzcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">也许是流动——作者的形象</p></figure><p id="631f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这有什么帮助？</p><p id="8869" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一个具体的使用示例是处理从后端接收到的响应。我们不知道收到的数据是否已定义，也不知道它是否符合预期的类型和格式。</p><p id="bb87" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">因此，我们可以用<code class="fe nn no np nq b">Maybe</code>包装数据，并链接转换函数。如果一步失败，所有的步骤都会失败。</p><pre class="kj kk kl km gt op nq oq or aw os bi"><span id="9fee" class="nx lh it nq b gy ot ou l ov ow"><strong class="nq iu">MayBe</strong>(Backend.Call()).map().map().getOrElse();</span></pre><p id="7f28" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">关于函数式编程的这篇文章到此为止！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4820" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="1266" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本文中，我们讨论了什么是函数式编程，它的好处以及可用的模式。</p><p id="b942" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">函数式编程是简短的、单一职责的、纯函数的组合。Pure意味着函数永远不会改变它的输入。该功能不会产生或导致副作用。</p><p id="cd10" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">函数更像数学函数:声明性的，简洁的(公式)。</p><p id="a43f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们从中获得了什么？</p><ul class=""><li id="9bc0" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">我们可以轻松地隔离功能，从而轻松地对它们进行单元测试。</li><li id="49a8" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated">由于每个功能都作为一个独立和隔离的微服务，我们可以很容易地扩展和重新安排全局行为。怎么会？通过使用组合、高阶函数和链接等技术。</li></ul><p id="6bfa" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后，我们看到了一些关于函数式编程的安全提示:</p><ul class=""><li id="0123" class="ne nf it ma b mb mu me mv mh ng ml nh mp ni mt nj nk nl nm bi translated">仿函数帮助我们安全地链接应用于一个值的函数。然而，它们不处理错误和异常。</li><li id="3308" class="ne nf it ma b mb nr me ns mh nt ml nu mp nv mt nj nk nl nm bi translated"><code class="fe nn no np nq b">Maybe</code>单子丰富了函子处理错误的能力。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c1eb" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">进一步的信息</h1><div class="qd qe gp gr qf qg"><a href="https://www.amazon.fr/Functional-Programming-Javascript-Luis-Atencio/dp/1617292826" rel="noopener  ugc nofollow" target="_blank"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd iu gy z fp ql fr fs qm fu fw is bi translated">JavaScript中的函数式编程:如何使用函数式来改进你的JavaScript程序</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">诺特/5。JavaScript中的Retrouvez函数式编程:如何使用函数式来改进您的JavaScript程序…</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">www.amazon.fr</p></div></div><div class="qp l"><div class="qq l qr qs qt qp qu ks qg"/></div></div></a></div><div class="qd qe gp gr qf qg"><a href="https://www.amazon.fr/Functional-Light-JavaScript-Pragmatic-Balanced-English-ebook/dp/B0787DBFKH" rel="noopener  ugc nofollow" target="_blank"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd iu gy z fp ql fr fs qm fu fw is bi translated">轻功能JavaScript:JavaScript中实用、平衡的FP(英文版)</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">achetez et téléchargez ebook Functional-Light JavaScript:实用、平衡的FP in JavaScript(英文版)…</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">www.amazon.fr</p></div></div><div class="qp l"><div class="qv l qr qs qt qp qu ks qg"/></div></div></a></div></div></div>    
</body>
</html>