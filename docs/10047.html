<html>
<head>
<title>Unit Testing API-Specific Code on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上特定于API的代码的单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-api-specific-code-on-android-cee08dd2dd1?source=collection_archive---------9-----------------------#2021-11-17">https://betterprogramming.pub/unit-testing-api-specific-code-on-android-cee08dd2dd1?source=collection_archive---------9-----------------------#2021-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9882" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">经过几次失败的尝试后，一本完善的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ab883edee6a67a9b96cdeae7a755e9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lCoLZXQYvhzmLQFrAWCEQ.jpeg"/></div></div></figure><p id="1c27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你是否曾经长时间盯着某件事，以至于你觉得已经用尽了所有可能的解决方法？最后，当你到达你的最后一个技巧时，它让你困惑，为什么它没有早点出现在你面前？这是我在Android上对特定于API的代码进行单元测试的经历。</p><p id="3ee5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对项目的这些部分进行单元测试可能具有挑战性，并且通常容易被认为“太难测试”我解决这个问题的大部分尝试都感觉站不住脚，不合时宜，但不足以让我用它来换取更少的单元测试覆盖率。</p><p id="cb6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">怎样做才能使项目代码的测试变得容易，并且感觉是集成的和经过深思熟虑的？也许你不会惊讶于Dagger在这个解决方案中扮演的核心角色。</p><h1 id="d561" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">了解编译器</h1><p id="9f8c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在深入探讨我称之为合适的解决方案之前，让我们先看看为什么这不是一个容易解决的问题。首先，Kotlin编译器在构建Android应用时考虑了优化。在大多数情况下，工程师会笑着说这是个好消息。事实证明，这种优化使我们的工作更加困难。</p><p id="00f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您有这段代码来解码Android上的位图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">一个跨越多个API版本来解码位图的函数</p></figure><p id="7f03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Android 9 (Pie、P、API 28等)或更高版本推荐使用一个<code class="fe mt mu mv mw b">ImageDecoder</code>来完成这项工作。在低于这个级别的API上它是不可用的，所以我们求助于<code class="fe mt mu mv mw b">MediaStore</code>来完成相同的任务。可惜的是，<code class="fe mt mu mv mw b">MediaStore</code>上的<code class="fe mt mu mv mw b">getBitmap()</code>已经弃用。这使我们陷入了一个尴尬的境地，不可用的API和不推荐的API，这取决于您的版本。使用版本检查有助于平滑那些粗糙的边缘。</p><p id="12bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，您可以在单元测试过程中使用运行时反射闯入<code class="fe mt mu mv mw b">Build.VERSION</code>对象并重写<code class="fe mt mu mv mw b">SDK_INT</code>值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">更改Build值的函数。版本</p></figure><p id="cf6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">老实说，这是最好的笨重，最差的不可靠。由于<code class="fe mt mu mv mw b">SDK_INT</code>只是一个<code class="fe mt mu mv mw b">public static final</code>(kot Lin术语中的<code class="fe mt mu mv mw b">const val</code>)，我希望其他具有类似访问器和作用域的对象也能以同样的方式工作。假设我们在<code class="fe mt mu mv mw b">BuildConfig</code>对象上使用了不同的属性。在这个例子中，我使用了<code class="fe mt mu mv mw b">BUILD_TYPE</code>标志:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">为发布版本设置安全标志的活动</p></figure><p id="65d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用反射方法应该以同样的方式工作，并允许我切换这个布尔值。然而，事实并非如此。在单元测试期间，两个对象上的两个<code class="fe mt mu mv mw b">public static final</code>属性表现不同。这是因为编译器优化了字符串，使其读起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">常量被内联后，编译后的代码看起来更加真实</p></figure><p id="e8b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在某些情况下，编译器内联这些值，而在其他情况下，它保留对对象的引用。没有办法访问内联值，所以我们显然不能依赖这种技术。我们的基础并不稳固，因为在测试静态属性时，我们需要两种不同的方法。</p><h1 id="6912" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">匕首拯救世界</h1><p id="8f35" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Dagger通常通过观察一个请求来工作，该请求通过查看一个类的唯一类型来填充构造函数或字段中的特定参数。只要匹配类型在其对象图中可用，它就会提供该对象的实例。</p><p id="e533" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，当我们在API级别上使用整数或者在构建类型上使用字符串时，我们非常相信在我们的整个对象图中再也不会有另一个整数或者字符串了。当从您的应用程序或另一个库中提供自定义的、完全限定的类时，这种想法是可以理解的，但对于构建这些语言的基础、原始类型来说，这种想法是不可理解的。</p><p id="1550" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以不用依赖类型，而是使用标签。当您用<code class="fe mt mu mv mw b">@Named("my unique name")</code>注释Dagger模块中的函数时，Dagger使用它作为匹配条件。这种方法更适合匹配字符串、整数、布尔和其他原语等类型。</p><p id="c49a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我已经从<code class="fe mt mu mv mw b">Build</code>和<code class="fe mt mu mv mw b">BuildConfig</code>对象中取出了每一个有问题的静态属性，并将它们移动到一个适当注释的Dagger模块中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">Dagger在Build和BuildConfig对象上提供静态值</p></figure><p id="3fbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我可以将这些属性注入到我的类中，而不用担心不必要的编译器优化。当需要对这些类进行单元测试时，我可以直接向构造函数或字段提供我想要的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">支持测试API相关代码的图像解码器</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">Dagger将构建类型注入MainActivity</p></figure><h1 id="01ac" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="00c8" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">了解<code class="fe mt mu mv mw b">@Named()</code>注释对于解决我项目中的一个长期问题至关重要。在生活中，我没有多少次可以说我遇到了银弹。然而，这种解决方案可能就是其中一种情况。</p><p id="d98c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它为<code class="fe mt mu mv mw b">Build</code>和<code class="fe mt mu mv mw b">BuildConfig</code>对象提出的问题提供了统一的解决方案。我的项目现在可以采取一致的方法来解决这个问题，并删除所有我超时设计的创造性解决方案，以通过几行来提升我的覆盖度量。</p><p id="3261" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你不知道这种技术，我希望这对你来说是一个启发性的时刻，并且会用更少的努力在你的测试中解锁更健壮的覆盖率。现在，在这种情况下，我们遵循艾伦·f·莫根森的智慧，这是人类在伟大的时间大厅中推崇的。“更聪明地工作，而不是更努力。”</p><h1 id="c3f4" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">喜欢你读的东西吗？</h1><p id="0308" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">本文最初发表于<a class="ae mx" href="https://go.oliverspryn.com/unit-testing-api-specific-code-on-android" rel="noopener ugc nofollow" target="_blank">https://oliverspryn.com/</a>。</p></div></div>    
</body>
</html>