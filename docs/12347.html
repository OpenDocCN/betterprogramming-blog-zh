<html>
<head>
<title>The Power of Iterator Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中迭代器设计模式的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-iterator-design-pattern-in-javascript-e8a9ec703fb5?source=collection_archive---------11-----------------------#2022-05-30">https://betterprogramming.pub/the-power-of-iterator-design-pattern-in-javascript-e8a9ec703fb5?source=collection_archive---------11-----------------------#2022-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c58" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">迭代器是每个集合最好的朋友</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e58f07d738a4d5ed9d8f54b34825d3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*DtyjfJ8cnhH-s2Vhsn1C0w.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">hitesh choudhary在<a class="ae ku" href="https://pexels.com" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄的照片</p></figure><p id="8324" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">几乎在我们编写的每一个JavaScript应用程序中，总会有某种形式的集合循环。例如，当我们通过HTTP请求接收数据时，循环收集就变得很有必要。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="4f98" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">由于数据可以采取多种形式，并不是每一种循环算法都能够比其他循环方法更快和/或更有效地完成工作。</p><p id="0960" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这种情况下，有一个明显的问题:我们需要能够在不同的算法之间切换，以便在需要时遍历集合。解决这个特定问题的设计模式称为迭代器设计模式。</p><p id="3739" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">也就是说，在这篇文章中，我们将回顾JavaScript中的迭代器设计模式，并动手实现。我们将了解为什么在开发时需要不同的算法。</p><h1 id="573f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">迭代器模式的视觉外观</h1><p id="2c87" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">从视觉角度看，这是图案的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/a334363fa0a61539de62e99a0586d104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-kylKy8iPahVc5k6.png"/></div></div></figure><h1 id="9fd4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">履行</h1><p id="8f97" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">假设我们有一个数组<code class="fe na nb nc nd b">arr</code>，它是一组数字的集合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2e1d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们正在开发一个程序，我们有一个常用的函数，它接受一个值列表和一个回调函数，该回调函数返回一个我们正在寻找的值，使用回调函数作为事实的来源，我们可以使用的最明显的可用策略之一是<code class="fe na nb nc nd b">for</code>循环:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="df6a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">或者我们可以使用迭代器模式，而不是将迭代的不同变体作为可注入算法来处理。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="129f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">将实现细节抽象出来更好的原因是，集合可以以各种数据结构出现。使用替代算法可以更有效地遍历一些数据结构。我们可以允许我们的对象能够在运行时从一个迭代器切换到另一个迭代器，只要有足够的算法来完成任务。</p><p id="c6e0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们继续我们的例子，创建一个简单的迭代器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9a9d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们能够遍历集合并查看结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0142c1c657c877ce619d4bbed20786b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*R4w8G6pnJKKezFjr.png"/></div></figure><p id="37b1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们有一个嵌套的项目集合会怎么样？我们当前的迭代方法不再有效，因为它没有考虑更深层次的键值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nh"><img src="../Images/aacc013e304911d7c71d62cfc2311fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*10FyNqhyJxvSs8SJ.png"/></div></div></figure><p id="9330" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据集合会变得非常复杂，它们不总是简单的JSON对象。JavaScript中的程序通常获取数据结构，转换它们，并且只对外部公开它们，这些外部公开的数据结构带有一些功能，可以处理一些常见的任务，比如生成最终的数据集合。</p><p id="15c1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这就是为什么<code class="fe na nb nc nd b">Iterator</code>模式如此重要，因为它促进了可扩展性、可伸缩性和组合性。</p><p id="7265" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">也就是说，我们可以使用不同的算法来获得我们的<code class="fe na nb nc nd b">elems</code>集合的所有后代，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ni"><img src="../Images/f81381937a4574ab052ad2b6fac5e58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-HC-F5ExHjtb_wJ6.png"/></div></div></figure><p id="376d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我相信你已经注意到了语法<code class="fe na nb nc nd b">Symbol.iterator</code>。JavaScript用它来为我们附加的任何对象放置默认迭代器。不要混淆，假设这是模式的一部分。只是语法糖而已。我们只是利用这种语法使<code class="fe na nb nc nd b">for of</code>能够运行，这完全与JavaScript有关。</p><p id="ecd2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们直接回到迭代器模式。在这些例子中，还没有太多有用的用例来展示它能变得多么强大，但我们确实经历了它在实际用例中解决的一个问题。</p><p id="11e2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，让我们进一步扩展我们的例子，以便对我们希望如何使用集合进行更多的控制，因为理解接下来的部分对于理解这个模式如何真正帮助我们是至关重要的。</p><p id="ec69" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">到目前为止，我们得到的是一个代表性DOM对象的嵌套集合。我们暴露了我们在使用常规<code class="fe na nb nc nd b">for loop</code>时遇到的一个问题，它不足以覆盖深度集合，所以我们实现了迭代器模式的变体来满足我们的需求。</p><p id="be73" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然而，在每次迭代中能够看到我们当前在复杂数据结构中的位置是非常有帮助的。</p><p id="cac4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们假设我们想要访问当前项(我们当前正在做)，我们当前所处的深度(每访问一个元素的<code class="fe na nb nc nd b">children</code>增加<code class="fe na nb nc nd b">depth</code>)，集合的当前索引，集合中的前一个和下一个项，迭代中的前一个、当前的和下一个元素(这与当前集合不同)，以及迭代中的项当前看起来像什么。</p><p id="8108" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有了这些信息，我们就可以对我们的元素集合做任何我们想做的事情。</p><p id="fbf1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以这样实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e654" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们现在需要做的就是调用它并提供回调。我们的回调将在每次迭代中提供所有这些信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1d03" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">结果如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="e554" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="69ba" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">希望你在这里找到了有价值的信息。以后多多关照！</p></div></div>    
</body>
</html>