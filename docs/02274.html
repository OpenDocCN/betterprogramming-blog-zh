<html>
<head>
<title>Great New Features in ES2018</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2018中的出色新功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/great-new-features-in-es2018-10fd5cc3d91c?source=collection_archive---------15-----------------------#2019-11-18">https://betterprogramming.pub/great-new-features-in-es2018-10fd5cc3d91c?source=collection_archive---------15-----------------------#2019-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c24e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">包括对象中的扩展操作符、rest操作符、异步迭代等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5b986907ca872c2f04f68b1c89fa4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S46iTtDuzH1LertT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6bae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从ES2015发布以来，这本身就是一个巨大的飞跃，JavaScript一直在快速改进。从那以后，JavaScript规范中每年都会增加新的特性。</p><p id="a86a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的语法和新的JavaScript构建方法等特性一直在不断增加。在ES2016和2017中，<code class="fe lv lw lx ly b">Object</code>对象增加了类似<code class="fe lv lw lx ly b">Object.values</code>和<code class="fe lv lw lx ly b">Object.entries</code>的方法。</p><p id="3447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2017中加入了类似<code class="fe lv lw lx ly b">padStart</code>和<code class="fe lv lw lx ly b">padEnd</code>的字符串方法。ES2017中还增加了<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>，后者是链接承诺的简写语法。</p><p id="43a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2016中增加了数组的<code class="fe lv lw lx ly b">includes</code>方法。ES2018是另一个具有许多新功能的版本。在ES2018中，扩展语法现在可用于对象文字。还添加了休息参数。</p><p id="dc9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还添加了<code class="fe lv lw lx ly b">for await...of</code>循环，这是一个顺序遍历承诺的循环语法。添加了<code class="fe lv lw lx ly b">SharedArrayBuffer</code>对象来表示无法分离的原始二进制数据。</p><p id="dddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">finally</code>函数也被添加到<code class="fe lv lw lx ly b">Promise</code>对象中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b241" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">对象中的扩展运算符</h1><p id="5e9a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">spread语法的工作方式是复制原始数组的值，然后将它们插入到另一个数组中，或者按照它们在数组中出现的顺序将它们作为函数中的参数列表以相同的顺序排列。</p><p id="7f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当spread运算符用于对象时，键值对的出现顺序与它们在原始对象中的出现顺序相同。</p><p id="36c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES2018中，spread运算符处理对象文字。然后，可以使用spread操作符将一个对象的键值对插入到另一个对象中。</p><p id="a6b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在同一个对象中有两个对象具有相同的关键点，并且spread运算符应用于这两个对象，那么后面插入的对象将覆盖前面插入的对象。</p><p id="408a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有以下内容:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="28f3" class="nh mh it ly b gy ni nj l nk nl">let obj1 = {foo: 'bar', a: 1};<br/>let obj2 = {foo: 'baz', b: 1};<br/>let obj3 = {...obj1, ...obj2 }</span></pre><p id="bf79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe lv lw lx ly b">{foo: “baz”, a: 1, b: 1}</code>作为<code class="fe lv lw lx ly b">obj3</code>的值，因为<code class="fe lv lw lx ly b">obj1</code>在<code class="fe lv lw lx ly b">obj2</code>之前展开。它们都有<code class="fe lv lw lx ly b">foo</code>作为对象中的键。</p><p id="62ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个<code class="fe lv lw lx ly b">foo: 'bar'</code>由展开操作员插入到<code class="fe lv lw lx ly b">obj3</code>。然后<code class="fe lv lw lx ly b">foo: 'baz'</code>在<code class="fe lv lw lx ly b">obj2</code>被合并后覆盖<code class="fe lv lw lx ly b">foo</code>的值，因为它有相同的键<code class="fe lv lw lx ly b">foo</code>，但是后来被插入。</p><p id="0bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于合并对象非常有用，因为我们不必遍历键并输入值，这比一行代码要多得多。</p><p id="6bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，我们不能在常规对象和可迭代对象之间混合spread运算符。例如，如果我们写下以下内容，我们将得到<code class="fe lv lw lx ly b">TypeError</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8ff3" class="nh mh it ly b gy ni nj l nk nl">let <!-- -->obj = {foo: 'bar'};<br/>let <!-- -->array = [...obj];</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5595" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Rest运算符</h1><p id="4b7b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">rest操作符是一个JavaScript操作符，我们可以在函数中以数组的形式存储不确定数量的参数。它看起来就像spread操作符，让我们将一个数组的条目或一个对象的键值对列表传播到另一个对象中。</p><p id="d87d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个函数，它有一个很长的参数列表，我们可以使用rest操作符来缩短函数中的参数列表。</p><p id="2865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">rest运算符与以下语法一起使用:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="87b7" class="nh mh it ly b gy ni nj l nk nl">const fn = (a,b,..restOfTheArgs) =&gt; {...}</span></pre><p id="4fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe lv lw lx ly b">restOfTheArgs</code>是一个数组，包含除前两个参数之外的参数列表。</p><p id="1db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想要编写一个<code class="fe lv lw lx ly b">sum</code>函数，它将一个不定的数字列表作为参数，并对这些数字求和，我们可以编写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8c93" class="nh mh it ly b gy ni nj l nk nl">const sum = (a,b,...otherNums) =&gt; {<br/>  return a + b + otherNums.reduce((x,y)=&gt;x+y, 0);<br/>}</span></pre><p id="af03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，这对于有参数列表的函数来说非常方便。在此之前，我们必须使用函数中可用的<code class="fe lv lw lx ly b">arguments</code>对象来获取参数列表。这并不理想，因为我们允许他们在参数中传递任何东西。</p><p id="c225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了rest操作符，我们就拥有了两个世界的精华。我们可以有一些固定的参数，而其余的保持灵活。这使得函数比具有固定数量参数的函数更灵活，同时具有采用不确定数量参数的函数的一些灵活性。</p><p id="a36a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">arguments</code>对象拥有函数的所有参数。此外，它不是一个真正的数组，所以数组函数对他们不可用。它只是一个对象，用索引和键来表示参数的位置。</p><p id="1d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank">sort</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">map</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">forEach</a></code>或<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener ugc nofollow" target="_blank">pop</a></code>这样的方法不能在<code class="fe lv lw lx ly b">argument</code>的对象上运行。它还具有其他属性。这给程序员造成了困惑。用rest操作符转换成数组的参数没有这些问题，因为它们是真实的数组。</p><p id="faa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要调用我们编写的<code class="fe lv lw lx ly b">sum</code>函数，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="de62" class="nh mh it ly b gy ni nj l nk nl">const result = sum(1,2,3,4,5,6,7,8,9,10);</span></pre><p id="c866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">result</code>将是55，因为我们将所有的参数加在一起。<code class="fe lv lw lx ly b">otherNums</code>是除1和2以外的所有数字的数组。</p><p id="f44b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用rest操作符将一个参数列表析构为一个变量列表。这意味着我们可以用spread操作符将参数列表转换成数组，然后将参数数组分解成变量列表。</p><p id="3901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常有用，因为我们可以获得rest操作符所操作的数组条目，并将它们转换为命名变量。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="cdca" class="nh mh it ly b gy ni nj l nk nl">const sum = (a,b,...[c,d,e])=&gt; a+b+c+d+e;</span></pre><p id="18e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以使用rest操作符，但是要限制函数接受的参数数量。我们取函数参数<code class="fe lv lw lx ly b">a</code>和<code class="fe lv lw lx ly b">b</code>，也取<code class="fe lv lw lx ly b">c</code>、<code class="fe lv lw lx ly b">d</code>、<code class="fe lv lw lx ly b">e</code>为参数。</p><p id="355f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，不使用rest操作符可能会更清楚，因为所有的参数都是固定的，我们可以直接列出参数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ffff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">for await...of</code></h1><p id="6e8c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">for await...of</code>循环允许我们创建一个循环，它迭代一个承诺列表以及一个普通可迭代的条目。</p><p id="8747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它适用于可迭代对象，如数组、字符串、<code class="fe lv lw lx ly b">argument</code>对象、<code class="fe lv lw lx ly b">NodeList</code>对象、<code class="fe lv lw lx ly b">TypedArray</code>、<code class="fe lv lw lx ly b">Map</code>、<code class="fe lv lw lx ly b">Set</code>以及用户定义的同步和异步可迭代对象。</p><p id="9a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用它，我们写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="41c5" class="nh mh it ly b gy ni nj l nk nl">for await (let variable of iterable) {<br/>  // run code on variable<em class="nm"><br/></em>}</span></pre><p id="0cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以用<code class="fe lv lw lx ly b">const</code>、<code class="fe lv lw lx ly b">let</code>或<code class="fe lv lw lx ly b">var</code>来声明<code class="fe lv lw lx ly b">variable</code>，可迭代对象是我们正在迭代的可迭代对象。我们可以迭代异步可迭代对象，如下所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1c86" class="nh mh it ly b gy ni nj l nk nl">const asynNums = {<br/>  [Symbol.asyncIterator]() {<br/>    return {<br/>      i: 6,<br/>      next() {<br/>        if (this.i &lt; 20) {<br/>          return Promise.resolve({<br/>            value: this.i++,<br/>            done: false<br/>          });<br/>        }</span><span id="8d7f" class="nh mh it ly b gy nn nj l nk nl">return Promise.resolve({<br/>          done: true<br/>        });<br/>      }<br/>    };<br/>  }<br/>};</span><span id="704e" class="nh mh it ly b gy nn nj l nk nl">(async () =&gt; {<br/>  for await (let num of asynNums) {<br/>    console.log(num);<br/>  }<br/>})();</span></pre><p id="2398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该会看到6到19个日志。它也适用于异步生成器:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9c75" class="nh mh it ly b gy ni nj l nk nl">async function* asynNumGenerator() {<br/>  var i = 6;<br/>  while (i &lt; 20) {<br/>    yield i++;<br/>  }<br/>}</span><span id="9533" class="nh mh it ly b gy nn nj l nk nl">(async () =&gt; {<br/>  for await (let num of asynNumGenerator()) {<br/>    console.log(num);<br/>  }<br/>})();</span></pre><p id="1d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到同样的事情被记录下来。它也适用于承诺:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f334" class="nh mh it ly b gy ni nj l nk nl">const arr = Array.from({<br/>  length: 20<br/>}, (v, i) =&gt; i)</span><span id="69b7" class="nh mh it ly b gy nn nj l nk nl">let promises = [];</span><span id="586f" class="nh mh it ly b gy nn nj l nk nl">for (let num of arr) {<br/>  const promise = new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(num);<br/>    }, 100)<br/>  })<br/>  promises.push(promise);<br/>}</span><span id="4663" class="nh mh it ly b gy nn nj l nk nl">(async () =&gt; {<br/>  for await (let num of promises) {<br/>    console.log(num);<br/>  }<br/>})();</span></pre><p id="d095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，如果我们运行上面的代码，我们应该看到从0到19的顺序记录，这意味着承诺是按顺序迭代的。这非常方便，因为在引入循环语法之前，我们从来没有任何东西可以遍历异步代码。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cdb0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">无极. finally()</h1><p id="a1ef" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">finally</code>函数被添加到<code class="fe lv lw lx ly b">Promise</code>对象中，该对象在承诺完成时运行。这意味着无论承诺是被实现还是被拒绝，它都会运行。</p><p id="3f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它需要一个回调函数，这个函数在承诺完成时运行。这让我们可以运行代码，而不管承诺如何结束。同样，这意味着我们不再需要在<code class="fe lv lw lx ly b">then</code>和<code class="fe lv lw lx ly b">catch</code>函数的回调中复制代码。</p><p id="ab5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe lv lw lx ly b">finally</code>功能，我们按如下方式使用:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3c7f" class="nh mh it ly b gy ni nj l nk nl">promise<br/>.finally(()=&gt;{<br/>  // run code that when promise is settled<br/>})</span></pre><p id="a24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">finally</code>很有用，因为我们希望在承诺结束时运行代码，比如清理代码或在代码结束后进行处理。</p><p id="41f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和叫<code class="fe lv lw lx ly b">.then(onFinally, onFinally)</code>很像。然而，我们不必声明它两次来为它创建一个变量并传递它两次。对<code class="fe lv lw lx ly b">finally</code>函数的回调没有任何参数，因为没有办法预先确定承诺的状态。</p><p id="2e20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它用于我们不知道承诺会发生什么的情况，所以不需要提供任何论据。如果履行了承诺，那么在调用<code class="fe lv lw lx ly b">finally</code>函数后，解析的值将保持不变。</p><p id="08c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8bdd" class="nh mh it ly b gy ni nj l nk nl">Promise.resolve(3).then(() =&gt; {}, () =&gt; {})</span></pre><p id="83b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将解析为<code class="fe lv lw lx ly b">undefined</code>，但是如果我们:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6553" class="nh mh it ly b gy ni nj l nk nl">Promise.resolve(3).finally(() =&gt; {})</span></pre><p id="7926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将解析为3。同样，如果承诺被拒绝，我们会得到:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d938" class="nh mh it ly b gy ni nj l nk nl">Promise.reject(5).finally(() =&gt; {})</span></pre><p id="5ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将被值5拒绝。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="12d0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">SharedArrayBuffer</h1><p id="dee1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">SharedArrayBuffer</code>是一个用来表示固定长度的原始二进制数据缓冲区的对象。</p><p id="9da1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它类似于<code class="fe lv lw lx ly b">ArrayBuffer</code>对象，但是我们可以用它在共享内存上创建视图。它不能超脱，不像一个<code class="fe lv lw lx ly b">ArrayBuffer</code>。它的构造函数将缓冲区的长度作为参数。</p><p id="3be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长度是要创建的数组缓冲区的字节大小。它返回一个指定大小的<code class="fe lv lw lx ly b">SharedArrayBuffer</code>,内容初始化为0。</p><p id="86a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主线程上的多个工作线程可以创建和更新共享内存。但是，这可能需要一段时间，直到更改传播到所有上下文。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0369" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="f253" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有了ES2018，我们有了更多方便的功能来帮助开发人员开发JavaScript应用。</p><p id="ef6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">亮点包括对象的spread操作符，它允许我们将键值对复制到其他对象，以及rest操作符，它允许我们传递可选参数。</p><p id="662f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">for await...of</code>循环让我们遍历异步代码的集合，这在以前是不容易做到的。</p></div></div>    
</body>
</html>