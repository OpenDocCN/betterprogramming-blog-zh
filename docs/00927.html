<html>
<head>
<title>Create a Custom useModal() React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个自定义的useModal() React挂钩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-custom-usemodal-react-hook-449b5909cc09?source=collection_archive---------1-----------------------#2019-07-29">https://betterprogramming.pub/create-a-custom-usemodal-react-hook-449b5909cc09?source=collection_archive---------1-----------------------#2019-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fc3c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">谁不喜欢好的、简单的模态呢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/adfd33152d74d9cac4f1f81dd97ba949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmQsx_PbP-hlL5oel-ymlg.png"/></div></div></figure><p id="6f5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我正在通读<a class="ae lq" href="https://scotch.io/" rel="noopener ugc nofollow" target="_blank"> Scotch.io </a>，我看到了Chris Nwamba的一篇关于创建自定义<a class="ae lq" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a> Hook: <code class="fe lr ls lt lu b">useFetch</code>的<a class="ae lq" href="https://scotch.io/tutorials/create-a-custom-usefetch-react-hook" rel="noopener ugc nofollow" target="_blank">文章。</a></p><p id="1711" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">定制钩子是我一直在工作和兼职项目中使用的东西，我已经创建了几个(包括<code class="fe lr ls lt lu b">useModal</code>)来分享。</p><p id="ee31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">众所周知，React挂钩是JavaScript函数，它允许您从函数组件中使用React状态和效果。自定义钩子是一个名字以<code class="fe lr ls lt lu b">use</code>开头的函数，调用其他钩子的函数。</p><p id="8678" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于自定义React挂钩，我不会详细介绍，上面的文章是一个很好的起点。</p><p id="c317" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想直接得到代码和演示，你可以看看下面的链接:</p><ol class=""><li id="1f71" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ma mb mc md bi translated"><a class="ae lq" href="https://csb-n1drq.netlify.com/" rel="noopener ugc nofollow" target="_blank">演示</a></li><li id="267c" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ma mb mc md bi translated"><a class="ae lq" href="https://github.com/CITGuru/custom-react-modal-hook" rel="noopener ugc nofollow" target="_blank"> GitHub代码</a></li><li id="170d" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ma mb mc md bi translated"><a class="ae lq" href="https://codesandbox.io/s/cocky-gauss-n1drq" rel="noopener ugc nofollow" target="_blank">项目</a></li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b51e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">入门指南</h1><p id="bd27" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">在本教程中，我将解释如何为模态组件创建自定义的React钩子。</p><p id="1174" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于React中的可访问性和结构问题，模态组件非常麻烦。模态在屏幕上有一个覆盖层，它比所有其他元素具有更高的视觉优先级。</p><p id="29f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们使用z指数，它应该是最高的。然而，这是一种不好的做法，因为它嵌套很深，并且树中的父元素优先于CSS。</p><p id="d1aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，要构建一个好的React模态组件，我们需要:</p><ul class=""><li id="f82d" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp nn mb mc md bi translated">出于可访问性的原因，使用门户将模态添加到DOM body属性的末尾。</li><li id="ac91" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">一旦呈现了DOM，就将模态挂载到DOM。</li><li id="9e96" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">当模态被隐藏时，从DOM中移除它们。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d330" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">构建一个反应模式组件</h1><p id="8eb4" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">我们将从构建一个使用自定义<code class="fe lr ls lt lu b">useModal</code>的React模态组件开始。</p><p id="b9db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个教程，我将使用<a class="ae lq" href="https://bloomer.js.org/" rel="noopener ugc nofollow" target="_blank">blomer</a>的模式，你可以用<code class="fe lr ls lt lu b">yarn add bloomer</code>安装它们。</p><p id="4215" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看下面这个简单的模态分量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="942a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个相当容易理解的组件，有助于将我们的组件包装在一个函数中。我们可以用以下方式启动它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ea28" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">编写自定义钩子:useModal</h1><p id="706d" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">我们的模态组件已经准备好了，让我们看看主主题，看看如何创建一个<code class="fe lr ls lt lu b">useModal</code>钩子。</p><p id="0aff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8be0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面我们做了不少事情:</p><ul class=""><li id="c0d3" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp nn mb mc md bi translated">为我们的<code class="fe lr ls lt lu b">modalOpen</code>状态添加了<code class="fe lr ls lt lu b">useState</code>钩子，并将值设置为<code class="fe lr ls lt lu b">initialMode</code>。</li><li id="20da" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">声明了一个调用<code class="fe lr ls lt lu b">setModalOpen</code>的<code class="fe lr ls lt lu b">toggle</code>函数，它将改变我们的<code class="fe lr ls lt lu b">modalOpen</code>值。</li><li id="bc58" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">返回了<code class="fe lr ls lt lu b">modalOpen</code>、<code class="fe lr ls lt lu b">setModalOpen</code>和<code class="fe lr ls lt lu b">toggle</code>，因此组件可以访问它们。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6f81" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用</h1><p id="c3e7" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">然后，为了同时使用<code class="fe lr ls lt lu b">CustomModal</code>和<code class="fe lr ls lt lu b">useModal</code>，考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="25eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Tada！我们现在可以使用一个定制的钩子来启动我们的模态了:<code class="fe lr ls lt lu b">useModal</code>。</p><p id="26ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里所做的就是:</p><ul class=""><li id="1655" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp nn mb mc md bi translated">导入我们的<code class="fe lr ls lt lu b">useModal</code>函数，初始化它，并访问<code class="fe lr ls lt lu b">itemModalOpen, setItemModalOpen, toggleModal</code>。</li><li id="c352" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">我们将<code class="fe lr ls lt lu b">toggleModal</code>传递给按钮，这样我们就可以用按钮切换我们的模态。</li><li id="6092" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">接下来，我们将<code class="fe lr ls lt lu b">itemModalopen</code>传递给<code class="fe lr ls lt lu b">isActive</code>道具。</li><li id="02ce" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">然后我们将<code class="fe lr ls lt lu b">setItemModalOpen</code>传递给我们的<code class="fe lr ls lt lu b">handleClose</code> prop函数。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d3ae" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">将数据传递给模式:useModalWithData</h1><p id="169b" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">我们的<code class="fe lr ls lt lu b">useModal</code>工作得很好，可以毫无故障地使用。</p><p id="05a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，启动模型的速度很快，而且无法知道是哪个元素启动了它，也无法通过钩子向它传递数据。</p><p id="74d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们假设您正在处理一个包含数据列表的表。您希望能够单击一行或一列，并让一个模态显示您所单击内容的全部细节。</p><p id="93be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种方法是，您需要将一个<code class="fe lr ls lt lu b">id</code>，或者您点击的元素的完整数据，传递给<code class="fe lr ls lt lu b">useModal</code>，然后传递给将使用该数据的组件。</p><p id="afec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑下面的定制挂钩<code class="fe lr ls lt lu b">useModalWithData</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3a31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在上面所做的是:</p><ul class=""><li id="1365" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp nn mb mc md bi translated">初始化我们之前的<code class="fe lr ls lt lu b">useModal</code>，从钩子访问<code class="fe lr ls lt lu b">modalOpen</code>和<code class="fe lr ls lt lu b">setModalOpen</code>。</li><li id="6596" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">初始化<code class="fe lr ls lt lu b">useState</code>以存储我们选择的<code class="fe lr ls lt lu b">id</code>状态，以及<code class="fe lr ls lt lu b">setSelected</code>以应用更改。</li><li id="ae07" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">声明一个将<code class="fe lr ls lt lu b">state</code>作为道具的<code class="fe lr ls lt lu b">setModalState</code>函数，调用<code class="fe lr ls lt lu b">setModalOpen</code>来控制模态，如果<code class="fe lr ls lt lu b">state</code>为假，则将<code class="fe lr ls lt lu b">selected</code>设置为空。</li><li id="2646" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated">然后我们返回钩子之外可以访问的东西。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="61d8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用</h1><p id="e4f8" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">在本例中，我们将创建三个组件:</p><ul class=""><li id="bf3f" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp nn mb mc md bi translated"><code class="fe lr ls lt lu b">UserTable</code>:以表格形式显示用户列表。</li><li id="3eb4" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated"><code class="fe lr ls lt lu b">UserDetail</code>:显示用户的全部详细信息。</li><li id="b498" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp nn mb mc md bi translated"><code class="fe lr ls lt lu b">UserInformation</code>:用于<code class="fe lr ls lt lu b">UserTable</code>和<code class="fe lr ls lt lu b">UserDetail</code>的组件包装器。</li></ul><p id="c411" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从创建一个表格组件开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="38df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面是一个简单的React组件，它映射给定的数据，并在一个表格中显示出来。</p><p id="7d75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来要看的是显示全部细节的<code class="fe lr ls lt lu b">UserDetail</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="25fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的组件应该很容易理解，因为我们只显示了道具的数据。</p><p id="f39e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何将所有这些放在<code class="fe lr ls lt lu b">UserInformation</code>组件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2427" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们添加虚拟数据来填充我们的表。我们现在可以使用它，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="564f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="b6b2" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">由于React构造DOM的方式，模态可能是React中一个棘手的组件。与React挂钩一起使用会使它更复杂。</p><p id="a6e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你已经学会了如何创建一个定制的模态钩子，你可以将相同的模态逻辑扩展到不同类型和风格的模态。</p><p id="2b28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在以后的文章中，我会写一系列关于我使用钩子的方法，从无限卷轴到表单等等。</p><p id="eb89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你也应该订阅我的YouTube视频教程。</p><p id="1cfb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div></div>    
</body>
</html>