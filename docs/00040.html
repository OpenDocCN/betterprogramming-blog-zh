<html>
<head>
<title>How to Communicate Between Components in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular组件之间进行通信</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-how-to-communicate-between-components-69aed0a283da?source=collection_archive---------6-----------------------#2017-07-18">https://betterprogramming.pub/angular-how-to-communicate-between-components-69aed0a283da?source=collection_archive---------6-----------------------#2017-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1555" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">多个组件使我们的应用程序更具可重用性，但是我们如何在它们之间进行通信呢？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b2c01a27b149f20deede1b71ba467908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCSHJve_b1PKjzpgBrgPEA.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">来源<a class="ae le" href="https://unsplash.com/photos/6bKpHAun4d8" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/6bKpHAun4d8</a></p></figure><h1 id="0d00" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">将数据传递给组件</h1><p id="6f3f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们想使用来自<code class="fe mi mj mk ml b">@angular/core</code>的<code class="fe mi mj mk ml b">@Input()</code>装饰器将数据从父组件传递给组件。让我们回顾一个简单的例子，看看这是如何实现的。</p><p id="ec47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要创建一个新组件<code class="fe mi mj mk ml b">ng g c name_of_your_component</code>，我将我的组件命名为<code class="fe mi mj mk ml b">first</code>，然后导入<code class="fe mi mj mk ml b">@Input()</code>装饰器并创建一个<code class="fe mi mj mk ml b">name</code>变量:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c749" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的<code class="fe mi mj mk ml b">first.component.html</code>应该是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f562" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以在<code class="fe mi mj mk ml b">app.component.html</code>中使用我们的组件，但是对于<code class="fe mi mj mk ml b">name</code>变量呢？我们可以通过使用<code class="fe mi mj mk ml b">class="btn"</code>将数据传递给组件。不清楚？请参见下面的示例。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7186" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您执行<code class="fe mi mj mk ml b">ng serve -o</code>时，您应该看到<code class="fe mi mj mk ml b">Hello, Asu!</code>这是一种从父组件向组件传递数据的简单方法。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="7597" class="lf lg it bd lh li mv lk ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc bi translated">从组件获取数据</h1><p id="befc" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">有一个<code class="fe mi mj mk ml b">@Output()</code>装饰器，就像<code class="fe mi mj mk ml b">@Input()</code>一样，你可以从<code class="fe mi mj mk ml b">@angular/core</code>导入它:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4fef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将<code class="fe mi mj mk ml b">@Input()</code>装饰器改为<code class="fe mi mj mk ml b">@Output()</code>，并用<code class="fe mi mj mk ml b">constructor</code>中的<code class="fe mi mj mk ml b">Asu</code>初始化<code class="fe mi mj mk ml b">name</code>变量。</p><p id="6b53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mi mj mk ml b">app.component.ts</code>中，我们需要像读取对象属性一样读取<code class="fe mi mj mk ml b">name</code>变量，但首先让我们将角度<code class="fe mi mj mk ml b">id</code>添加到<code class="fe mi mj mk ml b">app.component.html</code>中:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="25a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过使用来自<code class="fe mi mj mk ml b">@angular/core</code>的<code class="fe mi mj mk ml b">@ViewChild</code>装饰器来使用<code class="fe mi mj mk ml b">app.component.ts</code>中的id <code class="fe mi mj mk ml b">#firstComponent</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="23a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第10行你可以看到我们使用了<code class="fe mi mj mk ml b">@ViewChild('id')</code>。在这种情况下，id是<code class="fe mi mj mk ml b">firstComponent</code>。更远的部分是标准的<code class="fe mi mj mk ml b">accessor name_of_variable: type</code>。在由<code class="fe mi mj mk ml b">OnInit</code>接口实现的功能<code class="fe mi mj mk ml b">ngOnInit</code>中，我们使用基本的警告功能来显示来自第一个组件的<code class="fe mi mj mk ml b">name</code>。您可以尝试在<code class="fe mi mj mk ml b">constructor</code>中做同样的事情，但是在控制台中，您应该会看到类似于<code class="fe mi mj mk ml b">Can't get name of undefined</code>的错误。这是因为在构造函数级别，我们的第一个组件直到我们的父组件激活后才激活。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="bbee" class="lf lg it bd lh li mv lk ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc bi translated">组件间通信的终极方式</h1><p id="c865" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">服务！是的，当使用服务在组件之间进行通信时，不需要父子或父子关系。</p><p id="39da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">生成服务<code class="fe mi mj mk ml b">ng g s services/Store --module=app</code>。我在<code class="fe mi mj mk ml b">app.module</code>中添加了一个<code class="fe mi mj mk ml b">--module</code>标志来提供服务。</p><p id="d5e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想给你们看一个不好的例子，为此，我们需要在我们的组件中做一些改变:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="08fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第14行我们注入<code class="fe mi mj mk ml b">StoreService</code>。它可以从<code class="fe mi mj mk ml b">store</code>属性中获得。让我们生成名为<code class="fe mi mj mk ml b">second</code>的第二个组件:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1836" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并将其添加到<code class="fe mi mj mk ml b">app.component.html</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9df7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个简单的例子中，我们更改了<code class="fe mi mj mk ml b">second</code>组件中的<code class="fe mi mj mk ml b">name</code>，然后在<code class="fe mi mj mk ml b">first</code>组件中刷新它。仅仅更改名称就需要做大量的工作，而刷新并不是我们想要的。相反，我们可以使用名为<code class="fe mi mj mk ml b">Subject</code>和<code class="fe mi mj mk ml b">Observable</code>的<code class="fe mi mj mk ml b">rxjs</code>库中的工具。使用这些有什么好处？<code class="fe mi mj mk ml b">name</code>将在<code class="fe mi mj mk ml b">first</code>组件中自行刷新，无需我们的帮助。</p><p id="8710" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们告诉你如何做到这一点。</p><p id="3bf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以保持<code class="fe mi mj mk ml b">second</code>组件现在的样子，但是我们要改变<code class="fe mi mj mk ml b">first</code>组件和<code class="fe mi mj mk ml b">StoreService</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7d1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在构造函数中，我们订阅了来自<code class="fe mi mj mk ml b">StoreService</code>的名为<code class="fe mi mj mk ml b">getName()</code>的函数；我们可以订阅这个，因为它返回<code class="fe mi mj mk ml b">Observable</code>。Subscribe意味着每当可观察到的变化时，它将做<code class="fe mi mj mk ml b">subscribe</code>中的所有事情。</p><p id="fac0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要在html中添加<code class="fe mi mj mk ml b">async</code>管道。管道本身将处理诸如在组件被破坏后显示新值或取消订阅之类的事情(它防止内存泄漏)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="be73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每当我们在主题属性上调用<code class="fe mi mj mk ml b">next</code>函数时，可观察值就会改变，在我们的例子中，这个函数叫做<code class="fe mi mj mk ml b">name</code>。</p><p id="0021" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我看来，这是组件间通信的最佳方式，但这取决于我们想要共享数据的组件树中有多少组件。</p></div></div>    
</body>
</html>