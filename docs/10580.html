<html>
<head>
<title>Understanding Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Kubernetes</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-kubernetes-fe2999fa54f1?source=collection_archive---------10-----------------------#2022-01-16">https://betterprogramming.pub/understanding-kubernetes-fe2999fa54f1?source=collection_archive---------10-----------------------#2022-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0c94" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解Kubernetes的基本知识和工作原理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/28c57d148d0bc3c35c5d5c62d6654796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V-NB5yyebcERt64r"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@verneho?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Verne Ho </a>拍摄的照片</p></figure><p id="6d9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是三篇文章中的第一篇，将包括Kubernetes架构基础知识、监控基础知识(关注指标和资源使用)以及开源监控解决方案与生产环境需求的比较。</p><p id="bb43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们都是我硕士论文的一部分(<em class="ls">在生产环境中对Kubernetes集群的开源监控解决方案进行比较</em>)。我将尝试用超链接更新对特定章节的引用，以使导航更容易，并为清晰起见将参考书目放在一篇单独的文章中。</p><p id="4155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“了解Kubernetes”让您对Kubernetes是什么以及它是如何工作的有一个基本的概念。除了这一章的理论背景之外，它的目的是为将要与容器和Kubernetes交互并希望在日常工作中学习使用它的开发人员提供一个基本的理论背景。</p><h1 id="1a39" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">库伯内特的起源</h1><p id="502e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">2014年年中，谷歌首次宣布开发Kubernetes [2]。它深受Google的Borg系统(集群管理系统，它“接纳、调度、启动、重启和监控Google运行的所有应用程序”[3])的影响。最初，它的目标是编排容器并与Docker一起工作。</p><p id="9b05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2015年7月10日，它首次发布了1.0版本，并与Linux基金会建立了合作伙伴关系，成立了著名的今日云原生计算基金会(CNCF) [4]。从那时起，Kubernetes已经发展并获得了许多新的特性和扩展。截至2021年3月15日的当前版本是v1.20，其中一个主要的变化是Docker不再作为容器运行时，而是支持使用为Kubernetes [5]创建的适当CRI的普通容器。但是在解释Kubernetes生态系统本身之前，应该先解释像容器、容器引擎和容器编排器这样的基础知识。</p><h1 id="4ed6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">容器</h1><p id="49ab" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">简而言之，我们今天看到的容器是一个构建目标应用程序及其依赖项的包并在开箱即用的地方运行它的概念。所说的“包”实际上是一个操作系统的映像(除了<em class="ls"> scratch </em>容器)，而“某处”是一个容器引擎。因此，如果有人说“容器”,我们需要考虑在容器引擎上运行的图像实例。</p><h2 id="54f0" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">容器图像</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/d7d93b682b90bd579680f37d8149ec5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8kwfRT245X-Xtwsfdf3v2w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。1容器映像构建流程</p></figure><p id="db2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2015年6月22日，由Docker、CoreOS和集装箱行业的其他领导者发起了开放集装箱倡议(OCI)[6]。OCI是一个轻量级、开放的治理结构(项目)，它的形成得益于Linux基金会，旨在围绕容器格式和运行时创建开放的行业标准。该规范定义了如何创建OCI图像。容器格式和运行时的核心贡献者之一是Docker。构建过程将根据Docker的构建引擎机制和功能进行解释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/67c54794899f564b949d811c05848177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhXjb3vgqmmzQ0xEp3B7-g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。2示例Dockerfile文件</p></figure><p id="dd8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器图像由层层叠加而成。图2.1和2.2显示了用于创建图像的示例图层。映像构建指令存储为Dockerfile，每个指令代表一个层。构建过程中会缓存图层，并对每个图层计算SHA总和。由于缓存，重建时间大大减少，因为只有改变层重建，每一层，直到结束docker文件。</p><p id="59ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建指令包括设置基本映像、添加数据(本地和远程)、运行数据配置命令和设置容器特定元数据(例如，开放端口、入口点等)。).考虑到这一点，构建指令的幂等性问题就出现了。问题是，如果来自网络的远程包作为图层下载，是在重建期间重新下载还是使用缓存图层？答案是——如果不使用Docker build命令的适当标志显式强制这样做，它将不会被重新构建。这迫使开发人员尽可能固定第三方软件包的版本，以在需要完全重建映像的情况下保持幂等性。</p><h2 id="ae48" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">容器</h2><p id="88d6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在构建了容器映像并准备运行之后。它被部署到一个容器引擎，并在现有的主机操作系统上运行，无需硬件虚拟化。事实上，它调用主机操作系统内核来模拟容器中的底层操作系统。需要注意的是，容器不是虚拟机。两者的比较可以在第2.6章中找到。</p><p id="1ee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器引擎使用某些Linux内核功能来实现容器运行时，包括使用cgroups(控制组)和名称空间(见图2.4)。控制组允许指定一组进程使用的总资源的限制和度量。这些可以是f. ex。CPU、内存、网络或IO配额。另一方面，名称空间用于缩小一组进程通过某些进程树、网络接口、用户id或文件系统挂载的可见性[7]。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/029b25f90515169f3e0a26187fde04f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQxZBgnj6IY6NTkxSN_wHg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。4个容器组件</p></figure><p id="99b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">某个容器的cgroups和namespaces的集合产生了一个在宿主Linux系统中运行的完全隔离的环境。这些内核功能的存在和使用是容器同时在可伸缩性和安全性方面如此优秀的纯粹解释。它们可以访问与系统上运行的其他容器相同的资源池，但是已经以编程方式设置了它们不能跨越的资源配额和可见性限制。</p><p id="247a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器的生命周期由容器引擎(容器运行时)控制，这将在下一节中解释。</p><h1 id="478b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">容器运行时</h1><p id="efd8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">容器运行时(也称为容器引擎)是部署容器运行的地方(见图2.5)。以下是几种常见的容器运行时:</p><ul class=""><li id="8308" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">集装箱[8]，</li><li id="2517" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">CRI-O [9]</li><li id="e50a" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">Docker [10]。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/eabe30645b6547044601fca8ec05a6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlIsqAgNfCmcdHVytcPFrg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。5如何看待容器、容器引擎和操作系统</p></figure><p id="cba7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们的工作是按照用户的意愿控制容器的生命周期，以便它们可以运行、停止、恢复或销毁。它们还提供了一个以多种方式与容器交互的接口:</p><ul class=""><li id="55c8" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">执行容器中的命令，</li><li id="2e7f" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">检查容器的标准输出，</li><li id="1d00" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">获取指标(例如CPU使用率、内存使用率和限制)，</li><li id="08c5" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">检查容器配置细节(例如分配的IP地址)。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/abe190d58f80f214ca61704911feeec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*07vKMXQ-hmPnoYzcxPWBIg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。6 Linux容器体系结构分解</p></figure><p id="fb0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如图2.6所示，除了容器生命周期控制之外，容器运行时还充当容器内操作系统和主机操作系统之间的代理。</p><p id="a01c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于容器和容器引擎的更多阅读可以在RedHat博客[11]中找到。</p><h1 id="6fd1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">容器编排器</h1><p id="65c8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">容器编排器在管理资源和生命周期方面比容器引擎高一层(见图2.7)。容器引擎允许在单个节点上运行容器，而orchestrator允许在多个节点上同步调度容器，而不管本地化和节点主机操作系统配置如何。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/d464e3fd376529fee2165b44c5919061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9vmV8eWdAqLxhgjPqurbQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。Linux容器体系结构中的编排层</p></figure><p id="4dba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当前可用的容器编排器支持完全的多云、多区域设置，甚至多架构设置(例如，Raspberry Pi上的arm64架构上的一些本地节点和AWS云中的amd64虚拟化EC2节点，这形成了多区域、混合、多拱设置)。简而言之，orchestrators管理容器运行时，并提供许多领域的扩展，如使用CNI(容器网络接口)的网络增强。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/f65ab2ee9209f82b3572aaad68d85d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gk_dJ5DwIS-3SLuzf2wBmw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。8示例多云Kubernetes集群[12]</p></figure><p id="f471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多云设计(参见图2.8中的示例)是一种涉及多个云提供商的架构，例如。一个混合了亚马逊网络服务(AWS) EC2实例和谷歌云平台(GCP)谷歌计算引擎(GCE)实例的集群。这可能是因为各种原因而使用的，比如价格/价值差异，或者在一个云上部署旧系统，而在新的云上部署新产品。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/eb053210c598ea6af60cf805ec0538b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ri_XAY2C4C1h8kJ9q3x3NQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。9多区域Kubernetes设置示例</p></figure><p id="0bcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多区域设置是指多个k8s集群在多个区域共同努力实现一个目标，例如。(参见图2.9)一个集群部署在法兰克福，另一个部署在爱尔兰，两个集群都运行相同的应用程序，连接到法兰克福的相同数据库(DB)，这样两个地区的客户端都可以有合理的延迟，从而获得更好的用户体验。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/607e59b5688a09f4201c5064d4164026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OOM6cg-NxG2BAgh6Bqnkg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。10多架构Kubernetes设置示例</p></figure><p id="5067" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多架构设置是指在一个Kubernetes集群中，使用几个硬件架构来组装一个集群。其中一个用例是硬件效率，同时部署架构相关软件，例如部署由标准x86 amd64节点构成的集群，其中仅运行amd64兼容应用，并将其余应用部署在高能效ARM节点上。</p><h2 id="eaf2" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">资源分解</h2><p id="dd10" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">containers orchestrators在行业中取得成功的最具革命性的因素之一是管理资源的能力。当将被编排的节点集群被组装时，其资源被虚拟分解(参见图2.11)，这意味着它们不再被视为可以部署工作负载的独立空间，而是可以使用的单个资源池。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/445500e132651c757ebaa9d8e3edcad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*zGO_lE6UMy7gYNU2aNnDmw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。11容器编制器节点资源分解</p></figure><p id="c8cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们从3台机器组装一个集群，每台机器有4个vcpu和16GB RAM，我们将看到一个包含12个vcpu和48GB RAM的资源池。然而，仍然有物理边界需要考虑。创建容器编排器是为了支持微服务的架构，因此单个微服务相对小于整体系统。但是，如果在上面的示例中，我们要部署一个需要分配6个vCPUs和8GB内存的工作负载，container orchestrator将无法安排此类工作负载的部署。也就是说，由于物理资源边界不可跨越，多节点CPU计算对于不是为这样做而设计的系统来说是低效的，并且由于所使用的容器化，它应该是通用的。因此，协调器不再需要集群管理员负责高效的工作负载分配过程，但是在设计集群配置时，仍然应该考虑工作负载的规模。</p><h1 id="3009" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">库伯内特斯</h1><p id="762a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如今最受关注的容器编排器是Kubernetes(参与CNCF调查的78%的公司都使用它)[13]。它是一个复杂但仍在不断发展的工具和引擎，用于编排由容器和第三方自定义操作符组成的同构和异构环境。Kubernetes集群由一个控制平面和一个数据平面组成(见图2.12)。核心功能由控制平面的组件(主节点)提供:</p><ul class=""><li id="4857" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">etcd数据库，</li><li id="515e" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">调度程序，</li><li id="626d" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">API服务器，</li><li id="fdc3" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">控制器管理器。</li></ul><p id="1ca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个节点也有一个:</p><ul class=""><li id="3c69" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">库伯莱，</li><li id="038a" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">kube-proxy，</li><li id="5665" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">容器-运行时。</li></ul><p id="70d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有这些节点构成了一个数据平面，称为工作节点(见图2.12)。上述所有组件将在接下来的章节中解释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/a5fbf204ae331b7d0176f0605e917ad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bfp1ck0GhZNQzpcXnYFng.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。12 Kubernetes建筑简而言之[14]</p></figure><p id="6e6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubernetes状态作为对象存储在数据库中。对象可以很容易地写成YAML的清单。它们也可以以各种其他格式查看，例如使用k8s CLI的JSON，名为<em class="ls"> kubectl </em>。在Kubernetes中需要解释的最重要的物体是一个<em class="ls">豆荚</em>。一个<em class="ls"> pod </em>是一个对象，它配置一个容器(或几个容器)在集群中运行，并具有适当的标签、安全性和网络配置。</p><p id="5ed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubernetes目前用于两种模式:自管理(称为标准)和提供者管理(称为托管)。它们的不同之处在于如何为最终用户提供控制平面，我们将在以下部分进行解释。</p><h2 id="8438" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">控制平面</h2><p id="7e4a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">控制面板的职责是使用内部组件管理整个集群。</p><p id="b333" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Etcd数据库是存储集群状态的地方。它可以以高可用性(HA)和单节点方式部署。对集群的每个更改都在<code class="fe nw nx ny nz b">etcd</code>数据库中有一个引用，以便在任何节点出现故障的情况下，可以直接从存储的状态数据中进行协调。</p><p id="d974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调度程序的职责是调度集群中的pod。它会观察新创建的pod，并根据许多因素来决定应该调度哪个节点。这些因素包括:“个人和集体的资源需求、硬件/软件/策略约束、相似性和反相似性规范、数据局部性、工作负载间干扰和截止日期”[15]。</p><p id="9219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制器管理器实际上是监视k8s对象和维护集群状态的多个控制器的集合。这些控制器的一些类型是节点控制器(管理节点连接)、作业控制器(一次性类型的pod)和端点控制器(连接pod和服务对象)。</p><p id="02b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API服务器充当控制平面组件之间的代理，但也为集群的用户提供接口。部署到集群的所有清单都要经过API服务器，在将它们插入etcd数据库之前，会在API服务器中对其进行解析和错误检查。在集群中运行的对象的可观察性也由API服务器提供。</p><p id="7b3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述组件构成了控制平面，但这些组件并不是运行在这些节点上的唯一组件。还有一个kubelet、kube-proxy和container-runtime，它们运行在集群中的每个节点上，将在下一节中解释。</p><h2 id="14c2" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">数据平面</h2><p id="3f9a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">数据平面的职责是维护与主平面的连接，为当前运行的工作负载提供低级容器管理功能和可观察性。</p><p id="32e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubelet是在集群中的每个节点上运行的代理。“它确保容器在容器中运行”[15]。但是，它不管理不是由Kubernetes创建的容器。</p><p id="8dd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kube-proxy是一个网络组件，它维护节点上的网络规则，并允许集群内外的网络会话。</p><p id="ac02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器运行时也是每个节点上可用的数据平面的核心组件。</p><h2 id="2c11" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">托管Kubernetes</h2><p id="c88f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">“三大”云提供商——AWS(亚马逊网络服务)、GCP(谷歌云平台)和Azure(微软)提供一种叫做托管Kubernetes的服务。每个都有自己的命名AWS上的EKS、GCP上的GKE和Azure上的AKS:</p><ul class=""><li id="0559" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">亚马逊的弹性Kubernetes服务(EKS)</li><li id="0968" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">微软的Azure Kubernetes服务(AKS)</li><li id="d1c6" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">谷歌的Kubernetes引擎(GKE)。</li></ul><p id="5f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与标准部署和使用方式的不同之处在于，在这种情况下，控制平面由云提供商管理。用户仍然能够使用清单中的配置来配置群集，但是控制平面运行状况和HA的所有责任都依赖于服务提供商。</p><p id="8695" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，工作节点管理仍然是集群用户的责任。一些云提供商还提供自动化控制平面更新，只需几个手动配置步骤(EKS)，其他提供商甚至提供全自动集群升级流程以及工作节点(GKE) [16]。</p><h1 id="d824" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">监控Kubernetes</h1><p id="1729" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">考虑到container orchestrator的特性和流经Kubernetes集群的海量数据，可以监控的字段数量非常大，包括:</p><ul class=""><li id="2588" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">节点资源利用率，</li><li id="b88a" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">网络策略(例如拒绝点击)，</li><li id="09f2" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">网络流量利用率，</li><li id="b4d6" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">网络流量类型，</li><li id="7588" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">应用程序指标，</li><li id="91b4" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">还有更多…</li></ul><p id="6cb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于本文的考虑，我们将只深入考虑节点资源利用率(CPU和RAM)。市场上有各种监控解决方案。其中许多为Kubernetes集群监控提供了完整的解决方案，不仅包括指标收集和分析，还包括日志记录、解析和警报。弹性公司[17] [18]的ELK Stack和Metricbeat就是一个完整解决方案的例子。</p><h1 id="d4d1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">容器与虚拟机</h1><p id="5108" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">注意Linux容器和虚拟机(VM)之间的区别是很重要的。两者都是打包的计算环境，将各种应用程序及其依赖项与系统的其余部分隔离开来。核心区别在于规模和便携性。</p><p id="aacc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虚拟机被设计得很大，并在里面存储整个单片系统。它的资源是预先指定的，很难移动，主要是因为硬件虚拟化涉及f. ex。系统引导过程。</p><p id="f2b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器设计得很小，包含一个应用程序及其依赖项。由于其轻量级的设计和共享的操作系统，在多个环境之间移动它们也很容易。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/7a5c0505aad0f95d7f347df069aec74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ii4oRW7itCtcBZGER_Pxaw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。13架构比较:虚拟化与容器[19]</p></figure><p id="ee5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与容器组和名称空间分离设计相反，虚拟机使用一种称为管理程序的软件来将资源从物理机中分离出来，并将其分配给特定的虚拟机(参见图2.13)。这是主要的难点，因为它强制执行硬资源固定，并支持紧密耦合。而容器更多地支持松散耦合和高内聚的架构，如图2.14中的例子所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/ccfb22437fb3d70c81ef1ddc3a7788f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5f8ZXHHy6I9pSPQKCO-QJg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。14微服务、SOA和单片架构中的通信示例[20]</p></figure><p id="1188" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，虚拟化更多的是针对旧的整体式或面向服务的方法，而容器更多的是针对微服务架构。</p><h1 id="ea1f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">文献学</h1><p id="9d80" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@patryk.kobielak/thesis-knowledge-cycle-bibliography-a50ccbaab9ad" rel="noopener">文章中的所有链接和来源</a></p></div></div>    
</body>
</html>