<html>
<head>
<title>With ES Modules and HTTP/2 You May Not Need Webpack Anymore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有了ES模块和HTTP/2，您可能不再需要Webpack</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2020-004-the-rollout-of-modules-is-complete-d25f04870284?source=collection_archive---------14-----------------------#2020-01-15">https://betterprogramming.pub/2020-004-the-rollout-of-modules-is-complete-d25f04870284?source=collection_archive---------14-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0686" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">是时候全面拥抱进口/出口了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17e08d2678b71555c80195681724cb20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVPlLQLA8VY4fshdbKTBlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复用流上的JavaScript模块</p></figure><p id="1833" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">随着JavaScript模块在各种主流浏览器中得到全面支持，精明的开发人员现在可以在没有Webpack的情况下交付生产就绪的应用。</em></p><p id="6db2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前端Web开发人员正处于将其应用程序投入生产的新方式的风口浪尖。由于浏览器最终支持使用符合ECMA-262标准的模块的<code class="fe lv lw lx ly b">import</code>和<code class="fe lv lw lx ly b">export</code>，对传输器和打包器的需求正在消失。</p><p id="059a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，微软Edge是最后一个例外，它阻碍了我们在野外部署ES模块。今天，随着基于Chromium的Edge 76的发布，每个主流浏览器都支持新的模块标准。这对我们如何构建和部署代码有着巨大的影响。</p><p id="57b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解我的观点，请允许我分享一些背景故事。</p><p id="56b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">走到今天这一步是一条漫长的道路，经历了性能分析器、任务运行器、传输器、打包器和HTTP协议的重大变革。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4035" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">雅虎！时代</h1><p id="7413" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">2005年，雅虎发表了一篇文章，后来成为某种前端圣经。回顾今天的星群，雅虎看起来像是一个昏暗的尘埃。但是在《时代》杂志的“有史以来最有影响力的15个网站”排名中，雅虎。排名第七。</p><p id="6c31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">引起所有骚动的文章标题是“加速你的网站的最佳实践”最重要的是它的黄金法则<em class="lu">减少HTTP请求</em>。对于如何实现这一点，它给出了明确的建议:将所有的脚本合并到一个文件中。</p><p id="3982" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在那个时候，组合你的脚本是一个容易遵循的戒律。我们写的大部分都是操纵用户界面的简单事件监听器。更复杂的网站可能偶尔会编写一个函数，触发一个<code class="fe lv lw lx ly b">XMLHttpRequest</code>来检索数据。</p><p id="de6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论哪种方式，不管我们在这个时代写了什么，都是放在全球范围内的。因此，当我们的网站发展到具有更强的交互性时，全球范围的使用变得越来越成问题。如何命名一个迭代一系列事物的函数，如何将这个名字与其他相似的名字分开？像<code class="fe lv lw lx ly b">iterateThing1()</code>和<code class="fe lv lw lx ly b">iterateThing2()</code>这样的名字应该不是闻所未闻。</p><p id="354b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个时代，我有一个客户，他的全部20，000行代码都在一个文件中。团队中的每个开发人员都在同时工作！有些东西必须放弃。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8749" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">AMD和CommonJS时代</h1><p id="daa2" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">作为程序员，我们在这里没有遇到任何新的东西。定义本地名称空间是每一种主流编程语言都必须解决的一个共同需求。在几乎所有情况下，文件级的模块化代码都是解决方案。不幸的是，对于当时的JavaScript开发人员来说，这种语言还没有成熟到允许这样做。</p><p id="5ac5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">取而代之的是应用级的解决方案，以异步模块定义(AMD)规范及其<code class="fe lv lw lx ly b">RequireJS </code>实现的形式出现。使用这种解决方案，文件中的所有内容都被包装在自己的上下文中，将其函数和变量与外部隔离，有效地防止了名称冲突。每个文件本身就是一个单元。为了使用这个单元，开发者可以通过用一个<code class="fe lv lw lx ly b">define()</code>函数包装目标来选择对外界可见的内容。和任何其他想要访问它的单元，将使用一个<code class="fe lv lw lx ly b">require()</code>函数来完成。</p><p id="ce8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当这发生在前端时，Node.js正忙于处理后端的相同问题。他们的解决方案是CommonJS模块系统。在该系统中，开发人员将通过声明一个<code class="fe lv lw lx ly b">module.exports </code>语句来选择对外界可见的内容。任何其他想要获得这些出口的单位都需要一份<code class="fe lv lw lx ly b">require</code>声明。</p><p id="d274" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同一问题的两种不同解决方案。</p><p id="8afd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">快进到2015年，ECMAScript的TC39委员会加入了这场争论，并正式宣布了直接解决模块化代码需求的新语言特性。他们宣布，模块将通过两个新的关键字获得一流的语言支持:<code class="fe lv lw lx ly b">import</code>和<code class="fe lv lw lx ly b">export</code>。这就结束了争论。</p><p id="8920" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是宣布和实施是两回事。直到2017年末，第一个实现才在Chrome浏览器中实现。还需要两年半的时间<code class="fe lv lw lx ly b">import/export</code>才能被所有主流浏览器完全支持。</p><p id="a587" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">AMD、CommonJS和ES模块的完整故事无需在此赘述。但是<code class="fe lv lw lx ly b">import/export</code>的长期推出所带来的后果对我的故事很重要。结果是，希望获得模块化代码好处的开发人员不得不做出选择:要么使用旧的模块语法编写，要么使用新的语法编写，然后<em class="lu">将其转换回旧的语法以便部署。</em></p><p id="2846" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我的项目，我选择用新的语法来写。为了将代码部署到产品中，我使用了一个专门构建的CLI工具，我称之为<a class="ae nd" href="https://hub.readwritetools.com/tasks/eximjs.blue" rel="noopener ugc nofollow" target="_blank"> eximjs </a>，它将<code class="fe lv lw lx ly b">import</code>和<code class="fe lv lw lx ly b">export</code>语句转换为CommonJS语句。当我编写这个工具时，我认为它的寿命很短。我没想到我会用它五年！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8261" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">邦德勒时代</h1><p id="bbe2" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">看到他们的未来，许多项目选择通过使用transpilers来超越不可避免的事情。巴贝尔成为这一领域无可争议的冠军。它完美地解决了模块语法问题，同时还为TC39宣布的其他新特性提供了polyfills和shims。</p><p id="f584" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现这一点，前端开发人员开始远离伴随他们成长的简单的<em class="lu">脚本</em>工作流，并开始转向<em class="lu">构建过程</em>。这推动了对任务运行者的需求:可以作为一系列步骤运行的工具。最初，Grunt和Gulp满足了这个需求。我们使用它们来建立构建过程，每当源代码文件发生变化时，就对其进行编译、链接、测试和缩减。</p><p id="edeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模块化架构成为现实，开发人员全力以赴。名称空间问题已经解决。</p><p id="3a5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是DevOps的人首先注意到这种新方法产生了自己的一系列问题。或者说，它重新浮现了雅虎多年前小心翼翼发现的老问题。大量的小文件意味着大量的HTTP请求，这意味着更长的加载时间。但是我们不会因此而停止设计模块化架构。我们需要一种不同的方法。</p><p id="3a77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新方法以捆扎机的形式出现。我们一直使用的任务运行器被新的工具所取代，这些工具解析我们的JavaScript并确定它的依赖关系。这些依赖模块被连接成一个包，并在一个HTTP请求中发送出去。DevOps很开心。</p><p id="4693" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个人都重组了他们的构建过程，放弃了任务运行器，用Browserify或Webpack这样的捆绑器取而代之。不久之后，竞争以package和Rollup的形式出现，前者减轻了Webpack所需的大部分配置开销，后者专注于同构JavaScript和捆绑ES模块的愿望。</p><p id="be8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着时间的推移，许多有趣的问题已经被bundlers解决了。例如，<em class="lu">树摇动</em>和<em class="lu">分块</em>是对构建过程的主要改进。另一方面，在浏览器中，<em class="lu">代码分割</em>和<em class="lu">延迟加载</em>对到达目标的包进行了重大优化。今天，bundler toolscape仍然存在，并且与包大小和缓存相关的性能改进正在进行中。</p><p id="a8a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这一切都有问题。原来的问题是HTTP的线头阻塞问题，被雅虎这么小心翼翼的叫出来。随着我们的应用程序变得越来越复杂，它变成了名称空间问题。然后，当我们等待TC39精确地指定新的模块加载器应该如何工作时，它变成了语言缺陷问题。在此期间，它变成了bundler性能问题，因为我们试图平衡所有竞争需求，以实现更快的传输、按需加载和缓存。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9d4e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2020年时代</h1><p id="b0ef" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">但是让我们休息一下，在整个Web堆栈的更广泛的背景下重新检查这些问题。特别是，让我们在HTTP的上下文中来看它们。</p><p id="901a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">甚至在模块戏剧展开的同时，我们最初的性能问题的解决方案以HTTP/2的形式出现了。我们都非常熟悉的经典Web协议的这一更新提供了对我的故事非常重要的两个主要改进:持久连接和多路复用流。</p><p id="c3a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是这样工作的。使用HTTP/2，对HTML文档的请求会打开浏览器和服务器之间的连接，该连接会一直保持打开，直到所有需要的东西都到达。此外，当浏览器发现它需要什么(图像、字体、脚本、样式)时，它会请求它们，而不会暂停或等待响应完全完成。这是可行的，因为新协议有多路复用流，所以所有这些请求可以同时进行。简而言之，线头阻塞问题变得没有实际意义。</p><p id="0266" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在请允许我简短地离题。一听说HTTP/2，我就自然而然地寻找支持新协议的web服务器以及我正在编写的Node.js库。我对当时看到的一切都不满意。这成为我创建<a class="ae nd" href="https://hub.readwritetools.com/enterprise/rwserve.blue?utm_term=TheRolloutOfModulesIsComplete" rel="noopener ugc nofollow" target="_blank">读写服务</a> HTTP/2服务器的催化剂。今天，我在每个新项目中都使用这个服务器，我可以证明新协议的优势。持久连接和多路复用流如宣传的那样交付。</p><p id="15b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个新协议与我的信条直接相关，即捆扎机将很快成为过去的遗迹。因为HTTP/2如此完美地容纳了许多文件，所以应用程序不需要单独处理优化的任何部分。</p><p id="9591" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">HTTP/2和本地es模块提供的优势是多方面的:</p><ul class=""><li id="4476" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated">当使用JavaScript <code class="fe lv lw lx ly b">import</code>和<code class="fe lv lw lx ly b">export </code>语言语句时，Transpilation不再是必要的。</li><li id="5788" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">调试不再需要源代码映射，因为源代码不会被transpiler破坏。</li><li id="b057" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">不需要复杂的试探法来猜测最佳的块边界，因为块不是一个东西。</li><li id="342b" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">分割包不需要管理代码，因为模块是作为离散的命名文件到达的。</li><li id="de0b" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">不需要延迟加载优化器，因为浏览器只在需要时才请求脚本和资源。</li><li id="fc58" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">不需要摇动树，因为浏览器只请求它发现的依赖项。</li><li id="6f96" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">浏览器、服务器和内容交付网络的缓存都可以充分利用HTTP的<code class="fe lv lw lx ly b">cache-control</code>、<code class="fe lv lw lx ly b">if-none-match</code>和<code class="fe lv lw lx ly b">etag</code>头，节省网络带宽，提高吞吐量。</li><li id="2af0" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">DevOps人员可以使用每种mime类型的最佳方法来微调文件压缩。</li></ul><p id="8b6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与带有bundlers的HTTP/1.1相比，带有本机ES模块的HTTP/2显然是赢家。简而言之，源代码文件可以直接投入生产，而不需要我们为自己创造的所有代码。</p><p id="f478" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">长期以来，我们一直将JavaScript视为编译语言，以至于我们忘记了它实际上是一种解释语言。是的，我们可能仍然想使用棉绒和缩绒机，以保持整洁，但所有其他轧棉机只是适得其反。</p><p id="6ef4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，如果你对你的团队选择构建工具有任何影响，现在是重新思考你为什么需要Webpack的好时机。</p><p id="e4c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">保持简单是更聪明的成功之道。</p></div></div>    
</body>
</html>