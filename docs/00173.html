<html>
<head>
<title>How to Write Callbacks in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中编写回调</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/callbacks-in-node-js-how-why-when-ac293f0403ca?source=collection_archive---------0-----------------------#2018-08-16">https://betterprogramming.pub/callbacks-in-node-js-how-why-when-ac293f0403ca?source=collection_archive---------0-----------------------#2018-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb35" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们听起来很难，但是让我们花点时间来解释为什么它们不难</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/184de42d5c6d79205e210b0dc361431a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VRRKecfkGmW9W62l.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">她在打电话，这完全相关。</p></figure><p id="fdf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你从Node.js开始，你会很快遇到回调。它们是如此流行的一个概念，以至于你已经听说过它们，但是可能还没有想太多。哦，现在你来了——嗨！</p><p id="8235" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们定义回调之前，我们需要理解它们为什么存在。它们的存在是因为<strong class="la iu">节点的</strong> <strong class="la iu">的异步性质。众所周知，异步编程“更好”但“更难”。</strong></p><h1 id="d70b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">好吧，最后一句有点过于简单了</h1><p id="3ec6" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">让我们更深入一点，比较以同步方式编写的代码和异步方式编写的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e12e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你马上会注意到的是<strong class="la iu">异步</strong>版本是……丑陋的。看起来我们确实在为一点点收益把事情变得不必要的复杂，所以在你决定打包JS回到PHP之前，让我们马上讨论一下收益吧！</p><p id="d104" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于<strong class="la iu">异步</strong>编程很酷的一点是，当你的代码等待某件事情被完成时(比如一个API调用或者来自一个神秘而遥远的数据库的响应),它可以做别的事情。换句话说，当一个进程花费很长时间时，你的代码不会被阻塞。这实际上是创建<strong class="la iu"> Node.js </strong>的主要原因:运行同步代码的服务器花费大量时间等待。如果服务器可以在等待<strong class="la iu"> I/O </strong>的同时处理请求，那么事情就会做得更快<em class="mt">(</em><strong class="la iu"><em class="mt">I/O</em></strong><em class="mt">代表</em> <strong class="la iu"> <em class="mt">输入/输出</em> </strong> <em class="mt">顺便说一下！)</em></p><p id="0ee3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于异步编程来说，事情确实有点复杂，尤其是当你开始的时候，但是这并不是一个很难理解的概念，而且好处是值得的。</p><p id="f97a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对“<strong class="la iu">异步编程</strong>”和“<strong class="la iu">无阻塞</strong>”这样的术语有了更好的理解，我们来回答一个简单的问题。</p><h1 id="3350" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">什么是回调？</h1><blockquote class="mu mv mw"><p id="a95e" class="ky kz mt la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated"><strong class="la iu">回调只是一个作为参数传递给另一个函数的函数，该函数将使用它(回调它)。</strong></p></blockquote><p id="33e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个简单而又大胆的回调函数<strong class="la iu">的例子。</strong></p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cb24" class="nf lv it nb b gy ng nh l ni nj">fs.readFile(funFileName, <strong class="nb iu">function(err, file)</strong> <strong class="nb iu">{<br/>    if(err)<br/>        handleError(err);<br/>    console.log("file: ", file)<br/>}</strong>)</span></pre><p id="f4a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当<code class="fe nk nl nm nb b">fs.readFile</code>完成获取文件<code class="fe nk nl nm nb b">funFileName</code>时，它执行回调函数，如果抛出错误，该函数将处理错误，并将检索到的文件记录到控制台。</p><p id="fe3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意回调函数有两个参数:<code class="fe nk nl nm nb b">err</code>和<code class="fe nk nl nm nb b">file</code>。按照惯例，回调函数的第一个参数是一个错误。如果父函数抛出一个错误，它会在那里等待你去处理，如果没有抛出错误——这种情况时有发生——那么第一个参数应该是<code class="fe nk nl nm nb b">null</code>。同样按照惯例，以下参数是响应数据。查阅<a class="ae nn" href="https://nodejs.org/api/errors.html#errors_error_first_callbacks" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> Error-First回调</strong> </a> <strong class="la iu"> </strong>了解更多相关信息。</p><p id="221f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一切都很好，但为什么不简单地将上面的内容写成这样:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a511" class="nf lv it nb b gy ng nh l ni nj">let file = fs.readFile(fooFileName);</span><span id="b4b5" class="nf lv it nb b gy no nh l ni nj">console.log("file: ", file);</span></pre><p id="fcaf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，<em class="mt">因为异步。</em></p><p id="3797" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第二个例子中，当我们试图记录时，<code class="fe nk nl nm nb b">file</code>将是未定义的，因为在到达<code class="fe nk nl nm nb b">console.log()</code>之前，<code class="fe nk nl nm nb b">fs.readFile</code>不会完成获取。</p><p id="93c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我向你保证:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1164" class="nf lv it nb b gy ng nh l ni nj">let file = 1+1;</span><span id="e034" class="nf lv it nb b gy no nh l ni nj">console.log("file: ", file);</span></pre><p id="7557" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">会管用的。</p><p id="5ac1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于只和同步编程打过交道的新人来说，感觉有点混乱；你过着充满爱和逻辑的幸福生活，突然，第3行可以在第2行之前执行！？为了确保万无一失，你应该在任何地方都使用回调吗？号码</p><p id="a9df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们<em class="mt">不知道</em>什么时候会完成某件事的时候，就会使用回调。再一次，考虑类似API调用的东西，从数据库或硬盘驱动器的I/O获取数据。所有这些都需要时间，所以我们希望在我们等待的事件完成时调用我们的回调。因此有了术语<strong class="la iu">事件驱动编程。</strong></p><p id="27a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得你只有<em class="mt">种</em>懂了，不要觉得孤独。像生活中的许多事情一样，需要一点实践经验才能真正明白。</p><p id="78b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您获得实际操作经验之前，让我向您介绍一下您将遇到的下一个难题。</p><h1 id="8d5a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">回调地狱</h1><p id="85e0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">下面的代码不用研究的太透彻，看看就知道了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1dbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恶。这可能不是你想要的代码，除非你真的喜欢三角形。</p><p id="bcb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看起来像上面的代码被命名为<strong class="la iu">回调地狱</strong>。Async JS不需要<em class="mt">需要</em>这样，但是很容易不小心写了几个函数就意识到自己深陷回调地狱。又来了。</p><p id="161d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解释可以用来编写更干净的异步代码的许多策略超出了这篇介绍性文章的范围，但是当你准备好的时候，这里有一个甜蜜的链接可以让你得到一些想法:<a class="ae nn" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">callbackhell.com</a>。</p><h1 id="94f1" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="202e" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">回调是函数。您将它们传递给其他函数，这样它们就可以在适当的时候执行，也就是回调所需的事件发生的时候。这种做事方式是异步编程自带的，没那么难，值得。</p><h1 id="70ab" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">即将推出…</h1><p id="76d2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果你从回电开始，你会很快遇到承诺，你应该在承诺之前确保你真的得到了回电，但是你也应该有一天去了解承诺。因此，请继续关注更好的编程，以确保您了解即将发布的关于承诺的文章！</p></div></div>    
</body>
</html>