<html>
<head>
<title>An Introduction to Accelerator and Parallel Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速器和并行编程简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-accelerated-and-parallel-programming-introduction-2f91420fb4f0?source=collection_archive---------4-----------------------#2022-10-07">https://betterprogramming.pub/an-accelerated-and-parallel-programming-introduction-2f91420fb4f0?source=collection_archive---------4-----------------------#2022-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="94e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">加速器的重要性和使用都在持续增长，这对开发者来说意味着什么？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/767aae0434ecece614a86221a7a89428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GJdQxXxIrkgxIH_B"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7aa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算机是达到目的的一种手段。它们让我们能够更快地解决复杂的问题，提供在全球范围内存储和检索信息的能力，为机器人、自动驾驶汽车(某种程度上)和人工智能等卓越的技术提供支柱，并有望改善地球上每个人的生活。随着要解决的问题变得越来越复杂，计算机体系结构、编程语言和编程模型也在不断发展。这导致了硬件加速器和特定领域编程模型的增长。</p><p id="c7d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自加州大学伯克利分校的David Patterson教授(我大学时所有计算机架构书籍的作者)已经<a class="ae kv" href="https://hipporeads.com/uc-berkeleys-david-a-patterson-sees-the-future-after-moores-law/" rel="noopener ugc nofollow" target="_blank">广泛地谈论了特定领域架构</a>和加速器。今天，当我们谈论硬件加速器时，我们经常谈论GPU。然而，出现了无数不同类型的加速器来解决各种问题，包括深度学习和人工智能，这些加速器利用专门设计的硬件来执行大规模矩阵运算，这是DL工作负载的核心。</p><p id="e5d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，传统CPU中内置了硬件加速技术，如英特尔高级矢量扩展指令集(AVX)和英特尔高级矩阵扩展指令集(AMX)。</p><p id="a9a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着新加速器的出现，如何为该加速器编程总是一个挑战。目前可用的大多数加速器都基于并行执行，因此也是某种形式的并行编程。</p><p id="4dc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们将讨论并行编程以及在现代加速器上实现并行编程的各种方法的系列文章的第一篇。</p><h1 id="c98a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">并行性概述</h1><p id="a51f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">并行编程是我们如何编写代码来表达任何代码/算法中的并行性，以使其在一个加速器或多个CPU上运行。但是什么是并行呢？</p><p id="5188" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并行性是指程序的一部分可以与程序的另一部分同时运行。通常，我们将其分为两类:任务并行和数据并行。</p><h2 id="fefa" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">任务并行性</h2><p id="f338" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">任务并行是指多个功能可以同时独立执行。一个例子是准备一个聚会。一个人可能得到气球，另一个人可能得到冰淇淋，第三个人可能得到蛋糕。虽然没有这三样东西聚会就不完整，但三个不同的人可以独立于其他人做他们需要做的事情，只要他们在聚会前完成并在正确的地方见面。</p><p id="5547" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将此映射到计算机程序，每个人都类似于一些计算硬件(CPU/GPU/FPGA)，选择各种项目就是要运行的任务。</p><h2 id="2e00" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">数据并行性</h2><p id="d5b0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">数据并行是指相同的功能可以在几个相同的数据上独立执行。想象一下，上面例子中的那个人去买冰淇淋，但是另外四个人也想买冰淇淋。潜在地，所有五个人可以同时从同一个商店的冰箱里得到冰淇淋。</p><p id="daec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们再次把人比作计算机硬件，每个人的任务都是买冰淇淋。冰淇淋是我们对数据的(美味)类比。</p><p id="c101" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些例子很简单，但希望有指导意义。并行还有更微妙的类型，尤其是在计算机体系结构领域，但是这些简单的类比可以帮助您理解在进行并行编程时如何考虑并行性。</p><h1 id="07c6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可用资源、可用并行度和争用</h1><p id="6717" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">关于并行性，需要考虑的一些重要因素是可用资源和给定解决方案空间中的可用并行性。</p><ul class=""><li id="65a6" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">我们可能会受到完成一项任务的资源数量的限制——如果我只有三个人，我一次只能做三项任务。</li><li id="b8cb" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">我们可能会受到可用任务的限制——如果我的聚会只需要气球和蛋糕，第三个人执行任务对我没有帮助。</li><li id="c3b7" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">我们可能会受到可用数据的限制——如果我有五个人想买冰淇淋，但商店冰箱里只剩下三个容器的冰淇淋，那么两个人将无事可做。</li></ul><p id="fddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个需要考虑的问题是争用。资源通常是有限的，我们试图并行化一个问题时经常会遇到资源访问的问题。</p><p id="1360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们想象一下，我们去商店买冰淇淋，冰柜里有100个容器的冰淇淋，但是一次只能有三个人站在冰柜前面。这意味着，即使有100个人在那里买冰淇淋，由于进入冰柜的机会有限，买冰淇淋的人数最多也只有三人。</p><p id="9fb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类比适用于各种计算机硬件。举个例子:把冰箱的存取想象成一条内存总线。如果它不够宽，不能让所有的数据以足够快的速度流向加速器，那么您的加速器就会停滞不前，等待对数据的访问来完成它需要做的事情。</p><h1 id="e81b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">简单的代码示例</h1><p id="d120" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了使这一点更加具体，让我们展示上面的数据并行购物问题的一些代码。我们首先创建一个购物者类。这个类的工作是执行购物的工作。在这种情况下，我使用一个简单的矩阵乘法来计算购物成本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="16e4" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">与<a class="ae kv" href="https://www.openmp.org/" rel="noopener ugc nofollow" target="_blank"> OpenMP </a>并行</h2><p id="bc00" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我已经定义了购物行为，让我们看看如何使用OpenMP使这段代码并行运行，OpenMP是一种可移植的解决方案，允许程序员在他们的程序中添加并行性。Pragma指令被添加到现有代码中，以告诉编译器如何并行运行部分代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="280b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个简单的代码由四个简单的部分组成:</p><ol class=""><li id="0d12" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr nr nh ni nj bi translated">第18行:创建<code class="fe ns nt nu nv b">65536</code>购物者</li><li id="5add" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr nr nh ni nj bi translated">第21行:调用<code class="fe ns nt nu nv b">Shop</code>函数</li><li id="e87f" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr nr nh ni nj bi translated">第10-12行:请每位顾客去购物</li><li id="5774" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr nr nh ni nj bi translated">第9行:告诉编译器何时使用OpenMP并行运行循环迭代的pragma</li></ol><p id="8a6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其余的只是计时器，所以我们可以看到并行运行代码的好处。</p><p id="841c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OpenMP代码的好处在于，你可以告诉编译器使用/不使用OpenMP，这样就会产生一个串行程序。</p><p id="ad1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我使用的是一台HP Envy*笔记本电脑，它配备了英特尔酷睿i7–12700h处理器、32GB内存和集成的英特尔Iris Xe GPU。该系统运行的是6.0内核Ubuntu* 22.04和英特尔oneAPI DPC++/C++编译器。</p><p id="29e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我使用以下命令启用了英特尔编译器环境:</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="d11b" class="mp lt iq nv b gy oa ob l oc od">&gt; /opt/intel/oneapi/setvars.sh</span></pre><p id="c1d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下命令编译代码:</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="5f98" class="mp lt iq nv b gy oa ob l oc od">&gt; icx -lstdc++ grocery-omp.cpp -o serial-test<br/>&gt; icx -lstdc++ -fiopenmp grocery-omp.cpp -o omp-test</span></pre><p id="5810" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个命令包括<code class="fe ns nt nu nv b">-fiopenmp</code>标志，告诉编译器使用OpenMP启用并行性。运行可执行文件时，我在系统上得到以下输出:</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="6354" class="mp lt iq nv b gy oa ob l oc od">&gt; ./serial-test<br/>Elapsed time in milliseconds: 27361 ms<br/>&gt; ./omp-test<br/>Elapsed time in milliseconds: 4002 ms</span></pre><p id="95c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OpenMP运行利用我的几个CPU内核同时完成工作，这导致OpenMP运行速度提高了6到7倍。</p><h2 id="adfd" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">oneAPI/SYCL的并行性</h2><p id="bb33" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">OpenMP是一种通过直接方法实现并行的绝佳方式。带有SYCL的C++是<a class="ae kv" href="https://www.oneapi.io/" rel="noopener ugc nofollow" target="_blank"> oneAPI </a>规范的一部分，它允许我们使用显式方法来表达并行性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="55ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，SYCL代码大于前面的代码库。然而，我们有相同的核心代码:</p><ol class=""><li id="95ef" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr nr nh ni nj bi translated">第31行:创建<code class="fe ns nt nu nv b">65536</code>购物者</li><li id="01b9" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr nr nh ni nj bi translated">第46行:调用<code class="fe ns nt nu nv b">Shop</code>函数</li><li id="4480" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr nr nh ni nj bi translated">第25行:让每个购物者去购物</li></ol><p id="3290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与我们使用指令的OpenMP示例不同，SYCL允许用户通过代码和C++结构显式定义他们程序的并行行为。这提供了OpenMP所不具备的运行时灵活性。</p><p id="d2fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据您的用例，一种范式可能比另一种更有意义。在这种情况下，我们有办法使用英特尔的oneAPI SYCL运行时并使用<code class="fe ns nt nu nv b">SYCL_DEVICE_FILTER</code>环境变量来获取单个二进制文件并以多种方式运行它:</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="89a0" class="mp lt iq nv b gy oa ob l oc od">&gt; SYCL_DEVICE_FILTER=host:host:0 ./sycl-test<br/>Running on device: SYCL host device<br/>Elapsed time in milliseconds: 27201 ms<br/>&gt; SYCL_DEVICE_FILTER=opencl:cpu:1 ./sycl-test<br/>Running on device: 12th Gen Intel(R) Core(TM) i7-12700H<br/>Elapsed time in milliseconds: 4197 ms<br/>&gt; SYCL_DEVICE_FILTER=opencl:gpu:3 ./sycl-test<br/>Running on device: Intel(R) Graphics [0x46a6]<br/>Elapsed time in milliseconds: 3988 ms</span></pre><p id="28b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ns nt nu nv b">SYCL_DEVICE_FILTER</code>的值来自运行sycl-ls命令，该命令是<a class="ae kv" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/base-toolkit.html" rel="noopener ugc nofollow" target="_blank">英特尔oneAPI基础工具包</a>的一部分。</p><p id="ab16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">oneAPI C++ with SYCL实现的酷之处在于，二进制代码可以将工作定向到多个设备。</p><h1 id="ab1d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="79ac" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">理解并行性和编写并行代码是一个复杂的问题。这篇初级读物描述了一个简单的例子，说明如何使用OpenMP和C++以及SYCL来实现并行性。在创建并行程序时，还有许多其他考虑因素，例如多个计算资源如何共享内存和变量，以及如何在多个资源之间平衡工作。</p><p id="7810" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在以后的文章中解决这些问题。但是现在，我鼓励您尝试抓住上面的简单示例，看看它在您的系统上是如何工作的。</p><p id="4444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="187b" class="mp lt iq nv b gy oa ob l oc od"><strong class="nv ir">Want to Connect?</strong></span><span id="cfb9" class="mp lt iq nv b gy oe ob l oc od">If you want to see what random tech news I’m reading, you can <a class="ae kv" href="https://twitter.com/tonymongkolsmai" rel="noopener ugc nofollow" target="_blank">follow me</a> on Twitter.</span></pre><p id="a8b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="of">英特尔、英特尔标志和其他英特尔标志是英特尔公司或其子公司的商标。</em></p></div></div>    
</body>
</html>