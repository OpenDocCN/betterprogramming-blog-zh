<html>
<head>
<title>Refactoring From a Huge Storyboard to Multiple Smaller and More Manageable Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从一个巨大的故事板到多个更小更易管理的对象的重构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/from-a-huge-storyboard-to-multiple-smaller-and-manageable-objects-3c165fd7022a?source=collection_archive---------7-----------------------#2020-01-20">https://betterprogramming.pub/from-a-huge-storyboard-to-multiple-smaller-and-manageable-objects-3c165fd7022a?source=collection_archive---------7-----------------------#2020-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b489" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理故事板引用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8a2de3c8c4745cfbcb1aa702df71f420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PNAMBkF3aYOawwOh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0eb3" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">这一天已经到来</h1><p id="1484" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我最近开发了一款已经上市一段时间的iOS应用。这是一个在苹果发布其新的wonder框架SwiftUI之前发布的应用程序，使用单个故事板来实现整个UI。</p><p id="a00a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">正如经常发生的那样，一个应用程序是以一种方式构思、设计和最终创建的，随着时间的推移，会在流程和演进中进行修正、改进和更改。</p><p id="8da8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">简而言之，新的场景被添加到原始的故事板中，随着时间的推移，这些场景变得越来越多。</p><p id="bebe" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最终的结果是，正如我们许多人所经历的那样，Xcode现在费力而缓慢地打开了一个大故事板。</p><p id="0f5d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不仅仅是在场景之间移动，例如，检查它们是如何相互连接的，或者选择一个视图控制器来编辑它或纠正图形缺陷，现在都不再非常容易。</p><p id="3911" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所以，这一天对我来说也到了。我的工作是通过将场景分成多个故事板来消除这个包含所有UI的巨大对象。</p><p id="29ec" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们的目标是拥有更小、更易管理的故事板，加快Xcode的开放时间，并且为了有一天有更多的开发人员开发该应用，限制合并的问题以及在版本控制下工作时通常会遇到的实际冲突。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="52e0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">多重故事板</strong></h1><p id="f3ea" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我之前参与过其他使用多重故事板的项目。然而，这些从一开始就被构思和设计，然后被创造出来。因此，一切都很简单。</p><p id="a03b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我知道哪些视图控制器与分布在不同场景中的其他控制器相连接。在不同故事板中实现的场景之间的转换通常以下列方式进行:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8846" class="ne lh it na b gy nf ng l nh ni">let storyboard = UIStoryboard(name: “SecondStoryboard”, bundle: nil)</span><span id="18ae" class="ne lh it na b gy nj ng l nh ni">let secondVC = storyboard.instantiateViewController(identifier:”SecondViewController”)</span><span id="a4a2" class="ne lh it na b gy nj ng l nh ni">show(secondVC, sender: self)</span></pre><p id="ffef" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">同一个故事板中场景之间的转换是通过界面构建器设置的segues来管理的。</p><p id="da52" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我不得不面对与我相关的新问题:</p><ul class=""><li id="ab82" class="nk nl it ma b mb mu me mv mh nm ml nn mp no mt np nq nr ns bi translated">以某种方式将现有的场景组合在一起。</li><li id="5775" class="nk nl it ma b mb nt me nu mh nv ml nw mp nx mt np nq nr ns bi translated">将不同故事板上的组分开。</li><li id="c164" class="nk nl it ma b mb nt me nu mh nv ml nw mp nx mt np nq nr ns bi translated">确保场景之间的导航(分布在不同的故事板中)继续工作。</li></ul><p id="5fd5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">分组视图控制器显然是最简单的活动。在某种程度上，它已经完成了。负责登录、密码恢复等的视图控制器。基本上都被紧密地放在故事板上，一切都很简单。</p><p id="e553" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">由于场景的分离和它们的导航分布在几个故事板上，我不得不在网上寻找一些贡献来找到一个舒适的方法。</p><p id="cb02" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这让我能够深入研究我只听说过的东西，并解决两种不同的方法，每种方法都有自己的有趣之处。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d0f2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">一种完全的界面构建方法</strong></h1><p id="fbab" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">听说过故事板参考吗？苹果在iOS 9和macOS 10.11中引入了它们。他们做的正是我需要的。</p><p id="88d9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">它们允许你将一个故事板分成多个更小的故事板。故事板参考将多个故事板联系在一起，创建一个大型的复合故事板。</p><p id="2122" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我对它们的使用如此简单感到非常惊讶。我们只需要:</p><ul class=""><li id="f331" class="nk nl it ma b mb mu me mv mh nm ml nn mp no mt np nq nr ns bi translated">打开我们巨大的故事板。</li><li id="6023" class="nk nl it ma b mb nt me nu mh nv ml nw mp nx mt np nq nr ns bi translated">选择我们想要提取的场景并放在一个单独的文件中。</li><li id="c4ad" class="nk nl it ma b mb nt me nu mh nv ml nw mp nx mt np nq nr ns bi translated">使用Xcode <em class="ny">编辑器</em>菜单中的<em class="ny">重构到故事板……</em>选项。</li></ul><p id="d1f8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们最喜欢的IDE只是询问我们新故事板的名称，我们最终可以决定将新文件放在一个新的文件夹或一个现有的文件夹中。完成了。</p><p id="3ac9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">使用现有片段在场景之间导航，无需做任何更改。用于设置视图控制器的“准备”功能，例如将数据传输到目标场景，按原样工作。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8173" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">手动编程方式</strong></h1><p id="ca37" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这种方法迫使手动生成较小的故事板。</p><p id="1654" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在我的具体案例中，一旦我确定了注定要收集场景的一般组，我就复制独特的大故事板以获得一些完全相同的文件。因此，我将特定的名称归属于各个重复项，如“登录”、“内容”、“设置”。</p><p id="0ffd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我把这些新的故事板导入到解决方案中，然后一个接一个地清理它们，只留下对每个组有用的场景。</p><p id="d266" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在工作结束时，登录故事板只包含登录场景。其他人根据他们的专业各自包含自己的场景。</p><p id="3d8d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这种方法还迫使您编写一些代码来正确调用在不同故事板上实现的视图控制器。这是本文开头已经提到的方法，请参见下面的代码示例。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4220" class="ne lh it na b gy nf ng l nh ni"><strong class="na iu">let</strong> storyboard = UIStoryboard(name: "SecondStoryboard", bundle: <strong class="na iu">nil</strong>)</span><span id="df84" class="ne lh it na b gy nj ng l nh ni"><strong class="na iu">let</strong> secondVC = storyboard.instantiateViewController(identifier: "SecondViewController")</span><span id="6bf8" class="ne lh it na b gy nj ng l nh ni">show(secondVC, sender: <strong class="na iu">self</strong>)</span></pre><p id="cc8c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">它易于编写和阅读，并且可以快速修改以替换现有代码，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e7d7" class="ne lh it na b gy nf ng l nh ni"><strong class="na iu">self</strong>.performSegue(withIdentifier: "goThere", sender: <strong class="na iu">self</strong>)</span></pre><p id="a9bd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最终，如果目标场景需要来自调用视图控制器的值，则准备函数中的代码不再有用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b660" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">并且可以简单地替换为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="70c9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">话虽如此，如果我们不需要在每次需要从一个场景“跳到”另一个场景时都显式地实例化故事板和视图控制器，那会更方便。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8a3d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">可选择路线</strong></h1><p id="1ff6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">“可传递”允许你以一种非常简单的方式显示故事板中的一个场景，正如在这个<code class="fe ob oc od na b">ViewController</code>类的例子中的三个方法中很容易看到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5dd8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如您所见，每次我们需要将用户带到特定屏幕时，没有必要显式地实例化目标故事板和视图控制器。</p><p id="f748" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">从源控制器和目标控制器发送信息简单明了。参见本文末尾的<code class="fe ob oc od na b">Routable</code>组件的完整代码。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="aa73" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">Xcode 11和iOS 13推出的最新更新</strong></h1><p id="44f9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">令我惊讶的是，在我的研究过程中，我发现Xcode 11和iOS 13为故事板引入了一些新功能。我指的是<code class="fe ob oc od na b">SegueActions</code>和自定义初始化器。</p><h2 id="e4a5" class="ne lh it bd li oe of dn lm og oh dp lq mh oi oj ls ml ok ol lu mp om on lw oo bi translated"><strong class="ak">后续行动</strong></h2><p id="c45e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们已经看到，如果我们使用segues在场景之间导航，我们必须实现<code class="fe ob oc od na b">prepare</code>函数来将数据从起始视图控制器传输到另一个。</p><p id="24ce" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们必须编写一个switch语句来检查segue标识符名称，然后准备我们要发送到目的地控制器的值。在此之前，我们必须检查标识符是否为零，并最终从函数中退出。</p><p id="e915" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们可以避免实现这个函数，而是使用一个<code class="fe ob oc od na b">SegueAction</code>，这是我们的视图控制器中的一个方法，UIKit在后续过程中调用它。</p><p id="7b07" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">下面的例子展示了一个简单的<code class="fe ob oc od na b">SegueAction</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="3f70" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果不需要所有的输入参数，我们可以选择更简洁的形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2cf8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">目标视图控制器应该用自定义初始值设定项来实现，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="adcf" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">创建<code class="fe ob oc od na b">SegueAction</code>的过程非常简单。我们像在IB中一样创建segue，在我的例子中，我将我的蓝色按钮连接到一个目的地视图控制器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c3dec55ffeff3120db8545b889ec8fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JZY2IkvUNjiDPf7b"/></div></div></figure><p id="73c0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们选择这样的段落:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/9aa6d642494c20bb480b32aebbc468a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XEj7IAh4buBVsNCZ"/></div></div></figure><p id="eb6f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后，我们创建<code class="fe ob oc od na b">SegueAction</code>,就像通过从segue和<code class="fe ob oc od na b">viewController</code>的代码中拖动连接来创建<code class="fe ob oc od na b">IBAction</code>一样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/83e04edda7328bb8040ea6597ee8f257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OC_V62axSqXkZVDW"/></div></div></figure><p id="dc9b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们给这个新函数起了个名字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/36d8d41df49b403ccd779834a3c4a19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nAHToxFAV3w8HIlv"/></div></div></figure><p id="2307" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后，创建了<code class="fe ob oc od na b">SegueAction</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/b084f383b03de4455a0499be4d4b2151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tl-QnCdDGPIrI0IW"/></div></div></figure><p id="32be" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在我的例子中，我在最后添加了<code class="fe ob oc od na b">myData</code>参数，以将其传输到目标<code class="fe ob oc od na b">ViewController</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/483dc904dad91fab31fdc99998e798ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/0*u155Ub-TsqeAFLt9"/></div></figure><p id="31f8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不再需要准备功能。</p><h2 id="a5dd" class="ne lh it bd li oe of dn lm og oh dp lq mh oi oj ls ml ok ol lu mp om on lw oo bi translated"><strong class="ak">自定义初始值设定项</strong></h2><p id="0953" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在上面讨论的示例中创建的定制初始化器也可以以不同的方式使用。我已经提到过视图控制器之间的转换可以不使用segues来完成。</p><p id="da59" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">例如，我们可以创建一个普通的<code class="fe ob oc od na b">IBAction</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b747" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">iOS 13提供了一个接受创建块的<code class="fe ob oc od na b">instantiateViewController</code>版本，允许我们调用自定义初始化器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6c0a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">结论</strong></h1><p id="9637" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们仍将不得不在很长一段时间内处理故事板。我们在市场上都有需要维护和发展的应用程序。</p><p id="0f11" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不仅如此，许多开发人员仍然不愿意采用SwiftUI来创建新项目，因为他们认为这是一项尚未成熟的技术(真的吗？).</p><p id="50e9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">其他人将有目前正在开发的项目，这些项目在SwiftUI发布之前就开始了，可能在很长一段时间内都不会出现。</p><p id="cb35" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">因此，我们仍将不得不处理一个非常有用的工具，它将我们置于我们都熟知的问题之前，我在文章中提到了这些问题。</p><p id="29e8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当我们被迫将一个大的故事板分割成更小、更易管理的对象时，故事板引用或一种编码方法是两种舒适的解决方案。</p><p id="07e8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">此外，苹果仍然在故事板中发布新功能，这很好，证明了它意识到市场上有许多应用程序的用户界面是使用这样的工具创建的，这肯定需要几年的维护和发展。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b03e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">可传递组件的完整代码</h1><p id="7687" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">《可传递的路线》和它的故事板扩展都是由<a class="ae ky" href="https://medium.com/@ooosv" rel="noopener"> Osvaldo Pirrello </a>写的，他是<a class="ae ky" href="https://medium.com/@overapp" rel="noopener"> OverApp </a>的创始人兼首席执行官，我要感谢他。</p><p id="e80b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe ob oc od na b">Routable.swift</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1023" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe ob oc od na b">Extension+UIStoryboard.swift</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div></div>    
</body>
</html>