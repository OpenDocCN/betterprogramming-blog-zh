<html>
<head>
<title>How to Correlate Rails Requests to Database Logs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Rails请求关联到数据库日志</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/correlate-rails-requests-to-database-logs-1e998228fa43?source=collection_archive---------21-----------------------#2020-02-03">https://betterprogramming.pub/correlate-rails-requests-to-database-logs-1e998228fa43?source=collection_archive---------21-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3709" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用唯一的请求ID将应用程序日志连接到数据库日志，提高日志的质量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/345cef15d9948d376407e5175cd044d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u1mIsnJ-WEtEtJ6z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯帕·卡米尔·鲁宾</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e5f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用软件应用程序日志的用户动作的可追溯性是每个软件应用程序都应该支持的关键特性。这是一个非常重要的功能，使运行软件应用程序的工程师(如站点可靠性工程师、开发人员或基础设施工程师)能够跟踪用户操作并调查生产事故。</p><p id="6d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然对于大多数Rails应用程序来说，实现可跟踪性或审计日志特性被认为是一项简单的任务，但是一旦涉及到在相互通信的多个Rails应用程序或底层数据库应用程序之间关联日志，就可以认为是一项挑战。</p><p id="838a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将介绍一个关联和链接多个Rails应用程序日志的解决方案。这篇文章将包括以下几点:</p><ul class=""><li id="e4c0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用X-Request-Id关联Rails日志。</li><li id="365e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在多个Rails应用程序之间共享X-Request-Id。</li><li id="20bb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">与数据库应用程序共享X-Request-Id。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0eb6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">关联属于同一请求的Rails日志</h1><p id="ca44" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">默认情况下，Rails应用程序日志看起来像下面的代码片段。这仅属于一个应用请求，即<code class="fe nn no np nq b">GET /users</code>请求:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/e4755fdf524059bba79e1de8f33596b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJNWUNVbyoXL65qKF5ZQcw.png"/></div></div></figure><p id="f19c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然日志看起来是有序的，并且属于请求的所有行都是相互关联的，但当应用程序运行在具有多线程/多进程web服务器(如<code class="fe nn no np nq b">puma</code>或<code class="fe nn no np nq b">unicorn</code>)的生产环境中时，情况并非如此。在这种情况下，多个进程/线程将写入日志，并且不能保证每个请求日志看起来都是绑定在一起的。实际上，来自不同请求的日志会相互重叠，生产系统上的日志可能看起来像下面的代码片段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/7ce07ab30e2c806601215e36dd3112e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWpYbPwc0X2r_sGOZ3dcRw.png"/></div></div></figure><p id="f2c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的片段来看，很难(如果不是不可能的话)区分哪个日志行属于哪个请求。幸运的是，可以使用<code class="fe nn no np nq b"><a class="ae ky" href="https://api.rubyonrails.org/classes/ActionDispatch/RequestId.html" rel="noopener ugc nofollow" target="_blank">ActionDispatch:RequestId</a></code>中间件轻松地配置Rails来关联属于相同请求的日志行。这个中间件生成一个随机的唯一请求id，或者使用请求头中传递的请求id。我们可以使用这个id来标记Rails日志，以关联Rails日志行。这项任务可以通过对Rails应用程序的源代码执行以下更改来完成:</p><ul class=""><li id="efac" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将下面一行添加到<code class="fe nn no np nq b">config/environments/${env}.rb</code>以将更改应用到特定环境(如<code class="fe nn no np nq b">production</code>)或添加到<code class="fe nn no np nq b">config/application.rb</code>以将更改应用到所有支持的环境:</li></ul><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="c477" class="nx mr it nq b gy ny nz l oa ob">config.log_tags = [ :uuid ]</span></pre><p id="16b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实现了上面的更改之后，Rails日志将看起来像下面的日志片段。属于同一请求的所有行都将由相同的请求id值标记。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/cfec70f34ae0a223c0a0bb197b54993d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69_z_SaNUOmr8KIjYV93bw.png"/></div></div></figure><p id="88cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的改变，但是如果我们想要关联属于不同应用程序的日志呢？我们可以使用相同的请求id吗？</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8e95" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">在两个彼此同步通信的Rails应用程序之间关联日志</h1><p id="3dfe" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">不幸的是，没有实现这个任务的内置特性。不过，在<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/fidor/request_headers_middleware" rel="noopener ugc nofollow" target="_blank">RequestHeaderMiddleware</a></code>的帮助下，通过对应用的源代码进行一些修改，这个任务是可以实现的。</p><p id="ff49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/fidor/request_headers_middleware" rel="noopener ugc nofollow" target="_blank">RequestHeaderMiddleware</a></code>是一个请求存储库，它存储所有列入白名单的消息头(默认情况下只有X-Request-Id ),并使其在所有阶段都可用于Rails请求。因为该存储对Rails源代码是全局可用的，并且它包含request-id，所以可以使用该存储从存储中检索request-id，并将其作为请求头传递给所有传出的请求。目的地服务中的<code class="fe nn no np nq b"><a class="ae ky" href="https://api.rubyonrails.org/classes/ActionDispatch/RequestId.html" rel="noopener ugc nofollow" target="_blank">ActionDispatch:RequestId</a></code>将使用传递的头值，并且不会为该请求生成新的请求id。</p><p id="d0ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/fidor/request_headers_middleware" rel="noopener ugc nofollow" target="_blank">RequestHeaderMiddleware</a></code>提供使用<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/rails/activeresource" rel="noopener ugc nofollow" target="_blank">ActiveResource</a></code>、<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/lostisland/faraday" rel="noopener ugc nofollow" target="_blank">Faraday</a></code>和<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/JsonApiClient/json_api_client" rel="noopener ugc nofollow" target="_blank">JsonApiClient</a></code>将请求id传递给其他服务的指令。然而，中间件可以与任何执行HTTP请求的gem或库集成/使用，并提供添加HTTP请求头的方法。下面是利用中间件所需的更改:</p><ul class=""><li id="8558" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/rails/activeresource" rel="noopener ugc nofollow" target="_blank">ActiveResource</a></code>:下面的类可以用作应用程序中实现的所有<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/rails/activeresource" rel="noopener ugc nofollow" target="_blank">ActiveResource</a></code>类的基类。因此，报头转发将在没有任何进一步操作的情况下完成。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><ul class=""><li id="2c65" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/lostisland/faraday" rel="noopener ugc nofollow" target="_blank">Faraday</a></code>:以同样的方式，我们可以创建一个全局的singleton faraday对象，它为每个传出的请求传递来自<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/fidor/request_headers_middleware" rel="noopener ugc nofollow" target="_blank">RequestHeaderMiddleware</a></code>的消息头。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><ul class=""><li id="0f5e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/JsonApiClient/json_api_client" rel="noopener ugc nofollow" target="_blank">JsonApiClient</a></code>:根据中间件的文档，传递从<code class="fe nn no np nq b">JsonApiClient</code>扩展的类的头可以使用下面的语法。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a9b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是找到将Rails日志与数据库日志关联起来的方法。如果我们也可以将请求id传递给数据库日志，那就太好了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c709" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">将数据库日志与Rails应用程序日志相关联</h1><p id="a1be" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">由于诸如<code class="fe nn no np nq b">MySQL</code>、<code class="fe nn no np nq b">MongoDB</code>和<code class="fe nn no np nq b">SqlServer</code>之类的数据库应用程序不是Rails应用程序，并且不利用<code class="fe nn no np nq b"><a class="ae ky" href="https://api.rubyonrails.org/classes/ActionDispatch/RequestId.html" rel="noopener ugc nofollow" target="_blank">ActionDispatch:RequestId</a></code>(实际上，它们不接受HTTP请求)，所以不可能只将头转发给这些服务。</p><p id="c808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，大多数数据库应用程序记录服务器执行的SQL语句，包括注释(在一些数据库应用程序中，默认情况下禁用此功能)。例如，数据库<code class="fe nn no np nq b">MySQL</code>的日志消息可能如下所示:</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="d0c2" class="nx mr it nq b gy ny nz l oa ob">2019-12-19T20:54:50.325378Z   2 Query SELECT `users`.* FROM `users`<br/>2019-12-19T20:54:50.548397Z   2 Query SELECT `users`.* FROM `users`<br/>2019-12-19T20:54:50.842785Z   2 Query SELECT `users`.* FROM `users`</span></pre><p id="46c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，可以配置Rails应用程序在将SQL查询发送到数据库服务器之前附加注释。可以在下面显示的数据库服务器日志中看到附加的注释:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/5ef2ea43c15e6696d6a593b243dff81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wC0QXe7Ps4Q_OqO27zbKag.png"/></div></div></figure><p id="a6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述变化可以通过将<a class="ae ky" href="https://github.com/basecamp/marginalia" rel="noopener ugc nofollow" target="_blank">旁注</a> gem与Rails应用程序集成来实现。旁注将负责添加这些评论。作为这种集成的结果，我们将能够将<code class="fe nn no np nq b">SQL</code>查询关联到Rails应用程序控制器和负责<code class="fe nn no np nq b">SQL</code>查询的动作。</p><p id="f5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旁注gem还允许开发者定制和扩展评论属性。gem提供了一些内置属性，比如line属性可以返回生成<code class="fe nn no np nq b">SQL</code>查询的代码行。</p><p id="faab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里可以做的另一步是将request-id包含在由旁注gem生成的<code class="fe nn no np nq b">SQL</code>注释中。这个任务可以通过利用<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/fidor/request_headers_middleware" rel="noopener ugc nofollow" target="_blank">RequestHeaderMiddleware</a></code>来扩展旁注来实现。将下面的初始化器添加到Rails应用程序将负责将request-id属性添加到包含在<code class="fe nn no np nq b">SQL</code>注释中的属性列表中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的配置，MySQL访问日志将在注释中包含request-id，看起来像下面的代码片段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b7fa6a10e680b39513feeecc70cac0f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOH9HjPsfBTdkiQzTZHNXw.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="13c9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">结论</strong></h1><p id="de61" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在微服务架构中关联日志是一个至关重要的热门话题。它可以让工程师从客户端到数据库端跟踪生产环境中的问题。对于Rails应用程序来说，这个任务可以通过使用一些内置特性以及一些第三方的gem来完成，比如<a class="ae ky" href="https://github.com/basecamp/marginalia" rel="noopener ugc nofollow" target="_blank">旁注</a>。</p></div></div>    
</body>
</html>