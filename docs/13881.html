<html>
<head>
<title>Validating Complex Requests With NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NestJS验证复杂的请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/validating-complex-requests-with-nestjs-a-practical-example-b55c287f7c99?source=collection_archive---------0-----------------------#2022-10-08">https://betterprogramming.pub/validating-complex-requests-with-nestjs-a-practical-example-b55c287f7c99?source=collection_archive---------0-----------------------#2022-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cfaa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实际例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/deb44b72747219472f1c723ea310e62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*zKHU8ZH_EBvKbQRtIsKXgA.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">由<a class="ae kr" href="https://unsplash.com/@juanjodev02?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">胡安乔·哈拉米略</a>在<a class="ae kr" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="6c6f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在本文中，我想深入探讨用NestJS对传入请求执行复杂验证的方法。</p><p id="1ab1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">NestJS提供了一个很好的方法，通过一些好的默认值将请求验证集成到您的应用程序中。它的建议是使用一个强大的、有很好的文档和例子的<code class="fe lo lp lq lr b">class-validator</code>包。</p><h1 id="3393" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么请求验证很重要？</h1><p id="f438" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">验证是在线服务安全性和数据完整性的重要步骤。</p><p id="56cb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它确保您只接收您的服务期望的格式的数据。丢弃任何你不期望的额外数据的可能性。</p><p id="6987" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它提供了一层针对恶意行为者的保护，记住你不应该相信任何用户输入。尽可能采用零信任策略。</p><p id="6142" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">不要在数据库中存储无效数据，保护管道中的服务免受无效数据输入的影响。</p><h1 id="2c55" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是“类验证器”包？</h1><div class="mp mq gp gr mr ms"><a href="https://github.com/typestack/class-validator" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">GitHub—type stack/class-validator:基于Decorator的类属性验证。</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">允许使用装饰器和基于非装饰器的验证。在内部使用validator.js执行验证…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kl ms"/></div></div></a></div><p id="c781" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它是一组decorators，您可以使用它和您的JavaScript类属性来添加验证。有像<code class="fe lo lp lq lr b">@IsString()</code>这样的基本验证规则——验证的字段应该是一个字符串，并且能够编写完全自定义的验证类和装饰器。</p><p id="6102" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个包允许的另一件好事是从父应用程序使用依赖注入容器。这对于验证外部资源非常有用，例如一个<code class="fe lo lp lq lr b">User</code>数据库。有一个小技巧可以让它工作，并节省你搜索的时间。检查这个<code class="fe lo lp lq lr b">main.ts</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">一个使用NestJS DI容器的类验证器的例子。</p></figure><p id="4e53" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里最重要的一行是:</p><blockquote class="nj nk nl"><p id="15aa" class="ks kt nm ku b kv kw jr kx ky kz ju la nn lc ld le no lg lh li np lk ll lm ln ij bi translated">use container(app . select(app module)，{ fallbackOnErrors:true })；</p></blockquote><p id="b3df" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在撰写本文时，NestJS的官方文档中没有提到这一点。</p><h1 id="6344" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是复杂请求？</h1><p id="a2a4" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">我将它定义为至少有一个数组或一个对象的东西，这将依次包括嵌套的对象和/或数组。另一个常见的用例是根据外部资源(数据库、缓存、S3等)检查有效性。).</p><p id="9b14" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">对于我的例子，我将使用一个假想的SaaS多租户电子商务API，它将允许我:</p><ul class=""><li id="8190" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated">全局注册用户</li><li id="7ad3" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">为特定商店下订单</li></ul><h1 id="39e3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">验证用户创建请求</h1><p id="a2b5" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">要注册用户，我们需要下面的类中列出的字段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">我们将在全球范围内注册用户，没有任何特定商店的链接。</p></figure><p id="1411" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们的约束条件如下:</p><ul class=""><li id="d5f9" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">name </code> —必需，是一个字符串，长度至少为三个字符。</li><li id="9807" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">email</code> —必填，应为有效的电子邮件字符串，不应已在我们的数据库中注册。</li><li id="b86b" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">password</code> —必需，是一个字符串，长度至少为8个字符。</li></ul><p id="0c0c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是我的<code class="fe lo lp lq lr b">UserCreateDto</code>加上<code class="fe lo lp lq lr b">class-validator</code>装修工后的样子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="740d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们首先回顾一下这里使用的<code class="fe lo lp lq lr b">class-validator</code>包中的标准验证规则:</p><ul class=""><li id="39c4" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">@IsString()</code>—值应该是字符串</li><li id="4ae1" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">@MinLength(N)</code>—值的最小长度应为N</li><li id="f3b4" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">@IsEmail()</code> —值应该是有效的电子邮件(仅语法检查)</li></ul><p id="6a3c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在有趣的部分是<code class="fe lo lp lq lr b">@EmailNotRegistered()</code>验证。我创建这个是为了拒绝注册用户，如果他们的电子邮件已经存在于我们的应用程序中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">通过电子邮件对照第三方来源检查用户存在的自定义验证。</p></figure><p id="452f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是我的定制验证装饰器，创建它的过程在<a class="ae kr" href="https://github.com/typestack/class-validator#custom-validation-decorators" rel="noopener ugc nofollow" target="_blank">文档</a>中描述。然而，大部分代码是样板文件，让我们检查最有趣的行。</p><p id="a1e1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">第11行—注入一个定制的提供者<code class="fe lo lp lq lr b">private readonly userRepository: UserRepository</code>。</p><p id="59ce" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">第14–15行—通过在<code class="fe lo lp lq lr b">UserRepository</code>中搜索电子邮件来提供验证功能。</p><p id="abc3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">My <code class="fe lo lp lq lr b">UserRepository</code>只是一个内存存储，模拟某种形式的异步网络I/O。这是为了复制真实的DB请求/响应生命周期。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">复制异步网络I/O的内存存储。</p></figure><p id="6916" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">用户注册API端点如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7b4d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这就是让NestJS验证传入请求所要做的全部工作:</p><ul class=""><li id="a250" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated">在您的路由签名中键入提示DTO类</li><li id="743d" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">向DTO类中添加验证装饰器</li><li id="913e" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">在<code class="fe lo lp lq lr b">main.ts</code>内打开验证使用(如上例所示)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi oe"><img src="../Images/383bc0598a4ca640216147300aa781f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PDqKIetDOLdSljc3XdN84g.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">用户注册端点验证正在进行。</p></figure><p id="0316" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">干得好。让我们继续订单请求和验证！</p><h1 id="36b0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">验证创建订单请求</h1><p id="ac89" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">好了，我们从一些相当简单的事情开始，现在让我们试着验证一个订单请求。</p><p id="7ac8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们对<code class="fe lo lp lq lr b">OrderCreateDto</code>的要求是:</p><ul class=""><li id="878d" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated">应该有共同的订单属性，如商店ID(我们是SaaS多租户应用程序)，以及创建日期。</li><li id="1a3c" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">应该有客户信息(客户电子邮件)。</li><li id="e70a" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">应该有一个订单产品列表(一个数组)，有一个通用的结构——产品ID和数量。</li><li id="d0ee" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">应该有一个订单发货描述，这是一个可变对象:或者是<code class="fe lo lp lq lr b">Delivery</code>或者是<code class="fe lo lp lq lr b">Pickup</code>类型，带有各种必填字段。</li><li id="2ad6" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">最后，它应该有一个联系人列表，每个联系人的一些细节。</li></ul><p id="7465" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">满足这些要求的第一个未经验证的DTO可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">预期的创建订单请求对象。</p></figure><p id="5883" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们检查这个请求的每个块，描述它，并添加验证。</p><h1 id="75ba" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">OrderCreateDto</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">OrderCreateDto字段。</p></figure><p id="6910" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">以下是限制条件:</p><ul class=""><li id="c9b4" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">shop_id</code> —应为UUID格式，存在于<code class="fe lo lp lq lr b">ShopRepository</code>中。</li><li id="410e" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">created_at</code> —应为日期对象或日期可转换对象。</li></ul><h2 id="5ee2" class="oj lt iq bd lu ok ol dn ly om on dp mc lb oo op me lf oq or mg lj os ot mi ou bi translated">解决办法</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">验证订单特定字段的示例。</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">根据外部资源验证商店ID。</p></figure><p id="7de9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@IsUUID()</code> —是一个用于检查字符串是否为有效UUID的装饰器。</p><p id="2ebc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@Validate(ShopIdExistsRule)</code> —使用自定义规则验证字段(类似于编写您的装饰器，但更简单一点)。</p><p id="be63" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@Type(() =&gt; Date) &amp; @IsDate()</code> —将尝试将提供的输入转换为<code class="fe lo lp lq lr b">Date</code>，并验证它是一个<code class="fe lo lp lq lr b">Date</code>对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi oe"><img src="../Images/3fab884e5b6db9a2eb04f01933296bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*y200WKW0X9M0muVIWBM_gQ.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">订单创建验证正在进行。</p></figure><h1 id="5276" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">订单客户</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">OrderCustomerDto字段。</p></figure><p id="d5a6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">以下是限制条件:</p><ul class=""><li id="8fe5" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">email</code> —应该存在于用户存储库中，并且应该是有效的电子邮件字符串。</li><li id="1929" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">验证父级<code class="fe lo lp lq lr b">OrderCreateDto</code>中<code class="fe lo lp lq lr b">OrderCustomerDto</code>的嵌套对象。</li></ul><h2 id="1be0" class="oj lt iq bd lu ok ol dn ly om on dp mc lb oo op me lf oq or mg lj os ot mi ou bi translated">解决办法</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><code class="fe lo lp lq lr b">OrderCreateDto </code>和<code class="fe lo lp lq lr b">OrderCustomerDto </code>带有验证装饰器的对象。</p></figure><p id="fa3a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里的新东西:</p><p id="621b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@CustomerExists()</code> —这与我之前使用的<code class="fe lo lp lq lr b">@EmailNotRegistered()</code>规则相反。逻辑类似，我们采取提前注入<code class="fe lo lp lq lr b">UserRepository</code>。</p><p id="5edd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@Type(() =&gt; OrderCustomerDto)</code> —这是一个实用程序行，它将嵌套的对象转换成一个类，因此可以通过下面的<code class="fe lo lp lq lr b">@ValidateNested()</code>进行验证。如果不进行转换，验证将不会运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi oe"><img src="../Images/03fbb70e3ae9f520dad7e261d91c001e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*43ZIQs_TLcJiz0sbDC8uCg.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">客户数据验证正在进行。</p></figure><p id="2296" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果在启动NestJS时出现错误:</p><blockquote class="nj nk nl"><p id="6368" class="ks kt nm ku b kv kw jr kx ky kz ju la nn lc ld le no lg lh li np lk ll lm ln ij bi translated">ReferenceError:无法在初始化之前访问“OrderCustomerDto”</p></blockquote><p id="31da" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您需要将<code class="fe lo lp lq lr b">OrderCustomerDto</code>声明移动到<code class="fe lo lp lq lr b">OrderCreateDto</code>之前，如我上面的代码示例所示。</p><h1 id="4c29" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">OrderProductDto</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">OrderProductDto字段。</p></figure><p id="b67c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">以下是限制条件:</p><ul class=""><li id="1039" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">products</code> —应为数组，不应为空。</li><li id="d772" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">id</code> —应存在于<code class="fe lo lp lq lr b">ProductRepository</code>中，应为整数值。</li><li id="9ad3" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">quantity</code> —应足够该产品可用，应为整数。</li></ul><h2 id="7cfc" class="oj lt iq bd lu ok ol dn ly om on dp mc lb oo op me lf oq or mg lj os ot mi ou bi translated">解决办法</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">带有验证装饰器的OrderProductDto和<code class="fe lo lp lq lr b">OrderCustomerDto </code>对象。</p></figure><p id="bc7e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里有一些新的东西:</p><p id="1800" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@IsInt()</code> —检查值是否为整数，100.5验证失败。</p><p id="9968" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@ArrayNotEmpty()</code> —验证产品数组不为空。</p><p id="245a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@ValidateNested({ each: true })</code> —触发数组嵌套验证，因此我们可以有效地验证1到N个产品。</p><p id="cd2d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">ProductIdExists</code>和<code class="fe lo lp lq lr b">ProductIsAvailable</code> —是检查产品是否存在以及是否有足够的数量下订单的自定义规则。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi oe"><img src="../Images/03ce467f9c33db8b805c20c713c0e36a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oy7JykFVdq6F1zFtdlc7AQ.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">产品数据验证正在进行。</p></figure><h1 id="c376" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">订单交付</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">OrderShipmentDto字段。</p></figure><p id="bac5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">以下是限制条件:</p><ul class=""><li id="10e3" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">type</code> —应该是enum ( <code class="fe lo lp lq lr b">Delivery</code> | <code class="fe lo lp lq lr b">Pickup</code>)的一部分，应该被定义。</li><li id="5ee6" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">如果选择了<code class="fe lo lp lq lr b">Delivery</code>类型，则<code class="fe lo lp lq lr b">city</code>和<code class="fe lo lp lq lr b">address</code>字段为必填字符串，不能为空。</li><li id="77b7" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">如果选择了<code class="fe lo lp lq lr b">Pickup</code>类型，则<code class="fe lo lp lq lr b">point_id</code>字段为必填字段，应为整数，不能为空。</li></ul><h2 id="7294" class="oj lt iq bd lu ok ol dn ly om on dp mc lb oo op me lf oq or mg lj os ot mi ou bi translated">解决办法</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">带验证装饰器的装运和<code class="fe lo lp lq lr b">OrderCustomerDto </code>对象。</p></figure><p id="23ba" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里有一些新的东西:</p><p id="ee6d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@Equals(DeliveryTypes.DELIVERY)</code>和<code class="fe lo lp lq lr b">@Equals(DeliveryTypes.PICKUP)</code> —将对提供的值进行严格的(===)检查。</p><p id="d0a9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后，基于交付类型，我们验证嵌套对象。为此，我们需要一个更高级的<code class="fe lo lp lq lr b">@Type()</code>用例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">class-transformer根据请求中的字段进行键入的助手。</p></figure><p id="9f7e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">由于<code class="fe lo lp lq lr b">shipment</code>对象是变量类型，我们包括变量类型cast用于验证，现在<code class="fe lo lp lq lr b">shipment</code>看起来像这样:<code class="fe lo lp lq lr b">shipment: DeliveryShipmentDto | PickupShipmentDto;</code></p><p id="3d69" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这允许我们的验证系统删除特定交付对象不需要的字段，例如，您请求<code class="fe lo lp lq lr b">Pickup</code>装运并提供<code class="fe lo lp lq lr b">city</code>——这将被<code class="fe lo lp lq lr b">class-transformer</code>包删除。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi oe"><img src="../Images/0b9d0cd541429eb58a5e6c966b38cb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZO66JMXwwi0WeRnWI9g4-Q.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">发货数据验证正在进行。</p></figure><h1 id="8dcf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">OrderContactDto</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">OrderContactDto字段。</p></figure><p id="2a74" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">以下是限制条件:</p><ul class=""><li id="7971" class="nq nr iq ku b kv kw ky kz lb ns lf nt lj nu ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">name</code> —应该是一个字符串，应该被定义。</li><li id="079d" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">phone</code> —应该是有效的手机号码。</li><li id="7ef4" class="nq nr iq ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated"><code class="fe lo lp lq lr b">email</code> —可选，如果已定义，则应为有效的电子邮件语法。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">带有验证装饰器的OrderContactDto和<code class="fe lo lp lq lr b">OrderCustomerDto </code>对象。</p></figure><p id="e621" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">新的验证在这里:</p><p id="f724" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@IsMobilePhone(‘en-US’)</code> —将检查电话字符串是否具有有效的语法、号码数量等。</p><p id="e280" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">@IsOptional()</code> —仅验证提供的电子邮件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi ov"><img src="../Images/ca0af9714164d02b4689482e014ff14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_oz2L7Ju5sor3q4v4nVnrQ.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">联系人验证正在进行。</p></figure><h1 id="822d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最终解决方案</h1><p id="750d" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">好吧，这是一条漫长的道路。现在，让我们来看一个包含所有验证装饰器的完整请求对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">NestJS DTO类验证的最终版本。</p></figure><h1 id="a92a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">额外收获:更常见的验证用例</h1><p id="0ec6" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">很难举出一个例子来涵盖请求验证的所有特性。因此，我将在这里列出我实践中的一些有趣的用例:</p><h2 id="4f90" class="oj lt iq bd lu ok ol dn ly om on dp mc lb oo op me lf oq or mg lj os ot mi ou bi translated">付款确认</h2><p id="ad81" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">用例:来自第三方卡处理器(PayPal、Stripe)的webhook调用。</p><p id="ae1a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您通常在配置中存储了某种形式的<code class="fe lo lp lq lr b">secret</code>签名密钥，并且需要验证请求的签名。</p><p id="7b4b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里有一个使用注入NestJS配置服务的验证器的例子。</p><h2 id="85da" class="oj lt iq bd lu ok ol dn ly om on dp mc lb oo op me lf oq or mg lj os ot mi ou bi translated">请求</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8d2d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们将组合<code class="fe lo lp lq lr b">order id + amount + secret</code>并将其与接收到的签名进行比较。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">这个验证规则使用NestJS <code class="fe lo lp lq lr b">ConfigService</code>来获取秘密值。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi ow"><img src="../Images/e66cad465346cf3e2d4f35e60d2dd7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8abG3F4Iq00-NWcZjPMtAA.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">签名验证正在进行。</p></figure><h2 id="b54d" class="oj lt iq bd lu ok ol dn ly om on dp mc lb oo op me lf oq or mg lj os ot mi ou bi translated">条件属性验证</h2><p id="43c2" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">用例:仅当另一个属性设置为特定值时才验证属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8903" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">任务:只有当<code class="fe lo lp lq lr b">subscribe</code>为<code class="fe lo lp lq lr b">true</code>时，才验证<code class="fe lo lp lq lr b">email</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">根据subscribe字段的值，带有电子邮件字段的验证请求示例。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi ow"><img src="../Images/7dd8b91d078f0f44ba46bbc26d87b064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kykbTnIEFrBYdeA-vmbDWQ.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">订阅验证正在进行。</p></figure><h2 id="40ea" class="oj lt iq bd lu ok ol dn ly om on dp mc lb oo op me lf oq or mg lj os ot mi ou bi translated">没有数据库查询的重复约束验证</h2><p id="3509" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">用例:您有一个唯一的DB约束(field1 + field2)，但是您想在到达DB级别之前验证它(并获得存储异常)。您的请求接受一次存储多个实体，并且可以包含重复的实体。</p><p id="8602" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里有一个DTO的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8015" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过验证:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">一个记录数组的唯一性验证器的例子。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi ow"><img src="../Images/dea87adf063b3b32671c34c11df0be8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BvpIikOsdBciiIgTPJSrSg.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">操作中没有重复的用户验证。</p></figure><h2 id="bec7" class="oj lt iq bd lu ok ol dn ly om on dp mc lb oo op me lf oq or mg lj os ot mi ou bi translated">与请求相关的日期范围约束</h2><p id="4b2c" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">用例:带有<code class="fe lo lp lq lr b">start</code>和<code class="fe lo lp lq lr b">end</code>日期的过滤器。您希望<code class="fe lo lp lq lr b">end</code>日期晚于<code class="fe lo lp lq lr b">start</code>日期。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5ca2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">带有验证约束:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">应用开始/结束约束的日期验证。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi ow"><img src="../Images/3469c109311f5a8f29d5b4fe05801b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2LCEU-G8S0-xXwSWNDsenw.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">有效的日期范围验证。</p></figure><h1 id="75c4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="b011" class="pw-post-body-paragraph ks kt iq ku b kv mk jr kx ky ml ju la lb mm ld le lf mn lh li lj mo ll lm ln ij bi translated">NestJS和<code class="fe lo lp lq lr b">class-validator</code>在请求验证方面表现良好。它可以覆盖从最简单到复杂的验证场景的所有内容。</p><p id="60c7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">另一个好处是，在验证失败的情况下，可以获得标准的错误响应结构，您不必自己编写代码——所有这些都由NestJS处理。</p><p id="c721" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">带有测试代码的存储库如下:<a class="ae kr" href="https://github.com/dkhorev/validating-complex-requests-with-nestjs" rel="noopener ugc nofollow" target="_blank">https://github . com/dkhorev/validating-complex-requests-with-nest js</a></p></div><div class="ab cl ox oy hu oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="ij ik il im in"><p id="e53b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我希望这能有所帮助。好运，快乐工程！</p></div></div>    
</body>
</html>