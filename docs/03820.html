<html>
<head>
<title>5 Really Good Reasons to Use Redux Over Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在上下文中使用Redux的5个非常好的理由</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-really-good-reasons-to-use-redux-over-context-ad6cd93de30b?source=collection_archive---------9-----------------------#2020-03-06">https://betterprogramming.pub/5-really-good-reasons-to-use-redux-over-context-ad6cd93de30b?source=collection_archive---------9-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de61" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">反应上下文不是全局状态管理的好解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2756c69cd7b462d4a6a1e0638363e9d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D2DhhUiXrcvAFNwt.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=828826" rel="noopener ugc nofollow" target="_blank">免费提供的图像-来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=828826" rel="noopener ugc nofollow" target="_blank">像素</a>的照片</a></p></figure><p id="8117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">contact Context</a>于前段时间推出，但在<a class="ae ky" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">contact hook</a>推出React 16.8后才获得牵引力。虽然Context确实解决了它原本要解决的问题，但它不是全局状态管理的通用解决方案，原因如下。</p><h1 id="0751" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">很难调试</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/c920beceb82c0b8da793080dc2188ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*XBejTAKI5rttcduT"/></div></figure><p id="e570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的截图中，你可以看到<a class="ae ky" href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd" rel="noopener ugc nofollow" target="_blank"> Redux Devtools </a>扩展。它允许您详细检查每个动作，提供状态的不同和完整视图，并且可以倒带动作来检查哪里出错了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/0e5fd467f7a792438b9a377eefa7718f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Su1wYJBztGHP_Azq"/></div></div></figure><p id="75dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Redux Logger，在Redux DevTools不够或不适用于您的环境的情况下，这是另一个调试工具。它将记录每个调度的操作，并向您显示应用该操作之前和之后的状态。不过，Redux记录器不能倒回。但是它仍然可以比任何其他上下文工具做得更多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/324c315be5e24df8aa2b5082bbae8adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*iTA_ca4Y3s2uoDN0"/></div></figure><p id="b7db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<a class="ae ky" href="https://dev.to/deeppatel234/debug-reactjs-context-api-with-react-context-devtool-3plb" rel="noopener ugc nofollow" target="_blank">反应上下文开发工具</a>。它允许您查看上下文状态，仅此而已。也有一个不同的视图，但是不清楚在没有调度操作的情况下如何工作。我会补充说，这是一个在早期阶段的项目，只有两个贡献者在工作。所以，虽然这个工具给人留下了深刻的印象，我也很感谢它的开发人员，但它还没有到非常有用的阶段。</p><p id="3ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用<a class="ae ky" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank">reactor DevTools</a>，但是它们并不能在所有环境中工作，并且仍然缺乏Redux DevTools的大部分功能。还有一种方法<a class="ae ky" href="https://medium.com/@erwan.datin/react-context-api-how-to-connect-to-redux-devtools-625a2772b949" rel="noopener">将上下文与Redux开发工具</a>联系起来，但是考虑到这个解决方案的复杂性，我将只使用Redux。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ea65" class="lv lw it bd lx ly mw ma mb mc mx me mf jz my ka mh kc mz kd mj kf na kg ml mm bi translated">它不能被扩展</h1><p id="95a1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Redux最强大的功能之一是增强器。最常用的增强器之一是<a class="ae ky" href="https://redux.js.org/advanced/middleware/" rel="noopener ugc nofollow" target="_blank">中间件</a>，它允许您覆盖<code class="fe ng nh ni nj b">dispatch</code>函数。您可能在您的项目中使用过这样的中间件，如<a class="ae ky" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>、<a class="ae ky" href="https://github.com/LogRocket/redux-logger" rel="noopener ugc nofollow" target="_blank"> redux-logger </a>、<a class="ae ky" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>等。您还可以编写定制的中间件来直接在商店中嵌入逻辑，从而减少样板文件和重复。</p><div class="nk nl gp gr nm nn"><a href="https://medium.com/javascript-in-plain-english/improve-your-redux-skills-by-writing-custom-middleware-32a70b9dfb25" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">通过编写定制中间件来提高您的Redux技能</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在本文中，我将教您编写定制的中间件来扩展Redux的功能，并深入了解</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div><p id="fae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React上下文不提供这样的接口。您可以选择将这个逻辑嵌入到其他地方(组件/助手),或者使用<code class="fe ng nh ni nj b">useReducer</code>钩子并手动包装<code class="fe ng nh ni nj b">dispatch</code>函数。但即使这样，它也无法实现Redux enhancers所能实现的一半。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="3477" class="lv lw it bd lx ly mw ma mb mc mx me mf jz my ka mh kc mz kd mj kf na kg ml mm bi translated">它没有把逻辑和表现分开</h1><p id="4606" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这是前一个论点的延伸。因为没有办法将自定义行为嵌入到上下文中，所以必须在组件中实现。现在，您开始在相同的实体中混合逻辑和表示。当然，你可以将你的组件分成<em class="oc">容器</em>组件<em class="oc">和</em>哑组件<em class="oc">组件</em>，但是这真的对任何人有用吗？</p><p id="ceec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Redux和中间件，如Thunk或Saga，您可以在动作创建器和/或定制中间件中描述您的业务逻辑。这让您可以只使用<em class="oc">哑</em>组件，并且在业务逻辑和表示之间有一个具体的分离。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="590b" class="lv lw it bd lx ly mw ma mb mc mx me mf jz my ka mh kc mz kd mj kf na kg ml mm bi translated">它很慢</h1><p id="1873" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">是的，就是它。反应上下文<a class="ae ky" href="https://github.com/reduxjs/react-redux/issues/1177" rel="noopener ugc nofollow" target="_blank">是</a> <a class="ae ky" href="https://blog.theodo.com/2019/07/how-i-ruined-my-application-performances-by-using-react-context-instead-of-redux/" rel="noopener ugc nofollow" target="_blank">慢</a>，<a class="ae ky" href="https://medium.com/@leonardobrunolima/react-tips-context-api-performance-considerations-d964f3ad3087" rel="noopener">期</a>。这是因为没有像Redux中那样的选择器机制。这意味着当<em class="oc">上下文中的任何</em>值改变时，使用该上下文的每个组件都将重新呈现，不管它是否实际使用它。使用<a class="ae ky" href="https://everyday.codes/javascript/react-usememo-and-when-you-should-use-it/" rel="noopener ugc nofollow" target="_blank"> React.memo </a>可以部分缓解。</p><p id="70ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而Redux则没有这个问题。无论是使用HOS还是Hooks，您都可以准确地定义您需要什么数据，而且您组件只有在数据发生变化时才会重新呈现。这意味着你不需要不必要的<code class="fe ng nh ni nj b">React.memo</code>电话。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="b4df" class="lv lw it bd lx ly mw ma mb mc mx me mf jz my ka mh kc mz kd mj kf na kg ml mm bi translated">它不是更短或更容易</h1><p id="ba1c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">你经常听到的关于上下文的一个论点是，它比Redux更短或更容易。好吧，让我们检查一下。</p><p id="b3bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我给你写出了四个例子:使用Context，使用Context + useReducer，Redux，Redux + Redux Toolkit:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="69b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件和状态逻辑应该在不同的文件中，但是为了简单起见，我省略了这一点。你可以看到带有Redux的例子并不比上下文中的例子长。此外，您在应用程序中只需要一个Redux状态(并使用片来创建子状态)，但是您可能需要多个上下文，这导致了双倍的样板文件。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="3568" class="lv lw it bd lx ly mw ma mb mc mx me mf jz my ka mh kc mz kd mj kf na kg ml mm bi translated">结束语</h1><p id="e558" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当然，React上下文总是有用例的。它非常适合存储主题选项、本地设置和其他不经常改变的属性。但是如果你从上下文开始，并且你的应用程序变得越来越复杂，由于可读性和性能问题，你将不得不花时间将上下文重写为Redux。</p><p id="9abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，我希望你喜欢这篇文章。请在评论中告诉我你对上下文和Redux二分法的看法！</p><h2 id="c1dd" class="of lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">资源</h2><ul class=""><li id="c8cf" class="or os it lb b lc nb lf nc li ot lm ou lq ov lu ow ox oy oz bi translated"><a class="ae ky" href="https://github.com/reduxjs/react-redux/issues/1177" rel="noopener ugc nofollow" target="_blank">Redux Github中的原始问题解释了为什么Redux不在幕后使用上下文</a></li><li id="aa6b" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文文档</a></li></ul></div></div>    
</body>
</html>