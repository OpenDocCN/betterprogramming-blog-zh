# 为什么我更喜欢写 Python 而不是 Java

> 原文：<https://betterprogramming.pub/why-im-more-comfortable-writing-python-than-java-cfbcc81d175e>

## 两种编程语言之间强大但对比鲜明的差异的 4 个编码示例

![](img/46f4a70fc4312a77e6ad4ce2cf17fd9f.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上由[迈克·提尼翁](https://unsplash.com/@m15ky?utm_source=medium&utm_medium=referral)拍摄的照片。

夏天的海边。小时候和父母在一起和年轻时和朋友在一起有什么不同？好吧，可能程序员不爱海边。或者他们只是不喜欢沙子。但作为年轻人，我们终于尝到了来自父母和外部规则的自由(或多或少)。

快进到开发者生活。Java 的设计规则限制了程序员的自由，强加了选择和结构。Python 有完全不同的哲学，将潜在破坏设计的选择和责任留给了程序员。

以下是作为 Python 开发人员，使用 Java 时可能遇到的一些最烦人的限制。

# 私有、公共和受保护

Java 有一组限定符来设计一个变量、一个方法甚至一个类是否可以被访问。限制对方法和变量的访问是对用户的束缚。

我不认为禁止我访问某个特定的领域或方法会阻止对某个软件的滥用。我相信*知道*就足够了。一旦我意识到这样一个软件不应该被篡改，我可能会决定无论如何都要做。如果我的软件停止工作，那么我是唯一的责任人。如果我不想让一个类的给定字段被继承，不知何故我会请求一个继承的例外——我可以不要它。

Python 有*约定*来标记私有访问字段、方法或类。你知道你正在以一种*意想不到的*方式访问它们。你可能想找到另一个解决方案，但是如果你知道你在做什么，就去做吧。

在这个例子中，如果你想访问`myPlanet.core`，你不能，因为它不是为暴露而设计的。然而，`my_planet._core`是可访问的，支持 bug 追踪，进一步开发，或者完全搞乱这个星球。

# 样板文件

[样板文件](https://en.wikipedia.org/wiki/Boilerplate_code#)是程序员需要为重复任务编写的冗长和行数，很少或没有特别的变化。Java 是一种冗长的编程语言，需要许多行来完成几乎任何事情。这很累人。

当然，有一些方法可以解决这个问题(使用自动生成的代码、注释等)。)，但有时我会想，“嘿，我只是在那里放了一个变量。为什么我要编写一个 setter 和一个 getter 来安全地访问它？”为什么我要完全设计一个类结构(它不是一个类，而是一个接口),仅仅是为了声明我将放在别处的一个特定实现的结构？听起来太复杂了，不是吗？

当然，接口在 Java 中有其逻辑和理由。但是写三次相同的签名并使结构有两个实现是非常耗时的。

Python 通常更简洁，完成同样的任务需要更少的代码。我们不会遍历所有的语法，也不会比较 Python 紧凑多少。举个简单的例子——这里没有接口！

# 多重继承和类型化

Java 有基于接口的多重继承。这迫使程序员放入另一个抽象层，该抽象层包含要实现的公共定义。这是简单和实用主义的对立面。Java 的类型策略是严格的，方法签名、泛型、接口、抽象类和类型转换对于正确设计和调试都是一个问题。

在下面的片段中，`AbandonedAsteroid`是否适合居住？这是我们遇到的 Java 类型问题的一个例子。

Python 有一个非常强大的类型化策略，可以避免所有这些问题，并且包含多重继承。这叫做鸭子打字。只要实例*嘎嘎叫*，那么你就可以认为它是*鸭*。这意味着只要代码块的请求得到满足，就不需要进行类型检查。

注意:变量的类型是明确定义的，但是特定实例的使用并不局限于给定的类或类型。这也意味着你的代码可能会有意想不到的用法，仅仅是通过给它添加一些*嘎嘎叫*的东西。

# 什么是对象？这是什么？

Java 有定义什么是什么的类型和类。但是什么是类呢？什么是类型？一个功能？一种方法？什么是`this`？抽象的东西和幕后的魔法让构造器生成实例。

对于所有这些问题，Python 有两个非常简单的答案:一切都是对象，一个类的所有方法都像静态 Java 方法一样。

第一个断言意味着，除了基本类型，所有其他实体都是类实例。此外，类型定义是类，它们的实例是对象。函数、方法和 lambdas 也是对象。

第二点在所有的类定义中都有明确的证据:所有的方法签名都将`self`作为引用处理的第一个参数，这意味着原始实例的修改。唯一神奇的是你在调用方法的时候把它放下了(但这是我们习惯的)。实际的静态方法用`@staticmethod`标注，没有`self`参数。

# 权力越大，责任越大

伴随着自由和权力而来的是责任。对于生活和工作都是如此——对于海滩和编程语言。随着自由意志而来的是犯错的可能性。我们是唯一要为我们的错误负责的人。

这里最好的答案大概是“找到适合自己的。”我发现自己更适应 Python 的哲学，我不必强迫自己去设计东西，但有人可能会因为 Java 的僵硬和冗长而喜欢它。谁知道呢？