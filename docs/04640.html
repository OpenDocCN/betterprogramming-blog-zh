<html>
<head>
<title>Learn JavaScript by Implementing Lodash Methods: Unique Array Entries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现Lodash方法学习JavaScript:唯一数组条目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learning-javascript-by-implementing-lodash-methods-unique-array-entries-dfd17d336e76?source=collection_archive---------7-----------------------#2020-04-27">https://betterprogramming.pub/learning-javascript-by-implementing-lodash-methods-unique-array-entries-dfd17d336e76?source=collection_archive---------7-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ded" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Lodash的“uniq”系列方法可以毫无困难地用普通JS实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e699139696c6c0a6d403d0d780645114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*vnq894PjNfb37cKCC2htAQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">照片由<a class="ae ku" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上的<a class="ae ku" href="https://unsplash.com/@surface?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">表面</a>和</a>组成</p></figure><p id="b1f4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Lodash 是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然而，现在<a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" rel="noopener ugc nofollow" target="_blank"> JavaScript标准库</a>正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="8dce" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，我们将通过在普通JavaScript中实现一些Lodash方法，包括<code class="fe lr ls lt lu b">uniq</code> <code class="fe lr ls lt lu b">uniqBy</code>和<code class="fe lr ls lt lu b">uniqWith</code>，来了解和学习更多关于JavaScript的知识。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="38e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">唯一的</h1><p id="e4f9" class="pw-post-body-paragraph kv kw it kx b ky mu ju la lb mv jx ld le mw lg lh li mx lk ll lm my lo lp lq im bi translated">Lodash <code class="fe lr ls lt lu b">uniq</code>方法创建一个没有重复值的数组。每个值只有第一次出现在返回的数组中。</p><p id="5411" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因为JavaScript已经有了<code class="fe lr ls lt lu b">set</code>数据结构，我们可以使用spread操作符从原始数组中删除所有重复的数据并返回它。</p><p id="74d4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以这样实现:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="c5f6" class="nd md it lu b gy ne nf l ng nh">const uniq = arr =&gt; [...new Set(arr)]</span></pre><p id="cae8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的代码中，我们只是将<code class="fe lr ls lt lu b">arr</code>转换成一个集合来删除重复的值，然后用spread运算符将其转换回一个数组。</p><p id="c522" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么当我们这样称呼它的时候…</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="6cdd" class="nd md it lu b gy ne nf l ng nh">const result = uniq([1, 2, 2, 3]);</span></pre><p id="9deb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">…我们得到<code class="fe lr ls lt lu b">result</code>是<code class="fe lr ls lt lu b">[1, 2 ,3]</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d666" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><code class="fe lr ls lt lu b">'uniqBy'</code></h1><p id="74e0" class="pw-post-body-paragraph kv kw it kx b ky mu ju la lb mv jx ld le mw lg lh li mx lk ll lm my lo lp lq im bi translated"><code class="fe lr ls lt lu b">uniqBy</code>与<code class="fe lr ls lt lu b">uniq</code>相似，只是它采用了一个<code class="fe lr ls lt lu b">iteratee</code>函数，该函数在比较值的唯一性之前运行。这意味着我们不能把它转换成一个集合。相反，我们必须运行<code class="fe lr ls lt lu b">iteratee</code>，然后将它们与我们返回的数组中的现有条目进行比较。</p><p id="fa75" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为此，我们以下列方式实现了<code class="fe lr ls lt lu b">uniqBy</code>:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="4872" class="nd md it lu b gy ne nf l ng nh">const uniqBy = (arr, iteratee) =&gt; {<br/>  let uniques = [];<br/>  for (let a of arr) {<br/>    const mappedUniques = uniques.map(iteratee);<br/>    if (!mappedUniques.includes(iteratee(a))) {<br/>      uniques.push(a);<br/>    }<br/>  }<br/>  return uniques;<br/>}</span></pre><p id="ca83" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的代码中，我们有一个<code class="fe lr ls lt lu b">uniques</code>数组，它包含我们将返回的唯一条目的数组。</p><p id="d08e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后我们用<code class="fe lr ls lt lu b">for...of</code>循环遍历<code class="fe lr ls lt lu b">arr</code>。在循环内部，我们用<code class="fe lr ls lt lu b">iteratee</code>映射<code class="fe lr ls lt lu b">uniques</code>数组以获得映射的值。</p><p id="7898" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们检查每个数组条目是否已经在<code class="fe lr ls lt lu b">uniques</code>中，方法是检查它是否在<code class="fe lr ls lt lu b">mappedUniques</code>数组中，而不是在<code class="fe lr ls lt lu b">uniques</code>中，因为我们想比较它被<code class="fe lr ls lt lu b">iteratee</code>函数转换后的唯一性。</p><p id="78ef" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果用<code class="fe lr ls lt lu b">includes</code>方法检查时没有包含，那么我们将该值推入<code class="fe lr ls lt lu b">uniques</code>。</p><p id="f531" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一旦循环结束，我们返回<code class="fe lr ls lt lu b">uniques</code>。那么当我们这样称呼它的时候:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="b408" class="nd md it lu b gy ne nf l ng nh">const result = uniqBy([1, 2, 2.1, 3], Math.floor);</span></pre><p id="823d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么<code class="fe lr ls lt lu b">result</code>就是<code class="fe lr ls lt lu b">[1, 2, 3]</code>，因为<code class="fe lr ls lt lu b">2</code>和<code class="fe lr ls lt lu b">2.1</code>在对它们调用<code class="fe lr ls lt lu b">Math.floor</code>之后是相同的。<code class="fe lr ls lt lu b">iteratee</code>可以是任何接受一个参数并返回从其派生的内容的函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8e92" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><code class="fe lr ls lt lu b">'uniqWith'</code></h1><p id="7451" class="pw-post-body-paragraph kv kw it kx b ky mu ju la lb mv jx ld le mw lg lh li mx lk ll lm my lo lp lq im bi translated"><code class="fe lr ls lt lu b">uniqWith</code>类似于<code class="fe lr ls lt lu b">uniq</code>,除了它接受一个比较器，该比较器运行来比较具有唯一值的现有值和不具有唯一值的现有值。</p><p id="e513" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果原始数组中的条目不在具有唯一值的数组中，那么我们将它放入具有唯一值的数组中。</p><p id="ab68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在检查给定数组中的所有值后，最终返回具有唯一值的数组。</p><p id="1c03" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以如下实现它:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="55f1" class="nd md it lu b gy ne nf l ng nh">const uniqWith = (arr, comparator) =&gt; {<br/>  let uniques = [];<br/>  for (let a of arr) {<br/>    if (uniques.findIndex(u =&gt; comparator(a, u)) === -1) {<br/>      uniques.push(a);<br/>    }<br/>  }<br/>  return uniques;<br/>}</span></pre><p id="53e3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的代码中，我们有:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="cd39" class="nd md it lu b gy ne nf l ng nh">uniques.findIndex(u =&gt; comparator(a, u)) === -1</span></pre><p id="0fa9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这将检查<code class="fe lr ls lt lu b">uniques</code>中的条目是否与我们正在循环的数组条目相同。如果不是(如返回值<code class="fe lr ls lt lu b">-1</code>所示)，那么我们将它放入<code class="fe lr ls lt lu b">uniques</code>。</p><p id="c4d5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当循环完成时，我们返回<code class="fe lr ls lt lu b">uniques</code>。</p><p id="2dfe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后我们如下运行它:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="9fea" class="nd md it lu b gy ne nf l ng nh">const result = uniqWith([1, 2, 2.1, 3], (a, b) =&gt; Math.floor(a) === Math.floor(b));</span></pre><p id="5df9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">由此，我们得到<code class="fe lr ls lt lu b">[1, 2, 3]</code>作为<code class="fe lr ls lt lu b">result</code>的值，因为我们的比较器确定如果两个值的下限相同，那么它们就是相同的。<code class="fe lr ls lt lu b">comparator</code>函数需要两个参数和两个值进行比较。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="99a6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6cac" class="pw-post-body-paragraph kv kw it kx b ky mu ju la lb mv jx ld le mw lg lh li mx lk ll lm my lo lp lq im bi translated">Lodash方法可以很容易地用普通的JavaScript集合和spread操作符实现</p><p id="d416" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">uniqBy</code>实现起来有点困难，因为我们需要用传入的<code class="fe lr ls lt lu b">iteratee</code>函数映射这些值，然后才能比较它们的唯一性。</p><p id="be06" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">uniqWith</code>与<code class="fe lr ls lt lu b">uniqBy</code>相似，我们必须运行<code class="fe lr ls lt lu b">comparator</code>函数来比较这些值，以确定这些项目是否是唯一的。</p></div></div>    
</body>
</html>