<html>
<head>
<title>5 Ways to Pass Data Between View Controllers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在视图控制器之间传递数据的5种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-ways-to-pass-data-between-view-controllers-18acb467f5ec?source=collection_archive---------1-----------------------#2020-07-16">https://betterprogramming.pub/5-ways-to-pass-data-between-view-controllers-18acb467f5ec?source=collection_archive---------1-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e175" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">序列、委托、单例等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67d83b94f39f2dd6df15447ec4e714bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7IBrH11TYKuzz15SsEi6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="4b05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将探索在视图控制器之间传递数据的五种方法，并提供Swift代码片段和示例。这五种方式是:</p><ol class=""><li id="5549" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">塞格斯</li><li id="159c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">委托设计模式</li><li id="ff75" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">单一设计模式</li><li id="5c0d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">关闭</li><li id="0b43" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">通知中心</li></ol></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="a867" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">1.塞格斯</h1><p id="4268" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">Segues是一种传递数据的故事板模式。</p><p id="0b81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您的应用程序有一个onboarding屏幕，您希望询问用户的姓名，以便稍后在另一个屏幕上显示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7d5041b97a3864879c8c9a5a49ec4374.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*sfad7QmkInPjZz6NNLUUvA.gif"/></div></figure><p id="6f17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过故事板开始创作情节。<em class="nn"> </em>按住Control键并点击你要用来制作桥梁的UI元素，拖动到第二个视图控制器。从“动作继续”菜单中选择“显示”选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e8bae8ad19556fd722eb8b6861838f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*8neRWc1TH0kuugDyBZ-Hjg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按住Control键并单击按钮，拖动到第二个视图Controller，然后选择“显示”</p></figure><p id="537d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在第一个<code class="fe np nq nr ns b">ViewController</code>类中，您需要覆盖<code class="fe np nq nr ns b">prepare(for segue)</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3f6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您的<code class="fe np nq nr ns b">SecondViewController</code>类应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="32ce" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">2.委托设计模式</h1><p id="a184" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">Delegate是iOS开发中广泛使用的一种模式，用于在对象之间交换消息。它允许一个对象与它的所有者通信。</p><p id="ce80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下，一家餐馆提供几种口味的果汁。有人负责接受订单并将产品交付给客户，另一个人负责有效地制作正确的果汁。说明任务划分的应用程序应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8879e13d4491f83d6ca53b381046e855.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*CGid2s3Pbfy9w6ZUIefhQw.gif"/></div></figure><p id="90d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用delegate实现类似的东西，您基本上需要四样东西:</p><ol class=""><li id="4a06" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">定义交付果汁需求的委托协议。</li><li id="51b0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">一个<code class="fe np nq nr ns b">Juice</code>视图控制器<strong class="la iu"> </strong>使果汁具有合适的味道。</li><li id="39ac" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">一个<code class="fe np nq nr ns b">Restaurant</code> <strong class="la iu"> </strong>视图控制器，必须符合协议。</li><li id="8b8f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">您需要将委托<strong class="la iu"> </strong>方法和变量放在正确的位置。</li></ol><p id="7ba5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开始创建委派协议。以类命名是一个好的习惯。这个协议说明了一个想要遵守它的类(在这个例子中，是一个想要提供果汁的类)需要实现什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7cf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在<code class="fe np nq nr ns b">Juice</code>视图控制器上，当选择了口味时，我们需要通知餐馆。为此，我们使用委托来传递味道。将委托属性创建为弱属性<code class="fe np nq nr ns b">var</code>,以避免保留周期和内存泄漏。此外，创建一个方法(在本例中，我们使用了按下按钮的动作)来通知某人何时采取了动作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="64f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一个符合<code class="fe np nq nr ns b">JuiceDelegate</code>协议的类。在类声明中使用<code class="fe np nq nr ns b">JuiceDelegate</code>。这样做的时候，编译器会抱怨你需要实现<code class="fe np nq nr ns b">flavourWasChosen</code>方法。在方法内部，通知客户端果汁准备好了。当调用<code class="fe np nq nr ns b">Juice</code>视图控制器时，记得将代理分配给<code class="fe np nq nr ns b">self</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="86ae" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">3.单一设计模式</h1><p id="a6b8" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">尽管很多iOS开发人员在不应该的时候使用singleton(这是另一个讨论)，但确实有这种模式是一个好选择的情况。</p><p id="5215" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用singleton保证您的应用程序将只包含某个类的单个实例，可以在项目中的任何地方访问该实例。这是一个全局变量。</p><p id="4e30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">管理应用程序的设置是可以接受使用singleton的一个例子。假设用户关闭了<code class="fe np nq nr ns b">Settings</code>视图控制器上的声音。这个选择需要通过app的其余部分来体现。</p><p id="b089" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这么多人使用这种模式的主要原因是它实现起来真的很简单。看看这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3091" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是创建单例的全部内容。要访问<code class="fe np nq nr ns b">isSoundOn</code> <em class="nn"> </em>布尔值，要么覆盖它，要么获取它的值，您只需键入:</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="e770" class="nz mq it ns b gy oa ob l oc od">Settings.instance.isSoundOn</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="511a" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">4.关闭</h1><p id="4cfa" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">闭包是可以在代码中传递的代码块，用于在视图控制器之间共享数据。例如，当您使用本机<code class="fe np nq nr ns b">dismiss</code>方法时，您正在使用一个闭包:</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="ea9a" class="nz mq it ns b gy oa ob l oc od">dismiss(animated: true, completion: nil)</span></pre><p id="4185" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然我们通常用<code class="fe np nq nr ns b">nil</code>填充<code class="fe np nq nr ns b">completion</code>参数，但它实际上可以接收另一个函数作为参数。</p><p id="c621" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您有一个在视图中呈现给用户的概要文件，并且可以在另一个视图中回答一个表单来填充概要文件的一些字段。当您关闭表单视图时，您希望该数据返回到配置文件屏幕。像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9da4b59fb164b50c82fc3332f5a57f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*eY1E6PnBEPG39YA4QV77rQ.gif"/></div></figure><p id="dce0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用闭包实现这一点非常简单。首先，在您的<code class="fe np nq nr ns b">Profile</code>视图控制器上，创建一个接收数据的变量和一个设置该变量的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="eed1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在您的<code class="fe np nq nr ns b">Form</code>视图控制器上，创建一个获取所选宠物的方法(带有<code class="fe np nq nr ns b">String</code>返回)和一个调用<code class="fe np nq nr ns b">dismiss</code>闭包的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1256" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意第9-13行发生了什么。我们使用<code class="fe np nq nr ns b">dismiss</code>方法，并发送一个字符串作为完成参数。怎么会？</p><p id="e910" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，通过创建一个<code class="fe np nq nr ns b">Profile</code>视图控制器的实例。还记得这个<code class="fe np nq nr ns b">viewController</code>有一个<code class="fe np nq nr ns b">setPet</code>方法吗？我们从<code class="fe np nq nr ns b">viewController</code>实例中调用这个方法，由于这个函数(<code class="fe np nq nr ns b">setPet</code>)需要一个字符串参数，我们从<em class="nn"> </em> <code class="fe np nq nr ns b">getFavoritePet</code>方法中发送给它<code class="fe np nq nr ns b">return</code> <em class="nn"> </em>，这是一个字符串。</p><p id="0315" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事件的顺序如下:</p><ul class=""><li id="526b" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt oe ma mb mc bi translated">用户选择一只宠物。</li><li id="616c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">宠物的名字作为字符串存储在<code class="fe np nq nr ns b">favoritePet</code> <em class="nn"> </em>变量中。</li><li id="d6f1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated"><code class="fe np nq nr ns b">getFavoritePet</code>方法返回<em class="nn"> </em>这个名字。</li><li id="2593" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">我们使用这个返回作为<code class="fe np nq nr ns b">setPet</code>方法的参数。</li><li id="6664" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">在创建了实现它的类的实例之后，我们调用了<code class="fe np nq nr ns b">setPet</code>方法。</li><li id="4764" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">我们关闭当前的<code class="fe np nq nr ns b">Form</code>视图控制器，回到<code class="fe np nq nr ns b">Profile</code>视图控制器。</li><li id="3ede" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">然后，我们使用从<code class="fe np nq nr ns b">Form</code>视图控制器获得的数据。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="2731" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">5.通知中心</h1><p id="2a10" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">NotificationCenter是一种在视图控制器之间传递数据的“观察者设计模式”方式。当你期待的事情发生时，你可以用它来传递信息。例如，您可以等待玩家进入等候室玩多人游戏。当所有玩家都准备好了，你发送一个通知开始处理比赛。</p><p id="5032" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上有三件事需要注意:观察、发送和处理通知。</p><p id="c100" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要开始观察通知，创建一个通知并使用它向<code class="fe np nq nr ns b">NotificationCenter</code>添加一个观察者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="96d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在通知被发送时处理它，您应该实现一个方法，并将其用作上面实现的<code class="fe np nq nr ns b">addObserver</code>的<code class="fe np nq nr ns b">selector</code>参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="55d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，要从另一个视图控制器发送通知，只需使用<code class="fe np nq nr ns b">post</code>方法<em class="nn"> </em>和您的通知名称:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="68a5" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="7eb6" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">因此，这是在Swift视图控制器之间传递数据的五种方式。有疑问吗？反馈？欢迎在评论区联系我。</p><p id="325c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div></div>    
</body>
</html>