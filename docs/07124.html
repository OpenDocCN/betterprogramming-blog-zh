<html>
<head>
<title>How To Remove useEffect ESLint Warnings in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中删除useEffect ESLint警告</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-eslint-hates-your-useeffect-dependencies-react-js-560fcac0b1f?source=collection_archive---------4-----------------------#2020-12-09">https://betterprogramming.pub/why-eslint-hates-your-useeffect-dependencies-react-js-560fcac0b1f?source=collection_archive---------4-----------------------#2020-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d920" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不使用<code class="fe ki kj kk kl b">eslint-disable-line</code></h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4db2d399fe6fd508c3946740571c2112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gZ42fMnhmQUE8x8t"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@isaacwendland?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Isaac Wendland </a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="4f3c" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你是React开发者吗？是否使用挂钩和功能组件？你使用ESLint来确保你的代码不做任何怪异的事情吗？如果是，那么我敢肯定你在使用<code class="fe ki kj kk kl b">useEffect</code>时遇到过<code class="fe ki kj kk kl b">exhaustive-deps</code> ESLint警告。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lz"><img src="../Images/aa91f39cc4126bd290bab1480d45dbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cM7JNXgd2b1pdOpCpmeWIQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">你以前见过这个错误吗？</p></figure><p id="8945" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这篇文章中，我们将看看这个警告是什么时候触发的，以及正确的解决方法。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d1e2" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">ESLint什么时候触发这个警告？</h1><p id="88f4" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">为了理解什么时候触发<code class="fe ki kj kk kl b">exhaustive-deps</code>警告，让我们看一些代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8b19" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每当要显示其概要文件的用户的ID发生变化时，上面代码中的<code class="fe ki kj kk kl b">useEffect</code>就会加载用户的概要文件数据。现在，让我们站在ESLint的立场上分析一下<code class="fe ki kj kk kl b">useEffect</code>呼叫。</p><h2 id="e4e9" class="ng mi it bd mj nh ni dn mn nj nk dp mr lm nl nm mt lq nn no mv lu np nq mx nr bi translated"><strong class="ak"/><code class="fe ki kj kk kl b"><strong class="ak">useEffect</strong></code><strong class="ak">从ESLint的角度看</strong></h2><ul class=""><li id="2f21" class="ns nt it lf b lg mz lj na lm nu lq nv lu nw ly nx ny nz oa bi translated">每当<code class="fe ki kj kk kl b">userId</code>改变时，加载配置文件。</li><li id="1089" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated">但是等等！如果我们必须加载概要文件的方法的实现发生了变化，该怎么办？</li><li id="2c08" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated">我必须警告用户！</li></ul><p id="b0fb" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从ESLint的角度来看，确实有道理！我们知道在这种情况下<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>的实现不会改变，但是ESLint不会。然而，这里ESLint是正确的。在某种程度上，如果<code class="fe ki kj kk kl b">userId</code>改变了，那么<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>的实现(或者说<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>加载数据的方式)也会改变。这是因为<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>被绑定到了<code class="fe ki kj kk kl b">userId</code>。</p><p id="ca05" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们避开了这个小细节，通过在依赖数组中直接添加<code class="fe ki kj kk kl b">userId</code>来使<code class="fe ki kj kk kl b">useEffect</code>工作。这个概念过一会儿会变得更清晰，所以请多包涵。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9271" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">解除警告</strong></h1><p id="3f1d" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">现在，让我们看看如何删除这个警告。不，我们不会通过在依赖数组行上添加一个<code class="fe ki kj kk kl b">//eslint-disable-line</code>来删除警告。我们这里不喜欢这种类型的黑客。不管怎样，我们已经知道ESLint抱怨是因为<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>不在<code class="fe ki kj kk kl b">useEffect</code>依赖数组中。所以，让我们给ESLint它想要的！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bc16" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们所做的就是在依赖数组中添加<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>，然后嘭！这个警告现在已经消失了。我们现在可以睡个安稳觉了。但也不尽然！仅仅取消警告是不够的。这种解决方案导致了新的问题。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="7d15" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">新问题</strong></h1><p id="811e" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">在讨论这个问题之前，让我们通过陈述一些事实来确保我们意见一致。重新呈现<code class="fe ki kj kk kl b">Profile</code>组件可以被认为是简单地调用函数。此外，每当您调用一个函数时，它内部声明的所有其他函数(在本例中是<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>函数)都会被重新创建。因此，每当React重新呈现<code class="fe ki kj kk kl b">Profile</code>组件时，<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>将指向一个新的函数。</p><p id="67dc" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的新问题是<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>现在会改变或者在<em class="og">上被重新创建，无论</em>是否被改变。让我们一步步来看这个问题:</p><ul class=""><li id="5cf9" class="ns nt it lf b lg lh lj lk lm oh lq oi lu oj ly nx ny nz oa bi translated">组件已安装，并且<code class="fe ki kj kk kl b">useEffect</code>正在运行。</li><li id="e9a9" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated"><code class="fe ki kj kk kl b">useEffect</code>回调调用<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>，后者又调用<code class="fe ki kj kk kl b">setProfileData</code>。</li><li id="6c12" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated">在没有任何条件的情况下，每次重新渲染时发生变化的函数和变量将导致<code class="fe ki kj kk kl b">useEffect</code>循环。我们知道任何状态变化都会导致组件的重新呈现。如前所述，这种重新渲染改变/重新创建了<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>。</li><li id="87e4" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated"><code class="fe ki kj kk kl b">loadCurrentUserProfile</code>中的这一变化重新运行了<code class="fe ki kj kk kl b">useEffect</code>，因为它在依赖数组中。这会导致对API的额外的、不必要的调用。</li><li id="7795" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated">这种循环将永远重复下去，注定要遭遇与西西弗斯相似的命运。</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="85b1" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">正确移除警告</h1><p id="cea9" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">最后，让我们来看看如何正确地解决这个问题:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a92b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">以下是我们所做的更改:</p><ul class=""><li id="812e" class="ns nt it lf b lg lh lj lk lm oh lq oi lu oj ly nx ny nz oa bi translated">我们将<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>包装在一个<code class="fe ki kj kk kl b">useCallback</code>钩子中，并将<code class="fe ki kj kk kl b">userId</code>作为依赖项。</li><li id="8198" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated">我们改变了<code class="fe ki kj kk kl b">useEffect</code>的依赖数组，只包含了<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>。</li></ul><p id="b03f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，如果您不知道<code class="fe ki kj kk kl b">useCallback</code>做什么，它确保传递给它的函数不会在重新呈现之间被重新创建，除非依赖数组中的任何内容发生了变化。这意味着只有当<code class="fe ki kj kk kl b">userId</code>改变时<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>才会改变。这与我上面提到的每当<code class="fe ki kj kk kl b">userId</code>改变时<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>改变的实现有关。我们用<code class="fe ki kj kk kl b">useCallback</code>来讲述同样的事情来反应。</p><p id="6751" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里需要注意的一点是<code class="fe ki kj kk kl b">useCallback</code>也包含一个依赖数组。这里讨论的东西也可以应用到<code class="fe ki kj kk kl b">useCallback</code>和<code class="fe ki kj kk kl b">useMemo</code>钩子中的依赖数组。</p><p id="32f6" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">第二，<code class="fe ki kj kk kl b">useEffect</code>现在仅在<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>改变时触发。这里我们不在依赖数组中指定<code class="fe ki kj kk kl b">userId</code>，因为<code class="fe ki kj kk kl b">loadCurrentUserProfile</code>已经依赖于<code class="fe ki kj kk kl b">userId</code>。相反，我们告诉React每当加载当前用户配置文件的实现发生变化时，就重新加载当前用户的配置文件。从用户和棉绒的角度来看，这都是有意义的。</p><p id="dd6c" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">理解组件中不同数据之间的依赖关系和关系，以及它们是如何联系在一起的，有时会有点复杂。然而，随着你不断遇到这些问题并解决它们，你会对它们有更好的理解——就像处理其他问题一样。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="df52" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><ul class=""><li id="957c" class="ns nt it lf b lg mz lj na lm nu lq nv lu nw ly nx ny nz oa bi translated">始终指定依赖数组中使用的每个变量。</li><li id="2089" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated">在没有任何条件的情况下，每次重新渲染时发生变化的函数和变量将导致<code class="fe ki kj kk kl b">useEffect</code>循环。</li><li id="6f0f" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated">如果您需要使用在组件内部创建的函数作为依赖项，将它包装在一个<code class="fe ki kj kk kl b">useCallback</code>中。对于非函数的值,<code class="fe ki kj kk kl b">useMemo</code>相当于<code class="fe ki kj kk kl b">useCallback</code>。</li></ul><h2 id="21f3" class="ng mi it bd mj nh ni dn mn nj nk dp mr lm nl nm mt lq nn no mv lu np nq mx nr bi translated">一些提示</h2><ul class=""><li id="8503" class="ns nt it lf b lg mz lj na lm nu lq nv lu nw ly nx ny nz oa bi translated">将<code class="fe ki kj kk kl b">useCallback</code>用于函数，将<code class="fe ki kj kk kl b">useMemo</code>用于传递给子组件的非原始值也是一个好主意。这确保子对象不会在不必要时重新渲染或运行自己的钩子。</li><li id="a669" class="ns nt it lf b lg ob lj oc lm od lq oe lu of ly nx ny nz oa bi translated">您可以在自己的定制钩子中抽象出一些钩子逻辑。这将使代码模块化，可重用，并且更容易管理。然而，那是另一个时间的话题。</li></ul></div></div>    
</body>
</html>