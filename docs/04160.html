<html>
<head>
<title>How to Secure Your Smart Contracts (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保护您的智能合同(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-secure-your-smart-contracts-part-2-d3ec21f8685a?source=collection_archive---------10-----------------------#2020-03-26">https://betterprogramming.pub/how-to-secure-your-smart-contracts-part-2-d3ec21f8685a?source=collection_archive---------10-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="428d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">算术溢出和下溢</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/089699fb110d2ef9f92703388aa448b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glTwnf5K4Wv2n9YUfOwrFw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@antoine1003?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Antoine Dautry </a>在<a class="ae ky" href="https://unsplash.com/s/photos/maths?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="6ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">先决条件:对以太坊区块链和智能合约有基本的了解。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="08ae" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">介绍</h1><p id="5a0c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这是保护您的智能合同系列的第2部分。<a class="ae ky" href="https://medium.com/coinmonks/how-to-secure-your-smart-contracts-dc500f2c8fca" rel="noopener">第1部分讨论了可重入性和所有者逻辑盗窃攻击</a>。</p><p id="bb76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将经历<em class="lv">算术溢出</em>和<em class="lv">下溢，</em>这是一种有时会潜入我们代码的逻辑弱点。我们将描述它们的含义，它们可能出现的例子，以及如何防止它们出现在我们的智能合约中。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c95a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">它们是什么？</h1><p id="a541" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了理解算术上溢和下溢，我们必须首先理解它们出现的数据类型。</p><p id="c4c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以太坊虚拟机(EVM)整数的大小总是固定的。例如，<code class="fe na nb nc nd b">unit8</code>只能存储0到255之间(包括0和255)的值。试图在<code class="fe na nb nc nd b">uint8</code>变量中存储值256将导致值0。如果在执行前不进行检查，这是利用漏洞的最佳时机。</p><h2 id="c953" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">下溢</h2><p id="26bc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当从一个整数中减去一个值时，如果该整数的当前值小于被减的值，就会出现下溢。例如:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="fd1d" class="ne me it nd b gy nu nv l nw nx">uint8 myValue = 2;<br/>uint8 subValue = 3;</span><span id="9fff" class="ne me it nd b gy ny nv l nw nx">uint8 result = myValue - subValue;</span></pre><p id="8b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们的<code class="fe na nb nc nd b">result</code>变量不会像我们认为的那样等于-1；<code class="fe na nb nc nd b">result</code>等于255。</p><p id="3128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从2开始倒数，EVM变成了<em class="lv"> … </em> 1 … 0 … 255。这被称为<em class="lv">下溢。</em></p><h2 id="96ed" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">充满</h2><p id="014b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">溢出是下溢的反义词。当一个值被添加到一个整数变量时，如果结果大于该变量的数据类型的最大限制，就会出现这种情况。例如:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="0648" class="ne me it nd b gy nu nv l nw nx">uint8 myValue = 254;<br/>uint8 addValue = 3;</span><span id="817d" class="ne me it nd b gy ny nv l nw nx">uint8 result = myValue + addValue;</span></pre><p id="2e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们的<code class="fe na nb nc nd b">result</code>变量并不像我们认为的那样等于257。它被计算为1，因为255是<code class="fe na nb nc nd b">uint8</code>的最大值。</p><p id="0b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从254开始向上数，EVM是… 255 … 0 … 1。这就是所谓的<em class="lv">溢出。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="af60" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">例子</h1><p id="b464" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">考虑这段可靠性代码，在滚动到解释之前，您能发现问题吗？</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="bcd9" class="ne me it nd b gy nu nv l nw nx">mapping(address =&gt; uint) balances;</span><span id="893d" class="ne me it nd b gy ny nv l nw nx">function withdraw(uint _value) external {<br/>    require(balances[msg.sender] - _value &gt;= 0);<br/>    balances[msg.sender] -= _value;<br/>    msg.sender.transfer(_value);    <br/>}</span></pre><p id="d57a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">require</code>语句要求发送方的余额减去取款金额大于或等于0。这在逻辑上对我们是有意义的，因为我们不想让任何人提取超过他们余额的金额。但是，这容易受到下溢攻击。</p><p id="6deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果攻击者在契约中存储了两个乙醚，并试图提取十个，那么<code class="fe na nb nc nd b">require</code>语句将允许这样做。这是因为减法会通过下溢到最大值而导致<code class="fe na nb nc nd b">balances[msg.sender] — _value</code>的结果大于或等于0。因为整数是无符号的，只要<code class="fe na nb nc nd b">msg.sender</code>有余额，<code class="fe na nb nc nd b">require</code>语句就会<em class="lv">总是</em>通过。</p><p id="0f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照这种逻辑，<em class="lv">任何人</em>在任何时点存入余额，都可以完全冲掉资金契约。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c3ea" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">预防措施</h1><p id="d204" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">始终使用提供更安全函数的库来执行基本运算。<a class="ae ky" href="https://openzeppelin.com/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>的<a class="ae ky" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol" rel="noopener ugc nofollow" target="_blank"> SafeMath </a>库是Solidity社区中最常用的。它提供了加、减、乘、除和取模的功能。</p><p id="3e1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该库在发布之前经过了社区的彻底审查，因此我们可以对其防止算术逻辑错误的能力充满信心。下面是一个如何使用SafeMath的<code class="fe na nb nc nd b">sub()</code>函数而不是在我们的智能契约中使用减算术运算符的示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="9dc6" class="ne me it nd b gy nu nv l nw nx">using SafeMath for uint;</span><span id="0b6e" class="ne me it nd b gy ny nv l nw nx">function withdraw(uint _value) external {<br/>    require(balances[msg.sender].sub(_value) &gt;= 0);<br/>    balances[msg.sender] -= _value;<br/>    msg.sender.transfer(_value);    <br/>}</span></pre><p id="30cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，如果我们试图提取超过余额的金额，那么<code class="fe na nb nc nd b">require</code>语句就会失败。这是因为<code class="fe na nb nc nd b">sub()</code>功能要求余额大于或等于<code class="fe na nb nc nd b">_value</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a740" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">进一步阅读</h1><ul class=""><li id="2707" class="nz oa it lb b lc mv lf mw li ob lm oc lq od lu oe of og oh bi translated">阅读本系列关于可重入性和所有者逻辑盗窃的第1部分。</li><li id="7d65" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">浏览教程、演练、解释和备忘单的集合，积累您的区块链开发经验。</li></ul><div class="on oo gp gr op oq"><a href="https://medium.com/blockcentric/blockchain-development-resources-b44b752f3248" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">区块链开发资源马上跟进</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">学习区块链、以太坊和DApp开发的资源列表</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div></div></div>    
</body>
</html>