<html>
<head>
<title>Dependency Injection With Dip</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Dip的依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dependency-injecton-with-dip-1d5adec45cee?source=collection_archive---------3-----------------------#2019-09-29">https://betterprogramming.pub/dependency-injecton-with-dip-1d5adec45cee?source=collection_archive---------3-----------------------#2019-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a9cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Swift中使用依赖注入容器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e46ca22d88f8a3c75590cccaf12a036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viqGOdr1YHrjSK6bhCsDXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">依赖注入容器很像一个手提箱。</p></figure><p id="3f11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">依赖注入是降低复杂性的一个重要概念。依赖注入有许多不同的方法，今天我们来看一个叫做依赖注入容器的概念。我们将探索一个提供这种容器的框架，称为Dip，它是由AliSoftware开发的，可以在他的<a class="ae lu" href="https://github.com/AliSoftware/Dip" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="c490" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是什么是依赖注入容器呢？你可以把它想象成一个手提箱，里面装着你所有的依赖。手提箱(以及里面的所有东西)可以很容易地从一个人手中转到下一个人手中。依赖项注入容器提供了一种简单的方法，将依赖项捆绑在一个对象中进行传递。当您需要处理许多依赖项时，这非常有用。看看这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个类可能有许多依赖项。</p></figure><p id="36bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像这样的类可以管理一个应用程序的设置。它使用存储库来加载和保存设置和用户数据，可以访问验证用户对电子邮件和密码所做的更改的类，并且有许多其他依赖项。每当您想要创建一个<code class="fe lx ly lz ma b">SettingsService</code>的实例时，您将需要收集所有这些依赖项，它们自己可能有多个依赖项。</p><p id="4a17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用一个容器，例如Dip的<code class="fe lx ly lz ma b">DependencyContainer</code>类，你可以将所有的依赖关系封装在一个大的单一依赖关系中。这样<code class="fe lx ly lz ma b">SettingsService</code>的设置就简单多了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">只传递一个依赖容器要简单得多。</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d05b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">例子</h1><p id="8f84" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">让我们通过看一些例子来探索Dip。为了演示Dip是如何工作的，我将引入一个协议<code class="fe lx ly lz ma b">Clock</code>，它只定义了一个叫做<code class="fe lx ly lz ma b">today</code>的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">协议时钟将用于演示Dip的工作方式。</p></figure><p id="bffa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用该协议的三种不同实现来探索Dip的不同方面。</p><p id="2428" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个实现叫做<code class="fe lx ly lz ma b">SimpleClock</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SimpleClock是Clock的一个精简实现。</p></figure><p id="80ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 1</code> —每当这个类的一个实例被初始化时，它打印出一条消息。</p><p id="29c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 2</code> —我们还希望看到它何时被取消初始化，从而在此处添加另一个打印。</p><p id="e471" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 3</code> —最后，我们需要实现所需的函数<code class="fe lx ly lz ma b">today</code>，这里我们只是返回一个新的日期对象。</p><p id="c98b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们有了<code class="fe lx ly lz ma b">InitializerClock</code>。与前面的时钟不同，这个类期望在它的初始化器中有一个参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个InitializerClock都有自己的标识符。</p></figure><p id="9687" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像以前一样，我们打印出一条短消息，以便在初始化器被调用时得到通知。此外，我们保存给定的标识符。</p><p id="c79b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 2</code> —在反初始化器中，我们再次打印一条短消息。</p><p id="1ecc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 3</code> —同样，我们在<code class="fe lx ly lz ma b">today</code>中返回当前日期。</p><p id="d775" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后但同样重要的是:<code class="fe lx ly lz ma b">Clockzeption</code>。这个类看起来有点像上一个，但是这次它没有将标识符传递给它的初始化器，而是传递给了另一个<code class="fe lx ly lz ma b">Clock</code>实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Clockzeption非常懒惰，它使用另一个时钟来完成它的工作。</p></figure><p id="b5ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经设置好了一切，让我们看看Dip能为我们提供什么。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="97e0" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">Dip提供了什么</h1><h2 id="bf36" class="nf mj it bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">注册并解决</h2><p id="0afe" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">首先，让我们注册并解析一个<code class="fe lx ly lz ma b">SimpleClock</code>的实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注册并解决与Dip的依赖关系。</p></figure><p id="e04f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 1</code> —首先，我们创建一个新的<code class="fe lx ly lz ma b">DependencyContainer</code>。在闭包中，我们可以通过引用容器来注册依赖关系。</p><p id="6469" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 2</code> —注册就像调用方法<code class="fe lx ly lz ma b">register</code>并传递一个我们想要注册的对象一样轻松，例如<code class="fe lx ly lz ma b">SimpleClock</code>。这里我们创建了一个新的<code class="fe lx ly lz ma b">SimpleClock</code>实例，并注册为一个符合<code class="fe lx ly lz ma b">Clock</code>协议的依赖项。</p><p id="e801" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 3</code> — <strong class="la iu"> </strong>解析时，我们需要使用<code class="fe lx ly lz ma b">try</code>来捕捉错误。我们还需要指定我们期望从容器中得到的类型，以便能够解析正确的依赖关系。</p><p id="2caf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们运行这段代码时，我们会看到<em class="nr">在控制台中创建了SimpleClock </em>，因为它的初始化器被调用了。</p><h2 id="88e9" class="nf mj it bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">标签</h2><p id="14ba" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">到目前为止一切顺利！Dip还提供了使用标签来识别注册的依赖项的可能性。标签使得注册依赖关系的不同配置和设置成为可能。在解析时，我们需要传递我们想要依赖的标签。让我们使用<code class="fe lx ly lz ma b">InitializerClock</code>来看看如何做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标签允许我们识别注册的依赖项。</p></figure><p id="36af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 1</code> —我们可以使用普通的字符串作为标签，或者我们可以引入一个新的enum来实现协议<code class="fe lx ly lz ma b">DependencyTagConvertible</code>。该枚举保存要使用的标签。</p><p id="4b47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 2</code> —通过使用方法<code class="fe lx ly lz ma b">register(tag:)</code>，我们可以标记我们的依赖关系。这里你可以看到两种方法，使用<code class="fe lx ly lz ma b">Tags</code>枚举和一个原始字符串。</p><p id="3e5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们告诉容器标签，我们想要获得它的依赖。和以前一样，我们可以传递<code class="fe lx ly lz ma b">Tags</code>枚举或者使用一个原始字符串。</p><p id="a7b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看控制台，我们看到<em class="nr">用标识符创建initializer clock:Tagged clock</em>和<em class="nr">用标识符创建initializer clock:Tagged</em>，确认两个时钟都是用预期的名称创建的。</p><h2 id="42f4" class="nf mj it bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">自动布线</h2><p id="59fa" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">Dip提供了一种称为自动布线的机制。这意味着容器可以自己解决依赖关系。我们可以在<code class="fe lx ly lz ma b">Clockzeption</code>的帮助下探索这个特性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动连线自动连线从属关系。</p></figure><p id="edaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 1</code> —首先，我们注册一个<code class="fe lx ly lz ma b">SimpleClock</code>。</p><p id="816c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 2</code>——然后，当我们想要注册<code class="fe lx ly lz ma b">Clockzeption</code>时，需要在其初始化器中传递另一个时钟，容器可以自动解决这种依赖性。</p><p id="ed83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 3</code> — <strong class="la iu"> </strong>从容器中取出<code class="fe lx ly lz ma b">Clockzeption</code>时，它已经设置好，可以使用了。</p><p id="fdcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将看到<em class="nr">创建SimpleClock </em>和<em class="nr">创建clock zeption with internal clock:simple clock</em>，<em class="nr"> </em>证明Dip自动提供注册的<code class="fe lx ly lz ma b">SimpleClock</code>作为<code class="fe lx ly lz ma b">Clockzeption</code>的参数。</p><p id="26b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为自动布线的替代方案，我们可以通过解析<code class="fe lx ly lz ma b">SimpleClock</code>手册在闭包中设置<code class="fe lx ly lz ma b">Clockzeption</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在寄存器闭包中配置依赖关系。</p></figure><h2 id="c492" class="nf mj it bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">注册现有对象</h2><p id="1220" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">现在我们总是在register内部调用初始化器，但是我们也可以注册一个已经存在的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在容器中注册现有对象。</p></figure><p id="7d93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 1</code> —我们可能在代码中的其他地方创建了一个对象。</p><p id="fada" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 2</code>—<strong class="la iu">—</strong>在寄存器上，我们也可以引用已有的对象。</p><p id="fe96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 3</code> — <strong class="la iu"> </strong>解析时，我们可以检查是否是完全相同的实例。</p><h2 id="ce1d" class="nf mj it bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">寄存器值</h2><p id="4cce" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">Dip还允许我们注册值。正如你在这个例子中看到的，我们可以注册字符串、整数、布尔值或任何其他类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在容器中注册值</p></figure><h2 id="3416" class="nf mj it bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">范围</h2><p id="f48e" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">在依赖关系容器中注册的每个依赖关系都有一个定义其生存期的所谓范围。</p><p id="8cf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两个主要范围是<code class="fe lx ly lz ma b">unique</code>和<code class="fe lx ly lz ma b">singleton</code>。第一种方法每次创建一个新的实例。这是默认的作用域，所以如果你没有明确声明，每个依赖项都会有这个作用域。第二个作用域只创建一个实例一次，每次解析都返回相同的实例。</p><p id="19cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">范围<code class="fe lx ly lz ma b">singleton</code>还有另外两种选择:<code class="fe lx ly lz ma b">eagerSingleton</code> <em class="nr"> </em>(容器引导时创建实例)和<code class="fe lx ly lz ma b">weakSingleton</code> <em class="nr"> </em>(容器存储对已解析实例的弱引用)。</p><p id="c32b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个范围叫做<code class="fe lx ly lz ma b">shared</code>。具有此范围的依赖项是为一次resolve调用创建的。这允许我们有两个不同的对象共享同一个实例。</p><p id="c4c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让事情更清楚，让我们看看不同范围的依赖关系是如何表现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f888" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 1</code> —我们通过使用范围参数调用register方法来显式声明范围。这里我们注册了<code class="fe lx ly lz ma b">InitializerClock</code>的两个实例，一个具有作用域<code class="fe lx ly lz ma b">unique</code>，一个具有<code class="fe lx ly lz ma b">singleton</code>。我们用标签来区分要解决哪一个。</p><p id="424f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 2</code> —当两次解析带有范围<code class="fe lx ly lz ma b">unique</code>的时钟时，我们将在控制台中看到两行<em class="nr">创建带有标识符的initializer clock:unique</em>。这证明了每次解析都会初始化一个新的实例。</p><p id="0659" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 3</code> —但是当我们两次用作用域<code class="fe lx ly lz ma b">singleton</code>解析时钟时，我们只能看到一行<em class="nr">用标识符:singleton创建InitializerClock。因此，两个时钟singleton1和singleton2是相同的。</em></p><h2 id="fc0b" class="nf mj it bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">合作</h2><p id="0a21" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">多个容器可以链接在一起，从而进行协作。这允许使用其中一个组合容器的类也可以访问在另一个容器中注册的依赖项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">依赖性容器可以协作并共享它们依赖性。</p></figure><p id="23b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 1</code> —我们创建了两个容器，在其中我们用不同的标识符注册了<code class="fe lx ly lz ma b">InitializerClock</code>的实例。</p><p id="f86d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 2</code> —连接两个容器就像调用方法<code class="fe lx ly lz ma b">collaborate</code>一样简单。</p><p id="d4e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lx ly lz ma b">// 3</code> —当我们将其中一个容器传递给一个类时，这个类现在可以使用在两个容器中注册的依赖项。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d514" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">Dip的优点和缺点</h1><p id="8646" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">现在我们知道了如何使用Dip，我们可以看看它的一些优点和缺点。</p><h2 id="7619" class="nf mj it bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">优势</h2><ul class=""><li id="e8ed" class="ns nt it la b lb na le nb lh nu ll nv lp nw lt nx ny nz oa bi translated">注册和解析依赖关系非常简单。</li><li id="e2d5" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">传递多个依赖项更加方便，因为只需要传递一个容器，而不是多个不同的实例。</li><li id="94b5" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">自动连接改进了依赖项的创建和注册，依赖项本身依赖于已经在容器中注册的依赖项。</li><li id="f1be" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">标签允许我们注册多个不同配置的类。需要的变体可以通过标签识别。</li><li id="8075" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">使用一个单独的容器来模拟使得测试变得简单。</li><li id="c6b6" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">Dip可以自己解决循环依赖。</li></ul><h2 id="ebcf" class="nf mj it bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">不足之处</h2><ul class=""><li id="1331" class="ns nt it la b lb na le nb lh nu ll nv lp nw lt nx ny nz oa bi translated">任何只需要一个依赖项的类都可以访问容器中所有注册的对象。</li><li id="224c" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">乍一看，一个类具有哪种依赖关系是看不出来的。您需要查看哪些类已被解析。</li><li id="97b5" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">不像在初始化器中传递一个依赖项，从而确保它是可用的，任何解析依赖项的类都必须依赖于之前已经在某个地方注册过。</li><li id="ff3e" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">每个解决方案都需要错误处理。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7182" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="746a" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">总而言之，Dip是管理依赖关系的一个很好的方法。列出的缺点或多或少是这种依赖注入的普遍问题，并不仅仅与Dip相关。如果您决定使用依赖注入容器，Dip是一个不错的选择，它将为您提供各种各样的功能。</p><p id="d8c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想玩dip，但是用嵌入式pods创建一个游乐场对你来说太麻烦了，你可以在我的<a class="ae lu" href="https://github.com/DavidPiper94/dip_playground" rel="noopener ugc nofollow" target="_blank"> GitHub站点</a>上找到一个包含所有代码示例的游乐场。或者你可以<a class="ae lu" href="https://medium.com/@HeyDaveTheDev/making-swift-playgrounds-more-playful-6fd6d9f5ba54" rel="noopener">阅读我关于游乐场</a>的文章，在那里我解释了如何简单地用终端在一行中创建一个带有豆荚的游乐场。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="10ee" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">资源</h1><p id="f99f" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">【https://github.com/AliSoftware/Dip T4】</p></div></div>    
</body>
</html>