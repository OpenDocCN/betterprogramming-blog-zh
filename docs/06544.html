<html>
<head>
<title>Accessibility in Angular–Good Practices and Pitfalls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular中的可访问性——良好实践和缺陷</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-keyboard-listeners-good-practices-b208edc6bf89?source=collection_archive---------3-----------------------#2020-10-12">https://betterprogramming.pub/angular-keyboard-listeners-good-practices-b208edc6bf89?source=collection_archive---------3-----------------------#2020-10-12</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="bac1" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">软件工程</a></h2><div class=""/><div class=""><h2 id="a6ae" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">关于键盘监听器的5个案例研究</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/ad834674f968f0a1b1d596e9a5347b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*asIxYHG-XSwrnami"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">由<a class="ae li" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sigmund </a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="2e06" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">作为<a class="ae li" href="https://levelup.gitconnected.com/learning-velocity-and-coding-standards-10952f6c9640" rel="noopener ugc nofollow" target="_blank">开发人员</a>，我们喜欢在日常编码生活中使用键盘。与使用鼠标相比，它使事情变得更容易、更快捷。然而，在这份爱中，我们并不孤独；我们正在实现的应用程序的许多最终用户也喜欢这样做。设计一个更易访问的应用程序通常可以改善用户体验。这里唯一的问题是，对我们来说，知道如何使用键盘比知道如何通过按键盘上的一些键来实现一个可访问的功能要简单得多。</p><p id="9527" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">每当你添加一个事件监听器到你的代码中，你应该以一种优化的方式去做，以避免从用户的浏览器中吸取性能或者耗尽他们的小电池。</p><p id="9c48" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在今天的文章中，我将重点关注通过键盘事件或快捷键对用户做出反应。我将举五个在<a class="ae li" href="https://medium.com/better-programming/angular-10-new-features-dbc779061dc8" rel="noopener"> Angular app </a>中处理键盘监听器的真实例子。让我们开始吧。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="5b87" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated"><strong class="ak">案例研究1 </strong></h1><p id="319a" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">假设您的组件中有一个输入字段，并且您想在用户按F2时打开一个对话框。你可以用两种方法来做这件事。</p><h2 id="a079" class="nj mn iu bd mo nk nl dn ms nm nn dp mw ls no np my lw nq nr na ma ns nt nc ja bi translated"><strong class="ak">选项1 </strong></h2><p id="57b8" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">在您的HTML中添加<code class="fe nu nv nw nx b">(keydown.F2)</code>:</p><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="5393" class="nj mn iu nx b gz oc od l oe of">&lt;input matInput (keydown.F2)=”onF2KeyPress($event)”&gt;</span></pre><p id="b238" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以及TypeScript代码中的<code class="fe nu nv nw nx b">onF2KeyPress()</code>方法:</p><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="0e0d" class="nj mn iu nx b gz oc od l oe of">onF2KeyPress(event: KeyboardEvent) {<br/>    this.openOptionsDialog(…);<br/>}</span></pre><h2 id="0aaf" class="nj mn iu bd mo nk nl dn ms nm nn dp mw ls no np my lw nq nr na ma ns nt nc ja bi translated"><strong class="ak">选项二</strong></h2><p id="ff1d" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">只需在您的TypeScript代码中添加此方法:</p><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="f1c5" class="nj mn iu nx b gz oc od l oe of">@HostListener(‘keydown.F2’, [‘$event’])<br/>onF2KeyPress(event: KeyboardEvent) { <br/>    this.openOptionsDialog(…);<br/>}</span></pre><p id="a198" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">哪个选项更好？</p><p id="48b8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于第一个，我们有一个仅用于输入字段的<code class="fe nu nv nw nx b">keydown.F2</code>监听器。在第二个例子中，我们有一个用于整个组件的<code class="fe nu nv nw nx b">keydown.F2</code>监听器，每当按下F2键时就会被执行——即使焦点在输入字段之外。我个人更倾向于第一种选择。</p><h2 id="c190" class="nj mn iu bd mo nk nl dn ms nm nn dp mw ls no np my lw nq nr na ma ns nt nc ja bi translated"><strong class="ak">陷阱</strong></h2><p id="0efd" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">如果同时使用这两个选项:</p><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="6432" class="nj mn iu nx b gz oc od l oe of">(keydown.F2)=”onF2KeyPress($event)”</span></pre><p id="76d3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在输入字段和</p><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="caa5" class="nj mn iu nx b gz oc od l oe of">@HostListener(‘keydown.F2’, [‘$event’])</span></pre><p id="48cc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在方法<code class="fe nu nv nw nx b">onF2KeyPress()</code>上面，你的逻辑将被执行两次。在这种情况下，对话框将打开两次，您可能不会注意到它，直到您看到只有单击两次关闭按钮才能关闭对话框。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="dbee" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated"><strong class="ak">案例研究2 </strong></h1><p id="5ca1" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">假设您有一个<code class="fe nu nv nw nx b">formArray</code>，每当用户点击另一个<code class="fe nu nv nw nx b">formGroup</code>时，您需要保存之前编辑的<code class="fe nu nv nw nx b">formGroup</code>。为了实现这一目标，您创建了以下方法:</p><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="1a5c" class="nj mn iu nx b gz oc od l oe of">@HostListener(‘document:click’, [‘$event’])<br/>оnClick(event: KeyboardEvent) {<br/>    this.saveItem();<br/>}</span></pre><p id="9ac2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这里有什么问题？</p><p id="8726" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">该方法是整个文档(您面前的HTML视图)上的任何单击的侦听器，而不仅仅是表单区域中的单击的侦听器。如果用户从<code class="fe nu nv nw nx b">formArray</code>打开一个对话框并点击它，即使不需要<code class="fe nu nv nw nx b">onClick()</code>和<code class="fe nu nv nw nx b">this.saveItem()</code>方法也会被执行(因为用户仍在对话框中工作)。</p><p id="4a95" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果<code class="fe nu nv nw nx b">saveItem()</code>方法调用一些服务方法并发送一些REST API请求以在后端执行某些东西，这种情况可能会更糟。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="2622" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">案例研究3</h1><p id="26f0" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">假设您有一个带有一些字段的表单，用于输入一些搜索标准，并且您想为用户提供通过点击搜索按钮或按回车键来执行<code class="fe nu nv nw nx b">search()</code>方法的可能性。为了实现这一点，您实现了如下HTML代码:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="df6a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你的打字稿是:</p><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="9935" class="nj mn iu nx b gz oc od l oe of">search() {<br/>    this.service.search(this.form);<br/>}</span></pre><p id="f723" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你能猜出这里出了什么问题吗？</p><p id="3d4c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">有两个问题:</p><ul class=""><li id="c705" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me on oo op oq bi translated">首先，每当发出<code class="fe nu nv nw nx b">keyup</code>事件时(甚至当用户按Tab、shift、F3、…)都会执行<code class="fe nu nv nw nx b">search()</code>方法，而不仅仅是在按Enter键时。要解决这个问题，HTML代码中的第一行必须调整如下:</li></ul><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="2a71" class="nj mn iu nx b gz oc od l oe of">&lt;form name=”form” [formGroup]=”form” <strong class="nx je">(keyup.enter)=”search()”</strong>&gt;</span></pre><ul class=""><li id="c6de" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me on oo op oq bi translated">其次，您希望仅当表单有效且被触摸时才允许调用进行搜索。这可以通过禁用搜索按钮(<code class="fe nu nv nw nx b">[disabled]="form.invalid </code> || <code class="fe nu nv nw nx b">form.untouched"</code>)来正确实现，但在按下Enter后调用<code class="fe nu nv nw nx b">search()</code>会违反这一点。以下可能是此错误的解决方法:</li></ul><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="a9bd" class="nj mn iu nx b gz oc od l oe of">search() {<br/>    <strong class="nx je">if(this.form.valid &amp;&amp; this.form.touched) {</strong><br/>        this.service.search(this.form);<br/>    <strong class="nx je">}</strong>   <br/>}</span></pre></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="e0a6" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">案例研究4</h1><p id="e2ae" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">您已经实现了一个带有表单的对话框来创建或更新一些项目。输入数据后，用户可以单击save按钮或按Enter键向REST API发送保存请求。发送保存请求后，对话框应该会自动关闭。</p><p id="622b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你能猜到这是否会像预期的那样起作用吗？</p><p id="46ab" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">那么，如果表单包含一个下拉字段，而用户想要使用键盘从其中选择一个选项，该怎么办呢？</p><ol class=""><li id="2b10" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me or oo op oq bi translated">要打开下拉列表中的选项列表，用户在该字段中设置焦点后按Enter键。</li><li id="7139" class="oi oj iu ll b lm os lp ot ls ou lw ov ma ow me or oo op oq bi translated">然后，他们使用向下箭头/向上箭头导航到想要的选项。</li><li id="0c7e" class="oi oj iu ll b lm os lp ot ls ou lw ov ma ow me or oo op oq bi translated">然后他们按回车键选择该选项。</li></ol><p id="6c77" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当您的最终用户注意到每当他们按下回车键时，当他们想在关闭对话框之前继续编辑时，对话框消失了，他们会感到沮丧。</p><p id="641d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你如何解决这个问题？</p><p id="0908" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您可以使用另一个键盘监听器来调用<code class="fe nu nv nw nx b">save()</code>方法。<code class="fe nu nv nw nx b">control.s</code>可能是另一种选择:</p><pre class="kt ku kv kw gu ny nx nz oa aw ob bi"><span id="a698" class="nj mn iu nx b gz oc od l oe of">@HostListener(‘keydown.control.s’, [‘$event’])<br/>оnKeyDown(event: KeyboardEvent) {<br/>    this.save();<br/>}</span></pre></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="47e1" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">案例研究5</h1><p id="887f" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">在您的web应用程序中，有一个带有多个操作按钮的视图，应该可以通过键盘访问。对于每个动作按钮，您都添加了不同的快捷方式监听器:<code class="fe nu nv nw nx b">alt+e</code>、<code class="fe nu nv nw nx b">alt+r</code>、<code class="fe nu nv nw nx b">alt+o</code>等。</p><p id="e888" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这个解决方案有什么问题？</p><p id="f9e5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">最终用户可能有不同的设备。这些快捷方式对Mac用户来说没有用。作为一种解决方案，您可以为这些快捷键添加监听器:<code class="fe nu nv nw nx b">cmd+e</code>、<code class="fe nu nv nw nx b">cmd+r</code>、<code class="fe nu nv nw nx b">cmd+o</code>等。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="654a" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">外卖食品</h1><p id="d245" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">让我们总结一下我们刚刚学到的内容:</p><ul class=""><li id="28a3" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me on oo op oq bi translated">限制并指定必须监听某些键盘事件的区域。</li><li id="d58f" class="oi oj iu ll b lm os lp ot ls ou lw ov ma ow me on oo op oq bi translated">深思熟虑地选择你的<a class="ae li" href="https://medium.com/javascript-in-plain-english/angular-material-table-with-edit-function-like-excel-7c2c53332553" rel="noopener">键盘监听器</a>，并尝试想象它们可能的副作用以及它们不起作用的情况。</li><li id="9182" class="oi oj iu ll b lm os lp ot ls ou lw ov ma ow me on oo op oq bi translated">不要忘记，您的最终用户有不同的设备。当您添加键盘快捷键时，它们必须对所有可能的最终用户(PC、Mac等)有用。</li></ul><p id="5596" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">感谢阅读。如果您有任何问题，请随时发表评论。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="2d54" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的免费电子邮件简讯，独家获取</strong> </a> <strong class="ll je"> </strong>或在此注册Medium <a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener">。</a></p><p id="bc25" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="ox">你可以在Udemy上查看我的</em> <strong class="ll je"> <em class="ox">视频课程</em></strong><em class="ox">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="ox">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="ox">。</em></p></div></div>    
</body>
</html>