<html>
<head>
<title>How Sendable Can Help Prevent Data Races in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sendable如何帮助防止iOS中的数据竞争</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-sendable-can-help-prevent-data-races-in-ios-85887497c3b4?source=collection_archive---------8-----------------------#2021-10-07">https://betterprogramming.pub/how-sendable-can-help-prevent-data-races-in-ios-85887497c3b4?source=collection_archive---------8-----------------------#2021-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b68a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速浏览一下可发送协议</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e29f34e7ddd50ef8bd94eace3e43196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gA5wKx4Rqto-nwxI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@epicantus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Daria Nepriakhina </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="8ee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的<a class="ae ky" href="https://swiftsenpai.com/swift/actor-prevent-data-race/" rel="noopener ugc nofollow" target="_blank">文章</a>中，您了解到了参与者可以通过确保其可变状态的互斥来帮助我们防止数据竞争。只要我们在访问参与者内部的可变状态，这个陈述就是正确的。如果可变状态可以在参与者之外访问，数据竞争仍然会发生！</p><p id="6369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，让我们探索这种数据竞争是如何发生的，以及<code class="fe lv lw lx ly b">Sendable</code>协议如何帮助防止这种情况。除此之外，我们还将看看苹果公司将为<code class="fe lv lw lx ly b">Sendable</code>带来的未来改进，以应对这种情况。</p><p id="7cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，事不宜迟，我们开始吧！</p><h1 id="61a1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">将数据传递给参与者时会出现数据竞争</h1><p id="2a7e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">假设我们有一个<code class="fe lv lw lx ly b">Article</code>类，它有一个<code class="fe lv lw lx ly b">likeCount</code>变量来记录文章从读者那里获得的点赞数。下面是起始代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f25d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有一个<code class="fe lv lw lx ly b">ArticleManager</code>演员，负责管理一系列文章:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe lv lw lx ly b">ArticleManager</code> actor有一个增加特定文章的<code class="fe lv lw lx ly b">likeCount</code>的<code class="fe lv lw lx ly b">like(_:)</code>函数，和一个根据给定文章标题返回文章的<code class="fe lv lw lx ly b">getArticle(with:)</code>函数。</p><p id="867b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe lv lw lx ly b">getArticle(with:)</code>函数的存在，<code class="fe lv lw lx ly b">ArticleManager</code>的文章现在可以在actor之外访问。换句话说，参与者的可变状态现在可以在参与者之外更新，从而产生了潜在的数据竞争。</p><p id="85fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，考虑以下位于actor外部的<code class="fe lv lw lx ly b">dislike(_:)</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们现在正在减少(改变)actor之外的文章点赞数，如果我们试图同时运行actor的<code class="fe lv lw lx ly b">like(_:)</code>和上面的<code class="fe lv lw lx ly b">dislike(_:)</code>函数，就会发生数据竞争！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们创建了3000个子任务来喜欢一篇文章，同时创建了1000个子任务来不喜欢同一篇文章。最后，即使我们能够得到输出“<code class="fe lv lw lx ly b">👍🏻 Like count: 2000</code>”，Xcode thread sanitizer仍然会显示一个线程问题，表明数据竞争确实发生了。</p><h2 id="43a3" class="my ma it bd mb mz na dn mf nb nc dp mj li nd ne ml lm nf ng mn lq nh ni mp nj bi translated">专业提示:</h2><p id="40a7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">您可以通过导航到产品&gt;方案&gt;编辑方案…来启用线程杀毒器。然后，在编辑方案对话框中选择运行&gt;诊断&gt;选中线程杀毒器复选框。</p><p id="6241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然您已经看到了在角色之外改变角色状态会导致数据竞争，那么我们该如何防止这种情况发生呢？</p><h1 id="4c2f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">通过添加一致性检查可发送性</h1><p id="0ce8" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">Sendable</code>是Swift 5.5中与async/await和actors一起引入的新协议。一个<code class="fe lv lw lx ly b">Sendable</code>类型的人的价值观可以被不同的角色分享。如果我们将一个值从一个地方复制到另一个地方，并且两个地方都可以安全地修改该值的副本，而不会互相干扰，那么该类型被认为是一个<code class="fe lv lw lx ly b">Sendable</code>类型。要了解更多，你可以看看这个<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10133/?time=1112" rel="noopener ugc nofollow" target="_blank"> WWDC视频</a>。</p><p id="0c9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的示例代码，为了避免在<code class="fe lv lw lx ly b">ArticleManager</code>之外对文章进行变异时出现数据竞争，我们必须使<code class="fe lv lw lx ly b">Article</code>类型符合<code class="fe lv lw lx ly b">Sendable</code>协议。让我们用下面的代码来做这件事:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="db97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个阶段，编译器将开始抱怨“<em class="nk">‘Sendable’的存储属性‘like count’——符合类‘Article’是可变的。”</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/41fc83c885664ae26a61e8075697eb09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Eb53K0SXtO8C_1xK"/></div></div></figure><p id="db6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个错误意味着如果我们想让<code class="fe lv lw lx ly b">Article</code>类型成为<code class="fe lv lw lx ly b">Sendable</code>，我们就不能有一个可变的存储属性(<code class="fe lv lw lx ly b">likeCount</code>)。这是因为与可变的存储属性同时共享引用类型是不安全的，它会产生潜在的数据竞争。</p><p id="37a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的例子，我们肯定不能使<code class="fe lv lw lx ly b">likeCount</code>为常数，那么我们还有什么其他选择呢？根据苹果公司的说法，有许多不同种类的类型可以发送。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/e110863ae9d2c2dd81165af8b52a1cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RmE6cTb9q_PpAGgz"/></div></div></figure><p id="facc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的一个选择是将<code class="fe lv lw lx ly b">Article</code>改为值类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，<code class="fe lv lw lx ly b">Article</code>结构没有给我们任何编译器错误，但是我们在示例代码的其他地方得到了多个编译器错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/854b0b4633e1ffa686769dc1f6fee52b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TvZOgfa5pXLsVYHa"/></div></div></figure><p id="e86e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复所有这些编译器错误确实需要大量的代码修改，但这肯定是可行的。因此，我将把这作为一个练习留给你。如果你确实遇到了困难，可以在这里找到解决方案<a class="ae ky" href="https://github.com/LeeKahSeng/SwiftSenpai-Swift-Concurrency/blob/main/SwiftSenpai-Swift-Concurrency/Sendable%20Demo/SendableDemoViewController.swift" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="20bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的例子可以看出，符合<code class="fe lv lw lx ly b">Sendable</code>协议并不会自动使一种数据类型可发送。然而，它确实执行了我们需要遵守的规则，以便不意外地产生潜在的数据竞争。因此，下一次当您处理actors时，请确保所有可共享的可变状态都符合<code class="fe lv lw lx ly b">Sendable</code>协议。</p><h1 id="6f74" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">预期的未来改进</h1><p id="5bb3" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在WWDC，苹果提到，在未来，Swift编译器将阻止我们共享不可发送的类型。如果我们试图访问一个actor不可发送状态，我们将得到如下所示的编译器错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/13d420ff7da1cc0662ce9ca711a0d949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xLTIx9CPlF78gUSW"/></div></div></figure><p id="7a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">截至Swift 5.5，这种检查仍然不可用，苹果公司也没有关于这种检查何时可用的信息。现在，我们能做的最好的事情是，每当一个actor中有可共享的类型时，注意并始终遵守<code class="fe lv lw lx ly b">Sendable</code>协议。</p><h1 id="f669" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">包扎</h1><p id="bfdd" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在我们的<code class="fe lv lw lx ly b">ArticleManager</code>例子中，防止数据竞争的最好方法无疑是将整个<code class="fe lv lw lx ly b">dislike(_:)</code>函数移到<code class="fe lv lw lx ly b">ArticleManager</code>中。出于演示的目的，我特意使用了<code class="fe lv lw lx ly b">Sendable</code>方法，以便您可以更好地理解<code class="fe lv lw lx ly b">Sendable</code>协议如何帮助防止参与者之外的数据竞争。</p><p id="94b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在撰写本文时，Swift工程团队仍在积极改进<code class="fe lv lw lx ly b">Sendable</code>检查。如果您有任何想要分享的观点或想法，请务必在<a class="ae ky" href="https://forums.swift.org/t/improving-sendable/52377" rel="noopener ugc nofollow" target="_blank"> Swift论坛</a>上联系他们。</p><p id="1176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，您可以在这里获得完整的示例代码<a class="ae ky" href="https://github.com/LeeKahSeng/SwiftSenpai-Swift-Concurrency" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="e364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。更多关于iOS开发和Swift的文章，欢迎在<a class="ae ky" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank"> Twitter </a>关注我。</p></div></div>    
</body>
</html>