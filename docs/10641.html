<html>
<head>
<title>Using In-Memory Databases in Windows — SQL Query Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Windows中使用内存数据库— SQL查询缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-in-memory-databases-in-windows-sql-query-caching-3887060268a4?source=collection_archive---------18-----------------------#2022-01-19">https://betterprogramming.pub/using-in-memory-databases-in-windows-sql-query-caching-3887060268a4?source=collection_archive---------18-----------------------#2022-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ff6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">查询缓存听起来像是一个简单的用例，但它并不简单，尤其是如果您在Windows上进行查询缓存</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a7b45ea5a54525bd5a33164686cc3e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXn4-057kTa2fyfnDmFw7Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塔达斯·萨尔在<a class="ae ky" href="https://unsplash.com/s/photos/windows?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="99aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到web性能，缓存是所有改进活动的基础。保留已经计算过的信息以避免再次计算，这是解决大多数性能问题的一种简单而又非常有效的方法。<br/>对于web应用程序来说，最简单、最直观的解决方案是缓存整个服务器的响应，这样每当用户发出相同的请求时，服务器就已经计算好了所有的内容。</p><p id="dcf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于动态信息很少的简单页面来说，这是可行的。但是考虑一个有多个小部件的仪表板，每个小部件都相互独立，你如何确保对于每个请求，所有这些小部件的相同信息仍然有效？</p><p id="383f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5032" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">SQL查询缓存</h1><p id="8972" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">问题的解决方案不是停止缓存，而是缓存正确的数据。对于完全由动态数据组成的网页，单个缓存没有什么意义，但是，保存单个结果并并行缓存它们可能是您需要的解决方案。</p><p id="1d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种解决方案会导致每次这些小部件发生变化时，您都必须使缓存无效，这可能会导致缓存总是无效，从而使其变得无用。第二个选项可以缓存变化较小的窗口小部件，同时，更新那些经常变化的窗口小部件。</p><h2 id="1214" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">Redis的查询缓存</h2><p id="d8dd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">缓存需要的第一件事是拥有快速I/O，考虑到它需要避免变成性能瓶颈，而不是帮助解决您看到的实际问题。</p><p id="952c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的缓存的第二个方面是它能够在数据不再有效时立即使其失效。这可能很难通过代码实现。这意味着您必须知道每个不同的数据集何时不再有效，并且每次查询它时，您的逻辑都需要检查它是否仍然有效。</p><p id="28ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但Redis可以解决所有这些问题，并提供许多其他开箱即用的额外功能。这就是为什么Redis是整个行业使用的主要缓存解决方案之一。</p><ul class=""><li id="657b" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><strong class="lb iu"> Redis快</strong>。Redis是一种内存存储，能够在平均不到10毫秒的时间内处理读写操作。这是因为不需要处理磁盘I/O(这往往会增加很大的延迟)。</li><li id="281c" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu"> Redis可以自动使缓存失效</strong>。Redis自己的TTL特性允许您在所有缓存记录上设置一个可重置的过期日期。这意味着，只要您需要它，或者只要您不断更新它，缓存将是可访问的，如果它有一段时间没有更新，或者可能使用得不够频繁，内存将被释放，您的缓存将不得不重新创建。</li><li id="cd55" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">当缓存不再有效时，Redis可以通知您</strong>。扩展了传统缓存的需求，您可以在由于缺少更新而需要删除缓存之前对其进行被动更新。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/533322b1560807e915f2ee96fb1b69dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Me-1Y7_yVxWCDp8s.png"/></div></div></figure><p id="6b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看上面的图表，顶部显示了一个普通用户使用的标准web应用程序。一次单击产生一个请求，该请求转化为一个SQL查询。对于这个例子，这只是一个查询，但是考虑一下这怎么可能是两个甚至十个查询。<br/>下一节显示的是同一个用户处理一个已经在后台实现了查询缓存的应用程序。是的，体系结构更复杂，如果仔细想想，流程非常简单:</p><ol class=""><li id="20c2" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu ob ns nt nu bi translated">对于我们需要执行的每个查询，首先检查它是否已经被缓存。</li><li id="6c62" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">如果是，使用那些结果。</li><li id="5924" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">如果不是，那么查询数据库。</li></ol><p id="64f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照这种逻辑，如果我们执行第3步，我们可能会将结果存储在缓存中。<br/>如果缓存存在，但它突然过期，我们可以选择被动更新它，而不必等待用户下一次触发查询(通过使用与专用于此目的的并行进程混合的键空间通知)。</p><p id="84ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，Redis是满足您缓存需求的完美解决方案，而且由于它支持多种数据类型，在其中存储结果非常容易。<br/>如果你有简单的结果需要缓存(比如单个记录),你可以将它们作为一个字符串存储在Redis的一个键中。<br/>然而，如果您有更复杂的记录，您可以利用Redis散列在其中存储复杂的数据结构。</p><h2 id="548a" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">如何在Redis中缓存SQL查询结果？</h2><p id="5c65" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当决定在Redis上缓存查询结果的策略时，您必须考虑两个主要细节:</p><p id="46c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确命名你的钥匙。因为它们将在一个巨大的内存哈希表中充当缓存数据的ID。这意味着您必须始终避免命名冲突。一种可能的选择是对实际的查询字符串执行散列操作。如果每次查询都是自动生成的，那么无论客户端发送查询，您的哈希代码都有可能为同一个查询提供正确的值。如果字符串可以变化，您可能希望解析它并基于解析的数据生成散列。如果<code class="fe oc od oe of b">WHERE</code>子句中的参数顺序不同，那么一旦提取出来，您可以按照您认为合适的方式重新排列它们。</p><p id="b867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，以下查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="46cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成一个MD5散列如下:<code class="fe oc od oe of b">b88b231e77449e3cd97f71b07695b8dd</code> <br/>然后你可以创建一个名为<code class="fe oc od oe of b">query-cache:b88b231e77449e3cd97f71b07695b8dd</code>的密钥，并用它来存储你的数据。<br/>例如，结果可以存储在这个具有24小时TTL的键中。这意味着，如果您不做任何其他事情，这个缓存将在24小时内过期，一旦过期，您可以决定是自己自动填充它，还是在下次需要查询时让逻辑缓存它。<br/>事实上，您也可以在每次向表中添加新用户时从不同的进程更新缓存。通过更新现有的密钥，TTL被重置，因此您可以继续使用它，而不用担心数据过时。</p><p id="e92f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> #2你将如何存储数据</strong> <br/>足够简单的记录可以序列化并作为字符串存储在你的缓存键中。毕竟，这些信息在Redis中既不会被使用，也不会被查询。因此，存储格式并不真正相关，相反，这里的主要好处是您能够比通常使用SQL查询更快地获得结果。<br/>然后字符串可以被解析并转换成您的代码需要的任何数据类型。</p><p id="a769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将序列化的数据保存到Redis中的一个键中，并将TTL设置为24小时，就像下面这样简单:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="bea4" class="na me it of b gy om on l oo op">SET query-cache:b88b231e77449e3cd97f71b07695b8dd 'a:1:{s:7:"results";a:2:{i:0;a:3:{s:4:"name";s:15:"Fernando Doglio";s:9:"birthdate";s:10:"2014-10-24";s:7:"address";s:13:"Madrid, Spain";}i:1;a:3:{s:4:"name";s:8:"John Doe";s:9:"birthdate";s:10:"2020-10-24";s:7:"address";s:13:"New York, USA";}}}' EX 86400</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="81db" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">架构中的数据库查询缓存</h1><p id="5b69" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在现有架构中实现这种缓存解决方案的方法是将数据库访问抽象到一个单独的层中。<br/>这可以采用单个类、一个模块甚至一个完整微服务的形式。重点是避免直接从业务逻辑中使用数据库驱动程序。这样，您可以为每个查询添加代码，以便:</p><ol class=""><li id="1fea" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu ob ns nt nu bi translated">捕获查询并为其计算MD5散列。</li><li id="fd43" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">查询Redis以查找现有缓存。</li><li id="59c4" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">如果匹配，使用这些结果，解析它们并返回到您的逻辑中。</li><li id="5141" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">如果不匹配，直接查询数据库，用24小时TTL缓存结果，然后将记录返回到您的逻辑。</li></ol><p id="933c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是用Redis实现SQL查询缓存解决方案的全部内容。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5339" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">在Windows中实现SQL查询缓存</h1><p id="0aa3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">虽然Redis是可靠和高性能缓存解决方案的完美解决方案，但让它在Windows上正常工作可能具有挑战性。这就是为什么<a class="ae ky" href="https://www.memurai.com/" rel="noopener ugc nofollow" target="_blank"> Memurai </a>作为一个兼容Redis的Windows原生解决方案是完美的选择。它和原来的一样可靠，性能也一样好(在某些情况下甚至更快)。</p><p id="c5e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了<a class="ae ky" href="https://www.memurai.com/" rel="noopener ugc nofollow" target="_blank"> Memurai </a>你就可以构建你的解决方案了，因为它与Redis API完全兼容，任何编程语言上已经支持它的任何库都将完美地完成这项任务。</p></div></div>    
</body>
</html>