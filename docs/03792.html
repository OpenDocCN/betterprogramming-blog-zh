<html>
<head>
<title>Stop Using Python Decorators Redundantly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止多余地使用Python装饰器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-python-decorators-redundantly-2f8467c9eeca?source=collection_archive---------15-----------------------#2020-03-04">https://betterprogramming.pub/stop-using-python-decorators-redundantly-2f8467c9eeca?source=collection_archive---------15-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d3d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在父类的每个子类函数上设置装饰器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/beb82e89c98ba5855ff183ec8ac74aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrII8wPx3atAf6KjQH36RQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kimberlyfarmer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">金伯利农民</a>在<a class="ae ky" href="https://unsplash.com/s/photos/class?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="1d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">decorators</code>是Python中强大而有用的工具之一，因为它们允许我们修改类或函数的行为。装饰者通常将一个函数作为参数，并在另一个函数内部调用它，这通常被称为<code class="fe lv lw lx ly b">wrapper</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰器的用法示例</p></figure><p id="f2fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面定义的<code class="fe lv lw lx ly b">input_args</code>函数用于打印参数并返回被调用函数的输出。</p><p id="1de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们需要调用一个类的每一个函数，这可能会产生冗余，如下面的代码片段所述。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多余的装饰用法</p></figure><p id="8ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种冗余，我们可以使用Python的<code class="fe lv lw lx ly b">MetaClass</code>提供给我们的另一个强大的工具。这个<code class="fe lv lw lx ly b">MetaClass</code>将帮助我们修改子类的函数定义，这将减少对装饰函数的冗余调用。</p><p id="caac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">元类用法</p></figure><p id="3d93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe lv lw lx ly b">Parent</code>类将具有将我们的<code class="fe lv lw lx ly b">decorator</code>设置为基类的所有函数的逻辑。</p><p id="35ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的最终脚本将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含元类用法的最终脚本</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/26bc01b5908b2107554b2fd84f1d62cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*LlSCfvWuM3db8k2lLCC1yA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">元类使用的输出</p></figure><p id="674e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">MetaClass Parent</code> <strong class="lb iu"> </strong>现在是我们的武器，可以在任何我们希望使用装饰器的职业中被继承。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3326" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="e010" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我希望这个解释有用。你对<code class="fe lv lw lx ly b">metaclass</code>的用法有什么想法？你认为还有其他更简单或更好的语法吗？下面分享一下你的想法和经验吧！</p></div></div>    
</body>
</html>