<html>
<head>
<title>How To Use Kotlin’s Built-In Functions To Measure Code Execution Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Kotlin的内置函数来测量代码执行时间</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-kotlins-built-in-functions-to-measure-code-execution-time-1759b2ac90aa?source=collection_archive---------5-----------------------#2022-08-25">https://betterprogramming.pub/how-to-use-kotlins-built-in-functions-to-measure-code-execution-time-1759b2ac90aa?source=collection_archive---------5-----------------------#2022-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec8b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">调查性能问题或找出最佳实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e2126a4c5c26e1ab57588db977fab23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJV3fz5P5BAIo0ExF9oI3g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马克·赖歇尔在<a class="ae ky" href="https://unsplash.com/s/photos/kotlin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kotlin提供了测量执行时间的简单方法。这在很多地方都会派上用场。你可以用它来比较算法或者检查你的代码哪个部分慢。</p><p id="2be1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先看看测量执行时间的经典(Java风格)方法。只有这样，我们才能体会到科特林的好处。</p><p id="da0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为示例，我们比较了<code class="fe lv lw lx ly b">ArrayList</code>和<code class="fe lv lw lx ly b">LinkedList</code>的性能。我们测量5000万个整数相加，然后求和所需的时间。查看<a class="ae ky" href="https://gist.github.com/ablx/586d701a839b821253244c5d81cb36e4" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的代码。</p><h1 id="7956" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">经典的Java风格的方式</h1><p id="d1e7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果您使用Java已经有一段时间了，您可能会看到类似这样的内容(显然，这是在Java中，而不是在Kotlin中)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="213c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法工作得很好，但是也有缺点。</p><p id="6d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们必须将结果从纳秒转换为秒。其次，我们需要引入一两个变量和一长串代码来得到我们的结果。</p><p id="de0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要测量同一方法的不同部分，这可能会变得混乱。很容易发生的情况是，你用错误的变量计算差异。</p><p id="6f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很容易看出有一个简单的解决方案:提取一个测量时间的方法。但是我们为什么要重新发明轮子呢？</p><h1 id="1992" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">科特林测量时间的方法</h1><h2 id="4ee6" class="my ma it bd mb mz na dn mf nb nc dp mj li nd ne ml lm nf ng mn lq nh ni mp nj bi translated">measureTimeNanos和measureTimeMillis</h2><p id="171c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Kotlin中最简单的方法是使用来自<code class="fe lv lw lx ly b">kotlin.time</code>的<code class="fe lv lw lx ly b">measureTimeNanos</code>和<code class="fe lv lw lx ly b">measureTimeMillis </code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="efdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看看引擎盖下面，这些功能与你在上面看到的一样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="82f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法返回执行时间，所以我们不需要手动计算它们。但是，我们仍然需要手动转换单位。有一个很大的警告！你不能得到被测函数的返回值。</p><p id="9033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用的另一个方法是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/measure-time.html" rel="noopener ugc nofollow" target="_blank">measureTime</a>. </code>返回一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/" rel="noopener ugc nofollow" target="_blank">Duration</a></code> <a class="ae ky" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/" rel="noopener ugc nofollow" target="_blank">对象</a>。<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/" rel="noopener ugc nofollow" target="_blank">Duration</a></code>为您提供将持续时间转换成您想要的时间单位的方法。但是，返回值仍然会丢失:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="49ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，还有更好的解决方案。</p><h1 id="d2cb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">两全其美:测量时间价值</h1><p id="17f7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">到目前为止，我可以得到简洁的语法，但没有返回值或返回值和臃肿的语法。幸运的是，有一个两全其美的方法:<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/measure-timed-value.html" rel="noopener ugc nofollow" target="_blank">measureTimedValue</a></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bc06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以进一步使用另一个很酷的Kotlin特性，即析构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b6c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使您能够在代码中加入时间度量。用<code class="fe lv lw lx ly b">measureTimedValue</code>把它包起来，用Kotlin的<a class="ae ky" href="https://kotlinlang.org/docs/destructuring-declarations.html" rel="noopener ugc nofollow" target="_blank">析构</a>就可以一气呵成的得到时长和代码结果。</p><p id="0791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看看GitHub上的代码，你可能会注意到注释<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-experimental-time/" rel="noopener ugc nofollow" target="_blank">@OptIn(ExperimentalTime::class)</a></code>。我们需要这个，因为JetBrains将更先进的时间测量方法标记为实验性的。这些方法将来可能会改变它们的行为或语法。你需要记住这一点。无论如何，我不建议在产品代码中长期使用这些方法。</p><h1 id="f4d4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="b56d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在Kotlin中测量执行时间非常容易。您可以根据需要插入它，而不会因为不明确的变量而污染您的范围。</p><p id="032a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些有用的链接:</p><ul class=""><li id="75dc" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><a class="ae ky" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/" rel="noopener ugc nofollow" target="_blank"> kotlin.time API文档</a></li><li id="c369" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><a class="ae ky" href="https://kotlinlang.org/docs/destructuring-declarations.html" rel="noopener ugc nofollow" target="_blank">科特林的破坏</a></li><li id="9d70" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">在<a class="ae ky" href="https://gist.github.com/ablx/586d701a839b821253244c5d81cb36e4" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上完成代码。</li></ul><p id="d812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的宝贵时间！</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="7a71" class="my ma it ly b gy oj ok l ol om"><strong class="ly iu">Want to Connect?</strong></span><span id="c4f0" class="my ma it ly b gy on ok l ol om">Subscribe to my newsletter so you never miss a new post:<br/><a class="ae ky" href="https://verbosemode.dev/subscribe" rel="noopener ugc nofollow" target="_blank">https://verbosemode.dev/subscribe</a></span></pre></div></div>    
</body>
</html>