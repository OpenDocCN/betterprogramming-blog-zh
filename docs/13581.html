<html>
<head>
<title>Automate a Pinball Machine Using Computer Vision</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用计算机视觉自动化弹球机</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-ai-to-automate-a-pinball-machine-ef5721141f03?source=collection_archive---------7-----------------------#2022-09-08">https://betterprogramming.pub/using-ai-to-automate-a-pinball-machine-ef5721141f03?source=collection_archive---------7-----------------------#2022-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3f8c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用人工智能玩弹球</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4b51beb6f79d5780e18cf0656e73e6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5F16016FY2Rxwkyc"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">希瑟·麦肯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ca26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们高中的最后一年，我和我的同学们试图自动化坐在物理老师教室里的一台古董弹球机。</p><p id="44b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以前曾使用过一种简单的方法，用激光探测球，并根据需要发射脚蹼。然而，我们想在人工智能的帮助下更上一层楼。考虑到这一点，有两个主要的挑战需要解决:能够检测弹球和基于弹球检测做出决策。</p><h1 id="7c3a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可视化表格</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/0c5165e1b20d159b2e70975a574a2c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NcfIpQyRgrXHLWL8.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弹球桌计算机视觉设置图</p></figure><p id="effd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用安装在弹球桌顶部的摄像机以每秒60帧的速度拍摄整个操场。这有一些问题——很难将捕捉视野限制在桌子本身，相机的轻微移动会移动帧中的整个操场，桌子是倾斜的，这捕捉了一个非矩形的操场。</p><p id="c738" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们选择通过软件来解决所有这些问题，而不是为相机装备创建一个更强大的硬件解决方案。</p><h1 id="abf5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">检测和裁剪运动场</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/946ad44cb3fb3a1f41b006f3858cdf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*URAXM0DSEa3wNSSx.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">左图:用绿色圆圈突出显示我们添加的磁带的原始帧。右:已处理的帧</p></figure><p id="d15a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">借助OpenCV的强大功能，我们可以随心所欲地操纵摄像机捕捉的内容。</p><p id="39fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想出了在操场的四个角落放置对比色胶带的主意，用作剪切摄像机捕捉的锚。</p><p id="6e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每一帧，我们在对磁带的蓝色和黄色应用HSV颜色阈值遮罩后运行OpenCV的轮廓检测。从返回的轮廓中，我们过滤出具有四条边(矩形)和一个指定间隔内的区域的形状。我们用OpenCV检测这些角点的实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将原始捕捉转换和裁剪为仅具有矩形运动场的帧</p></figure><p id="d392" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个，我们就有了检测弹球的基础，而没有桌子周围的所有视觉噪声，并且更少依赖于相机的位置。如果四个角带片段在帧中，运动场将被处理以占据整个帧。</p><p id="8d87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于项目的决策部分尤其重要，因为决策模型将依赖于来自检测算法的球的位置。如果没有锚点，当摄像机移动时，球的位置将来自不同的参考点。训练决策模型将依赖于来自相同参考点的所有位置数据。</p><p id="31cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本系列的下一部分，我将介绍我们如何在如此丰富多彩和嘈杂的环境中检测弹球。</p><h1 id="64c1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">弹球检测的头脑风暴法</h1><p id="64b2" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们首先想到的是尝试一种机器学习策略，通过卷积神经网络运行每一帧来检测弹球的位置；然而，在尝试这种方法时，我们意识到了两个问题——计算成本很高，我们需要大量的劳动来标记数据以训练模型。</p><p id="4d69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们开始研究一种非机器学习的方法。幸运的是，OpenCV实现了非常强大的计算机视觉算法，比机器学习算法的计算效率更高。在做了图像预处理(模糊、HSV阈值处理和转换成二进制图像)后，我们使用OpenCV的<code class="fe mt mu mv mw b">cv2.findContours(...)</code>函数。这个函数使用铃木智和安倍昭惠在论文中提出的算法，可以在这里找到<a class="ae kv" href="https://doi.org/10.1016/0734-189X(85)90016-7" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl mx"><img src="../Images/8526340155f81b38afc4e25704bc5f29.png" data-original-src="https://miro.medium.com/v2/format:webp/0*a1LJ5IKGVddrSNB7.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">1)高斯模糊帧2) HSV阈值帧，3)检测到的轮廓4)红色球轮廓</p></figure><p id="e406" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在检测到的许多轮廓中，我们根据面积间隔、最大周长和最大边数对它们进行过滤。有了这个，我们可以在没有任何东西阻挡摄像机视线的情况下很好地探测到球。</p><p id="bf64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到球的<code class="fe mt mu mv mw b">x</code>和<code class="fe mt mu mv mw b">y</code>坐标的最后一步是得到我们轮廓的“质心”。这非常简单，这要感谢OpenCV对<code class="fe mt mu mv mw b">cv2.moments(...)</code>的实现。你可以用下面的代码得到<code class="fe mt mu mv mw b">x</code>和<code class="fe mt mu mv mw b">y</code>质心坐标:</p><pre class="kg kh ki kj gt my mw mz na aw nb bi"><span id="244f" class="nc lt iq mw b gy nd ne l nf ng">m = cv2.moments(c)  # given that c is the contour of the ball<br/>               <br/>x = int(m['m10'] / m['m00'])                <br/>y = int(m['m01'] / m['m00'])</span></pre><h1 id="d452" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">GitHub知识库</h1><div class="nh ni gp gr nj nk"><a href="https://github.com/automation-club/autonomous-pinball-backend" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">GitHub-automation-club/autonomy-pinball-back end:后端解决方案的代码库…</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kp nk"/></div></div></a></div></div></div>    
</body>
</html>