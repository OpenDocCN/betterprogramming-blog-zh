<html>
<head>
<title>Implementing Clean MVVM With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI实施清洁MVVM</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-clean-mvvm-with-swiftui-10c52d503d67?source=collection_archive---------1-----------------------#2021-09-22">https://betterprogramming.pub/implementing-clean-mvvm-with-swiftui-10c52d503d67?source=collection_archive---------1-----------------------#2021-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d508" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在SwiftUI中正确使用MVVM模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d340450fd6a15211ed8e40b2b4818184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b2k3YUvjnsdz1gEZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢卡·米凯利在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个话题有许许多多的教程。然而，我找不到任何东西能清楚地解释如何处理现实应用中可能发生的复杂情况。</p><p id="355c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我能找到的所有例子都是基本的:它们从一个简单的视图开始，在那里放置一些由视图模型获取的数据。视图使用<code class="fe lv lw lx ly b">@StateObject</code>或<code class="fe lv lw lx ly b">@ObservedObject</code>变量来保持视图模型的活性。仅此而已。</p><p id="0bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界的应用程序中，我们有需要适当编排的依赖关系和逻辑片段。我们有需要传递绑定的子视图。这些问题在我找到的文章中都没有得到恰当的描述。</p><p id="f3ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我想更深入地探讨这个架构问题，并帮助大家使用MVVM和SwiftUI更进一步。</p><h1 id="b246" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">该应用程序</h1><p id="dff0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们将建立一个应用程序的通知设置。该应用程序让用户控制他们是否希望在本地通知。然后，应用程序会显示何时向用户显示提醒。只有当我们有权从系统和应用程序本身安排通知时，才会显示选择日期的选择器。</p><p id="5ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<code class="fe lv lw lx ly b">Reminder at</code>，用户可以更新通知的预定时间。</p><p id="703b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给人一种应用真实的感觉，我们将把设置屏幕嵌入到一个带有Hello World主屏幕的<code class="fe lv lw lx ly b">TabView</code>中。</p><p id="931e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是预期的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8d532d704ffb74ca9c057651015ca368.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*INpXJdL-WILcPb99DHa3zA.gif"/></div></figure><p id="f408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了构建这个应用程序，我们需要实现一些组件。我将分享所有的代码，浏览文章，并在结论中加上最终的项目。</p><p id="c071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将尽量只关注对架构真正重要的部分，跳过所有细节，比如依赖注入、如何请求推送通知权限等等。</p><h2 id="20f0" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated">模型</h2><p id="31a0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在开发一个app的时候，我们应该从思考数据模型开始。我们想向用户展示什么？我们的应用程序需要什么才能正常工作？</p><p id="07e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们需要一个<code class="fe lv lw lx ly b">NotificationSettings</code>结构来存放我们需要的所有信息。在代码中，它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一些信息:</p><ul class=""><li id="f8ca" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><code class="fe lv lw lx ly b">notificationEnabledByUser</code>布尔值，用于跟踪当前内部用户偏好</li><li id="7a9d" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe lv lw lx ly b">remindAt</code> date属性，用于跟踪应用程序应该何时安排通知</li></ul><p id="bb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">struct是<code class="fe lv lw lx ly b">Codable</code>，这样我们可以存储用户的偏好。注意，所有的属性都是<code class="fe lv lw lx ly b">var</code>:用户可以在应用程序生命周期中修改它们，我们想要持久化它们。</p><h2 id="6ccf" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated">视图模型</h2><p id="3ed1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">第二步是考虑如何转换数据模型，以便视图可以轻松地使用它。</p><p id="d7cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢通过理解我们需要多少个状态来呈现我们的UI来思考这个过程。在我们的示例中，我们有:</p><ol class=""><li id="a500" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nz nr ns nt bi translated"><strong class="lb iu">授权未确定</strong>:我们需要显示一个请求授权的按钮，通知切换被禁用，并且没有日期选择器。</li><li id="2fc8" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nz nr ns nt bi translated"><strong class="lb iu">授权并启用通知</strong>:我们显示当前状态，开关打开，我们显示日期选择器。</li><li id="a8b8" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nz nr ns nt bi translated"><strong class="lb iu">授权和通知禁用</strong>:我们显示当前状态，开关关闭，没有日期选择器</li><li id="b466" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nz nr ns nt bi translated"><strong class="lb iu">拒绝</strong>:我们显示一个按钮将用户移至设置，切换被禁用。没有日期选择器</li></ol><p id="5ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个分析也让我们理解了这个视图的其他需求是什么。我们需要一个能够打开设置页面的对象和一个请求通知权限并检索当前状态的对象。</p><p id="2a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图模型的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ViewModel代码，没有SwiftUI属性包装器和协议。它们会在文章的后面出现。</p></figure><p id="c0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我向<code class="fe lv lw lx ly b">ViewModel</code>添加了一些注释和文档，并使用<code class="fe lv lw lx ly b">extension</code>将语义相似的属性和方法分组在一起。理解每段代码做什么应该很容易。请注意，没有SwiftUI/Combine协议或属性包装器。我们将在后面的步骤中添加它们，以更深入地解释它们是什么以及为什么需要它们。</p><p id="ce8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们引入了几种类型来封装业务逻辑:<code class="fe lv lw lx ly b">SettingsManager</code>、<code class="fe lv lw lx ly b">SettingsOpener</code>和<code class="fe lv lw lx ly b">AuthorizationManager</code>。我们将在后面探讨它们，但它们与架构无关。我们用它们来表示我们的项目中一直存在的依赖关系，它们可以通过<code class="fe lv lw lx ly b">ViewModel</code>的其他方法来访问。</p><p id="fabe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图模型包含一些计算变量来决定我们需要显示UI的哪些部分。这大大简化了UI，因为所有的逻辑都被推到了<code class="fe lv lw lx ly b">ViewModel</code>中。</p><h2 id="1dae" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated">景色</h2><p id="3f8a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">既然我们已经分析了需要覆盖的所有州，我们可以单独开发视图。我更喜欢的方式是为每个组件使用单独的方法，这样<code class="fe lv lw lx ly b">body</code>属性可以以声明的方式组成视图。代码如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有属性包装和协议的SwiftUI代码。它们会在文章的后面出现。</p></figure><p id="92af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我又一次删除了所有的绑定代码，这样我们可以稍后再讨论它。</p><p id="a5e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过监听<code class="fe lv lw lx ly b">scenePhase</code>环境变量来检测应用程序何时从后台移动到前台。一旦我们声明我们的视图对观察该属性感兴趣，我们就可以在需要的时候刷新授权状态。</p><p id="941e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意视图是多么整洁:主视图声明我们有一个由两部分组成的表单。在这两个扩展中，我们可以分别看到这两个部分是如何组织的。</p><h2 id="1b92" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated">将视图模型与视图连接起来</h2><p id="e4c5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最后一步是添加所有的属性包装器和协议，以实现视图模型和视图之间的绑定。</p><p id="33f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要:</p><ol class=""><li id="667f" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nz nr ns nt bi translated">使<code class="fe lv lw lx ly b">ViewModel</code>符合<code class="fe lv lw lx ly b">ObservableObject</code>协议。</li><li id="7d43" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nz nr ns nt bi translated">将<code class="fe lv lw lx ly b">@Published</code>属性添加到可以触发UI更新的<code class="fe lv lw lx ly b">ViewModel</code>的所有属性中。在我们的例子中，它们是<code class="fe lv lw lx ly b">currentAuthorizationStatus</code>和<code class="fe lv lw lx ly b">settingsManager</code>。</li><li id="65fb" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nz nr ns nt bi translated">将<code class="fe lv lw lx ly b">@StateObject</code>属性包装器添加到视图中的<code class="fe lv lw lx ly b">viewModel</code>属性。</li></ol><p id="2ce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下，在这一步，我们应该能够同时使用<code class="fe lv lw lx ly b">Toggle</code>和<code class="fe lv lw lx ly b">DatePicker</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个设置自动使我们能够从<code class="fe lv lw lx ly b">@StateObject</code>中获得所需的绑定。我们可以深入到几个层，并检索绑定所需的特定变量。SwiftUI注意更新UI，即使最终属性没有发布:它只需要用<code class="fe lv lw lx ly b">@Published</code>属性包装器对容器进行注释。</p><p id="0541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，<code class="fe lv lw lx ly b">ViewModel</code>的<code class="fe lv lw lx ly b">settingsManager</code>属性是<code class="fe lv lw lx ly b">Published</code>，但是它的每个属性都不需要是<code class="fe lv lw lx ly b">Published</code>。</p><h2 id="eed2" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated">@StateObject与@ObservedObject</h2><p id="578d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">关于什么时候使用前者，什么时候使用后者，有点混乱。任何事情都可以通过思考谁拥有被注释对象的所有权来解决。</p><p id="cbc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对象是视图的本地对象，并且它的生命周期与视图的生命周期绑定在一起，那么它应该是一个<code class="fe lv lw lx ly b">StateObject</code>。<code class="fe lv lw lx ly b">ViewModel</code>就是这样一个对象:一个<code class="fe lv lw lx ly b">ViewModel</code>只有和它关联的<code class="fe lv lw lx ly b">View</code>才有意义。我们很少重用它，并且<code class="fe lv lw lx ly b">View</code>是唯一应该对它有强引用的实体。</p><p id="035a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果视图接收到一个由其他实体管理的<code class="fe lv lw lx ly b">ObservableObject</code>，我们应该使用<code class="fe lv lw lx ly b">@ObservedObject</code>属性包装器。</p><h1 id="fbeb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">把所有东西放在一起</h1><p id="c20e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在，我们还需要一些片段来创建一个工作示例。</p><p id="306d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要实施:</p><ol class=""><li id="88e5" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nz nr ns nt bi translated"><code class="fe lv lw lx ly b">SettingsManager</code>将设置保存在磁盘上。</li><li id="be3b" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nz nr ns nt bi translated"><code class="fe lv lw lx ly b">AuthorisationManager</code>询问权限。</li><li id="f5e4" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nz nr ns nt bi translated"><code class="fe lv lw lx ly b">SettingsOpener</code>打开设置应用程序。</li></ol><p id="6876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把所有的东西都放在应用程序里。</p><p id="ee24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将快速介绍前三个元素，展示代码和方法，但不会深入底层细节。</p><h1 id="28f3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">设置管理器</h1><p id="6ff9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">SettingsManager</code>是<code class="fe lv lw lx ly b">Settings</code>对象的容器，它必须从磁盘中存储和检索它们。为了实现这一点，我们将传递一个<code class="fe lv lw lx ly b">UserDefaults</code>实例作为存储。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="219f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码还包含对<code class="fe lv lw lx ly b">UserDefaults</code>的一个小扩展，以使代码在处理<code class="fe lv lw lx ly b">Codable</code>对象时更具可读性。</p><p id="7b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们可以使用<code class="fe lv lw lx ly b">@AppStorage</code>属性包装器来存储和检索值。然而，这样做，我们无法在测试中正确地注入不同的存储。</p><h2 id="025c" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated">授权经理</h2><p id="245a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">该对象实现了检索当前授权状态和向系统请求通知权限的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="26f7" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated">设置开启器</h2><p id="6782" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这是这个示例应用程序所需的最后一部分逻辑。该任务可由<code class="fe lv lw lx ly b">UIApplication</code>对象执行。我们应该把它包装到一个合适的协议中，以便灵活地进行替代实现，例如在测试中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="6ad4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">该应用程序</h1><p id="90ec" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们现在有了所有的要素来组装我们的应用程序，并在工作中看到它。同样，在这种情况下，我们需要修改<code class="fe lv lw lx ly b">ContentView</code>和<code class="fe lv lw lx ly b">MainApp</code>。</p><h2 id="7640" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated">更新内容视图</h2><p id="8b9a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">内容视图包含<code class="fe lv lw lx ly b">TabView</code>，它负责初始化子视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d24b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们一直在使用我们的MVVM建筑。我们创建一个<code class="fe lv lw lx ly b">ViewModel</code>来接收选项卡所需的所有经理。然后，它提供一个计算变量来导出<code class="fe lv lw lx ly b">NotificationSettingsViewModel</code>。</p><p id="20e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图是一个简单的<code class="fe lv lw lx ly b">TabView</code>，它通过从<code class="fe lv lw lx ly b">ContentViewViewModel</code>检索视图模型，创建了一个带有简单标签的<code class="fe lv lw lx ly b">Home</code>选项卡和我们的<code class="fe lv lw lx ly b">Settings</code>选项卡。</p><h2 id="397c" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated">主应用程序</h2><p id="c1dd" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">主应用程序是我们需要初始化应用程序的所有依赖项的地方。它是入口点，也是在应用程序的整个生命周期中保持所有实例存活的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个组件有责任组成应用程序逻辑的其余部分。在这个例子中，我们只需要初始化几个管理器，我们可以将它们作为单独的变量保存在<code class="fe lv lw lx ly b">MainApp</code>中。</p><p id="a193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当依赖项的数量开始增加时，我们可以创建一个依赖项容器来将它们放在一起。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="70de" class="lz ma it bd mb mc oh me mf mg oi mi mj jz oj ka ml kc ok kd mn kf ol kg mp mq bi translated">结论</h1><p id="d3bb" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在今天的文章中，我们探讨了如何构建一个具有复杂依赖关系和小表单的MVVM应用程序。我们致力于保持代码整洁，并始终确保依赖关系和数据的单一流动:从<code class="fe lv lw lx ly b">MainApp</code>到<code class="fe lv lw lx ly b">ContentView</code>再到<code class="fe lv lw lx ly b">NotificationSettings</code>。</p><p id="fe1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们探索了<code class="fe lv lw lx ly b">ObservedObject</code>和<code class="fe lv lw lx ly b">StateObject</code>之间的差异，并且我们验证了我们可以将<code class="fe lv lw lx ly b">Published</code>元素的数量限制为视图实际需要的数量。</p><p id="2389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们探讨了如何在应用程序进入后台和前台时进行监听，以及如何以一种干净的方式将所有东西放在一起。</p><p id="f559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个代码可以从<a class="ae ky" href="https://github.com/cipolleschi/MVVM" rel="noopener ugc nofollow" target="_blank">这个repo </a>下载。</p></div></div>    
</body>
</html>