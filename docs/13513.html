<html>
<head>
<title>Solidity Tutorial: All About Memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实度教程:关于内存的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-tutorial-all-about-memory-1e1696d71ee4?source=collection_archive---------1-----------------------#2022-09-03">https://betterprogramming.pub/solidity-tutorial-all-about-memory-1e1696d71ee4?source=collection_archive---------1-----------------------#2022-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2082" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解EVM的短期记忆</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8df96a52bf85ed9c299e153cc52eae75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f8G4r1C_g2nNPnec"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mechmind" rel="noopener ugc nofollow" target="_blank">机械心灵</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kz la lb"><p id="c903" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/solidity-tutorial-all-about-data-locations-dabd33212471"><em class="it"/></a><em class="it">子系列的第二部分。</em></p></blockquote><p id="65b9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们将学习EVM内存的布局、它的保留空间、空闲内存指针、如何使用<code class="fe mc md me mf b">memory</code>引用来读写内存以及使用内存时的传统最佳实践。</p><p id="1840" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们将使用来自<a class="ae ky" href="https://docs.ens.domains/" rel="noopener ugc nofollow" target="_blank">以太坊名称服务(ENS) </a>的合同代码片段，用有意义的例子来支持这篇文章。这将帮助我们更好地理解这个受欢迎的项目背后的智能合同是如何工作的。</p><h1 id="95f7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">目录</h1><ul class=""><li id="3bb6" class="my mz it lf b lg na lj nb lz nc ma nd mb ne ly nf ng nh ni bi translated">介绍</li><li id="ba89" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">EVM记忆——概述</li><li id="2695" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">内存布局</li><li id="4853" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">记忆基础</li><li id="ab15" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">从内存中读取(<code class="fe mc md me mf b">MLOAD</code>)</li><li id="b91f" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">写入内存(<code class="fe mc md me mf b">MSTORE</code> + <code class="fe mc md me mf b">MSTORE8</code>)</li><li id="dec3" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">知道内存大小(<code class="fe mc md me mf b">MSIZE</code>)</li><li id="21de" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">空闲内存指针</li><li id="2aef" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated"><code class="fe mc md me mf b">memory</code>作为函数参数的参考</li><li id="3385" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated"><code class="fe mc md me mf b">memory</code>函数体内部的引用</li><li id="a0ce" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">内存扩展成本</li><li id="3c15" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">合约调用之间的内存</li><li id="a11e" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">结论</li></ul></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="9607" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">介绍</h1><p id="e374" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">在介绍性文章<em class="le">“关于数据位置的一切”，</em>中，我将EVM描述为一个工业工厂。在工厂的某些地方，你会发现由操作员控制的机器和机器人。</p><p id="662f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这些机器将无法加工的大块钢/铝(例如，穿过炉门)分解成小块。</p><p id="fea0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们可以用同样的例子来说明以太坊。EVM作为32字节字的堆栈机器运行。当EVM遇到大于32字节的数据(复杂类型，如<code class="fe mc md me mf b">string</code>、<code class="fe mc md me mf b">bytes</code>、<code class="fe mc md me mf b">struct</code>或数组)时，它不能在堆栈上处理它们，因为这些项太大了。</p><p id="99f7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因此，EVM需要获取这些数据，并在其他地方进行处理。它有一个专门的地方:记忆。通过将这样的变量放入内存，EVM可以将它们以更小的块一个接一个地传递给堆栈。</p><p id="266d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">EVM存储器还用于复杂的内置运算，如abi编码、abi解码或通过keccak256的散列函数。对于这些特定情况，想象一下内存充当EVM的便笺簿或白板。</p><p id="a7d7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">老师或科学家可能会用白板在上面写东西来解决问题。这同样适用于EVM。EVM将内存用作暂存区来执行这些操作或计算，并返回最终值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/aef2ec465f502d7be0119296805026dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*Fu8leU0fGHBgOnGd.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://giphy.com/explore/physics-lecture" rel="noopener ugc nofollow" target="_blank">https://giphy.com/explore/physics-lecture</a></p></figure><p id="9f61" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">对于<code class="fe mc md me mf b">abi.decode(...)</code>或<code class="fe mc md me mf b">keccak256</code>，存储器是输入源。对于<code class="fe mc md me mf b">abi.encode(...)</code>来说，存储器是输出将被存储的地方。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="6f80" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">EVM记忆——概述</h1><p id="c2a0" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">EVM记忆有4个主要特征:</p><ul class=""><li id="46af" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly nf ng nh ni bi translated">就汽油而言更便宜</li><li id="bb7c" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">可变= <strong class="lf iu">可以被覆盖和更改</strong></li><li id="0437" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">相对于来自函数调用的事务= <strong class="lf iu">，或构造函数</strong> ( <strong class="lf iu"> = </strong>合同创建)</li><li id="eb37" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">短期<strong class="lf iu"> =不持久</strong>和<strong class="lf iu">在外部函数调用之间被擦除。</strong></li></ul><p id="f8f4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">EVM存储器是一个字节可寻址空间<strong class="lf iu">。</strong>里面所有的字节最初都是空的(定义为零)。它是一个可变的数据区，意味着你可以读写它。和calldata一样，内存也是通过字节索引来寻址的，但是我们会在<em class="le">“与内存交互”</em>一节中看到，在内存中一次只能读取32字节的字。</p><p id="6c02" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">EVM记忆也是不稳定的。存储在内存中的值不会在外部调用之间保持不变。</p><blockquote class="oh"><p id="5294" class="oi oj it bd ok ol om on oo op oq ly dk translated">一个<strong class="ak"> <em class="or">刚被</em> <em class="or">清除，当一个契约调用另一个契约时，获得新的内存实例</em> </strong> <em class="or">。</em></p></blockquote><p id="1e2a" class="pw-post-body-paragraph lc ld it lf b lg os ju li lj ot jx ll lz ou lo lp ma ov ls lt mb ow lw lx ly im bi translated">存储器不会被擦除和清除。EVM内存的每个新实例都特定于一个执行上下文，即当前契约执行。</p><p id="9b54" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因此，您应该记住，EVM内存是特定于1)消息调用和2)被调用的契约的执行环境的。稍后，我们将在单独的章节中更详细地解释这个概念。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="dc7f" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">内存布局</h1><blockquote class="oh"><p id="41b3" class="oi oj it bd ok ol om on oo op oq ly dk translated">存储器是线性的，可以在字节级寻址。</p></blockquote><p id="f405" class="pw-post-body-paragraph lc ld it lf b lg os ju li lj ot jx ll lz ou lo lp ma ov ls lt mb ow lw lx ly im bi translated">把内存想象成一个非常大(甚至<strong class="lf iu">巨大！</strong>)字节数组，像<code class="fe mc md me mf b">byte[]</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/415c4d1cc8758f9df6865602e68360b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmMnXOKhRfRCyl9HV8FEaw.jpeg"/></div></div></figure><p id="2f36" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当你与EVM内存交互时，你读取或写入(我称之为)<em class="le"/>32字节长的“内存块”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/84acd8745b521bbcea1b3e2fc10859f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gc3EkurgNVzyGySfIGsx6w.png"/></div></div></figure><h2 id="e61b" class="oz mh it bd mi pa pb dn mm pc pd dp mq lz pe pf ms ma pg ph mu mb pi pj mw pk bi translated">保留空间</h2><p id="3db6" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">存储器中的前4 x 32字节字是出于不同目的而保留的空间:</p><ul class=""><li id="f07e" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly nf ng nh ni bi translated">前2个字(<strong class="lf iu">偏移量</strong> <code class="fe mc md me mf b">0x00</code>和<code class="fe mc md me mf b">0x20</code>):散列函数的暂存空间</li><li id="4bf7" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated"><strong class="lf iu">偏移量</strong> <code class="fe mc md me mf b">0x40</code>和<code class="fe mc md me mf b">0x50</code>:第3个字:<strong class="lf iu">空闲内存指针</strong></li><li id="5062" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated"><strong class="lf iu">偏移量</strong> <code class="fe mc md me mf b">0x60</code>:永久为零，用作空动态内存数组的初始值</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/cb59ec8b81843fc729703aedada1e4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khEqdPBqyjZAN-L_tGgStg.jpeg"/></div></div></figure><p id="b108" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">空闲内存指针(位于偏移量0x40)是<em class="le">EVM内存中最重要的部分。必须小心处理，尤其是在组装/Yul时。我们将在单独的章节中介绍它。</em></p><blockquote class="kz la lb"><p id="454c" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">更多信息参见Solidity文档中的<a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.13/internals/layout_in_memory.html" rel="noopener ugc nofollow" target="_blank"><strong class="lf iu"/></a><em class="it"/>章节。</p></blockquote><h2 id="873e" class="oz mh it bd mi pa pb dn mm pc pd dp mq lz pe pf ms ma pg ph mu mb pi pj mw pk bi translated">最大内存限制</h2><p id="c3a7" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">我们看到，EVM存储器是一个线性阵列，可通过字节索引(称为偏移量)寻址。它最多可以包含多少字节？</p><blockquote class="oh"><p id="ab59" class="oi oj it bd ok ol om on oo op oq ly dk translated">这个数组有多大？EVM记忆有多大？</p></blockquote><p id="8850" class="pw-post-body-paragraph lc ld it lf b lg os ju li lj ot jx ll lz ou lo lp ma ov ls lt mb ow lw lx ly im bi translated">这个问题的答案就在geth源代码里(下面截图)。看一下使用的转换类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/fee52671e08bb5db087adcc56d5984c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2QJT6F3TBo9jbQA3XGYsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/ethereum/go-ethereum/blob/master/core/vm/instructions.go#L506" rel="noopener ugc nofollow" target="_blank">source:instructions . go(geth客户端源代码)。</a></p></figure><p id="712e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">从geth客户端的截图中我们可以看到，<code class="fe mc md me mf b">mStart.Uint64()</code>将内存偏移量转换为一个<code class="fe mc md me mf b">uint64</code>值。这意味着您可以放入内存的最大数据量是一个<code class="fe mc md me mf b">uint64</code>数的最大值。</p><p id="5e9f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果指定的偏移量大于该值，它将恢复原状。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="2481" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">记忆基础</h1><p id="399d" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">您只能在内部函数中指定<code class="fe mc md me mf b">memory</code>,而不能在契约级别指定外部函数。</p><p id="5500" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">默认情况下，以下数据和值始终位于内存中:</p><ul class=""><li id="c4b5" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly nf ng nh ni bi translated">复杂类型的函数参数。</li><li id="5a88" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">复杂类型的局部变量(在函数体内)。</li><li id="6ac7" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">从函数返回的值，不管它们是什么类型(这是通过<strong class="lf iu"> return </strong>操作码完成的)。</li><li id="8c30" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">函数返回的任何复杂值类型都必须指定关键字<code class="fe mc md me mf b">memory</code></li></ul><p id="1a82" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">对于复杂类型的变量/值，我们指的是<code class="fe mc md me mf b">struct</code>、数组、<code class="fe mc md me mf b">bytes</code>和<code class="fe mc md me mf b">strings</code>等变量。</p><p id="e2da" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">一旦函数调用结束，这些用关键字<code class="fe mc md me mf b">memory</code>定义的变量就会消失。这就是我们之前所说的“不坚持”。</p><p id="53c3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">原因是<code class="fe mc md me mf b">memory</code>告诉Solidity在运行时为变量创建一块空间，保证它的大小和结构，以便在函数执行期间在该函数中使用。</p><h2 id="bf80" class="oz mh it bd mi pa pb dn mm pc pd dp mq lz pe pf ms ma pg ph mu mb pi pj mw pk bi translated">与内存交互—概述</h2><p id="eb77" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">在EVM的记忆中,“可靠性文件”指出:</p><blockquote class="oh"><p id="b511" class="oi oj it bd ok ol om on oo op oq ly dk translated">…读取限于256位宽，而写入可以是8位宽或256位宽。</p></blockquote><p id="b1b9" class="pw-post-body-paragraph lc ld it lf b lg os ju li lj ot jx ll lz ou lo lp ma ov ls lt mb ow lw lx ly im bi translated">如果我们看看黄皮书，我们可以看到一个操作码被定义为从内存中读取(<code class="fe mc md me mf b">MLOAD</code>)，两个操作码被定义为写入内存:<code class="fe mc md me mf b">MSTORE</code>和<code class="fe mc md me mf b">MSTORE8</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/95f512bef55ae0bbc5e906280caf2d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i59M3Bd8-LRYjdS_Xs8y1w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">资料来源:<a class="ae ky" href="https://ethereum.github.io/yellowpaper/paper.pdf" rel="noopener ugc nofollow" target="_blank"> Ethreum黄皮书，第34页</a></p></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="a2b2" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">凭记忆阅读</h1><p id="decd" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">您可以使用<code class="fe mc md me mf b">MLOAD</code>操作码从内存中读取。</p><h2 id="f7ec" class="oz mh it bd mi pa pb dn mm pc pd dp mq lz pe pf ms ma pg ph mu mb pi pj mw pk bi translated"><strong class="ak">黄纸配方</strong></h2><p id="24c6" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">以下是黄皮书对<code class="fe mc md me mf b">MLOAD</code>操作码规范的描述。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/60b24acaf4065e4c3a19728dd0513d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JL3tsbW5upY4zvcVEIfxiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让我们揭开这个非常正式的公式的神秘面纱！</p></figure><p id="dd29" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">黄皮书中的公式可以解释如下:</p><ul class=""><li id="94d5" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly nf ng nh ni bi translated"><code class="fe mc md me mf b">Us[0]</code> =栈顶项目。</li><li id="e566" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated"><code class="fe mc md me mf b">Us'[0]</code> =放在堆栈顶部的结果项目。</li><li id="026b" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated"><code class="fe mc md me mf b">Um</code> =存储器中从特定偏移量开始的内容。</li></ul><p id="896e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">公式<code class="fe mc md me mf b">Um[Us[0]...Us[0] + 31]]</code>可以用简单的英语翻译如下:</p><ol class=""><li id="d187" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly pp ng nh ni bi translated"><em class="le">取栈顶最后一个项目</em> <code class="fe mc md me mf b"><em class="le">Us[0]</em></code> <em class="le">。</em></li><li id="17b4" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated"><em class="le">使用该值作为起始指针读入内存</em> <code class="fe mc md me mf b"><em class="le">Um</em></code> <em class="le"> (= offset) </em></li><li id="cbf7" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated"><em class="le">从该内存指针</em> <code class="fe mc md me mf b"><em class="le">Us[0]</em></code> <em class="le">中读取接下来的31个字节(</em> <code class="fe mc md me mf b"><em class="le">Us[0] + 31</em></code> <em class="le">)。</em></li></ol><p id="0b47" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">从内存中读取一次只能读取32字节的字。这意味着用<code class="fe mc md me mf b">mload</code>操作码一次只能从内存中取出32个字节。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pq pr l"/></div></figure><p id="33d9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这些操作码可用于Solidity内嵌汇编或独立的Yul代码。</p><h2 id="c4d9" class="oz mh it bd mi pa pb dn mm pc pd dp mq lz pe pf ms ma pg ph mu mb pi pj mw pk bi translated">例如:ENS合同中的SHA1图书馆</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/51775e30c8cb14b9ae2eddfd69f1d8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YdcfflrTz3bj4mtZ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://ens.domains/static/twitter-49d4bb2b55c07c5f5900e95860401fd0.png" rel="noopener ugc nofollow" target="_blank">ens-domains.com</a></p></figure><p id="d6c4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们来看看ENS合同中的一个例子:SHA1.sol 。</p><p id="841c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在下面的代码片段中，<code class="fe mc md me mf b">mload</code>操作码被使用了两次。</p><ul class=""><li id="0989" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly nf ng nh ni bi translated">首先检索<strong class="lf iu">空闲内存指针。</strong>暂存变量随后被用作内存中的指针，数据的sha1散列将被计算和写入。</li><li id="73f2" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">第二次检索数据变量的长度(=字节数)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/b5d1b7427b8a6adb60eb2ad63b888ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbPZ57b6PmVXAaQVzIgPcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/ensdomains/ens-contracts/blob/8a2423829a28852297ee208357d148987e8dce0f/contracts/dnssec-oracle/SHA1.sol" rel="noopener ugc nofollow" target="_blank">来源:Github上的ENS源代码，SHA1.sol库</a></p></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="4b55" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">写入内存</h1><p id="be8c" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">您可以使用以下两种操作码之一写入存储器:</p><ul class=""><li id="00e5" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly nf ng nh ni bi translated"><code class="fe mc md me mf b">MSTORE</code> →在内存中写一个字(= 32字节)。</li><li id="cf2e" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated"><code class="fe mc md me mf b">MSTORE8</code> →在存储器中写入一个字节</li></ul><p id="9e87" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这条推文展示了geth客户端中的EVM实例如何将参数从堆栈中取出作为<code class="fe mc md me mf b">MSTORE</code>的输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pq pr l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pq pr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/3d3093b5074b07f8dd39bb28e5f1dcec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/0*NrHb6YeHDay65hqw"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://twitter.com/721Orbit/status/1511961771879370753?s=20&amp;t=KDGCQ4OwQ47e2NACgQ8WWg" rel="noopener ugc nofollow" target="_blank">来源:法希尔在推特上</a></p></figure><p id="ba1a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">坚固性</strong></p><p id="e5f6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在Solidity中，每当你用<code class="fe mc md me mf b">memory</code>关键字实例化一个变量并赋值(一个文字字节/字符串，或者一个函数的返回值)时，EVM就会执行一个<code class="fe mc md me mf b">mstore</code>指令。</p><p id="7488" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这里有一个来自ENS的<code class="fe mc md me mf b">DNSRegistar.sol</code>合同的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/ad1b9e6a8a434dec298e91f46e4e861a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLW1IsZLxBi_k0e349-vVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/ensdomains/ens-contracts/blob/3445b94a187cac1016ec6e3fb69b885227565d8e/contracts/dnsregistrar/DNSRegistrar.sol#L175-L178" rel="noopener ugc nofollow" target="_blank">来源:Github上的ENS源代码，DNSRegistar.sol </a></p></figure><p id="8b78" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">组装中</strong></p><p id="9152" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe mc md me mf b">mstore</code>操作码可以在内嵌汇编中使用。它接受两个参数:</p><ul class=""><li id="d2e3" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly nf ng nh ni bi translated">要写入的内存偏移量。</li><li id="e593" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">要写入内存的数据</li></ul><p id="2fcc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">查看<code class="fe mc md me mf b">mstore</code>如何在同一个ENS合同<code class="fe mc md me mf b">SHA1.sol.</code>中用于装配</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/754a429aff31dccbc612198f031d0ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMfwHG9NQ5xClgRGyzzZTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/ensdomains/ens-contracts/blob/8a2423829a28852297ee208357d148987e8dce0f/contracts/dnssec-oracle/SHA1.sol#L41-L56" rel="noopener ugc nofollow" target="_blank">来源:Github上的ENS源代码，SHA1.sol库。</a></p></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="950a" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">知道内存大小</h1><blockquote class="kz la lb"><p id="72e4" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有关<code class="fe mc md me mf b">MSIZE</code>操作码的更多详细信息，请参见<a class="ae ky" href="https://www.evm.codes/" rel="noopener ugc nofollow" target="_blank"> evm.codes </a>中的操作码说明</p></blockquote><p id="005e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">乍一看，EVM操作码<code class="fe mc md me mf b">MSIZE</code>顾名思义，它将返回内存中存储了多少数据。或者换句话说，当前有多少字节被写入存储器。</p><p id="19f5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe mc md me mf b">MSIZE</code>操作码有点复杂。Solidity编译器的C++源代码提供了更多的信息来理解它。见下文。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/11de316591daca90c2045969a909d067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*16HlGJ8ifDnaKFS-.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Solidity Github仓库上的SemanticInformation.cpp</p></figure><p id="1663" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe mc md me mf b">MSIZE</code>操作码返回当前执行环境中在内存中访问的最高字节偏移量。大小将始终是字的倍数(32字节)。</p><p id="b93c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是在坚固性上，<em class="le">“内存中存储多少字节”</em>和<em class="le">“内存中访问的最大索引/偏移量”有什么区别？</em></p><p id="662e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们将用一个使用Solidity本身的实际例子来说明！请看下面的代码片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pr l"/></div></figure><p id="1500" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这里发生了什么事？</p><p id="1cd4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">第一步:</strong> <code class="fe mc md me mf b">freeMemBefore</code>首先返回空闲内存指针:<code class="fe mc md me mf b">0x80 (= 128)</code></p><p id="1690" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">第二步:</strong>然后我们将<code class="fe mc md me mf b">data</code>写入内存(64字节)。空闲内存指针得到更新。(<code class="fe mc md me mf b">freeMemAfter</code>)变成<code class="fe mc md me mf b">0xc0 (= 192)</code>。</p><blockquote class="kz la lb"><p id="77d2" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">注意:</strong>在上面的例子中，空闲内存指针自动更新只是因为我们在汇编块之外。如果您通过<code class="fe mc md me mf b">mstore</code>或类似的操作码(如<code class="fe mc md me mf b">calldatacopy</code>)写入汇编中的内存，空闲内存指针不会自动更新。你有责任自己手动完成。</p><p id="2b6e" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请记住Solidity文档中提到的规则:“内联汇编可能有一个非常高级的外观，但它是非常低级的”。</p></blockquote><p id="446d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">此时，从技术上讲，内存中总共分配了192个字节。</p><pre class="kj kk kl km gt pz mf qa qb aw qc bi"><span id="4b5c" class="oz mh it mf b gy qd qe l qf qg">  32 bytes <br/>x 4             (the first 4 reserved spaces in memory)<br/>---------------------<br/>= 128 <br/>+ 64 bytes      (the variable `data`)  <br/>---------------------  <br/>= 192           (total)</span></pre><p id="395d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">现在注意第28行。我们试着从偏移量<code class="fe mc md me mf b">0x0c (192)</code>读入内存</p><p id="bf6e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">第三步:</strong>当我们做<code class="fe mc md me mf b">msize</code>(第31行)时，我们获得了数字<code class="fe mc md me mf b">224 (= 0xe0)</code>。刚刚发生了什么？总共只有192字节存储/分配在内存中。这224从何而来？</p><p id="e344" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe mc md me mf b">224 = 192 + 32</code>。所以<code class="fe mc md me mf b">msize</code>返回的值就是内存中存储的总字节数(<code class="fe mc md me mf b">192</code> ) + 32。我们刚刚触发并见证了一场记忆膨胀。内存总是一次扩展32字节字。</p><p id="a4fd" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">对于<code class="fe mc md me mf b">msize</code>操作码，没有比来自<a class="ae ky" href="https://www.evm.codes/" rel="noopener ugc nofollow" target="_blank"> evm.codes </a>的解释更好的了。</p><blockquote class="oh"><p id="874f" class="oi oj it bd ok ol om on oo op oq ly dk translated">msize tracks是当前执行中访问过的最高偏移量。对更大偏移量的首次写入或读取将触发<a class="ae ky" href="https://www.evm.codes/about" rel="noopener ugc nofollow" target="_blank">存储器扩展</a></p></blockquote></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="46d1" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">空闲内存指针</h1><p id="cbd7" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">在他们的热门文章系列“解构智能合约”中，OpenZeppelin揭示了每个智能合约的前5个字节背后的操作码的含义。</p><pre class="kj kk kl km gt pz mf qa qb aw qc bi"><span id="c743" class="oz mh it mf b gy qd qe l qf qg">0x6080604052...</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/be8d3bf2cab2afdc789cd612072de45a.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/0*3FlrByGd0DBQm1lX"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-ii-creation-vs-runtime-6b9d60ecb44c/" rel="noopener ugc nofollow" target="_blank">资料来源:OpenZeppelin，解构智能合同(第一部分)</a></p></figure><p id="1ebf" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在一个nutschell中，这个操作码序列将数字<code class="fe mc md me mf b">0x80</code>(十进制128)存储到内存的位置<code class="fe mc md me mf b">0x40</code>(十进制64)。为什么</p><p id="2929" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如前一节<em class="le">“存储器布局”</em>所述，存储器中的前4个字是为特定目的而保留的。第三个字——位于内存中的位置<code class="fe mc md me mf b">0x40</code>——被称为<strong class="lf iu">自由内存指针。</strong></p><p id="0bb6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">Open Zeppelin将自由内存指针描述为<em class="le">“对内存中第一个未使用的字的引用”</em>。它能够知道内存中的哪个位置(在哪个偏移量)有空闲空间可以写入数据。这是为了避免覆盖内存中已经存在的数据。</p><p id="4c0c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">空闲内存指针是EVM最重要和最关键的东西之一。</p><h2 id="cc8f" class="oz mh it bd mi pa pb dn mm pc pd dp mq lz pe pf ms ma pg ph mu mb pi pj mw pk bi translated">Solidity中的空闲内存指针</h2><p id="2cf7" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">在Solidity中，做<code class="fe mc md me mf b">bytes memory myVariable</code>这样的代码片段时会自动取+更新空闲内存指针。</p><p id="d8a1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们看一个例子。对于坚固性代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qi"><img src="../Images/680de5c858a9a1cdd80c82de7f347496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjJAHD_F3DwwvWl5KOBK0A.png"/></div></div></figure><p id="dd85" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这些是由Solidity编译器生成的操作码。我们感兴趣的是如何获取和更新空闲内存指针，从指令<code class="fe mc md me mf b">056</code>到指令<code class="fe mc md me mf b">065</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qj"><img src="../Images/57a3d8813c9544195bfecb31abf69d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hE0XT5gcTsowfKQaOvoqmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">写字符串存储器的基本操作码序列。</p></figure><p id="0117" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当一个字符串或一些数据被写入Solidity的内存中时，EVM总是执行以下最初的两个步骤:</p><p id="9638" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">第一步:获取空闲内存指针。</strong></p><p id="d133" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">EVM首先从内存位置<code class="fe mc md me mf b">0x40</code>加载空闲内存指针。<code class="fe mc md me mf b">mload</code>返回的值是<code class="fe mc md me mf b">0x80</code>。我们的空闲内存指针告诉我们，内存中第一个有空闲空间可写的地方是在偏移量<code class="fe mc md me mf b">0x80</code>。这是我们栈顶最后的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qk"><img src="../Images/2163ac6edcfc7cea3b930e30a455777e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEMW7DJTOCXkjQ8yntWpIw.png"/></div></div></figure><p id="627f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">第二步:分配内存+用新的空闲内存指针更新。</strong></p><p id="4d54" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">EVM现在将在内存中为<code class="fe mc md me mf b">string test</code>保留该位置。它将空闲内存指针返回的值保存在本地堆栈上。</p><p id="3942" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是Solidity编译器既聪明又安全！在分配之后，在向内存中写入任何值之前，它总是更新空闲内存指针。这是指内存中下一个空闲空间。</p><p id="49cb" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">根据ABI规范，<code class="fe mc md me mf b">string</code>由两部分组成:长度+字符串本身。下一步是更新空闲内存指针。EVM在这里说的是<em class="le">“我要在内存中写2×32字节的字。因此，新的空闲内存指针将比当前指针“</em>多64个字节。</p><p id="aca3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">下面的操作码做的事情很简单。它:</p><ol class=""><li id="ea0f" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly pp ng nh ni bi translated">复制空闲内存指针的当前值= <code class="fe mc md me mf b">0x80</code></li><li id="c793" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated">给它加上<code class="fe mc md me mf b">0x40</code></li><li id="aa52" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated">将<code class="fe mc md me mf b">0x40</code>(再次=空闲内存指针的位置)压入堆栈</li><li id="ec83" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated">通过<code class="fe mc md me mf b">MSTORE</code>用新值更新空闲内存指针</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ql"><img src="../Images/154735b9f1fbab9386494b3bdb0bdee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCJoqPaKujn2bIgVBOA1Vg.png"/></div></div></figure><h2 id="4bc8" class="oz mh it bd mi pa pb dn mm pc pd dp mq lz pe pf ms ma pg ph mu mb pi pj mw pk bi translated">程序集中的空闲内存指针</h2><p id="c042" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">在内联汇编中，必须小心处理空闲内存指针！</p><p id="a9dd" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">不仅要手动获取，还要手动更新！</p><p id="0fa0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因此，在汇编中处理内存时必须小心。如果您不想最终覆盖内存中已经有一些内容的内容，那么您必须确保总是首先获取汇编中的空闲内存，并写入空闲内存指针所指向的内存位置。</p><p id="911d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">一旦写入内存，必须确保用新的空闲内存偏移量更新空闲内存指针。</p><p id="6b32" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">总之，当谈到空闲内存指针时，永远记住OpenZeppelin的建议:</p><blockquote class="oh"><p id="b499" class="oi oj it bd ok ol om on oo op oq ly dk translated"><em class="or">“在汇编级操作内存时，必须非常小心。否则，您可能会覆盖保留的空间。</em></p></blockquote><blockquote class="kz la lb"><p id="4ce9" class="lc ld le lf b lg os ju li lj ot jx ll lm ou lo lp lq ov ls lt lu ow lw lx ly im bi translated"><strong class="lf iu">注意:在检查空闲内存指针指向的内存位置实际存储了什么之前，先写入空闲内存指针可能不是一个好的做法。</strong></p></blockquote><p id="db89" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">示例:来自</strong><a class="qm qn ep" href="https://medium.com/u/3e5dfef854b6?source=post_page-----1e1696d71ee4--------------------------------" rel="noopener" target="_blank"><strong class="lf iu">gona lo sá</strong></a>的solidity-bytes-utils库</p><p id="b51c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们来看看这个流行的用来操纵<code class="fe mc md me mf b">bytes</code>的Solidity库。如果您仔细查看每个函数的初始汇编代码，您会发现加载空闲内存指针是首先发生的事情。</p><p id="f51b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">函数结束时，返回<code class="fe mc md me mf b">tempBytes</code>。在底层，这可以通过“返回内存中由<code class="fe mc md me mf b">tempBytes</code>指向的内存偏移量处的内容”来解释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ca"><img src="../Images/d88877ae7c29630f359f1d1b7af660b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVQ2zpD-UrHsVd9lC5w9rg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/GNSPS/solidity-bytes-utils/blob/6458fb2780a3092bc756e737f246be1de6d3d362/contracts/BytesLib.sol#L245-L247" rel="noopener ugc nofollow" target="_blank">来源:Github上的GBSPS/solidity-bytes-utils，BytesLib.sol </a></p></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="8b57" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">作为函数参数的内存引用</h1><p id="1824" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">每次在Solidity中，当我们必须将一个动态或复杂类型的参数传递给一个函数时，我们都会使用这个语句。</p><p id="07ef" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">例如，在ENS契约中，<code class="fe mc md me mf b">DNSRegistar.sol</code>的<code class="fe mc md me mf b">claim(...)</code>函数接受两个参数:a <code class="fe mc md me mf b">name</code>和<code class="fe mc md me mf b">proof</code>，两者都是<code class="fe mc md me mf b">memory</code>引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qo"><img src="../Images/569b3cfd2e5eb6016465591a5faa95dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_Y3Gia6gLULOOURLpHc0g.png"/></div></div></figure><p id="acfe" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是对于EVM来说，<code class="fe mc md me mf b">memory</code>引用作为函数参数意味着什么呢？让我们用一个基本的坚实度的例子。</p><pre class="kj kk kl km gt pz mf qa qb aw qc bi"><span id="e31d" class="oz mh it mf b gy qd qe l qf qg">function test(string memory input) public {<br/>    // ...<br/>}</span></pre><p id="1a86" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当一个<code class="fe mc md me mf b">memory</code>引用作为参数传递给一个函数时，该函数的EVM字节码依次执行4个主要步骤:</p><ol class=""><li id="83ca" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly pp ng nh ni bi translated"><strong class="lf iu">从</strong> <code class="fe mc md me mf b"><strong class="lf iu">calldata</strong></code> <strong class="lf iu">加载字符串偏移量到堆栈:</strong>知道字符串在<code class="fe mc md me mf b">calldata</code>里面的起始位置。</li><li id="6742" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated"><strong class="lf iu">将字符串长度加载到堆栈中:</strong>将用于知道从<code class="fe mc md me mf b">calldata</code>中复制多少数据。</li><li id="1d3c" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated"><strong class="lf iu">分配一些内存空间</strong>将字符串从<code class="fe mc md me mf b">calldata</code>移至<code class="fe mc md me mf b">memory</code>:这与“空闲内存指针”中描述的相同。</li><li id="fd03" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated"><strong class="lf iu">使用操作码<code class="fe mc md me mf b">calldatacopy</code>将字符串从</strong> <code class="fe mc md me mf b"><strong class="lf iu">calldata</strong></code> <strong class="lf iu">转移到</strong> <code class="fe mc md me mf b"><strong class="lf iu">memory</strong></code> <strong class="lf iu"> </strong>。</li></ol><p id="b680" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我把详细的操作码放在下面了。你也可以查看我的Github库来了解更多细节。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qp"><img src="../Images/a2d2a004c33549779cf4f2fc5ba14e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLohdDYp4Jx-LW6o2dPteg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qq"><img src="../Images/db57ae6c650a260a170749a95fbdc06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qGsUCN6HrWlaVCPoVjyk2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Memory.md#a-string-passed-as-a-function-argument" rel="noopener ugc nofollow" target="_blank">来源:关于坚固性的一切——记忆(Github库)</a></p></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="4d3c" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">函数体内的内存引用</h1><p id="1bdf" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">让我们看看下面的准系统例子。</p><pre class="kj kk kl km gt pz mf qa qb aw qc bi"><span id="19bc" class="oz mh it mf b gy qd qe l qf qg">function test() public {</span><span id="4961" class="oz mh it mf b gy qr qe l qf qg">    uint256[] memory data;</span><span id="209d" class="oz mh it mf b gy qr qe l qf qg">}</span></pre><p id="636e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">要问的问题是<em class="le">变量</em> <code class="fe mc md me mf b"><em class="le">data</em></code> <em class="le">包含什么？</em></p><p id="32e6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">回答<em class="le"/><code class="fe mc md me mf b"><em class="le">uint256</em></code><em class="le">号的空数组</em>可能会很有诱惑力。但是不要被语法所迷惑或误导。这是Solidity，不是Javascript或者Typescript！</p><p id="f913" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在Typescript中，声明一个具有<code class="fe mc md me mf b">uint256[]</code>类型的变量而不初始化它会导致该变量首先保存一个空数组。</p><p id="ba79" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然而，关键字<code class="fe mc md me mf b">memory</code>在这里改变了这一切！</p><p id="551e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们来刷新一下我们的大脑，在介绍文章《关于数据位置的一切》中，我们描述了带有关键字<code class="fe mc md me mf b">storage</code>、<code class="fe mc md me mf b">memory</code>或<code class="fe mc md me mf b">calldata</code>的变量称为<strong class="lf iu">引用类型变量。</strong></p><p id="f0fd" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">所以当你在一个带有关键字<code class="fe mc md me mf b">memory</code>的实性函数中看到一个变量时，你是在处理一个对内存中某个位置的引用。</p><p id="3ff8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因此，上面的变量<code class="fe mc md me mf b">data</code>不保存数组，而是保存<strong class="lf iu">一个指向内存中某个位置的指针。</strong>Solidity文档对此做了很好的描述:</p><blockquote class="oh"><p id="d76a" class="oi oj it bd ok ol om on oo op oq ly dk translated">引用内存的局部变量计算内存中变量的地址，而不是值本身。</p></blockquote><p id="150c" class="pw-post-body-paragraph lc ld it lf b lg os ju li lj ot jx ll lz ou lo lp ma ov ls lt mb ow lw lx ly im bi translated">而坚固性在解释上更进一步！</p><blockquote class="oh"><p id="8bbc" class="oi oj it bd ok ol om on oo op oq ly dk translated">这样的变量也可以赋值给，但是注意赋值只会改变指针而不会改变数据</p></blockquote><p id="790a" class="pw-post-body-paragraph lc ld it lf b lg os ju li lj ot jx ll lz ou lo lp ma ov ls lt mb ow lw lx ly im bi translated">让我们看另一个例子来更好地理解。</p><pre class="kj kk kl km gt pz mf qa qb aw qc bi"><span id="720d" class="oz mh it mf b gy qd qe l qf qg">function test() public pure returns (bytes memory) {</span><span id="290b" class="oz mh it mf b gy qr qe l qf qg">    bytes memory data;<br/>    bytes memory greetings = hex"cafecafe";</span><span id="7810" class="oz mh it mf b gy qr qe l qf qg">    data = greetings;<br/>    data[0] = 0x00;<br/>    data[1] = 0x00;</span><span id="504e" class="oz mh it mf b gy qr qe l qf qg">    return greetings;</span><span id="8c21" class="oz mh it mf b gy qr qe l qf qg">}</span></pre><p id="b816" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">有人可能会认为变量<code class="fe mc md me mf b">greetings</code>在这里是安全的，这个函数将返回<code class="fe mc md me mf b">0xcafecafe</code>。但是这里的假设是错误的，如果你运行这个函数，它会返回如下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/1649fda8736c2780678877023f85e225.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*FkXzg07rxbVZzzyHCddrxA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存引用给人的惊奇和错误的假设。</p></figure><p id="1a24" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">实际上，我们创建了两个指向内存的指针，分别用变量<code class="fe mc md me mf b">data</code>和<code class="fe mc md me mf b">greetings</code>命名。</p><p id="ad77" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当我们做<code class="fe mc md me mf b">data = greetings</code>时，我们认为我们在给变量<code class="fe mc md me mf b">data</code>赋值<code class="fe mc md me mf b">cafecafe</code>。但是<strong class="lf iu">我们在这里根本没有分配任何东西</strong>！我们向EVM发出以下指令:</p><blockquote class="kz la lb"><p id="f590" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">"变量<code class="fe mc md me mf b">data</code>，我命令你指向内存中变量<code class="fe mc md me mf b">greetings</code>指向的相同位置！"<em class="it">🫡</em>🪖</p></blockquote><h2 id="cda9" class="oz mh it bd mi pa pb dn mm pc pd dp mq lz pe pf ms ma pg ph mu mb pi pj mw pk bi translated">在内存中分配新元素</h2><p id="c0c4" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">在上一节中我们看到，我们可以在内存中为变量分配一些空间，并通过给变量赋值来直接写入。</p><p id="f687" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们也可以在内存中分配一些空间，但不立即写入内存，方法是使用<code class="fe mc md me mf b">new</code>关键字。</p><p id="b237" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这主要是在实例化复杂类型(如函数中的数组)时。</p><p id="08a0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当用<code class="fe mc md me mf b">new</code>关键字创建数组时，数组长度必须在括号中指定。在函数体内的内存中只允许固定大小的数组。</p><pre class="kj kk kl km gt pz mf qa qb aw qc bi"><span id="98ce" class="oz mh it mf b gy qd qe l qf qg">uint[] memory data = new uint[](3);</span></pre><p id="6d6e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">对于结构，new关键字不是必需的。</p><h2 id="fa7d" class="oz mh it bd mi pa pb dn mm pc pd dp mq lz pe pf ms ma pg ph mu mb pi pj mw pk bi translated">从存储参考变量复制</h2><p id="3efb" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">让我们继续下面的坚实度的例子。</p><pre class="kj kk kl km gt pz mf qa qb aw qc bi"><span id="c7e7" class="oz mh it mf b gy qd qe l qf qg">// SPDX-License-Identifier: UNLICENSED<br/>pragma solidity ^0.8.0;</span><span id="d31f" class="oz mh it mf b gy qr qe l qf qg">contract Playground {</span><span id="51b7" class="oz mh it mf b gy qr qe l qf qg">    bytes storageData = hex"C0C0A0C0DE";</span><span id="a299" class="oz mh it mf b gy qr qe l qf qg">    <br/>    function test() public {</span><span id="50ea" class="oz mh it mf b gy qr qe l qf qg">        bytes memory data = storageData;</span><span id="533b" class="oz mh it mf b gy qr qe l qf qg">    }</span><span id="bd69" class="oz mh it mf b gy qr qe l qf qg">}</span></pre><p id="379f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在这个场景中，我们将一个<code class="fe mc md me mf b">storage</code>引用(=在<code class="fe mc md me mf b">=</code>符号的右边)复制到一个<code class="fe mc md me mf b">memory</code>引用(=在<code class="fe mc md me mf b">=</code>符号的左边)。这里发生了两件事:</p><ol class=""><li id="b0dd" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly pp ng nh ni bi translated">新的内存被分配，变量<code class="fe mc md me mf b">data</code>将指向内存中的一个新位置。</li><li id="a09e" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated">十六进制十进制值<code class="fe mc md me mf b">0xC0C0A0C0DE</code>从存储器中加载并复制到内存中<code class="fe mc md me mf b">data</code>所指的存储位置。</li></ol></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="c554" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">内存扩展成本</h1><blockquote class="kz la lb"><p id="0162" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有关内存扩展成本的更多详细信息，请阅读<a class="ae ky" href="https://www.evm.codes/about#memoryexpansion" rel="noopener ugc nofollow" target="_blank"> evm.codes </a></p></blockquote><p id="66b1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">坚固性文件陈述如下:</p><blockquote class="oh"><p id="cc7d" class="oi oj it bd ok ol om on oo op oq ly dk translated">当访问(读取或写入)先前未接触的存储器字(即，字内的任何偏移)时，存储器被一个字(256位)扩展。</p><p id="fdf0" class="oi oj it bd ok ol om on oo op oq ly dk translated">在扩建时，必须支付燃气费用。内存越大，成本就越高(它以平方的方式扩展)。</p></blockquote><p id="7bf9" class="pw-post-body-paragraph lc ld it lf b lg os ju li lj ot jx ll lz ou lo lp ma ov ls lt mb ow lw lx ly im bi translated">事实上，每当我们在内存中写入一个以前没有使用过(其中有一些数据)或访问过(通过<code class="fe mc md me mf b">mload</code>)的新单词时，内存就会“扩展”。</p><p id="6ba7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为什么内存扩展很重要？因为内存越大，每次与它交互时消耗的气体就越多。</p><p id="12fc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当你通过<code class="fe mc md me mf b">mstore</code>(或<code class="fe mc md me mf b">mstore8</code>)写入内存时，这两个操作码会用到一些gas。但是，写入内存的开销不仅仅取决于您向内存写入了多少数据。它还取决于实际的内存大小，也就是EVM影子开发者社区所说的<em class="le">“内存扩展成本”。</em></p><p id="9202" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">除了写入内存的成本之外，还有一个与内存扩展量相关的额外成本。</p><p id="8bb9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">内存扩展成本以下列方式增加:</p><ul class=""><li id="9a84" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly nf ng nh ni bi translated">前724个字节是线性的。</li><li id="7b5f" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly nf ng nh ni bi translated">之后是二次<em class="le">(解释“二次”</em>的意思)</li></ul><p id="57ff" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当通过<code class="fe mc md me mf b">mload</code>操作码在内存中访问更高的偏移量时，简单的内存读取操作也会增加内存扩展成本。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="4979" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">合约调用之间的内存</h1><p id="4086" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">关于EVM记忆和智能合约，有一个重要的概念需要注意。可靠性文件很好地说明了这一点:</p><blockquote class="oh"><p id="751c" class="oi oj it bd ok ol om on oo op oq ly dk translated">…契约为每个消息调用获得一个新清除的(内存)实例。</p></blockquote><p id="019b" class="pw-post-body-paragraph lc ld it lf b lg os ju li lj ot jx ll lz ou lo lp ma ov ls lt mb ow lw lx ly im bi translated">这有助于我们理解EVM记忆的一个主要特征:<strong class="lf iu">一个清晰的记忆实例是在外部调用之间获得的。</strong></p><p id="22ce" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">事实上，EVM内存的一个实例是特定于每个契约和当前执行上下文的。这意味着在每次新约定交互时，获得新清除的空内存。</p><p id="806b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们在实践中检查如何在每个新的外部调用中获得一个清晰的内存实例。我们将以这两份合同为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pr l"/></div></figure><p id="2288" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">使用这两个基本契约，我们可以使用<code class="fe mc md me mf b">Source</code>契约与<code class="fe mc md me mf b">Target</code>契约进行交互。让我们在Remix中部署和调试它们。</p><ol class=""><li id="ea0a" class="my mz it lf b lg lh lj lk lz oe ma of mb og ly pp ng nh ni bi translated">打开<a class="ae ky" href="https://remix-project.org/" rel="noopener ugc nofollow" target="_blank"> Remix IDE </a>，创建一个新文件复制上面的Solidity代码。</li><li id="828d" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated">在不启用优化器或不运行任何次数的情况下编译文件。</li><li id="477b" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated">首先部署<code class="fe mc md me mf b">Target</code>合同。</li><li id="1693" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated">其次部署<code class="fe mc md me mf b">Source</code>契约，给出之前部署的<code class="fe mc md me mf b">Target</code>契约的地址作为构造函数参数。</li><li id="0731" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated">在<code class="fe mc md me mf b">Source</code>合同上，运行功能<code class="fe mc md me mf b">callTarget()</code></li><li id="8750" class="my mz it lf b lg nj lj nk lz nl ma nm mb nn ly pp ng nh ni bi translated">在控制台上，点击<strong class="lf iu">“Debug”</strong>，调试事务的各个操作码。</li></ol><p id="e6af" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当您调试并检查每个操作码时，您应该看到EVM内存中充满了各种偏移量的数据。其中一个在偏移量<code class="fe mc md me mf b">0x80</code>处显示了值<code class="fe mc md me mf b">0x826926790000000000000000...</code>。这是目标契约上功能<code class="fe mc md me mf b">doSomething()</code>的功能选择器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qt"><img src="../Images/9d6d1c9f6c3e296019ba281884bb2664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/0*THyj5hxpsIqvgJ0J.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们在这里可以看到，在外部契约调用之前，内存中充满了数据</p></figure><p id="6003" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们可以在上面的截图中看到执行上下文。调试器突出显示了代码行nb 12，外部调用<code class="fe mc md me mf b">target.doSomething()</code>。</p><p id="abfa" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">现在注意下一步！如果你点击蓝色箭头按钮跳转到下一个操作码进行调试，就像变魔术一样，内存被清空，变成空的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qu"><img src="../Images/101ec95890c0f4fc74ce31b2c0d33ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*QwZ5EXmQBmD1VjJX6MZ5kQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查看内存切换状态“无数据可用”</p></figure><p id="be87" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">从上面的截图可以看出，左边栏的“内存”栏现在显示“无数据可用”。刚刚发生了什么？</p><p id="3335" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe mc md me mf b">CALL</code>操作码使EVM改变了执行环境。我们现在在一个新的执行上下文中运行EVM:<code class="fe mc md me mf b">Target</code>契约的上下文。从上面可以看到，函数<code class="fe mc md me mf b">doSomething()</code>现在被突出显示，为这个新的执行上下文切换提供了额外的线索。</p><p id="1720" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">下面是Solidity中这个外部调用的操作码摘要。为了简洁起见，我省略了一些操作码，并以注释的形式解释了发生的情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pr l"/></div></figure><p id="6c7e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">简单解释一下，EVM会生成calldata字节，将<code class="fe mc md me mf b">doSomething()</code>(为<code class="fe mc md me mf b">0x82692679</code>)的函数选择器推到堆栈上，并将其左移以准备calldata，这样就有这4个字节作为calldata中的函数选择器。</p><p id="e569" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然后，要发送的calldata有效负载存储在内存中由空闲内存指针检索的位置。</p><p id="d20f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">最后，<code class="fe mc md me mf b">CALL</code>操作码将调用外部契约地址，该地址最初从契约存储器(在指令编号<code class="fe mc md me mf b">057</code>处)获取，并且将通过从存储器(其先前被写入的位置)获取来发送calldata。</p><blockquote class="kz la lb"><p id="38b1" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可以在github的<a class="ae ky" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Memory.md#memory-between-function-calls" rel="noopener ugc nofollow" target="_blank">“All About Solidity”库中查看这个外部调用的EVM操作码的完整片段。</a></p></blockquote></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="850e" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">结论</h1><p id="7e7a" class="pw-post-body-paragraph lc ld it lf b lg na ju li lj nb jx ll lz oa lo lp ma ob ls lt mb oc lw lx ly im bi translated">在EVM，记忆是一个重要的学习领域。它使EVM能够执行消息呼叫，例如标准的<code class="fe mc md me mf b">call</code>、<code class="fe mc md me mf b">staticcall</code>和<code class="fe mc md me mf b">delegatecall</code>。与消息调用一起发送的calldata和payload是从内存中存储和检索的。</p><p id="0fc1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因此，EVM内存允许更好的可组合性，从而能够在智能合约中创建灵活的内部函数和子例程。此外，定义为<code class="fe mc md me mf b">memory</code>的参数使契约能够接收来自各种来源的调用和参数，包括EOAs和外部契约调用(从<code class="fe mc md me mf b">calldata</code>到<code class="fe mc md me mf b">memory</code>加载有效负载)，还能够直接从内部函数中组合输入。</p><p id="503c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">最后，在低级汇编中使用内存时要小心处理。这是为了确保您不会覆盖一些已经包含一些数据的保留内存空间。因此，尊重<a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.16/assembly.html#memory-management" rel="noopener ugc nofollow" target="_blank">可靠性内存管理</a>是你的责任。</p><p id="6515" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">Solidity语言还提供了关键字<a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.16/assembly.html#memory-safety" rel="noopener ugc nofollow" target="_blank"> <em class="le">【内存安全】</em> </a> <em class="le"> </em>来更安全地使用内联汇编，并尊重Solidity内存模型。</p><blockquote class="kz la lb"><p id="3320" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">更多详情请参见实体文档中的<a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.14/assembly.html?highlight=storage#conventions-in-solidity" rel="noopener ugc nofollow" target="_blank">惯例</a>部分。</p></blockquote></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="166e" class="mg mh it bd mi mj nv ml mm mn nw mp mq jz nx ka ms kc ny kd mu kf nz kg mw mx bi translated">参考</h1><div class="qv qw gp gr qx qy"><a href="https://blog.openzeppelin.com/ethereum-in-depth-part-2-6339cf6bddb9/" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">以太坊深度，第2部分- OpenZeppelin博客</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">感谢你对这篇文章感兴趣！我们正在进行品牌重塑，所以如果有些名字…</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">blog.openzeppelin.com</p></div></div><div class="rh l"><div class="ri l rj rk rl rh rm ks qy"/></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://www.evm.codes/" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">EVM电码</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">以太坊虚拟机操作码的交互式参考</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">www.evm.codes</p></div></div><div class="rh l"><div class="rn l rj rk rl rh rm ks qy"/></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://github.com/ethereum/solidity" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">GitHub -以太坊/solidity: Solidity，智能契约编程语言</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">您可以在Gitter和Matrix上与我们交流，在Twitter上向我们发推文，或者在Solidity论坛上创建一个新主题。问题…</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">github.com</p></div></div><div class="rh l"><div class="ro l rj rk rl rh rm ks qy"/></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://www.evm.codes/about#memoryexpansion" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">EVM电码</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">以太坊虚拟机(或EVM)是一种基于堆栈的计算机。这意味着所有指令都带参数…</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">www.evm.codes</p></div></div><div class="rh l"><div class="rp l rj rk rl rh rm ks qy"/></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://ethereum.stackexchange.com/questions/9537/how-to-return-dynamic-sized-arrays-original-address-on-the-memory-of-solidity/28457#28457" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">如何返回动态大小数组在Solidity内存中的原始地址？</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">修改为以前的答案不完全正确，因为它在内存中是可能的，但它只能在汇编和…</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">ethereum.stackexchange.com</p></div></div><div class="rh l"><div class="rq l rj rk rl rh rm ks qy"/></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://ethdebug.github.io/solidity-data-representation/" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">固体中的数据表示</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">适用于代码调试器和其他调试相关实用程序的编写人员。作者哈里·奥特曼[@haltman-at]发表…</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">ethdebug.github.io</p></div></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://docs.soliditylang.org/en/v0.8.14/assembly.html?highlight=storage#memory-management" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">在线装配-坚固性0.8.14文件</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">你可以在一种接近以太坊虚拟语言的语言中用内联汇编来交错Solidity语句</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">docs.soliditylang.org</p></div></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://stackoverflow.com/a/33839164/8245387" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">以太坊坚固中，“记忆”关键字的用途是什么？</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">当人们谈论Solidity中的存储和内存时，他们实际上可能指的是这些东西的两种不同用途…</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">stackoverflow.com</p></div></div><div class="rh l"><div class="rr l rj rk rl rh rm ks qy"/></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://ethereum.stackexchange.com/questions/9603/understanding-mload-assembly-function/9610" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">了解mload汇编函数</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">mload(0xAB)加载位于存储器地址0xAB的字(32字节)。例如，mload(0x60)加载位于0x60的字…</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">ethereum.stackexchange.com</p></div></div><div class="rh l"><div class="rs l rj rk rl rh rm ks qy"/></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://docs.soliditylang.org/en/v0.8.15/internals/layout_in_memory.html" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">内存布局- Solidity 0.8.15文档</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">Solidity中有一些操作需要大于64字节的临时存储区，因此不适合…</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">docs.soliditylang.org</p></div></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://docs.soliditylang.org/en/v0.8.16/assembly.html#memory-management" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">在线装配-坚固性0.8.16文件</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">你可以在一种接近以太坊虚拟语言的语言中用内联汇编来交错Solidity语句</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">docs.soliditylang.org</p></div></div></div></a></div><div class="qv qw gp gr qx qy"><a href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Memory.md" rel="noopener  ugc nofollow" target="_blank"><div class="qz ab fo"><div class="ra ab rb cl cj rc"><h2 class="bd iu gy z fp rd fr fs re fu fw is bi translated">主CJ42上的全可靠性/memory . MD/全可靠性</h2><div class="rf l"><h3 class="bd b gy z fp rd fr fs re fu fw dk translated">MSIZE操作码可能会让您认为它返回存储在内存中的数据的实际大小(以字节为单位)。它不…</h3></div><div class="rg l"><p class="bd b dl z fp rd fr fs re fu fw dk translated">github.com</p></div></div><div class="rh l"><div class="rt l rj rk rl rh rm ks qy"/></div></div></a></div></div></div>    
</body>
</html>