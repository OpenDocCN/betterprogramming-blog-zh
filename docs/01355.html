<html>
<head>
<title>SQL Injection and XSS: What White Hat Hackers Know About Trusting User Input</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL注入和XSS:白帽黑客对信任用户输入了解多少</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sql-injection-and-xss-what-white-hat-hackers-know-about-trusting-user-input-379a6131cb99?source=collection_archive---------6-----------------------#2019-09-03">https://betterprogramming.pub/sql-injection-and-xss-what-white-hat-hackers-know-about-trusting-user-input-379a6131cb99?source=collection_archive---------6-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c713" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SQL注入和跨站点脚本的初级读本，以及如何在软件开发中处理用户输入</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/431080b3fa1e4b380c0f2a8a00c3c45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*MWBubin3qw3KytVO.png"/></div></figure><p id="08b8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">软件开发人员有很多想法。当创建一个网站或应用程序时，有无数的问题要问:<em class="lm">我们将使用什么技术？架构将如何设置？我们需要什么功能？UI会是什么样子的</em>？尤其是在一个软件市场，发布新应用似乎更像是一场声誉竞赛，而不是一个经过深思熟虑的过程，最重要的问题之一往往落在“紧急”栏的底部:<em class="lm">我们的产品将如何得到保护？</em></p><p id="84b5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你正在使用一个健壮的开源框架来构建你的产品(如果有一个是可用的，那么你为什么不呢？)那么一些基本的安全问题，如CSRF令牌和密码加密，可能已经为您解决了。尽管如此，快速行动的开发人员将很好地重温他们对常见威胁和陷阱的知识，即使只是为了避免一些令人尴尬的新手错误。通常，你的软件安全性中最薄弱的环节是——你<em class="lm">。</em></p><p id="0de6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我最近对一般的信息安全更感兴趣了，尤其是实践道德黑客。一个<em class="lm">道德黑客</em> r，有时被称为<em class="lm">白帽黑客</em>，有时简称为<em class="lm">黑客</em> r，是搜索可能的安全漏洞并负责任地(私下)将它们报告给项目所有者的人。相比之下，恶意或黑帽黑客(也称为黑客)是利用这些漏洞来娱乐或谋取私利的人。白帽和黑帽黑客可能使用相同的工具和资源，通常试图进入他们不应该去的地方；然而，白帽子这样做是经过许可的，目的是加强防御，而不是摧毁它们。黑帽子是坏人。</p><p id="ea87" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当谈到学习如何发现安全漏洞时，我贪婪地阅读我能得到的任何信息就不足为奇了。这篇文章是一些关键领域的精华，在处理用户输入时对开发者特别有帮助。这些经验教训都是从这些优秀的资源中收集而来的:</p><ul class=""><li id="eb70" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated"><a class="ae lw" href="https://www.owasp.org/index.php/Main_Page" rel="noopener ugc nofollow" target="_blank">开放Web应用安全项目</a>指南</li><li id="ad6f" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated">来自<a class="ae lw" href="https://www.youtube.com/channel/UCsgzmECky2Q9lQMWzDwMhYw/" rel="noopener ugc nofollow" target="_blank"> HackerOne的YouTube频道</a>的Hacker101播放列表</li><li id="a171" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated">彼得·雅沃斯基的网络黑客101 </li><li id="ee92" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated"><a class="ae lw" href="https://brutelogic.com.br/blog/" rel="noopener ugc nofollow" target="_blank">蛮逻辑的博客</a></li><li id="94de" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated"><a class="ae lw" href="https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA" rel="noopener ugc nofollow" target="_blank">电脑爱好者</a> YouTube频道</li><li id="2879" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated">Jason Haddix ( <a class="ae lw" href="https://github.com/jhaddix/" rel="noopener ugc nofollow" target="_blank"> @jhaddix </a>)和Tom Hudson ( <a class="ae lw" href="https://github.com/tomnomnom/" rel="noopener ugc nofollow" target="_blank"> @tomnomnom </a>)是两个有成就的道德黑客，他们使用不同但有效的方法</li></ul><p id="a7b0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可能熟悉这样一个口号，“净化您的输入！”然而，正如我希望这篇文章所展示的，开发一个具有健壮安全性的应用程序并不那么简单。我建议一个替代短语:注意你的输入。让我们通过检查利用该领域中的漏洞的最常见攻击来详细说明:SQL注入和跨站脚本。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ecf6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">SQL注入攻击</h1><p id="3a4c" class="pw-post-body-paragraph kq kr it ks b kt nb ju kv kw nc jx ky kz nd lb lc ld ne lf lg lh nf lj lk ll im bi translated">如果你还不熟悉SQL注入攻击，或SQLi，这里有一个很棒的<a class="ae lw" href="https://www.youtube.com/watch?v=_jKylhJtPmI" rel="noopener ugc nofollow" target="_blank">解释-就像-我是-五个视频</a>。你可能已经从xkcd的小鲍比桌中知道了这次攻击。本质上，恶意行为者可能能够通过您站点上的一些输入发送影响您的应用程序的SQL命令，比如从您的数据库中提取结果的搜索框。用PHP编写的站点特别容易受到这些攻击，成功的SQL攻击对于依赖数据库的软件来说可能是毁灭性的(例如，您的用户表现在是一盆牵牛花)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/05bde897b596b73a79eab8f63979e48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6UeemTSbbqzA58HzsJxtw.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">你没有生存的机会。</p></figure><p id="5018" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以测试您自己的站点，看看您是否容易受到这种攻击。(请只测试您拥有的站点，因为在您没有权限的地方运行SQL注入在您所在的地方可能是非法的；而且普遍不太好笑。)以下有效载荷可用于测试输入:</p><ul class=""><li id="8384" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated"><code class="fe np nq nr ns b">' OR 1='1</code>计算为常量true，成功时返回表中的所有行。</li><li id="a659" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated"><code class="fe np nq nr ns b">' AND 0='1</code>计算结果为常量false，如果成功，则不返回任何行。</li></ul><p id="c3b4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lw" href="https://www.youtube.com/watch?v=ciNHn38EyRc" rel="noopener ugc nofollow" target="_blank">这个视频演示了上面的测试</a>，很好地展示了SQL注入攻击的影响力。</p><p id="a789" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">幸运的是，有很多方法可以减轻SQL注入攻击，它们都归结为一个基本概念:不要相信用户输入。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3164" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">SQL注入缓解</h1><p id="54da" class="pw-post-body-paragraph kq kr it ks b kt nb ju kv kw nc jx ky kz nd lb lc ld ne lf lg lh nf lj lk ll im bi translated">为了有效地减少SQL注入，开发人员必须阻止用户成功地向站点的任何部分提交原始SQL命令。</p><p id="1cca" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一些框架将为您完成大部分繁重的工作。例如，<a class="ae lw" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>通过使用<a class="ae lw" href="https://docs.djangoproject.com/en/2.2/topics/db/queries/" rel="noopener ugc nofollow" target="_blank">查询集</a>实现了<a class="ae lw" href="https://en.wikipedia.org/wiki/Object-relational_mapping" rel="noopener ugc nofollow" target="_blank">对象关系映射</a> (ORM)的概念。我们可以把这些看作包装器函数，帮助您的应用程序使用预定义的方法查询数据库，避免使用原始SQL。</p><p id="5e12" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，能够使用一个框架从来不是一个保证。当直接处理数据库时，我们可以使用其他方法从用户输入中安全地提取SQL查询，尽管它们的效率各不相同。按照从最受欢迎到最不受欢迎的顺序排列，并提供了相关示例的链接:</p><ol class=""><li id="68f2" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll nt lt lu lv bi translated">带有变量绑定的预准备语句(或<a class="ae lw" href="https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank">参数化查询</a>)，</li><li id="eff1" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll nt lt lu lv bi translated"><a class="ae lw" href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html#defense-option-2-stored-procedures" rel="noopener ugc nofollow" target="_blank">存储过程</a>；和</li><li id="d9e3" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll nt lt lu lv bi translated"><a class="ae lw" href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html#defense-option-3-whitelist-input-validation" rel="noopener ugc nofollow" target="_blank">白名单</a>或<a class="ae lw" href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html#defense-option-4-escaping-all-user-supplied-input" rel="noopener ugc nofollow" target="_blank">避开</a>用户输入。</li></ol><p id="9f78" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您想实现上述技术，链接的备忘单是深入研究的一个很好的起点。可以说，使用这些技术来获取数据，而不是使用原始的SQL查询，有助于最大限度地减少应用程序中接受用户输入的任何部分处理SQL的机会，从而减少SQL注入攻击。</p><p id="7a35" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，这场战斗只赢了一半…</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3f1b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">跨站点脚本(XSS)攻击</h1><p id="c2c9" class="pw-post-body-paragraph kq kr it ks b kt nb ju kv kw nc jx ky kz nd lb lc ld ne lf lg lh nf lj lk ll im bi translated">如果你是一个恶意的程序员，JavaScript几乎是你最好的朋友。正确的命令可以做合法用户在网页上可以做的任何事情(甚至一些他们不应该做的事情)，有时不需要实际用户的任何交互。<a class="ae lw" href="https://en.wikipedia.org/wiki/Cross-site_scripting" rel="noopener ugc nofollow" target="_blank">跨站脚本</a>攻击，或称XSS，发生在JavaScript代码被注入网页并改变网页行为的时候。它的影响范围从恶作剧滋扰事件到更严重的身份验证绕过或凭证窃取。<a class="ae lw" href="https://blogs.apache.org/infra/entry/apache_org_04_09_2010" rel="noopener ugc nofollow" target="_blank">2010年来自Apache的这份事件报告</a>是一个很好的例子，说明了XSS如何在一场更大的攻击中被捆绑起来，以接管帐户和机器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nu"><img src="../Images/0cd3ff5a28a0ad7fc52db32ddf4d7324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8mgaieGKwrQPe7NnyTVenw.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">一年一度的DOM舞蹈大赛迎来了一位不速之客</p></figure><p id="6c81" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">XSS可以发生在服务器或客户端，通常有三种类型:基于DOM- ( <a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank">文档对象模型</a>)的、存储的和反射的XSS。不同之处在于攻击负载注入应用程序的位置。</p><h2 id="090c" class="nv mk it bd ml nw nx dn mp ny nz dp mt kz oa ob mv ld oc od mx lh oe of mz og bi translated">基于DOM的XSS</h2><p id="2887" class="pw-post-body-paragraph kq kr it ks b kt nb ju kv kw nc jx ky kz nd lb lc ld ne lf lg lh nf lj lk ll im bi translated">当JavaScript有效负载影响用户在浏览器中加载的网页的结构、行为或内容时，就会发生基于DOM的XSS。这些通常是通过修改后的URL执行的，例如在<a class="ae lw" href="https://www.owasp.org/index.php/Phishing" rel="noopener ugc nofollow" target="_blank">钓鱼电子邮件</a>中。</p><p id="94cf" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了了解注入的JavaScript操纵页面有多容易，我们可以用一个HTML web页面创建一个工作示例。尝试使用以下HTML和JavaScript代码在您的本地系统上创建一个名为<code class="fe np nq nr ns b">xss-test.html</code>(或者您喜欢的任何名称)的文件:</p><pre class="kj kk kl km gt oh ns oi oj aw ok bi"><span id="529b" class="nv mk it ns b gy ol om l on oo">&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;My XSS Example&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1 id="greeting"&gt;Hello there!&lt;/h1&gt;<br/>&lt;script&gt;<br/>var name = new URLSearchParams(document.location.search).get('name');<br/>if (name !== 'null') {<br/>document.getElementById('greeting').innerHTML = 'Hello ' + name + '!';<br/>}<br/>&lt;/script&gt;<br/>&lt;/h1&gt;<br/>&lt;/html&gt;</span></pre><p id="d6aa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该网页将显示标题“你好！”除非它从带有值为<code class="fe np nq nr ns b">name</code>的查询字符串中接收到一个<a class="ae lw" href="https://en.wikipedia.org/wiki/Query_string" rel="noopener ugc nofollow" target="_blank"> URL参数。要查看脚本的工作情况，请在浏览器中打开附加了URL参数的页面，如下所示:</a></p><p id="2490" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ns b">file:///path/to/file/xss-test.html?name=Victoria</code></p><p id="937e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">好玩吧。我们的不安全(从安全的角度来说，而不是从情感的角度来说)页面接受<code class="fe np nq nr ns b">name</code>的URL参数值，并将其显示在DOM中。页面希望这个值是一个友好的字符串，但是如果我们把它改成别的什么呢？由于该页面归我们所有，并且只存在于我们的本地系统中，所以我们可以随心所欲地测试它。如果我们将<code class="fe np nq nr ns b">name</code>参数改为<code class="fe np nq nr ns b">&lt;img+src+onerror=alert("pwned")&gt;</code>，会发生什么？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi op"><img src="../Images/43c5e76e05356b6483f5208dbb9130ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_lXswqwVg4wXpyORZ_kRQ.png"/></div></div></figure><p id="677f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这只是一个例子，很大程度上基于<a class="ae lw" href="https://brutelogic.com.br/blog/dom-based-xss-the-3-sinks/" rel="noopener ugc nofollow" target="_blank"> Brute的帖子</a>中的一个，展示了XSS攻击是如何执行的。有趣的弹出警报可能很有趣，但JavaScript可能会造成很多危害，包括帮助恶意攻击者窃取密码和个人信息。</p><h2 id="b89a" class="nv mk it bd ml nw nx dn mp ny nz dp mt kz oa ob mv ld oc od mx lh oe of mz og bi translated">存储和反射XSS</h2><p id="102c" class="pw-post-body-paragraph kq kr it ks b kt nb ju kv kw nc jx ky kz nd lb lc ld ne lf lg lh nf lj lk ll im bi translated"><a class="ae lw" href="https://en.wikipedia.org/wiki/Cross-site_scripting#Persistent_(or_stored)" rel="noopener ugc nofollow" target="_blank">存储XSS </a>当攻击有效载荷存储在服务器上时，例如存储在数据库中。每当在浏览器中检索和呈现存储的数据时，攻击都会影响受害者。例如，不使用URL查询字符串，攻击者可能会更新他们在社交网站上的个人资料页面，在“关于我”部分包含一个隐藏脚本。该脚本不正确地存储在站点的服务器上，稍后当另一个用户查看攻击者的配置文件时会成功执行。</p><p id="90ed" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">其中一个最著名的例子是2005年几乎接管MySpace的Samy蠕虫病毒。它通过发送HTTP请求进行传播，每当查看受感染的配置文件时，该请求会将其复制到受害者的配置文件页面上。在短短20小时内，它已经传播到超过100万用户。</p><p id="a866" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当注入的有效载荷传播到服务器时，反射XSS 类似地发生，但是，恶意代码最终没有存储在数据库中。而是由web应用程序立即返回给浏览器。通过引诱受害者点击向易受攻击网站的服务器发送请求的恶意链接，可能会执行此类攻击。然后，服务器将向攻击者和受害者发送响应，这可能导致攻击者能够获取密码或实施看似来自受害者的操作。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="85be" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">XSS攻击缓解</h1><p id="43e1" class="pw-post-body-paragraph kq kr it ks b kt nb ju kv kw nc jx ky kz nd lb lc ld ne lf lg lh nf lj lk ll im bi translated">在所有这些情况下，XSS攻击可以通过两个关键策略来缓解:验证表单字段，以及避免用户在网页上直接输入。</p><h2 id="13a4" class="nv mk it bd ml nw nx dn mp ny nz dp mt kz oa ob mv ld oc od mx lh oe of mz og bi translated">验证表单域</h2><p id="8dde" class="pw-post-body-paragraph kq kr it ks b kt nb ju kv kw nc jx ky kz nd lb lc ld ne lf lg lh nf lj lk ll im bi translated">框架可以再次帮助我们确保用户提交的表单是正确的。一个例子是<a class="ae lw" href="https://docs.djangoproject.com/en/2.2/ref/forms/fields/#built-in-field-classes" rel="noopener ugc nofollow" target="_blank"> Django内置的</a> <code class="fe np nq nr ns b"><a class="ae lw" href="https://docs.djangoproject.com/en/2.2/ref/forms/fields/#built-in-field-classes" rel="noopener ugc nofollow" target="_blank">Field</a></code> <a class="ae lw" href="https://docs.djangoproject.com/en/2.2/ref/forms/fields/#built-in-field-classes" rel="noopener ugc nofollow" target="_blank">类</a>，它提供了验证一些常用类型的字段，还指定了相同的默认值。例如，Django的<code class="fe np nq nr ns b">EmailField</code>使用一组规则来确定提供的输入是否是有效的电子邮件。如果提交的字符串中包含电子邮件地址中不常见的字符，或者没有模仿电子邮件地址的常见格式，那么Django不会认为该字段有效，表单也不会被提交。</p><p id="6aa8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果依赖框架不可行，我们可以实现自己的输入验证。这可以通过几种不同的技术来实现，包括<a class="ae lw" href="https://en.wikipedia.org/wiki/Type_conversion" rel="noopener ugc nofollow" target="_blank">类型转换</a>:例如，确保一个数字的类型是<code class="fe np nq nr ns b">int()</code>；检查数字和字符串长度的最小和最大范围值；使用预定义的选择数组，避免任意输入，例如一年中的几个月；以及对照严格的<a class="ae lw" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank">正则表达式</a>检查数据。</p><p id="9fbd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">谢天谢地，我们不必从头开始。开源资源可以提供帮助，例如<a class="ae lw" href="https://www.owasp.org/index.php/OWASP_Validation_Regex_Repository" rel="noopener ugc nofollow" target="_blank"> OWASP验证正则表达式存储库</a>，它提供了一些常见数据形式的匹配模式。许多编程语言都提供了特定于它们语法的验证库，我们可以在GitHub 上找到很多这样的库。此外，<a class="ae lw" href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" rel="noopener ugc nofollow" target="_blank"> XSS滤波器规避备忘单</a>对测试有效载荷有一些建议，我们可以用它们来测试我们现有的应用。</p><p id="9957" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然这看起来很乏味，但正确实现的输入验证可以保护我们的应用程序不受XSS的影响。</p><h2 id="abb1" class="nv mk it bd ml nw nx dn mp ny nz dp mt kz oa ob mv ld oc od mx lh oe of mz og bi translated">避免直接喷射</h2><p id="2b8f" class="pw-post-body-paragraph kq kr it ks b kt nb ju kv kw nc jx ky kz nd lb lc ld ne lf lg lh nf lj lk ll im bi translated">应用程序中直接将用户输入返回到浏览器的元素，在不经意间可能并不明显。我们可以通过探究几个问题来确定应用程序中可能存在风险的领域:</p><ul class=""><li id="5fd1" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">数据如何流经我们的应用程序？</li><li id="3deb" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated">当用户与这个输入交互时，他们期望发生什么？</li><li id="78db" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated">数据出现在我们页面的什么位置？它是嵌入在字符串中还是属性中？</li></ul><p id="957d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里有一些示例负载，我们可以使用它们来测试我们站点上的输入(同样，只有我们自己的站点！)由<a class="ae lw" href="https://www.hacker101.com/" rel="noopener ugc nofollow" target="_blank">黑客101 </a>提供。成功执行这些示例中的任何一个都可能表示由于直接注入而可能存在XSS漏洞。</p><ul class=""><li id="68ee" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated"><code class="fe np nq nr ns b">"&gt;&lt;h1&gt;test&lt;/h1&gt;</code></li><li id="1566" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated"><code class="fe np nq nr ns b">'+alert(1)+'</code></li><li id="9c81" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated"><code class="fe np nq nr ns b">"onmouserover="alert(1)</code></li><li id="1e68" class="ln lo it ks b kt lx kw ly kz lz ld ma lh mb ll ls lt lu lv bi translated"><code class="fe np nq nr ns b">http://"onmouseover="alert(1)</code></li></ul><p id="86e3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为一般规则，如果您能够围绕直接注入输入进行设计，那么就这样做。或者，一定要完全理解你选择的方法的效果；例如，在JavaScript中使用<code class="fe np nq nr ns b">innerText</code>而不是<code class="fe np nq nr ns b">innerHTML</code>将确保内容被设置为纯文本，而不是潜在易受攻击的HTML。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="eaa8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">注意你的输入</h1><p id="098c" class="pw-post-body-paragraph kq kr it ks b kt nb ju kv kw nc jx ky kz nd lb lc ld ne lf lg lh nf lj lk ll im bi translated">当与黑帽黑客竞争时，软件开发人员处于明显的劣势。尽管我们做了大量工作来保护每一个可能危及我们应用的输入，但攻击者只需找到我们遗漏的那一个。这就像在所有的门上安装了插销，但却开着一扇窗！</p><p id="a72c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，通过学会像攻击者一样思考，我们可以更好地准备我们的软件来对抗坏人。尽可能快地发布特性可能令人兴奋，但是如果我们事先花时间仔细考虑应用程序的流程，遵循数据，并注意我们的输入，我们将避免积累大量的安全债务。</p></div></div>    
</body>
</html>