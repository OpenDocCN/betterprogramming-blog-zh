<html>
<head>
<title>Lifecycle Methods 101: Adding and Unmounting a Countdown</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生命周期方法101:添加和卸载倒计时</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lifecycle-methods-101-adding-and-unmounting-a-countdown-a6922a8ead8?source=collection_archive---------21-----------------------#2020-03-18">https://betterprogramming.pub/lifecycle-methods-101-adding-and-unmounting-a-countdown-a6922a8ead8?source=collection_archive---------21-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">取消componentWillUnmount方法中的所有订阅和异步任务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ea749ecb3ae311ec7dad7bc2fd76bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TufLjVHe4I_IxZJMHXeeA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="http://pexels.com" rel="noopener ugc nofollow" target="_blank">pexels.com</a></p></figure><p id="a8bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将介绍以下React生命周期方法:<code class="fe lv lw lx ly b">ComponentDidMount</code>、<code class="fe lv lw lx ly b">ComponentDidUpdate</code>和<code class="fe lv lw lx ly b">ComponentWillUnmount</code>。如果你需要复习它们是什么，读读这个故事。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b9e1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们将建造什么</h1><p id="4041" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们将构建一个简单的应用程序，一个倒计时，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d3c9241e788f37085365279ab831392a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Pxo_BLKDzaQoxHx_2RQKMw.gif"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7f6b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第一步。设置</h1><p id="ef32" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我创建了一个React应用程序之后，我创建了一个<code class="fe lv lw lx ly b">Timer</code>类组件。它被初始化为一个状态<code class="fe lv lw lx ly b">timeLeft: 15</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="da15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我的<code class="fe lv lw lx ly b">index.css</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a7b4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第二步。componentDidMount中的setInterval</h1><p id="98b3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，当我们的页面加载时，我们希望倒计时立即开始。因此，我们将在<code class="fe lv lw lx ly b">componentDidMount</code>中放置一个<code class="fe lv lw lx ly b">setInterval</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每秒钟状态都会更新，随后页面上呈现的数字也会更新。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="524a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第三步。条件渲染</h1><p id="5675" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们添加条件渲染:如果<code class="fe lv lw lx ly b">timeLeft</code>是0，我们希望看到“KABOOM！”让我们添加一个<code class="fe lv lw lx ly b">console.log</code>以便跟踪状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="491a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以看到，一旦状态变为<code class="fe lv lw lx ly b">0</code>，就会弹出一个漂亮的动画。</p><p id="61a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这并不是我们旅程的终点，因为尽管它看起来没问题，但我们现在正在经历内存泄漏——在后台，状态仍在进行不必要的更新:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/4e025be5fffdea4b2345d9a605590536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89Ub2uzW-4YjLBnI_-IzbQ.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c3c4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第四步。componentDidUpdate中的clearInterval</h1><p id="f206" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们保护自己免受这种丑陋的内存泄漏。为此，我们将在<code class="fe lv lw lx ly b">componentDidUpdate</code>中设置一个跟踪器，如果<code class="fe lv lw lx ly b">timeLeft</code>为0，它将清除间隔。</p><p id="832b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提醒一下，<code class="fe lv lw lx ly b">componentDidUpdate</code>是在每次<code class="fe lv lw lx ly b">state</code>或<code class="fe lv lw lx ly b">props</code>更新后触发的方法。</p><pre class="kj kk kl km gt nh ly ni nj aw nk bi"><span id="0032" class="nl mh it ly b gy nm nn l no np">componentDidUpdate(prevProps, prevState){<br/>  if (prevState.timeLeft == 1){<br/>   clearInterval(this.interval)<br/>  }<br/>}</span></pre><p id="aae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong> : <strong class="lb iu"> </strong> <code class="fe lv lw lx ly b">componentDidUpdate</code>以这个特定的顺序接受两个参数，所以即使我们没有使用<code class="fe lv lw lx ly b">prevProps</code>，我们仍然需要把它们放在那里。</p><p id="9455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后台不再发生内存泄漏。然而，想象一下，当计时器运行时，在计时器变为0之前，我们的用户点击了页面上的某个东西。</p><p id="547a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将导致一个难看的错误和长期内存泄漏:</p><pre class="kj kk kl km gt nh ly ni nj aw nk bi"><span id="e565" class="nl mh it ly b gy nm nn l no np">Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.</span></pre><p id="9778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也需要针对这种情况的安全措施！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5b6a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第五步。组件中的clearInterval将卸载</h1><p id="cc90" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，我们将使用<code class="fe lv lw lx ly b">componentWillUnmount</code>，这是一个在组件从页面中卸载(消失)之前触发的方法:</p><pre class="kj kk kl km gt nh ly ni nj aw nk bi"><span id="e262" class="nl mh it ly b gy nm nn l no np">componentWillUnmount(){<br/>  clearInterval(this.interval)<br/>}</span></pre><p id="8fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们不会有内存泄漏了。</p><p id="9abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的代码现在应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想进一步练习React生命周期方法，试试<a class="ae ky" href="https://medium.com/better-programming/react-lifecycle-methods-101-adding-a-title-to-your-page-8781eba042cd" rel="noopener">给你的页面添加一个标题</a>！</p></div></div>    
</body>
</html>