<html>
<head>
<title>Speed Up Your Python Codebases With C Extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C扩展加速你的Python代码库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/speed-up-your-python-codebases-with-c-extensions-94859875eb70?source=collection_archive---------2-----------------------#2021-07-19">https://betterprogramming.pub/speed-up-your-python-codebases-with-c-extensions-94859875eb70?source=collection_archive---------2-----------------------#2021-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7aa4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给你的Python程序带来C语言的速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7346b58af6c87b64b3619ad454485718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*McmBZ4VIG2PyTt6D"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sumo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">保罗·史密斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bcee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python既简单又强大，已经成为最流行的编程语言之一。尽管如此，它有时缺乏像C和Java这样的静态类型和预编译编程语言的宝贵速度。</p><h1 id="33b8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Python为什么慢？</h1><p id="63d1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可能知道，Python一般是通过一个<a class="ae ky" href="https://g.co/kgs/eJyYmN" rel="noopener ugc nofollow" target="_blank">解释器</a>实现的。与C和Java等语言相比，这可能会导致代码执行相当缓慢，这些语言具有编译的实现，并且其源代码被预先编译成<a class="ae ky" href="https://g.co/kgs/rAZgv2" rel="noopener ugc nofollow" target="_blank">机器</a> / <a class="ae ky" href="https://g.co/kgs/WuXQ2o" rel="noopener ugc nofollow" target="_blank">字节</a>代码。但是，这个主题超出了本文的范围。</p><h1 id="e066" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何提高Python代码的速度？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/5875cba01edeb4f11121d2779fe8616b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*sYcWbMDK22JLyXNIFgQ0FA.png"/></div></figure><p id="c11c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非必须执行计算量很大的操作，否则Python的速度通常不是问题。这就是C扩展派上用场的地方。</p><p id="87fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mt"> C扩展是一种用C编写函数、将它们编译成Python模块并在源代码中作为普通Python库使用的方法。</em></p><p id="3620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好的性能和/或低级功能，许多流行的模块实际上是用C或C++(例如<code class="fe mu mv mw mx b"><a class="ae ky" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank">numpy</a>, <a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">pandas</a>, <a class="ae ky" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank">tensorflow</a>…</code>)编写的。</p><p id="23fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些快速免责声明:</p><ul class=""><li id="b676" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">c扩展不适用于除了<a class="ae ky" href="https://en.wikipedia.org/wiki/CPython" rel="noopener ugc nofollow" target="_blank"> Cpython </a>之外的Python实现。这应该不是问题，因为Cpython是默认的。</li><li id="5827" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">建议您具备C编程语言的基础知识。然而，如果你只懂Python，你应该可以毫无问题地理解。</li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="6e2d" class="lv lw it bd lx ly nt ma mb mc nu me mf jz nv ka mh kc nw kd mj kf nx kg ml mm bi translated">如何构建一个C扩展</h1><p id="d34e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作为一个例子，让我们实现经典的<code class="fe mu mv mw mx b">fib(n)</code>函数。<code class="fe mu mv mw mx b">fib(n)</code>接受一个数字<code class="fe mu mv mw mx b">n</code>，并返回斐波那契数列中相应的数字。然后我们将比较Python和C版本的性能。</p><p id="4ae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先你需要Python C API <code class="fe mu mv mw mx b">Python.h</code>。这是一个C头文件<a class="ae ky" href="https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html#:~:text=A%20header%20file%20is%20a,Header%20files%20serve%20two%20purposes." rel="noopener ugc nofollow" target="_blank">包含了与Python接口所需的一切。</a></p><h2 id="a7d4" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">Python API安装</h2><ul class=""><li id="e1d1" class="my mz it lb b lc mn lf mo li ok lm ol lq om lu nd ne nf ng bi translated">在Linux上，你通常必须安装<code class="fe mu mv mw mx b">python-dev</code>或<code class="fe mu mv mw mx b">python3-dev</code>包，如果还没有的话。(请注意，在某些发行版中，软件包名称可能会有所不同)</li><li id="2c5b" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">默认情况下，如果用默认安装程序安装，Windows应该附带Python。</li><li id="f5a2" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">MacOs也应该自带Python。如果没有，<code class="fe mu mv mw mx b">brew reinstall python</code>应该可以解决这个问题。</li></ul><p id="d789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，打开您选择的代码编辑器并创建C模块文件。它应该按照惯例来命名——类似于<code class="fe mu mv mw mx b">module_name.c</code>，尽管你可以随意命名。这里我们称之为<code class="fe mu mv mw mx b">c_module.c</code>。</p><p id="5a73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始编写扩展代码之前，您需要包含一些核心定义和声明。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="0a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于兼容性目的，建议您将这些行放在文件的开头<a class="ae ky" href="https://docs.python.org/3/c-api/intro.html#:~:text=Since%20Python%20may%20define%20some%20pre-processor%20definitions%20which%20affect%20the%20standard%20headers%20on%20some%20systems%2C%20you%20must%20include%20Python.h%20before%20any%20standard%20headers%20are%20included." rel="noopener ugc nofollow" target="_blank"/>。</p><p id="cb75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为在Python中一切都是对象，所以我们的<code class="fe mu mv mw mx b">c_fib(n)</code>函数应该返回一个对象，确切地说是一个<code class="fe mu mv mw mx b">PyObject</code>指针(在<code class="fe mu mv mw mx b">Python.h</code>中定义)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后需要<em class="mt">声明从模块中导出哪些函数</em>以使Python可以访问它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="8395" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">定义模块方法</h2><p id="9707" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每个导出的方法都表示为一个结构，包括:</p><ul class=""><li id="dd6a" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">导出的方法名(在本例中为<code class="fe mu mv mw mx b">"c_fib”</code>)</li><li id="5591" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">要导出的实际方法(<code class="fe mu mv mw mx b">c_fib</code>)</li><li id="c41a" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">方法采用的参数类型(在本例中为<code class="fe mu mv mw mx b">METH_VARARGS</code>)。这来自于关于<code class="fe mu mv mw mx b">METH_VARARGS</code> : <em class="mt">的文档“这是典型的调用约定，其中方法具有类型</em> <code class="fe mu mv mw mx b"><em class="mt">PyCFunction</em></code> <em class="mt">。该函数期望两个</em> <code class="fe mu mv mw mx b"><em class="mt">PyObject*</em></code> <em class="mt">值。第一个是</em> <code class="fe mu mv mw mx b"><em class="mt">self</em></code> <em class="mt">对象为方法；对于模块函数，它是模块对象。第二个参数(通常称为</em> <code class="fe mu mv mw mx b"><em class="mt">args</em></code> <em class="mt">)是一个表示所有参数的元组对象。”</em></li><li id="c569" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">描述该方法的<code class="fe mu mv mw mx b">const char*</code></li></ul><h2 id="a1f5" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">定义模块</h2><p id="1b09" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该模块表示为一个结构，如上面的代码所示。它是自文档化的，除了我们设置为<code class="fe mu mv mw mx b">-1</code>的<a class="ae ky" href="https://docs.python.org/3/c-api/module.html#:~:text=PyDoc_STRVAR%20is%20used.-,Py_ssize_t%20m_size,-%C2%B6" rel="noopener ugc nofollow" target="_blank"> m_size </a>参数。从文档中:</p><blockquote class="op oq or"><p id="58b8" class="kz la mt lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">将<code class="fe mu mv mw mx b">m_size</code>设置为<code class="fe mu mv mw mx b">-1</code>意味着模块不支持子解释器，因为它具有全局状态。</p></blockquote><h2 id="bb38" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">模块初始化功能</h2><p id="b449" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当模块被导入并初始化时，调用<code class="fe mu mv mw mx b">PyMODINIT_FUNC</code>。注意，函数名必须以<code class="fe mu mv mw mx b">PyInit_</code>开头，以模块名结尾，因此是<code class="fe mu mv mw mx b">PyInit_c_module()</code>。</p><p id="8491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些只是Python API的一些功能。欲了解更多信息和特性，请访问API的<a class="ae ky" href="https://docs.python.org/3/c-api/index.html" rel="noopener ugc nofollow" target="_blank">文档页面</a>。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="8520" class="lv lw it bd lx ly nt ma mb mc nu me mf jz nv ka mh kc nw kd mj kf nx kg ml mm bi translated">将您的扩展编译成Python模块</h1><p id="b846" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一旦C代码完成，你必须把它编译成Python模块。幸运的是，有很多内置工具可以让你做到这一点。</p><p id="58cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个Python脚本，通常命名为<code class="fe mu mv mw mx b">setup.py</code>，并插入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个脚本有很多功能，但是我们将只使用<code class="fe mu mv mw mx b">build</code>和<code class="fe mu mv mw mx b">install</code>命令。有关更多信息，请查看<a class="ae ky" href="https://docs.python.org/3/distutils/setupscript.html" rel="noopener ugc nofollow" target="_blank">文档</a>或运行带有帮助标志的脚本:</p><pre class="kj kk kl km gt ov mx ow ox aw oy bi"><span id="4784" class="ny lw it mx b gy oz pa l pb pc"> python3 setup.py --help</span></pre><p id="af6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从命令行运行以下命令:</p><pre class="kj kk kl km gt ov mx ow ox aw oy bi"><span id="2418" class="ny lw it mx b gy oz pa l pb pc">python3 setup.py build</span></pre><p id="ff30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个名为<code class="fe mu mv mw mx b">build</code>的目录，并将编译后的库放入其中。完成后，运行以下命令:</p><pre class="kj kk kl km gt ov mx ow ox aw oy bi"><span id="0bc3" class="ny lw it mx b gy oz pa l pb pc">python3 setup.py install</span></pre><p id="545d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在您的系统上安装刚刚构建的库，使它们可以从任何地方访问。</p><p id="7ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mt">请注意，您可能需要root/admin权限才能这样做。你不必在系统范围内安装它，但是如果你跳过安装过程，你将不得不使用</em> <a class="ae ky" href="https://realpython.com/absolute-vs-relative-python-imports/" rel="noopener ugc nofollow" target="_blank"> <em class="mt">相对导入</em> </a> <em class="mt">来使用扩展。</em></p><h1 id="e14b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在Python程序中使用C扩展</h1><p id="87cd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Python文件中，使用您选择的名称导入新创建的模块。在我们的例子中，它是<code class="fe mu mv mw mx b">c_module</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="0124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该扩展可以像任何其他Python模块一样使用。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="0678" class="lv lw it bd lx ly nt ma mb mc nu me mf jz nv ka mh kc nw kd mj kf nx kg ml mm bi translated">与普通Python版本相比如何？</h1><p id="7208" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在让我们比较一下<code class="fe mu mv mw mx b">c_fib</code>函数和它的普通Python对应物。我们将使用内置的<code class="fe mu mv mw mx b">time</code>模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ov mx ow ox aw oy bi"><span id="7516" class="ny lw it mx b gy oz pa l pb pc">Input: 5<br/>py_res=5, py_time=5.245208740234375e-06<br/>c_res=5, c_time=1.6689300537109375e-06</span></pre><p id="1e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不出所料，C函数更快。</p><p id="b67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mt">注意，你可能在不同的机器上得到不同的时间，但是相同代码的C版本总是更快。</em></p><p id="e872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们尝试一些更大的数字:</p><pre class="kj kk kl km gt ov mx ow ox aw oy bi"><span id="6357" class="ny lw it mx b gy oz pa l pb pc">Input: 10<br/>py_res=55, py_time=3.147125244140625e-05<br/>c_res=55, c_time=2.6226043701171875e-06</span><span id="47dd" class="ny lw it mx b gy pd pa l pb pc">Input: 30<br/>py_res=832040, py_time=0.40490126609802246<br/>c_res=832040, c_time=0.004115581512451172</span><span id="9d5a" class="ny lw it mx b gy pd pa l pb pc">Input: 40<br/>py_res=102334155, py_time=50.17047834396362<br/>c_res=102334155, c_time=0.4414968490600586</span></pre><p id="e568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当涉及到大数时，C版本明显优于Python版本。如果您只需要做一些简单的计算，可能不值得用C实现它们，因为性能差异很小。然而，对于非常耗时的操作或需要重复多次的函数，Python的速度可能不够。</p><p id="7ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是C扩展真正大放异彩的地方。您可以将所有繁重的工作留给C，但仍然使用Python作为您的主要语言。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="7881" class="lv lw it bd lx ly nt ma mb mc nu me mf jz nv ka mh kc nw kd mj kf nx kg ml mm bi translated">C扩展的真实用例</h1><p id="4d20" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设您必须执行一些繁重的计算，无论是加密算法、深度学习模型训练还是处理大量数据。c扩展可以减轻Python的负担，加快应用程序的速度。</p><p id="10c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想构建一个低级接口或者直接在Python内存上工作，那会怎么样？如果你知道如何处理原始指针，那么c扩展是一个不错的选择。</p><p id="f455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何优化一个已经存在的Python应用程序，该应用程序性能很差，但您不想(或不能)用另一种语言重写它？c扩展是答案。</p><p id="625f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果您只是一个希望自己的代码尽可能快地运行的优化顽固分子，但您仍然想要一些用于网络、GUI等的高级抽象，该怎么办呢？在这种情况下，C扩展绝对是你最好的朋友。</p><blockquote class="pe"><p id="516f" class="pf pg it bd ph pi pj pk pl pm pn lu dk translated">时间是我们总是希望拥有更多的东西。明智地投资。</p></blockquote></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="315b" class="lv lw it bd lx ly nt ma mb mc nu me mf jz nv ka mh kc nw kd mj kf nx kg ml mm bi translated">结论</h1><p id="6923" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">无论您是沉迷于性能和效率的Python开发人员，还是喜欢混合使用不同技术的人，或者您只是想尝试一些新东西，Python的C扩展都是您开发人员工具箱中的绝佳补充。它们不仅为您提供了几乎免费的性能，还可以扩展Python的功能，将它从过时的技术堆栈中拯救出来。</p><p id="d038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>