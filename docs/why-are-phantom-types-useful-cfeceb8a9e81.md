# 为什么幻影类型有用？

> 原文：<https://betterprogramming.pub/why-are-phantom-types-useful-cfeceb8a9e81>

## 使用 Elm 编程语言

![](img/a6b7615861f76284fdea08b776e8cfe1.png)

本·科林斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

在这篇文章中，我们将慢慢揭开什么是幻影类型，以及为什么它们可能有用。

我们将使用 Elm 作为编程语言的例子，但是如果你懂一点其他支持类型参数的编程语言，你可能会明白。

首先，让我们从一个定义开始:

> "幻象类型是具有一个或多个未使用的类型参数的自定义类型."

这是一个幻影类型的例子。

```
type Length unit = Length Int
```

为了理解这是什么以及为什么它可能有用，我们将从理解他们可以解决的问题开始。

让我们从这段 elm 代码开始。

```
meter : Int 
meter = 1twoMeters : Int 
twoMeters = meter + meterkilometer : Int 
kilometer = 1twoKilometers : Int 
twoKilometers = kilometer + kilometer
```

这完全没问题。然而，在这段代码中有一个错误等待着我们去犯。看看这个:

```
test : Int 
test = meter + kilometer> test 
> 2
```

这是不对的。不先换算一下就把一米加到一公里上是没有意义的。发生了什么事？

错就错在我们加了两个意思不一样的东西；两个不相容的概念。我们把单位“米”和“公里”混在一起，结果毫无意义。

一个可能出现的问题是:“如果不先换算就把一公里加到一米上是没有意义的，怎么可能这样做？”

这个错误是可能的，因为在编写这个程序时，我们将“米”的概念和“公里”的概念抽象为“整数”的概念。

抽象是“忘记”或“省略”细节的过程。在这种情况下，我们采用一个概念“长度”，它有一个“单位”和一个“数量”组件，我们将其抽象为一个“整数”，一个只有，因此只能捕获“数量”组件的概念。在这个抽象的过程中，我们“省略”了一个重要的细节，即“单元”组件；决定两个给定长度的加法是否有意义的分量。这就是电脑不阻止你添加“米”和“公里”的原因。它不知道“米”或“公里”，它们是我们抽象出来的“单位”。

好了，我们现在理解了可能出错的原因:在表示概念“长度”时，我们执行了一个抽象步骤，“省略”了“单位”组件。因此，不可能再用不同的单位来区分长度，因此可以添加隐含不同单位的长度。

让我们试着想出一个防止这种错误发生的方法。

记住,“长度”的概念有“单位”和“数量”两部分。整数已经捕获了“数量”部分，所以为了确保我们永远不会将不同单位的长度相加，我们只需要找出一种方法来告诉计算机:

*   具体“长度”的“单位”是什么。
*   它应该防止两个没有相同“单位”的“长度”相加。

如何着手此事？

一种方法是将“单位”和“数量”组件存储在一个`Length`数据结构中。然后，在我们组合两个长度之前，我们首先比较它们的“单位”，以确保操作有意义。

```
type Unit = Meters | Kilometerstype Length = Length Unit Intadd : Length -> Length -> Maybe Length 
add (Length unitA a) (Length unitB b) = 
 if unitA == unitB then 
   Just (Length unitA (a + b))  else 
   Nothing
```

如果我们现在犯了一个错误，至少我们不会变得毫无意义。不过，它也有一些缺点。

*   当我们犯了错误，只有在运行时才变得明显。虽然没有之前那么微妙，但它可能仍然是一个 bug。
*   我们必须想出一个特别的方法来处理单元不相同的情况。在这种情况下，我选择返回一个“可能长度”,但我也可以选择返回“结果单位错误长度”或更自定义的内容。
*   现在，每个被调用者都必须处理错误情况，即使他们确信自己没有犯任何错误。

我认为我们可以做得更好。

也许我们可以在类型系统中编码“单元”组件。这样我们就可以在运行时完全防止错误发生，所以我们不必处理任何错误情况。

让我们通过为每个支持的“单元”定义一个自定义类型来尝试这样做。

```
type Meters = Meters Int
type Kilometers = Kilometers IntaddMeters : Meters -> Meters -> Meters 
addMeters (Meters a) (Meters b) = 
   Meters (a + b)

addKilometers : Kilometers -> Kilometers -> Kilometers 
addKilometers (Kilometers a) (Kilometers a) = 
   Kilometers (a + b)
```

好的，这是可行的，不太可能意外地把米加到公里上，但仍然是次优的。

*   我们希望在“长度”上支持的每个函数都需要为每个支持的“单元”重新实现(例如，如果我们希望支持减法，会发生什么？).所有这些函数都遵循完全相同的结构。不是很干。
*   每当我们想要支持一个新的“单元”时，我们需要为那个“单元”重新实现所有支持的“长度”函数。再说一遍，不是很干。

我们已经得到了我们想要的运行时属性，但是一遍又一遍地重新实现相同功能的成本不是我愿意接受的。也许有一种方法可以概括这一点；只实现所有这些功能一次，并且能够为所有“单元”重用它们。

让我们再来看看上面定义的类型。

```
type Meters = Meters Int 
type Kilometers = Kilometers Int
```

我们可以将这些定义理解为预先填充了“单位”成分的“长度”概念的表示。`Meters`类型具有“长度”的含义，其中“单位”组件始终为米，“T2”也是如此。有没有办法“拉出”那个预填充的“单元”？我们能不能定义一个有意义的东西“一个‘长度’，其中‘单位’分量是 X”。

这是幻影类型开始变得有趣的地方。这正是我们要找的。它概括了以前的方法。

让我们再来看一下定义:

> "幻象类型是具有一个或多个未使用的类型参数的自定义类型."

既然我们理解了它们可以解决的问题，我们也可以用一种稍微不同的方式来描述它们。

> "幻影类型可以用来赋予相同的数据结构不同的含义."

让我们来看看他们的行动:

```
type Length unit = Length Int — (1)type Meters = Meters — (2) 
type Kilometers = Kilometers — (2)add : Length unit -> Length unit -> Length unit — (3) 
add (Length a) (Length b) = 
   Length (a + b)
```

*   ①这是一种幻影式。我们用一个未使用的类型参数`unit`定义了一个自定义类型`Length`。它的意思就是“一个‘长度’，其中‘单位’分量是 X”。类型参数“unit”用作 x。
*   (2)我们定义了自定义类型`Meters`和`Kilometers`，分别代表单位“米”和“公里”。例如，`Length Meters`衍生出“长度”的意思，其中“单位”部分是“米”。关键的是，`Length Meters`和`Length Kilometers`的数据结构完全相同(都是`Length Int`)，所以我们可以编写可重用的函数，但类型检查器会将它们视为不同的类型。混合它们会导致类型错误！
*   (3)`add`的类型定义为:“可以添加任意两个长度，只要是同一个单位”。还要注意，因为`Length Meters`和`Length Kilometers`都与`Length unit`兼容，所以我们可以对这两种类型重用这个算法。

酷，这种方法没有以前方法的缺点:

*   单元在运行时不存在，所以开销更少，没有运行时错误处理！
*   我们可以编写适用于任何单位的函数。没有重复实现每个单元的每个功能！

为了更好地了解幻影类型的实际使用情况，我将列出两个常见的真实用例:

1.  措施

我们在这篇文章中所举的例子是一个参数化长度的“单位”部分的例子，但是这种技术可以用于任何测量。

这里我们看到一个`Quantity`类型，它可以用来表示任何数量，同时仍然防止数量的混合。

我们看到这种技术在 [elm-units](https://package.elm-lang.org/packages/ianmackenzie/elm-units/latest/) 包中被广泛使用，它是 [elm-3d-scene](https://package.elm-lang.org/packages/ianmackenzie/elm-3d-scene/latest/) 的支柱。

2.本能冲动

数据库实体通常有相同类型的 id(例如`String`或`Int`)，但是`userId`和`bookId`的含义不同。我们可以使用幻象类型来分离这些概念，同时共享适用于任何 id 的函数。

除了这些常见的用例，可能还有更多使用幻影类型的情况。

如果你感兴趣，你可以看看这种技术的一个更高级的版本，叫做幻影构建模式，作者是[耶鲁安·恩格斯](https://jfmengels.net/):