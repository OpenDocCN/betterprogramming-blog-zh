<html>
<head>
<title>How to Query Multiple APIs With the Combine Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Combine框架查询多个API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-query-multiple-apis-with-the-combine-framework-1c4e0298418e?source=collection_archive---------5-----------------------#2020-06-17">https://betterprogramming.pub/how-to-query-multiple-apis-with-the-combine-framework-1c4e0298418e?source=collection_archive---------5-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d845" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Combine对多个数据源进行多个异步服务调用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3e2043ad62118da886aed25513f1fa47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*er5_6ldW00jdxHro"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@medhatdawoud?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅达·达伍德</a>拍摄的照片。</p></figure><p id="d69e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:如果您现在不想使用Combine，您可以查看本文</em>  <em class="lv">中的</em> <a class="ae ky" href="https://medium.com/better-programming/how-to-query-multiple-apis-with-dispatchworkitem-and-dispatchgroup-41a757692367" rel="noopener"> <em class="lv">的原生方法。</em></a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2c7b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">介绍</h1><p id="8d42" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Combine是苹果公司开发的一个新框架，在2019年WWDC上推出。它是一个用于处理异步操作的声明性Swift API。换句话说，这是苹果做函数式反应式编程的方式。Combine构建在发布-订阅模式之上。如果您熟悉该模式或任何其他FRP框架，如RxSwift、ReactiveSwift等。，你会更容易理解。</p><p id="5f0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不打算介绍出版商、订户或主题。如果你对它们一无所知，你应该先读一读。我打算直接跳到代码。然而，我在本文末尾提供了一些联合资源。</p><p id="be1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据苹果开发者称，Combine“提供了一个声明性的Swift API，用于随时间处理值。”</p><p id="ea2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面找到示例项目:</p><div class="na nb gp gr nc nd"><a href="https://github.com/ibrahimoktay/AsyncProgramming" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">Ibrahim oktay/异步编程</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">演示应用程序-使用DispatchWorkItem和DispatchGroup。通过创建……为ibrahimoktay/async编程开发做出贡献</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ks nd"/></div></div></a></div><p id="252d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">DispatchWorkItem</code>和<code class="fe ns nt nu nv b">DispatchGroup</code>用于主分支。我为联合收割机创建了另一个分支。你能猜出它的名字吗？它是结合在一起。我会将示例项目逐步转换为组合。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ddee" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第一步</h1><p id="8dc0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们需要一种方法来发出网络请求。幸运的是，苹果已经建立了一个返回出版商的方法(<code class="fe ns nt nu nv b">dataTaskPublisher</code>)。<strong class="lb iu"> </strong>在现实世界的app中，这种方法可能是不够的。通常，你会做更多的错误检查，转换错误消息，拦截器，或者你可能有插件，等等。</p><p id="3bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保持代码简单，我将把它写成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0e9d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第二步</h1><p id="e3e5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我将在我的<code class="fe ns nt nu nv b">ImageService</code>协议中添加另一个方法，它将返回一个publisher。您可能会注意到关键字<code class="fe ns nt nu nv b">Never</code>。基本上就是说不会失败。我这样做是因为我将用一个空的字符串数组替换<code class="fe ns nt nu nv b">error</code>。这个方法将从我们的视图模型中调用:</p><pre class="kj kk kl km gt ny nv nz oa aw ob bi"><span id="37fd" class="oc me it nv b gy od oe l of og"><strong class="nv iu">func</strong> search(<strong class="nv iu">_</strong> query: String) -&gt; AnyPublisher&lt;[String], Never&gt;</span></pre><p id="be65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在服务层实现代码。我们只是将<code class="fe ns nt nu nv b">UnsplashResponse</code>转换成一个字符串数组，并用一个空数组替换任何错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f4be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在视图模型中调用这个方法。让我们更改ViewModel中的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里暂停一下。我们刚刚改变了视图模型中的<code class="fe ns nt nu nv b">search</code>方法。此时，您可以运行项目并查看结果。然而，它并不做与主分支中相同的工作，因为我们只查询第一个服务(<code class="fe ns nt nu nv b">services.first?</code>)。别担心，我们以后会改变的。我们称之为来自视图控制器的<code class="fe ns nt nu nv b">completion</code>。因此，我们不需要修改视图控制器中的任何代码。<code class="fe ns nt nu nv b"><a class="ae ky" href="https://developer.apple.com/documentation/combine/cancellable" rel="noopener ugc nofollow" target="_blank">Cancellable</a></code>是表示可以取消流程的协议。我们代码中的<code class="fe ns nt nu nv b">cancellable</code>其实就是<code class="fe ns nt nu nv b"><a class="ae ky" href="https://developer.apple.com/documentation/combine/anycancellable" rel="noopener ugc nofollow" target="_blank">AnyCancellable</a></code>。你需要一个对<code class="fe ns nt nu nv b">sink</code>方法结果的强引用。否则ARC会清理掉，你什么都看不到。</p><p id="0291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个区别，那就是延迟。我们不会推迟我们的请求。因此，让我们以组合的方式实现那些缺失的部分，并在更新视图控制器时使用发布器。</p><p id="56aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在视图控制器中实现:</p><pre class="kj kk kl km gt ny nv nz oa aw ob bi"><span id="b37a" class="oc me it nv b gy od oe l of og"><strong class="nv iu">func</strong> updateSearchResults(for searchController: UISearchController) {<br/>  viewModel.query = searchController.searchBar.text ?? ""<br/>}</span></pre><p id="143a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而不是这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e89c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第三步</h1><p id="a61a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们改变我们的视图模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，就是这样。现在，我们的代码比用<code class="fe ns nt nu nv b">DispatchWorkItem</code>和<code class="fe ns nt nu nv b">DispatchGroup</code>构建的示例项目要少。看到<code class="fe ns nt nu nv b">published</code>关键词了吗？这是属性包装器和组合带来的另一个奇特特性。每次您给<code class="fe ns nt nu nv b">query</code>设置一个值，它将发出这些值:</p><pre class="kj kk kl km gt ny nv nz oa aw ob bi"><span id="4b88" class="oc me it nv b gy od oe l of og">query = "a"<br/>query = "ab"<br/>query = "abc"</span></pre><p id="88ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两个<code class="fe ns nt nu nv b">@Published</code>值，一个用于ViewController(以便它可以观察<code class="fe ns nt nu nv b">imageUrls</code>)，另一个用于ViewModel。我们使用包装发布器来访问<code class="fe ns nt nu nv b">$query</code>，这允许我们过滤流并延迟它:</p><pre class="kj kk kl km gt ny nv nz oa aw ob bi"><span id="0092" class="oc me it nv b gy od oe l of og">$query.filter{ $0.count &gt; 3 } // filter if character count is less than 4</span></pre><p id="8416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果字符数小于4，我们不必返回空字符串数组或取消任何请求，因为我们不会预先触发任何操作。我们可以用一行代码添加一个延迟:</p><pre class="kj kk kl km gt ny nv nz oa aw ob bi"><span id="3b9e" class="oc me it nv b gy od oe l of og">.debounce(for: .seconds(1), scheduler: RunLoop.main)</span></pre><p id="d8a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的包装纸准备好了。</p><p id="4836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是所有奇迹发生的地方。我们查询<code class="fe ns nt nu nv b">Services</code>数组中的每个服务，并合并另一个发布者中的所有请求。这个新的发布者等待每个服务的响应。最后，我们必须将结果扁平化，因为合并操作会转换我们的数据。就是这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c312" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="5298" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">组合是一个新的框架。尽管有iOS 13.0+这样的限制，但它会变得更加流行和强大。Timer、URLSession和NotificationCenter已经采用了Combine框架。日复一日，更多的API将跟随这一趋势。在我看来，未来我们会看到很多SwiftUI和Combine。我认为你用得越多，你就会越喜欢它，你会一直喜欢它，直到你讨厌它。如果你是一只孤独的狼，你可能不会那么讨厌它。</p><p id="0e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。任何反馈都将不胜感激。如果你有任何问题，请与我联系。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5c3d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><div class="na nb gp gr nc nd"><a href="https://developer.apple.com/documentation/combine" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">结合</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">Combine框架提供了一个声明性的Swift API，用于随时处理值。这些值可以代表许多…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">developer.apple.com</p></div></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://developer.apple.com/videos/play/wwdc2019/722/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">介绍联合收割机- WWDC 2019 -视频-苹果开发者</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">Combine是一个统一的声明性框架，用于随时间处理值。了解它如何简化异步代码…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">developer.apple.com</p></div></div><div class="nm l"><div class="oh l no np nq nm nr ks nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://developer.apple.com/videos/play/wwdc2019/721/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">结合实践- WWDC 2019 -视频-苹果开发者</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">扩展您对Combine的了解，Combine是Apple新的统一声明式框架，用于处理随时间变化的值。学习…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">developer.apple.com</p></div></div><div class="nm l"><div class="oi l no np nq nm nr ks nd"/></div></div></a></div></div></div>    
</body>
</html>