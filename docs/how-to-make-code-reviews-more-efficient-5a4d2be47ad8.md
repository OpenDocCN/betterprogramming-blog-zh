# 如何让代码评审更高效

> 原文：<https://betterprogramming.pub/how-to-make-code-reviews-more-efficient-5a4d2be47ad8>

## 通过高效的 CRs，我们希望在不妨碍将代码部署到产品中的过程的情况下发现潜在的问题

![](img/b87e74378dde14c6c3d06b441e689d31.png)

[iStockPhoto](https://www.istockphoto.com/) 上 [gorodenkoff](https://www.istockphoto.com/portfolio/gorodenkoff?mediatype=photography) 的照片

代码审查(CR)的简单目标是确保代码在审查后处于更好的状态。通过高效的 CRs，我们希望在不妨碍将代码部署到产品中的过程的情况下发现潜在的问题。研究表明，在发现软件缺陷方面，同行评审通常比测试更有效。在他的书 [Code Complete](https://www.amazon.com/Code-Complete-Second-Steve-McConnell/dp/0735619670) 中，Steve McConnell 肯定了软件测试作为一种独立的方法已经被证明显示出有限的有效性:

> …软件测试本身的有效性有限。单元测试的平均缺陷检测率只有 25 %,功能测试是 35 %,集成测试是 45%。相比之下，设计和代码检查的平均效率是 55%和 60%。

CR 作者是变更的最终所有者。他/她还负责确保变更没有错误，并且符合团队政策。作者应该尽最大努力向评审者发送干净、正确、经过充分测试的代码，而不应该仅仅依靠他人来发现问题。

如果你在网上快速搜索，你会发现优秀的企业责任最佳实践，比如谷歌的。在这篇文章中，我将提供我对高效代码评审的看法。

# 谁应该审查代码？

对于作者和审稿人来说，CR 都是一个学习的机会。考虑将这些人添加为您的代码审查者:

*   ***领域专家*** —很明显，一个拥有领域知识的人会有更多的语境。与经验不足的审阅者相比，他们查看新版本所需的时间也更少。因此，作为一个团队节省时间。
*   **它可以帮助他们快速理解服务底层逻辑，并且在编写他们自己的代码时或者在他们随叫随到的时候是有益的。**
*   ***有人比你强！***——试着找到比你更有专业知识的人，听取他们对你的代码的意见。有时候，他们会推荐一个新的设计逻辑，比如一个库或者设计，让你的代码更好的执行和理解。

请注意，人们会有个人偏好，不同的人可能会提出不同的非屏蔽评论。因此，在一个 CR 上保留少量的审阅者可以减少不同人之间过多的来回。

# CRs 里看什么？

您应该带着几个关键问题来回顾代码，以保持关注。例如，您可以评估代码以回答以下问题:

## **代码正确性**

*   代码是否正常运行？有什么模棱两可的要求吗？有没有你需要考虑的不成文的要求？当事情失败时，它会激活适当的响应吗？
*   有没有什么 bug 或者错误？
*   因为改变而产生副作用了吗？
*   是否有足够的单位/职能部门来应对变化？

## **透明度**

***简单性:*** 代码即使快速浏览也应该很容易理解。尤其是在凌晨 3 点，当值班人员收到传呼并希望快速找到问题时！您是否使用级联呼叫？名字清楚吗？例如，如果你正在使用 Java lambda，考虑一下它是否有必要。Lambda 通常使代码更简洁，更容易理解。

```
Arrays.sort(arr, (s1,s2) -> s1.length() — s2.length());
```

然而，如果[引入太多级联逻辑](https://www.vitavonni.de/blog/201603/2016030101-stop-abusing-lambda-expressions---this-is-not-functional-programming.html)，它会很快变成复杂且难以理解的代码块。

```
Stream<Pair> allFactorials = Stream.iterate(
  new Pair(BigInteger.ONE, BigInteger.ONE),
  x -> new Pair(
    x.num.add(BigInteger.ONE),
    x.value.multiply(x.num.add(BigInteger.ONE))));
return allFactorials.filter(
  (x) -> x.num.equals(num)).findAny().get().value;
```

***风格:*** 作为 CR 的一部分，你在评估代码是否与周围的一致。在许多 ide 中，你可以设置一个特定的代码风格(缩进，删除不用的导入，文档等等。)自动应用于代码。如果你是一名 Java 开发人员，请看一下 [Google Java 风格指南](https://google.github.io/styleguide/javaguide.html)以获得全面的最佳实践文档。

***简洁:*** 每个函数或方法都应该简洁明了，最多一页(几十行代码)。不要将多个独立的变更(例如，多个不相关的修正)放入一个单一的 CR 中，考虑将变更分割成多个。

> 每个 CR 本质上都应该有一个单一的目标。

单一责任使得代码更容易审查，并且在特定功能有问题时更容易回滚。如果 CR 是为一个大目标服务的，考虑把它分解成独立的、自成一体的子目标。

***文档化:*** 考虑代码是否被适当地文档化，以便其他人理解和维护。评论容易理解吗？它给周围的代码增加价值了吗？这些功能有明确的意图吗？一些概述期望描述的评论会有帮助吗？

## 设计

在大多数情况下，CR 可能影响低层次或高层次的设计。审查代码时，请尝试回答以下问题:

*   设计是否合理？(有变化或无变化)
*   这些变化与现有的设计配合得好吗？(例如，新的职责是否属于变更后的实体？)
*   任何改变会暴露现有设计中的弱点吗？(例如，简单的行为更改需要复杂的代码更改来修复)
*   变更是否完全符合所有功能/问题的要求？对于可能在生产中产生问题的需求的解释，是否存在任何不确定性或疑问？
*   是否有足够的空间来应用增强的设计模式？例如，如果一个方法有大量的输入，是否可以应用构建器模式来提高清晰度和可扩展性？

## **向后兼容**

*   代码是否向后兼容预先存在的 API？
*   它是否向后兼容预先存在的配置？
*   是否存在并不真正需要的向后不兼容的变更？
*   如果存在向后不兼容的变更，如何根据包构建、部署和通信来管理它们？

## **重用**

*   这个包包含重复的代码吗？
*   有什么本地功能应该放在共享库中吗？
*   可以完全删除任何代码或者用现有的库替换代码来提高效率吗？

## **配置或常量**

*   行为会激活应该可配置的随机常量值吗？
*   代码中有没有发现或重复出现的神奇的数字或起始常数？
*   所有配置设置都有默认值吗？
*   配置设置的行为是否被正确记录？

## **性能**

*   是否有迹象表明存在过早优化？
*   是否有明显的性能或效率问题被认为不需要解决？
*   即使大部分额外的时间都花在了阻塞上，代码是否需要更长的时间来执行？

## **依赖关系**

*   是否正在实施新的外部依赖关系，这可能会带来全新的可用性或运营风险？
*   每个新的库依赖都是强制性的吗？现有的依赖是必不可少的吗？有没有可能用更简单的方法解决这个问题？
*   是否有其他“轻量级”依赖项可以替代使用？

## **故障**

*   代码能够从任何被调用的库代码垃圾返回值吗？
*   代码能处理边缘情况吗？
*   代码是只处理愉快的路径，还是也处理所有的错误情况？
*   是否有透明度和可靠的策略来处理异常？

## **日志记录和指标**

代码应该有足够的日志记录机制，以便在出现问题时，很容易快速评估和解决问题。始终确保记录足够多的信息。但是，请记住，过度日志记录反过来会引发安全问题(例如，日志中客户电子邮件地址等机密信息)或性能问题(大量不必要的日志记录导致大量 I/O)。

对于度量，尝试确定代码是否与性能度量一起使用。这包括诸如呼叫率、类型和延迟等项目。所有离开进程和主机的远程调用都有度量吗？你如何发现压力/负荷/偏差？

## **安全**

尝试评估代码是否违反了任何数据处理策略。当前代码面临任何安全威胁吗？例如，如果代码处理用户输入，那么代码是否会受到安全保护，防止 [SQL 注入](https://www.sqlshack.com/sql-injection-detection-and-prevention/)？

# ***除代码外，CR 请求中还应包括哪些信息？***

CR 请求不仅仅与代码有关。本质上，它包含了所有相关的元数据和代码评审人员的讨论，可以在未来用作参考。我建议将数据放入 CR 请求中，包括:

*   参考资料(票号、维基文档、设计文档等。)
*   变更描述:突出主要的接触点(同样，想象一下凌晨 3 点出了问题，有人想知道您的变更是否相关)。
*   警报和指标待定配置
*   测试是如何进行的
*   任何特定的考虑事项，如部署顺序、向后兼容性或依赖性)

# 如何有效地添加您的评论

评审者应该准备好区分阻塞和非阻塞问题。冻结问题是指阻止 CR 发货的事情。非阻塞问题专门针对更主观的问题，可以通过讨论达成共识，或者在后续 CRs 中解决。请注意，虽然理论上只有非阻塞注释的 CR 可能会被发货(因为它不会导致生产问题)，但这并不意味着非阻塞注释可以被忽略。

## **阻塞问题**

大多数阻碍性问题都是影响生产的事情，往往是客观存在的。例如:

*   CR 违反了上面列出的一项或多项“作者指南”
*   代码错误
*   任何潜在的性能问题
*   单向门决策
*   产品代码中缺少关键测试
*   评论不足

## **非阻塞问题**

非阻塞问题大多是需要达成共识的主观意见。请记住，不同的人有不同的做事风格。因此，会有几种不同的解决方案。非阻塞注释的一些例子是:

*   代码增强建议
*   重构建议
*   代码可维护性讨论
*   你也可以改变这类事情。每个人都是团队的一部分。如果您想在不等待 CR 提交者回复的情况下做出更改，除了在 people's CR 中评论之外，您还可以自己动手做！

## **评论**

为了让评论更有效并节省来回的时间，试着有一个作者可以处理的明确的行动项目。一些例子是:

*   “你调查过 X 吗？”除了“存在其他选择”
*   “改名为 Y 怎么样？”除了“名称需要澄清”之外
*   “把 A 移到 B，让 C 调用 D”除了“这个应该重构”

如果一个主题需要很多来回的对话，而不是有一长串的评论，亲自做评论，只把最终结果放在评论里。

# 作者应该如何处理评论？

收到非屏蔽评论不代表可以忽略。作者需要通过反馈尊重他人的努力:

*   花点时间对评审者的反馈做一个令人生畏的回复，不管是阻塞还是非阻塞，以达成共识。
*   务必尽快回复不明确的评论或发起冗长的讨论(尤其是在发布新版本之前)，以避免发布基于第一版评论的第三版。
*   与审核者进行离线跟进，以解决他们意见中的任何理解不足之处，并在 CR 中为其他审核者总结结果。
*   发布新版本时，更新 CR 标题和消息描述。
*   如果您收到了所需的批准，但其他人在未经批准的情况下对 CR 进行了评论，请与他/她联系，以确定问题是否得到解决。

编码快乐！