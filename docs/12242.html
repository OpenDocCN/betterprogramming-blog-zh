<html>
<head>
<title>Secure Your Apps With Spring Boot Validation and Bean Manipulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Spring Boot验证和Bean操作保护您的应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/spring-boot-validation-and-bean-manipulation-4fd546fe813b?source=collection_archive---------3-----------------------#2022-05-21">https://betterprogramming.pub/spring-boot-validation-and-bean-manipulation-4fd546fe813b?source=collection_archive---------3-----------------------#2022-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ce78" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看一下处理安全性的两种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e82012dfd980a018ec2a1ede4932f135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7zQS3KZnvwcXavdyrIffg.png"/></div></div></figure><p id="a83f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安全应用在其开发和生产阶段遵循若干安全措施，由于可能发生数据注入的风险，应用入口点是最重要的安全部分之一。Spring提出了它的数据验证方法，改进了对这些特殊点的控制。</p><p id="4793" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您已经猜到的，本文不仅仅是关于数据验证；它还涉及bean或自定义数据结构操作，这是每个开发人员都应该了解的两个重要的应用程序安全特性。</p><p id="9c2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">介绍得够多了，现在，让我们从我们需要实现的全球蓝图开始，您需要知道这两种机制都解决了两个安全漏洞:</p><ul class=""><li id="dc50" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><strong class="kt ir">喷射攻击</strong></li><li id="f270" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><strong class="kt ir">数据库模式暴露</strong></li></ul><p id="1d2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">听起来很糟糕，对吧？嗯，解决方案其实比你想象的要简单。首先，让我们先了解这两个问题，然后再寻求解决方案。</p><h1 id="f0ab" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">注入攻击</h1><p id="ea2c" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">注入攻击是指恶意代码被注入网络，并从数据库中检索所有数据，然后将其发送给攻击者。正如您得出的结论，攻击使用您的应用程序的开放门户来获取所有存储的数据，它可以以多种类型伪装攻击，如XSS、SQL、XPath、模板、代码、CRLF、LDAP、操作系统命令注入等。如果你使用ORM操作，你并不完全安全，但是你已经领先一步了。你提出的防御越多越好。</p><h1 id="dd2d" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">数据库模式暴露</h1><p id="8872" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">主要是当这种情况发生时，它不会给攻击者带来很大的好处，但它仍然提供了一条有价值的信息，这是您构造您的<strong class="kt ir">模式、数据类型和关系</strong>的方式，在某些场景中，它变得至关重要。</p><h1 id="ccba" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">数据有效性</h1><p id="4d64" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">在本教程中，我们将基于我们最后的<a class="ae my" href="https://github.com/xrio/simple-spring-boot-movies" rel="noopener ugc nofollow" target="_blank">电影API </a>。</p><p id="c27b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们将Spring boot验证依赖项添加到pom.xml文件中。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="7eda" class="ne mc iq na b gy nf ng l nh ni">&lt;dependency&gt; <br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; <br/>    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; <br/>&lt;/dependency&gt;</span></pre><p id="f706" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，我们将使用一些验证规则来增强我们的电影模型。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="cec5" class="ne mc iq na b gy nf ng l nh ni">// other imports<br/>import javax.persistence.Entity;<br/>import javax.persistence.GeneratedValue;<br/>import javax.persistence.GenerationType;<br/>import javax.validation.constraints.Max;<br/>import javax.validation.constraints.Min;<br/>import javax.validation.constraints.NotBlank;<br/>import javax.validation.constraints.NotNull;<br/><br/>@Data<br/>@Entity<br/>public class Movie {<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.SEQUENCE)<br/>    @NotNull(message = "Id must not be null")<br/>    private Long id;<br/><br/>    @NotBlank(message = "Name must not be blank")<br/>    private String name;<br/><br/>    @NotBlank(message = "Type must not be blank")<br/>    private String type;<br/><br/>    @Min(value = 1, message = "Movies are mainly more than a minute")<br/>    @Max(value = 300, message = "Movies are less than 5 hours")<br/>    private Long duration;<br/><br/>    @NotNull(message = "Release year must not be null")<br/>    private Long releaseYear;<br/><br/>}</span></pre><p id="4d72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第三，我们改变了控制器端点的签名，这样它们就可以验证传入的请求体并抛出异常，而不是自定义异常。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="dc79" class="ne mc iq na b gy nf ng l nh ni">package io.xrio.movies.controller;<br/><br/>...<br/><br/>import javax.validation.Valid;<br/><br/>@RestController<br/>@RequestMapping("movie")<br/>@Data<br/>public class MovieController {<br/><br/>    ...<br/><br/>    @PostMapping("/")<br/>    public ResponseEntity&lt;?&gt; save(@Valid @RequestBody Movie movie) throws Exception {<br/>        if (movie == null)<br/>            return ResponseEntity.badRequest().body("The provided movie is not valid");<br/>        return ResponseEntity.status(HttpStatus.CREATED).body(movieService.save(movie));<br/>    }<br/><br/>    @PutMapping("/")<br/>    public ResponseEntity&lt;?&gt; update(@Valid @RequestBody Movie movie) throws Exception {<br/>        if (movie == null)<br/>            return ResponseEntity.badRequest().body("The provided movie is not valid");<br/>        return ResponseEntity.ok().body(movieService.update(movie));<br/>    }<br/><br/>    ...<br/><br/>}</span></pre><p id="c4d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nj nk nl na b">@Valid</code>确保传入的主体是有效的，否则将抛出一个<code class="fe nj nk nl na b">MethodArgumentNotValidException</code></p><p id="3eb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">显然，我们移除了定制的异常，并用<code class="fe nj nk nl na b">Exception</code>类替换它，这样控制器就不会抑制控制器层中的异常，让默认的异常处理程序干涉，这将导致500服务器内部错误。相反，它将由我们将要创建的异常处理程序来处理。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="406d" class="ne mc iq na b gy nf ng l nh ni">package io.xrio.movies.controller.advice;<br/><br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.validation.FieldError;<br/>import org.springframework.web.bind.MethodArgumentNotValidException;<br/>import org.springframework.web.bind.annotation.ControllerAdvice;<br/>import org.springframework.web.bind.annotation.ExceptionHandler;<br/>import org.springframework.web.bind.annotation.ResponseStatus;<br/><br/>import java.util.HashMap;<br/>import java.util.Map;<br/><br/>@ControllerAdvice<br/>public class ValidationExceptionHandler {<br/><br/>    @ExceptionHandler(MethodArgumentNotValidException.class)<br/>    public ResponseEntity&lt;?&gt; handleValidationExceptions(MethodArgumentNotValidException exception) {<br/>        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();<br/>        exception.getBindingResult().getAllErrors().forEach((error) -&gt; {<br/>            String fieldName = ((FieldError) error).getField();<br/>            String errorMessage = error.getDefaultMessage();<br/>            errors.put(fieldName, errorMessage);<br/>        });<br/>        return ResponseEntity.badRequest().body(errors);<br/>    }<br/>}</span></pre><p id="bacd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就像我们之前的电影异常处理程序一样，这个基于<code class="fe nj nk nl na b">ControllerAdvice</code>的处理程序将针对<code class="fe nj nk nl na b">MethodArgumentNotValidException</code>类型的异常，并通过检索验证违规来解决它们，将其包装在一个响应实体中，并使用400错误请求响应代码将其发送回用户。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/38aeb5cef9fe0a4e03b7da560f012c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofMhNs-30dud43ep9IolwQ.png"/></div></div></figure><p id="3355" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nn">注意:将验证违规返回给用户是一个巨大的搅拌器，就像告诉一个入室抢劫者为什么他们没能抢劫你自己的房子。</em></p><p id="f305" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了应对这种情况，我们将把它们打印在日志上，顺便说一下，只有生产环境管理员可以访问这些日志。我们的例外将是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1dce" class="ne mc iq na b gy nf ng l nh ni">import lombok.extern.slf4j.Slf4j;</span><span id="1cd4" class="ne mc iq na b gy no ng l nh ni">...</span><span id="81ec" class="ne mc iq na b gy no ng l nh ni">@ControllerAdvice<br/>@Slf4j<br/>public class ValidationExceptionHandler {</span><span id="54c7" class="ne mc iq na b gy no ng l nh ni">    @ExceptionHandler(MethodArgumentNotValidException.class)<br/>    public ResponseEntity&lt;?&gt; handleValidationExceptions(MethodArgumentNotValidException exception) {<br/>        exception.getBindingResult().getAllErrors().forEach((error) -&gt; {<br/>            String fieldName = ((FieldError) error).getField();<br/>            String errorMessage = error.getDefaultMessage();<br/>            log.error(fieldName + ": " + errorMessage);<br/>        });<br/>        return ResponseEntity.badRequest().body("Sorry, that movie you sent sucks :)");<br/>    }<br/>}</span></pre><p id="1f05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">发送相同的请求将导致以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/35bcdc5d6e257883d758a6336bf6cab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pPTlE0bNiUGNcyzmTmE2g.png"/></div></div></figure><p id="3533" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只有生产环境管理员可以看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/888c6a19c24b36169b54acd9619a5e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*st9wWtnrP10zE3jZhgHaIw.png"/></div></div></figure><p id="43c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nj nk nl na b">@Slf4j</code>是使用<a class="ae my" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank">龙目语</a>调用记录器的一种简称。</p><p id="3b99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数据验证不仅是抵御注入攻击的一层，而且有助于保持数据整洁。</p><p id="e9cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们仍然在我们的端点中暴露我们的模型，是时候改变它了！</p><h1 id="b59f" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">数据操作</h1><h1 id="5163" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">dto简介</h1><p id="f069" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">数据传输对象，也称为值对象(VOs ),将是在两个进程之间携带数据的对象，在我们的例子中，将是它们的结构而不是模型的结构被暴露。</p><p id="88f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的电影将如下:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="9956" class="ne mc iq na b gy nf ng l nh ni">import lombok.Data;</span><span id="9955" class="ne mc iq na b gy no ng l nh ni">import javax.validation.constraints.Max;<br/>import javax.validation.constraints.Min;<br/>import javax.validation.constraints.NotBlank;<br/>import javax.validation.constraints.NotNull;</span><span id="66c5" class="ne mc iq na b gy no ng l nh ni">@Data<br/>public class MovieDTO {</span><span id="f2ff" class="ne mc iq na b gy no ng l nh ni">    @NotNull(message = "Id must not be null")<br/>    private Long id;</span><span id="03a6" class="ne mc iq na b gy no ng l nh ni">    @NotBlank(message = "Name must not be blank")<br/>    private String name;<br/>    @NotBlank(message = "Type must not be blank")<br/>    private String type;<br/>    @Min(value = 1, message = "Movies are mainly more than a minute")<br/>    @Max(value = 300, message = "Movies are less than 5 hours")<br/>    private Long duration;<br/>    @NotNull(message = "Release year must not be null")<br/>    private Long releaseYear;</span><span id="73f1" class="ne mc iq na b gy no ng l nh ni">}</span></pre><p id="44d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为dto是要公开的对象，所以我们添加了一些验证规则。</p><p id="2265" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nn">好了，我们已经公开了dto，但是我们如何使用dto持久化数据呢？</em></p><p id="3b1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nn">答案是dto只存在于控制器层，换句话说，我们不能在服务和存储库层使用它们。</em></p><p id="3754" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">也意味着我们需要一个转换机制，是的，我们需要一个<code class="fe nj nk nl na b">MovieConverter</code>。</p><p id="3a65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从集成<a class="ae my" href="http://modelmapper.org/getting-started/" rel="noopener ugc nofollow" target="_blank"> ModelMapper </a>依赖项开始，这将有助于以两种方式转换模型和DTO:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="039e" class="ne mc iq na b gy nf ng l nh ni">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.modelmapper&lt;/groupId&gt;<br/>    &lt;artifactId&gt;modelmapper&lt;/artifactId&gt;<br/>    &lt;version&gt;2.3.5&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="d503" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们添加它的基本配置，因此它将被视为Spring Bean:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4a50" class="ne mc iq na b gy nf ng l nh ni">import org.modelmapper.ModelMapper;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.context.annotation.Configuration;</span><span id="3854" class="ne mc iq na b gy no ng l nh ni">@Configuration<br/>public class ModelMapperConfig {<br/>    <br/>    @Bean<br/>    public ModelMapper modelMapper() {<br/>        return new ModelMapper();<br/>    }<br/>}</span></pre><p id="e9e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不喜欢重复自己(<a class="ae my" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">枯燥的原则</a>)这就是为什么我总是把多余的行为放到泛型类中，<code class="fe nj nk nl na b">AbstractConverter</code>会帮我们做到这一点:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="7163" class="ne mc iq na b gy nf ng l nh ni">import java.util.ArrayList;<br/>import java.util.List;</span><span id="13ba" class="ne mc iq na b gy no ng l nh ni">public abstract class AbstractConverter &lt;DM, DTO&gt; {</span><span id="9a32" class="ne mc iq na b gy no ng l nh ni">    public abstract DM convertToDM(DTO dto);</span><span id="b868" class="ne mc iq na b gy no ng l nh ni">    public abstract DTO convertToDTO(DM dm);</span><span id="de00" class="ne mc iq na b gy no ng l nh ni">    public List&lt;DM&gt; convertToDMs(List&lt;DTO&gt; dtos) {<br/>        List&lt;DM&gt; dms = new ArrayList&lt;&gt;();<br/>        for (DTO dto : dtos) dms.add(convertToDM(dto));<br/>        return dms;<br/>    }</span><span id="a54e" class="ne mc iq na b gy no ng l nh ni">    public List&lt;DTO&gt; convertToDTOs(List&lt;DM&gt; dms) {<br/>        List&lt;DTO&gt; dtos = new ArrayList&lt;&gt;();<br/>        for (DM dm : dms) dtos.add(convertToDTO(dm));<br/>        return dtos;<br/>    }</span><span id="8eb8" class="ne mc iq na b gy no ng l nh ni">}</span></pre><p id="d974" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的<code class="fe nj nk nl na b">MovieConverter</code>将继承<code class="fe nj nk nl na b">AbstractConverter</code>的电影模型和DTO作为类参数。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="64e1" class="ne mc iq na b gy nf ng l nh ni">import io.xrio.movies.dto.MovieDTO;<br/>import io.xrio.movies.model.Movie;<br/>import org.modelmapper.ModelMapper;<br/>import org.modelmapper.config.Configuration;<br/>import org.springframework.stereotype.Component;</span><span id="95fb" class="ne mc iq na b gy no ng l nh ni">@Component<br/>public class MovieConverter extends AbstractConverter&lt;Movie, MovieDTO&gt; {</span><span id="455b" class="ne mc iq na b gy no ng l nh ni">    private final ModelMapper modelMapper;</span><span id="78d0" class="ne mc iq na b gy no ng l nh ni">    public MovieConverter(ModelMapper modelMapper) {<br/>        modelMapper.getConfiguration()<br/>                .setFieldMatchingEnabled(true)<br/>                .setFieldAccessLevel(Configuration.AccessLevel.PRIVATE);<br/>        this.modelMapper = modelMapper;<br/>    }</span><span id="c7f1" class="ne mc iq na b gy no ng l nh ni">    @Override<br/>    public Movie convertToDM(MovieDTO movieDTO) {<br/>        return modelMapper.map(movieDTO, Movie.class);<br/>    }</span><span id="1db3" class="ne mc iq na b gy no ng l nh ni">    @Override<br/>    public MovieDTO convertToDTO(Movie movie) {<br/>        return modelMapper.map(movie, MovieDTO.class);<br/>    }<br/>}</span></pre><p id="ae50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我用<code class="fe nj nk nl na b">@Component</code>注释修饰了<code class="fe nj nk nl na b">MovieConverter</code>，这样它可以在以后被注入到MovieController中。</p><p id="11a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模型映射器将通过简单的配置在<code class="fe nj nk nl na b">MovieConverter</code>构造函数中进行配置，由于模型和DTO具有相同的字段，映射现在将是可能的。</p><p id="0fa6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在测试我们的转换器之前，我们需要将它注入到控制器中，然后改变端点，以便它们现在可以处理d to。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="faae" class="ne mc iq na b gy nf ng l nh ni">package io.xrio.movies.controller;</span><span id="8b36" class="ne mc iq na b gy no ng l nh ni">import io.xrio.movies.converter.MovieConverter;<br/>import io.xrio.movies.dto.MovieDTO;<br/>import io.xrio.movies.service.MovieService;<br/>import lombok.Data;<br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.bind.annotation.*;</span><span id="a0a0" class="ne mc iq na b gy no ng l nh ni">import javax.validation.Valid;<br/>import java.util.List;</span><span id="aa62" class="ne mc iq na b gy no ng l nh ni">@RestController<br/>@RequestMapping("movie")<br/>@Data<br/>public class MovieController {</span><span id="a92d" class="ne mc iq na b gy no ng l nh ni">    final MovieService movieService;<br/>    final MovieConverter movieConverter;</span><span id="9406" class="ne mc iq na b gy no ng l nh ni">    @PostMapping("/")<br/>    public ResponseEntity&lt;?&gt; save(@Valid @RequestBody MovieDTO movieDTO) throws Exception {<br/>        if (movieDTO == null)<br/>            return ResponseEntity.badRequest().body("The provided movie is not valid");<br/>        return ResponseEntity<br/>                .status(HttpStatus.CREATED)<br/>                .body(movieConverter.convertToDTO(movieService.save(movieConverter.convertToDM(movieDTO))));<br/>    }</span><span id="c2cc" class="ne mc iq na b gy no ng l nh ni">    @PutMapping("/")<br/>    public ResponseEntity&lt;?&gt; update(@Valid @RequestBody MovieDTO movieDTO) throws Exception {<br/>        if (movieDTO == null)<br/>            return ResponseEntity.badRequest().body("The provided movie is not valid");<br/>        return ResponseEntity<br/>                .ok()<br/>                .body(movieConverter.convertToDTO(movieService.update(movieConverter.convertToDM(movieDTO))));<br/>    }</span><span id="cd62" class="ne mc iq na b gy no ng l nh ni">    @DeleteMapping("/{id}")<br/>    public ResponseEntity&lt;?&gt; delete(@PathVariable Long id) throws Exception {<br/>        if (id == null)<br/>            return ResponseEntity.badRequest().body("The provided movie's id is not valid");<br/>        return ResponseEntity.ok().body("Movie [" + movieService.delete(id) + "] deleted successfully.");<br/>    }</span><span id="1c21" class="ne mc iq na b gy no ng l nh ni">    @GetMapping("/")<br/>    public ResponseEntity&lt;List&lt;MovieDTO&gt;&gt; findAll() {<br/>        return ResponseEntity.ok().body(movieConverter.convertToDTOs(movieService.findAll()));<br/>    }</span><span id="4a6e" class="ne mc iq na b gy no ng l nh ni">}</span></pre><p id="039b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那我们测试一下！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/5219fff7b6ec400fcbaeb9ecd4b38d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNAjLpJHzIUvxSBavRfADg.png"/></div></div></figure><p id="c190" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">太好了！但是它看起来和以前一样，只是代码更多！</strong></p><p id="c639" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没错，所以让我们用不同的规则玩同样的游戏，现在我们的电影模型将不同于DTO，以保护我们的API免受数据库模式暴露:</p><p id="7c59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些电影模型字段将被放在一个info类中，该类将被嵌入到电影中，这样我们将改变结构，让事情变得简单。</p><p id="f9b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="nn">注意:我删除了模型验证，因为它不再被使用或需要。</em> </strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="29a2" class="ne mc iq na b gy nf ng l nh ni">import lombok.Data;</span><span id="9069" class="ne mc iq na b gy no ng l nh ni">import javax.persistence.*;<br/>import javax.validation.Valid;<br/>import javax.validation.constraints.NotNull;</span><span id="7548" class="ne mc iq na b gy no ng l nh ni">@Data<br/>@Entity<br/>public class Movie {</span><span id="a71c" class="ne mc iq na b gy no ng l nh ni">    @Id<br/>    @GeneratedValue(strategy = GenerationType.SEQUENCE)<br/>    private Long id;</span><span id="8033" class="ne mc iq na b gy no ng l nh ni">    @Embedded<br/>    private Info info;</span><span id="7024" class="ne mc iq na b gy no ng l nh ni">}</span><span id="1e2f" class="ne mc iq na b gy no ng l nh ni">import javax.persistence.Embeddable;</span><span id="0f60" class="ne mc iq na b gy no ng l nh ni">@Embeddable<br/>public class Info {</span><span id="e5e0" class="ne mc iq na b gy no ng l nh ni">    private String name;<br/>    private String type;<br/>    private Long duration;<br/>    private Long releaseYear;</span><span id="1fce" class="ne mc iq na b gy no ng l nh ni">}</span></pre><p id="650e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要更改DTO字段的名称，这样就不需要为模型映射器添加高级配置。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="aff8" class="ne mc iq na b gy nf ng l nh ni">import lombok.Data;</span><span id="8582" class="ne mc iq na b gy no ng l nh ni">import javax.validation.constraints.Max;<br/>import javax.validation.constraints.Min;<br/>import javax.validation.constraints.NotBlank;<br/>import javax.validation.constraints.NotNull;</span><span id="46b0" class="ne mc iq na b gy no ng l nh ni">@Data<br/>public class MovieDTO {</span><span id="81e1" class="ne mc iq na b gy no ng l nh ni">    @NotNull(message = "Id must not be null")<br/>    private Long id;</span><span id="6ef3" class="ne mc iq na b gy no ng l nh ni">    @NotBlank(message = "Name must not be blank")<br/>    private String infoName;<br/>    @NotBlank(message = "Type must not be blank")<br/>    private String infoType;<br/>    @Min(value = 1, message = "Movies are mainly more than a minute")<br/>    @Max(value = 300, message = "Movies are less than 5 hours")<br/>    private Long infoDuration;<br/>    @NotNull(message = "Release year must not be null")<br/>    private Long infoReleaseYear;</span><span id="b180" class="ne mc iq na b gy no ng l nh ni">}</span></pre><p id="01e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后测试它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/49ffb4425b1718e349ec3d61a0fbe448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkpPspBTr2xeFWwXht-Z3Q.png"/></div></div></figure><h1 id="af6c" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">最后</h1><p id="04d9" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">数据验证和数据操作对于您的API开发和产品来说是一项非常有价值的资产，不仅可以增强安全性，还可以让您保持数据的形状，并在不改变自己的情况下适应用户的需求。</p><p id="2b85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里找到源代码<a class="ae my" href="https://github.com/xrio/simple-spring-boot-movies" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>