<html>
<head>
<title>I Made My Own “Parallel.ForEach” in .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我做了我自己的“平行。ForEach" in。NET C#</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/i-made-my-own-parallel-foreach-in-net-c-9d072424586b?source=collection_archive---------21-----------------------#2022-01-27">https://betterprogramming.pub/i-made-my-own-parallel-foreach-in-net-c-9d072424586b?source=collection_archive---------21-----------------------#2022-01-27</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="e748" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如何以最简单的方式创建自己的轻量级并行库</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/a3d53824c6e8d284d6d4e8e882861c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahNynzJhPBG1b2uFoTxH6w.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">Jonathan Chng 在<a class="ae kw" href="https://unsplash.com/s/photos/running-track?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5eb4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">是的，是的，我知道。英寸网有一个<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.parallel.foreach?view=net-6.0" rel="noopener ugc nofollow" target="_blank">水货。对于每个从盒子里出来的东西。但是让我试着解释一下。我发现自己处于这样的情况，我需要一段更小的代码，简单地对一组输入执行一个动作(工作)。试图照顾太多，并准备处理许多随机情况，对我来说，那只是噪音。</a></p><p id="060b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">所以，我在想，如果我们写一个更小的库，简单地处理对一组并行输入的操作，让操作处理所有的事情(甚至错误处理)，并且让我的库尽可能的简单，会怎么样呢？</p><p id="00ab" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为什么？对我来说，这是最常见的情况。示例:“向这些用户中的每一个发送通知”或“调用此服务并将结果写入每个输入的文件中”。</p><p id="0834" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">基本上“为这些输入中的每一个做这个任务”，这些任务(工作)可以并行执行。</p><p id="845c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们以我目前的工作作为一个很适合这个图书馆的例子。我做ETL，用几句话来概括我的工作:基于一个配置文件，我查询一个源系统并写入一些数据接收器。</p><p id="39f1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">例如，从配置文件中，我得到了一个很长的表列表，一个要处理的表所需的每个对象要么是通过阿迪框架创建的，要么是在需要时由某个工厂动态创建的。</p><p id="7e0b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">考虑到这一点，我需要的是能帮我协调所有工作的东西。目前，我开发了两种算法，一种是基于信号量的主动算法，另一种是我将在这里展示的被动算法，它基于一个轻量级工具的思想，简单地执行一个接一个的任务。</p><h1 id="f510" class="lx ly ir bd lz ma mb mc md me mf mg mh jx mi jy mj ka mk kb ml kd mm ke mn mo bi translated">简单ForEach</h1><p id="d0f8" class="pw-post-body-paragraph kx ky ir kz b la mp js lc ld mq jv lf lg mr li lj lk ms lm ln lo mt lq lr ls ik bi translated">根据我的要求，让我们为<code class="fe lt lu lv lw b">IEnumerable&lt;T&gt;</code>创建一个扩展方法，让一个<code class="fe lt lu lv lw b">Action&lt;T&gt;</code>在<code class="fe lt lu lv lw b">Enumerable</code>的每一项上执行。</p><p id="e976" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">正如您在这个for-each中看到的，这可以简单到设置一个<code class="fe lt lu lv lw b">Actions</code>的<code class="fe lt lu lv lw b">List</code>，然后将每个作为<code class="fe lt lu lv lw b">Task</code>启动，并利用<code class="fe lt lu lv lw b">Task.WhenAll()</code>来确保它们全部运行完成。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mu mv l"/></div></figure><p id="67c8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">要设置一个动作，我们必须使用传入的<code class="fe lt lu lv lw b">Action</code>来配置一个<code class="fe lt lu lv lw b">Actions</code>列表，每个列表对应一个输入。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mu mv l"/></div></figure><p id="175e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一旦配置了一个<code class="fe lt lu lv lw b">Action</code>，下一步就是在一个<code class="fe lt lu lv lw b">Task</code>内触发它。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mu mv l"/></div></figure><p id="fc59" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了跟踪每个<code class="fe lt lu lv lw b">Task</code>，我们将在<code class="fe lt lu lv lw b">List&lt;Task&gt;</code>中保存他们的引用。这样我们就可以利用<code class="fe lt lu lv lw b">Task.WhenAll()</code>，让呼叫者成为获奖者。</p><p id="fe31" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有效地只处理并行启动任务，而不处理其他事情。</p><h1 id="740b" class="lx ly ir bd lz ma mb mc md me mf mg mh jx mi jy mj ka mk kb ml kd mm ke mn mo bi translated">线程感知ForEach</h1><p id="c37a" class="pw-post-body-paragraph kx ky ir kz b la mp js lc ld mq jv lf lg mr li lj lk ms lm ln lo mt lq lr ls ik bi translated">如果我们需要限制程序可以使用的<code class="fe lt lu lv lw b">Threads</code>的数量呢？可能是因为源系统不稳定，无法并行处理太多请求。在这种情况下，我们不能简单地开始所有的任务并抱最好的希望，我们必须跟踪活动任务的数量。</p><p id="3173" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为此，我们可以改变已触发<code class="fe lt lu lv lw b">Actions</code>的循环。再次初始化一个列表<code class="fe lt lu lv lw b">Actions</code>，但是这次让我们初始化一个子集<code class="fe lt lu lv lw b">Actions</code>。</p><p id="97ec" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们将把这个子集命名为<code class="fe lt lu lv lw b">workInProgress</code>。当有工作正在进行时，我们假设仍然有活动的<code class="fe lt lu lv lw b">Tasks</code>并保持循环活动，等待<code class="fe lt lu lv lw b">Tasks</code>完成，这次利用<code class="fe lt lu lv lw b">Task.WhenAny()</code>。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mu mv l"/></div></figure><p id="0b3a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在循环中有两件重要的事情让这个工作很好地进行，我们让程序阻塞等待<code class="fe lt lu lv lw b">Task.WhenAny()</code>，一旦<code class="fe lt lu lv lw b">WhenAny</code>让程序继续运行:</p><ul class=""><li id="4562" class="mw mx ir kz b la lb ld le lg my lk mz lo na ls nb nc nd ne bi translated">我们知道一个任务已经完成，所以，我们可以触发一个新的任务。</li><li id="4211" class="mw mx ir kz b la nf ld ng lg nh lk ni lo nj ls nb nc nd ne bi translated"><code class="fe lt lu lv lw b">WhenAny()</code>还返回一个对已完成的<code class="fe lt lu lv lw b">Task</code>的引用，我们只需将<code class="fe lt lu lv lw b">Remove</code>这个具体的<code class="fe lt lu lv lw b">Task</code>从<code class="fe lt lu lv lw b">workInProgress</code>的基础上引用即可。</li></ul><p id="68db" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一旦<code class="fe lt lu lv lw b">workInProgress</code>为空，我们就知道输入列表中的每一项都已被处理。</p><h1 id="ea7e" class="lx ly ir bd lz ma mb mc md me mf mg mh jx mi jy mj ka mk kb ml kd mm ke mn mo bi translated">最后的话</h1><p id="2330" class="pw-post-body-paragraph kx ky ir kz b la mp js lc ld mq jv lf lg mr li lj lk ms lm ln lo mt lq lr ls ik bi translated">如您所见，我没有处理错误。在现实生活中，由于使用了像IoC和工厂这样的模式，我在多个地方负责日志记录和错误处理。</p><p id="afad" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">希望这些想法能对你的工作有用，让我们保持创意源源不断。</p></div></div>    
</body>
</html>