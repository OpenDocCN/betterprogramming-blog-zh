<html>
<head>
<title>3 Cases Where You Don’t Really Need Asynchronous Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不需要异步通信的3种情况</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-cases-where-you-dont-really-need-asynchronous-communication-5c8c6d56e95f?source=collection_archive---------11-----------------------#2021-04-09">https://betterprogramming.pub/3-cases-where-you-dont-really-need-asynchronous-communication-5c8c6d56e95f?source=collection_archive---------11-----------------------#2021-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="73aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道何时在您的微服务中实现异步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1a7c9d0e7555fcc407ec9765d55a551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nu8TjS_QDOWpyPzJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·赫伦在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="3b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步通信越来越广泛地应用于过程和系统，尤其是微服务。你看，人们在博客上谈论他们如何使某些操作异步。所有最新的web应用程序框架和编程语言都是为了使异步编程更容易理解而创建的。实现异步通信有很多好处。您的程序可能会运行得更快，您的客户可能会更高兴，等等。</p><p id="58d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，异步通信也有缺点。缺点之一是出现问题时很难调试。你的程序变得复杂。</p><p id="a78b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，向系统添加一个消息队列将需要一个死信队列来存储失败消息。如果你的程序需要有序，这将需要更多的存储和其他计算资源。代码级的异步通信会使程序难以阅读。JavaScript的回调地狱就是一个例子。</p><p id="138f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步工作还会降低工程开发时间。</p><p id="0522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想分享您可能希望避免在应用程序中实现异步通信的三个原因。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4d1f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是异步通信？</h1><p id="6e9f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在继续之前，我想描述一下异步通信和模式，这样我们就在同一页上了。简而言之，异步通信是指客户端在向服务器发送请求时立即接收到传递消息。这个传递消息还没有响应，只是确认服务器收到了响应。</p><p id="3445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端可以执行其他任务，并相信服务器会收到关于准确响应的通知。</p><p id="bab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步通信中经常使用两种模式。最广为人知的是回调函数。回调函数可以在服务级别或编程级别实现(回调事件)。微服务中另一个广泛使用的通信模式是消息队列——具有发布者-订阅者模式，并使用消息代理来分离两个服务之间的通信。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4646" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.更新依赖于另一个进程的进程</h1><p id="2ff9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用异步通信来更新依赖于其他数据的数据不是一个好主意，因为您的数据可能会不同步。</p><p id="cf98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您的应用程序中有一个更新字段，可以更新电子商务站点上的用户信息。执行这些操作需要您更新用户服务和订购服务，而订购服务依赖于用户服务。</p><p id="b5f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，同步计算可能是首选，因为当一个服务出错时更容易推理。</p><p id="6391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用异步通信，您将需要考虑回滚操作。此外，您还必须处理应用程序中的数据一致性。因此，根据您的应用程序的用例，同步而不是异步可能是一个好主意。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d919" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.您的服务没有任何繁重的计算资源</h1><p id="1c3b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你的系统会做大量的计算吗，比如压缩，大量的递归，或者大量的内存编码？</p><p id="68ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个服务想从另一个服务获取数据库中的属性，那么在两个服务之间不需要消息队列。</p><p id="440f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，web应用程序的第一次加载可能需要来自服务器的大量数据来呈现web。但是，不需要为简单的获取实现服务回调操作来通过ID获取用户。此时，您过度优化了您的应用程序。</p><p id="5be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们经常选择异步方式进行简单的计算。例如，我们经常试图通过使循环异步来避免阻塞，从而优化循环。</p><p id="cc5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，当循环中有许多迭代或复杂操作时，异步循环是必要的。当你迭代一个简单的任务时，比如循环遍历一个数组，没有理由使用复杂的递归函数使事情变得过于复杂。</p><p id="e432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您知道计算速度很慢，还需要在计算中利用异步，请对您的应用程序进行性能测试。当您意识到某些操作占用了更多的时间时，第一个选择就是缓存。如果缓存不起作用，你可以把异步作为最后的手段。async是最后一招的原因之一是因为async在系统中制造了复杂性，并且当bug不明显时。因此，通过优化使用async的性能，您也产生了隐藏的复杂性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c164" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.没有严格的SLA</h1><p id="c369" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">即使应用程序有许多CPU绑定，但没有严格的SLA，通过服务使用异步通信只会使事情过于复杂。</p><p id="346f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，对一个没有严格响应时间的ETL管道进行批处理的应用程序使用同步调用是可以的。在这些情况下进行异步IO调用将导致过早优化，并可能使系统过于复杂。</p><p id="6002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的一个经验法则是，如果效率不是一个要求，你几乎总是想要简单。简单不代表容易。简单来说，你可能需要做很多工作。这项工作可能包括创建抽象以使应用程序可维护。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3592" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="a5ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">过度优化应用程序会增加复杂性。因此，只有在必要时才尝试优化。</p><p id="7ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你从这篇文章中得到了什么，那应该是:在必要的时候使用异步通信。总是想着简单。例如，有很多方法可以编写Fizz Buzz，你可以让算法变得非常复杂，非常高效。但是，如果应用程序的目的是调用可被3整除的数字上的“Fizz”和可被5整除的数字上的“Buzz ”,则不需要使用回调来实现该算法。它不需要有纳秒级的性能。</p><p id="8415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现您的微服务也是如此。如果消息队列可以解决系统中的瓶颈，那么它是必要的。一些新的技术或范例被创造出来以解决特定的问题。如果系统没有这个问题，它会制造复杂性，从长远来看会伤害我们。希望这份清单可以帮助您为您的应用确定正确的决策。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f0ab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="0691" class="mz na it lb b lc mu lf mv li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" href="https://dzone.com/articles/asynchronous-communication-methods-and-strategies" rel="noopener ugc nofollow" target="_blank">异步通信—方法和策略— DZone性能</a></li><li id="f834" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://stackify.com/when-to-use-asynchronous-programming/" rel="noopener ugc nofollow" target="_blank">何时使用(或不使用)异步编程:20位专家揭示最佳用例——stack ify</a></li></ul><p id="db5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【https://edward-huang.com】最初发表于<a class="ae ky" href="https://edward-huang.com/best-practice/distributed-system/2021/04/07/three-use-case-when-you-do-not-need-to-use-asynchronous-communication-in-your-microservice/" rel="noopener ugc nofollow" target="_blank"><em class="nn"/></a><em class="nn">。</em></p></div></div>    
</body>
</html>