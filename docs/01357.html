<html>
<head>
<title>Two Practical Uses of Enum in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Enum在Swift中的两个实际应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/two-very-practical-uses-of-enum-in-swift-36b9967d1925?source=collection_archive---------8-----------------------#2019-09-03">https://betterprogramming.pub/two-very-practical-uses-of-enum-in-swift-36b9967d1925?source=collection_archive---------8-----------------------#2019-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="48cd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">具有关联类型和通用枚举模式的Swift枚举</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f523f57595418ec7a066a8b13ad0dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83fzu_MwQifGcVnFhn3y_Q.jpeg"/></div></div></figure><p id="549f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我最近的任务是编写优化的Swift SDK。随着Swift 5的推出和Swift对嵌入式框架的支持，时机似乎是正确的。</p><p id="e7c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单介绍一下背景，<a class="ae ln" href="https://www.optimizely.com/" rel="noopener ugc nofollow" target="_blank"> Optimizely </a> Swift SDK用于在您的iOS或tvOS设备上运行A/B测试以及功能管理。</p><p id="ebae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在完成<a class="ae ln" href="https://cocoapods.org/pods/OptimizelySwiftSDK" rel="noopener ugc nofollow" target="_blank"> Swift SDK </a>(我们现在正式发布)之后，我回顾了一些出现的模式。有些很早就出现了，比如enum的使用，而有些则是在开发过程中出现的需求。这已经变成了一个由四部分组成的系列，其中我将讨论最有用的设计模式。特别是，我们将讨论Swift enums和相关类型以及在Swift 5中采用的<code class="fe lo lp lq lr b">result</code>通用enum模式。然后，我们将讨论被证明非常有用的通用类<code class="fe lo lp lq lr b">AtomicProperty</code>。接下来，我们讨论依赖注入。最后，我们将介绍如何在Swift代码中公开Objective-C API，而不影响Swift的设计、实施和代码。</p><p id="1330" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们直接开始吧！</p><p id="cfdb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发这个SDK的第一个挑战是使用一个配置JSON文件。为了做到这一点，我使用了一个在线JSON到Swift数据对象转换器来创建我的初始数据对象。这处理得很好，但是当JSON字段可能是多种类型时，需要做很多额外的工作。我的结局是这样的:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="a695" class="lw lx iq lr b gy ly lz l ma mb"><strong class="lr ir">struct</strong> UserAttribute: Codable, Equatable {</span><span id="a234" class="lw lx iq lr b gy mc lz l ma mb"><em class="md"> // MARK: — JSON parse</em></span><span id="6e1a" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> name: String?</span><span id="463b" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> type: String?</span><span id="1232" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> match: String?</span><span id="e0d8" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> value: Any?</span><span id="ce16" class="lw lx iq lr b gy mc lz l ma mb">}</span></pre><p id="123c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很好，也是可行的。这只是意味着您需要添加自定义的编码和解码方法。这也意味着每次你想使用它的时候，你必须弄清楚它的类型和类型。更干净、更可重用的解决方案是使用带有关联值的Swift enum。这看起来更像这样:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="f527" class="lw lx iq lr b gy ly lz l ma mb"><strong class="lr ir">struct</strong> UserAttribute: Codable, Equatable {</span><span id="99ab" class="lw lx iq lr b gy mc lz l ma mb"><em class="md"> // MARK: — JSON parse</em></span><span id="f1ad" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> name: String?</span><span id="a085" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> type: String?</span><span id="d2ea" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> match: String?</span><span id="d4d5" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> value: AttributeValue?</span><span id="dca9" class="lw lx iq lr b gy mc lz l ma mb">}</span></pre><p id="da71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在您可以使用<code class="fe lo lp lq lr b">CodingKey</code>来定义您的json名称，并让<code class="fe lo lp lq lr b">AttributeValue</code>来完成繁重的工作。将<a class="ae ln" href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html" rel="noopener ugc nofollow" target="_blank"> Swift enum </a>关联值想象成一个c联合，在这里它可以被转换成任意数量的类型。我们使用case语句来关联每个值的名称和类型。我们还实现了<a class="ae ln" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank"> Codable </a>，它是json编码/解码的可编码和可解码协议的类型别名。下面是一个代码示例—一个支持多种类型的属性值的非常简单的声明(这可能是另一个数据结构的通用属性):</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="ce7e" class="lw lx iq lr b gy ly lz l ma mb"><strong class="lr ir">enum</strong> AttributeValue: Codable {</span><span id="0749" class="lw lx iq lr b gy mc lz l ma mb"> case string(String)</span><span id="a87f" class="lw lx iq lr b gy mc lz l ma mb"> case int(Int64) // supported value range [-2⁵³, 2⁵³]</span><span id="1cf4" class="lw lx iq lr b gy mc lz l ma mb"> case double(Double)</span><span id="dbda" class="lw lx iq lr b gy mc lz l ma mb"> case bool(Bool)</span><span id="d484" class="lw lx iq lr b gy mc lz l ma mb"> case others</span><span id="aa70" class="lw lx iq lr b gy mc lz l ma mb"> // here we get the container and try and decode the value as       different types and setting</span><span id="01d3" class="lw lx iq lr b gy mc lz l ma mb"> // self to the type we decoded.</span><span id="e88e" class="lw lx iq lr b gy mc lz l ma mb"> init(from decoder: Decoder) <strong class="lr ir">throws</strong> {</span><span id="f1de" class="lw lx iq lr b gy mc lz l ma mb"> let container = <strong class="lr ir">try</strong> decoder.singleValueContainer()</span><span id="2b1c" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> if</strong> let value = <strong class="lr ir">try</strong>? container.decode(String.self) {</span><span id="9dfc" class="lw lx iq lr b gy mc lz l ma mb">  self = .string(value)</span><span id="3bed" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  return</strong></span><span id="293d" class="lw lx iq lr b gy mc lz l ma mb"> }</span><span id="ff01" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> if</strong> let value = <strong class="lr ir">try</strong>? container.decode(Double.self) {</span><span id="664f" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  self</strong> = .double(value)</span><span id="4978" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  return</strong></span><span id="1996" class="lw lx iq lr b gy mc lz l ma mb"> }</span><span id="ee28" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> if</strong> let value = <strong class="lr ir">try</strong>? container.decode(Int64.self) {</span><span id="94ca" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  self</strong> = .int(value)</span><span id="5344" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  return</strong></span><span id="ec91" class="lw lx iq lr b gy mc lz l ma mb"> }</span><span id="1f0c" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> if</strong> let value = <strong class="lr ir">try</strong>? container.decode(Bool.self) {</span><span id="7a06" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  self</strong> = .bool(value)</span><span id="637e" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  return</strong></span><span id="b5bb" class="lw lx iq lr b gy mc lz l ma mb"> }</span><span id="7388" class="lw lx iq lr b gy mc lz l ma mb"> // accept all other types (null, {}, []) for forward compatibility support</span><span id="e44e" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> self</strong> = .others</span><span id="8bfc" class="lw lx iq lr b gy mc lz l ma mb">}</span><span id="e468" class="lw lx iq lr b gy mc lz l ma mb">// here we are encoding the values by switching on self.</span><span id="6269" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">func</strong> encode(to encoder: Encoder) <strong class="lr ir">throws</strong> {</span><span id="0044" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> container = encoder.singleValueContainer()</span><span id="800e" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> switch</strong> <strong class="lr ir">self</strong> {</span><span id="2047" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  case</strong> .string(let value):</span><span id="acf4" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">   try</strong> container.encode(value)</span><span id="2a0b" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  case</strong> .double(let value):</span><span id="87b8" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">   try</strong> container.encode(value)</span><span id="1b16" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  case</strong> .int(let value):</span><span id="8927" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">   try</strong> container.encode(value)</span><span id="5024" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  case</strong> .bool(let value):</span><span id="37e6" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  try</strong> container.encode(value)</span><span id="ef57" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  case</strong> .others:</span><span id="27b3" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  return</strong></span><span id="2b03" class="lw lx iq lr b gy mc lz l ma mb">  }</span><span id="66c8" class="lw lx iq lr b gy mc lz l ma mb"> }</span><span id="20bf" class="lw lx iq lr b gy mc lz l ma mb">}</span></pre><p id="81d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一个用法示例:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="6574" class="lw lx iq lr b gy ly lz l ma mb"><strong class="lr ir">func</strong> testEncodeDecodeString() {</span><span id="eff6" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> let</strong> attributeValue = AttributeValue.string(“json”)</span><span id="4dff" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> let</strong> jsonData = <strong class="lr ir">try</strong>! JSONSerialization.data(withJSONObject: [“json”], options: [])</span><span id="946d" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> let</strong> attributes = <strong class="lr ir">try</strong>! JSONDecoder().decode([AttributeValue].<strong class="lr ir">self</strong>, from: jsonData)</span><span id="01ac" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> switch</strong> attributes[0] {</span><span id="1e34" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  case</strong> .string(let str):</span><span id="488e" class="lw lx iq lr b gy mc lz l ma mb">   XCTAssert(str == “json”)</span><span id="e55d" class="lw lx iq lr b gy mc lz l ma mb">   XCTAssert(attributes[0] == attributeValue)</span><span id="58f0" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  default</strong>:</span><span id="b88b" class="lw lx iq lr b gy mc lz l ma mb">   XCTAssert(<strong class="lr ir">false</strong>)</span><span id="3a38" class="lw lx iq lr b gy mc lz l ma mb">  }</span><span id="e61c" class="lw lx iq lr b gy mc lz l ma mb">}</span></pre><p id="c963" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所看到的，在Swift中使用enums绝对是json编码和解码正确值的强大工具。通过从容器对象中提取代码，可以在任何需要支持多个属性的地方重用枚举。我们甚至可以为特定的验证添加一些额外的验证方法或挂钩。我发现这种封装方法比在我的容器对象上支持<code class="fe lo lp lq lr b">Any?</code>并不断地强制转换它要干净得多。它还帮助我的容器编码和解码变得干净。</p><p id="639c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Swift 5中采用的另一个伟大模式是<code class="fe lo lp lq lr b">result</code> enum。<code class="fe lo lp lq lr b">result</code>枚举保存错误的返回类型，并使用泛型来确定错误和返回值可能是什么。它使得切换和处理结果变得容易。</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="b232" class="lw lx iq lr b gy ly lz l ma mb"><strong class="lr ir">enum</strong> Result&lt;T, Error&gt; {</span><span id="89ee" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> case</strong> success(T)</span><span id="ea6b" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> case</strong> failure(error)</span><span id="af3d" class="lw lx iq lr b gy mc lz l ma mb">}</span></pre><p id="3f92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可用于定义函数签名，如下所示:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="b8b6" class="lw lx iq lr b gy ly lz l ma mb"><strong class="lr ir">public</strong> <strong class="lr ir">enum</strong> OptimizelyError: Error {</span><span id="63b7" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> case</strong> generic</span><span id="0809" class="lw lx iq lr b gy mc lz l ma mb">}</span><span id="a59c" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">public</strong> <strong class="lr ir">typealias</strong> DatafileDownloadCompletionHandler = (Result&lt;Data?, OptimizelyError&gt;) -&gt; Void</span><span id="a252" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">func</strong> downloadDatafile(sdkKey: String,</span><span id="b65e" class="lw lx iq lr b gy mc lz l ma mb">completionHandler:<strong class="lr ir">@escaping</strong> DatafileDownloadCompletionHandler) {</span><span id="49b9" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> let</strong> task = session.downloadTask(with: request) { (url, response, error) <strong class="lr ir">in</strong></span><span id="5472" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> var</strong> result = Result&lt;Data?,OptimizelyError&gt;.failure(.generic(“Failed to parse”))</span><span id="2a83" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> if</strong> error != <strong class="lr ir">nil</strong> {</span><span id="259f" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> self</strong>.logger.e(error.debugDescription)</span><span id="f7f5" class="lw lx iq lr b gy mc lz l ma mb"> result = .failure(.generic(error.debugDescription))</span><span id="3e01" class="lw lx iq lr b gy mc lz l ma mb"> } <strong class="lr ir">else</strong> <strong class="lr ir">if</strong> <strong class="lr ir">let</strong> response = response <strong class="lr ir">as</strong>? HTTPURLResponse {</span><span id="991c" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> if</strong> response.statusCode == 200 {</span><span id="9e37" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> let</strong> data = <strong class="lr ir">self</strong>.getResponseData(sdkKey: sdkKey, response: response,   url: url)</span><span id="4507" class="lw lx iq lr b gy mc lz l ma mb"> result = .success(data)</span><span id="8f82" class="lw lx iq lr b gy mc lz l ma mb"> } <strong class="lr ir">else</strong> <strong class="lr ir">if</strong> response.statusCode == 304 {</span><span id="f0ba" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  self</strong>.logger.d(“The datafile was not modified and won’t be downloaded again”)</span><span id="57cd" class="lw lx iq lr b gy mc lz l ma mb">  result = .success(<strong class="lr ir">nil</strong>)</span><span id="224f" class="lw lx iq lr b gy mc lz l ma mb"> }</span><span id="268f" class="lw lx iq lr b gy mc lz l ma mb">  completionHandler(result)</span><span id="6399" class="lw lx iq lr b gy mc lz l ma mb"> }</span><span id="a693" class="lw lx iq lr b gy mc lz l ma mb">task.resume</span><span id="bdfe" class="lw lx iq lr b gy mc lz l ma mb">}</span></pre><p id="c26b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可以按如下方式消耗:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="1ec7" class="lw lx iq lr b gy ly lz l ma mb">downloadDatafile(sdkKey: sdkKey) { (result) <strong class="lr ir">in</strong></span><span id="805c" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir"> switch</strong> result {</span><span id="0b11" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  case</strong> .success(<strong class="lr ir">let</strong> data):<br/>    datafile = data</span><span id="a2c8" class="lw lx iq lr b gy mc lz l ma mb"><strong class="lr ir">  case</strong> .failure(<strong class="lr ir">let</strong> error):<br/>   <strong class="lr ir">self</strong>.logger.e(error.reason)</span><span id="8276" class="lw lx iq lr b gy mc lz l ma mb"> }<br/>}</span></pre><p id="1268" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Swift 5之前，我们编写自己的结果，大多数Swift开发人员也是如此。事实上，我们仍然使用我们的<code class="fe lo lp lq lr b">OptimizelyResult</code>。Result enum是一个受欢迎的附加功能，是已经被广泛采用的酷模式的一个补充。产生的模式和用于编码和解码的enum关联值只是Swift中枚举功能的几个例子。按照这里描述的方式使用它们是轻松集成json对象和处理结果的好方法。</p><p id="924f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这是有用的。下次我们将讨论Swift中的原子性质。</p></div></div>    
</body>
</html>