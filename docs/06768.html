<html>
<head>
<title>Advanced Programming With Kotlin (Part 6)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin进行高级编程(第6部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-programming-with-kotlin-part-6-3f33290d8aad?source=collection_archive---------6-----------------------#2020-11-03">https://betterprogramming.pub/advanced-programming-with-kotlin-part-6-3f33290d8aad?source=collection_archive---------6-----------------------#2020-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f16" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kotlin 1.4版本中的语言增强</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/49feaa131b88068a1a3104fe7661de1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*v4LXaVKgUORTM_BP565Q8g.jpeg"/></div></figure><p id="a54b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" href="https://kotlinlang.org/docs/reference/whatsnew14.html" rel="noopener ugc nofollow" target="_blank"> Kotlin 1.4 </a>最近发布了许多期待已久的功能和令人兴奋的跨领域增强。这是Kotlin作为一个平台发展的一个重要里程碑，它致力于使标准库保持一致并满足开发者的期望。在这篇文章中，我们将探索它们。</p><p id="c990" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我想提到的一件令人兴奋的事情是10月12日举办的Kotlin在线活动。活动录像可从JetBrains的官方<a class="ae lm" href="https://www.youtube.com/user/JetBrainsTV" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>或Kotlin <a class="ae lm" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">网站</a>上获得。</p><p id="b794" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您会发现关于新特性的最新更新的深入技术讨论，如<a class="ae lm" href="https://github.com/Kotlin/kotlinx-datetime" rel="noopener ugc nofollow" target="_blank"> kotlinx.dateTime </a>库、协程调试的改进、<a class="ae lm" href="https://github.com/Kotlin/kotlinx.serialization" rel="noopener ugc nofollow" target="_blank"> kotlinx.serialization </a>，以及多平台和服务器端开发。</p><p id="2723" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">事不宜迟，让我们开始了解Kotlin 1.4中引入的新特性。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="29df" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak"> SAM转换</strong></h1><p id="cc54" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">单抽象方法(SAM)转换只不过是在需要SAM接口时传递lambda或可调用引用的能力。在Kotlin 1.4之前，我们只能在Java接口上应用SAM转换。</p><p id="b1b9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你试图在Kotlin接口上这样做，它会抛出一个异常:<em class="mr">请使用函数类型</em>。从1.4版本开始，我们也可以在Kotlin接口上使用它；我们需要在interface关键字前添加<code class="fe ms mt mu mv b">fun</code>修饰符来使其工作。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4c42" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">很多人已经要求这个功能很长时间了。由于大量的修复请求，他们引入了功能接口。引入函数接口背后的原因是意图应该是显式的，这意味着如果你希望一个接口有SAM转换，通过添加一个<code class="fe ms mt mu mv b">fun</code>关键字使它显式。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="9a5b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">显式API模式</h1><p id="ec63" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">Kotlin是一种非常方便的语言，具有许多便利的特性；我喜欢我们不需要明确提到函数的返回类型。</p><p id="d43f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然它很方便，但也没有什么缺点。如果你没有明确提到返回类型，那么编译器会根据返回值自动决定类型。这种方法可能会导致代码中不可预见的错误。为了更好地理解，让我们看一下下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e7f3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在上面的代码中，基于返回值，编译器在没有任何通知的情况下将返回类型从<code class="fe ms mt mu mv b">String</code>更改为<code class="fe ms mt mu mv b">Any</code>，这可能导致了代码中其他地方的错误。</p><p id="62b9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，从Kotlin 1.4开始，编译器会显示一个错误，指出具有不同返回值类型的函数的返回类型，这是推荐的方法。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="c0cf" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">尾随逗号</h1><p id="6b47" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">下一个特性是语言的改进。尾随逗号是提高语言可用性的一个特性。例如，如果在Kotlin 1.4之前的函数或构造函数中有一个参数列表，则不能在最后一个参数的末尾添加逗号。</p><p id="321d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们想要交换参数时，这使得情况变得困难；例如，当您将最后一个参数与前一个参数交换时，我们需要手动添加逗号和删除逗号。这个问题可以通过引入<em class="mr">尾随逗号来解决，</em>我们甚至可以为最后一个参数添加一个逗号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="d083" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">在“when”块中中断并继续</h1><p id="bdbe" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">科特林<code class="fe ms mt mu mv b">when</code>街区是一个革命性的特征。这是我在Kotlin体验中使用最多的功能之一。其中一个缺点是，当我们试图在<code class="fe ms mt mu mv b">when</code>块中使用<code class="fe ms mt mu mv b">break</code>或<code class="fe ms mt mu mv b">continue</code>关键字时，它会抛出一个错误:<em class="mr">when语句中不允许使用Break和continue。</em></p><p id="d0b0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">解决这个问题的方法之一是使用标签，请看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">科特林1.3</p></figure><p id="9670" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Kotlin 1.4允许<code class="fe ms mt mu mv b">when</code>语句中的<code class="fe ms mt mu mv b">break</code>和<code class="fe ms mt mu mv b">continue</code>在没有任何标签的循环内。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">科特林1.4</p></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="1809" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">混合命名参数和位置参数</h1><p id="2dc9" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">Kotlin讨论了Java的主要难点——其中我最喜欢的一个是命名参数。当一个函数中有三个以上的参数时，我们在传递值时经常会忘记参数的顺序。有了命名实参，我们可以指定形参的名称并传递值，不需要遵循任何顺序。看一看:</p><pre class="kj kk kl km gt nc mv nd ne aw nf bi"><span id="4fa2" class="ng lv it mv b gy nh ni l nj nk">drawCustomView( <strong class="mv iu">height =</strong> 30, <strong class="mv iu">width =</strong> 30, <strong class="mv iu">color =</strong> Color.GREEN )</span></pre><p id="a4d7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在大多数情况下，使用名称参数是有帮助的，比如上面代码中的高度和宽度，但是没有必要使用颜色参数名称。Kotlin 1.4允许您组合命名参数和位置参数，这意味着我们不需要像<code class="fe ms mt mu mv b">color</code>那样为参数编写参数名，只要它们按顺序放置即可。</p><pre class="kj kk kl km gt nc mv nd ne aw nf bi"><span id="623d" class="ng lv it mv b gy nh ni l nj nk">drawCustomView( <strong class="mv iu">height =</strong> 30, <strong class="mv iu">width =</strong> 30, Color.GREEN )</span></pre></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="9d38" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">命名约定的增强</h1><h2 id="283d" class="ng lv it bd lw nl nm dn ma nn no dp me kz np nq mg ld nr ns mi lh nt nu mk nv bi translated">“最大”、“最小”功能</h2><p id="ee51" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">从Kotlin 1.0开始，尝试在空列表上使用<code class="fe ms mt mu mv b">max</code>和<code class="fe ms mt mu mv b">min</code>函数总是会产生<code class="fe ms mt mu mv b">null</code>结果，这不是命名约定的预期结果。使用<code class="fe ms mt mu mv b">orNull</code>后缀是合适的。</p><p id="5b37" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">随着Kotlin的不断发展，这种命名惯例与他们的理念不符。所以在<strong class="ks iu"> </strong> Kotlin 1.4中有所改变:增加了<code class="fe ms mt mu mv b">maxOrNull</code>和<code class="fe ms mt mu mv b">minOrNull</code>两个新函数，旧的<code class="fe ms mt mu mv b">max</code>和<code class="fe ms mt mu mv b">min</code>函数被弃用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="5c01" class="ng lv it bd lw nl nm dn ma nn no dp me kz np nq mg ld nr ns mi lh nt nu mk nv bi translated">“零”函数</h2><p id="f910" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">标准库包含两组函数，常规函数和带有<code class="fe ms mt mu mv b">orNull</code>后缀的对应函数。例如，<code class="fe ms mt mu mv b">toInt</code>是常规函数，而<code class="fe ms mt mu mv b">toIntOrNull</code>是对应函数。</p><p id="c0fb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不同之处在于，常规的组函数返回一个非空值，或者在出错时抛出一个异常，比如当一个字符串不能被转换成整数时。相反，如果出现问题，<code class="fe ms mt mu mv b">OrNull</code>后缀函数会返回<code class="fe ms mt mu mv b">null</code>。</p><p id="3b33" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Kotlin 1.4中，增加了一个新的<code class="fe ms mt mu mv b">orNull</code>函数——即<code class="fe ms mt mu mv b">randomOrNull</code>函数。它的作用是在出错时给你一个随机结果或<code class="fe ms mt mu mv b">null</code>。当你想从列表中选择一个随机数时，这是很有帮助的。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="25fe" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">“onEach”和“onEachIndexed”</h1><p id="3cdd" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated"><code class="fe ms mt mu mv b">onEach</code>和<code class="fe ms mt mu mv b">onEachIndexed</code>在Kotlin 1.4中引入；<code class="fe ms mt mu mv b">forEach</code>对每个元素执行给定的动作，而<code class="fe ms mt mu mv b">onEach</code>对每个元素执行给定的动作，然后返回集合本身。</p><p id="1480" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">可以在调用链中间使用<code class="fe ms mt mu mv b">onEach</code>和<code class="fe ms mt mu mv b">onEachIndexed</code>。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="0141" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">“减少”和“运行减少”</h1><p id="de0c" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated"><code class="fe ms mt mu mv b">runningReduce</code>是Kotlin 1.4中新增的功能。现有的<code class="fe ms mt mu mv b">reduce</code>计算并分析每个元素，而新的<code class="fe ms mt mu mv b">runningReduce</code>在整个操作完成之前不会分析任何元素。</p><p id="9f96" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一般的<code class="fe ms mt mu mv b">reduce</code>函数返回最终结果，而<code class="fe ms mt mu mv b">runningReduce</code>返回所有的中间步骤。这就是<code class="fe ms mt mu mv b">reduce</code>和<code class="fe ms mt mu mv b">runningReduce</code>的区别。名为<code class="fe ms mt mu mv b">runningFold</code>的类似功能已添加到折叠功能中。请看下图，以便有更好的了解:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/0d01686d3d943312754cbebc6b2e31d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T17Xyg6NyaiS3Trs2u2J4Q.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">截图自2020年科特林线上活动</p></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="fac9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">参考</h1><p id="5d99" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">要了解更多关于Kotlin 1.4的信息，请访问以下链接:</p><div class="ob oc gp gr od oe"><a href="https://kotlinlang.org/docs/reference/whatsnew14.html" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Kotlin 1.4的新特性- Kotlin编程语言</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">在Kotlin 1.4.0中，我们对其所有组件进行了大量改进，重点是质量和性能…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">kotlinlang.org</p></div></div><div class="on l"><div class="oo l op oq or on os ko oe"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot mx l"/></div></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="7207" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">奖金</h1><p id="b819" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">要了解更多关于Kotlin的知识，请阅读“使用Kotlin进行高级编程”系列的前几部分:</p><ul class=""><li id="ac89" class="ou ov it ks b kt ku kw kx kz ow ld ox lh oy ll oz pa pb pc bi translated"><a class="ae lm" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">“使用Kotlin进行高级编程—第1部分”</a></li><li id="fe04" class="ou ov it ks b kt pd kw pe kz pf ld pg lh ph ll oz pa pb pc bi translated"><a class="ae lm" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">“用Kotlin进行高级编程—第二部分</a>”</li><li id="bd8e" class="ou ov it ks b kt pd kw pe kz pf ld pg lh ph ll oz pa pb pc bi translated"><a class="ae lm" href="https://medium.com/better-programming/advanced-programming-in-kotlin-2e01fbc39134" rel="noopener">《用Kotlin进行高级编程—第三部分》</a></li><li id="55eb" class="ou ov it ks b kt pd kw pe kz pf ld pg lh ph ll oz pa pb pc bi translated"><a class="ae lm" href="https://medium.com/better-programming/advanced-android-programing-in-kotlin-part-4-187b88fea048" rel="noopener">“使用Kotlin进行高级编程—第4部分”</a></li><li id="03b2" class="ou ov it ks b kt pd kw pe kz pf ld pg lh ph ll oz pa pb pc bi translated"><a class="ae lm" href="https://medium.com/better-programming/advanced-programming-in-kotlin-part-5-b674ce9e692f" rel="noopener">“使用Kotlin进行高级编程—第5部分”</a></li></ul></div></div>    
</body>
</html>