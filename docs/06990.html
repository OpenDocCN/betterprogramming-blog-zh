<html>
<head>
<title>Is Virtual DOM Derived From Document Fragments?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">虚拟DOM是来源于文档片段吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-virtual-dom-derived-from-document-fragments-74f8841f9e6d?source=collection_archive---------8-----------------------#2020-11-24">https://betterprogramming.pub/is-virtual-dom-derived-from-document-fragments-74f8841f9e6d?source=collection_archive---------8-----------------------#2020-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e059" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">DOM、文档片段、虚拟DOM、反应片段、增量DOM和影子DOM的采访指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/47c97f7527e5b080820a536c626342f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DPFY7vtuIvJOsS0x"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@manuelsardo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Manuel Sardo </a>拍摄的照片</p></figure><p id="ccb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟DOM是React的核心概念。它是保存在内存中并与实际DOM同步的UI的表示。<a class="ae ky" href="https://github.com/facebook/react/tree/master/packages/react-dom" rel="noopener ugc nofollow" target="_blank"> React DOM </a>通过本地协调差异来维护虚拟DOM。根据React拉取时间表，更改被插入到实际的DOM中。</p><p id="f2d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment" rel="noopener ugc nofollow" target="_blank">DocumentFragment</a></code>是一个定义最小文档对象的接口，没有父对象。它被用作<code class="fe lv lw lx ly b">Document</code>的轻量级版本，存储DOM对象。文档片段对实际的DOM没有影响。但是他们的孩子可以根据需要添加到实际的DOM中。</p><p id="6734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟DOM和文档片段使用相同的概念来提高UI性能。虚拟DOM是从文档片段中派生出来的吗？</p><p id="6933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们深入了解一下这些JavaScript、React和Angular概念。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bfa6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是DOM？</h1><p id="95ad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank">文档对象模型(DOM) </a>是对象的数据表示，包括web上文档的结构和内容。DOM是HTML和XML文档的接口。它表示页面，以便程序可以更改文档结构、样式和内容。DOM将文档表示为节点和对象。通过这种方式，JavaScript等编程语言可以连接到页面。</p><p id="c55d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个DOM树的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/7aa73fb49660038e7700402c72f83bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/0*TKQ3K93zzwrqDFcb.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:维基百科</p></figure><p id="9812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想在加载100万个节点的压力下评估性能吗？试试下面的<code class="fe lv lw lx ly b">index.html</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="99e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次运行的持续时间不同，但大约是2.5秒。</p><p id="0f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DOM操作是一项开销很大的操作。添加/移除元素会导致内容的中间重绘和重排。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="be42" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">为什么要使用文档片段？</h1><p id="a1d4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">document.createDocumentFragment()</code>创建一个新的空的<code class="fe lv lw lx ly b">DocumentFragment</code>, DOM节点可以被添加到其中以构建一个离屏DOM树。在构建了屏幕外DOM树之后，可以根据需要将<code class="fe lv lw lx ly b">DocumentFragment</code>的子节点更新到DOM中。</p><p id="28b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为文档片段在内存中，不是实际DOM的一部分，所以向它追加子元素不会导致页面回流(元素位置和几何形状的计算)。很可能，用较少的文档片段更新来批处理更改，最终会获得更好的性能。</p><p id="911c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何使用文档片段的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ae6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次运行的持续时间不同，但大约为1.5秒。</p><p id="447d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将子元素附加到实际的DOM之后(第25行)，文档片段变成了空的。如果想要重用更新的内容，在将文档片段附加到DOM之前克隆它。</p><p id="b03d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，空文档片段可以被重用来构建未来的更新。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ac93" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">虚拟DOM是如何工作的？</h1><p id="164d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">虚拟DOM是从文档片段中派生出来的吗？</p><p id="f7d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不，虚拟DOM不使用任何文档片段。</p><p id="688c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，虚拟DOM来源于使用虚拟DOM来提高性能的概念。然而，虚拟DOM是为大规模更新而设计的。它还可以应用于不存在DOM的环境，比如Node.js，React是第一个使用虚拟DOM的主流框架。此外，虚拟DOM已经被Vue、Ember、Preact和Mithril采用。</p><p id="9fa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从版本16开始，React一直使用<a class="ae ky" href="https://github.com/acdlite/react-fiber-architecture" rel="noopener ugc nofollow" target="_blank">光纤架构</a>。</p><blockquote class="ng nh ni"><p id="3543" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">“在UI中，没有必要立即应用每个更新；事实上，这样做可能会造成浪费，导致丢帧，降低用户体验。</p><p id="da36" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">不同类型的更新具有不同的优先级，例如，动画更新需要比来自数据存储的更新更快地完成。</p><p id="6f3c" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">基于推送的方法需要应用程序(你，程序员)来决定如何安排工作。基于拉的方法允许框架(React)变得聪明并为您做出那些决定。“— <a class="ae ky" href="https://github.com/acdlite/react-fiber-architecture" rel="noopener ugc nofollow" target="_blank">在GitHub上反应光纤架构</a></p></blockquote><p id="d327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React被设计成具有独立的协调和渲染阶段。</p><ul class=""><li id="4300" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">协调:【React使用算法来区分不同的树，以确定哪些部分需要更改。不同的组件类型被假定为产生实质上不同的树。React不会尝试改变它们，而是完全替换旧树。列表的区分是使用键来执行的。密钥应该是稳定的、可预测的和唯一的。</strong></li><li id="4bb1" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">呈现:</strong>该过程使用diff信息来实际更新呈现的应用程序。它可以将渲染工作分割成块，并分散到多个帧上。它使用一个虚拟堆栈框架来暂停工作并在以后返回，为不同类型的工作分配优先级，重用以前完成的工作，并在不再需要时中止工作。</li></ul><p id="2327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种分离允许React DOM和React Native使用它们自己的渲染器，同时共享同一个协调器。</p><p id="a6e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子来展示虚拟DOM的优势。这是从<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener">创建反应应用</a>修改而来的<code class="fe lv lw lx ly b">public/index.html</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第30行和第31行是两个并排的<code class="fe lv lw lx ly b">span</code>元素。</p><p id="70e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个修改过的<code class="fe lv lw lx ly b">src/app.js</code>文件，它在React中呈现了一个<code class="fe lv lw lx ly b">select</code>元素。从React 17开始，React组件不再需要导入React来使用JSX。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="99bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是修改过的<code class="fe lv lw lx ly b">src/index.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c1a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第8-13行使用实际的DOM呈现了一个<code class="fe lv lw lx ly b">select</code>元素。</p><p id="3986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第15-20行使用虚拟DOM呈现一个<code class="fe lv lw lx ly b">select</code>元素。</p><p id="8d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它显示了两个并排的<code class="fe lv lw lx ly b">select</code>元素，其中<code class="fe lv lw lx ly b">Apple</code>被选中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/77a069ffb55d961b99502d6651e40fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*4JdRMubVMO74wspoE7sIDQ.png"/></div></figure><p id="610c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当第23行触发更新时，每秒钟会重新创建两个<code class="fe lv lw lx ly b">select</code>元素。</p><p id="52ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试为两个元素选择<code class="fe lv lw lx ly b">Pear</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/808ab76d339f73d6cb69e43c1784bab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*oypRBs4_g8WmGAYFbq1Zbw.png"/></div></figure><p id="3512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左边的<code class="fe lv lw lx ly b">select</code>直接渲染到DOM。娱乐使人无法选择<code class="fe lv lw lx ly b">Pear</code>。</p><p id="22a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">右边的<code class="fe lv lw lx ly b">select</code>先渲染到虚拟DOM。频繁的重建发生在虚拟DOM上，而不是实际的DOM上。因此，<code class="fe lv lw lx ly b">select</code>元件工作正常。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f88e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">关于反应片段</h1><p id="c3a7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了让情况变得更有趣，React创建了一种语法来对一系列子元素进行分组，而无需向DOM添加额外的节点。这个语法叫做<code class="fe lv lw lx ly b">React.Fragment</code>。下面是一个<code class="fe lv lw lx ly b">React.Fragment</code>的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fbae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.Fragment</code>可以简化为空标签:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用显式<code class="fe lv lw lx ly b">&lt;React.Fragment&gt;</code>语法声明的片段可能有键。这是官方文件提供的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了命名，片段与文档片段无关。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="24a4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是增量DOM？</h1><p id="8934" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">增量DOM是一个用于构建DOM树并在数据改变时更新它们的库。它与虚拟DOM方法的不同之处在于没有创建中间树(现有的树在适当的位置发生了变异)。这种方法大大减少了对DOM树进行增量更新时的内存分配和GC抖动，因此在某些情况下显著提高了性能。</p><p id="1294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">增量DOM删除DOM的附加副本。这导致了内存使用的减少，但也导致了寻找差异时速度的降低。减少内存使用对于移动或其他内存受限的设备至关重要。</p><p id="b5b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">增量DOM主要是作为Angular等模板语言的编译目标。从版本9开始，Angular采用了Angular Ivy，这是一个使用增量DOM的编译器和运行时。</p><p id="0ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是来自<a class="ae ky" href="http://google.github.io/incremental-dom/" rel="noopener ugc nofollow" target="_blank">官网</a>的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1f51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码对应于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的<code class="fe lv lw lx ly b">renderPart</code>函数，<code class="fe lv lw lx ly b">patch</code>函数可用于将所需的结构渲染到现有的<code class="fe lv lw lx ly b">Element</code>或<code class="fe lv lw lx ly b">Document</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ed73" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">影子DOM是什么？</h1><p id="e85a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">影子DOM是一种确保代码、样式和结构封装在一个单独的、隐藏的DOM树中的技术。影子DOM可以附加到DOM中的一个元素上。Shadow DOM是Web Components的一部分，Web Components是一套用于创建可重用定制元素的不同技术。</p><p id="8c28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是影子DOM的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第8-18行定义了Shadow DOM中的一个元素类。这个类被定义为一个新的标签，<code class="fe lv lw lx ly b">new-number-list-element</code>，注册到<code class="fe lv lw lx ly b">window.customElements</code>(第20行)。新创建的定制元素在第25行使用。</p><p id="84fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Angular Ivy之前，老的编译器和运行时是View Engine，用的是Shadow DOM。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="162b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="f4fc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经回答了“虚拟DOM是从文档片段中派生出来的吗？”</p><p id="62cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于长的答案，我们已经走过了DOM、文档片段、虚拟DOM、React片段、增量DOM和影子DOM。这些知识对于面试和日常编码都很有用。</p><p id="e69c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>