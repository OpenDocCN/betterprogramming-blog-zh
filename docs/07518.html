<html>
<head>
<title>Implement a Periodically Refreshing Cache in Your Golang App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在你的Golang应用中实现定期刷新缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-a-periodically-refreshing-cache-in-your-golang-app-9982aff4920?source=collection_archive---------7-----------------------#2021-01-22">https://betterprogramming.pub/implement-a-periodically-refreshing-cache-in-your-golang-app-9982aff4920?source=collection_archive---------7-----------------------#2021-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="557e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们提高web应用程序的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/131ae7a3995ed05aa5d42e38c17c9833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LxbttpJf28juyF5x"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jess Bailey 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="af4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后台定期刷新的缓存是几种用例中使用的常见模式，但是我们如何在Go中实现这一点呢？在本文中，我将向您介绍实现背后的概念，帮助您理解它是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/2dccb6eeb7dfecf6fb532500af8abba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*BZstYOuWMhBLuNoJ2bIPhA.png"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3096" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="aac2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">没有文字，更多代码。如果你想看完整的实现，直接去<a class="ae ky" href="https://gist.github.com/thomaspoignant/f2c901911e81f3109fe64ad840b5d393" rel="noopener ugc nofollow" target="_blank">这个要点</a>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e296" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">定期在后台做一些事情</h1><p id="2c57" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这个例子中，假设我们的缓存是一个简单的<code class="fe na nb nc nd b">map</code>:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="c477" class="ni me it nd b gy nj nk l nl nm">var <strong class="nd iu">cache</strong> map[string]interface{}</span></pre><p id="c83e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要的是拥有一个每<em class="nn"> X </em>秒<em class="nn">更新缓存的线程</em>。为了在Go中做到这一点，我们将使用一个<code class="fe na nb nc nd b">goroutine</code>来创建一个后台线程，它的作用是定期更新缓存。</p><p id="9350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有两个概念:创建一个新线程和定期处理一个动作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="2160" class="ni me it bd mf nq nr dn mj ns nt dp mn li nu nv mp lm nw nx mr lq ny nz mt oa bi translated">Goroutine和channel</h2><p id="a436" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如你所见，为了执行<code class="fe na nb nc nd b">startUpdaterDaemon</code> <strong class="lb iu"> </strong>功能，我们给它加上了前缀<code class="fe na nb nc nd b">go</code>。这个<strong class="lb iu"> </strong>意味着我们在一个新线程中调用这个函数。</p><p id="71dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以看到我们正在参数中发送一个通道<strong class="lb iu"> </strong>。正如在<a class="ae ky" href="https://codefarm.me/2017/06/11/goroutines-and-channels-in-go-lanugage/" rel="noopener ugc nofollow" target="_blank"> Code Farm </a>中所解释的，“通道是一种通信机制，它使一个goroutine能够向另一个goroutine发送值。”在这里，如果需要的话，我们可以用它来从外面阻止<code class="fe na nb nc nd b">goroutine</code>。</p><p id="d001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要停止<code class="fe na nb nc nd b">goroutine</code>，只需关闭通道:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9879" class="ni me it nd b gy nj nk l nl nm">defer <strong class="nd iu">close</strong>(updaterChan)</span></pre><p id="ec37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您将转到<code class="fe na nb nc nd b">select</code>的第二部分并从函数返回，从而停止无限循环:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="b432" class="ni me it nd b gy nj nk l nl nm">case &lt;-<strong class="nd iu">updaterChan</strong>:<br/>  // stop the daemon<br/>  <strong class="nd iu">return</strong></span></pre><p id="93a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多关于<code class="fe na nb nc nd b">goroutine</code>:</p><div class="ob oc gp gr od oe"><a href="https://pkg.go.dev/github.com/dc0d/goroutines" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">戈鲁廷斯</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">这个包提供了在goroutine上执行常见任务的实用程序——等待go routine启动、超时、do…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">pkg.go.dev</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><h2 id="a789" class="ni me it bd mf nq nr dn mj ns nt dp mn li nu nv mp lm nw nx mr lq ny nz mt oa bi translated">心脏</h2><p id="5162" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">第二个关键部分是<code class="fe na nb nc nd b">time.Ticker</code>。这个概念允许你管理什么时候做一个动作。当你在创建你的<code class="fe na nb nc nd b">time.Ticker</code>时，你给出一个<code class="fe na nb nc nd b">duration</code>，之后，你可以使用<code class="fe na nb nc nd b">ticker.C</code>来知道什么时候该做动作了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你完成时，不要忘记用<code class="fe na nb nc nd b">Stop()</code>功能关闭你的<code class="fe na nb nc nd b">time.Ticker</code>。</p><p id="befd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe na nb nc nd b">time.Ticker</code>的更多信息:</p><div class="ob oc gp gr od oe"><a href="https://pkg.go.dev/time#Ticker" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">时间</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">包装时间提供测量和显示时间的功能。日历计算总是假设…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">pkg.go.dev</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e28a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">管理缓存上的读/写</h1><p id="af9b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">实现一个好的缓存的另一个关键是考虑当你的包的其他部分同时在读缓存时，你如何写/修改你的缓存。</p><p id="ad0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了做到这一点，我们将使用互斥体。Go有一个我们需要的完美对象:<code class="fe na nb nc nd b">sync.RWMutex</code>。</p><blockquote class="ou ov ow"><p id="01b0" class="kz la nn lb b lc ld ju le lf lg jx lh ox lj lk ll oy ln lo lp oz lr ls lt lu im bi translated">RWMutex是一个读取器/写入器互斥锁。锁可以由任意数量的读取器或单个写入器持有。RWMutex的零值是一个未锁定的互斥体。— <a class="ae ky" href="https://golang.org/pkg/sync/" rel="noopener ugc nofollow" target="_blank"> Go的文档</a></p></blockquote><p id="7dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以同时有多个读者，但只能有一个作者。</p><p id="6dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要更新缓存，您应该在更新之前使用互斥体的<code class="fe na nb nc nd b">Lock()</code>。然后，在使用<code class="fe na nb nc nd b">Unlock()</code>功能更新后，释放您的锁定。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="20a8" class="ni me it nd b gy nj nk l nl nm"><em class="nn">// update the cache<br/></em><strong class="nd iu">mutex.Lock()</strong><em class="nn"> // lock the cache before writing into it<br/></em>cache["key3"] = time.Now()<br/><strong class="nd iu">mutex.Unlock()</strong><em class="nn"> // unlock the cache before writing into it</em></span></pre><p id="fba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个考虑是当你读取数据时。我们在这里所做的也是使用一个锁，但是这一次，我们使用<code class="fe na nb nc nd b">RLock()</code>和<code class="fe na nb nc nd b">RUnlock()</code>，因为我们想要有多个读锁。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="12c6" class="ni me it nd b gy nj nk l nl nm"><strong class="nd iu">mutex.RLock()</strong> <em class="nn">// add a read lock before reading the cache<br/></em>fmt.Println(cache["key3"])<br/><strong class="nd iu">mutex.RUnlock()</strong> <em class="nn">// release the read lock when reading is done</em></span></pre><p id="28a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe na nb nc nd b">RWMutex</code>的更多信息:</p><div class="ob oc gp gr od oe"><a href="https://golang.org/pkg/sync/#RWMutex" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">sync-Go编程语言</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">Cond实现了一个条件变量，一个等待或宣布事件发生的集合点</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">golang.org</p></div></div><div class="on l"><div class="pa l op oq or on os ks oe"/></div></div></a></div></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7973" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">完全解</h1><p id="7f6e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">完整的解决方案将如下所示。正如你所看到的，我们正在使用我们已经谈论过的所有上下文:<code class="fe na nb nc nd b">RWMutex</code>、<code class="fe na nb nc nd b">time.Ticker</code>、<code class="fe na nb nc nd b">goroutine</code>和<code class="fe na nb nc nd b">channel</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e79c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在下面的输出中看到的，缓存每三秒钟改变一次:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="58bd" class="ni me it nd b gy nj nk l nl nm">2021-01-20 20:48:54.415613 +0100 CET m=+0.000100959<br/>2021-01-20 20:48:54.415613 +0100 CET m=+0.000100959<br/>2021-01-20 20:48:57.418863 +0100 CET m=+3.003280863<br/>2021-01-20 20:48:57.418863 +0100 CET m=+3.003280863<br/>2021-01-20 20:48:57.418863 +0100 CET m=+3.003280863<br/>2021-01-20 20:49:00.415974 +0100 CET m=+6.000323481<br/>2021-01-20 20:49:00.415974 +0100 CET m=+6.000323481<br/>2021-01-20 20:49:00.415974 +0100 CET m=+6.000323481<br/>2021-01-20 20:49:03.420429 +0100 CET m=+9.004709000<br/>2021-01-20 20:49:03.420429 +0100 CET m=+9.004709000<br/>2021-01-20 20:49:03.420429 +0100 CET m=+9.004709000<br/>2021-01-20 20:49:06.419332 +0100 CET m=+12.003543113<br/>...</span></pre></div></div>    
</body>
</html>