<html>
<head>
<title>3 Ways To Upload Files to Google Cloud Storage With Next.js and Formidable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Next.js和harvardable将文件上传到Google云存储的3种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-ways-to-upload-files-to-google-cloud-storage-with-nextjs-and-formidable-3b58707e7886?source=collection_archive---------2-----------------------#2022-11-08">https://betterprogramming.pub/3-ways-to-upload-files-to-google-cloud-storage-with-nextjs-and-formidable-3b58707e7886?source=collection_archive---------2-----------------------#2022-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="83a8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这一宝贵功能的简要指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0fa014fc51a8eed104373ed6d65bbbce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8MV-qQIMOgGghyWSJ8_1g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自Canva的作者</p></figure><p id="629a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大家好。今天，我们将讨论在您的Next.js应用程序中上传文件的三种方法。每种方法都有其特定的用例，所以请阅读到最后。</p><p id="1b70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我创建了一个基本页面，用户可以在这里上传一个文件到一个<code class="fe lr ls lt lu b">/api/upload</code>端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/f9d55fa79bbdbd7c2bcc98494cd8cf64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSf6OSasInUbF4OGUDTRVA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自作者的UI演示图像</p></figure><p id="cafe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当用户点击按钮时，我们触发一个隐藏的文件输入。当添加新文件时，我们发送包含文件数据的POST请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/7ea11165d7a57bb851c7d692a4f4cebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWPctmjj2QxXSUr0uwHJuQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自carbon.now.sh作者的UI代码图像</p></figure><p id="bd04" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意图标来自<a class="ae lx" href="https://feathericons.com/" rel="noopener ugc nofollow" target="_blank">羽毛</a>。</p><p id="7943" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，确保你有一个谷歌云存储空间。现在，您将需要一个服务帐户密钥文件。如果您没有，请按照此处<a class="ae lx" href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating" rel="noopener ugc nofollow" target="_blank">列出的步骤</a>获取一个。</p><h1 id="c06e" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">初始化GCS</h1><pre class="kg kh ki kj gt mq lu mr ms aw mt bi"><span id="86d1" class="mu lz iq lu b gy mv mw l mx my">npm i @google-cloud/storage</span></pre><p id="52b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建一个名为<code class="fe lr ls lt lu b">lib</code>的新文件夹，并在其中创建一个名为<code class="fe lr ls lt lu b">gcs.ts</code>的文件。现在导出一个函数，在bucket中为指定的文件名打开一个写流。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="312c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">1.API路线</h1><p id="772d" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">我们使用<code class="fe lr ls lt lu b">node-formidable</code>在Next.js API路径中处理文件上传。但是默认情况下，文件解析在无服务器的环境中不起作用。我们将不得不安装<code class="fe lr ls lt lu b">formidable-serverless</code>。因此，在部署到Vercel、Netlify等时，处理文件上传应该是可行的。</p><pre class="kg kh ki kj gt mq lu mr ms aw mt bi"><span id="e588" class="mu lz iq lu b gy mv mw l mx my">npm i formidable<br/>npm i -D @types/formidable</span></pre><p id="dd37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是“承诺”表单解析的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3120" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还要注意，我们将代码从<code class="fe lr ls lt lu b">formidable-serverless</code>放到我们的文件夹中。NPM目前的版本没有使用最新版本的<code class="fe lr ls lt lu b">formidable</code>。</p><p id="56d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，在一个API route文件中定义一个<code class="fe lr ls lt lu b">handler</code>函数，它只接受POST并调用<code class="fe lr ls lt lu b">method1</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2f70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们禁用Next.js主体解析器，让<code class="fe lr ls lt lu b">formidable</code>完成它的工作(主体流)。</p><p id="0336" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以在<code class="fe lr ls lt lu b">lib</code>中创建一个<code class="fe lr ls lt lu b">upload.ts</code>文件来处理上传。</p><p id="034c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">formidable</code>将文件上传到服务器上的临时文件中，这样我们就可以调用一个好的ol’<code class="fe lr ls lt lu b">fs.createReadStream</code>。然后，我们可以跟随一个<code class="fe lr ls lt lu b">.pipe</code>到一个GCS桶存储写流。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9474" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您希望在将文件发送到GCS之前对其进行任何预处理，那么这种方法是最合适的。例如，您可能希望从音频文件中提取元数据，如持续时间、比特率和标题。</p><p id="5508" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是如果你不想要主机上的文件，你仍然可以直接上传到GCS。</p><h1 id="c36a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">2.具有直接流的API路线</h1><p id="7864" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">现在，我们来定义一下<code class="fe lr ls lt lu b">method2</code>。它将使用<code class="fe lr ls lt lu b">fileWriteStreamHandler</code>属性直接上传文件流。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b610" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的<code class="fe lr ls lt lu b">uploadStream</code>函数中，我们必须创建一个新的<code class="fe lr ls lt lu b">PassThrough</code>实例。一个<code class="fe lr ls lt lu b">PassThrough</code>流是必要的，这样<code class="fe lr ls lt lu b">formidable</code>就可以写这个流，并且我们仍然可以通过管道把它传递给GCS。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="9ac9" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">3.自定义Express服务器</h1><p id="07ae" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">如果API路由的使用限制了应用程序的需求，Next.js允许您创建一个定制的服务器。唯一的缺点就是不能再用Vercel了。</p><p id="2aa2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将使用<code class="fe lr ls lt lu b">express</code>来设置我们的后端服务器并定义上传路径。</p><p id="dad0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">npm i express dotenv<br/>npm i -D nodemon @types/express ts-node</code></p><p id="bfb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">确保使用服务器文件配置了TypeScript，这样我们仍然可以导入我们的文件上载方法。您可以在Next.js <a class="ae lx" href="https://github.com/vercel/next.js/tree/canary/examples/custom-server" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到一个工作示例。简而言之，我们使用一个额外的<code class="fe lr ls lt lu b">tsconfig</code>文件，用<code class="fe lr ls lt lu b">nodemon</code>观察文件变化，用<code class="fe lr ls lt lu b">ts-node</code>执行TypeScript。</p><p id="c6c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们通过添加带有端点的服务器代码来结束本文。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="994d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">包扎</h1><p id="5f45" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">今天，我们学习了三种将用户文件上传到谷歌云存储的不同方法。每一种都有自己的权衡。</p><p id="1515" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">仅此而已！如果你喜欢这篇文章，请继续关注。</p><p id="4f72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在GitHub的这里找到这篇文章<a class="ae lx" href="https://github.com/WoolDoughnut310/nextjs-gcs" rel="noopener ugc nofollow" target="_blank">的所有代码。</a></p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="32d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nn">原发布于</em><a class="ae lx" href="https://cs310.hashnode.dev/3-ways-to-upload-files-to-google-cloud-storage-with-nextjs-and-formidable" rel="noopener ugc nofollow" target="_blank"><em class="nn">https://cs 310 . hash node . dev</em></a>。</p></div></div>    
</body>
</html>