<html>
<head>
<title>Build Your First Rust API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您的第一个Rust API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-first-rust-api-cd2cba50cf8d?source=collection_archive---------4-----------------------#2021-02-23">https://betterprogramming.pub/build-your-first-rust-api-cd2cba50cf8d?source=collection_archive---------4-----------------------#2021-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1a7a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过使用Rocket.rs和Diesel.rs构建一个真实的API，亲自动手学习Rust</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a18b7f791f00c885b26114efbe3be703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1Npao1Ww536EDYBe2KZmw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@pawel_czerwinski?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">paweczerwiński</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a3f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我将描述如何使用流行的Rust web框架<a class="ae kv" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank"> Rocket </a>和<a class="ae kv" href="https://diesel.rs/" rel="noopener ugc nofollow" target="_blank"> Diesel </a>作为Postgres的ORM来构建一个简单的API。我最初构建这个小项目是为了学习Rust和上述技术，所以我认为尝试构建一些我可以以某种方式使用的东西是个不错的主意。这就是为什么我决定构建这个小API来帮助我管理我的作品集中的中型文章的链接。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ac17" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我们的API的结构</h1><p id="d10e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，让我们看看我们的API将如何构造。它将有三个主要的路由处理器:</p><ul class=""><li id="90bd" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><code class="fe nf ng nh ni b">/user</code> <strong class="ky ir"> : </strong>创建用户，然后验证用户的访问令牌</li><li id="4e6a" class="mw mx iq ky b kz nj lc nk lf nl lj nm ln nn lr nb nc nd ne bi translated"><code class="fe nf ng nh ni b">/auth</code> <strong class="ky ir"> : </strong>用于获取用户访问令牌的组</li><li id="699b" class="mw mx iq ky b kz nj lc nk lf nl lj nm ln nn lr nb nc nd ne bi translated"><code class="fe nf ng nh ni b">/posts</code> <strong class="ky ir"> <em class="no"> : </em> </strong>创建和检索帖子</li></ul><p id="72ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程结束时，我们的API中将有以下端点(这是我们运行服务器时得到的输出):</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="69af" class="nt ma iq ni b gy nu nv l nw nx">Mounting <em class="no">/user:</em></span><span id="dd0c" class="nt ma iq ni b gy ny nv l nw nx">=&gt; <strong class="ni ir"><em class="no">POST</em></strong> <em class="no">/user</em> <em class="no">application/json</em> <em class="no">(create)</em></span><span id="bc64" class="nt ma iq ni b gy ny nv l nw nx">=&gt; <strong class="ni ir"><em class="no">GET</em></strong> <em class="no">/user/info</em> <em class="no">(info)</em></span><span id="7818" class="nt ma iq ni b gy ny nv l nw nx">=&gt; <strong class="ni ir"><em class="no">GET</em></strong> <em class="no">/user/info</em> <em class="no">[2]</em> <em class="no">(info_error)</em></span><span id="65eb" class="nt ma iq ni b gy ny nv l nw nx">Mounting <em class="no">/auth:</em></span><span id="c6de" class="nt ma iq ni b gy ny nv l nw nx">=&gt; <strong class="ni ir"><em class="no">POST</em></strong> <em class="no">/auth/login</em> <em class="no">(login)</em></span><span id="ef02" class="nt ma iq ni b gy ny nv l nw nx">Mounting <em class="no">/posts:</em></span><span id="3222" class="nt ma iq ni b gy ny nv l nw nx">=&gt; <strong class="ni ir"><em class="no">POST</em></strong> <em class="no">/posts</em> <em class="no">(create)</em></span><span id="9629" class="nt ma iq ni b gy ny nv l nw nx">=&gt; <strong class="ni ir"><em class="no">GET</em></strong> <em class="no">/posts</em> <em class="no">(read)</em></span><span id="8e6a" class="nt ma iq ni b gy ny nv l nw nx">=&gt; <strong class="ni ir"><em class="no">POST</em></strong> <em class="no">/posts</em> <em class="no">[2]</em> <em class="no">(create_error)</em></span><span id="b0e2" class="nt ma iq ni b gy ny nv l nw nx">Rocket <em class="no">has</em> <em class="no">launched</em> <em class="no">from</em> <a class="ae kv" href="http://0.0.0.0:8000" rel="noopener ugc nofollow" target="_blank"><em class="no">http://0.0.0.0:8000</em></a></span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c4c1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">设置好一切</h1><p id="1e46" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="no">在本教程中，假设你已经下载了Rust并运行了一个</em> <code class="fe nf ng nh ni b">Postgres</code> <em class="no">实例。</em></p><p id="35ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将使用以下命令创建一个新的Rust项目(从现在开始，我们将使用<code class="fe nf ng nh ni b">blog-backend</code>作为我们项目的名称):</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="61e4" class="nt ma iq ni b gy nu nv l nw nx"><strong class="ni ir">cargo</strong> new blog-backend</span></pre><p id="841a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Rocket利用了Rust的高级特性，我们将需要使用Rust的夜间版本。为了在我们的项目中只使用夜间版本，我们导航到我们项目的目录(<code class="fe nf ng nh ni b">blog-backend</code>)并运行以下命令:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="e67f" class="nt ma iq ni b gy nu nv l nw nx"><strong class="ni ir">rustup</strong> override set nightly</span></pre><p id="3465" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="no">注意</em> : Rocket每晚都需要Rust的最新版本，所以如果在构建过程中出现任何问题，只需更新工具链和依赖项即可:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="58b8" class="nt ma iq ni b gy nu nv l nw nx"><strong class="ni ir">rustup</strong> update &amp;&amp; <strong class="ni ir">cargo</strong> update</span></pre><p id="72d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将安装<code class="fe nf ng nh ni b">diesel_cli</code>包，它将帮助我们管理数据库模式。同样，由于我们正在使用<code class="fe nf ng nh ni b">Postgres</code>，我们可以避免下载所有其他默认特性:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="b853" class="nt ma iq ni b gy nu nv l nw nx"><strong class="ni ir">cargo</strong> install diesel_cli --no-default-features --features "postgres"</span></pre><p id="c7ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们通过设置以下环境变量向<code class="fe nf ng nh ni b">Diesel</code>指示连接到我们数据库的URL。在本例中，<code class="fe nf ng nh ni b">blog</code>是我们正在使用的模式的名称:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="1a8e" class="nt ma iq ni b gy nu nv l nw nx"><strong class="ni ir">export</strong> DATABASE_URL=postgres//user:pass@localhost/blog</span></pre><p id="e521" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，Diesel CLI将使用以下命令处理数据库和迁移目录创建:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="64a4" class="nt ma iq ni b gy nu nv l nw nx"><strong class="ni ir">diesel</strong> setup</span></pre><p id="b9f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们回忆一下我们的API定义，我们显然是在使用两种不同的数据类型:用户和帖子，所以我们必须为这两种实体创建表。</p><p id="1399" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建一个表来存储我们的用户。我们通过定义迁移策略来做到这一点:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="39a6" class="nt ma iq ni b gy nu nv l nw nx"><strong class="ni ir">diesel</strong> migration generate users</span></pre><p id="86bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令生成两个文件，<code class="fe nf ng nh ni b">up.sql</code>和<code class="fe nf ng nh ni b">down.sql</code>，放在目录<code class="fe nf ng nh ni b">migrations/date_of_creation_users/</code> <em class="no">中。</em>第一个文件定义如何应用迁移，第二个文件定义如何恢复迁移。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于用户迁移的up.sql</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于用户迁移的down.sql</p></figure><p id="0f7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应用迁移:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="b741" class="nt ma iq ni b gy nu nv l nw nx"><strong class="ni ir">diesel</strong> migration run</span></pre><p id="5e82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将用下面的定义文件对posts表重复这个过程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">posts迁移的up.sql</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">posts迁移的down.sql</p></figure><p id="2069" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们在<code class="fe nf ng nh ni b"><em class="no">Cargo.toml</em></code>文件中添加我们需要的所有依赖项:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="2449" class="lz ma iq bd mb mc ob me mf mg oc mi mj jw od jx ml jz oe ka mn kc of kd mp mq bi translated">进入代码</h1><p id="2e2c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您可能已经注意到，在设置过程中的某个时候已经生成了一个名为<code class="fe nf ng nh ni b">schema.rs</code> <em class="no"> </em>的文件。该文件由Diesel自动生成，并在我们运行迁移时进行更新。它包含代表数据库模式中所有表和列的<code class="fe nf ng nh ni b">table!</code>宏。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">schema.rs</p></figure><p id="324a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了建立数据库连接，我们将使用以下文件创建一个数据库连接池，以便在将来的请求中重用数据库连接:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据库连接池</p></figure><p id="24d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们添加一个主函数，启动rocket服务器，初始化数据库连接池，并挂载users和posts模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">main.rs</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e304" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">用户</h1><p id="0554" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们进入用户模块。在本模块中，我们不仅包括与用户相关的所有内容，还包括与身份认证相关的内容。</p><p id="4e1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们看一下我们的<code class="fe nf ng nh ni b">model.rs</code> <em class="no"> </em>文件<em class="no">、</em>，其中我们<strong class="ky ir"> </strong>定义了用户结构并实现了与数据库交互的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用户模块的模型</p></figure><p id="2fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们有两种不同的用户结构。这两种结构的命名解释了其中的原因:由于用户ID是由数据库创建的，所以我们用于插入的用户结构将与常规的用户结构相同，但是删除了ID字段。</p><p id="9f2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe nf ng nh ni b">bcrypt</code> <em class="no"> </em>机箱来加密用户的密码。当插入一个新用户时，我们通过散列先前的值来更新用户结构的密码字段。另一方面，当试图通过用户名和密码检索用户时，我们必须使用前面提到的验证函数来验证两个密码是否匹配。</p><h2 id="66c2" class="nt ma iq bd mb og oh dn mf oi oj dp mj lf ok ol ml lj om on mn ln oo op mp oq bi translated">证明</h2><p id="348c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们使用基于JWT的认证。我在<a class="ae kv" href="https://github.com/marcocastignoli/rust_rocket_api_authentication" rel="noopener ugc nofollow" target="_blank">下面的库</a>中发现了一个Rocket实现，所以我们可以看到这就是我们正在使用的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">证明</p></figure><p id="f7d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个文件中，我们实际上是在检查每个需要对用户进行身份验证的请求。如果请求包含一个带有有效令牌的报头，则请求被接受，但是如果令牌丢失或无效，则请求被转发。</p><p id="e5a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们为用户和认证路由定义处理函数。唯一不直接的处理程序是登录处理程序，在这里我们检查凭证是否正确，然后为用户生成一个有效的令牌。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a707" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">邮件</h1><p id="221a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">文章模型将类似于用户模型。因为文章也有一个数据库生成的ID，所以我们也采用两个结构的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">岗位模型</p></figure><p id="7413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们还将为POST方法定义两条路由—一条用于处理包含有效令牌的请求，另一条用于发送未经授权的错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">帖子修改</p></figure><p id="f8b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经拥有了所需的一切，我们只需运行以下命令，一切都将启动并运行:</p><pre class="kg kh ki kj gt np ni nq nr aw ns bi"><span id="e10f" class="nt ma iq ni b gy nu nv l nw nx"><strong class="ni ir">cargo</strong> run</span></pre><p id="a292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在<a class="ae kv" href="https://github.com/UxioAndrade/blog-backend" rel="noopener ugc nofollow" target="_blank">库</a>中找到本教程中描述的所有文件。</p></div></div>    
</body>
</html>