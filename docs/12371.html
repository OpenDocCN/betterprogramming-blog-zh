<html>
<head>
<title>A Quick and Practical Example of Hexagonal Architecture in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个快速实用的Java六边形架构的例子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-quick-and-practical-example-of-hexagonal-architecture-in-java-8d57c419250d?source=collection_archive---------0-----------------------#2022-06-01">https://betterprogramming.pub/a-quick-and-practical-example-of-hexagonal-architecture-in-java-8d57c419250d?source=collection_archive---------0-----------------------#2022-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c55f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实践中的软件设计模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f2d76b1ddc3e90ba9c184eba51fc16c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U8KZ3vht9EGoGoy2"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Clark Van Der Beken 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="fab4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.概观</h1><p id="3154" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">六角形架构是由<a class="ae kv" href="https://web.archive.org/web/20170730135337/http://alistair.cockburn.us/Hexagonal+architecture" rel="noopener ugc nofollow" target="_blank">阿利斯泰尔·考克伯恩</a>首先提出的一种软件设计模式。它提供了一种使用Java或Java相关框架(如Spring)设计web应用程序架构的自以为是的方法。在本文中，我们将研究Java中的六边形架构，并借助一个使用Spring框架实现的实际例子来展示它的用法。</p><h1 id="92a4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.六角形建筑</h1><p id="9008" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">六边形架构背后的主要思想是通过接口隔离原则实现清晰的逻辑隔离。此外，六角形架构通过<em class="mk">端口和适配器</em>的概念创建了松散耦合的应用程序。这里端口指的是接口，适配器指的是它的实现类(如下图所示)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/e488069286a6a8a411a9294829c7a9b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*9LELTYyRhtTU4oCvpZxL2Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">六角形建筑</p></figure><p id="c705" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">上图显示了典型六边形架构中的各种端点。通过应用层，用户通过端口和适配器与核心应用程序逻辑进行交互。应用层由GUI客户端、社交媒体客户端、HTTP/API调用等组成。类似地，应用程序的另一半显示了一个持久层或基础设施层，数据通过它流向其他组件。持久层包含外部组件，如数据库、邮件和消息队列等。</p><h1 id="d793" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.例子</h1><p id="5092" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了更好地理解六边形架构，让我们考虑一个比萨饼服务应用程序的例子。在该应用中，我们将具有以下特性:</p><ul class=""><li id="b77e" class="mr ms iq lq b lr mm lu mn lx mt mb mu mf mv mj mw mx my mz bi translated">列出所有可以买到的比萨饼</li><li id="b9b0" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">在数据库中插入新的比萨饼</li><li id="ff4c" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">按名字买披萨</li></ul><h1 id="9fe5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">4.域对象</h1><p id="8ae9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">域或实体对象是六边形架构的核心部分。它可以有状态和行为。该对象不依赖于任何应用程序组件。如果业务需求本身发生了变化，域对象中的任何变化都会发生。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="cc4c" class="nk kx iq ng b gy nl nm l nn no">public class Pizza {<br/>	private String name;<br/>	private int price;<br/>	private String[] toppings;<br/>	// code for getters &amp; setters<br/>}</span></pre><h1 id="bf1a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">5.港口</h1><p id="29f8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">六边形结构中的端口是指允许入站或出站流量的接口。入站端口向外界公开核心应用程序功能。例如，对服务接口的API调用。</p><p id="d999" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">让我们定义一个<em class="mk"> PizzaService </em>接口，它将向外部组件公开其功能(比如API调用)。这是我们的进港港口。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="48ec" class="nk kx iq ng b gy nl nm l nn no">public interface PizzaService {<br/>       public void createPizza(Pizza pizza);<br/>       public Pizza getPizza(String name);<br/>       public List&lt;Pizza&gt; laodPizza();<br/>}</span></pre><p id="01d5" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">类似地，出站端口用于连接一些外部存储库，如数据库。</p><p id="1d59" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">让我们定义一个将访问外部持久系统(DB)的<em class="mk"> PizzaRepository </em>。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="3e2f" class="nk kx iq ng b gy nl nm l nn no">public interface PizzaRepo {<br/>       public void createPizza(Pizza pizza);<br/>       public Pizza getPizza(String name);<br/>       public List&lt;Pizza&gt; getAllPizza();<br/>}</span></pre><h1 id="528b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">6.适配器</h1><p id="c06a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">适配器指的是六边形架构中它们各自端口的实现类。它们是应用程序的外部部分(如GUI、API调用、Webviews、Dao等)。)并分别通过入站和出站端口与应用程序交互。此外，适配器使得更换应用程序的特定层变得简单。根据所需的更改，我们只需要添加一个实现输入或输出端口的适配器。</p><h1 id="0882" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">6.1主适配器</h1><p id="4bef" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它们也被称为输入或驱动适配器，因为它们通过使用入站端口调用应用程序的核心部分来驱动应用程序。</p><p id="8a42" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">让我们将<em class="mk">pizzarestcontroller</em>定义为REST控制器，作为我们的主适配器。它提供了创建和获取披萨的端点，还实现了<em class="mk"> PizzaRestUI </em> (Webview)。除此之外，它使用<em class="mk"> PizzaService </em>(入站端口)来调用不同的方法。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="66e1" class="nk kx iq ng b gy nl nm l nn no">@RestController<br/>@RequestMapping(value="/pizza")<br/>public class PizzaRestController implements PizzaRestUI {<br/>       @Autowired<br/>       private PizzaService pizzaService;<br/>       @Override<br/>       public void createPizza(@RequestBody Pizza pizza) {<br/>             pizzaService.createPizza(pizza);<br/>       }<br/>       @Override<br/>       public Pizza getPizza(@PathVariable String name) {<br/>             return pizzaService.getPizza(name);<br/>       }<br/>       @Override<br/>       public List&lt;Pizza&gt; listPizza() {<br/>             return pizzaService.laodPizza();<br/>       }<br/>}</span></pre><h1 id="18f1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">6.2二级适配器</h1><p id="7e64" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它们被称为输出或驱动适配器，实现出站端口接口。这些适配器提供了访问应用程序的辅助组件(如数据库、消息队列等)的实现。服务层实现输入端口，而输出端口是使用持久层实现的。</p><p id="d129" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在我们的例子中，<em class="mk"> PizzaRepoImpl </em>是实现<em class="mk"> PizzaRepo </em>(出站端口)的出站适配器。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="96a0" class="nk kx iq ng b gy nl nm l nn no">@Repository<br/>public class PizzaRepoImpl implements PizzaRepo {<br/>       private Map&lt;String, Pizza&gt; pizzaStore = new HashMap&lt;String, Pizza&gt;();<br/>       @Override<br/>       public void createPizza(Pizza pizza) { <br/>             pizzaStore.put(pizza.getName(), pizza);<br/>       }<br/>       @Override<br/>       public Pizza getPizza(String name) {<br/>             return pizzaStore.get(name);<br/>       }<br/>       @Override<br/>       public List&lt;Pizza&gt; getAllPizza() {<br/>             return pizzaStore.values().stream().collect(Collectors.toList());<br/>       }<br/>}</span></pre><p id="03a8" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">接下来，我们可以使用任何API测试工具(如Postman)来测试GET &amp; POST端点。</p><p id="8076" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们可以通过<em class="mk">http://localhost:8080/pizza-service/pizza/</em>测试POST端点</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="2af6" class="nk kx iq ng b gy nl nm l nn no">{<br/>    "name" : "Margherita",<br/>    "price": "25",<br/>    "toppings" : ["tomato","onion","cucumber","jalapeno"]<br/>}</span></pre><p id="91fb" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">同样，我们可以通过http://localhost:8080/pizza-service/pizza/Margherita测试GET端点</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="0747" class="nk kx iq ng b gy nl nm l nn no">{<br/>    "name": "Margherita",<br/>    "price": 25,<br/>    "toppings": [<br/>        "tomato",<br/>        "onion",<br/>        "cucumber",<br/>        "jalapeno"<br/>    ]<br/>}</span></pre><h1 id="ea9a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">7.利益</h1><p id="eb22" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">与传统的分层结构相比，六边形结构有几个优点，例如:</p><ul class=""><li id="9c7e" class="mr ms iq lq b lr mm lu mn lx mt mb mu mf mv mj mw mx my mz bi translated">它通过分离应用程序的内部和外部组件简化了架构设计</li><li id="3e7f" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">核心业务逻辑与任何外部依赖相分离，导致了高度的解耦</li><li id="85e4" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">基于端口的架构允许我们的应用适应新的通道或轻松使用新的通信协议，这对开发<a class="ae kv" href="https://www.baeldung.com/hexagonal-architecture-ddd-spring" rel="noopener ugc nofollow" target="_blank">域驱动的应用</a>非常有用</li></ul><h1 id="ad40" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">8.结论</h1><p id="ef4a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们通过一个在Spring框架中实现的简单例子了解了Java中的六角形架构。此外，我们已经讨论了使用六边形架构相对于传统分层架构的一些优势。</p><p id="6e4a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">Github 上的<a class="ae kv" href="https://github.com/SumitKumar30/baeldung-tutorials/tree/master/java-hexagon/pizza-service" rel="noopener ugc nofollow" target="_blank">提供了给定示例的代码。</a></p></div></div>    
</body>
</html>