<html>
<head>
<title>How To Do the Basics in React Testing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何做好React测试库中的基础工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-do-the-basics-in-react-testing-library-c52cdb3a7726?source=collection_archive---------1-----------------------#2019-06-04">https://betterprogramming.pub/how-to-do-the-basics-in-react-testing-library-c52cdb3a7726?source=collection_archive---------1-----------------------#2019-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9cff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">向非React专家介绍React测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee0ca4044b32c6f073f6423d8f8cd80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bdUSV4xgmIvJrSoj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sapegin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Artem Sapegin </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="3758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个月前，我受雇成为一个网站的测试员。问题？我对React没有什么经验，要遵循React的测试文档，从<a class="ae ky" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酶</a>和React测试库是相当复杂的。所以在我理解了这一切之后，我决定制作这个教程。</p><p id="ceab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件要说的重要事情是，我试图用酶来做测试，但这不足以轻易做到这一点。它并不比React测试库更容易阅读，这也是我最终选择它的原因。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="10bd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基本语法介绍</h1><p id="b8ed" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了使<a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>错误报告易于阅读，我们在<code class="fe mz na nb nc b">nameOfComponent.test.js</code>中有三个层次的描述——引用组件、<code class="fe mz na nb nc b">describe</code>(通过一些上下文标记一组测试)和<code class="fe mz na nb nc b">it</code>(描述那个特定的测试和断言组(用<code class="fe mz na nb nc b">expect</code>做的)引用什么)。</p><p id="6d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有了<code class="fe mz na nb nc b">render</code> <strong class="lb iu"> </strong>函数，这是一个将组件放入Jest DOM并放入<code class="fe mz na nb nc b">renderResult</code>的方法。这是我们要用来做断言的。<code class="fe mz na nb nc b">render</code>参数是一个带有各自属性的React元素。在第一个代码示例中，我已经使用WAI-ARIA设计模式输入了有效下拉菜单所必需的最小道具。</p><p id="3625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们对<code class="fe mz na nb nc b">expects</code> <strong class="lb iu"> </strong>进行了两点考虑:</p><ul class=""><li id="6e80" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">指向DOM中元素的指针；HTML元素。</li><li id="1571" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">“toBe”断言。</li></ul><p id="f61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8f7f9b39cd547a59d231b585c5a0ae8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/0*--1Td2fO_iQYyZE9"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用“<code class="fe mz na nb nc b">describe”</code>和“it”的报告示例</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="560e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是“renderResult”？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ca03b60300e9585d5d347939b7170f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/0*zHhs6ThDQBtrI6LE"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">console.log(渲染结果)</p></figure><p id="e010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TK *(thing you want be sure)这是技术对话还是垃圾？*知道您作为参数传递的内容的最佳方式是转到<code class="fe mz na nb nc b">console.log</code>(“thingyouwantobe sure”)，并检查<a class="ae ky" href="https://vscode.readthedocs.io/en/latest/editor/integrated-terminal/" rel="noopener ugc nofollow" target="_blank"> VSCode终端</a>的输出部分，因为终端部分可能会省略一些重要的内容。</p><p id="e4c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">console.log(renderResult)</code>是一个有几个方法的对象。其中一个是返回<code class="fe mz na nb nc b">DIV</code>和<code class="fe mz na nb nc b">HTMLBodyElement</code>的容器，里面有我们的<code class="fe mz na nb nc b">DropDown</code>组件。</p><p id="1804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">renderResult</code>提供了更容易在DOM中搜索元素的方法。这就是为什么我们需要“获取方法”，也就是查询，在<a class="ae ky" href="https://testing-library.com/docs/dom-testing-library/api-queries" rel="noopener ugc nofollow" target="_blank"> React测试库API </a>中描述。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6783" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">查询API</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/c954b0b0af810084e62491dd3d28d3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*_JpxcnfYwjcDwyTa"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">console . log(render result . get bytext(" lab1))</p></figure><p id="166a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为标签的子标签是这个组件中的一个标签元素，所以字符串<code class="fe mz na nb nc b">rotulo</code>在文档中。我们可以在<code class="fe mz na nb nc b">container.innerHTML console.log</code>中看到。</p><p id="c752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以<code class="fe mz na nb nc b">expect(renderResult.getByText(“lab1)).toBeInTheDocument()</code>将返回true。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/26bb98ec0526d442c257ff0cfb05cf86.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/0*qPVLbYl70p4IC0cS"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标签元素的待定属性</p></figure><p id="9023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">getByText</code>查询用于在HTML文档中可视化显示的唯一字符串中进行断言。这里还有一些例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/73c9c95e7173c94fcadf59c28fa3f042.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/0*6zQs2txkoa4QlYA1"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台. log(renderResult.container)</p></figure><p id="3cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">renderResult.container </code>返回一个指向DOM元素的指针，我们可以访问DOM API来搜索其他相关节点，就像这些查询:</p><p id="10a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">.getElementsByTagName(“span”)[0][“textContent”]</code></p><p id="85bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第一个span标记中获取“儿童”文本。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="efcd" class="oc md it nc b gy od oe l of og">.getElementsByTagName(“div”)[0][“id”]</span></pre><p id="3e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从第一个<code class="fe mz na nb nc b">div</code>开始的<code class="fe mz na nb nc b">id</code>。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="4af9" class="oc md it nc b gy od oe l of og">.getElementsByTagName(“button”)[0].getAttribute(“aria-label”)</span></pre><p id="0491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从第一个<code class="fe mz na nb nc b">button</code>开始的<code class="fe mz na nb nc b">aria-label</code>内容。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="83bd" class="oc md it nc b gy od oe l of og">.getElementsByClassName(“Extra”)[0]</span></pre><p id="7d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个<code class="fe mz na nb nc b">Element</code>是一个名为<code class="fe mz na nb nc b">Extra</code>的类。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="674d" class="oc md it nc b gy od oe l of og">.getElementsByTagName(“div”)[1][“classList”].contains(“checkable”)</span></pre><p id="d940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它在第二个<code class="fe mz na nb nc b">div</code>中，那么它就是包含“可检查”类的<code class="fe mz na nb nc b">ClassList</code>。</p><p id="12cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅使用这些例子，我就可以做出12个WAI-ARIA模式组件所需的所有断言——复选框、日期输入、下拉菜单、单选按钮、按钮组、表格、选项卡、多选列表等。但是，这并不适用于各种道具。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d4a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">历史、路由器和表单</h1><p id="89e4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是一个链接和搜索查询测试链接的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，我们都需要使用click事件，将这个新状态推送到我们的<code class="fe mz na nb nc b">memoryHistory</code>中，并将查询放入<code class="fe mz na nb nc b">location.search</code>中。为了让点击发生，我们使用<code class="fe mz na nb nc b">getByText(“Home”)</code>来引用span元素。</p><p id="893e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住点击事件传播到链接元素(它的父元素)是很重要的。这就是为什么点击会触发链接和查询方法，但相同上下文中的焦点不会。现在，让我们来看看“历史”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/9725cc1894a579a65f2c9d7995fd24b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/0*xfx3T0G53PS-Jbjd"/></div></figure><p id="2606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们推断链接组件的验证是:</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="704a" class="oc md it nc b gy od oe l of og">fireEvent.click(RenderResult.getByText(“Home”));<br/>expect(history.location.pathname).toBe(“/example”);</span></pre><p id="13d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并测试搜索参数的变化:</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="c982" class="oc md it nc b gy od oe l of og">fireEvent.click(RenderResult.getByText(“Home”)); expect(history.location.search).toBe(“?author=Raissa”);<br/>expect(history.location.pathname).toBe(“/”);</span></pre><p id="9fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道也不使用React路由器，建议你开始使用。</p><div class="oi oj gp gr ok ol"><a href="https://www.freecodecamp.org/news/beginner-s-guide-to-react-router-53094349669/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">React路由器初学者指南</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">由纳德达比特初学者指南反应路由器或我希望我知道当开始与反应路由器。&gt;点击此处…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.freecodecamp.org</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><p id="abc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TK *链接到葡萄牙文有帮助吗？*我推荐的另一件事是使用Formik创建表单。这里有一篇关于福米克的文章(葡萄牙语)。</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/reactbrasil/formik-construa-formul%C3%A1rios-em-react-sem-l%C3%A1grimas-a80c52887882" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">formik part 1——constru formuláRios em React，sem lágrimas</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">最近，一项研究表明，这两种形式的反应是复杂的，决定于…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz ks ol"/></div></div></a></div><p id="4340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Formik在测试中也有自己的要求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="828f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是两个简单的验证，确保渲染不会崩溃。然而，您可以验证<code class="fe mz na nb nc b">Form</code>标签的其他属性值，就像我们之前做的例子一样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7f74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">射击事件和故事书的使用</h1><p id="3a7f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">点火事件需要考虑两个因素。您必须使用哪个HTML元素来引发事件，以及事件是否有一些类似于<code class="fe mz na nb nc b">input</code>的参数。</p><p id="1408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe mz na nb nc b">onClick</code>、<code class="fe mz na nb nc b">onBlur</code>、<code class="fe mz na nb nc b">onKeyDown</code>等功能道具应该是有据可查的，这样我们就知道它们的监听器是哪个HTML元素了。测试人员能够独立于组件的实现编写测试代码，因为有些事件，比如焦点，不会传播到父组件。</p><p id="05f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了容易识别HTML元素，它基本上和以前一样——使用<code class="fe mz na nb nc b">console.log</code> —来生成期望。要查找哪些事件使用并调用函数prop，一个想法是使用<a class="ae ky" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank"> Storybook </a>来记录孤立的组件、其外观及其行为。这将使测试变得非常真实。</p><h2 id="411b" class="oc md it bd me pb pc dn mi pd pe dp mm li pf pg mo lm ph pi mq lq pj pk ms pl bi translated">密码</h2><div class="oi oj gp gr ok ol"><a href="https://github.com/storybooks/storybook" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">故事书</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">UI组件开发和测试:React，Vue，Angular，React Native，Ember，Web组件等等！故事书/故事书</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="pm l ow ox oy ou oz ks ol"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e99a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">点火事件示例</strong></h1><p id="df6e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">记住这取决于你的组件总是好的！所以这里我们将关注事件，而不是组件。</p><p id="4eb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需点击span文本，在一个按钮。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="29c9" class="oc md it nc b gy od oe l of og">const onClick = jest.fn();<br/>fireEvent.click(RenderResult.getByText(“label”));<br/>expect(onClick).toHaveBeenCalled();</span></pre><p id="08c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">悬停显示内容，就像在工具提示中一样。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="870d" class="oc md it nc b gy od oe l of og">fireEvent.focus(RenderResult.getByLabelText(“Label”));<br/>expect(RenderResult.getByText(“TooltipContent”)).toBeInTheDocument()</span></pre><p id="81a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击未选中的选项和多选列表中的一个选中选项。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="428b" class="oc md it nc b gy od oe l of og">fireEvent.click(RenderResult.getByText(“option 1”));<br/>expect(SelectionFunc).toHaveBeenCalled();<br/>fireEvent.click(RenderResult.getByText(“option 2”));<br/>expect(UnselectionFunc).toHaveBeenCalled();</span></pre><p id="d4fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击选择选项，然后单击提交它。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="7b4c" class="oc md it nc b gy od oe l of og">fireEvent.click(RenderResult.getByText(“option 1”));<br/>fireEvent.click(<br/>  RenderResult.container.getElementsByTagName(“button”)[0]<br/>);<br/>expect(onChange).toHaveBeenCalled();</span></pre><p id="f69d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">DateInput</code>上插入一个日期来调用它的<code class="fe mz na nb nc b">onChange</code>模拟函数。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="011e" class="oc md it nc b gy od oe l of og">fireEvent.change(RenderResult.getByLabelText(“label”), {<br/>  target: { value: “2019–06–25” }<br/>});<br/>expect(onChange).toBeCalled();</span></pre><p id="d3fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Event</code>类型列表:</p><div class="oi oj gp gr ok ol"><a href="https://github.com/testing-library/dom-testing-library/blob/master/src/events.js" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">测试库/DOM-测试库</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">🐙简单完整的DOM测试工具，鼓励良好的测试实践。…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="pn l ow ox oy ou oz ks ol"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="83db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">成为的</h1><p id="a4e4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我只用过下面这些，但还有很多其他的。</p><ul class=""><li id="93c5" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><code class="fe mz na nb nc b">toBeInTheDocument()</code> —用于断言DOM中的文本。段落、按钮标签、工具提示、跨度文本、空内容警告等…</li><li id="4da2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe mz na nb nc b">toBe(“someString”)</code> —确定我在<code class="fe mz na nb nc b">getMethods</code>中引用的HTML元素中是否存在字符串。如果expect中的某个东西是' === '，那么<code class="fe mz na nb nc b">toBe</code>中的另一个东西将为真。</li><li id="5e0c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe mz na nb nc b">toBeDefined()</code>——确定某事是否是”！== "未定义。最常用的情况是当一个类存在于元素类列表中时，这个类只因为我传递了一个布尔属性而存在，比如:<code class="fe mz na nb nc b">dark</code>、<code class="fe mz na nb nc b">noStyle</code>、<code class="fe mz na nb nc b">big</code>、<code class="fe mz na nb nc b">small</code>。</li><li id="d5c3" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe mz na nb nc b">toBeCalled()</code> —用于测试触发事件后的函数调用。</li><li id="2dff" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe mz na nb nc b">ToHaveBeenCalled()</code>、<code class="fe mz na nb nc b">ToHaveBeenCalledTimes()</code>、<code class="fe mz na nb nc b">ToHaveBeenCalledWith()</code>都是重要的变体。</li><li id="74ce" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe mz na nb nc b">toMatchSnapshot()</code> —在一些更复杂的组件中，我更喜欢使用快照测试进行初始化，这是针对这种情况的断言。例如:</li></ul><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="99b7" class="oc md it nc b gy od oe l of og">it(“Match Snapshot Button”, () =&gt; {<br/>  const RenderResult = render(&lt;Button&gt;Hello&lt;/Button&gt;);<br/>  expect(RenderResult.getByText(“Hello”)).toBeInTheDocument();<br/>  expect(RenderResult).<strong class="nc iu">toMatchSnapshot</strong>();<br/>});</span></pre><p id="3fa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<a class="ae ky" href="https://jestjs.io/docs/en/snapshot-testing" rel="noopener ugc nofollow" target="_blank">快照测试</a>的更多信息。</p><p id="b378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有更多<a class="ae ky" href="https://jestjs.io/docs/en/expect.html" rel="noopener ugc nofollow" target="_blank"> Jest期待</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b16e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">依赖性和测试设置</h1><p id="7333" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我已经对这个导入做了所有的测试，而且我们之前已经讨论过了:</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="26db" class="oc md it nc b gy od oe l of og">import React from “react”;<br/>import Component, { ComponentGroup } from “.”;<br/>import { render, fireEvent } from “react-testing-library”;<br/>import { Router } from “react-router-dom”;<br/>import { createMemoryHistory } from “history”;<br/>import { Form, Formik } from “formik”;</span></pre><p id="314a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在src/setupTests.js配置文件中，重要的是:</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="b1d9" class="oc md it nc b gy od oe l of og"><br/>import “react-testing-library/cleanup-after-each”;</span></pre><p id="4959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保证每个测试不会干扰下一个测试(等幂)，因为使用render挂载的React树将被卸载:</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="980b" class="oc md it nc b gy od oe l of og">import “jest-dom/extend-expect”;</span></pre><p id="a54b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于某些特定的断言是必要的:</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="7f70" class="oc md it nc b gy od oe l of og">import “mutationobserver-shim”;</span></pre><p id="544f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些测试需要一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank">变异观测器</a>。模态是我们组件中的一个例子。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="d784" class="oc md it nc b gy od oe l of og">Element.prototype.scrollIntoView = () =&gt; {};</span></pre><p id="8a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在多选列表中，需要在DOM中添加一个<code class="fe mz na nb nc b">scrollIntoView</code>模拟函数，默认情况下不存在。</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="23d3" class="oc md it nc b gy od oe l of og">const originalConsoleError = console.error;<br/>  console.error = message =&gt; {<br/>  if (/(Failed prop type)/.test(message)) {<br/>    throw new Error(message);<br/>  }<br/>  originalConsoleError(message);<br/>};</span></pre><p id="ab15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得prop类型警告显示为测试失败。</p><p id="b359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">/package.json</code>中的<code class="fe mz na nb nc b">devDependencies</code>:</p><pre class="kj kk kl km gt ny nc nz oa aw ob bi"><span id="b947" class="oc md it nc b gy od oe l of og">“jest-dom”: “3.2.2”,<br/>“jsdoc”: “3.5.5”,<br/>“mutationobserver-shim”: “0.3.3”,<br/>“react-testing-library”: “7.0.0”</span></pre></div></div>    
</body>
</html>