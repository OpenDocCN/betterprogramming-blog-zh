# 数据库表被锁了怎么办？

> 原文：<https://betterprogramming.pub/what-should-i-do-if-the-database-table-is-locked-fb8139079e8>

## 解决此使用案例的故障排除和解决流程

![](img/5fabec65a89bdc229f78dc4397719eb3.png)

多梅尼科·洛亚在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

在程序员的职业生涯中，总会出现数据库表被锁的情况，前几天又碰到了。

由于业务需求突然，各部门都在批量操作导出数据，数据库还没有做到读写分离。结果是数据库中的一个表被锁定！

用户反映系统部分功能无法使用。执行紧急调查以定位数据库表被锁定，然后执行紧急处理。

本文将与您分享类似紧急情况的故障排除和解决过程。

# **故障描述**

用户在一个正常运行的页面上报告了一个 502 错误，于是他立即检查服务是否正常，数据库是否正常。

在控制台上，我看到数据库 CPU 猛增，积累了大量未提交的事务。有些交易已经被封锁了很长时间。基本定位是数据库层有问题。

# **解决方案**

看阻塞交易列表，发现有锁表现象。本想用控制台直接结束被阻塞的事务，但控制台账号权限有限，于是通过客户端登录相应账号杀死锁表事务，避免了情况恶化。

想象一个场景，这当然是软件工程师职业生涯中都会遇到的场景:一个本来正常运行的程序，突然有一天数据库的表被锁了，业务无法正常运行，那么如何快速定位表后是哪个事务锁，如何结束相应的事情？

第一个也是最简单的方法是重启 MySQL。没错，网管解决问题的神器——就是“**重启**”。至于后果，能不能跑，要三思而后行！

重启可以解决锁表问题，但对于线上商家显然不可行。

让我们看看不停止服务的解决方案:

## **第一步:检查表格使用情况**

当遇到数据库阻塞的问题时，必须首先检查表是否在使用中。

```
show open tables where in_use > 0 ;
```

如果查询结果为空，那么该表没有被使用，说明不是锁表的问题。

```
mysql>  show open tables where in_use > 0 ;
Empty set (0.00 sec)
```

例如，如果查询结果不为空，将出现以下结果:

```
mysql>  show open tables where in_use > 0 ;
+----------+-------+--------+-------------+
| Database | Table | In_use | Name_locked |
+----------+-------+--------+-------------+
| test     | t     |      1 |           0 |
+----------+-------+--------+-------------+
1 row in set (0.00 sec)
```

意味着该表(测试)正在被使用，此时需要进一步调查。

## **第二步:检查流程**

查看数据库的当前进程，看看是否有任何缓慢的 SQL 或阻塞的线程。

执行 SQL:

```
show processlist;
```

这个命令只显示当前用户运行的线程，当然，前提是根用户能够看到所有线程。

## **第三步:检查所有当前正在运行的事务**

```
SELECT * FROM information_schema.INNODB_TRX;
```

## **步骤 4:检查出现的当前锁**

```
SELECT * FROM information_schema.INNODB_LOCKs;
```

## **第五步:查询锁等待的对应关系**

```
SELECT * FROM information_schema.INNODB_LOCK_waits;
```

看事务表`INNODB_TRX`中是否有被锁定的事务线程，看 ID 是否在`show processlist`的睡眠线程中。如果是，说明这个睡眠的线程事务还没有提交或者回滚，而是被卡住了，需要手动杀死。

在搜索结果中，如果在事务表中发现了很多任务，最好把它们都干掉。

## **第六步:终止交易**

```
kill some_pid;
```

在相应的线程执行了 kill 命令后，后续事务可以正常处理。

对于紧急情况，通常直接操作第一、二、六步。

数据库锁设计的初衷是为了处理并发问题。作为多个用户共享的资源，当并发访问发生时，数据库需要合理控制资源的访问规则，而锁是用来实现这些访问规则的重要数据结构。

根据锁定的范围，MySQL 中的锁大致可以分为三类:全局锁、表级锁和行锁。MySQL 中有两种类型的表级锁:一种是表锁，另一种是元数据锁(MDL)。

表锁是在服务器层实现的。像`alter table`这样的语句使用了表锁，而忽略了存储引擎的锁机制。表锁由`lock tables … read/write`实现，对于 InnoDB，一般使用行级锁。毕竟，锁定整个表对范围的影响太大了。

另一个表级锁是 MDL(元数据锁)，用于在并发条件下维护数据一致性，保证读写的正确性。它不需要显式使用，而是在访问表时自动添加。

一个常见的锁表场景是当事务操作处于**状态等待表元数据锁**时。

MySQL 在执行`alter table`等 DDL 操作时，有时会出现等待表元数据锁的等待场景。

一旦`alter table table_name`的操作被卡在等待表元数据锁定状态，对该表的任何后续操作(包括读取)都无法进行，因为在打开表阶段，它们也会进入等待表元数据锁定等待队列。

如果核心表有一个锁定的等待队列，将会产生灾难性的后果。

*   场景 1:一个长事务运行，阻塞 DDL，然后阻塞同一个表上的所有后续操作。通过`show processlist`可以看到桌子上有正在进行的操作(包括读取)。此时，`alter table`语句无法获得元数据排他锁，将等待。
*   场景 2:为了提交事务，阻塞 DDL，然后阻塞同一个表上的所有后续操作。通过`show processlist`看不到表上的任何操作，但实际上有未提交的事务，可以在`information_schema.innodb_trx`中查看。在事务完成之前，表上的锁不会被释放，并且 alter table 也不能获得元数据的排他锁。

处理方法:通过`select * from information_schema.innodb_trx\G;`找到未提交事物的 sid，然后将其杀死，让其回滚。

*   场景 3:显式事务失败操作获取锁，但不释放它

在`show processlist`之前，我看不到表上的任何操作，也看不到`information_schema.innodb_trx`中正在进行的任何事务。很可能在一个显式事务中，对表执行了一个失败的操作(比如查询一个不存在的字段)，此时事务没有启动，但是失败语句获取的锁仍然有效，没有释放。失败的语句可以在`performance_schema.events_statements_current`表中找到。

处理方法:通过`performance_schema.events_statements_current`找到它的 sid，杀死会话，或者杀死 DDL 所在的会话。

总之`alter table`的说法很危险(核心是未提交事务或者长事务导致的)。在操作之前，确保要操作的表上没有正在进行的操作、没有未提交的事务和没有显式的事务。中的错误语句。

如果有一个`alter table`维护任务在无人监管的情况下运行，最好通过`lock_wait_timeout`设置超时时间，避免长时间的元数据锁等待。

我们在练习的过程中尽量避免锁表的情况，当然这需要一定经验的支持。

但更重要的是，如果发现锁表，一定要能够快速反应，快速解决问题，避免影响正常业务，避免事态进一步恶化。

感谢您阅读这篇文章。如果你在这篇文章中发现任何错误，请告诉我。