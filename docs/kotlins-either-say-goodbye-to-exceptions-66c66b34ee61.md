# 科特林的要么:告别例外

> 原文：<https://betterprogramming.pub/kotlins-either-say-goodbye-to-exceptions-66c66b34ee61>

## 这里有一个消除 try-catch 块的库

![](img/a7582b88e11b24f938e5477f680c1fb8.png)

在本文中，我们将讨论任何 JVM 语言中异常处理最常见的问题之一，以及在错误处理方面，我们可以使用什么替代方法来实现更清晰、更干净和更易维护的代码。

# 介绍

在最近几十年里，我们看到了编程领域的繁荣，在我们的代码中冒泡异常，然后在代码中的某个隐藏点进行异常处理，这已经成为一种普遍的习惯，在大多数情况下，对于任何不了解代码的开发人员来说，这是一个很难找到的地方。例如，Spring 的异常处理程序就是这种情况。

除非您知道那个特定的类，否则您不会通过遵循代码的正常流程找到逻辑应用的位置。跟踪异常和跟踪代码变得更加困难。

这是问题之一，但当我们遇到错误边缘的情况时，它也会变得混乱，很难维护和调试问题。

那么实际问题是什么，为什么我们需要做些什么？

# 为什么目前的情况不理想？

当我们执行一个操作时，比如一个 HTTP 调用，如果一切顺利，我们可以进行一个完全干净的调用，并取回我们的对象，但是如果调用失败了会发生什么呢？我们有几个选项，让我们看看它们的样子和它们的含义:

## 引发异常

我们可以做的事情之一是检查响应，如果不成功就抛出异常。例如:

在这个例子中，如果调用成功，我们将返回我们的`Employee`对象，如果调用失败，我们将抛出一个异常。这种处理错误的方式既难看又混乱，因为没有办法确切地知道谁和在哪里会捕捉到那个异常并对此做些什么。在许多项目中，异常是冒泡出现的，直到一个“神奇的”组件以一种不熟悉代码的开发人员很难猜到的方式透明地处理异常。

仅仅依赖异常并从代码的每个地方冒泡的主要问题之一是，理解异常来自哪里变得非常困难。这也是一种次优的交流方式，即在我们的代码部分发生了错误。

所以我们对这个选项不是特别满意，让我们看看还有什么其他选项。

## 返回响应对象

我们的另一个选择是返回我们使用的 HTTP 库提供的响应对象。例如:

这种方法给我们带来的好处是，允许任何使用该服务的客户端完全透明地了解呼叫是如何进行的以及我们在响应中收到的内容；然而，我们现在有两个主要问题:

*   我们的代码将与某个 HTTP 库的使用紧密结合。
*   每个客户端都必须解析响应。

最重要的是，假设我们在现有的 HTTP 客户端中发现了一个高安全风险问题，他们不会在接下来的几周内发布修复程序。我们必须切换到一个新的 HTTP 库，但是让它们的对象分布在我们所有的代码中会使这变得更加困难和麻烦。这只是为什么这种方法对我们来说不是一个好主意的众多原因之一；我们必须继续寻找其他的选择。

## 自定义响应包装

我们还有一个选择，就是围绕我们的响应构建一个自定义对象，以便能够轻松获得响应，同时能够检查和处理响应错误。

尽管这种方法改进了一些东西，但是除了实现定制解决方案的额外工作之外，我们仍然有一些以前见过的问题；这个解决方案也不理想。

那么我们能做什么呢？我们如何才能实现一种简单易读的方式来处理响应？

# Arrow 要么是来救援的

答案是使用[或者](https://arrow-kt.io/docs/0.11/apidocs/arrow-core-data/arrow.core/-either/)。[或者](https://arrow-kt.io/docs/0.11/apidocs/arrow-core-data/arrow.core/-either/)是 [Arrow 库](https://arrow-kt.io/)的一部分，这个库为 Kotlin 提供了一些很好的“增强”,可以在我们的项目中使用。[或者](https://arrow-kt.io/docs/0.11/apidocs/arrow-core-data/arrow.core/-either/)基本上是一个包装器对象，用于保存计算结果，一旦出现第一个错误，就允许停止计算。

虽然我不得不承认使用 [Arrow library](https://arrow-kt.io/) 有一个很长的学习曲线，而且我对他们的文档不是特别满意，但是这个库提供了一些概念，对于在 Kotlin 中实现更好的可读性和可维护性非常有用。

![](img/107a346a80d4b81a84612905695c7dba.png)

要使用 Arrow 库，您只需在 Gradle 项目的 dependencies 部分导入依赖项:

```
implementation("io.arrow-kt:arrow-core:1.0.0")
```

它的工作方式是，我们将返回一个[或者](https://arrow-kt.io/docs/0.11/apidocs/arrow-core-data/arrow.core/-either/)对象，而不是返回一个类型作为执行我们方法的结果。当事情成功完成时，这个对象将总是包含一个结果，或者当事情不顺利并且请求不能被完成时，这个对象将总是包含一个“问题”。

如果我们试图将这一点应用到前面的例子中，我们必须首先定义在我们的例子中什么是“问题”:

一旦我们有了它，我们的方法就会像这样:

正如你可以清楚地看到的，这种方法更加干净，不仅如此，它还允许客户端使用我们的代码进行简单而整洁的错误处理。

如果你把它想成一个有两个通道的管道可能会有帮助:`Left`和`Right`。

我们总是使用`Left`通道来传达错误，使用`Right`通道来传达成功计算的结果。 [Kotlin 扩展](https://kotlinlang.org/docs/extensions.html)允许在每个对象中提供`left()`和`right()`方法，以便能够轻松响应转换为任一对象，这就是 [Kotlin 扩展](https://kotlinlang.org/docs/extensions.html)如此强大的原因。

那么现在客户收到了一个`Either`，他们可以用它做什么呢？让我们通过创建一个使用我们的`EmployeeService`的假`PayrollService`来看一个例子:

正如你在上面的例子中看到的，我们利用`fold`方法来处理响应。这允许我们干净利落地处理`EmployeeService`的响应，并且清楚地看到在两种情况下我们要做什么:如果事情按预期进行和如果事情出错。

在这种情况下，我们在记录错误后使用`PayrollService`将`Problem`传播到任何客户端，但是我们也可以只透明地传播`Problem`，而不需要针对错误场景的专用处理程序。我们如何做到这一点？我们可以利用`flatMap`方法，让我们看看如何使用它:

如你所见，这更加简洁干净！不需要异常和难看的 try-catch 块！。箭库给了我们很多可能性；还有一个我们可以使用的`map`方法，但是我们得到的响应可能是这样的:

```
Either<Problem, Either<Problem, Payroll>>
```

这是为什么呢？这是因为我们在`PayrollService` : `EmployeeService.findByEmployeeName`中使用了两个嵌套调用`Either`，在`PayrollService`中使用了私有方法`buildPayrollForEmployee`。当我们映射任一响应时，它们将被链接起来，因为我们可能会得到其中任何一个响应的失败。嵌套调用是使用`Either`的复杂性之一，只是为了简化事情，这就是我们在示例中使用`flatMap`的原因。

# 结论

在我们的源代码中，我们已经看到了一种完全不同的处理“问题”的方式，这是由 [Arrow library](https://arrow-kt.io/) 提供的。 [Arrow library](https://arrow-kt.io/) 理解起来可能很复杂，改变心态以适应它带来的新概念可能需要一些时间；在本文中，我们试图向您传达对[或](https://arrow-kt.io/docs/0.11/apidocs/arrow-core-data/arrow.core/-either/)概念的基本理解，但是还有更多的东西需要了解，并且当使用[或](https://arrow-kt.io/docs/0.11/apidocs/arrow-core-data/arrow.core/-either/)处理不同的数据结构时，事情会变得更加复杂。

在以后的文章中，我们将通过一些更复杂的例子来填补目前留下的空白；我感觉 Arrow library 文档是不够的，并且在互联网上查找示例是相当困难的。这就是为什么我想向你们介绍更多这些概念的主要原因，以使你们与 [Kotlin](https://kotlinlang.org/) 的日常工作更加容易。

暂时就这样吧！我们真心希望你喜欢这篇文章，也希望你今天学到了有用的东西！