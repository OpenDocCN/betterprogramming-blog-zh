<html>
<head>
<title>Solving Dogpile Effect Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python解决狗堆效应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solving-dogpile-effect-completely-in-code-8ae23025866f?source=collection_archive---------16-----------------------#2022-11-21">https://betterprogramming.pub/solving-dogpile-effect-completely-in-code-8ae23025866f?source=collection_archive---------16-----------------------#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1fe7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">可行的代码解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/437093a78ece78fbf089580543c5b0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R0lFWt4K4t8gxa9Q"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">朱迪·纽迈耶在<a class="ae kv" href="https://unsplash.com/photos/ECjHeJtRznQ" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8b97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上次，我们谈到了如何解决<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/solving-dogpile-effect-9d869174d302">堆效应</a>。</p><p id="6fc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提到的三种方法如下:</p><ol class=""><li id="2a3d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">预热缓存</li><li id="ed83" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">延长缓存时间</li><li id="4959" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">互锁</li></ol><p id="0d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们也提到了三种方法中的每一种都有其适用的场景和相应的潜在风险。那么有没有办法提取各自的优点，构造一个更完整的解决方案呢？</p><p id="16b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将提供一个例子，并解释我的想法。</p><h1 id="7b58" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">解决方案概念</h1><p id="1f2b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">延长缓存时间有效地提高了缓存的可用性。当缓存无效并且同时被请求时，只有一个请求可以通过缓存进入后端系统。随着缓存时间的延长，其余的请求将获得原来的结果。</p><p id="02f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，当并发请求同时发生时(这通常是不常见的)，仍然存在多个请求进入后端系统的可能性，因此采用了排他锁方法。</p><p id="9ad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，一直使用排他锁的成本太高了，如果可能的话，我们应该尽量减少排他锁的使用。然后，只有当缓存不存在并且需要访问后端系统时，才使用排他锁，否则就使用扩展缓存时间。</p><p id="4649" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个过程如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/df674bd3bebb4c7afe153e7826ff5b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5F1C1C3x8yiWirjGyOxDfg.png"/></div></div></figure><p id="afe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，确定缓存是否存在，如果缓存存在我们还是要确定缓存是否过期。如果一切正常，我们可以只取缓存的原值，但是如果缓存过期，就必须进入更新缓存的过程。</p><p id="b183" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免高并发请求的影响，所有更新缓存进程都应该尝试获取一个锁。</p><p id="0e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，如果缓存从一开始就不存在，那么更新缓存的过程将是相同的。只是过程和上面说的不一样，因为没有原值，所以没有获得锁的人必须等待锁，才能得到结果。</p><h1 id="45b6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">解决方案概述</h1><p id="6cda" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在我们进入实现的细节之前，让我们看看实际的做法。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="3544" class="nj mh iq nf b be nk nl l nm nn">def read_aside_cached(ttl, lock_period, race_period):<br/>  def decorator(func):<br/>    def wrap(*args, **kw):<br/>      key = f"{func.__name__}_{args}_{kw}"<br/>      return cache_factory(key, ttl, lock_period, race_period).handle(func, *args, **kw)<br/>      <br/>    return wrap<br/>  return decorator<br/><br/>@read_aside_cached(60 * 5, 30, 60)<br/>def foo(a, b=1, c=2):<br/>  return db.query(a, b, c)</span></pre><p id="b7ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是Python中的一个例子，我们使用装饰器来封装实际的数据库操作。</p><p id="3b01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个装饰器需要几个参数。</p><ol class=""><li id="0c47" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">ttl，这个很好理解，就是这个缓存的到期时间。</li><li id="fbe9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">lock_period，因为我们需要获取锁，所以这个参数决定了我们要锁多久。</li><li id="4cd6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">race_period，这个参数用于确定我们想要将缓存扩展多长时间。</li></ol><p id="6cae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的示例中，<code class="fe no np nq nf b">foo</code>的缓存过期时间为5分钟，并保留1分钟的缓冲时间。锁定时间是30秒，这与数据库操作的预期时间有关。</p><h1 id="1d2c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">解决方案详细信息</h1><p id="bc79" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">接下来，让我们分解流程图的实际细节。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="1f36" class="nj mh iq nf b be nk nl l nm nn">def cache_factory(key, ttl, lock_period, race_period):<br/>  value, expired_at = Store.get(key)<br/>  <br/>  if expired_at is not None:<br/>    handler = ExistedCacheHandler(key, ttl, lock_period, race_period)<br/>  else:<br/>    handler = NonExistedCacheHandler(key, ttl, lock_period, race_period)<br/><br/>  handler.set_meta(value, expired_at)<br/>  return handler</span></pre><p id="3497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在流程图的开始，我们需要首先尝试获取一个缓存，并使用结果来查看是否需要延长缓存时间。</p><p id="41bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">流程图的顶部和底部路径由每个类封装。我们先来看一下<code class="fe no np nq nf b">ExistedCacheHandler</code>的实现。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="c157" class="nj mh iq nf b be nk nl l nm nn">class ExistedCacheHandler(BaseCacheHandler):<br/>  def handle(self, func, *args, **kw):<br/>    if self.now &gt; self.expired_at and Store.try_lock(self.key, self.lock_period):<br/>      result = func(*args, **kw)<br/>      Store.set(self.key, result, self.ttl + self.race_period)<br/>      Store.unlock(self.key)<br/>      return result<br/><br/>    return self.orig_val</span></pre><p id="8904" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果缓存过期并成功获得锁，它将负责更新缓存。</p><p id="19ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/solving-dogpile-effect-9d869174d302">在上一篇文章</a>中，我们介绍了Rails方法，其中Rails将原始值再次写回缓存，并稍微延长了有效时间。但是这里我们直接让缓存时间为<code class="fe no np nq nf b">(ttl + race_period)</code>，所以不需要手动延长缓存时间。</p><p id="1d13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，如果高速缓存未过期或未被锁定，则使用高速缓存中的原始结果。</p><p id="64b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，缓存不存在的逻辑更加复杂。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="00b3" class="nj mh iq nf b be nk nl l nm nn">class NonExistedCacheHandler(BaseCacheHandler):<br/>  def handle(self, func, *args, **kw):<br/>    while self.expired_at is None:<br/>      if Store.try_lock(self.key, self.lock_period):<br/>        result = func(*args, **kw)<br/>        Store.set(self.key, result, self.ttl + self.race_period)<br/>        Store.unlock(self.key)<br/>        return result<br/>      else:<br/>        while not Store.try_lock(self.key, self.lock_period):<br/>          time.sleep(0.01)<br/>          self.orig_val, self.expired_at = Store.get(self.key)<br/>        <br/>        Store.unlock(self.key)<br/>    else:<br/>      return self.orig_val</span></pre><p id="6fa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当发现缓存不存在时，我们仍然需要获取锁来更新缓存。但是如果没有成功获得锁，我们必须等待，要么等待锁，要么等待缓存更新。</p><p id="23cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么要等这两个条件中的任何一个呢？</p><p id="58c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原因是获得锁的人可能出于“某种原因”没有释放锁。我们的最终目标是获得缓存结果，所以即使我们没有获得锁，我们仍然可以获得结果。当然，如果锁被成功获取，更新缓存的责任将被承担。</p><p id="e0a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们看看两个常见的组件。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="7bc3" class="nj mh iq nf b be nk nl l nm nn">class Store:<br/>  @staticmethod<br/>  def get(k):<br/>    value = redis.get(k)<br/>    expired_at = redis.pttl(k) / 1000 + time.time() if value is not None else None<br/>    return value, expired_at<br/>    <br/>  @staticmethod<br/>  def set(k, v, ttl):<br/>    return redis.set(k, v, "EX", ttl)<br/><br/>  @staticmethod<br/>  def try_lock(k, lock_period):<br/>    r = redis.set(k, 1, "NX", "EX", lock_period)<br/>    return r == "OK"<br/>  @staticmethod<br/>  def unlock(k):<br/>    redis.del(k)<br/>    <br/>class BaseCacheHandler:<br/>  def __init__(self, key, ttl, lock_period, race_period):<br/>    self.key = key<br/>    self.ttl = ttl<br/>    self.lock_period = lock_period<br/>    self.race_period = race_period<br/>  <br/>  def set_meta(self, value, expired_at):<br/>    self.orig_val = value<br/>    self.expired_at = expired_at</span></pre><p id="1a82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe no np nq nf b">BaseCacheHandler</code>定义了构造函数和一个帮助函数。</p><p id="f179" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe no np nq nf b">Store</code>是整个实现的核心，我用Redis作为示范。</p><ul class=""><li id="bce7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nr ly lz ma bi translated"><code class="fe no np nq nf b">get()</code>:除了获取缓存值，我们还需要获取缓存的到期时间。</li><li id="82a6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nr ly lz ma bi translated"><code class="fe no np nq nf b">set()</code>:写入数值，同时设置到期时间。</li><li id="6a4e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nr ly lz ma bi translated"><code class="fe no np nq nf b">try_lock()</code>:使用Redis的原子更新锁定<code class="fe no np nq nf b">NX</code>。</li><li id="6a50" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nr ly lz ma bi translated"><code class="fe no np nq nf b">unlock()</code>:简单的移除钥匙。</li></ul><p id="fad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过组装所有这些部分，高速缓存装饰器就完成了，不仅具有延长高速缓存时间的能力，还具有独占锁支持。</p><h1 id="aafe" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="83ed" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是一个可行的例子，为了更容易理解，我们用更直观的方式进行了排列。然而，有些事情是可以改进的。</p><p id="128a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如目前很多地方都是用单一命令直接操作Redis，写在<a class="ae kv" href="https://redis.io/docs/manual/pipelining/" rel="noopener ugc nofollow" target="_blank"> Redis管道</a>里会更好。此外，用Lua编写一些简单的逻辑作为脚本也是一个好主意。</p><p id="327f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不得不说这样的实现实际上非常复杂，但是旁读缓存真的需要这样做吗？</p><p id="3c55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这取决于应用程序的负载和我们对应用程序的期望。</p><p id="bc70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果后端系统很强大，能够处理突然的峰值，那么常规的延长缓存时间是可行的。但如果后端薄弱，就要考虑更扎实的办法了。</p><p id="ebf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">增强缓存机制是一种选择，但是增强后端系统也是一种选择。有几种常见的方法可以增强后端系统的可用性。</p><ol class=""><li id="08d0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">断路器模式</li><li id="9895" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">服务质量下降</li><li id="327b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">多层缓存</li></ol><p id="957e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文提供了一个增强缓存的选项，不需要部署新的组件，只需要修改逻辑，在我看来还是值得的。</p></div></div>    
</body>
</html>