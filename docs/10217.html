<html>
<head>
<title>C++ Framework for More Expressive Inter-Process Message Passing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更具表现力的进程间消息传递的C++框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/c-framework-for-inter-process-message-passing-df3789f982bc?source=collection_archive---------3-----------------------#2021-12-14">https://betterprogramming.pub/c-framework-for-inter-process-message-passing-df3789f982bc?source=collection_archive---------3-----------------------#2021-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="53c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写进程间消息传递框架，提高代码的表现力，使代码更加优雅。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b218ccbc68d209bea5db456e130e3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X5ff0BKPMEhOPMjC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="5354" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">进程间通信</h1><h2 id="f707" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">流程——概述</h2><p id="936e" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我们经常在网上读到进程是正在执行的程序，但是等一下，这到底是什么意思呢？对一些人来说，可能不太清楚这意味着什么。维基百科提供了一个更清晰的定义:</p><blockquote class="mz na nb"><p id="56ed" class="mg mh nc mi b mj nd ju ml mm ne jx mo nf ng mq mr nh ni mt mu nj nk mw mx my im bi translated">进程是由一个或多个线程执行的计算机程序的实例。</p></blockquote><p id="be2f" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">让我们看一个例子。我们有一个正在开发的名为<code class="fe nl nm nn no b">app</code>的可执行文件，所以我们有一个名为<code class="fe nl nm nn no b">app</code>的文件，在Windows上称为<code class="fe nl nm nn no b">app.exe</code>。当我们运行它时，例如，通过从shell启动<code class="fe nl nm nn no b">./app</code>，我们将运行我们程序的一个实例<code class="fe nl nm nn no b">app</code>。我们可以多次执行<code class="fe nl nm nn no b">./app</code>，并在我们的操作系统上运行多个<code class="fe nl nm nn no b">app</code>实例(多个进程)。</p><p id="3f9f" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">我们的<code class="fe nl nm nn no b">app</code>可以有单线程或多线程，这取决于我们如何设计它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4001815d85abe70cd17876cce81a0e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*GWK8QIzKbOedko4tRpdcKA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">流程的简化说明(图片由作者提供)</p></figure><p id="b7dc" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">在上面的简单图示中，我们可以看到每个进程都被分配了一个单独的虚拟内存空间。<code class="fe nl nm nn no b">process1</code>对<code class="fe nl nm nn no b">process2</code>的虚拟内存空间一无所知，也无权访问。</p><p id="3c65" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">另一方面，线程生活在同一个进程中，它们共享相同的虚拟内存空间。我希望这个例子阐明了进程和线程之间的区别。</p><h2 id="b33f" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">线程间通信与进程间通信</h2><p id="fbed" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">线程可以更容易地通信，因为它们如上所述共享相同的地址空间。我们可以为线程使用一个共享的全局变量，通过适当的同步机制来交换数据/消息。阅读下面我关于线程间消息传递的文章。</p><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/writing-framework-for-inter-thread-message-passing-in-c-256b5308a471"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">用C++编写线程间消息传递框架</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">一个在线程间传递消息的框架，而不必担心底层线程代码</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">better编程. pub</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/710d18329c13b631d5be916746b9a6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*HbHtnKYJBe4sYlJowUNXAA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">线程使用相同的内存空间进行通信(图片由作者提供)</p></figure><p id="b234" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">进程不共享同一个地址空间，所以我们需要另一种机制在进程间交换数据。我们不能使用全局变量，一个过程中的全局变量在另一个过程中不存在。其中一种方法是简单地使用文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/0cff6406e913fc3f7bc040b433048108.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*vX2GMYCLSMezI8WTm7zQmw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用文件进行进程间数据交换(图片由作者提供)</p></figure><p id="0420" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">既然已经清楚了为什么我们不能使用线程中使用的相同方法在进程间交换数据，我们可以在下一节看看进程间通信(IPC)的常用方法。</p><h2 id="ae85" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">用C++实现IPC的不同方法</h2><p id="72ff" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我们可以使用许多IPC机制。其中一些是:</p><ul class=""><li id="5103" class="ok ol it mi b mj nd mm ne lw om lz on mc oo my op oq or os bi translated">文件</li><li id="8e74" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">共用存储器</li><li id="fd96" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">管</li><li id="8298" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">Unix域套接字</li><li id="77f2" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">信息排队</li><li id="e870" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">等等。</li></ul><p id="8a2c" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">有很多C++库可以用于IPC，比如<a class="ae ky" href="https://www.boost.org/doc/libs/1_78_0/doc/html/interprocess.html" rel="noopener ugc nofollow" target="_blank"> Boost。进程间</a>等。本文的重点是创建一个抽象层，隐藏底层IPC机制的细节，以便应用程序开发人员可以专注于编写应用程序逻辑。他们可以忘记幕后发生的事情，也不必编写大量样板代码。我们的目标是以下列形式发送消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="45b2" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">我们可以简单地将对象发送给其他进程。在接收过程中，我们希望这样编写代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="541f" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">我们只是在主要使用lambdas的地方注册我们的处理程序，就这样。我将在接下来的章节中介绍细节。在本文中，我们使用<a class="ae ky" href="https://www.boost.org/doc/libs/1_78_0/doc/html/interprocess/synchronization_mechanisms.html#interprocess.synchronization_mechanisms.message_queue" rel="noopener ugc nofollow" target="_blank"> Boost的消息队列</a>作为底层的IPC机制。</p><h1 id="c3e4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">序列化</h1><h2 id="bd67" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">为什么我们需要序列化我们的对象？</h2><p id="474f" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">当我们想要在进程之间交换消息时，一件重要的事情是序列化我们的数据。</p><blockquote class="mz na nb"><p id="e8f8" class="mg mh nc mi b mj nd ju ml mm ne jx mo nf ng mq mr nh ni mt mu nj nk mw mx my im bi translated">序列化是一个将代码中的数据结构/对象状态转换为一种格式的过程，这种格式可以在同一台机器或不同的机器上存储或传输，并在以后进行重构。</p></blockquote><p id="ea4f" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">如果我们有一个类的实例——一个对象，我们可能想把它保存到一个文件中，或者把它发送到同一台机器或另一台机器上的另一个进程中。</p><p id="1ea2" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">如前所述，两个进程不共享相同的内存空间，因此我们需要一种机制，在将对象发送给另一个进程之前，将它转换为字节流。</p><p id="547d" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">现在，下一个问题是为什么我们不能只发送对象的字节？有可能，但是有很多事情可能会出错。假设我们使用C++编写了两个程序，如果我们使用不同的编译器构建它们，或者如果对象不是简单的旧对象(PODs)，或者我们在具有不同体系结构的不同机器上构建它们(big vs. little-endian)，等等，仍然可能出错。</p><p id="84c3" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">对于复杂类型，例如，将指针/引用作为成员并具有虚函数的类型，我们不能简单地转储内存，因为它们包含仅在该进程中有效的地址(指针、虚拟指针)。如果你不熟悉C++对象模型，你可以阅读下面我的文章，解释C++如何存储对象。</p><div class="nq nr gp gr ns nt"><a href="https://towardsdatascience.com/c-basics-understanding-object-model-b8152c8a4bcf" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">C++基础:理解对象模型</h2><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="pa l oe of og oc oh ks nt"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/9decd6c07ba37c8e06129c115acf32ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*HADnpZaE-oQZf2WLHhh5Yw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将对象从进程1发送到进程2(图片由作者提供)</p></figure><p id="6161" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">为了传输我们的数据，我们可以使用上一节中列出的任何IPC机制。</p><h2 id="0e3c" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">序列化技术</h2><p id="da59" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">在为我们的应用程序选择序列化时，我们要考虑很多事情。其中一些是:</p><ul class=""><li id="2fd8" class="ok ol it mi b mj nd mm ne lw om lz on mc oo my op oq or os bi translated">用户友好性:我们是否希望它是人类可读的</li><li id="2d44" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">编码和解码速度</li><li id="0d10" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">序列化数据的大小</li><li id="1d52" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">语言不可知/特定于语言</li><li id="b8b8" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">安全支持等。</li></ul><p id="dfb5" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">我们还可以将序列化分为:</p><ul class=""><li id="2b9a" class="ok ol it mi b mj nd mm ne lw om lz on mc oo my op oq or os bi translated">基于文本的</li><li id="d211" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">基于二进制的</li></ul><p id="44b6" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">基于文本的序列化包括XML、JSON、YAML等。，而对于基于二进制的，我们有CBOR，谷歌协议缓冲区等。</p><p id="f6cc" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">例如，我们可以有一个名为<code class="fe nl nm nn no b">Coord</code>的结构，它表示一个三维笛卡尔坐标系。我们有x，y，和z。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="4346" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">假设我们选择了JSON作为我们的序列化技术，我们可以得到如下的序列化数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="be8b" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">我们的数据可以作为上面文本的utf-8字节流发送。</p><p id="e10a" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">您可以根据自己的需要选择序列化技术，您是否需要一种得到良好支持的技术，人类可读性是否是一个决定性因素，都将取决于您的应用程序需求。</p><p id="4955" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">为了演示C++中进程间消息传递的框架，我们将在本文中使用JSON。我使用的库是nlohmann JSON，你可以在这个Github <a class="ae ky" href="https://github.com/nlohmann/json" rel="noopener ugc nofollow" target="_blank"> repo </a>中查看。我假设您了解如何使用该库。但是如果您不知道也不用担心，因为我将在下一节向您展示如何使用它。</p><h1 id="df68" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">消息传递框架</h1><p id="e338" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">既然我们已经决定了使用哪些组件:</p><ul class=""><li id="cb34" class="ok ol it mi b mj nd mm ne lw om lz on mc oo my op oq or os bi translated">我们使用Boost的消息队列作为IPC机制，并且</li><li id="586f" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">我们使用JSON来序列化我们的消息</li></ul><p id="c486" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">让我们开始框架的实现。</p><h2 id="2071" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">这些信息</h2><p id="f17b" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">假设我们有两条不同的消息要从<code class="fe nl nm nn no b">Process 1</code>发送到<code class="fe nl nm nn no b">Process 2</code>。他们是<code class="fe nl nm nn no b">Coord</code>和<code class="fe nl nm nn no b">LatLong</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="a81e" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">它们的JSON表示如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="f76f" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">我们采取的第一步是使用选择的库为两个对象编写序列化/反序列化函数模板，命名为<code class="fe nl nm nn no b">to_json</code>和<code class="fe nl nm nn no b">from_json</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="18b3" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">使用这些函数模板，我们可以通过编写以下代码来序列化/反序列化我们的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="ad3b" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">没有框架</h2><p id="29a5" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">有了序列化/反序列化，我们可以添加一个IPC机制来交换消息。下面是使用Boost的消息队列的两个进程<code class="fe nl nm nn no b">sender</code>和<code class="fe nl nm nn no b">receiver</code>的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发件人(作者代码)</p></figure><p id="1e58" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">上面的<code class="fe nl nm nn no b">sender</code>代码创建了一个消息队列，并在退出之前发送了两条消息。在发送之前，对象被序列化成JSON对象，并通过<code class="fe nl nm nn no b">dump()</code>和<code class="fe nl nm nn no b">c_str()</code>函数转换成空终止字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ec38" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">在<code class="fe nl nm nn no b">receiver</code>端，我们打开创建的消息队列，等待消息到达。消息是字节流，所以首先我们必须将它们转换成JSON对象，并调用反序列化函数将JSON对象转换成<code class="fe nl nm nn no b">Coord</code>和<code class="fe nl nm nn no b">LatLong</code>类型。</p><p id="141a" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">我们的代码现在按照我们想要的方式工作，但是有很多事情我们可以改进，比如隐藏类中的细节，消除编写样板代码的需要，等等。</p><h2 id="b2e8" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">表达代码</h2><p id="2ee0" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我相信大家都知道，代码被阅读的次数比它被编写的次数多得多，我们都花了很多时间阅读别人或我们自己编写的代码。这就是为什么当我们写代码时，我们必须为其他开发者写，而不是为机器写。</p><p id="52aa" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">也许这并不适用于所有情况，对于性能关键型软件，我们可能希望优先考虑机器，牺牲可读性，但一般来说，大多数时候我们应该编写代码供他人阅读。</p><p id="4e9d" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">这就是编写表达性代码的目的，清楚地表达代码的意图，而不增加不必要的复杂性。</p><p id="1fe0" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">没有标准的方法来衡量代码的可表达性，这是一个定性的主观的衡量标准。</p><p id="4552" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">在我们的例子中，我认为我们可以通过为进程间消息传递编写一个框架来使我们的代码更有表现力。发送和接收消息时真正重要的是<code class="fe nl nm nn no b">send()</code>和<code class="fe nl nm nn no b">handle()</code>。我们可以对比以下几个版本，决定哪一个对我们更有表现力。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有框架</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带框架</p></figure><h2 id="731d" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">有了框架</h2><p id="e9b9" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">现在让我们一步一步地实现这个框架。我们没什么需要做的。我们可以重用在下一篇文章中讨论过的<code class="fe nl nm nn no b">CallbackWrapper</code>类。</p><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/writing-framework-for-inter-thread-message-passing-in-c-256b5308a471"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">用C++编写线程间消息传递框架</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">一个在线程间传递消息的框架，而不必担心底层线程代码</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">better编程. pub</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><p id="8792" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">如果你没看过，建议你看一下了解详情。使用类型擦除技术实现该类，以包装可调用的并提供接口来:</p><ul class=""><li id="bc55" class="ok ol it mi b mj nd mm ne lw om lz on mc oo my op oq or os bi translated">检查包装的对象是否可以处理类型</li><li id="738d" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">转接电话</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="2c60" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">下一步是实现<code class="fe nl nm nn no b">Sender</code>类。这很简单，请看下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="a276" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">最后一步是实现<code class="fe nl nm nn no b">Receiver</code>类。构建这个类有几个部分，如下所述。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="eb06" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">除了包装序列化/反序列化和消息队列，我们还实现了:</p><ul class=""><li id="611c" class="ok ol it mi b mj nd mm ne lw om lz on mc oo my op oq or os bi translated"><code class="fe nl nm nn no b">Handle()</code>功能模板，以及</li><li id="e944" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">调度表</li></ul><p id="abbb" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">Handle function template接受一个callable，获取它的第一个参数的类型，<strong class="mi iu">从中删除引用和cv限定符</strong>。然后，它使用该类型来<em class="nc">选择使用哪个函数将JSON对象转换成正确的对象</em>。它还将可调用的存储在一个向量中。</p><p id="e538" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">当消息到达时，我们遵循以下步骤:</p><ul class=""><li id="f0ed" class="ok ol it mi b mj nd mm ne lw om lz on mc oo my op oq or os bi translated">创建一个JSON对象</li><li id="f39d" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">使用调度表获得正确的<code class="fe nl nm nn no b">from_json</code>功能</li><li id="d2e1" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">将JSON对象转换为正确的对象</li><li id="9167" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">通过<code class="fe nl nm nn no b">callbackWrappers</code>循环检查应该使用哪个处理程序</li><li id="b1c3" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">调用处理程序</li></ul><p id="7fac" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">有了这个框架，我们只需编写以下代码来发送和接收消息，就可以实现我们在本文开始时提出的目标。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="1666" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">执行时，代码会打印:</p><pre class="kj kk kl km gt pc no pd pe aw pf bi"><span id="c64c" class="lr la it no b gy pg ph l pi pj">Coord: 1, 2, 3<br/>LatLong: 1.5, 2.5</span></pre><p id="28ed" class="pw-post-body-paragraph mg mh it mi b mj nd ju ml mm ne jx mo lw ng mq mr lz ni mt mu mc nk mw mx my im bi translated">当然，为了让它正确打印，我们必须实现以下内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h1 id="7b38" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><ul class=""><li id="be49" class="ok ol it mi b mj mk mm mn lw pk lz pl mc pm my op oq or os bi translated">进程间消息传递不同于线程间消息传递，因为进程不共享相同的地址空间</li><li id="1c43" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">因此，我们不能简单地使用全局变量进行进程间通信</li><li id="e926" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">有许多可用的进程间通信机制，我们可以选择一个适合我们需要的，例如，消息队列</li><li id="3ff2" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">在进程之间交换数据需要序列化，因为对象在内存中的存储方式可能会因CPU架构、编译器等的不同而不同。</li><li id="8bb3" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">作为开发人员，我们的目标不仅是编写有效的代码，还要编写有表现力的代码，因为代码读得比写得多，我们必须清楚地表达我们的意图，并尽量避免增加不必要的复杂性，这会使我们的代码变得混乱</li><li id="774c" class="ok ol it mi b mj ot mm ou lw ov lz ow mc ox my op oq or os bi translated">本文展示了一种用C++编写IPC框架的方法</li></ul></div></div>    
</body>
</html>