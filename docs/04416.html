<html>
<head>
<title>Analyse the Contents of Swift Files With SourceKitten</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SourceKitten分析Swift文件的内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/analysing-swift-code-with-sourcekitten-99ff43d19428?source=collection_archive---------6-----------------------#2020-04-12">https://betterprogramming.pub/analysing-swift-code-with-sourcekitten-99ff43d19428?source=collection_archive---------6-----------------------#2020-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="71fb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Swift中检查Swift源文件的内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/841cddeb7e5f6124a1a84bbc80cb5952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1A68TqcNkd4zQ5ch2Q92Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kimtheris?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sereja Ris </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4c2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/jpsim/SourceKitten" rel="noopener ugc nofollow" target="_blank"> SourceKitten </a>是一个开源项目，用于解析Swift文件的内容并获取有关该文件的详细信息。它用在许多你可能经常使用的工具中，比如<a class="ae ky" href="https://github.com/realm/SwiftLint" rel="noopener ugc nofollow" target="_blank"> SwiftLint </a>和<a class="ae ky" href="https://github.com/realm/Jazzy" rel="noopener ugc nofollow" target="_blank"> Jazzy </a>。</p><p id="85bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当查看它的自述文件时，它似乎只是一个命令行工具。然而，SourceKitten还包括一个名为<code class="fe lv lw lx ly b">SourceKittenFramework</code>的框架，我们可以用它来构建程序，自己分析和检查Swift代码。它只能在Mac应用程序中使用，不支持iOS、tvOS或watchOS。</p><p id="8373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们首先将框架集成到我们的项目中。接下来，我们将了解如何分析Swift文件的内容，并仔细查看分析结果。一旦我们理解了哪些信息是可用的，我们将把它包装在一个结构中，在这个结构上我们可以执行我们自己的分析。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bb01" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">装置</h1><p id="befa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">第一步是让<code class="fe lv lw lx ly b">SourceKittenFramework</code>在我们的应用程序中可用。我们可以使用CocoaPods或Swift包管理器来实现。</p><ol class=""><li id="7da0" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">CocoaPods:只需将<code class="fe lv lw lx ly b">pod `SourceKittenFramework`</code>添加到您的podfile并运行<code class="fe lv lw lx ly b">pod install</code>。</li><li id="1e9a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">Swift包管理器:将包添加到您的<code class="fe lv lw lx ly b">Package.swift</code>文件中的<code class="fe lv lw lx ly b">dependencies</code>列表中，如下所示:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将SourceKittenFramework添加到Package.swift文件中。</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1d23" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用</h1><p id="fad9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们看一个标准的<code class="fe lv lw lx ly b">UIViewController</code>模板，它是Xcode在添加新的Cocoa Touch类时生成的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UIViewController子类的入门模板。</p></figure><p id="fa8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它只不过是<code class="fe lv lw lx ly b">UIViewController</code>的一个名为<code class="fe lv lw lx ly b">ViewController</code>的空子类，它覆盖了方法<code class="fe lv lw lx ly b">viewDidLoad</code>，并将方法调用传递给它的超类。</p><p id="b028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，您可以看到如何使用我们之前导入的<code class="fe lv lw lx ly b">SourceKittenFramework</code>来分析Swift代码。</p><p id="cd83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:当您收到错误“xcrun: error:不能在应用程序沙箱中使用”时，您需要在应用程序中禁用沙箱。您可以在后面的“问题”一节中看到如何做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用SourceKittenFramework分析Swift源代码。</p></figure><p id="19e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —当然，我们从导入<code class="fe lv lw lx ly b">SourceKittenFramework</code>开始，以便能够使用它的类、结构和方法。</p><p id="1f26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —接下来，我们需要创建一个<code class="fe lv lw lx ly b">File</code>对象，它代表一个源文件。这可以通过将我们想要分析的Swift文件的路径传递给它的初始化器来完成，初始化器将读取文件的内容。</p><p id="a5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code>—<code class="fe lv lw lx ly b">File</code>类提供了另一个初始化器，它直接将源代码作为字符串。这对于测试特别有用，因为我们不需要将每个想要测试的代码片段定义为一个单独的文件。我们可以在测试用例中直接定义它们。</p><p id="df4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —通过将<code class="fe lv lw lx ly b">File</code>对象传递给<code class="fe lv lw lx ly b">Structure</code>的初始化器，我们开始分析。我们通过检查<code class="fe lv lw lx ly b">Structure</code>的属性<code class="fe lv lw lx ly b">description</code>来访问分析结果，该属性保存了分析结果的文本JSON表示。</p><p id="408d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们执行分析的代码很短，但结果却不是这样。在60多行JSON代码中，我们获得了之前看到的关于<code class="fe lv lw lx ly b">ViewController</code>类的所有可用信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用SourceKittenFramework分析UIViewController模板的结果。</p></figure><p id="9752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看一些关键参数:</p><ul class=""><li id="4a8b" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu nt nj nk nl bi translated"><code class="fe lv lw lx ly b">substructure</code>:子结构是一个对象列表，其中每个对象代表源代码中的一个元素。这些元素可以是类、结构、参数、方法、方法调用等等。由于一个方法通常包含在一个类或结构中，相应的<code class="fe lv lw lx ly b">substructure</code>也是代表一个类或结构的<code class="fe lv lw lx ly b">substructure</code>的一部分。因此，它们反映了被分析源代码的层次结构。因为在这个例子中我们只分析了一个类，所以主JSON对象在列表中只有一个元素表示我们的类<code class="fe lv lw lx ly b">ViewController</code>。在第19行，我们可以找到另一个<code class="fe lv lw lx ly b">substructure</code>，也就是方法<code class="fe lv lw lx ly b">viewDidLoad</code>。这又在第24行中定义了另一个<code class="fe lv lw lx ly b">substructure</code>，表示调用<code class="fe lv lw lx ly b">super.viewDidLoad</code>。</li><li id="58b3" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nt nj nk nl bi translated"><code class="fe lv lw lx ly b">name</code>、<code class="fe lv lw lx ly b">nameoffset</code>、<code class="fe lv lw lx ly b">namelenght</code>:在这里我们可以找到一个<code class="fe lv lw lx ly b">substructure</code>的名字(比如第12行的<code class="fe lv lw lx ly b">ViewController</code>或者第29行的<code class="fe lv lw lx ly b">super.viewDidLoad</code>)。<code class="fe lv lw lx ly b">nameoffset</code>是所分析的源文件中名称首字母的索引。在本例中，名称<code class="fe lv lw lx ly b">ViewController</code>从索引20开始。与<code class="fe lv lw lx ly b">namelength</code>一起，它定义了文件名在文件中的位置。</li><li id="c2f2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nt nj nk nl bi translated"><code class="fe lv lw lx ly b">accessibility</code>:这个字段告诉我们一个元素的可访问性(例如私有、内部或公共)。</li><li id="0ae9" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nt nj nk nl bi translated"><code class="fe lv lw lx ly b">kind</code>:<code class="fe lv lw lx ly b">kind</code>的值告诉我们当前<code class="fe lv lw lx ly b">substructure</code>是什么样的代码实体。如果一个类声明有种类<code class="fe lv lw lx ly b">source.lang.swift.decl.class</code>，一个参数可以被<code class="fe lv lw lx ly b">source.lang.swift.decl.var.parameter</code>识别。可能值的列表可以在SourceKittenFrameworks存储库的<a class="ae ky" href="https://github.com/jpsim/SourceKitten/blob/master/Source/SourceKittenFramework/SwiftDeclarationKind.swift" rel="noopener ugc nofollow" target="_blank"> this file </a>中找到。但是看起来这个列表是不完整的，因为在结果中，我们看到<code class="fe lv lw lx ly b">source.lang.swift.structure.elem.typeref</code>是最外面的<code class="fe lv lw lx ly b">substructure</code>，它不在列表中。</li><li id="a4ce" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nt nj nk nl bi translated"><code class="fe lv lw lx ly b">inheritedtypes</code>:这是一个包含当前<code class="fe lv lw lx ly b">substructure</code>元素继承或符合的所有类和协议的列表。我们可以在第51行找到这个列表。正如所料，我们的<code class="fe lv lw lx ly b">ViewController</code>是<code class="fe lv lw lx ly b">UIViewController</code>的子类。</li></ul><p id="3972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在我们知道了关于类<code class="fe lv lw lx ly b">ViewController</code>的大量信息，但它只是一个表示JSON结构的字符串。我们如何在应用程序中使用它来查看和执行更详细的分析呢？</p><p id="aee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们可以创建一个符合<code class="fe lv lw lx ly b">Codable</code>的结构，并使用一个<code class="fe lv lw lx ly b">JSONDecoder</code>将<code class="fe lv lw lx ly b">Structure</code>的<code class="fe lv lw lx ly b">description</code>属性自动转换为这个名为<code class="fe lv lw lx ly b">SyntaxStructure</code>的结构，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要从生成的JSON文件中解码的结构。</p></figure><p id="ca06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —它包括我们在上述分析结果中发现的所有参数。请注意，像<code class="fe lv lw lx ly b">substructure</code>这样的一些属性具有类型<code class="fe lv lw lx ly b">[SyntaxStructure]?</code>。这就是我们如何创建层次结构。</p><p id="290b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —由于JSON文件中的键与结构的参数名不匹配，我们需要添加一个符合<code class="fe lv lw lx ly b">CodingKey</code>的enum。这里，我们告诉解码器如何根据上面的JSON文件填充一个<code class="fe lv lw lx ly b">SyntaxStructure</code>的值。</p><p id="e320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将看到如何使用一个<code class="fe lv lw lx ly b">JSONDecoder</code>来创建一个<code class="fe lv lw lx ly b">SyntaxStructure</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将生成的JSON文件解码为struct SyntaxStructure。</p></figure><p id="d6b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —我们将解码封装在一个名为<code class="fe lv lw lx ly b">syntaxStructure(from:)</code>的函数中，该函数从<code class="fe lv lw lx ly b">SourceKittenFramework</code>中获取一个<code class="fe lv lw lx ly b">File</code>对象，并将其转换为<code class="fe lv lw lx ly b">SyntaxStructure</code>的实例。因为JSON解码可能会失败，所以输出类型将是可选的。</p><p id="00df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —首先，我们尝试从给定文件创建一个<code class="fe lv lw lx ly b">Structure</code>对象。我们可以通过将<code class="fe lv lw lx ly b">description</code>属性转换成数据来获取JSON数据。</p><p id="4f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —最后，我们尝试用<code class="fe lv lw lx ly b">JSONDecoder</code>将我们在上一步中创建的数据解码为<code class="fe lv lw lx ly b">SyntaxStructure</code>的实例。</p><p id="53c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —因为将文件转换成<code class="fe lv lw lx ly b">Structure</code>文件，解码可能会失败，我们捕捉到一个可能的错误，将其打印出来，看看要修复什么，然后返回<code class="fe lv lw lx ly b">nil</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f13c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="a9f4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">就是这样！现在，您可以检查已分析的Swift文件的内容。例如，您可以计算继承，计算代码实体及其依赖关系的度量，或者编写您自己的linter。</p><p id="84ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SourceKitten是一个强大的工具，需要一点练习才能使用。根据您分析的代码和您的用例，您可能需要修改<code class="fe lv lw lx ly b">StructureSyntax</code>及其参数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="639d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">问题</h1><h2 id="f18b" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">1.SourceKitten不能在macOS应用程序沙箱内使用。</h2><p id="5c59" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首次运行SourceKitten时，可能会遇到以下错误:“xcrun: error:不能在应用程序沙箱内使用。”</p><p id="24a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为SourceKitten不能在应用程序沙箱中使用。因此，您需要为您的应用程序停用它。有两种方法可以做到这一点:</p><ul class=""><li id="d3ef" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu nt nj nk nl bi translated">转到项目设置中的“签名和功能”选项卡。在那里，你会发现一个名为应用沙盒的签名部分。通过按下x按钮，您可以移除沙箱。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/3831807c82ef761203f5fc2f41e7090f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBZOaNA9Wv0VV9-A-_7DQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">禁用应用程序沙盒-选项1:通过项目文件。</p></figure><ul class=""><li id="441a" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu nt nj nk nl bi translated">转到项目的授权文件，将应用沙箱<em class="oh"> </em>的值从YES改为NO</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b7fe33dc1c6232512282bfb01719d6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0UNirK-E6y9QDy7vQKsNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">禁用应用程序沙盒—选项2:通过授权。</p></figure><p id="821a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是请记住，如果没有沙盒，您将无法在mac App Store中分发您的应用程序！</p><h2 id="5c02" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">2.SourceKitten的分析结果并不包含所有可能的信息。</h2><p id="af8f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">例如，分析结果不会包括<code class="fe lv lw lx ly b">as</code>表达式。</p><p id="0c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但你可能会说，“SwiftLint用SourceKitten，看看他们的自述吧。第一张截图显示，他们可以将<code class="fe lv lw lx ly b">as!</code>检测为强制转换违例。”你是对的！</p><p id="d466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，他们没有用SourceKitten检测到<code class="fe lv lw lx ly b">as!</code>。正如您在<a class="ae ky" href="https://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/Idiomatic/ForceCastRule.swift" rel="noopener ugc nofollow" target="_blank">中看到的，这个文件</a>定义了强制转换规则，它们通过正则表达式搜索这个字符串。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ba8d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">资源</h1><div class="oi oj gp gr ok ol"><a href="https://github.com/jpsim/SourceKitten" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">jpsim/SourceKitten</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">一个可爱的小框架和命令行工具，用于与SourceKit交互。SourceKitten链接和交流…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.comm</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>