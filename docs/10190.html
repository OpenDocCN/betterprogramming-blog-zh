<html>
<head>
<title>Khipu: Rapid and Sustainable Software Creation in Swift Through Declarative Domain Paradigm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Khipu:通过声明性领域范例在Swift中快速和可持续地创建软件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/khipu-rapid-and-sustainable-software-creation-in-swift-using-engineering-and-science-principles-312a933cce57?source=collection_archive---------7-----------------------#2021-12-09">https://betterprogramming.pub/khipu-rapid-and-sustainable-software-creation-in-swift-using-engineering-and-science-principles-312a933cce57?source=collection_archive---------7-----------------------#2021-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6d6e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">运用工程和科学原理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e6adacf91a9335df989986c42c69294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x1KwQNlgjgyIoE3S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">肖恩·朗斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现实世界的物体受制于“生产问题”:虽然设计这些物体可能是一项有趣且具有挑战性的任务，但真正的挑战在于扩大生产规模以创建成千上万的副本，同时随着时间的推移保持一致的质量。这种生产模式的无处不在已经产生了一种假设，即它通常是正确的。<br/>但软件不是这样:部署或复制代码或字节几乎没有挑战和成本。难点只在<em class="lv">设计</em>、<em class="lv">探索、</em>和<em class="lv">发现</em>。我想展示我们如何通过使用科学工具和思维方式来更快地编写更好的软件。</p><p id="1e4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为什么这是必要的呢？我赞同Alan Kays的观察，他在他的演讲“<a class="ae ky" href="https://www.youtube.com/watch?v=kgmAwnNxdgw&amp;list=PLY5suVncE-vfIoYDOLWggSOk0VtVcF7Tl&amp;index=1" rel="noopener ugc nofollow" target="_blank">生物不能在自己的废物中生存</a>”中提出，最熟练的开发发生在修补、工程、数学和科学重叠的最佳点。但事实是，到目前为止，大多数开发都是在大量修补的基础上进行的，而很少用到工程学，甚至更少用到数学。我也同意Kay的观点，许多软件团队甚至完全忽略了工程和科学。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/0fb6c43db12ea0fa428533ecba1d92bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOwuo99ukc0soWt6BKVcJA.png"/></div></div></figure><p id="b412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们现在所知，我们的工作是探索和学习，让我们看看科学(包括数学)和工程为我们提供的一些工具，因为这些学科都是围绕探索和发现展开的:</p><ul class=""><li id="aea0" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><strong class="lb iu">迭代和反馈</strong>:以小步骤工作来收集反馈，不管我们是否正在取得进展。这是迄今为止最有效的进步方式。设置和评估可测量的目标，为下一次迭代收集反馈和数据。这是学习的基础。</li><li id="7d35" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><strong class="lb iu">增量工作:</strong>不要一步一步地创建复杂的系统，而是要一步一步来。假设，你错了，限制错误决策的半径。设计和编码你能想到的最好的下一步，但是要以这样的方式，即使它是错的，你也能纠正它。</li><li id="cf5c" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><strong class="lb iu">实验性工作</strong>:按照科学的方法将测试设计成微型实验——一次观察对一个变量变化的反应。检验你的预测。通过正确键入来限制变量范围。</li><li id="ee10" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><strong class="lb iu">经验主义</strong>:在工程上，我们的模型不需要完美——只要足够好就行。随着时间的推移，通过了解我们应用程序的更多领域，我们应该能够用新收集的知识轻松地改进我们的模型。</li></ul><p id="75e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于可持续的软件工程(能够在项目的整个生命周期中保持相同的质量和开发速度)，我们的设计目标必须是最大限度的简单，因为正是这种简单允许我们使用科学的工具集，对我们的代码进行实验，并做出有意义的预测。</p><p id="342d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单<em class="lv">或复杂</em>的事物是对一种结构的描述，而简单<em class="lv">和困难</em>和困难<em class="lv">与每个人的独特视角相关，因为它是经验、知识和好奇心的函数。为了进一步澄清<em class="lv">简单</em>和<em class="lv">容易</em>之间的区别，我强烈推荐Rich Hickey的《简单变得容易》，这是每个开发人员必看的一本书。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望实现的简单性由以下因素保证:</p><ul class=""><li id="b7e6" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><strong class="lb iu">一切都是模块</strong>:在这个上下文中，模块是一个最多有一个<code class="fe mn mo mp mq b">Input</code>和一个<code class="fe mn mo mp mq b">Output</code>的数据结构，并使用一个数据结构与系统的其他部分进行通信——即<em class="lv">领域特定语言，</em>简称:<code class="fe mn mo mp mq b">DSL</code>。由于一切都是一个模块，您可以将这个架构描述为一个<em class="lv">可组合的命令解释器</em>，由松散耦合的特性组成，并且具有绝对的信息隐藏，因为只有<code class="fe mn mo mp mq b">Input</code>函数和消息类型贡献于任何表面区域。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/4319088c73b08ae42b5ce30c15a37215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2OjjvQX5HnW-LkYrKZcdQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从机器上看，每个程序都有内在的设计</p></figure><ul class=""><li id="a868" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><strong class="lb iu">单向流动</strong>:所有信息总是单向流动。这与每个应用程序都具有的“内在设计”相一致——至少从机器的角度来看，这意味着UI事件触发应用程序的逻辑来处理新的状态，然后在UI中表现出来。代码越偏离这种内在设计，它就变得越复杂——这是不必要的。如今，作为面向对象的大量类中杂乱无章的命令式结构化代码回避了这样一个事实，即增加复杂性是对已经存在的复杂性的适当反应。通过在系统的中心使用类，这种影响被极大地放大了。它们太强大了，因为它们提供了几种交互方式并且是可变的——然而它们作为模块构建类型实际上是不好的，因为它们不允许真正的黑盒(事实证明，子类化通常需要类签名之外的额外信息),并且没有数据流方向的概念。这些缺点导致了Clutter-OO所依赖的大量模式。</li><li id="5fe6" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><strong class="lb iu">不可变/静态</strong>:所有的模型和状态都是不可变的，每次发生变化都会递归地重新生成，而应用程序的框架是静态的，在应用程序的生命周期内不会改变。这是两个有意的设计选择，因为两者都降低了复杂性:一个根本不能改变的类型也不能无意中改变，并且在运行时应用程序的结构中没有任何东西会突然出现或消失——一整类的错误和崩溃根本不可能。</li><li id="a7f9" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">以一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">声明式</strong>方式</a>(告诉计算机“做什么”，而不是“怎么做”)使用Swift的类型系统，我们几乎100%符合机器的视角。只有少数语句不在这一序列中，但是非常简单，我想把它们描述为“公理”。这仅在声明性代码中是可能的，因为在命令性代码中，编码器和编译器之间共享的知识被减少到语句级别。</li></ul><p id="7a0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把我这里要用的架构叫做“<strong class="lb iu"> <em class="lv"> Khipu </em> </strong>”(之前的项目名称:“Core|UI”)。最初，我着手创建罗伯特·c·马丁的“干净架构”的实现。将它与使用DSL接口的模块和不可变数据类型等想法结合起来，它已经变得独一无二，但是关于Clean Architecture的所有事实对于这个设计仍然是正确的。</p><ul class=""><li id="8638" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe mn mo mp mq b">UseCases</code>通过<code class="fe mn mo mp mq b">Requests</code>和<code class="fe mn mo mp mq b">Responses</code>进行通信</li><li id="d688" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">UseCases</code>只做一件事(或者两件事，如果这两件事是相互补充的，比如打开或关闭某些东西)，提高系统的内聚性。</li><li id="97ec" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">"<code class="fe mn mo mp mq b">Gateways</code>"-与更广阔的世界通信的对象-作为依赖项被传入，并且通常包含相当<a class="ae ky" href="https://gitlab.com/vikingosegundo/brighter-hue/-/blob/master/BrighterHue/Gateways/HueClient.swift" rel="noopener ugc nofollow" target="_blank">常规的代码</a>。</li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="3f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我向大家展示一下，使用Khipu架构实现一个应用程序来控制Phillips Hue智能照明系统意味着什么。科学方法将由</p><ul class=""><li id="2c00" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">遵循科学方法的测试粒度</li><li id="02ed" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">执行路径和状态的可预测性</li><li id="0615" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">仅仅通过几个公理化的陈述就可以改变状态</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/751156923728152308de516af8fc248e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*pXGvKkRm6F9KM547nP1nhg.gif"/></div></figure><p id="d724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您没有hue桥，但想运行代码，您会发现一个测试模拟。</p><p id="bb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Khipu的顶层是<code class="fe mn mo mp mq b">AppDomain</code>，它只是一个接受类型为<code class="fe mn mo mp mq b">Message</code>的参数并将其转发给每个<code class="fe mn mo mp mq b">feature</code>的函数。<br/> A <code class="fe mn mo mp mq b">feature</code>是一个以<code class="fe mn mo mp mq b">output</code>函数为参数的函数，返回的函数是特征的<code class="fe mn mo mp mq b">input</code>。通过保存对这个<code class="fe mn mo mp mq b">input</code>的引用，我们可以在任何给定的时间将<code class="fe mn mo mp mq b">messages</code>转发给它。这种技术被称为“部分应用”,我们将它与一种<code class="fe mn mo mp mq b">Message</code>类型结合起来，这种类型允许我们创建有限数量的值来编码行为——一种理想的模块类型:</p><ul class=""><li id="19f2" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">一个<code class="fe mn mo mp mq b">input</code>，</li><li id="29e7" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">一个<code class="fe mn mo mp mq b">output</code></li><li id="c33e" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">一种模块接口类型，作为少量值(词汇表)的<code class="fe mn mo mp mq b">DSL</code></li></ul><p id="00a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一个都对系统的简单性做出了巨大的贡献。稍后将详细介绍局部应用。</p><p id="06cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下代码的结构，以及信息是如何在其中流动的。</p><p id="3e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的功能由不同的<code class="fe mn mo mp mq b">UseCases</code>组成</p><p id="37db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">照明</strong></p><ul class=""><li id="2c2b" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe mn mo mp mq b">LightLoader</code>:从桥上加载灯光信息</li><li id="8b05" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">LightSwitcher</code>:开关灯</li><li id="0815" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">LightValueSetter</code>:将光线设置为HSB、色温或简单的亮度值。</li><li id="594e" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">Dimmer</code> : in-或按一定百分比降低光线的亮度、饱和度、色调和色温值。</li><li id="2857" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">LightChanger</code>:改变灯光的元信息，如名称。</li></ul><p id="7043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">仪表盘</strong></p><ul class=""><li id="05fd" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe mn mo mp mq b">FavoriteAdder</code>:将灯光作为收藏添加到仪表板。或者移除它。</li><li id="c38b" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">WatchSyncer</code>:将任何选定的收藏夹与apple watch应用程序同步。</li></ul><p id="228b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">测井</strong></p><ul class=""><li id="247a" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe mn mo mp mq b">Logger</code>:会监听某些消息并记录下来。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/8bfb95638ca2daaf5c9dca919efea11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SkOoeVnHhj_ZJDCBfl8Uig.png"/></div></div></figure><ul class=""><li id="3475" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">用户交互生成<code class="fe mn mo mp mq b">Message M</code>，并将其传递给<code class="fe mn mo mp mq b">AppDomain</code></li><li id="874f" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">AppDomain</code>简单的转发给每一个<code class="fe mn mo mp mq b">feature</code></li><li id="37d9" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">如果需要的话，<code class="fe mn mo mp mq b">features</code>将把<code class="fe mn mo mp mq b">M</code>翻译成一个或多个<code class="fe mn mo mp mq b">UseCase</code> <code class="fe mn mo mp mq b">Request</code>并相应地传递它们。这种到<code class="fe mn mo mp mq b">requests</code>和从<code class="fe mn mo mp mq b">responses</code>的转换确保了<em class="lv">关注点的最高分离。</em></li><li id="a9b3" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">一个<code class="fe mn mo mp mq b">UseCase</code>可能会对它的<code class="fe mn mo mp mq b">Feature</code>做出一次或几次同步或异步的响应</li><li id="1915" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">Feature</code>收到一个响应并创建一个新消息<code class="fe mn mo mp mq b">M*</code>，该消息将被传递到应用程序域——循环再次开始。</li><li id="1c97" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在每一步中,<code class="fe mn mo mp mq b">state</code>都被更新，这将触发UI重新构建</li></ul><p id="fec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我假设大多数读者希望这些特性被编码成类，因为对于大多数编码者来说，它们是模块构建的goto类型。但是班级提供了大量的互动。它们允许任何数量的方法，它们是可子类化的和可变的。虽然这些都是模块不需要的东西，但我需要它们能够做的一件事，类做得很差:几十年来，它们一直被宣传为黑盒的完美工具，尽管它们最多提供灰盒，这一点被一个事实所证明，即除了类的签名之外，通常还需要额外的子类化信息。班级辜负了他们的核心承诺。此外，它们实际上无法提供模块所期望的流通——实现这一点需要模式魔法。实际上，我同意伊利亚·苏兹达尔尼茨基的观点，并认为到目前为止，大多数模式只在处理面向对象(和类)的缺点时才是必要的。</p><blockquote class="nb nc nd"><p id="b2c0" class="kz la lv lb b lc ld ju le lf lg jx lh ne lj lk ll nf ln lo lp ng lr ls lt lu im bi translated">没有客观公开的证据表明OOP比简单的过程化编程更好。</p><p id="b307" class="kz la lv lb b lc ld ju le lf lg jx lh ne lj lk ll nf ln lo lp ng lr ls lt lu im bi translated"><em class="it">痛苦的事实是OOP在它唯一想要解决的任务上失败了。理论上看起来不错——我们对动物、狗、人类等有清晰的等级划分。然而，一旦应用程序的复杂性开始增加，它就变得平淡无奇了。它不但没有降低复杂性，反而鼓励混杂的</em> <strong class="lb iu"> <em class="it"> </em> </strong> <em class="it">共享</em> <a class="ae ky" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank"> <em class="it">可变状态</em></a><strong class="lb iu"><em class="it"/></strong><em class="it">，并以其众多的</em> <a class="ae ky" href="https://suzdalnitski.com/oop-design-patterns-bd2c4fb3014c" rel="noopener ugc nofollow" target="_blank"> <em class="it">设计模式</em> </a> <em class="it">引入额外的复杂性。OOP使得常见的开发实践，如重构和测试，变得不必要的困难。</em></p></blockquote><p id="3ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具有许多不同形式的交互和操作的类会导致比需要的更高的复杂性。这将不可避免地导致更快的代码恶化，并将任何团队的开发速度减慢到零。</p><p id="0241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我不是在我的系统中心使用类，而是一种比OOP早几十年的技术，但在OOP中并不常用:<em class="lv">部分应用</em>。</p><p id="995a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部分应用的函数是这样的函数，当被执行时，返回另一个函数，然后该函数可以被写入引用并被随意地反复调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="7154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">createAdder</code>将状态保存在变量<code class="fe mn mo mp mq b">value</code>中，并返回函数，该函数将添加值并返回该值。请注意，我们将以同样的方式处理依赖关系。</p><p id="5fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用局部应用返回一个函数元组，即创建一个<code class="fe mn mo mp mq b">Stack&lt;T&gt;</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="0336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Khipu中，使用部分应用程序的一个<code class="fe mn mo mp mq b">feature</code>可能看起来像</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="81e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到创建函数返回了一个<code class="fe mn mo mp mq b">input</code>函数(第24行)，该函数检查<code class="fe mn mo mp mq b">feature</code>是否是这个<code class="fe mn mo mp mq b">message</code>的接收者，并将这些<code class="fe mn mo mp mq b">messages</code>转发给<code class="fe mn mo mp mq b">execute(command:)</code>，其中模式匹配用于将<code class="fe mn mo mp mq b">requesst</code>发送给适当的<code class="fe mn mo mp mq b">UseCases</code>。<code class="fe mn mo mp mq b">UseCases</code>被赋予一个函数来处理它的响应，并在<code class="fe mn mo mp mq b">process(response:)</code>函数中回调<code class="fe mn mo mp mq b">output</code> (= <code class="fe mn mo mp mq b">AppDomain</code>)。<code class="fe mn mo mp mq b">Store</code>和<code class="fe mn mo mp mq b">LightStack</code>作为依赖项传递。并完成<code class="fe mn mo mp mq b">Gateways</code>在清洁架构中的角色。</p><p id="41e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe mn mo mp mq b">UseCase</code>被类型化符合一个<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/swift-pat-or-generics-f2f01d788de9">协议和相关类型，PAT </a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="de1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里由<code class="fe mn mo mp mq b">Dimmer</code>实现，允许<code class="fe mn mo mp mq b">hue</code>、<code class="fe mn mo mp mq b">saturation</code>、<code class="fe mn mo mp mq b">brightness</code>、&amp;、<code class="fe mn mo mp mq b">colortemp</code>的增减。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="0fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">Dimmer</code> <code class="fe mn mo mp mq b">Requests</code>和<code class="fe mn mo mp mq b">Responses</code>可能长得像</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">读起来像带有时髦标点的英语</p></figure><p id="3c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了了解如何使用<code class="fe mn mo mp mq b">Dimmer</code>，我们来看看我为这个<code class="fe mn mo mp mq b">UseCase</code>编写的测试</p><p id="73ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用<a class="ae ky" href="https://github.com/Quick/Quick" rel="noopener ugc nofollow" target="_blank">快速</a>和<a class="ae ky" href="https://github.com/Quick/Nimble" rel="noopener ugc nofollow" target="_blank">灵活</a>进行测试。如果您从未使用过这些工具，它可能看起来很奇怪，尤其是当我编写非常紧凑的测试代码时。</p><ul class=""><li id="23be" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">规格(=规格)在级联闭包中定义，<code class="fe mn mo mp mq b">contexts</code></li><li id="02fe" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">it/expect</code>对评估测试，测试本质上是由在<code class="fe mn mo mp mq b">it/expect</code>对之前定义的所有<code class="fe mn mo mp mq b">beforeEach</code>闭包组合而成，按升序执行。</li><li id="7115" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在执行每个闭包之后，所有先前的<code class="fe mn mo mp mq b">afterEach</code>闭包都被调用，以降序排列。</li></ul><p id="5032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许测试在级联中被定义，但是每个测试将被单独执行。</p><p id="b30e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe mn mo mp mq b">UseCase</code>只允许通过传递<code class="fe mn mo mp mq b">requests</code>进行交互，所以所有测试的结构都相同:</p><ul class=""><li id="ee51" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">打个<code class="fe mn mo mp mq b">request</code></li><li id="645b" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">倾听<code class="fe mn mo mp mq b">responses</code></li><li id="653f" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">检查，如果<code class="fe mn mo mp mq b">responses</code>是预期的</li></ul><p id="c448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的文件包含16个测试，等于所有可能的<code class="fe mn mo mp mq b">requests</code>、<code class="fe mn mo mp mq b">success</code>和<code class="fe mn mo mp mq b">failure</code>案例的组合——<code class="fe mn mo mp mq b">Dimmer</code>通过它提供的唯一接口<code class="fe mn mo mp mq b">request</code>方法进行了全面测试(这里还隐藏了一个<code class="fe mn mo mp mq b">request</code>函数，以允许创建尽可能类似英语口语的代码)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="614a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经看到了作为部分应用功能的<code class="fe mn mo mp mq b">features</code>的结构，以及它们如何与<code class="fe mn mo mp mq b">UseCases</code>交互。为了允许不同的<code class="fe mn mo mp mq b">features</code>交换信息，它们共享相同的<code class="fe mn mo mp mq b">DSL</code>类型— <code class="fe mn mo mp mq b">Message</code> —并组合成一个<code class="fe mn mo mp mq b">AppDomain</code>，如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="6284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次使用部分应用。<code class="fe mn mo mp mq b">createAppDomain</code>服用</p><ul class=""><li id="5e18" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">一个<code class="fe mn mo mp mq b">store</code>，它跟踪<code class="fe mn mo mp mq b">state</code>，</li><li id="9366" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">receivers</code>，它也能理解<code class="fe mn mo mp mq b">messages</code>，并可用于将<code class="fe mn mo mp mq b">AppDomain</code>与UI挂钩</li><li id="fa6c" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">加载一个工作色调堆栈或一个模拟</li><li id="7d5c" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">而<code class="fe mn mo mp mq b">roothandler</code>作为回调使用。我们将会看到<code class="fe mn mo mp mq b">AppDomain</code>通过它自己</li></ul><p id="623e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">Store</code>和<code class="fe mn mo mp mq b">LightStack</code>是<code class="fe mn mo mp mq b">gateways</code>，可以包含常规代码，允许我们连接到预先存在的代码和库。</p><p id="9c60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后</p><ul class=""><li id="782f" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">创建三个特征:<code class="fe mn mo mp mq b">Lighting</code>、<code class="fe mn mo mp mq b">Dashboard</code>和<code class="fe mn mo mp mq b">Logging</code></li><li id="ee0d" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">并且返回一个<code class="fe mn mo mp mq b">Input</code>函数，该函数将只迭代整个<code class="fe mn mo mp mq b">receivers</code>和<code class="fe mn mo mp mq b">features</code>，转发每个接收到的消息。</li></ul><p id="cc22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe mn mo mp mq b">AppDomain</code>的全部代码:它接收<code class="fe mn mo mp mq b">messages</code>并将它们转发给任何<code class="fe mn mo mp mq b">receiver</code>(即UI)和每个<code class="fe mn mo mp mq b">feature</code>。</p><p id="bf5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在的<code class="fe mn mo mp mq b">Message</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="6984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及一些可以用这个枚举来表达的例子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="9c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些可以作为英文命令读给<code class="fe mn mo mp mq b">feature</code>。试试看:</p><blockquote class="nb nc nd"><p id="cbb4" class="kz la lv lb b lc ld ju le lf lg jx lh ne lj lk ll nf ln lo lp ng lr ls lt lu im bi translated">“照明:加载灯光”<br/>“照明:打开灯光”<br/>“照明:关闭灯光”<br/>“照明:在灯光上应用值HSB(0.5，0.5，0.5)”<br/>“照明:在灯光上增加10点亮度”<br/>……你明白了吗</p></blockquote><p id="c0e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据上下文<em class="lv">照明</em>要么被寻址，要么向更早的命令报告，如:</p><blockquote class="nb nc nd"><p id="104a" class="kz la lv lb b lc ld ju le lf lg jx lh ne lj lk ll nf ln lo lp ng lr ls lt lu im bi translated">灯光:“开灯成功”</p></blockquote><p id="5d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经看到了<code class="fe mn mo mp mq b">AppDomain</code>及其<code class="fe mn mo mp mq b">features</code>的结构，让我们把注意力转向不可变的模型和状态，以及我们如何存储它。</p><p id="8ce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确信你从未见过这样的模型结构，但是如果你仔细观察，你会发现它只是我们以前见过的一个想法的另一个化身:行为被编码在一个<code class="fe mn mo mp mq b">Light.Change</code> DSL中，非常类似于特征连接<code class="fe mn mo mp mq b">Message</code>类型，而<code class="fe mn mo mp mq b">Request</code>和<code class="fe mn mo mp mq b">Response</code>类型在<code class="fe mn mo mp mq b">UseCases</code>中可以看到</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="b949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为没有一个属性是var属性，所以这个<code class="fe mn mo mp mq b">Light</code>模型是不可变的。通过递归应用alter函数来反映变化，每次返回一个新的<code class="fe mn mo mp mq b">Light</code>值。<code class="fe mn mo mp mq b">Light.Change</code>枚举允许10种不同的命令:</p><ul class=""><li id="a078" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.renaming(.it(to:"new Name"))</code></li><li id="59ef" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.turning(.it(.on))</code></li><li id="5409" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.turning(.it(.off))</code></li><li id="9fb8" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.setting(.brightness(to:newValue))</code></li><li id="da51" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.setting(.saturation(to:newValue))</code></li><li id="c738" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.setting(.hue(to:newValue))</code></li><li id="4f8c" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.setting(.temperature(to:newValue))</code></li><li id="59ea" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.toggling(.display(to:.slider))</code></li><li id="0635" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.toggling(.display(to:.scrubbing))</code></li><li id="b528" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">.adding(.mode(to:newMode))</code></li></ul><p id="b478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是我们可以应用的更改，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="12d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">Light</code>类型规格(又名测试):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="a7a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe mn mo mp mq b">Light</code>是完全不可变的，<code class="fe mn mo mp mq b">beforeEach</code>和<code class="fe mn mo mp mq b">afterEach</code>是不需要的，所有的测试实际上是一次实例化的。这个大约50行代码的规范包含30个测试。</p><p id="4e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">state</code>的管理非常类似，<code class="fe mn mo mp mq b">AppState.Change</code>值被递归应用，并且在每一步中生成一个新的<code class="fe mn mo mp mq b">state</code>值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="5248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">AppState</code>和<code class="fe mn mo mp mq b">Light</code>之类的型号在结构上完全相同，所以我不会展示<code class="fe mn mo mp mq b"><a class="ae ky" href="https://gitlab.com/vikingosegundo/brighter-hue/-/blob/master/BrighterHueTests/State%20Specs/AppStateSpec.swift" rel="noopener ugc nofollow" target="_blank">AppState’s</a></code>和<a class="ae ky" href="https://gitlab.com/vikingosegundo/brighter-hue/-/blob/master/BrighterHueTests/State%20Specs/AppStateSpec.swift" rel="noopener ugc nofollow" target="_blank">的规格</a>。</p><p id="b7ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe mn mo mp mq b">AppState</code>是不可变的，我们必须有一个地方来保存状态的当前版本——T10。</p><p id="a390" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe mn mo mp mq b">store</code>实际上是使用一个类的很好的候选对象(完成它！)，但我想再次重用部分应用程序方法，这次让创建函数返回一个函数元组，如<code class="fe mn mo mp mq b">Stack&lt;T&gt;</code>示例所示。这个元组将为我的需求量身定制，而一个类提供了我不需要的复杂性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="f239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">Store</code>是一个元组，其中</p><ul class=""><li id="553a" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe mn mo mp mq b">store.state()</code>将返回当前状态，</li><li id="2b73" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">store.change(…)</code>将在当前版本上应用一个更改值，产生一个新版本</li><li id="11e1" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">store.reset()</code>删除所有数据并用默认数据重置状态。</li><li id="9bca" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe mn mo mp mq b">store.updated({…})</code>采用一个回调函数，将为每个新的状态版本调用，实现一个简单的通知模式</li></ul><p id="cbb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实现这些要求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="e379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想指出，第12、13和14行中的赋值是整个应用程序中唯一使用可变性的地方。由于这些变量是在本地私有函数作用域中定义的，所以它们无法从应用程序的其他部分访问，只能通过传入<code class="fe mn mo mp mq b">AppState.Change</code>值来更改——相当可靠。</p><p id="afe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">Store</code>用法举例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="5aad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经看到了如何设置结构，模型在这个结构中是如何处理的，以及如何保持状态，那么只剩下一个任务要做:连接UI。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="dfa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe mn mo mp mq b">store</code>被创建并传递到一个新的<code class="fe mn mo mp mq b">viewstate</code>中，该新的<code class="fe mn mo mp mq b">viewstate</code>连接到swiftui并将自己注册为<code class="fe mn mo mp mq b">store</code>和appDomain的观察者，appDomain将传递它以便可以在<code class="fe mn mo mp mq b">UseCases</code>中使用它。</p><p id="6bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的视图都通过一个<code class="fe mn mo mp mq b">roothandler</code>，一个<code class="fe mn mo mp mq b">input</code>函数，实际上是<code class="fe mn mo mp mq b">AppDomain</code>。对于任何用户交互，类似于</p><p id="841e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行<code class="fe mn mo mp mq b">rootHandler( .lighting(.turn(light,onOrOff)) )</code>或<code class="fe mn mo mp mq b">rootHandler( .lighting(.increase(value,by:inc,on:light)) )</code>。关于完整的SwiftUI代码，请参考<a class="ae ky" href="https://gitlab.com/vikingosegundo/brighter-hue/-/tree/master/BrighterUI" rel="noopener ugc nofollow" target="_blank">库。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="158f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于UIKit，我建议让<code class="fe mn mo mp mq b">viewState</code>广播一个<code class="fe mn mo mp mq b">Notification</code>，让一个基本视图控制器监听它并从中读取最新状态。</p><p id="5d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经看到了如何连接UI，让我们讨论一下为什么这个架构支持代码创建的科学方法</p><ul class=""><li id="ad8d" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><strong class="lb iu">作为实验的测试</strong>:我在这里展示的测试遵循了科学的方法——在任何给定的时间改变一个变量，然后观察结果。测试相当容易，不可变的模型和状态很容易被完全测试。<code class="fe mn mo mp mq b">usecases</code>和<code class="fe mn mo mp mq b">features</code>通常会包含一些<code class="fe mn mo mp mq b">default</code>case或<code class="fe mn mo mp mq b">error</code>case，这些case实际上在语义上无法执行，但在语法上是必需的。因此，实现98%的代码覆盖率应该是容易实现的。</li><li id="b13d" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">所有的状态改变动作都会产生一个代码执行路径，其中所有的路径都要经过<strong class="lb iu">几个“公理”语句</strong>。如果您查看模型或状态上的alter方法，您会注意到，左边的case声明准确地描述了右边实现的内容；<br/> <code class="fe mn mo mp mq b">.renaming(.it(to:<em class="lv">newname</em> ))</code>产生<code class="fe mn mo mp mq b">Light(id, <em class="lv">newname</em>, isOn, brightness, saturation, hue, ct, display, modes, selectedMode)</code>，旧值用于创建新的灯光，新名称覆盖任何先前的名称。<br/> <code class="fe mn mo mp mq b">.by(.adding (.light(<em class="lv">light</em>)))</code>导致<code class="fe mn mo mp mq b">AppState(sort(lights + [<em class="lv">light</em>]), rooms, favorites)</code>。它们如此简单，其正确性很容易证明，就像数学中的公理一样。<br/>这些公理化的陈述可以组合起来，就像我们在<code class="fe mn mo mp mq b">newLight</code>函数中看到的那样。<br/>由于所有状态改变动作都将通过这些语句中的一个或几个来路由，因此测试也是如此。最后:在撰写本文时，175个单元测试中只有不到20个是公理化的。</li><li id="f8da" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><strong class="lb iu">增量工作</strong>:这里显示的风格允许增量设计和发现。DSL可以逐渐改变，复杂的行为是通过递归地应用公理化的改变而逐渐产生的。</li><li id="0d30" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><strong class="lb iu">临时工作</strong>:通过将代码组织在由DSL类型(通常是嵌套枚举)连接的模块中，可以推断和测试所有可能的输入类型值。预测可以作为单元测试来制定和测试。</li><li id="0271" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">通过应用和商店的单向流动允许<strong class="lb iu">在任何时刻系统状态</strong>的可预测性。</li></ul><p id="52b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">科学和工程中另一件重要的事情是记录你的工作。通过将行为编码为DSL值，我们可以将它们作为模块的文档，这里是<code class="fe mn mo mp mq b">Lighting feature</code>。使用代码来记录代码有一个好处，如果文档过时了，编译器会检测到——代码不会编译。文档也可以被测试，它的内容可以作为其他测试的输入值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mm l"/></div></figure><p id="fbba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<em class="lv">是面向对象的</em>吗？还是<em class="lv">功能性</em>？虽然它是作为一个真正的面向对象的干净架构的实现开始的，但是它分享了通常从FP中得知的思想，比如不可变状态，但是它也使用了面向对象的概念来隐藏状态和依赖注入。</p><p id="c686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我相信这是一个新的范例。</p><p id="d74a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个上下文中，一个范例是一个用于创建不同架构的系统。一个范例是由它引入到代码中的约束来定义的，而代码又是作为编码者的指导线。</p><ul class=""><li id="2e88" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">结构化编程引入了执行路径需要明确定义的概念(“goto被认为是有害的”)</li><li id="9f4b" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">FP和OO都试图解决同一个问题:可变的全局状态——FP通过移除可变性，OO通过隐藏可变状态</li></ul><p id="fc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里使用的约束条件是:</p><ul class=""><li id="abdf" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">系统中心的模块构建类型是部分应用功能</li><li id="5b66" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">行为在基于类型的DSL(通常是嵌套枚举)中编码，通过模式匹配解码</li><li id="e184" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">可变性仅限于一个或很少几个地方，特别是在局部函数范围内</li></ul><p id="fcce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个系统是由那些约束定义的，我认为这是一个范例，<strong class="lb iu">声明域范例</strong>。</p><p id="9462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Khipu只是应用这一范例的一个架构。事实上，你可以通过跳过<code class="fe mn mo mp mq b">feature</code>和<code class="fe mn mo mp mq b">UseCase</code>层，直接写入商店来简化琐碎的应用程序。<br/>我在文章“<a class="ae ky" href="https://medium.com/codex/declarative-diplomacy-in-swift-c32a07101c9f" rel="noopener">声明式Swift中的外交</a>”和“<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-a-swift-snake-game-using-declarative-domain-paradigm-7eb34a139017">使用声明式域范例</a>在Swift中构建一个贪吃蛇游戏”中展示了这一点。<br/>Swift语言的这个子集允许图灵完全编码，这一点通过<a class="ae ky" href="https://medium.com/devgauge/declarative-immutable-and-brain-sized-swift-did-i-discover-a-new-paradigm-1514c1614ea8" rel="noopener">实现图灵机</a>得到了证明。</p><p id="f5b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后是本文中显示的<a class="ae ky" href="https://gitlab.com/vikingosegundo/brighter-hue" rel="noopener ugc nofollow" target="_blank">代码</a>。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="db10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅通过使用两个想法——部分应用程序和行为编码的DSL类型——我们已经创建了一个基于模块的声明性架构，它具有非常小的复杂性。使用相同的DSL方法允许我们的模型和状态完全不可变，进一步降低了复杂性。由于系统的唯一接口是<code class="fe mn mo mp mq b">AppDomain</code>函数，UI——或者任何其他客户端，比如测试——尽可能地松散耦合。<br/>模块DSL可以被设计成类似于口语，这可以导致公理陈述，其中匹配大小写值的模式匹配右侧编码的变化。这些公理化的陈述可以递归地组合，允许新的行为出现。这类似于数学，更复杂的知识来自更简单的知识，最终来自公理。这种简单性使我们能够在工作中引入更多的科学严谨性。</p><p id="586d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是一旦你尝试一下，你会注意到最重要的事情:编写这样的软件很快，这并不奇怪，因为简单导致效率。但那是一种我无法描述的体验——你必须自己去感受。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="f26a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于软件开发中的科学和工程的更一般的观点，我强烈推荐戴夫·法利的视频:“成为一名软件工程师需要什么”。<br/>不包括代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div></div>    
</body>
</html>