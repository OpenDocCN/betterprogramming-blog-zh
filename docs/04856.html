<html>
<head>
<title>How to Upload Files to Firebase Cloud Storage With React and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React和Node.js上传文件到Firebase云存储</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-upload-files-to-firebase-cloud-storage-with-react-and-node-js-e87d80aeded1?source=collection_archive---------2-----------------------#2020-05-17">https://betterprogramming.pub/how-to-upload-files-to-firebase-cloud-storage-with-react-and-node-js-e87d80aeded1?source=collection_archive---------2-----------------------#2020-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3307" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的应用程序构建文件上传程序的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67362306eb22c84ccebea6a03a637df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6SxnrwOMd_tt1hhPt9C2Ag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">背景照片由<a class="ae ky" href="https://unsplash.com/@sapegin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Artem Sapegin </a>在<a class="ae ky" href="https://unsplash.com/search/photos/react?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="39b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我曾经参与过几个需要实现文件上传程序的项目，但总是发现这并不容易。</p><p id="e295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提交文件格式会引出不同的问题:“文件到底是什么？我们通过电线发送的是什么？我们如何处理这样一种格式来存储它并提供给用户？”</p><p id="509a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近使用Firebase云存储作为文件存储空间构建了一个，我想我会喜欢一篇带我了解它如何工作以及如何正确设置它的帖子。</p><p id="0587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，在这里，我希望它能回答你的问题，如果你需要下一个项目的样板文件，我会提供整个项目的回购。</p><p id="4f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先决条件:这篇文章假设你已经熟悉用Express构建Node.js API和用React构建前端。这里我们只关注文件上传部分。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f66" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置Firebase云存储</h1><p id="4cc7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，您需要一个Firebase帐户，其中有一个活动项目和一个打开的存储桶:</p><ol class=""><li id="d46c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">连接或创建一个<a class="ae ky" href="https://firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase </a>账户。</li><li id="1af7" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">创建新项目。</li><li id="9eed" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">为您的项目命名。</li><li id="d7ef" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">激活或不激活谷歌分析，由你决定。</li><li id="3eb2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在左侧菜单中，点击“存储”，然后点击“开始”。</li><li id="bdb4" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">Rules:打开一个模式，显示您的bucket的默认读写访问规则。我们希望保持对写访问的身份验证。关于读取权限，这取决于您的需求。在这里，我们将更新规则，使我们的图像从他们的公共网址公开可读。</li></ol><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1c62" class="ns md it no b gy nt nu l nv nw">rules_version = '2';<br/>service firebase.storage {<br/>  match /b/{bucket}/o {<br/>    match /{allPaths=**} {<br/>      allow read;<br/>      allow write: if request.auth != null;<br/>    }<br/>  }<br/>}</span></pre><p id="b603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文档中关于存储安全规则<a class="ae ky" href="https://firebase.google.com/docs/storage/security/start?authuser=0#sample-rules" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><p id="3757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7.地点:明智地选择，你不能改变这一点。我住在巴黎，所以我选择了位于德国法兰克福的<code class="fe nx ny nz no b">europe-west3</code>。您可以在<a class="ae ky" href="https://firebase.google.com/docs/projects/locations?authuser=0" rel="noopener ugc nofollow" target="_blank"> this Firebase页面</a>上找到完整的位置列表以及关于为您的项目选择数据位置的更多信息。</p><p id="12c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经有了可以使用的默认存储桶。在<a class="ae ky" href="https://firebase.google.com/pricing" rel="noopener ugc nofollow" target="_blank"> Firebase的免费层</a>中，你可以拥有一个，最多存储5 GB。如果你需要多个桶和更多的空间，你需要相应地升级你的计划。</p><p id="9ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了存储桶，我们需要生成一个私钥，我们的API将使用它安全地连接到我们的桶。</p><ol class=""><li id="b09f" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">在左侧菜单中，单击顶部的设置轮。</li><li id="2fbb" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">选择“服务帐户”选项卡。</li><li id="1f78" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在页面底部，单击“生成新的私钥”按钮。这将生成一个JSON文件，其中包含您的Firebase帐户凭证。</li></ol><p id="7ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会得到一个警告，说这个私钥应该保密并放在一个安全的地方，所以要确保无论你把这个文件放在哪里，你都要<em class="oa">而不是</em>把它提交给你的远程repo。</p><p id="77f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您将在下一步看到的，我们将为我们的服务器创建一个<code class="fe nx ny nz no b">api/</code>文件夹。我将把这个文件存储在这个文件夹中的一个<code class="fe nx ny nz no b">services/</code>文件夹中。然后我会将这个文件夹中的所有JSON文件添加到我的<code class="fe nx ny nz no b">.gitignore</code>中:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="ac28" class="ns md it no b gy nt nu l nv nw">/api/services/*.json</span></pre><p id="8120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经准备好下一步，构建上传API。</p><p id="ff2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于安全原因，我们希望从我们的服务器处理经过身份验证的调用，而不是从浏览器处理，因为在浏览器中，包含敏感凭据的环境变量更容易被访问。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2707" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">API: Node.js + Express.js + Multer</h1><p id="716f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了给你提供一个全功能的repo，我将API包含在同一个项目文件夹中。</p><p id="550c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这并不理想，因为把所有的鸡蛋放在同一个篮子里从来都不是。因此，请记住，在现实生活中，您要么使用无服务器功能，要么让上传API与后端的其余部分一起运行。</p><h2 id="9cb6" class="ns md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">设置Express服务器</h2><p id="606d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">1.我们安装必要的依赖项:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="377f" class="ns md it no b gy nt nu l nv nw">$ npm i express body-parser cors dotenv</span></pre><p id="498f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.在项目的根目录下，我们创建了一个<code class="fe nx ny nz no b">api/</code>文件夹，并在其中创建了一个<code class="fe nx ny nz no b">index.js</code>文件，我们在其中设置了Express服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="52e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们希望我们的前端和API同时运行，同时仍然有一个命令要运行。为此，在我们的<code class="fe nx ny nz no b">package.json</code>文件中，我们这样更新我们的<code class="fe nx ny nz no b">start</code>脚本:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="6042" class="ns md it no b gy nt nu l nv nw">"scripts": {     <br/>    "start": "(cd api &amp;&amp; node index.js) &amp; react-scripts start",     <br/>    ... <br/>}</span></pre><p id="a4dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，如果你想了解更多关于如何同时运行多个命令的信息，我发现这篇文章很有用。</p><h2 id="f737" class="ns md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">添加上传端点</h2><p id="d0c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们创建一个能够接收POST请求的<code class="fe nx ny nz no b">/api/upload</code>端点。我们将使用<a class="ae ky" href="https://www.npmjs.com/package/multer" rel="noopener ugc nofollow" target="_blank"> Multer </a>，这是一个Node.js中间件，允许我们处理<code class="fe nx ny nz no b">multipart/form-data</code>:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="bbcb" class="ns md it no b gy nt nu l nv nw">$ npm i multer</span></pre><p id="0dbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Multer向包含上传文件的<code class="fe nx ny nz no b">request</code>对象添加一个<code class="fe nx ny nz no b">file</code>(如果发送多个文件，则为<code class="fe nx ny nz no b">files</code>)。它还向<code class="fe nx ny nz no b">request</code>添加了一个<code class="fe nx ny nz no b">body</code>对象，该对象包含您想要添加到请求中的任何其他文本字段。</p><p id="aca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，感谢Multer，我们将能够通过<code class="fe nx ny nz no b">req.file</code>访问我们上传的文件，并从<code class="fe nx ny nz no b">req.body</code>访问我们剩余的数据。</p><p id="8db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nx ny nz no b">index.js</code>中，我们创建了一个Multer实例:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b506" class="ns md it no b gy nt nu l nv nw">const multer = require('multer');</span></pre><p id="4702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将我们的文件发送到Firebase，我们需要用它创建一个<code class="fe nx ny nz no b">Buffer</code>对象。我们将使用Multer提供的内存存储引擎:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用内存存储时，我们的<code class="fe nx ny nz no b">req.file</code>将包含一个名为<code class="fe nx ny nz no b">buffer</code>的字段，该字段包含整个文件。</p><p id="8805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是该端点的起始代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b6da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经成功了一半。现在剩下的就是连接到Firebase云存储并处理我们的文件，因为服务需要正确地上传它。</p><h2 id="ab9c" class="ns md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">连接到Firebase云存储</h2><ol class=""><li id="aa82" class="mz na it lb b lc mu lf mv li oo lm op lq oq lu ne nf ng nh bi translated">首先，我们需要添加<code class="fe nx ny nz no b">@google-cloud/storage</code>依赖项来连接到Firebase云存储:</li></ol><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="705d" class="ns md it no b gy nt nu l nv nw">$ npm i @google-cloud/storage</span></pre><p id="433b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.接下来，我们需要三个环境变量。这就是我们一开始安装的<code class="fe nx ny nz no b"><a class="ae ky" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank">dotenv</a></code>模块发挥作用的地方。它将环境变量从<code class="fe nx ny nz no b">.env</code>文件加载到<code class="fe nx ny nz no b">process.env</code>。</p><p id="c80a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在项目的根目录下创建一个<code class="fe nx ny nz no b">.env</code>文件，并在其中添加两个环境变量:</p><ul class=""><li id="574b" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu or nf ng nh bi translated">这是您的Firebase项目ID。你可以在你的Firebase账号&gt;设置&gt;通用设置里找到。</li><li id="cb8f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu or nf ng nh bi translated"><code class="fe nx ny nz no b">GCLOUD_APPLICATION_CREDENTIALS</code>:还记得当初你存放在某处的私钥吗？这是我们需要它的地方。您需要在这里指明您的私钥JSON文件的路径。因此，它可能类似于<code class="fe nx ny nz no b">/api/services/myprivatekey.json</code>。</li><li id="e7a8" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu or nf ng nh bi translated"><code class="fe nx ny nz no b">GCLOUD_STORAGE_BUCKET_URL</code>:最后，您需要您的存储桶的URL，即<code class="fe nx ny nz no b">[YOUR_GCLOUD_PROJECT_ID].appspot.com</code>。如果你不确定，你可以在你的Firebase账户&gt;存储&gt;文件标签(这是默认的)&gt;中看到，就在左侧存储文件列表的上方，你有一个类似<code class="fe nx ny nz no b">gs://you-project-id.appspot.com</code>的网址。这就是了。</li></ul><p id="e82f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，确保您将新的<code class="fe nx ny nz no b">.env</code>文件添加到您的<code class="fe nx ny nz no b">.gitignore</code>中。</p><p id="e3d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.现在我们可以用我们的Firebase凭证启动一个<code class="fe nx ny nz no b">Storage</code>实例:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="61ee" class="ns md it no b gy nt nu l nv nw">const { Storage } = require('@google-cloud/storage');</span><span id="78b0" class="ns md it no b gy os nu l nv nw">const storage = new Storage({<br/>    projectId: process.env.GCLOUD_PROJECT_ID,<br/>    keyFilename: process.env.GCLOUD_APPLICATION_CREDENTIALS,<br/>});</span></pre><p id="b9ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.并创建一个<code class="fe nx ny nz no b">bucket</code>，它是对象(文件)的容器，我们将它与我们的Firebase存储桶相关联。我们将在下面的端点中使用它来处理我们的文件。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="fd2b" class="ns md it no b gy nt nu l nv nw">const bucket =<br/>    storage.bucket(process.env.GCLOUD_STORAGE_BUCKET_URL);</span></pre><p id="e109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.接下来，我们继续进入我们的<code class="fe nx ny nz no b">app.post('api/upload')</code>端点。检查后，我们确实有一个现有的<code class="fe nx ny nz no b">req.file</code>。如果您记录它，您会看到它包含以下内容:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2b1b" class="ns md it no b gy nt nu l nv nw">{<br/>  fieldname: 'image',<br/>  originalname: 'Medium Post Cover 3.png',<br/>  encoding: '7bit',<br/>  mimetype: 'image/png',<br/>  buffer: &lt;Buffer 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 00 00 0b 22 00 00 07 6c 08 06 00 00 00 e9 93 d9 14 00 00 00 04 67 41 4d 41 00 00 b1 8f 0b fc 61 05 00 ... 1834232 more bytes&gt;,<br/>  size: 1834282<br/>}</span></pre><p id="827a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Firebase使用的是<code class="fe nx ny nz no b">Blobs</code>(二进制大对象)，这是一种可以在数据库中存储二进制数据的数据类型。</p><p id="65dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们用<code class="fe nx ny nz no b">file()</code>方法在我们的桶中创建新的blob，将我们的文件名作为引用传递给它:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="24b8" class="ns md it no b gy nt nu l nv nw">const blob = bucket.file(req.file.originalname);</span></pre><p id="75bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们启动一个<em class="oa">可写流</em>。FreeCodeCamp写了一个关于Node.js streams的很棒的指南，其中他们回答了你可能会有的关于他们的所有问题(我有很多)。</p><p id="b355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oa">流</em>是一组数据(比如数组或字符串)的集合，这些数据可能不会一下子全部可用。它们允许我们处理大量的数据(如图像或视频)，我们需要一次处理一大块。</p><p id="9af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<em class="oa">可写的流</em>是一种抽象的流，数据可以被写到<em class="oa">目的地</em>，所以基本上，当我们想要写数据时，我们使用一个可写的流，这就是我们在这里想要的。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="a6f6" class="ns md it no b gy nt nu l nv nw">const blobStream = blob.createWriteStream(<!-- -->{<br/>    metadata: {<br/>        contentType: req.file.mimetype,<br/>    },<br/>}<!-- -->);</span></pre><p id="ba2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重要提示</strong>:您需要将文件mimetype作为元数据传递给<code class="fe nx ny nz no b">createWriteStream()</code>，否则您的文件将不会以正确的格式存储，并且不可读。</p><p id="6037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回一个<code class="fe nx ny nz no b">WriteStream</code>对象，我们可以在其上检查事件。在<code class="fe nx ny nz no b">finish</code>事件中，我们组装新存储文件的公共URL，并在响应中发送给用户，让用户要么在前面显示文件，要么在数据库中存储位置字符串。</p><p id="553a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们在<code class="fe nx ny nz no b">blob.name</code>上使用了<code class="fe nx ny nz no b">encodeURI</code>来涵盖文件名包含空格或其他需要编码的字符的情况。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="a045" class="ns md it no b gy nt nu l nv nw"><strong class="no iu">// If there's an error</strong><br/>blobStream.on('error', (err) =&gt; next(err));</span><span id="9217" class="ns md it no b gy os nu l nv nw"><strong class="no iu">// If all is good and done<br/></strong>blobStream.on('finish', () =&gt; {</span><span id="ea57" class="ns md it no b gy os nu l nv nw"><strong class="no iu">    // Assemble the file public URL</strong><em class="oa"><br/>    </em>const publicUrl =<br/>`https://firebasestorage.googleapis.com/v0/b/${bucket.name}/o/${encodeURI(blob.name)}?alt=media`;</span><span id="b34a" class="ns md it no b gy os nu l nv nw"><em class="oa">    </em><strong class="no iu">// Return the file name and its public URL<br/>    // for you to store in your own database<br/>    </strong>res.status(200).send({ <br/>        fileName: req.file.originalname,<br/>        fileLocation: publicUrl<br/>    });<br/>});</span><span id="1bfe" class="ns md it no b gy os nu l nv nw"><strong class="no iu">// When there is no more data to be consumed from the stream the end event gets emitted</strong><br/>blobStream.end(req.file.buffer);</span></pre><p id="8eb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做到了！我们的API已经可以使用了。以下是完整的<code class="fe nx ny nz no b">index.js</code>文件的要点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">index.js |文件上传API端点处理上传到Firebase云存储</p></figure><p id="2847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的只是一个简单的前端，带有一个处理文件输入的表单。为此，我们将使用React。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9004" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">前端的上传处理器</h1><p id="f8b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为我们在这里假设您知道如何设置React应用程序和使用钩子，所以我将只关注调用我们的上传端点的表单提交处理程序。但我在这篇文章的结尾提供了完整的项目回购。</p><p id="83a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个<code class="fe nx ny nz no b">FormData</code>对象:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="37ae" class="ns md it no b gy nt nu l nv nw">let fileData = new FormData();</span></pre><p id="3b6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在我们的<code class="fe nx ny nz no b">FormData</code>对象上设置了<code class="fe nx ny nz no b">image</code>字段，并添加了选中的文件及其名称。这里有两点需要注意:</p><p id="d61b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，字段名称必须与我们在API中期望的名称相同:<code class="fe nx ny nz no b">app.post('/api/upload', uploader.single(&lt;FIELD_NAME&gt;), …)</code>。</p><p id="41c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，请注意，我们使用<code class="fe nx ny nz no b">Date.now()</code>将当前时间戳添加到文件名中。这可以确保文件在存储中具有唯一的名称，从而防止以后被覆盖。</p><p id="6272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一方面，这允许用户多次上传同一个文件，这可能是你想要的，也可能是你不想要的。另一方面，如果您需要设置auth来读取图像，它可以防止潜在的问题。</p><p id="d904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，Firebase会为每个文件生成一个访问令牌，如果用户上传相同的图片，它会替换之前的图片并更新访问令牌，这将导致使用之前令牌的图像在某个地方损坏。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="dc36" class="ns md it no b gy nt nu l nv nw">fileData.set('image', selectedFile, `${Date.now()}-${selectedFile.name}`<br/>);</span></pre><p id="719f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我使用<code class="fe nx ny nz no b">axios</code>进行API调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将所有这些都放在一个尝试/捕捉中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是它的全部！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa51" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="778b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以在完整的项目报告中通过加载和错误处理来检查完整的React组件(我保持它的简单，只有一个主要的<code class="fe nx ny nz no b">App</code>组件):</p><div class="ot ou gp gr ov ow"><a href="https://github.com/clairechabas/file-uploader-firebase-storage-react-node" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">claire chabas/文件-上传程序-firebase-存储-反应-节点</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">要使用这个文件上传器，你需要:设置一个Firebase帐户&gt;激活云存储&gt;生成一个…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><p id="19f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章是有帮助的。如果你有任何问题或改进建议，我很乐意在评论中看到。</p><p id="906a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快乐编码。</p></div></div>    
</body>
</html>