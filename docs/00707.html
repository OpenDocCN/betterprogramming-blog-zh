<html>
<head>
<title>Eight Practices in React That Will Crash Your App in the Future</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的八种做法会让你的应用程序在未来崩溃</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-practices-in-react-that-will-crash-your-app-in-the-future-e4c0e4529d26?source=collection_archive---------0-----------------------#2019-07-03">https://betterprogramming.pub/8-practices-in-react-that-will-crash-your-app-in-the-future-e4c0e4529d26?source=collection_archive---------0-----------------------#2019-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="aab0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">我在生产部门的工作经历</h2><div class=""/><div class=""><h2 id="2592" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">照顾好你的用户，他们也会照顾好你</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f1b0cd1f7dc68fd795fd0dace2f936de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xbye8HrAmogAosq0mkTNhA.jpeg"/></div></div></figure><p id="1a7d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">编辑</strong>:本帖的第<strong class="lf jd"> <em class="lz"> #2 </em> </strong>点已被修改，以一个读者的角度来看更容易理解(和<strong class="lf jd">更恐怖</strong>)。感谢dev.to上的用户发邮件给我，告诉我之前的困惑！</p><p id="5bcf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们很多人都爱上了React库，原因有几个。创建复杂的交互式用户界面是非常容易的。最大的特点是能够在不破坏其他组件的情况下一个接一个地组装组件。</p><p id="db66" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">令人惊讶的是，即使是社交媒体巨头，如<a class="ae ma" href="https://www.facebook.com/" rel="noopener ugc nofollow" target="_blank">脸书</a>、<a class="ae ma" href="https://www.instagram.com/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>和<a class="ae ma" href="https://www.pinterest.com/" rel="noopener ugc nofollow" target="_blank"> Pinterest </a>也大量使用了<a class="ae ma" href="https://brainhub.eu/blog/10-famous-apps-using-reactjs-nowadays/" rel="noopener ugc nofollow" target="_blank">它们</a>，同时用巨大的API如<a class="ae ma" href="https://cloud.google.com/maps-platform/?&amp;sign=0" rel="noopener ugc nofollow" target="_blank">谷歌地图</a>创造了无缝的用户体验。</p><p id="7338" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您目前正在使用React构建一个应用程序，或者正在考虑将其用于即将到来的项目，那么本教程就是为您准备的。我希望通过展示一些你应该三思而后行的代码实现，来帮助<em class="lz">你</em>踏上创建伟大的react应用程序的征程。</p><p id="703e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">话不多说，React中有八种做法会让你的应用程序在未来崩溃:</p><h2 id="235b" class="mb mc it bd md me mf dn mg mh mi dp mj lm mk ml mm lq mn mo mp lu mq mr ms iz bi translated">1.在null上声明默认参数</h2><p id="7ad8" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">我在之前的一篇文章中提到过这个话题，但是这是一个令人毛骨悚然的<em class="lz">陷阱</em>，可以在一个阴沉的星期五愚弄一个粗心的开发者！毕竟，应用程序崩溃不是一个笑话——如果处理不当，任何类型的崩溃都可能导致金钱损失。</p><p id="ef65" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我曾经因为花费过多的时间调试类似的东西而感到内疚:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="099d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我们的应用程序组件中，如果日期最终是<code class="fe na nb nc nd b">falsey</code>，它将被初始化为null。</p><p id="0548" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你和我一样，直觉告诉我们当<code class="fe na nb nc nd b">items</code>是一个<code class="fe na nb nc nd b">falsey</code>值时，默认情况下应该初始化为一个空数组。但是当<code class="fe na nb nc nd b">dates</code>为<code class="fe na nb nc nd b">falsey </code>时，我们的应用会崩溃，因为<code class="fe na nb nc nd b">items </code>为空。<em class="lz">什么</em>？</p><p id="b355" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果没有传递值或未定义，默认函数参数允许命名参数用默认值初始化！</p><p id="8aff" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我们的例子中，即使null是<code class="fe na nb nc nd b">falsey</code>，它仍然是一个值！</p><p id="32d8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以下一次你设置默认值为空值时，一定要三思而后行。当空数组是值的预期类型时，可以将值初始化为空数组。</p><h2 id="eb69" class="mb mc it bd md me mf dn mg mh mi dp mj lm mk ml mm lq mn mo mp lu mq mr ms iz bi translated">2.用方括号抓取属性</h2><p id="c532" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">有时获取属性的方式可能会影响应用程序的行为。如果你想知道这是什么行为，这是应用程序崩溃。以下是使用方括号执行对象查找的示例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c08a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这些实际上是100%有效的用例，除了<a class="ae ma" href="https://stackoverflow.com/questions/26353417/javascript-object-vs-array-lookup-performance/26353637" rel="noopener ugc nofollow" target="_blank">比对象键查找</a>慢之外，它们没有任何问题。</p><p id="b642" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">无论如何，当一个非故意的问题出现时，真正的问题开始在你的应用程序中蔓延，比如一个小小的打字错误:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6bf1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您或您的一名队友正在实现对该代码片段的一些增强，并且犯了一个小错误(例如将<em class="lz"> joe </em>中的<em class="lz"> J </em>大写)，结果将立即返回<em class="lz"> undefined </em>，并且会发生崩溃:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b0ea" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">令人毛骨悚然的是，应用程序<em class="lz">不会崩溃</em>，直到你的一部分代码试图用那个未定义的值进行属性查找！</p><p id="8306" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以与此同时，<em class="lz">Joe profile</em>(<em class="lz">undefined</em>伪装)将在你的应用中传递，没有人能够知道这个无声的未定义值正在四处蔓延，直到一段代码执行一些属性查找，就像<em class="lz">Joe profile . age</em>，因为<em class="lz">Joe profile</em>是<code class="fe na nb nc nd b">undefined</code>！</p><p id="745b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一些开发人员为避免崩溃所做的是，如果查找失败，初始化一些默认的有效返回值:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="dffa" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">至少现在app不会崩溃了。这个故事的寓意是，当你用方括号符号应用查找时，总是<em class="lz">处理无效的查找情况！</em></p><p id="2936" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于一些人来说，如果没有真实世界的例子，可能很难解释这种做法的严重性。所以我要举一个真实的例子。我将要向您展示的代码示例取自8个月前的一个存储库。为了保护这些代码来源的隐私，我重命名了几乎所有的变量，但是<em class="lz">代码的设计、语法和架构保持不变</em>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0409" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="lz"> fixVideoTypeNaming </em>是一个基于作为参数传入的值提取视频类型的函数。如果参数是视频<em class="lz">对象</em>，它将从<code class="fe na nb nc nd b">.videoType</code>属性中提取视频类型。如果它是一个字符串，那么调用者传入了<code class="fe na nb nc nd b">videoType </code>，所以我们可以跳过第一步。有人发现,<code class="fe na nb nc nd b">videoType <em class="lz">.mp4</em>property</code>在应用程序的几个地方被拼错了。为了快速临时解决这个问题，使用了<em class="lz"> fixVideoTypeNaming </em>来修补这个错别字。</p><p id="f0bb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，正如你们中的一些人可能已经猜到的，这个应用是用<a class="ae ma" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>构建的——因此有了语法。</p><p id="81ef" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了使用这些选择器，您可以将它们导入到一个<a class="ae ma" href="https://react-redux.js.org/api/connect" rel="noopener ugc nofollow" target="_blank"> connect </a>高阶组件中，以连接一个组件来监听该状态片段。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b46f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">用户界面组件:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="70ad" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该组件接收特设委员会传递给它的所有道具，并根据道具提供的数据显示符合条件的信息。在一个完美的世界里，这很好。在一个不完美的世界里，这暂时不会有问题。</p><p id="48a6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们回到容器中，看看选择器选择它们的值的方式，我们实际上可能埋下了一颗定时炸弹，等待爆炸的机会:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="768d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在开发任何种类的应用程序时，确保更高的可信度和减少开发流程中的错误的常见做法包括在中间实施测试以确保应用程序按预期运行。</p><p id="0863" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然而，就这些代码片段而言，如果它们没有被测试，没有被及早处理，应用程序<em class="lz">将来会崩溃。</em></p><p id="7a51" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，<code class="fe na nb nc nd b">state.app.media.video.videoType</code>是<em class="lz">链中的四个</em>层级。如果另一个开发人员在被要求修复应用程序的另一部分时意外出错，导致<code class="fe na nb nc nd b">state.app.media.video</code>变成<em class="lz">未定义</em>怎么办？app会因为无法读取未定义的<code class="fe na nb nc nd b">videoType</code>属性<em class="lz">而崩溃。</em></p><p id="ed3a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此外，如果有另一个关于<code class="fe na nb nc nd b">videoType</code>的打字错误问题，而<code class="fe na nb nc nd b">fixVideoTypeNaming</code>没有更新以适应这个问题以及<em class="lz"> mp3 </em>问题，应用程序就有另一个意外崩溃的风险，除非<em class="lz">真实用户</em>遇到这个问题，否则没有人能够检测到。到那个时候，就太晚了。</p><p id="eb28" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">假设应用程序永远不会遇到这样的错误也不是一个好的做法。请小心！</p><h2 id="e19b" class="mb mc it bd md me mf dn mg mh mi dp mj lm mk ml mm lq mn mo mp lu mq mr ms iz bi translated">3.渲染时不小心检查空对象</h2><p id="95f7" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">很久以前，在有条件呈现组件的黄金时代，我曾经做过的事情是使用<code class="fe na nb nc nd b">Object.keys</code>检查数据是否已经被填充到对象中。如果有数据，那么如果条件通过，组件将继续呈现:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="63ae" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">假设我们调用了某个API，并在响应中的某个地方接收到了作为对象的<code class="fe na nb nc nd b">items</code>。也就是说，这一开始看起来很好。<code class="fe na nb nc nd b">items</code>的预期类型是一个对象，所以使用<code class="fe na nb nc nd b">Object.keys</code>完全没问题。毕竟，我们<em class="lz">确实</em>将<code class="fe na nb nc nd b">items</code>初始化为一个空对象，作为一种防御机制，以防出现bug将它转换为<code class="fe na nb nc nd b">falsey </code>值。</p><p id="4066" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是我们不应该相信服务器总是返回相同的结构。如果<code class="fe na nb nc nd b">items</code>以后变成了数组呢？<code class="fe na nb nc nd b">Object.keys(items)</code>会不会<em class="lz">不崩溃</em>但是会返回一个类似<code class="fe na nb nc nd b">["0", "1", "2"]</code>的奇怪输出。您认为使用该数据呈现的组件会有什么反应？</p><p id="49a0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但这还不是最糟糕的。该代码片段中最糟糕的部分是，如果<code class="fe na nb nc nd b">items</code>在props中作为一个空值被接收，那么<code class="fe na nb nc nd b">items</code> <a class="ae ma" href="https://medium.com/better-programming/10-things-not-to-do-when-building-react-applications-bc26d4f38644" rel="noopener">甚至不会被初始化为您提供的默认值</a>！</p><p id="a36d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后<em class="lz">你的应用会在开始做其他事情之前崩溃</em>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="99c9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">还是那句话，请小心！</p><h2 id="2827" class="mb mc it bd md me mf dn mg mh mi dp mj lm mk ml mm lq mn mo mp lu mq mr ms iz bi translated">4.渲染前不小心检查数组是否存在</h2><p id="1aac" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">这与第三种情况非常相似，但是数组和对象经常互换使用，所以它们应该有自己的部分。</p><p id="9821" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你有这样的习惯:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="23b5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后确保你至少有单元测试来一直关注代码，或者在将它传递给render方法之前尽早正确处理<code class="fe na nb nc nd b">arr</code>，否则如果<code class="fe na nb nc nd b">arr</code>变成了<em class="lz">对象文字</em>，应用程序将会崩溃。当然，<code class="fe na nb nc nd b">&amp;&amp;</code>操作者会认为它是<code class="fe na nb nc nd b">truthy</code>，并试图<code class="fe na nb nc nd b">.map</code>对象文字，这将导致整个应用程序崩溃。</p><p id="8ab8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以请记住这一点。把你的精力和挫折留给更大的问题吧，这些问题更值得你特别关注！；)</p><h2 id="80b4" class="mb mc it bd md me mf dn mg mh mi dp mj lm mk ml mm lq mn mo mp lu mq mr ms iz bi translated">5.不使用棉绒</h2><p id="4bb1" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">如果您在开发应用程序时没有使用任何类型的linter，或者您根本不知道它们是什么，请允许我详细说明一下为什么它们在开发中有用。</p><p id="3a59" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我用来帮助我的开发流程的linter是<a class="ae ma" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>，这是一个众所周知的JavaScript林挺工具，它允许开发人员甚至不用执行代码就能发现代码中的问题。</p><p id="7d6d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个工具非常有用，它可以充当你的半导师，帮助你实时纠正错误——就好像有人在指导你一样。它甚至<em class="lz">描述了为什么你的代码可能是糟糕的</em>，并建议你应该做什么！</p><p id="0a57" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里有一个例子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ne"><img src="../Images/07deba851db9911d18bd6323e0a7f878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siUZw72AgNmdhZr7d1HbWQ.jpeg"/></div></div></figure><p id="f3f3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">关于ESLint最酷的事情是，如果你不喜欢某些规则或者不同意其中的一些，你可以简单地禁用某些规则，这样它们就不会在你开发的时候显示为林挺警告/错误。<em class="lz">让自己开心就好</em>对吧？</p><h2 id="ba89" class="mb mc it bd md me mf dn mg mh mi dp mj lm mk ml mm lq mn mo mp lu mq mr ms iz bi translated">6.呈现列表时析构</h2><p id="4bac" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">我在过去看到过一些人发生这种情况，这并不总是一个容易发现的错误。基本上，当你有一个项目列表，并且你要为列表中的每个项目渲染一堆组件时，当列表中的一个项目不是你期望的值时，将来可能会在你的应用程序中出现的错误就会发生。如果你的应用不知道如何处理值类型，它可能会崩溃。</p><p id="bd21" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里有一个例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b88956c5a7c965878e67d79146573279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*nmuGAMp1CUffPNGSE9fI6g.jpeg"/></div></figure><p id="b7d9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">代码会非常好地工作。现在，让我们看看API调用。与其归还这个——</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6e59" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">—如果在API客户端出现意外情况时，数据流的处理方式出现了问题，并且返回了这个数组，该怎么办？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7c10" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你的应用会崩溃，因为它不知道如何处理:</p><pre class="ks kt ku kv gt ng nd nh ni aw nj bi"><span id="c492" class="mb mc it nd b gy nk nl l nm nn">Uncaught TypeError: Cannot read property 'name' of undefined<br/>    at eval (DataList.js? [sm]:65)<br/>    at Array.map (&lt;anonymous&gt;)<br/>    at DataList (DataList.js? [sm]:64)<br/>    at renderWithHooks (react-dom.development.js:12938)<br/>    at updateFunctionComponent (react-dom.development.js:14627)</span></pre><p id="6501" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，为了防止应用程序崩溃，您可以在每次迭代中设置一个默认对象:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="725e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，您的用户不必对您的技术和专业知识做出判断，因为他们不会看到页面在他们面前崩溃:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi no"><img src="../Images/274e83bfaf79326b055da515f0368f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*CuyB22eEkPKj_Im4oZJpmA.jpeg"/></div></figure><p id="7f27" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然而，即使应用程序不再崩溃，我还是建议更进一步，处理丢失的值，比如对有类似问题的整个项目返回null，因为它们没有任何数据。</p><h2 id="3fad" class="mb mc it bd md me mf dn mg mh mi dp mj lm mk ml mm lq mn mo mp lu mq mr ms iz bi translated">7.对你将要实现的东西没有做足够的研究</h2><p id="e732" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">在过去，我犯了一个致命的错误，那就是对我实现的搜索输入过于自信，在游戏中过早地相信我的意见。</p><p id="a46e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我这么说是什么意思？嗯，我并不是对搜索输入组件<em class="lz">的</em>过于自信。组件<em class="lz">应该是一个简单的</em>任务——事实也的确如此。</p><p id="2b23" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">整个搜索功能出现问题的真正原因是<em class="lz">包括查询中的字符</em>。</p><p id="6488" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当我们将关键字作为查询发送到搜索API时，认为用户键入的每个键都是有效的并不总是足够的，即使他们因此而在键盘上。</p><p id="cfab" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">只要100%确定像这样的正则表达式完全按照预期工作，并避免遗漏任何可能导致应用程序崩溃的无效字符:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1a42" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个例子是最新的、为搜索API建立的正则表达式。</p><p id="3f71" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是之前的情况:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9745" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如你所见，斜线<code class="fe na nb nc nd b">/</code>不见了，这导致了应用程序崩溃！如果这个字符最终通过网络被发送给一个API，猜猜API认为这个URL会是什么？</p><p id="69e2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">另外，我不会100%相信你在网上找到的例子。它们中的许多都不是经过全面测试的解决方案，而且对于正则表达式来说，大多数用例都没有真正的标准。</p><h2 id="24dd" class="mb mc it bd md me mf dn mg mh mi dp mj lm mk ml mm lq mn mo mp lu mq mr ms iz bi translated">8.不限制文件输入的大小</h2><p id="0f90" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">限制用户选择的文件大小是一个很好的做法，因为大多数时候你并不真的需要一个大得离谱的文件，只要它可以以某种方式压缩而不会失去任何明显的质量损失。</p><p id="a4a8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是有一个更重要的原因可以解释为什么将尺寸限制在一定范围内是一种好的做法。在我的公司，我们注意到用户过去在上传图片时偶尔会“冻结”。不是每个人都拥有外星人17 R5，所以你必须考虑到你的用户的某些情况。</p><p id="716d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下面是一个将文件限制在5 MB (5，000，000字节)的示例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b5cd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你不会希望用户在应该上传文档的时候上传视频游戏！</p><h2 id="1b81" class="mb mc it bd md me mf dn mg mh mi dp mj lm mk ml mm lq mn mo mp lu mq mr ms iz bi translated">结论</h2><p id="a1c7" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">本帖到此结束！</p><p id="006a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">将会有第二部分，因为我只看完了一半的清单——哎呀！</p><p id="dd7f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">感谢您的阅读，并确保关注我的未来更新！7月4日快乐！</p></div></div>    
</body>
</html>