<html>
<head>
<title>Using the UIMenuController and Manipulating the Responder Chain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用UIMenuController并操作响应器链</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/uimenucontroller-and-manipulating-the-responder-chain-c06fad73c64b?source=collection_archive---------4-----------------------#2019-05-20">https://betterprogramming.pub/uimenucontroller-and-manipulating-the-responder-chain-c06fad73c64b?source=collection_archive---------4-----------------------#2019-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="859d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Swift通过UIMenuController处理事件的详细指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/29362c7419c57d2b3732533e0638a920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHhWyc6QAQBXiYATqRHIXQ.png"/></div></div></figure><p id="5024" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文重点介绍UIMenuController功能，以及它如何与UIResponder链交互来处理事件。它假设您至少对这两者都有所了解，但是如果没有，请在继续之前阅读一下。你也可以在最后找到一个这样的例子。</p><ul class=""><li id="50d4" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/uimenucontroller" rel="noopener ugc nofollow" target="_blank"> UIMenuController API </a></li><li id="5c22" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events" rel="noopener ugc nofollow" target="_blank">与记者合作</a></li></ul><p id="94da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，现在让我们进入主要部分。当显示UIMenuController时，它需要有一个firstResponder对象。通常，您只需将上面显示菜单的视图设置为第一响应者就可以了，但是如果您想在一个视图上面显示这个菜单，而另一个视图作为第一响应者呢？例如，当UITextView/UITextField处于活动状态时，用户正在键入某些内容，而无需关闭键盘。嗯，正好有一种方法可以处理这种情况，但是您必须对响应者链进行一些操作才能实现。值得庆幸的是，苹果已经让这个目标相对容易实现。</p><p id="5115" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们要做的是获取两个独立的UIResponder链，一个代表菜单呈现的视图，我们称之为“气泡视图”，另一个代表用户输入的文本视图，然后合并它们。这将是在信息功能的背景下，类似于Instagram的聊天。我们的目标是让用户在能够长按消息气泡来执行操作的同时输入消息。</p><p id="86de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们目标的一个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/7454b4281b364ac55b74f5b0976e2f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*664Oc0vPp8fYcJJeLSUthw.gif"/></div></figure><p id="f2cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要设置并附加一个长按手势，定制UIMenuController singleton，并在presenting视图中覆盖<code class="fe me mf mg mh b">canPerformAction</code>以使其能够显示菜单。我假设从现在开始已经准备好了，但如果你想了解更多细节，这篇文章的底部有参考资料。</p><p id="7b50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经准备好菜单并开始运行，但是您可能会注意到一个问题。每当菜单弹出时，它会隐藏键盘。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/dd88bd37e79adc3f82854f91a8ac6511.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*Lnmai1KB12WFaB9kB9vDKw.gif"/></div></figure><p id="17ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们将稍微调整一下响应链。本质上，我们需要输入文本字段作为第一响应者，但是对于视图，我们是在决定菜单在哪里显示以及显示什么动作。这是通过用我们点击的视图替换文本字段的“下一个响应者”对象来实现的。</p><p id="0cb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们子类化UITextField和override <code class="fe me mf mg mh b">nextResponder</code>并提供我们自己的覆盖。这个覆盖将是从上面的“气泡视图”。</p><pre class="kg kh ki kj gt mi mh mj mk aw ml bi"><span id="e51d" class="mm mn iq mh b gy mo mp l mq mr">weak var nextResponderOverride: UIResponder?</span><span id="144d" class="mm mn iq mh b gy ms mp l mq mr">override var next: UIResponder? {<br/>  if nextResponderOverride != nil {<br/>    return nextResponderOverride<br/>  } else {<br/>    return super.next<br/>  }<br/>}</span></pre><p id="58df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除此之外，我们还需要覆盖UITextField上的<code class="fe me mf mg mh b">canPerformAction</code>方法，这样我们就可以允许被覆盖的<code class="fe me mf mg mh b">nextResponder</code>做出决定。这将是我们如何允许文本字段“假装”它可以稍后执行UIMenuController的操作。</p><pre class="kg kh ki kj gt mi mh mj mk aw ml bi"><span id="7d4e" class="mm mn iq mh b gy mo mp l mq mr">override func canPerformAction(_ action: Selector, withSender sender: Any?) -&gt; Bool {<br/>  if nextResponderOverride != nil {<br/>    return false<br/>  } else {<br/>    return super.canPerformAction(action, withSender: sender)<br/>  }<br/>}</span></pre><p id="8d50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里发生的事情的要点是，如果我们已经设置了<code class="fe me mf mg mh b">nextResponderOverride</code>，也就是说，我们希望“气泡视图”来处理这个问题，那么无论如何我们都会返回false。这导致UIMenuController检查文本视图的<code class="fe me mf mg mh b">next</code>响应器，我们已经将其覆盖为我们的“气泡视图”，这样我们就完成了响应器链的交换。</p><p id="fb59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在剩下唯一要做的事情就是设置我们的“气泡视图”来处理期望的动作。我们通过以下方式做到这一点:</p><pre class="kg kh ki kj gt mi mh mj mk aw ml bi"><span id="ca9e" class="mm mn iq mh b gy mo mp l mq mr">// Ensure our bubble view can be the first responder<br/>override var canBecomeFirstResponder: Bool {<br/>  return true<br/>}</span><span id="8a80" class="mm mn iq mh b gy ms mp l mq mr">// Set it to be able to perform desired actions<br/>override func canPerformAction(_ action: Selector, withSender sender: Any?) -&gt; Bool {<br/>  // Extend this to check for all actions<br/>  if action == #selector(oneMethod) { <br/>    return true<br/>  } else {<br/>    return false<br/>  }<br/>}</span></pre><p id="5cb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，当你打开键盘并触发你的菜单显示时，它会显示出来，而不需要接管和隐藏键盘！🎉</p><p id="352a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请在下面留下您在实施时遇到的任何问题或困难的评论。</p><p id="7ad5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很快还会有一篇后续文章，将涵盖一些在构建这种用户交互时可能出现的边缘情况错误，例如长按文本字段时操作被复制。你可以在下面的例子和Instagram的聊天功能中看到这种情况。</p><p id="a4c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个这方面的例子:<a class="ae lw" href="https://github.com/alexpersian/MenuItemTester" rel="noopener ugc nofollow" target="_blank">https://github.com/alexpersian/MenuItemTester</a></p><p id="7279" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">堆栈溢出参考答案:<a class="ae lw" href="https://stackoverflow.com/a/23849955/3434244" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/23849955/3434244</a></p></div></div>    
</body>
</html>