<html>
<head>
<title>7 JavaScript Patterns Part 1: Making Variables from Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7 JavaScript模式第1部分:从属性生成变量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-js-patterns-part-1-switching-from-properties-to-variables-and-reverse-3d86fea07c1d?source=collection_archive---------4-----------------------#2019-05-15">https://betterprogramming.pub/7-js-patterns-part-1-switching-from-properties-to-variables-and-reverse-3d86fea07c1d?source=collection_archive---------4-----------------------#2019-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1fc7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">所有初级开发人员都应该知道的JavaScript模式系列的第一部分</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/2750136a5ceb070ce75039280d1b2088.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gsDlEML6Wg5Ll0GIb84lYQ.png"/></div></figure><h1 id="18aa" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">从属性切换到变量…看起来像什么？</h1><p id="0191" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">自从ES6发布以来，有几种方法可以将变量的值/引用分配给属性，反之亦然。一方面，我们有<strong class="lk iu">增强的对象字面量</strong>，另一方面，有<strong class="lk iu">析构赋值</strong>。</p><p id="0b1a" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">增强的对象文字是从变量中分配对象属性的一种方式，如下所示:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="cdbc" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">析构从对象的属性创建变量，如下所示:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6d17" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><em class="ml">* * * ES6及更高版本支持，</em> <a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> <em class="ml">文档</em> </a> <em class="ml"> *** </em></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="1e00" class="kq kr it bd ks kt mu kv kw kx mv kz la jz mw ka lc kc mx kd le kf my kg lg lh bi translated">怎么解码？</h1><h2 id="a398" class="mz kr it bd ks na nb dn kw nc nd dp la lr ne nf lc lv ng nh le lz ni nj lg nk bi translated"><strong class="ak">增强的对象文字</strong></h2><p id="8a76" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设您声明了两个变量:</p><pre class="ki kj kk kl gt nl nm nn no aw np bi"><span id="71c2" class="mz kr it nm b gy nq nr l ns nt">const model = "civic", wheel = 4</span></pre><p id="6dc5" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">使用增强的语法创建一个对象文字，如下所示:</p><pre class="ki kj kk kl gt nl nm nn no aw np bi"><span id="316e" class="mz kr it nm b gy nq nr l ns nt">const my_car = {model, wheel}</span></pre><p id="6fc8" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">与没有增强语法的情况相同，如下所示:</p><pre class="ki kj kk kl gt nl nm nn no aw np bi"><span id="89de" class="mz kr it nm b gy nq nr l ns nt">const my_car = {model: model, wheel: wheel}</span></pre><p id="32ea" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">很明显，对吧？这就是每次遇到增强的对象文字时需要看到的内容。它创建一个对象属性，其名称和值/引用与用来增强对象的变量相同。</p><h2 id="f804" class="mz kr it bd ks na nb dn kw nc nd dp la lr ne nf lc lv ng nh le lz ni nj lg nk bi translated"><strong class="ak">解构</strong></h2><p id="981a" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们假设你有一个看起来像这样的物体:</p><pre class="ki kj kk kl gt nl nm nn no aw np bi"><span id="2b94" class="mz kr it nm b gy nq nr l ns nt">const car = {<br/>  model: "civic",<br/>  brand: {<br/>    name: "Honda",<br/>    founding_year: 1948<br/>  }<br/>}</span></pre><p id="6c05" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">如果使用析构赋值创建变量:</p><pre class="ki kj kk kl gt nl nm nn no aw np bi"><span id="8ca3" class="mz kr it nm b gy nq nr l ns nt">const {model, brand} = car</span></pre><p id="7740" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这和不这样用是一样的</p><pre class="ki kj kk kl gt nl nm nn no aw np bi"><span id="b31b" class="mz kr it nm b gy nq nr l ns nt">const model = car.model, brand = car.brand</span></pre><p id="045d" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这一条可能不太明确，但同样的原则适用。<br/>在变量赋值的一边，你把你想访问的所有属性的名字作为一个变量写在一个对象文字里。另一方面，编写要从中提取属性的对象。像这样制作的变量将与它的属性具有相同的名称和相同的值/引用。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="533c" class="kq kr it bd ks kt mu kv kw kx mv kz la jz mw ka lc kc mx kd le kf my kg lg lh bi translated">它们有什么用？</h1><p id="1957" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们讨论的模式是为了让你的代码枯燥无味(不要重复)。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/49e9e27985a6b3ba4badfc8eaa9a1db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W9pVaVSxa-WMS1ZQ.jpg"/></div></div></figure><p id="8f42" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">例如，假设我们想创建一个函数来记录你有多爱你的车:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9ead" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">使用析构赋值可以省去我们每次想要访问其属性时键入<em class="ml"> your_car </em>的麻烦。因此，析构赋值是使用同一个对象的属性而不用多次提及它的一种更简单的方法。增强对象文字是用变量创建对象的一种更简单的方法，因为如果属性名称与变量同名，就不必指定属性名称。</p><p id="0e99" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">而且，你知道我还可以更干<em class="ml"> loveYourCar </em>功能吗？</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3c97" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">是的，的确，你也可以在函数参数中使用析构赋值，只要那个参数是一个对象。</p><h2 id="49dc" class="mz kr it bd ks na nb dn kw nc nd dp la lr ne nf lc lv ng nh le lz ni nj lg nk bi translated">有趣的仿真陈述</h2><p id="fceb" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在webpack中，当您从这样的库中导入模块时:</p><pre class="ki kj kk kl gt nl nm nn no aw np bi"><span id="6b14" class="mz kr it nm b gy nq nr l ns nt">import {Text, View} from 'react-native';</span></pre><p id="35e0" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">你实际上只是在使用析构赋值！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9bae" class="kq kr it bd ks kt mu kv kw kx mv kz la jz mw ka lc kc mx kd le kf my kg lg lh bi translated">有什么你应该知道的怪癖吗？</h1><p id="1226" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，有一个，虽然它实际上更像是JS的一个怪癖。</p><p id="3afe" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">JS通过所有原语(数字、字符串、布尔值等)的值和对象的引用来分配变量或属性。<a class="ae mm" href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0" rel="noopener" target="_blank">点击此处了解更多信息</a>。让我们看一个增强对象文字的例子:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="45b3" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">具有相同引用的属性或变量赋值将指向同一个对象。因此，此对象的变异会对其所有引用产生影响。非常注意这一点。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="dcea" class="kq kr it bd ks kt mu kv kw kx mv kz la jz mw ka lc kc mx kd le kf my kg lg lh bi translated">我们到此为止</h1><p id="24bd" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个系列的下一步:<a class="ae mm" href="https://medium.com/@patick.cyiza/js-patterns-part-2-the-spread-syntax-9f7e66038c86" rel="noopener">扩展语法</a></p><p id="15e0" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><a class="ae mm" href="https://medium.com/@patick.cyiza/7-js-patterns-junior-developers-should-know-well-1a0ad075338f" rel="noopener">点击此处查看完整系列。</a></p></div></div>    
</body>
</html>