<html>
<head>
<title>Best Practices That Every Node Developer Should Follow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个节点开发人员都应该遵循的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-practices-that-every-node-developer-should-follow-fe553491b00f?source=collection_archive---------5-----------------------#2020-10-19">https://betterprogramming.pub/best-practices-that-every-node-developer-should-follow-fe553491b00f?source=collection_archive---------5-----------------------#2020-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="887a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">所有项目都应该遵循最佳实践来提高效率和质量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c3569190e7c59d391dda489f9d79754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uM3PMyCc-ECKlbr7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@soul_adorning_shades1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">潘达夫坦克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="8f2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>作为一种用于后端开发的异步和事件驱动语言，在开发人员中很受欢迎。它的语法非常容易理解——即使对初学者来说也是如此。</p><p id="75ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是使用Node的初学者还是经验丰富的开发人员，在开发面向生产的应用程序时，都必须遵循Node.js编程的最佳实践。</p><p id="5fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将指出每个节点开发人员应该遵循的十个最佳实践。除了作为程序员应该遵循的一般最佳编码实践，这些将帮助您最大限度地利用Node的独特功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c365" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将确切的包版本保存到package.json</h1><p id="b126" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在开发过程中，我们使用以下命令向应用程序添加一个新包:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d929" class="ne md it na b gy nf ng l nh ni">npm install express --save</span></pre><p id="f5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将软件包及其安装版本保存到<code class="fe nj nk nl na b">package.json</code>文件，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3b55" class="ne md it na b gy nf ng l nh ni">"express": "^4.17.1",</span></pre><p id="0b74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，使用脱字符号(<code class="fe nj nk nl na b">^</code>)表示应用程序接受了来自<code class="fe nj nk nl na b">“&gt;=4.17.1 &lt;5.0.0”</code>地区的版本包。</p><p id="d25a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">注意:如果你想知道更多关于像插入符号这样的符号如何定义版本范围，请阅读</em> <a class="ae ky" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> <em class="nm"> SemVar文档</em> </a> <em class="nm">。</em></p><p id="313f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当其他人使用我们创建的<code class="fe nj nk nl na b">package.json</code>文件来设置应用程序环境和安装依赖项(使用<code class="fe nj nk nl na b">npm install</code>命令)时，这就成问题了。</p><p id="3ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，npm安装的不是我们用于开发的软件包版本，而是其他用户安装依赖项时可用的最新版本。如果最新版本与我们在初始实现中使用的版本不兼容，就会导致错误。特别是如果项目是开源的，我们需要注意这种可能性。</p><p id="7a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用两种方法来防止包版本的冲突。</p><p id="06f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是每次安装并保存软件包到<code class="fe nj nk nl na b">package.json</code>文件时使用<code class="fe nj nk nl na b">--save-exact</code>:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="68d0" class="ne md it na b gy nf ng l nh ni">npm install express --save --save-exact</span></pre><p id="caa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以使用以下命令配置npmrc文件一次，以便在默认情况下，安装的每个软件包的可接受版本都是其确切版本:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="81ff" class="ne md it na b gy nf ng l nh ni">npm config set save-exact=true</span></pre><p id="5e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法都保存安装到<code class="fe nj nk nl na b">package.json</code>文件中的每个新包，前面没有插入符号:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0ff6" class="ne md it na b gy nf ng l nh ni">"express": "4.17.1",</span></pre><p id="69e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每当别人使用<code class="fe nj nk nl na b">package.json</code>文件安装依赖项时，npm都会安装文件中提到的确切版本，而不是最新版本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fdec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">每次代码更改后，使用工具重新启动应用程序</h1><p id="02df" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在开发阶段，如果不使用其他工具，您将不得不停止并重新启动应用程序，以应用对代码库所做的简单更改。编码一段时间后，这变成了一个麻烦，不会让你完全专注于任务。</p><p id="4fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为解决方案，您可以使用一个工具来监控应用程序的代码库，并在每次发生更改时自动重启应用程序。</p><p id="94d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">适用于Node的一些流行的代码监控包有:</p><ul class=""><li id="a45c" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">Nodemon:每当向代码中添加新的更改时，Nodemon都会自动重启应用程序。你可以在命令行用<code class="fe nj nk nl na b">nodemon</code>代替<code class="fe nj nk nl na b">node</code>来初始化Nodemon(比如用<code class="fe nj nk nl na b">nodemon</code> app代替<code class="fe nj nk nl na b">node app</code>)。</li><li id="184b" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">Forever: Forever还提供了Nodemon提供的自动重启特性，但是带有额外的配置选项。这些选项包括设置工作目录和将通常在<code class="fe nj nk nl na b">stdout</code>上打印的日志写入文件。</li><li id="e03c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">PM2: PM2是另一个你可以使用的过程管理工具。与其他两种相比，它允许更多的控制和功能来管理生产中运行的流程。</li></ul><p id="d578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你甚至可以在生产环境中使用这些工具——尤其是《永远》和《PM2》。这将保证应用程序在运行时出错后能够顺利恢复。它还将确保应用程序在运行它的服务器关闭的情况下尽快重启。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f24b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用样式指南</h1><p id="3231" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当许多开发人员在同一个项目上工作时，不可避免地，他们的代码风格会有差异。不幸的是，程序员是一群非常固执己见的人。</p><p id="3b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的代码风格不同于您目前从事的项目的前一位开发人员，您很可能会根据自己的喜好重新设置大括号的位置或用制表符替换空格。你将会在这个平凡而无用的任务上花费大量的时间，而这个任务对你内心的平静来说是非常必要的。</p><p id="d4e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然程序员喜欢在空闲时间讨论什么是节点编程的最佳风格，但这种选择大多是主观的。因此，为了您的安心和工作效率，我们建议您在项目开始前选择并同意特定的风格指南。您甚至可以找到其他程序员使用的现有风格指南。</p><p id="8682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些受欢迎的科技公司使用的风格指南:</p><ul class=""><li id="a6f8" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><a class="ae ky" href="https://google.github.io/styleguide/javascriptguide.xml" rel="noopener ugc nofollow" target="_blank">谷歌</a></li><li id="e3f0" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://github.com/airbnb/javascript" rel="noopener ugc nofollow" target="_blank"> Airbnb </a></li><li id="75ed" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://contribute.jquery.org/style-guide/js/" rel="noopener ugc nofollow" target="_blank"> jQuery </a></li></ul><p id="2e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用一些工具来确保所选风格指南的规则在整个项目中得以实施。我们可以使用ESLint来验证编写的代码，并使用更漂亮的工具来自动格式化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3876" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用async/await代替回调</h1><p id="b717" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当第一次引入Node时，它的异步特性是通过使用回调来保持的。但是任何节点开发人员都会从经验中知道，当回调一个接一个地嵌套时，用不了多久就会失控。这就是我们所说的回调地狱。此时，您的代码将非常难以阅读。</p><p id="f504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过随着ES6中<code class="fe nj nk nl na b">async/await</code>的引入(以及之前的承诺)，Node已经提供了解决这个问题的方案。因此，作为一名节点开发人员，您有责任利用这一新的引入，而不是在有办法避免回调的情况下又回到回调地狱。</p><p id="fff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个温和版的回调地狱:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="bc23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nj nk nl na b">async/await</code>，我们可以很容易地避免遇到这种情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="28f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为节点编程的最佳实践，总是尝试用<code class="fe nj nk nl na b">async</code>和<code class="fe nj nk nl na b">await</code>替换回调函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="27fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用合适的测井工具</h1><p id="d80d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，<code class="fe nj nk nl na b">console.log</code>不是一个合适的测井工具。忘记将它用于应用程序的每一个日志记录目的。在许多限制中，<code class="fe nj nk nl na b">console.log</code>没有为日志记录提供足够的配置选项，包括根据需要过滤它们的选项。</p><p id="a2ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node有几个专用的日志框架，您可以在应用程序中使用。温斯顿、班扬和皮诺就是这类工具的几个例子。您可以测试并选择一个适合您的应用程序的需求。</p><p id="26c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了简单的日志记录之外，它们还为您提供了定义日志记录级别的选项，如错误、警告、信息和调试。使用专用的日志记录工具，您还可以根据情况仅打开必要级别的日志，即使应用程序处于生产状态。</p><p id="105b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用所选工具创建测井系统时，不要忘记遵循<a class="ae ky" href="https://livecodestream.dev/post/2020-09-14-you-built-your-node-app-but-are-you-logging/" rel="noopener ugc nofollow" target="_blank">最佳测井实践</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c190" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">总是尝试使用const Over let</h1><p id="04cb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽可能使用<code class="fe nj nk nl na b">const</code>在<code class="fe nj nk nl na b">let</code>上声明变量。</p><p id="59a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你使用<code class="fe nj nk nl na b">const</code>声明一个变量时，你不能在第一次赋值后给它重新赋值。这可以防止您在多个场合重复使用同一个变量。因为<code class="fe nj nk nl na b">const</code>迫使你在不重用现有变量的情况下用适当的名字声明新变量，这使得你的代码更加干净和清晰。</p><p id="60ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有些情况下，您可能希望能够灵活地更改变量值。然后，您可以使用<code class="fe nj nk nl na b">let</code>来声明该变量，但前提是您已经正确地将它标识为一个改变其值的变量。例如，您必须使用<code class="fe nj nk nl na b">let</code>关键字在<code class="fe nj nk nl na b">for</code>循环中声明增量变量。</p><p id="8186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES6引入<code class="fe nj nk nl na b">let</code>之前，在Node中使用<code class="fe nj nk nl na b">var</code>来声明变量。一些开发人员出于习惯仍然在他们的代码中使用<code class="fe nj nk nl na b">var</code>。但是作为节点最佳实践，不要再在代码中使用<code class="fe nj nk nl na b">var</code>。</p><p id="0187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用这些关键字声明变量之前，注意它们的<a class="ae ky" href="https://levelup.gitconnected.com/understanding-variables-scope-and-hoisting-in-javascript-93018bf29190" rel="noopener ugc nofollow" target="_blank">范围也很重要——无论是<code class="fe nj nk nl na b">const</code>还是<code class="fe nj nk nl na b">let</code>。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b162" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用代码覆盖工具来跟踪未测试的代码</h1><p id="bff7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们没有将<a class="ae ky" href="https://medium.com/better-programming/testing-in-node-js-using-mocha-and-chai-part-1-d5a9e91f4b06" rel="noopener">测试您的节点应用</a>列为最佳实践之一，因为这是不言而喻的。然而，使用代码覆盖工具是作为节点开发人员应该遵循的最佳实践之一。</p><p id="1bbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用代码覆盖工具来确定程序中测试覆盖的级别。这种工具可以识别测试覆盖率是否下降，并突出测试不匹配。</p><p id="3cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/istanbuljs/nyc" rel="noopener ugc nofollow" target="_blank">伊斯坦布尔/纽约市</a>是一个很好的工具，你可以用它来达到这个目的。它提供了彩色的代码覆盖报告，帮助您轻松地识别您所编写的单元测试没有覆盖的区域。您可以轻松地设置NYC来使用您首选的测试框架。</p><p id="23e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，从npm安装软件包作为开发依赖项:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="52e5" class="ne md it na b gy nf ng l nh ni">npm install nyc --save-dev</span></pre><p id="5b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，添加脚本来运行NYC并生成代码覆盖率报告:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ff43" class="ne md it na b gy nf ng l nh ni">"scripts": {<br/>    "test": "mocha",<br/>    "coverage: "nyc npm run test"<br/>}</span></pre><p id="da8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您可以使用<code class="fe nj nk nl na b">npm coverage</code>命令来生成报告。</p><p id="fcc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读我上面链接的文档，了解如何配置NYC以适应您的应用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="97f7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在==运算符上使用===运算符</h1><p id="9184" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Node中，可以同时使用<code class="fe nj nk nl na b">===</code>运算符和<code class="fe nj nk nl na b">==</code>运算符来检查两个变量是否相等。虽然第一个更严格，但第二个也接受较弱的等式。</p><p id="e956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nj nk nl na b">===</code>运算符，两个变量除了值相似之外，还必须是同一类型:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f01a" class="ne md it na b gy nf ng l nh ni">1 === 1 //true<br/>1 === "1" //false<br/>false == 0 //false<br/>0 === “” //false<br/>“” === false //false<br/>null === undefined //false<br/>NaN === null //false<br/>NaN === undefined //false<br/>NaN === NaN //false</span></pre><p id="d2cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个操作符<code class="fe nj nk nl na b">==</code>接受两个值相等的变量，即使它们的类型不同。在执行比较之前，它将两个变量转换为一个通用类型(类型强制):</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1355" class="ne md it na b gy nf ng l nh ni">1 == 1 //true<br/>1 == "1" //true<br/>false == 0 //true<br/>0 == “” //true<br/>“” == false //true<br/>null == undefined //true<br/>NaN == null //false<br/>NaN == undefined //false<br/>NaN == NaN //false</span></pre><p id="3c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在这些例子中看到的，使用<code class="fe nj nk nl na b">==</code>操作符给出了不同于我们通常预期的答案。这是因为在类型强制期间，JavaScript的行为违背了我们的直觉。如果你能记住所有奇怪的情况，并在使用<code class="fe nj nk nl na b">==</code>操作符编写程序时留意它们，这就不是问题了。</p><p id="3898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是通过使用严格的等式操作符<code class="fe nj nk nl na b">===</code>进行比较，您可以很容易地避免担心这种不直观的行为。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7351" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要从节点提供您的前端资产</h1><p id="928e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就其本质而言，Node只使用一个线程来处理向服务器发出的所有请求。我们必须注意最大化这个单线程的效率，否则，它会对应用程序的性能产生很大的影响。</p><p id="f7b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用节点服务器发送静态内容(如HTML或CSS文件)和图像，它们可能会占用单线程。这不公平地影响了应用程序的动态内容，因为它们实际上利用了应用程序的内部组件和逻辑。由于动态和静态内容之间的执行时间分配不平衡，我们的应用程序速度会大大降低。</p><p id="8243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种不平衡，您可以将静态内容从节点服务器中移出，并使用Nginx、S3或CDN等专用中间件将它们提供给用户。然后，节点就有机会提供动态内容，这实际上利用了它的内部逻辑，并防止了静态内容导致的性能下降。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="97e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">保持你的应用程序无状态</h1><p id="0618" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将您需要通过应用程序存储的任何类型的数据(例如，用户会话、用户数据、缓存)存储在外部数据存储中。不要在应用程序本身存储任何信息。</p><p id="0935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，让你的应用程序保持无状态。您应该能够每天关闭并重启服务器，而不会影响它为用户提供的服务。或者，您可以使用像AWS Lambda这样的无服务器平台，它在默认情况下强制实施无状态行为。</p><p id="900c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持服务器无状态可以让应用程序在任何最终的系统故障中幸存下来，而不会损害其服务和性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b6a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b219" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们讨论了作为节点开发人员应该遵循的十个最佳编码实践。这些实践帮助您编写更好的代码，以确保应用程序的最佳性能。</p><p id="c95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，这些是您应该遵循的实践，以及适用于任何编程语言的其他最佳编码实践。第一次尝试时，您可能无法使用所有这些实践。挑选一两个你认为最重要的，然后从那里开始。最终，在编写Node.js代码时，您将能够遵循所有这些原则。</p><p id="843d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>