<html>
<head>
<title>Kubernetes Deployment: Connect Your Front End to Your Back End With Nginx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes部署:用Nginx将您的前端连接到后端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-deployment-connect-your-front-end-to-your-back-end-with-nginx-7e4e7cfef177?source=collection_archive---------0-----------------------#2020-05-04">https://betterprogramming.pub/kubernetes-deployment-connect-your-front-end-to-your-back-end-with-nginx-7e4e7cfef177?source=collection_archive---------0-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f451" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Kubernetes部署全栈应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9f578370f73d4b4252aeb913a8859180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnHmbE2N2j-dUxnB5T2Zmg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约瑟夫·巴里恩托斯在<a class="ae ky" href="https://unsplash.com/s/photos/helm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2fbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes是目前最好的编排工具之一。此外，它得到了Google的支持，所以我们对Kubernetes能够提供的支持和性能没有任何疑问。</p><p id="73ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用<a class="ae ky" href="https://kubernetes.io/docs/setup/learning-environment/minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>来了解如何在Kubernetes中部署全栈应用。</p><p id="2d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我记得当我在进行我的第一次Kubernetes部署时，我意识到部署一个Kubernetes全栈应用程序并连接前端和后端可能有点棘手。所以我决定写一篇教程来帮助你部署你的全栈应用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2550" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="ddf0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本教程假设您对Kubernetes有基本的了解。为了使本教程与主题相关，强烈建议您至少阅读这些主题。</p><ul class=""><li id="88c8" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> Kubernetes部署</a></li><li id="5dec" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务</a></li><li id="f61d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li></ul><p id="3d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，如果你在本地机器上工作，请安装<code class="fe nn no np nq b">minikube</code>、<code class="fe nn no np nq b">kubectl</code>和<code class="fe nn no np nq b">docker</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6ff5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们今天要部署什么？</h1><p id="5e0e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最常见的全栈应用至少有三个组件:</p><ul class=""><li id="0896" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">数据库ˌ资料库</li><li id="c465" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">API服务器</li><li id="39e4" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">前端应用程序</li></ul><p id="1091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程旨在帮助您熟悉Kubernetes部署。一旦您理解了如何部署上述三个组件，您就能够在Kubernetes中部署任何应用程序。</p><p id="6c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Node.js作为后端，使用<a class="ae ky" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>作为数据库，为了简单起见，我们将使用一个带有Ajax的简单HTML文件作为前端。您可以选择React或Angular或您选择的任何前端框架。框架的选择不会影响任何步骤。</p><p id="0d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一步一步，我们将访问所有三个组件。你可以在<a class="ae ky" href="https://github.com/vidu171/Kubernetes-deployment" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到与本文相关的所有代码。</p><p id="e146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那我们就直入主题吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b074" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">后端</h1><p id="72de" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于本教程，我们将保持我们的后端非常简单。我们有一个简单的节点服务器，带有<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>和<a class="ae ky" href="https://mongoosejs.com/docs/" rel="noopener ugc nofollow" target="_blank">mongose</a>。</p><p id="6c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用Mongoose连接到我们的MongoDB。我已经为快递选择了端口<code class="fe nn no np nq b">3000</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="61b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们使用了<code class="fe nn no np nq b">mongo-service</code>作为数据库URL的主机名。这是因为Kubernetes为您提供了名为<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>的抽象。我们将在本教程的后半部分创建一个<code class="fe nn no np nq b">mongo-service</code>服务。并且您可以使用服务名作为主机名来连接到您的应用程序(在本例中为<code class="fe nn no np nq b">mongo-service</code>)。</p><p id="9a60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TLDR；如果您有一个名为<code class="fe nn no np nq b">mongo-service</code>的Kubernetes服务，您可以使用<code class="fe nn no np nq b">mongo-service</code>作为您的应用程序的DNS名称。Kubernetes负责将请求转发到相应的pod。别担心，我们会重新讨论的。</p><p id="448e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还应该向我们的后端应用程序添加一个route <code class="fe nn no np nq b">/api</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。我们现在已经完成了前端应用程序。我们现在要做的就是将应用程序容器化并编写Kubernetes对象。</p><h2 id="5c07" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">容器化节点应用</h2><p id="0249" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要将应用程序部署到Kubernetes，我们需要该应用程序的Docker映像。所以在这一步，我们将容器化我们的后端应用程序。下面是我们的节点应用程序的一个相当简单的<code class="fe nn no np nq b">Dockerfile</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经使用<code class="fe nn no np nq b">node-alpine</code>作为我的基本图像。要创建Docker映像，请运行以下命令:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="4ffd" class="nt md it nq b gy oj ok l ol om">docker build -t backend .</span></pre><p id="f4e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有一个图像叫做<code class="fe nn no np nq b">backend</code>。接下来，我们将编写Kubernetes对象。</p><h2 id="d8d7" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">用于节点应用程序的Kubernetes对象</h2><p id="4901" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于任何Kubernetes部署，我们都需要Kubernetes对象。这些<a class="ae ky" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" rel="noopener ugc nofollow" target="_blank"> Kubernetes对象</a>代表你的容器的状态。</p><p id="5fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个Kubernetes部署对象。部署对象包含诸如使用的Docker映像、副本集的数量、资源分配等信息。</p><p id="541e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个名为<code class="fe nn no np nq b">node-deployment</code>的部署。我们将使用我们的后端映像并创建容器的一个副本。在<code class="fe nn no np nq b">node-deployment.yaml</code>文件中，写下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d6f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个部署对象，我们告诉Kubernetes创建一个名为<code class="fe nn no np nq b">node-deployment</code>的部署，它有一个名为<code class="fe nn no np nq b">node-pod</code>的pod副本集。<code class="fe nn no np nq b">node-pod</code>是一个<code class="fe nn no np nq b">backend</code>图像的集装箱，涉及集装箱港口<code class="fe nn no np nq b">3000</code>。</p><p id="b071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建此部署，只需运行以下命令:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="942a" class="nt md it nq b gy oj ok l ol om">kubectl apply -f node-deployment.yaml</span></pre><p id="6b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经创建了一个部署，但是我们无法与之通信。为了解决这个问题，我们必须创建一个<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>。服务是Kubernetes中的一个抽象概念，它为pod分配IP地址，为一组pod分配一个DNS。正如我们之前在连接MongoDB时看到的，我们使用<code class="fe nn no np nq b">mongo-service</code>作为主机名。我们将编写一个名为<code class="fe nn no np nq b">node-service</code>的服务，这样我们可以从前端连接到我们的后端应用程序。</p><p id="e17e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nn no np nq b">node-service.yaml</code>文件看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经创建了一个类型为<code class="fe nn no np nq b">LoadBalancer</code>的服务。该服务被绑定到名为<code class="fe nn no np nq b">node-pod</code>的pod的所有副本。现在，您可以使用主机名<code class="fe nn no np nq b">node-pod</code>与节点服务器对话。</p><p id="bec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令应用服务:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="c054" class="nt md it nq b gy oj ok l ol om">kubectl apply -f node-service.yaml</span></pre><p id="c131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的后端步骤到此结束。我们现在可以开始开发我们的前端应用程序了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8de9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">前端</h1><p id="3be8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于前端，我使用一个简单的HTML文件和jQuery来保持本教程的简单明了。但是您可以使用自己选择的任何前端框架。无论您使用哪个框架，都不会影响这些步骤。</p><p id="d95d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了服务我们的前端应用程序，我们将使用<a class="ae ky" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a> web服务器。我们使用Nginx服务器的原因是它提供了一个代理。我们将需要Nginx代理将我们的请求传递给我们的节点部署。</p><p id="4d1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个名为<code class="fe nn no np nq b">index.html</code>的非常简单的HTML文件。我们将使用Ajax 来查询我们的节点服务器。</p><p id="8f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从网络浏览器，如果您尝试连接到<code class="fe nn no np nq b"><a class="ae ky" href="http://node-server:3000/api" rel="noopener ugc nofollow" target="_blank">http://node-server:3000/api</a></code>，您将得到“未找到主机”错误。这是因为DNS <code class="fe nn no np nq b">node-server</code>没有在互联网上注册。</p><p id="aa94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种解决方法是将请求发送到前端应用程序，比如说发送到一个路径<code class="fe nn no np nq b">/api</code>。使用Nginx，我们可以将查询转发给后端应用程序。</p><p id="0a4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的意思是，我们将把所有后端调用发送到前端应用程序中的<code class="fe nn no np nq b">/api</code>路径，并配置Nginx，使其将请求传递给<code class="fe nn no np nq b"><a class="ae ky" href="http://node-service/api" rel="noopener ugc nofollow" target="_blank">http://node-service/api</a></code>。</p><p id="847e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nn no np nq b">index.html</code>文件看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4de5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到我们如何使用<code class="fe nn no np nq b">/api</code>作为我们的网址了吗？</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="737c" class="nt md it nq b gy oj ok l ol om">const url = "/api/"</span></pre><p id="3788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将编写Nginx conf <code class="fe nn no np nq b">Nginx.conf</code>文件，将请求从路径<code class="fe nn no np nq b">/api</code>转发到<code class="fe nn no np nq b"><a class="ae ky" href="http://node-service/api" rel="noopener ugc nofollow" target="_blank">http://node-service/api</a></code>。</p><p id="2da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nn no np nq b">Nginx.conf</code>文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b7e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个配置文件告诉Nginx，对于路径<code class="fe nn no np nq b">/api</code>的所有请求，将请求发送到<code class="fe nn no np nq b"><a class="ae ky" href="http://node-service" rel="noopener ugc nofollow" target="_blank">http://node-service</a>:3000/api</code>。你可以在文档中阅读更多关于<code class="fe nn no np nq b">proxy_pass</code> <a class="ae ky" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><h2 id="a902" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">集装箱化前端</h2><p id="1380" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将为Kubernetes部署容器化应用程序。在我们的前端图像中，我们需要用conf文件替换默认的Nginx conf文件。</p><p id="90b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nn no np nq b">Dockerfile</code>会是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第4行从图像中删除默认的Nginx配置文件</p><p id="5111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第5行将我们的新配置文件复制到<code class="fe nn no np nq b">Conf.d</code>文件夹。</p><p id="cc30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们已经成功地为前端应用程序创建了Docker映像。让我们进入下一步，为我们的前端应用程序创建Kubernetes部署和服务。</p><h2 id="34e8" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">Kubernetes前端对象</h2><p id="fba9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Nginx的部署对象将与我们在后端应用程序中创建的部署对象非常相似。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8cab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe nn no np nq b">kubectl apply</code>之后，我们有一个名为<code class="fe nn no np nq b">frontend-deployment</code>的部署，它有一个名为<code class="fe nn no np nq b">frontend-pod</code>的pod的副本，该副本是使用<code class="fe nn no np nq b">frontend</code>映像制作的。</p><p id="bc99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们的<code class="fe nn no np nq b">nginx-service.yaml</code>文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="702f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这创建了一个名为<code class="fe nn no np nq b">frontend-service</code>的<code class="fe nn no np nq b">LoadBalancer</code>类型的服务，它被绑定到名为<code class="fe nn no np nq b">frontend-pod</code>的pod的所有副本。</p><p id="f047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的前端步骤到此结束。现在我们可以进行最后一步，即数据库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="992a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据库ˌ资料库</h1><p id="0540" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Kubernetes中部署我们的数据库是最简单的步骤，因为我们不需要为它创建任何Docker映像。而且非常容易配置。</p><p id="eadd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要创建MongoDB映像，因为我们可以直接使用来自<a class="ae ky" href="https://hub.docker.com/_/mongo" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>的MongoDB映像。我们可以直接开始编写部署对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这创建了一个简单的Mongo部署。容器中的<code class="fe nn no np nq b">env</code>键告诉Kubernetes，这些是创建图像时必须使用的环境值。我们基本上是告诉Kubernetes用pod的一个副本集<code class="fe nn no np nq b">mongo-pod</code>创建一个部署，它有一个Mongo容器，数据库的名称是<code class="fe nn no np nq b">database</code>。</p><p id="5f30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步，我们将编写我们的<code class="fe nn no np nq b">mongo-service</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="07c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在执行完<code class="fe nn no np nq b">kubectl apply</code>命令后，我们应该已经创建了一个名为<code class="fe nn no np nq b">mongo-service</code>的服务，该服务绑定到所有名为<code class="fe nn no np nq b">mongo-pad</code>的副本。现在您可以使用主机名<code class="fe nn no np nq b">mongo-pod</code>与MongoDB对话。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ce3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="c052" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有了这个，我们在Kubernetes中部署了我们的全栈应用。</p><p id="029b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Nginx <code class="fe nn no np nq b">proxy_pass</code>衍生工具，我们能够将前端部署连接到后端部署。大多数人在Kubernetes中连接前端和后端时都会遇到问题。</p><p id="e35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以按照上述步骤部署一个完整的全栈应用程序。</p><p id="851d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快乐编码。</p></div></div>    
</body>
</html>