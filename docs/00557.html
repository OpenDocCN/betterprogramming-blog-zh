<html>
<head>
<title>React Context API. Part 1 — Dark Theme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应上下文API。第1部分—黑暗主题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-context-api-part-1-dark-theme-3f00666cbacb?source=collection_archive---------2-----------------------#2019-06-10">https://betterprogramming.pub/react-context-api-part-1-dark-theme-3f00666cbacb?source=collection_archive---------2-----------------------#2019-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/204c54fffd8c1b82209d26908b79c17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZMCZiUqEpwkqPPdGP03_w.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@pathum_danthanarayana?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pathum Danthanarayana </a>在<a class="ae kc" href="https://unsplash.com/search/photos/dark-theme?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="89fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个系列中，我们将探索一些<a class="ae kc" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>上下文API的潜在用例。我还将分享我实现一些有用特性的方法。在第1部分中，我们将回顾UI主题，或者黑暗主题切换器。</p><p id="21c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Context是React解决道具钻孔问题的开箱即用的解决方案。与<a class="ae kc" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>一样，它允许我们创建一种全局状态(组件),可以从组件树的任何地方访问它。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/89eac40fa91e5e25a135897a0ae8dc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7gl-3SbI7MszLOCS1F953Q.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">带上下文的基本应用程序结构。</p></figure><p id="1607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当可能需要在整个应用程序的许多组件上访问数据时，上下文是最佳选择。</p><p id="13f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种数据的一些例子:</p><ul class=""><li id="0597" class="lg lh iq kf b kg kh kk kl ko li ks lj kw lk la ll lm ln lo bi translated">当前的UI主题。</li><li id="59e9" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">当前用户界面语言。</li><li id="762c" class="lg lh iq kf b kg lp kk lq ko lr ks ls kw lt la ll lm ln lo bi translated">用户的个人资料信息(头像、姓名等。).</li></ul><p id="b1da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将专注于实现一个UI主题特性，以及我是如何实现的。</p><p id="fb88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用React钩子和CSS变量来实现这个效果。这是我们将要使用的简单应用程序:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序组件</p></figure><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">卡片组件</p></figure><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">开关组件。我使用了<a class="ae kc" href="https://www.npmjs.com/package/react-icons" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> react-icons库</em> </a>来设计切换按钮的样式。</p></figure><p id="8876" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们给组件添加一些样式。</p><p id="143a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，我更喜欢使用CSS模块，并且每个组件都有单独的样式文件，但是在这个例子中，我们将把它们都写在一个<code class="fe lx ly lz ma b">index.css</code>中。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">为了专注于改变UI主题特性，我没有在这里包括CSS属性的其余部分。您可以在完整的index.css. <a class="ae kc" href="https://github.com/aleckan53/react-context-playground/blob/master/src/index.css" rel="noopener ugc nofollow" target="_blank">链接</a>中找到它们</p></figure><p id="02ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用CSS变量，而不是显式的颜色分配。这样以后更容易覆盖。</p><p id="8e2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要在应用程序的<code class="fe lx ly lz ma b">/src</code>目录下创建一个新文件，并将其命名为<code class="fe lx ly lz ma b">ThemeContext.js</code>。</p><p id="0165" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React提供了一个名为<code class="fe lx ly lz ma b">createContext</code>的函数。我们将使用它来创建我们的上下文。我们可以提供一个默认值作为参数。这对测试很有帮助，但是在我们的例子中，这只是为了自动完成的目的。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="6cee" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">语境。供应者</h1><p id="6700" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">每个上下文对象都带有一个提供者React组件，该组件允许组件的消费来订阅上下文更改。</p><p id="abdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，我们需要将所有的全局数据和功能放在提供者中，以便以后能够从树中的任何组件(消费者)访问它。</p><p id="d8f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建<code class="fe lx ly lz ma b">ThemeProvider</code>组件，就在<code class="fe lx ly lz ma b">ThemeContext</code>的下面。</p><p id="a4b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ma b">ThemeProvider</code>将返回带有value属性的<code class="fe lx ly lz ma b">ThemeContext.Provider</code>，该属性将具有当前的UI主题状态和一个切换它的功能。</p><p id="205b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe lx ly lz ma b">ThemeProvider</code>包装了我们的应用程序，我们需要在里面传递子组件。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="f648" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lx ly lz ma b">index.js</code>中，我们导入<code class="fe lx ly lz ma b">ThemeProvider</code>并将其包装在app组件周围:</p><pre class="lc ld le lf gt nl ma nm nn aw no bi"><span id="678e" class="np mj iq ma b gy nq nr l ns nt">...</span><span id="2f63" class="np mj iq ma b gy nu nr l ns nt">import { ThemeProvider } from './context/ThemeContext';</span><span id="58a3" class="np mj iq ma b gy nu nr l ns nt">ReactDOM.render(&lt;ThemeProvider&gt;&lt;App /&gt;&lt;/ThemeProvider&gt;, document.getElementById('root'));</span></pre><p id="02d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lx ly lz ma b">ThemeProvider</code>中，我们需要一种跟踪当前应用主题的方法。</p><p id="8cef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用<code class="fe lx ly lz ma b">useState</code>钩子将它存储在提供者的状态中。</p><pre class="lc ld le lf gt nl ma nm nn aw no bi"><span id="fd04" class="np mj iq ma b gy nq nr l ns nt">const [dark, setDark] = useState(false);</span></pre><p id="1913" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以切换状态来改变应用程序的主题。</p><p id="1401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了记住用户最后的选择，我们将最后选择的主题保存到浏览器的<code class="fe lx ly lz ma b">localStorage</code>中。</p><pre class="lc ld le lf gt nl ma nm nn aw no bi"><span id="553b" class="np mj iq ma b gy nq nr l ns nt">const toggle = () =&gt; {<br/>  setDark(!dark);<br/>  window.localStorage.setItem('darkTheme', !dark);<br/>};</span></pre><p id="f893" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要为新的颜色主题创建另一组颜色。我们还需要保存默认值，以便能够切换回来。</p><p id="3d31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们将颜色集存储在数组中。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将这些数组作为参数传递给<code class="fe lx ly lz ma b">applyTheme()</code>。它将数组转换成有效的CSS文本，并将其写入我们的根元素(&lt; html &gt;)。</p><pre class="lc ld le lf gt nl ma nm nn aw no bi"><span id="81f4" class="np mj iq ma b gy nq nr l ns nt">const applyTheme = theme =&gt; {<br/>  const root = document.getElementsByTagName('html')[0];<br/>  root.style.cssText = theme.join(';');<br/>}</span></pre><p id="2cc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将添加逻辑来决定应用哪个主题。</p><p id="811e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ma b">useLayoutEffect</code>钩子会处理好的。与<code class="fe lx ly lz ma b">useEffect</code>的主要区别在于<code class="fe lx ly lz ma b">useLayoutEffect</code>在元素呈现在页面上之前触发，这使得它适合于做布局工作。</p><p id="8836" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是它看起来的样子。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="94be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要将我们的<code class="fe lx ly lz ma b">Switch</code>组件连接到上下文。</p><p id="f82f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入<code class="fe lx ly lz ma b">ThemeContext</code>并将其作为参数传递给<code class="fe lx ly lz ma b">React.useContext</code>函数。然后，在变量中保存对其<code class="fe lx ly lz ma b">dark</code>和<code class="fe lx ly lz ma b">toggle</code>属性的引用。</p><pre class="lc ld le lf gt nl ma nm nn aw no bi"><span id="6be2" class="np mj iq ma b gy nq nr l ns nt">...</span><span id="1e2c" class="np mj iq ma b gy nu nr l ns nt">import ThemeContext from '../context/ThemeContext';</span><span id="fb7b" class="np mj iq ma b gy nu nr l ns nt">const { dark, toggle } = React.useContext(ThemeContext);</span><span id="19df" class="np mj iq ma b gy nu nr l ns nt">...</span></pre><p id="641b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以完全访问上下文值，并且我们可以在单击按钮时调用<code class="fe lx ly lz ma b">toggle()</code>函数来触发主题更改。</p><p id="ce8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将有条件地呈现图标的类，以根据当前活动的主题改变它的颜色。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8958" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！主题切换功能现在完全正常了。</p><p id="2b06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一种改进，我们可以添加CSS过渡，使颜色变化平滑。</p><pre class="lc ld le lf gt nl ma nm nn aw no bi"><span id="47e1" class="np mj iq ma b gy nq nr l ns nt">/* index.css */</span><span id="8a04" class="np mj iq ma b gy nu nr l ns nt">*:not(body) { transition: all .5s ease; }</span><span id="84a8" class="np mj iq ma b gy nu nr l ns nt">// typically I avoid using * selector</span></pre><p id="7470" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免第一次加载时身体无意中出现背景色动画，我们将在<code class="fe lx ly lz ma b">toggle()</code>函数中添加一个动画属性。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="5805" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">证明文件</h1><p id="bf28" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated"><a class="ae kc" href="https://dark-theme.olegakan5326.now.sh" rel="noopener ugc nofollow" target="_blank">现场演示</a> | <a class="ae kc" href="https://github.com/aleckan53/react-context-playground" rel="noopener ugc nofollow" target="_blank">回购</a></p><p id="3bc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这篇文章！</p><p id="4b24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一篇文章中，我们将探索<a class="ae kc" href="https://medium.com/better-programming/react-context-hooks-part-2-ui-language-switch-f4610a21379b" rel="noopener">如何使用上下文API </a>实现应用程序的UI语言改变特性。</p><p id="fa40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读和快乐编码。</p></div></div>    
</body>
</html>