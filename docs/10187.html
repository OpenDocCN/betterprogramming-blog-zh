<html>
<head>
<title>Layered Dependency Injection With Swift Property Wrappers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift属性包装器的分层依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-layered-dependency-injection-with-swift-property-wrappers-6e7a841f0934?source=collection_archive---------4-----------------------#2021-12-09">https://betterprogramming.pub/create-layered-dependency-injection-with-swift-property-wrappers-6e7a841f0934?source=collection_archive---------4-----------------------#2021-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3ff0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在编译时解决依赖关系</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/48f93665145ebe1b2a069684bb485b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bhtzF73jqYw2_FnL"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰里米·贝赞格在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="cdb7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目的</h1><ul class=""><li id="6004" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">依赖注入的简单解决方案</li><li id="7114" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">依赖关系的编译时解析</li><li id="ae1f" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">为不同的层提供不同范围的可注入值:视图模型、视图、路由器、交互器等。</li><li id="f8b1" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">减少通过<code class="fe ml mm mn mo b">init</code>方法传递的依赖项的数量</li><li id="979e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">避免在整个项目中传播来自外部库的抽象。</li></ul><h1 id="253a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">解决方案</strong></h1><p id="e9ce" class="pw-post-body-paragraph mp mq iq lq b lr ls jr mr lt lu ju ms lv mt mu mv lx mw mx my lz mz na nb mb ij bi translated">尽管解决方案是属性注入，但它也提供了通常归因于构造函数注入的好处。由于属性包装器和关键路径，这些成为可能。它们允许在编译时解决所有的依赖关系。如果缺少任何一项，项目就无法构建。这意味着具有这种依赖关系的每个实例都将在创建时进行设置。</p><p id="04a3" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">由于我们通过属性注入依赖，传递给<code class="fe ml mm mn mo b">init</code>方法的参数列表减少了。我们不需要在创建实例的每个地方传递所有的依赖关系。</p><p id="6be3" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">一个好的项目有一个层次结构。例如，如果我们遵循干净的架构，我们可能会有以下几层:视图、视图模型、交互器(用例)、应用程序状态等。最有可能的是，您不希望所有这些层都访问相同的依赖项。该解决方案使用关键路径来构建依赖关系，只为设计允许的每一层提供那些依赖关系。</p><p id="4137" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">让我们看看它是如何工作的。下面的代码样本来自一个测试项目。你可以在本文末尾找到一个链接。</p><h2 id="82f8" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lv nm nn li lx no np lk lz nq nr lm ns bi translated">注入的属性包装</h2><p id="a51a" class="pw-post-body-paragraph mp mq iq lq b lr ls jr mr lt lu ju ms lv mt mu mv lx mw mx my lz mz na nb mb ij bi translated">下面是我们实现属性包装器的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e42a" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">我们使用一个关键路径来标识注入的依赖项。这种关键路径的前缀决定了依赖关系的层范围。例如，注入到视图模型中，我们将使用<code class="fe ml mm mn mo b">\.viewModel.</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f19e" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">类似地，可以在keypath中使用前缀<code class="fe ml mm mn mo b">\.interactor.</code>来访问交互器的注入:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b696" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">这里一个很棒的事情是，你不需要指定一个可注入变量的类型。编译器通过keypath来推断它。</p><h2 id="fe18" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lv nm nn li lx no np lk lz nq nr lm ns bi translated">根依赖容器</h2><p id="4593" class="pw-post-body-paragraph mp mq iq lq b lr ls jr mr lt lu ju ms lv mt mu mv lx mw mx my lz mz na nb mb ij bi translated">层是可定制的。你在根<code class="fe ml mm mn mo b">DependencyInjection</code>类中指定它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="3752" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lv nm nn li lx no np lk lz nq nr lm ns bi translated">层</h2><p id="e50f" class="pw-post-body-paragraph mp mq iq lq b lr ls jr mr lt lu ju ms lv mt mu mv lx mw mx my lz mz na nb mb ij bi translated">在我们的例子中，我们只为两层提供注入:交互器和视图模型。协议允许我们隐藏容器的实现细节，例如，使用模拟注射进行测试。以下是协议的定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e793" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">两层都可以访问<code class="fe ml mm mn mo b">appState</code>。但是只有交互器可以调用<code class="fe ml mm mn mo b">network</code>。</p><p id="d1d8" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">如果我们为视图层设置注入，我们可能不会在那里添加<code class="fe ml mm mn mo b">appState</code>，只允许视图通过它们的视图模型访问<code class="fe ml mm mn mo b">appState</code>。</p><p id="2a94" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated"><code class="fe ml mm mn mo b">InteractorInjectionProtocol</code>的实际实现很简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="24da" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">对于<code class="fe ml mm mn mo b">ViewModelInjectionProtocol</code>，我们提供了两个实现，包括测试的模拟版本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="71cc" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">我们通过<code class="fe ml mm mn mo b">init</code>传递<code class="fe ml mm mn mo b">AppState</code>的一个实例，因为它是共享的。这里使用的关键字<code class="fe ml mm mn mo b">lazy</code>对于<code class="fe ml mm mn mo b">gitHubInteractor</code>来说并不重要，但是在单个应用程序运行期间，我们可能并不总是需要注入时使用它是合理的。</p><p id="3474" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">为了全面理解，让我们看看<code class="fe ml mm mn mo b">GitHubInteractor</code>和<code class="fe ml mm mn mo b">MockGitHubInteractor</code>的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f5ad" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">两个交互器实现相同的协议。在内部，他们也使用依赖注入机制。它们从交互层访问可注入值。因为所有的依赖项都被直接注入到属性中，所以我们不需要通过<code class="fe ml mm mn mo b">init</code>方法传递它们。</p><h2 id="758b" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lv nm nn li lx no np lk lz nq nr lm ns bi translated">装配</h2><p id="3297" class="pw-post-body-paragraph mp mq iq lq b lr ls jr mr lt lu ju ms lv mt mu mv lx mw mx my lz mz na nb mb ij bi translated">为了提供我们项目中所有可用注入的集合，我们将它作为计算属性添加到<code class="fe ml mm mn mo b">DependencyInjection</code>类的扩展中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="865d" class="pw-post-body-paragraph mp mq iq lq b lr nc jr mr lt nd ju ms lv ne mu mv lx nf mx my lz ng na nb mb ij bi translated">我们为应用程序本身使用不同的程序集，同时运行项目进行预览。因为预览中不需要网络调用。</p><h2 id="27b3" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lv nm nn li lx no np lk lz nq nr lm ns bi translated">试验</h2><p id="3eaf" class="pw-post-body-paragraph mp mq iq lq b lr ls jr mr lt lu ju ms lv mt mu mv lx mw mx my lz mz na nb mb ij bi translated">下面是我们如何在测试用例中设置我们的程序集:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="d21e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="9b3f" class="pw-post-body-paragraph mp mq iq lq b lr ls jr mr lt lu ju ms lv mt mu mv lx mw mx my lz mz na nb mb ij bi translated">所开发的解决方案具有以下主要优势:</p><ul class=""><li id="6c3d" class="lo lp iq lq b lr nc lt nd lv nv lx nw lz nx mb mc md me mf bi translated">尽管这是一个属性注入，但注入的值在对象构造时变得可用。解析是在编译期间执行的。关键路径的特征确保了这一点。</li><li id="d64e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">我们不会用额外的依赖来重载<code class="fe ml mm mn mo b">init</code>方法。依赖关系被直接注入到属性中。</li><li id="9b09" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">它允许您控制从不同层对依赖项的访问。</li><li id="f33d" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">这是一个简单的解决方案，不需要外部库的代码。</li></ul><h1 id="7ab3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">资源</h1><p id="dec2" class="pw-post-body-paragraph mp mq iq lq b lr ls jr mr lt lu ju ms lv mt mu mv lx mw mx my lz mz na nb mb ij bi translated">您可以在我的GitHub资源库中找到本文中使用的源代码:</p><ul class=""><li id="f9a6" class="lo lp iq lq b lr nc lt nd lv nv lx nw lz nx mb mc md me mf bi translated"><a class="ae kv" href="https://github.com/ihorvovk/Layered-Dependency-Injection" rel="noopener ugc nofollow" target="_blank">分层依赖注入</a></li></ul></div></div>    
</body>
</html>