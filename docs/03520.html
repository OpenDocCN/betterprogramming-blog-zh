<html>
<head>
<title>SOLID Principles Applied to Swift Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适用于快速开发的坚实原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solid-principles-application-to-swift-development-1de8d7c57fdf?source=collection_archive---------1-----------------------#2020-02-15">https://betterprogramming.pub/solid-principles-application-to-swift-development-1de8d7c57fdf?source=collection_archive---------1-----------------------#2020-02-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0ff5" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">巩固我们的Swift代码</h2></div><h1 id="1df6" class="kj kk iu bd kl km kn ko kp kq kr ks kt ka ku kb kv kd kw ke kx kg ky kh kz la bi translated">介绍</h1><p id="17b8" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">作为一名开发人员，你可能使用或听说过<a class="ae lx" href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" rel="noopener ugc nofollow" target="_blank">坚实的原则</a>。</p><p id="547c" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">这个首字母缩写词是由Robert c . Martin(Bob叔叔，也是de '<a class="ae lx" href="https://medium.com/@raulferrer/what-is-clean-architecture-188a65c7dd48" rel="noopener">Clean architecture</a>')在他的书<a class="ae lx" href="https://www.goodreads.com/book/%20show%20/%2084985.Agile_Software_Development_Principles_Patterns_and_Practices" rel="noopener ugc nofollow" target="_blank"><em class="md">Agile Software Development:Principles，Patterns，and Practices </em> </a>中介绍的，指的是面向对象编程的五个基本原则，它们与<a class="ae lx" href="https://www.raulferrergarcia.com/en/design-patterns-in-software/" rel="noopener ugc nofollow" target="_blank">设计模式</a>有关。</p><p id="7abd" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">如果我们应用这五个原则:</p><ul class=""><li id="2550" class="me mf iu ld b le ly lh lz lk mg lo mh ls mi lw mj mk ml mm bi translated">我们将有灵活的代码，我们可以很容易地改变，这将是可重用和可维护的。</li><li id="3754" class="me mf iu ld b le mn lh mo lk mp lo mq ls mr lw mj mk ml mm bi translated">开发的软件将是健壮的、稳定的和可伸缩的(我们可以很容易地添加新的特性)。</li><li id="1d3a" class="me mf iu ld b le mn lh mo lk mp lo mq ls mr lw mj mk ml mm bi translated">结合设计模式的使用，它将允许我们创建高度内聚(也就是说，系统的元素紧密相关)和松散耦合(元素之间的依赖程度低)的软件。</li></ul><h2 id="ac1d" class="ms kk iu bd kl mt mu dn kp mv mw dp kt lk mx my kv lo mz na kx ls nb nc kz nd bi translated">缩写词SOLID的由来</h2><p id="e362" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">缩写SOLID来自:</p><ul class=""><li id="16fd" class="me mf iu ld b le ly lh lz lk mg lo mh ls mi lw mj mk ml mm bi translated">单一责任原则</li><li id="aa89" class="me mf iu ld b le mn lh mo lk mp lo mq ls mr lw mj mk ml mm bi translated"><strong class="ld iv"> O </strong> (OCP):开/关原理</li><li id="3ec4" class="me mf iu ld b le mn lh mo lk mp lo mq ls mr lw mj mk ml mm bi translated"><strong class="ld iv"> L </strong> (LSP):利斯科夫替代原理</li><li id="f753" class="me mf iu ld b le mn lh mo lk mp lo mq ls mr lw mj mk ml mm bi translated"><strong class="ld iv"> I </strong> (ISP):接口隔离原则</li><li id="e8f2" class="me mf iu ld b le mn lh mo lk mp lo mq ls mr lw mj mk ml mm bi translated"><strong class="ld iv"> D </strong> (DIP):依存倒置原则</li></ul></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="aa66" class="kj kk iu bd kl km nl ko kp kq nm ks kt ka nn kb kv kd no ke kx kg np kh kz la bi translated">单一责任原则</h1><p id="fa29" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">根据这个原则，一个类应该有且只有一个改变的理由。也就是说，一个类应该只有一个责任。</p><p id="87dd" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">让我们看一个例子:</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="3771" class="nz kk iu nv b be oa ob l oc od">class LoginUser {<br/>    func login() {<br/>        let data = authenticareUserViaAPI()<br/>        let user = decodeUser(data: data)<br/>        saveToDB(array: array)<br/>    }<br/>    <br/>    private func authenticareUserViaAPI() -&gt; Data {<br/>        // Call server to authenticate and return user's info<br/>    }<br/>    <br/>    private func decodeUser(data: Data) -&gt; User {<br/>        // Decode data (Codable protocol) into User object<br/>    }<br/>    <br/>    private func saveUserInfoOnDatabase(user: User) {<br/>        // Save User info onto database<br/>    }<br/>}</span></pre><p id="0118" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">如上所述，该类提供了三个职责:<em class="md">认证</em>、<em class="md">解码信息</em>和<em class="md">保存信息</em>。为了实现唯一责任的原则，我们将这些责任提取到其他更小的类中</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="f542" class="nz kk iu nv b be oa ob l oc od">class LoginUser {<br/>    let oAuthHandler: OAuthHandler<br/>    let decodeHandler: DecodeHandler<br/>    let databaseHandler: DataBaseHandler<br/>    <br/>    init(oAuthHandler: OAuthHandler, decodeHandler: DecodeHandler, databaseHandler: DataBaseHandler) {<br/>        self.oAuthHandler = oAuthHandler<br/>        self.decodeHandler = decodeHandler<br/>        self.databaseHandler = databaseHandler<br/>    }<br/>    <br/>    func login() {<br/>        let data = oAuthHandler.authenticareUserViaAPI()<br/>        let user = decodeHandler.decodeUser(data: data)<br/>        databaseHandler.saveUserInfoOnDatabase(user: user)<br/>    }<br/>}<br/><br/>class OAuthHandler {<br/>    func authenticareUserViaAPI() -&gt; Data {<br/>        // Call server to authenticate and return user's info<br/>    }<br/>}<br/><br/>class DecodeHandler {<br/>    func decodeUser(data: Data) -&gt; User {<br/>        // Decode data (Codable protocol) into User object<br/>    }<br/>}<br/><br/>class DataBaseHandler {<br/>    func saveUserInfoOnDatabase(user: User) {<br/>        // Save User info onto database<br/>    }<br/>}</span></pre><h1 id="cfb8" class="kj kk iu bd kl km kn ko kp kq kr ks kt ka ku kb kv kd kw ke kx kg ky kh kz la bi translated">开/关原则</h1><p id="d5c5" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">根据这个原则，我们必须能够在不改变其行为的情况下扩展该类。这是通过抽象实现的。</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="0db1" class="nz kk iu nv b be oa ob l oc od">class Scrapper {<br/><br/>    func scrapVehicles() {<br/>        let cars = [<br/>            Car(brand: "Ford"),<br/>            Car(brand: "Peugeot"),<br/>            Car(brand: "Toyota"),<br/>        ]<br/><br/>        cars.forEach { car in<br/>            print(car.getScrappingAddress())<br/>        }<br/><br/>        let trucks = [<br/>            Truck(brand: "Volvo"),<br/>            Truck(brand: "Nissan"),<br/>        ]<br/><br/>        trucks.forEach { truck in<br/>            print(truck.getScrappingAddress())<br/>        }<br/>    }<br/>}<br/><br/>class Car {<br/>    let brand: String<br/><br/>    init(brand: String) {<br/>        self.brand = brand<br/>    }<br/><br/>    func getScrappingAddress() -&gt; String {<br/>        return "Cars scrapping address"<br/>    }<br/>}<br/><br/>class Truck {<br/>    let brand: String<br/><br/>    init(brand: String) {<br/>        self.brand = brand<br/>    }<br/><br/>    func getScrappingAddress() -&gt; String {<br/>        return "Trucks scrapping address"<br/>    }<br/>}</span></pre><p id="e8cf" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">每一款新车型都要重新实现<code class="fe oe of og nv b">getScrapingAddress()</code>功能，打破了开/关的原则。</p><p id="16dc" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">为了解决这一点，我们引入了包含<code class="fe oe of og nv b">getScrappingAddress()</code>方法的<code class="fe oe of og nv b">Scrappable</code>协议:</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="f4ba" class="nz kk iu nv b be oa ob l oc od">protocol Scrappable {<br/>    func getScrapingAddress() -&gt; String<br/>}<br/><br/>class Scrapper {<br/><br/>    func getScrapingAddress() {<br/>        let vehicles: [Scrappable] = [<br/>            Car(brand: "Ford"),<br/>            Car(brand: "Peugeot"),<br/>            Car(brand: "Toyota"),<br/>            Truck(brand: "Volvo"),<br/>            Truck(brand: "Nissan"),<br/>        ]<br/><br/>        vehicles.forEach { vehicle in<br/>            print(vehicle.getScrapingAddress())<br/>        }<br/>    }<br/>}<br/><br/>class Car: Scrappable {<br/>    let brand: String<br/><br/>    init(brand: String) {<br/>        self.brand = brand<br/>    }<br/><br/>    func getScrapingAddress() -&gt; String {<br/>        return "Cars scrapping address"<br/>    }<br/>}<br/><br/>class Truck: Scrappable {<br/>    let brand: String<br/><br/>    init(brand: String) {<br/>        self.brand = brand<br/>    }<br/><br/>    func getScrapingAddress() -&gt; String {<br/>        return "Trucks scrapping address"<br/>    }<br/>}</span></pre><h1 id="b8af" class="kj kk iu bd kl km kn ko kp kq kr ks kt ka ku kb kv kd kw ke kx kg ky kh kz la bi translated">利斯科夫替代原理</h1><p id="c6ff" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">Barbara Liskov在1987年提出的这个原则指出，在一个程序中，任何类都应该能够被它的一个子类替换，而不会影响它的功能。</p><p id="9acf" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">例如，假设我们有一个类，<code class="fe oe of og nv b">UserService</code>，它负责联系用户(例如，发送电子邮件)。</p><p id="db62" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">如果我们改变业务逻辑，例如，我们只能向17岁以上的用户发送电子邮件，我们可以创建一个子类来添加新的业务逻辑:</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="5bf3" class="nz kk iu nv b be oa ob l oc od">class UserService {<br/>    func contact(user: User) {<br/>        // Retrieve user from database<br/>    }<br/>}<br/><br/>class ValidUserService: Handler {<br/>    override func contact(user: User) {<br/>        guard user.age &gt; 17 else { return }<br/><br/>        super.contact(user: User)<br/>    }<br/>}</span></pre><p id="4b63" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">在这种情况下，Liskov替换原则没有得到满足，因为子类增加了一个条件(用户的年龄超过17岁)，这是<code class="fe oe of og nv b">UserService</code>类的客户所不期望的。</p><p id="fb54" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">我们可以通过不创建子类，并添加前置条件到<code class="fe oe of og nv b">UserService</code>(包括一个默认值)来解决这个问题:</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="a6ab" class="nz kk iu nv b be oa ob l oc od">class UserService {<br/>    func contact(user: User, minAge: Int = 0) {<br/>        guard user.age &gt; minAge else { return }<br/>        // Retrieve user from database<br/>    }<br/>}</span></pre><h1 id="fa4a" class="kj kk iu bd kl km kn ko kp kq kr ks kt ka ku kb kv kd kw ke kx kg ky kh kz la bi translated">界面分离原理</h1><p id="6c5f" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">接口分离原则表明，拥有特定于每个客户端的不同接口(协议)比拥有一个通用接口更好。</p><p id="3e4e" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">此外，它表明客户端不必实现他们不使用的方法。</p><p id="111c" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">例如，我们可以为动物创建一个包含置换方法的界面:</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="5306" class="nz kk iu nv b be oa ob l oc od">protocol AnimalProtocol {<br/>    func walk()<br/>    func swimm()<br/>    func fly()<br/>}<br/><br/>struct Animal: AnimalProtocol {<br/>    func walk() {}<br/>    func swimm() {}<br/>    func fly() {}<br/>}<br/><br/>struct Wale: AnimalProtocol {<br/>    func swimm() {<br/>        // Walw only needs to implement this function<br/>        // All the other functions are irrelavant<br/>    }<br/>    <br/>    func walk() {}<br/>    <br/>    func fly() {}<br/>}</span></pre><p id="e95b" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">然而，虽然<code class="fe oe of og nv b">Wale</code>采用了该协议，但有两个方法它没有实现。解决方案是建立三个接口(协议)，每个方法一个接口:</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="3ace" class="nz kk iu nv b be oa ob l oc od">protocol WalkProtocol {<br/>    func walk()<br/>}<br/><br/>protocol SwimmProtocol {<br/>    func swimm()<br/>}<br/><br/>protocol FlyProtocol {<br/>    func fly()<br/>}<br/><br/>struct Wale: SwimmProtocol {<br/>    func swimm() {}<br/>}<br/><br/>struct Crocodile: WalkProtocol, SwimmProtocol {<br/>    func walk()<br/>    func swimm() {}<br/>}</span></pre><h1 id="253e" class="kj kk iu bd kl km kn ko kp kq kr ks kt ka ku kb kv kd kw ke kx kg ky kh kz la bi translated">从属倒置原则</h1><p id="1264" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">根据依赖性倒置原则:</p><ul class=""><li id="f156" class="me mf iu ld b le ly lh lz lk mg lo mh ls mi lw mj mk ml mm bi translated">高级类不应该依赖低级类。两者都应该依赖于抽象。</li><li id="5f24" class="me mf iu ld b le mn lh mo lk mp lo mq ls mr lw mj mk ml mm bi translated">抽象不应该依赖于细节。细节应该取决于抽象。</li></ul><p id="742b" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">这个原则试图减少模块之间的依赖性，从而实现类之间的低耦合。</p><p id="4d26" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">让我们看看下面的例子:</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="ee20" class="nz kk iu nv b be oa ob l oc od">class User {<br/>    var name: String<br/>    <br/>    init(name: String) {<br/>        self.name = name<br/>    }<br/>}<br/><br/>class CoreData {<br/>    func save(user: User) {<br/>        // Save user on database<br/>    }<br/>}<br/><br/>class UserService {<br/>    func save(user: User) {<br/>        let database = CoreData()<br/>        database.save(user: user)<br/>    }<br/>}</span></pre><p id="9a1d" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">如果我们想使用<a class="ae lx" href="https://realm.io/products/realm-database/" rel="noopener ugc nofollow" target="_blank">领域数据库</a>而不是使用<code class="fe oe of og nv b">CoreData</code>来保存数据，会发生什么？</p><p id="211c" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">我们在示例中完成的类的实例化生成了一个强耦合，所以如果我们想要使用另一个数据库，我们将不得不重做代码。</p><p id="7eb8" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">要解决这个问题，我们可以按照上一篇文章中的解释，在建立数据库层时进行。</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="1a67" class="nz kk iu nv b be oa ob l oc od">protocol Storable { }<br/><br/>extension Object: Storable { } // Realm Database<br/>extension NSManagedObject: Storable { } // Core Data Database<br/>protocol StorageManager {<br/>  /// Save Object into Realm database<br/>  /// - Parameter object: Realm object (as Storable)<br/>  func save(object: Storable)<br/>}</span></pre><p id="1959" class="pw-post-body-paragraph lb lc iu ld b le ly jv lg lh lz jy lj lk ma lm ln lo mb lq lr ls mc lu lv lw in bi translated">现在我们有了采用<code class="fe oe of og nv b">Storable</code>协议的<code class="fe oe of og nv b">User</code>和采用<code class="fe oe of og nv b">StorageManager</code>协议的<code class="fe oe of og nv b">UserService</code>类，所以即使我们改变了数据库，我们也不需要改变整个实现代码:</p><pre class="nq nr ns nt gu nu nv nw bn nx ny bi"><span id="8469" class="nz kk iu nv b be oa ob l oc od">class User: Storable {<br/>    var name: String<br/>    <br/>    init(name: String) {<br/>        self.name = name<br/>    }<br/>}<br/><br/>class UserService: StorageManager {<br/>    func save(object: Storable) {<br/>        // Saves user to database<br/>    }<br/>}</span></pre><h1 id="ada6" class="kj kk iu bd kl km kn ko kp kq kr ks kt ka ku kb kv kd kw ke kx kg ky kh kz la bi translated">结论</h1><p id="e117" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">这些原则将允许我们在代码中创建可重用、可维护和高质量的组件，从而减少代码的刚性和脆弱性。</p></div></div>    
</body>
</html>