<html>
<head>
<title>Solidity Tutorial: All About Calldata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实度教程:关于Calldata的所有内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-tutorial-all-about-calldata-aebbe998a5fc?source=collection_archive---------0-----------------------#2022-10-29">https://betterprogramming.pub/solidity-tutorial-all-about-calldata-aebbe998a5fc?source=collection_archive---------0-----------------------#2022-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ca63" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解Solidity中以太坊交易的“数据”字段</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a00e6cc4d5121c9b9529d1ecd073c7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZTsQCIfq_DW761sUhFvug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><blockquote class="ky kz la"><p id="3e4d" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/solidity-tutorial-all-about-data-locations-dabd33212471"><em class="it"/></a><em class="it">子系列的第三部分。</em></p></blockquote><p id="b8e9" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">今天，我们将学习<code class="fe mc md me mf b">calldata</code>的特性，以及为什么应该优先于其他数据位置，如<code class="fe mc md me mf b">memory</code>。我们将使用来自<a class="ae ly" href="https://gnosis.io/" rel="noopener ugc nofollow" target="_blank"> Gnosis </a> safe契约的代码示例来理解与<code class="fe mc md me mf b">calldata</code>相关的三个EVM操作码。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="a494" class="mk ml it mf b gy mm mn l mo mp">Table of Contents</span><span id="72fe" class="mk ml it mf b gy mq mn l mo mp">Introduction<br/><a class="ae ly" href="#c451" rel="noopener ugc nofollow">Layout of calldata</a><br/><a class="ae ly" href="#8b66" rel="noopener ugc nofollow">Basics of calldata</a><br/><a class="ae ly" href="#3266" rel="noopener ugc nofollow">Accessing calldata in Solidity</a><br/><a class="ae ly" href="#a041" rel="noopener ugc nofollow">Calldata opcodes With Assembly</a><br/><a class="ae ly" href="#c9a6" rel="noopener ugc nofollow">Creating calldata for Low-level Calls</a><br/><a class="ae ly" href="#2eea" rel="noopener ugc nofollow">Extracting Bytes Calldata Slices</a><br/><a class="ae ly" href="#a299" rel="noopener ugc nofollow">calldata in Internal Functions</a><br/><a class="ae ly" href="#ce8d" rel="noopener ugc nofollow">calldata in Constructor</a></span></pre><h1 id="8d2a" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">介绍</h1><p id="57ea" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">如果你熟悉web3.js或ethers.js，你可能看过作为参数传递给<code class="fe mc md me mf b">.send({ ... })</code>或<code class="fe mc md me mf b">.sendTransaction({ ... })</code>的<code class="fe mc md me mf b">data</code>字段。</p><p id="12b0" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这就是calldata(简而言之)，或者“沿着消息调用发送的数据”(无论我们是指一个<code class="fe mc md me mf b">staticcall</code>，一个契约调用，还是一个改变任何形式的状态的实际事务——区块链状态还是契约状态，在这里都无关紧要)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/3a3b856e1f265802b3f7c686232de704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WM35ECxwYv4zBSle9mau4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">黄皮书对calldata有什么看法？(第21页，第4.2节&gt;交易&gt;数据)。</p></figure><p id="38ca" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">calldata是EVM中的一个特殊数据位置。它指的是在两个地址之间的任何消息调用事务中发送的原始十六进制字节。对于EVM，calldata中包含的任何数据都由地址(无论是EOA还是智能合同)作为输入给出，以执行外部调用。</p><p id="863d" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">当调用协定(从EOA或另一个协定)时，calldata是包含被调用函数的初始输入参数(=自变量)的数据位置。这里存储了<code class="fe mc md me mf b">public</code>或<code class="fe mc md me mf b">external</code>功能的参数。</p><p id="f2b0" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">看看其他编程语言，EVM中的calldata可与:</p><ul class=""><li id="f791" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated">C++中的动态内存(添加参考)。</li><li id="32b4" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">C#中的堆内存(添加引用)。</li></ul><h1 id="c451" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">呼叫数据的布局</h1><p id="ef6e" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">Calldata由字节组成，以与内存相同的方式连续排列。这与存储或堆栈等其他数据位置的布局相反，后者由字(32字节长)组成。</p><p id="6c92" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在EVM中，调用数据是一个字节可寻址空间，类似于EVM存储器。各种类型的变量在calldata中的布局方式与它们在内存中的布局方式非常相似。</p><p id="2da8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">对于读取，calldata的行为方式与内存相同:一次可以加载32个字节(<code class="fe mc md me mf b">mload</code> vs <code class="fe mc md me mf b">calldataload</code>)。但是，它对内存的行为有所不同，因为您不能写入内存。</p><p id="86cc" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">calldata是任何基于EVM的区块链都非常特定的数据位置，具有一些布局特异性:</p><ul class=""><li id="2d4e" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated">前4个字节对应于函数签名的选择器。</li><li id="7791" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">剩余的字节对应于函数的输入参数。每个输入参数的长度总是32个字节。如果其类型小于32字节，则该参数被填充。</li></ul><p id="74be" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><strong class="le iu">注意</strong>:根据输入参数的类型，输入参数被填充在右边或左边(例如，<code class="fe mc md me mf b">uintN</code>或<code class="fe mc md me mf b">address</code>被填充在左边，而<code class="fe mc md me mf b">bytesN</code>被填充在右边)。</p><h1 id="8b66" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">呼叫数据基础</h1><p id="c09c" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">Calldata经常与<code class="fe mc md me mf b">memory</code>混淆，或者被理解为“内存中的特定位置”。Calldata不同于memory，因为它是一个独立的数据位置。要理解它与<code class="fe mc md me mf b">memory</code>的区别，我们必须理解它的目的，但主要是它来自哪里。</p><p id="a822" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">要理解<code class="fe mc md me mf b">calldata</code>与<code class="fe mc md me mf b">memory</code>的区别，一个很好的问题是问“谁在calldata中创建数据？”vs“谁在内存中创建数据？”(“创建”和“分配”这两个词在这里可以互换使用)。</p><p id="2d4a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">以太坊栈交易所的这个<a class="ae ly" href="https://ethereum.stackexchange.com/a/74443" rel="noopener ugc nofollow" target="_blank">精彩回答</a>有助于明确区分。</p><blockquote class="oc"><p id="a800" class="od oe it bd of og oh oi oj ok ol lx dk translated">“思考(T7和T8之间的)区别以及如何使用它们的一个好方法是，<code class="fe mc md me mf b">calldata</code>由调用者分配，而<code class="fe mc md me mf b">memory</code>由被调用者分配。”—作者</p></blockquote><p id="dc38" class="pw-post-body-paragraph lb lc it le b lf om ju lh li on jx lk lz oo ln lo ma op lr ls mb oq lv lw lx im bi translated">这句话很有力量，总结的很好。让我们把它放在上下文中。从EOA或另一个合同<code class="fe mc md me mf b">Source</code>调用合同<code class="fe mc md me mf b">Target</code>时。</p><ul class=""><li id="fbcd" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated">调用者(=无论是EOA还是<code class="fe mc md me mf b">Source</code>契约)是创建要发送给<code class="fe mc md me mf b">Target</code>契约的数据的人。该数据在calldata中分配，并通过消息调用发送到目标。</li><li id="b3ad" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">被调用者(=合同<code class="fe mc md me mf b">Target</code>)使用calldata并使用内存做进一步的处理。正在处理的数据既可以从calldata加载，也可以从它自己的存储中加载。</li></ul><p id="a2c1" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">现在让我们看看calldata的主要特性。calldata是保存事务或调用的数据参数的数据位置。</p><ul class=""><li id="f204" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated">不可修改(只读)=您不能修改或更改呼叫数据中的数据。它不能被覆盖。</li><li id="ce31" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">几乎无限的大小=几乎无限的大小，没有固定的边界。</li><li id="2c0f" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">非常便宜且高效=读取+在调用中分配字节数据非常便宜且高效。</li><li id="a844" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">非持久性(事务完成后)</li><li id="f2f9" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">具体到交易和合同调用。</li></ul><h2 id="885f" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">呼叫数据不可修改</h2><p id="f8fb" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">让我们从了解<code class="fe mc md me mf b">calldata</code>在坚固性方面最重要的特征之一开始</p><blockquote class="oc"><p id="036a" class="od oe it bd of og oh oi oj ok ol lx dk translated">"存储在calldata中的数据是不可变的."—作者</p></blockquote><p id="2d33" class="pw-post-body-paragraph lb lc it le b lf om ju lh li on jx lk lz oo ln lo ma op lr ls mb oq lv lw lx im bi translated">当谈到Solidity中的呼叫数据时，这是需要理解的最重要的概念之一。</p><p id="23e7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在他非常深入的文章<a class="ae ly" href="https://ethdebug.github.io/solidity-data-representation/" rel="noopener ugc nofollow" target="_blank"> <em class="ld">“数据在实体中的表示</em></a><em class="ld">”</em>中，哈里·奥特曼陈述了一个关于复杂句子背后的calldata的重要事实:</p><blockquote class="ky kz la"><p id="e277" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">"[……]因此我们会说“calldata不能直接包含值类型”之类的话，只是因为Solidity不允许声明值类型的calldata变量(calldata中的原始值总是会在使用前复制到堆栈中)。显然，该值仍然存在于calldata中，但由于没有变量指向那里，所以这不是我们所关心的。”</p></blockquote><p id="b7d5" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">对我们来说重要的部分在括号之间:“calldata中的原始值在使用之前总是被复制到堆栈中。”</p><p id="8dc9" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">从这句话中，我们可以推断出三件事:</p><ol class=""><li id="a4c0" class="no np it le b lf lg li lj lz nq ma nr mb ns lx pc nu nv nw bi translated">calldata是不可变的:我们不能修改驻留在其中的数据。</li></ol><p id="ce72" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">结果是</p><p id="2ce5" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">2.calldata是只读的</p><p id="9105" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">3.当从calldata读取值时，值被复制到堆栈上。</p><p id="155c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">calldata是不可变的这一事实也导致了我们只能通过Solidity中的引用，使用<code class="fe mc md me mf b">calldata</code>关键字来访问calldata。</p><p id="820c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">任何用<code class="fe mc md me mf b">calldata</code>指定为数据位置的复杂类型变量都是只读的。无法修改该变量。如果变量作为函数参数传递或在函数体中定义，这一点适用。</p><p id="e740" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">让我们通过下面的Solidity代码片段来看看它的实际应用。如果你在Remix中粘贴这段代码，Solidity编译器会抱怨被指定为<code class="fe mc md me mf b">calldata</code>的<code class="fe mc md me mf b">input</code>变量，不允许你编辑它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="cf5a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">Calldata的大小几乎没有限制。</p><p id="3684" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">Calldata比内存有一个额外的好处:它的大小。</p><p id="9082" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">内存有最大大小限制。它最多可以容纳2 ** 64字节(= uint 64的最大值)。</p><p id="fa3c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">相比之下，calldata的大小实际上是无限的。这在黄皮书中都有描述，也可以从geth客户机源代码中的类型推断出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/3a3b856e1f265802b3f7c686232de704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WM35ECxwYv4zBSle9mau4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">黄皮书对calldata有什么看法？(第21页，第4.2节&gt;交易&gt;数据)。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/f43b7ce7dfb4bfac8d7f07f29c47eda9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IoUEZDihb9zoEDUuLl6rQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/ethereum/go-ethereum/blob/5f70f9fd37b14c6c8021cd277f9d620dbef7583b/core/types/transaction.go#L50-L59" rel="noopener ugc nofollow" target="_blank"> source: geth客户端源代码(Github)—core/types/transaction . go，第50–59行</a></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/91a302a2accff55372f785235ffcbb90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VbynQb-kgoCcGd2Or6zVjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/ethereum/go-ethereum/blob/5f70f9fd37b14c6c8021cd277f9d620dbef7583b/core/types/transaction.go#L77" rel="noopener ugc nofollow" target="_blank"> source: geth客户端源代码(Github)—core/types/transaction . go，第77行</a></p></figure><p id="b2c9" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这意味着，在某种程度上，“calldata可以根据需要保存任意多的字节。”然而，从技术上来说，调用数据和内存一样，也会受到阻塞气体限制的约束。</p><p id="caf4" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">然而，在calldata中分配更多字节的成本总是与内存成线性关系，而随着内存大小的增加，这种关系成平方关系。我们将在下一小节中看到这种差异。</p><h2 id="f1f8" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">Calldata非常便宜而且省油</h2><p id="8180" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">尽管calldata是只读的，并且不能写入，但它仍然有成本。但与其他数据位置相比，这一成本在汽油方面相对便宜。</p><p id="45cb" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">calldata的每个字节都有一个开销:</p><ul class=""><li id="ae31" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated">4气为0字节<code class="fe mc md me mf b">0x00</code></li><li id="a5db" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">16 gas为非零字节。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/6bc85d4a34ef6132d07cdbc4fa4ba052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MatO99UIeXFqsQrp_jXrfA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://ethereum.github.io/yellowpaper/paper.pdf" rel="noopener ugc nofollow" target="_blank">资料来源:以太坊黄皮书，附录G，费用表(柏林版，第27页)</a></p></figure><blockquote class="ky kz la"><p id="be54" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le iu">注</strong>:非零字节气费变更为<a class="ae ly" href="https://eips.ethereum.org/EIPS/eip-2028" rel="noopener ugc nofollow" target="_blank"> EIP 2028 —交易数据气费下调</a>。降低calldata的气体成本的目的是提高链上的可伸缩性。由于呼叫数据更便宜，每个事务可以容纳更多的呼叫数据字节，一般来说，单个块可以容纳更多的数据(《EIP》的作者称之为“呼叫数据的更高带宽”)。</p><p id="5edb" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">EIP 2028鼓励第2层可扩展性解决方案。就像洋葱的各层一样，高消耗的操作(存储读/写+计算)被移到外层(离链),并引入数据传输。这采用证明系统/欺诈证明的形式(在单个证明tx中批量处理多个交易)，或者通过calldata将数据放在主链上。</p><p id="0c90" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">保持调谐！我们将在本文后面的第2层环境中研究calldata:)</p></blockquote><p id="19fb" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">类似地，操作码<code class="fe mc md me mf b">CALLDATALOAD</code>从calldata读取一个32字节的字只需要3个gas，方法是将它从calldata加载到堆栈上。</p><p id="9e96" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">相比之下，使用<code class="fe mc md me mf b">MLOAD</code>操作码从内存读取的成本取决于内存的当前大小和<a class="ae ly" href="https://www.evm.codes/about" rel="noopener ugc nofollow" target="_blank">内存扩展成本</a>。</p><h2 id="855a" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">Calldata特定于外部调用，例如Gnosis</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/29b5481c193fb9dfad4df0fbc32f648e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zmrEwXPhNmJ3Ph4-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ly" href="https://cryptoouf.com/reviews/gnosis" rel="noopener ugc nofollow" target="_blank">cryptoouf.com</a></p></figure><p id="2e04" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如上所述，<code class="fe mc md me mf b">calldata</code>通常指来自外部交易(eoa)或合同调用的数据。它只特定于消息调用，而不特定于契约创建事务(我们将在下面的“构造函数中的调用数据”一节中看到这种差异)</p><p id="64d8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">让我们使用一个流行项目的可靠性代码的例子:来自<a class="pj pk ep" href="https://medium.com/u/e7281ad70ea?source=post_page-----aebbe998a5fc--------------------------------" rel="noopener" target="_blank"> Gnosis </a>的Gnosis-Safe。</p><p id="4766" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">Gnosis-Safe有一个<code class="fe mc md me mf b">setUp(...)</code>功能，用于初始化保险箱的存储。你可以看到第一个参数是拥有保险箱的所有者 <code class="fe mc md me mf b"><a class="ae ly" href="https://github.com/safe-global/safe-contracts/blob/186a21a74b327f17fc41217a927dea7064f74604/contracts/GnosisSafe.sol#L76" rel="noopener ugc nofollow" target="_blank">address[]</a></code>的<a class="ae ly" href="https://github.com/safe-global/safe-contracts/blob/186a21a74b327f17fc41217a927dea7064f74604/contracts/GnosisSafe.sol#L76" rel="noopener ugc nofollow" target="_blank">数组。这些用数据位置<code class="fe mc md me mf b">calldata</code>指定，因为该功能被定义为<code class="fe mc md me mf b">external</code>。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/3872da503863c1252f8ce53033f8c2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbfaU3pjv9i7L1huTnWwYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/safe-global/safe-contracts/blob/186a21a74b327f17fc41217a927dea7064f74604/contracts/GnosisSafe.sol#L76" rel="noopener ugc nofollow" target="_blank">来源:gnosis safe . sol(Github.com)</a></p></figure><h1 id="3266" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">在Solidity中访问呼叫数据</h1><p id="bbb8" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">让我们看一下黄皮书。被定义为执行环境的呼叫数据包含以下字段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/40f5beecfe4cecafdb00f127cae951b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*9A8uXwK3HVOj-mELtb6_kA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://ethereum.github.io/yellowpaper/paper.pdf" rel="noopener ugc nofollow" target="_blank">资料来源:以太坊黄皮书，第13页，第9.3节</a></p></figure><p id="ecee" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">此类字段可通过全局变量<code class="fe mc md me mf b">msg.</code>在Solidity中访问。此全局变量允许访问呼叫数据中的不同信息，包括以下内容:</p><ul class=""><li id="dcfe" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated"><code class="fe mc md me mf b">msg.sender</code> =发起消息呼叫的地址。</li><li id="7826" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated"><code class="fe mc md me mf b">msg.value</code> =在调用或事务中发送的值。</li><li id="42ff" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated"><code class="fe mc md me mf b">msg.sig</code> =函数标识符(函数签名的keccak256散列的前4个字节)。这相当于访问calldata的前4个字节。(展示一个例子)</li><li id="2025" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">需要解释</li><li id="c2d4" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated"><code class="fe mc md me mf b">gasleft()</code> =交易中剩余的可用气体量。</li></ul><blockquote class="ky kz la"><p id="f8ea" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在0.6.4版本的Solidity中，数据位置calldata仅适用于外部函数调用的参数。<br/>从Solidity 0.6.4开始，calldata作为一个数据位置也可以为公共、内部或私有函数的参数指定。</p><p id="735c" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">gasleft()以前被称为msg.gas，但在0.5.0中被删除了</p></blockquote></div><div class="ab cl pn po hx pp" role="separator"><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps"/></div><div class="im in io ip iq"><h2 id="7e36" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">消息.信号</h2><p id="3be0" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">calldata的前4个字节引用函数选择器。它是被调用函数的选择器。</p><p id="43e2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">它可以通过取函数签名的keccak256散列的前4个字节来获得。例如，对于以下功能:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="3bb9" class="mk ml it mf b gy mm mn l mo mp">function withdraw(uint256a amount) external {}</span></pre><p id="310c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">函数签名可以派生为函数名，参数类型放在括号中。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="71a1" class="mk ml it mf b gy mm mn l mo mp">withdraw(uint256)</span></pre><p id="78bd" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">散列函数签名将导致以下结果:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="71fc" class="mk ml it mf b gy mm mn l mo mp">keccak256("withdraw(uint256)") = 0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f</span></pre><p id="dafd" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">功能选择器仅对应前4个字节，为<code class="fe mc md me mf b">0x2e1a7d4d</code>。</p><p id="4a6e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如果函数包含多个参数，则要哈希的函数签名中的参数类型必须是用逗号“，”分隔的参数，不能有空格。例如，ERC20中流行的<code class="fe mc md me mf b">transfer</code>函数。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="365d" class="mk ml it mf b gy mm mn l mo mp">// function definition<br/>function transfer(address to, uint256 amount) public returns (bool)</span><span id="e758" class="mk ml it mf b gy mq mn l mo mp">// signature<br/>transfer(address,uint256)</span><span id="d117" class="mk ml it mf b gy mq mn l mo mp">// keccak256("transfer(address,uint256)")<br/>0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b</span><span id="ac89" class="mk ml it mf b gy mq mn l mo mp">selector = 0xa9059cbb</span></pre><p id="bf34" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">最后，当函数参数是复杂或动态类型并指定数据位置时，函数签名从不包括数据位置。例如，ERC721中包含第四个参数<code class="fe mc md me mf b">bytes memory data</code>的常用<code class="fe mc md me mf b">safeTransferFrom</code>函数。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="fc55" class="mk ml it mf b gy mm mn l mo mp">// function definition<br/>function safeTransferFrom(<br/>    address from,        <br/>    address to,        <br/>    uint256 tokenId,        <br/>    bytes memory data    <br/>) public</span><span id="1ba2" class="mk ml it mf b gy mq mn l mo mp">// signature<br/>safeTransferFrom(address,address,uint256,bytes)</span><span id="af0b" class="mk ml it mf b gy mq mn l mo mp">// keccak256("safeTransferFrom(address,address,uint256,bytes)")<br/>0xb88d4fde60196325a28bb7f99a2582e0b46de55b18761e960c14ad7a32099465</span><span id="b5e1" class="mk ml it mf b gy mq mn l mo mp">selector = 0xb88d4fde</span></pre><p id="6118" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">EVM使用calldata的选择器来标识在一次调用中必须执行哪个函数。</p><p id="bcf0" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">因此，您可以使用全局成员<code class="fe mc md me mf b">msg.sig</code>访问函数选择器。</p><p id="0eb8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">您还可以使用calldata切片进行如下提取。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="f721" class="mk ml it mf b gy mm mn l mo mp">bytes4 selector = msg.data[4:]</span></pre><blockquote class="ky kz la"><p id="7a90" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le iu">注:</strong> <code class="fe mc md me mf b"><em class="it">msg.sig </em></code>用于施工人员</p><p id="0e66" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在构造函数中，当创建代码运行时，没有4字节的偏移量。这是因为在构造函数中，calldata是空的(特殊变量<code class="fe mc md me mf b"><em class="it">msg.sig</em></code>被填充以包含4个零字节)。我们将在下面看到更多的细节。</p></blockquote></div><div class="ab cl pn po hx pp" role="separator"><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps"/></div><div class="im in io ip iq"><h2 id="49a7" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">消息.数据</h2><p id="dda0" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">全局<code class="fe mc md me mf b">msg.data</code>让您可以访问整个调用数据，包括函数选择器。</p><p id="85d3" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">calldata由我们之前看到的函数选择器(4个字节)和传递给函数的其余参数(如果给定的话)组成。</p><p id="bdac" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在calldata的上下文中，这些参数通常被称为输入数据。</p><p id="067e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">需要记住的一点是，输入数据参数的长度是32字节。任何需要传递给函数的参数都可以添加到32字节的片段中。</p><p id="a16b" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这些被称为“字”,跟随在交易输入数据的签名散列之后。</p><h1 id="a041" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">调用程序集中的数据操作码</h1><p id="21da" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">EVM提供了三个主要的操作码来与calldata交互。</p><ul class=""><li id="a27f" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated"><code class="fe mc md me mf b">CALLDATALOAD</code> =允许从作为参数给出的特定偏移量开始，从calldata加载一个32字节的字。</li><li id="a9fd" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated"><code class="fe mc md me mf b">CALLDATASIZE</code> =返回calldata中包含的字节数</li><li id="b1bc" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated"><code class="fe mc md me mf b">CALLDATACOPY</code> =将给定数量的字节从calldata中的源复制到内存中的指定目的地。</li></ul><p id="074b" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">Solidity提供了这些操作码的内联汇编版本。</p><p id="a1a2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">为了更好地理解它们，让我们重新使用Gnosis安全契约中的一个例子。<code class="fe mc md me mf b">GnosisSafeProxy.sol</code>(一个通用代理契约)是一个用来理解作为数据位置的<code class="fe mc md me mf b">calldata</code>的例子。</p><p id="2fdd" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">通过在构造函数中指定实现地址，将一个<code class="fe mc md me mf b">GnosisSafeProxy</code>链接到部署上的实现契约。</p><p id="a0ec" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这个单例代理只包含一个函数:<code class="fe mc md me mf b">fallback()</code>函数。对契约的任何调用都在这个函数中结束。然后，<code class="fe mc md me mf b">fallback()</code>函数将获取调用数据，并通过<code class="fe mc md me mf b">delegatecall</code>将其发送给实现契约(由变量<code class="fe mc md me mf b">singleton</code>定义)。因为它是一个<code class="fe mc md me mf b">delegatecall</code>，函数的逻辑将在代理契约的上下文中运行(执行<code class="fe mc md me mf b">delegatecall</code>)，并且代理契约的存储/状态将被更新。</p><p id="56b6" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><code class="fe mc md me mf b">delegatecall</code>对存储器中的数据进行操作。因此，为了使回退功能起作用，必须首先将所有调用数据复制到内存中。</p><blockquote class="ky kz la"><p id="4c5d" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">关于代理调用如何工作的更多细节，请参见文章<a class="ae ly" href="https://jeancvllr.medium.com/solidity-tutorial-all-about-addresses-ffcdf7efc4e7" rel="noopener">“关于地址的一切”</a></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/19e13331ef652ad6498c9365a8183b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRGdoMl6L1aIqNqfVg72Hg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/safe-global/safe-contracts/blob/da66b45ec87d2fb6da7dfd837b29eacdb9a604c5/contracts/proxies/GnosisSafeProxy.sol" rel="noopener ugc nofollow" target="_blank">来源:Github上的GnosisSafeProxy.sol契约</a></p></figure><p id="62d8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这个代码片段中的<code class="fe mc md me mf b">fallback()</code>函数使用了与calldata相关的三个操作码。</p><h2 id="7cd4" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">调用数据加载</h2><p id="941d" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated"><code class="fe mc md me mf b">calldataload</code>操作码将32字节的事务数据加载到堆栈上。它只需要一个参数，如下所示:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="fdb1" class="mk ml it mf b gy mm mn l mo mp">calldataload(startingOffset)</span></pre><ul class=""><li id="bc8d" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated">开始加载的calldata中的<code class="fe mc md me mf b">startingOffset</code> (= index)。</li></ul><p id="a2b2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">然后，它将从calldata中的指定偏移量开始将32个字节加载到堆栈上。</p><p id="d430" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在Gnosis示例中，<code class="fe mc md me mf b">calldataload</code>从calldata的开头(偏移量0)开始加载32个字节。然后，它比较calldata的前4个字节是否对应于函数签名<code class="fe mc md me mf b">masterCopy()</code>的散列。</p><p id="2019" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">通过用一些零<code class="fe mc md me mf b">0000...</code>填充文字<code class="fe mc md me mf b">0xa619486e</code>来进行比较，使其长度达到32个字节。两个值(文字十六进制字符串和从calldata加载的内容)通过相等操作码<code class="fe mc md me mf b">eq()</code>进行比较。</p><p id="90f6" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如果匹配(calldata是<code class="fe mc md me mf b">masterCopy()</code>的函数选择器)，则不进行约定调用。<code class="fe mc md me mf b">masterCopy()</code>函数将返回实现契约的地址。因此，为了避免进行合同调用(这会造成不必要的开销和浪费)，我们返回变量<code class="fe mc md me mf b">_singleton</code>(包含实现地址)。</p><h2 id="fbc5" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">调用数据副本</h2><p id="4a81" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated"><code class="fe mc md me mf b">calldatacopy</code>在内存中复制一定数量字节的交易数据。<code class="fe mc md me mf b">calldata</code>操作码有三个参数:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="e5fe" class="mk ml it mf b gy mm mn l mo mp">calldatacopy(<br/>    memoryDestinationOffset, <br/>    calldataStartOffset, <br/>    nbOfBytes<br/>)</span></pre><ul class=""><li id="d6d9" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated">内存中的<code class="fe mc md me mf b">memoryDestinationOffset</code>，结果将被复制到那里。</li><li id="843f" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">调用数据中开始复制的<code class="fe mc md me mf b">calldataStartOffset</code>。</li><li id="3c9d" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">要复制的<code class="fe mc md me mf b">nbOfBytes</code>。</li></ul><p id="f47a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在gnosis示例中，这个操作码在fallback函数中用于将所有的calldata复制到一个内存指针(=发送到契约的所有数据有效负载)。将所有有效载荷复制到内存后，由下一行的<code class="fe mc md me mf b">delegatecall</code>消耗。</p><p id="af72" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><code class="fe mc md me mf b">GnosisSafeProxy</code>契约如何加载整个调用数据？如果您查看<code class="fe mc md me mf b">calldatacopy</code>操作码的第三个参数，您会看到用于该参数的值本身就是一个操作码。</p><h2 id="9d38" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">calldatasize</h2><p id="7a09" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated"><code class="fe mc md me mf b">calldatasize</code>操作码返回事务数据的字节大小。它在栈顶输出结果。这不需要任何争论。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="0047" class="mk ml it mf b gy mm mn l mo mp">calldatasize()</span></pre><p id="9741" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">正如上一节所解释的，它用于将整个calldata加载到内存中，以便它可以被<code class="fe mc md me mf b">delegatecall</code>操作码使用。</p><h1 id="c9a6" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">为低级别呼叫创建呼叫数据</h1><p id="8bd2" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">我们了解到，tx/message调用的数据字段中包含的内容使智能合约能够知道要执行和运行哪部分代码。我们命名为<code class="fe mc md me mf b">calldata</code>的这个数据字段是一个字节序列，包含要调用的函数的bytes4函数选择器+它的参数。我总是将整个calldata(字节4选择器+函数参数)命名为有效负载(不是恶意软件术语)。</p><blockquote class="ky kz la"><p id="d69e" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">有效载荷是<a class="ae ly" href="https://en.wikipedia.org/wiki/Data_transmission" rel="noopener ugc nofollow" target="_blank">发送数据</a>的一部分，即实际的预期消息。<a class="ae ly" href="https://en.wikipedia.org/wiki/Header_(computing)" rel="noopener ugc nofollow" target="_blank">头</a>和<a class="ae ly" href="https://en.wikipedia.org/wiki/Metadata" rel="noopener ugc nofollow" target="_blank">元数据</a>仅被发送以启用有效载荷传送。(维基百科)。</p></blockquote><p id="d46b" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">当通过<code class="fe mc md me mf b">address(target_contract).call(calldataPayload)</code>进行外部低级调用时，有多种方法来构建将在tx/msg调用中传递的calldata。</p><p id="550a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们将在下面看到所有可用的选项来构建这样的呼叫数据作为一个<code class="fe mc md me mf b">bytes</code>值，这样它就可以通过一个低层<code class="fe mc md me mf b">.call()</code>发送。这将包括新推出的<code class="fe mc md me mf b">abi.encodeCall(...)</code>。</p><p id="e0ea" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">想象一下这个示例场景:a <code class="fe mc md me mf b">CallerContract</code>与a <code class="fe mc md me mf b">DeployedContract</code>交互。<code class="fe mc md me mf b">CallerContract</code>旨在调用<code class="fe mc md me mf b">DeployedContract</code>中的<code class="fe mc md me mf b">add(uint256)</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="7f64" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">将数据作为文字字符串调用</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/8c75f3c6936d05c3138c73816e29e56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JeggSyiHStQYAcHL0cQ4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Calldata.md" rel="noopener ugc nofollow" target="_blank">来源:Github，calldata.md上关于坚固性的一切</a></p></figure><h2 id="e3d0" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">以十六进制“…”字符串形式调用数据</h2><p id="f8b3" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">这与前面的例子有细微的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/fdbfa4787ae6c78d41bd35d4ac65f74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zq9IKRjp9Ujm_TlRa6zglA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Calldata.md" rel="noopener ugc nofollow" target="_blank">来源:Github，calldata.md </a>上关于可靠性的一切</p></figure><h2 id="11d5" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">通过使用keccak256手动创建字节4选择器来调用数据</h2><p id="a5aa" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">下面，我们根据ABI指定的规则手动计算函数选择器。我们执行以下操作:</p><ol class=""><li id="8368" class="no np it le b lf lg li lj lz nq ma nr mb ns lx pc nu nv nw bi translated">哈希函数签名<code class="fe mc md me mf b">keccak256</code> +只保留前4个字节。</li><li id="c33b" class="no np it le b lf nx li ny lz nz ma oa mb ob lx pc nu nv nw bi translated">在末尾追加函数调用的参数。</li></ol><p id="a221" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">对于附加/连接，我们使用<code class="fe mc md me mf b">abi.encodePacked(...)</code>按照ABI规范将任何实体类型转换为低级字节表示。(<code class="fe mc md me mf b">bytes.concat(...)</code>不允许我们这样做，因为它只能接受固定大小的字节)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/e09def8e0afb9ba2003626b2b4521216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyo0yvylGAWuobr15haD0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Calldata.md" rel="noopener ugc nofollow" target="_blank">来源:Github，calldata.md </a>上关于可靠性的一切</p></figure><h2 id="65d9" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">使用<code class="fe mc md me mf b">abi.encodeWithSignature</code>调用数据</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/25156e1e4639c95ce1ec593e2e580f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDdOBai1_yUOKl1mKS3r8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Calldata.md" rel="noopener ugc nofollow" target="_blank">来源:Github，calldata.md上关于坚固性的一切</a></p></figure><h2 id="728c" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">使用<code class="fe mc md me mf b">abi.encodeWithSelector + bytes4 value</code>调用数据</h2><p id="5ef9" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">在这个例子中，函数选择器被手动写成一个<code class="fe mc md me mf b">bytes4</code>文本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/eac36a0fae5037831d6bad43035bff15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2cr-vUTZM2h14z-Oz4usg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Calldata.md" rel="noopener ugc nofollow" target="_blank">来源:Github，calldata.md上关于坚固性的一切</a></p></figure><p id="230b" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">您还可以通过以下方式生成字节4选择器:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="9e83" class="mk ml it mf b gy mm mn l mo mp">bytes4(keccak256("add(uint256)"))</span></pre><h2 id="7dc8" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">使用<code class="fe mc md me mf b">abi.encodeWithSelector + functionName.selector</code>调用数据</h2><p id="44b8" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">手动计算或生成函数选择器可能很棘手，而且容易出错。事实上，例如，提供给<code class="fe mc md me mf b">abi.encodeWithSignature(...)</code>的字符串中的一个错别字可能会生成错误的选择器。</p><p id="fe26" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这个例子是我最喜欢的例子之一，我强烈推荐它。您可以使用内置实体成员<code class="fe mc md me mf b">.selector</code>从函数中提取选择器。合同的每个功能都有这个特性(包括<code class="fe mc md me mf b">contract</code>和<code class="fe mc md me mf b">interface</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/e8395218547b1360e3984f8b345aa3b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0_ZjGEe1qVdrhsg7kZJPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Calldata.md" rel="noopener ugc nofollow" target="_blank">来源:Github，calldata.md上关于坚固性的一切</a></p></figure><h2 id="98e5" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">使用<code class="fe mc md me mf b">abi.encodeCall</code>调用数据</h2><p id="a59e" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">这个新语法是在Solidity 0.8.11中引入的。它将类型安全检查添加到提供的参数中。唯一的区别是我们脱离了函数选择器的概念，而是使用了函数指针。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/a8937214a538014fb83091fdf6af1cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNNkYCj9huIdXgRmofTgmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Calldata.md" rel="noopener ugc nofollow" target="_blank">来源:Github，calldata.md </a>上关于可靠性的一切</p></figure><h1 id="2eea" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从呼叫数据中提取切片</h1><blockquote class="ky kz la"><p id="0e51" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">语法<code class="fe mc md me mf b"><em class="it">data[start:end]</em></code>只适用于指向<code class="fe mc md me mf b"><em class="it">calldata</em></code>的<code class="fe mc md me mf b"><em class="it">bytes</em></code>变量，不适用于<code class="fe mc md me mf b"><em class="it">memory</em></code>。</p></blockquote><p id="85c5" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们了解到calldata是一个连续的<code class="fe mc md me mf b">bytes</code>字符串。您可以使用呼叫数据切片提取Solidity中的一部分呼叫数据。Solidity的<a class="ae ly" href="https://blog.soliditylang.org/2020/05/26/array-slices/" rel="noopener ugc nofollow" target="_blank"> 0.6.0主版本提供了这个特性。</a></p><p id="34b2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">呼叫数据切片使您能够获取呼叫数据的切片。返回的切片类型为<code class="fe mc md me mf b">bytes</code>。它通过指定以下内容来工作:</p><ul class=""><li id="e5d8" class="no np it le b lf lg li lj lz nq ma nr mb ns lx nt nu nv nw bi translated">开始切片的偏移量。</li><li id="f58a" class="no np it le b lf nx li ny lz nz ma oa mb ob lx nt nu nv nw bi translated">帮助确定切片结束位置的偏移量。</li></ul><p id="59ab" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">冒号<code class="fe mc md me mf b">:</code>分隔开始和结束。您也可以发出开始或结束。省略开始将默认从偏移量0开始切片。省略end默认切片到calldata中的最后一个字节。</p><p id="3cdd" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在两种情况下切片是可以使用和有用的。</p><p id="0027" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">案例1:直接从整个calldata切片— <code class="fe mc md me mf b">msg.data</code>。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="0574" class="mk ml it mf b gy mm mn l mo mp">msg.data[start:end]</span></pre><p id="ea3a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">案例2:用数据位置calldata对a <code class="fe mc md me mf b">bytes</code>进行切片。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="e5de" class="mk ml it mf b gy mm mn l mo mp">function example(bytes calldata input) public {<br/>    bytes calldata secondThirdBytes = input[1:3];<br/>}</span></pre><p id="1e07" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">让我们用一些例子来说明。</p><h2 id="dc45" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">提取函数选择器</h2><p id="b676" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">可以通过对calldata的前4个字节进行切片来提取函数的签名。这相当于<code class="fe mc md me mf b">msg.sig</code>(除了<code class="fe mc md me mf b">msg.sig</code>会自动强制转换到前4个字节。下面，我们通过显式转换进行转换)。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="7768" class="mk ml it mf b gy mm mn l mo mp">bytes4 selector = msg.data[:4];</span></pre><blockquote class="ky kz la"><p id="8665" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le iu">注意:</strong>从<code class="fe mc md me mf b">bytes</code>转换到<code class="fe mc md me mf b">bytesN</code>是<a class="ae ly" href="https://github.com/ethereum/solidity/releases/tag/v0.8.5" rel="noopener ugc nofollow" target="_blank">从Solidity 0.8.5开始可用。</a></p></blockquote><h2 id="fd5e" class="mk ml it bd ms or os dn mw ot ou dp na lz ov ow nc ma ox oy ne mb oz pa ng pb bi translated">提取字节片</h2><p id="d857" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">以<code class="fe mc md me mf b">bytes</code>数据<code class="fe mc md me mf b">0xcafecafebeefbeeff00df00d</code>为例。</p><p id="297e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">您可以使用开始和结束提取呼叫数据的不同部分，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/35b6e5c2b58af37ecb4af366705da553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vHDfup_bn5dEK5C4aczwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/Calldata.md" rel="noopener ugc nofollow" target="_blank">来源:Github上关于可靠性的所有内容，calldata.md </a></p></figure><h1 id="a299" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">调用内部函数中的数据</h1><p id="940d" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">在Twitter上与一些Solidity开发者讨论时，我被要求解释以下内容:</p><p id="2692" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><em class="ld">“为什么不能将一个</em> <code class="fe mc md me mf b"><em class="ld">memory</em></code> <em class="ld">变量传递给一个以</em> <code class="fe mc md me mf b"><em class="ld">calldata</em></code> <em class="ld">为参数的内部函数？”</em></p><p id="ab9a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">"但是为什么你可以反过来做呢:把一个calldata变量传递给一个内部函数，这个函数把内存作为一个参数？"</p><p id="c0c8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">让我们用图片来展示答案。为什么下面的代码会编译？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/2ceaabcc93dcdd84c92cf38fe51b4fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7zkOel6tAHBDvEUrwLMBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><p id="de11" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">而这两个代码片段不会编译并返回错误？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/72657b8003bb22142236d971739458c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATTy-R06z5aPV4GS-L5Iww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/f8515e32a53247978560dfee5ef40443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sag_K1-hbV16aVk6jfN2nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qg"><img src="../Images/45ceefbc6efc80db72aaabebc366e16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6Tt9cZ3fSwCElHlPop_BQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><p id="0f9e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">答案在于<code class="fe mc md me mf b">calldata</code>和<code class="fe mc md me mf b">memory</code>的特性。正如我们已经看到的，calldata是只读的。相反，内存是一个可读可写的数据位置。</p><p id="93a2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">让我们回到第一个编译的例子。在本例中，EVM可以将变量从calldata移动到内存中。我们可以将这个流程表示如下:</p><p id="abe8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">EVM能够做到这一点:<code class="fe mc md me mf b">calldata</code> → ✅ <code class="fe mc md me mf b">memory</code></p><p id="eecf" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">当一个<code class="fe mc md me mf b">calldata</code>引用被传递给一个接受<code class="fe mc md me mf b">memory</code>作为函数参数的内部函数时，EVM可以通过两种方式将这个值从calldata移动到内存中:</p><ol class=""><li id="310a" class="no np it le b lf lg li lj lz nq ma nr mb ns lx pc nu nv nw bi translated">使用操作码<code class="fe mc md me mf b">calldataload</code>(将值从calldata加载到stacl)，然后使用<code class="fe mc md me mf b">mstore</code>(将加载的值写入内存)。</li><li id="0218" class="no np it le b lf nx li ny lz nz ma oa mb ob lx pc nu nv nw bi translated">使用操作码<code class="fe mc md me mf b">calldatacopy</code>在单个步骤中将值从calldata直接移动到内存中。</li></ol><blockquote class="ky kz la"><p id="4718" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le iu">注:</strong>实际上，值并不是从真正意义上的calldata中<em class="it"/>“移动”出来的。它们是相当抄袭的。操作码<code class="fe mc md me mf b"><em class="it">calldataload</em></code>和<code class="fe mc md me mf b"><em class="it">calldatacopy</em></code>都创建副本。calldata中的数据是不可变的，只制作其副本。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/2ceaabcc93dcdd84c92cf38fe51b4fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7zkOel6tAHBDvEUrwLMBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><p id="1b90" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">另一方面，所示的两个代码示例没有编译，因为EVM不能在另一个方向移动值(从内存到calldata)。</p><p id="9385" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">EVM无法做到这一点:<code class="fe mc md me mf b">calldata</code> ❌ ← <code class="fe mc md me mf b">memory</code></p><p id="3c7e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">正如我们所看到的，calldata是只读的，没有与写入calldata相关联的操作码(只有要读取的操作码)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/72657b8003bb22142236d971739458c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATTy-R06z5aPV4GS-L5Iww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><p id="cccb" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这使我们看到calldata是一个单向的数据位置:来自calldata的值只能被加载。因此，来自calldata的值总是:</p><ol class=""><li id="bc51" class="no np it le b lf lg li lj lz nq ma nr mb ns lx pc nu nv nw bi translated">使用<code class="fe mc md me mf b">calldataload</code>或<code class="fe mc md me mf b">calldatacopy</code>加载(=复制)到堆栈中。</li><li id="1316" class="no np it le b lf nx li ny lz nz ma oa mb ob lx pc nu nv nw bi translated">然后加载/复制的值被移入<code class="fe mc md me mf b">storage</code>、<code class="fe mc md me mf b">memory</code>或<code class="fe mc md me mf b">code</code>(对于构造函数中的<code class="fe mc md me mf b">immutable</code>)。</li></ol><h1 id="ce8d" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">调用C语言中的数据<code class="fe mc md me mf b">onstructor</code></h1><p id="4d10" class="pw-post-body-paragraph lb lc it le b lf ni ju lh li nj jx lk lz nk ln lo ma nl lr ls mb nm lv lw lx im bi translated">有一种特殊情况，calldata的行为有所不同。构造函数就是这种情况。</p><p id="63ba" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在构造函数的上下文中，数据位置<code class="fe mc md me mf b">calldata</code>不能作为函数参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/164bbbb7bed64219848b82e45d42bb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0R0pamwES5PZDfl__HLRQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qi"><img src="../Images/0801efaee7ff1b3be02d33e254b5ec97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1fa-PoEhpDetBuS74I-Yg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><p id="d2f3" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">原因是，当部署协定并且构造函数运行时，calldata总是为空。在部署事务期间，合同创建代码不会进入<code class="fe mc md me mf b">data</code>字段(=调用数据)。相反，合同创建代码进入交易的<code class="fe mc md me mf b">init</code>字段。</p><p id="d0c3" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这在黄皮书中有描述(见下面截图)。<code class="fe mc md me mf b"><strong class="le iu">data</strong></code> <strong class="le iu"> </strong>字段用于消息调用，只能对存储了一些代码的地址进行调用(也称为智能契约)。当构造函数运行时，地址是已知的，但是没有字节码存储在被部署的契约的地址下。</p><p id="1e46" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">因此，在构造函数上下文中的calldata中没有4字节的偏移量(<code class="fe mc md me mf b">bytes4</code>函数选择器)。特殊变量<code class="fe mc md me mf b">msg.sig</code>被填充以包含4个零字节</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qj"><img src="../Images/05cb225dc1619413363826e1a959003d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVyAAmQ3ixjg0Er3B8fVug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ly" href="https://ethereum.github.io/yellowpaper/paper.pdf" rel="noopener ugc nofollow" target="_blank">资料来源:以太坊黄皮书，柏林版，第5页</a></p></figure><p id="d576" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们可以在下面的截图中看到这种行为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qk"><img src="../Images/cc6ce6d60fcc4ec3ccf60ce6e077bfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RsEf4bTwoS0m8t0W6NfFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><p id="b2e6" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在部署时，我们将来自calldata的值分配给状态变量。这就是我们所获得的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/57d2f604651d7125ed549d061a1ab287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*nooonLHJNZuo2lytFvEVuA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:作者</p></figure><h1 id="48bc" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">参考</h1><div class="qm qn gp gr qo qp"><a href="https://github.com/safe-global/safe-contracts/blob/da66b45ec87d2fb6da7dfd837b29eacdb9a604c5/contracts/proxies/GnosisSafeProxy.sol" rel="noopener  ugc nofollow" target="_blank"><div class="qq ab fo"><div class="qr ab qs cl cj qt"><h2 class="bd iu gy z fp qu fr fs qv fu fw is bi translated">safe-contracts/gnosis safe proxy . sol at da 66 b 45 EC 87 D2 FB 6 da 7 DFD 837 b 29 ea CDB 9 a 604 c 5…</h2><div class="qw l"><h3 class="bd b gy z fp qu fr fs qv fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="qx l"><p class="bd b dl z fp qu fr fs qv fu fw dk translated">github.com</p></div></div><div class="qy l"><div class="qz l ra rb rc qy rd ks qp"/></div></div></a></div><div class="qm qn gp gr qo qp"><a href="https://ethereum.org/en/developers/tutorials/short-abi/#:~:text=A%20byte%20of%20calldata%20costs,on%20L2%20is%2022100%20gas" rel="noopener  ugc nofollow" target="_blank"><div class="qq ab fo"><div class="qr ab qs cl cj qt"><h2 class="bd iu gy z fp qu fr fs qv fu fw is bi translated">呼叫数据优化的简短ABIs | ethereum.org</h2><div class="qw l"><h3 class="bd b gy z fp qu fr fs qv fu fw dk translated">april波默兰兹2022年4月1日15分钟阅读这篇文章，你会了解到乐观的累积，成本…</h3></div><div class="qx l"><p class="bd b dl z fp qu fr fs qv fu fw dk translated">ethereum.org</p></div></div><div class="qy l"><div class="re l ra rb rc qy rd ks qp"/></div></div></a></div><div class="qm qn gp gr qo qp"><a href="https://eips.ethereum.org/EIPS/eip-2028" rel="noopener  ugc nofollow" target="_blank"><div class="qq ab fo"><div class="qr ab qs cl cj qt"><h2 class="bd iu gy z fp qu fr fs qv fu fw is bi translated">EIP-2028年:交易数据天然气成本降低</h2><div class="qw l"><h3 class="bd b gy z fp qu fr fs qv fu fw dk translated">我们建议将call data(gtxdata非零)的gas成本从当前的每字节68 gas降低到每字节16 gas</h3></div><div class="qx l"><p class="bd b dl z fp qu fr fs qv fu fw dk translated">eips.ethereum.org</p></div></div></div></a></div><div class="qm qn gp gr qo qp"><a href="https://ethdebug.github.io/solidity-data-representation/" rel="noopener  ugc nofollow" target="_blank"><div class="qq ab fo"><div class="qr ab qs cl cj qt"><h2 class="bd iu gy z fp qu fr fs qv fu fw is bi translated">固体中的数据表示</h2><div class="qw l"><h3 class="bd b gy z fp qu fr fs qv fu fw dk translated">适用于代码调试器和其他调试相关实用程序的编写人员。作者哈里·奥特曼[@haltman-at]发表…</h3></div><div class="qx l"><p class="bd b dl z fp qu fr fs qv fu fw dk translated">ethdebug.github.io</p></div></div></div></a></div><div class="qm qn gp gr qo qp"><a href="https://medium.com/@devrann.simsek/solidity-msg-sender-9072c1561966" rel="noopener follow" target="_blank"><div class="qq ab fo"><div class="qr ab qs cl cj qt"><h2 class="bd iu gy z fp qu fr fs qv fu fw is bi translated">可靠性—消息发送者</h2><div class="qw l"><h3 class="bd b gy z fp qu fr fs qv fu fw dk translated">在这一章中，我们将学习Solidity中的Msg.sender。</h3></div><div class="qx l"><p class="bd b dl z fp qu fr fs qv fu fw dk translated">medium.com</p></div></div><div class="qy l"><div class="rf l ra rb rc qy rd ks qp"/></div></div></a></div><div class="qm qn gp gr qo qp"><a href="https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory" rel="noopener  ugc nofollow" target="_blank"><div class="qq ab fo"><div class="qr ab qs cl cj qt"><h2 class="bd iu gy z fp qu fr fs qv fu fw is bi translated">什么时候应该使用calldata，什么时候应该使用内存？</h2><div class="qw l"><h3 class="bd b gy z fp qu fr fs qv fu fw dk translated">memory和calldata(以及storage)是定义存储变量的数据区域的关键字。要回答…</h3></div><div class="qx l"><p class="bd b dl z fp qu fr fs qv fu fw dk translated">ethereum.stackexchange.com</p></div></div><div class="qy l"><div class="rg l ra rb rc qy rd ks qp"/></div></div></a></div></div></div>    
</body>
</html>