<html>
<head>
<title>Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从属倒置原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solid-swift-by-examples-part-five-a860b86b85f5?source=collection_archive---------2-----------------------#2019-08-03">https://betterprogramming.pub/solid-swift-by-examples-part-five-a860b86b85f5?source=collection_archive---------2-----------------------#2019-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fc2d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Swift实例中的坚实原则</h2><div class=""/><div class=""><h2 id="4dca" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">坚固的雨燕</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/8a118e25627a1ef77787cef3b03c6637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*or6to6ZTDpLJPJXR"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">paweczerwi324ski</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="24fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是坚实的原则系列的最后一部分。在以前的文章中，我们讨论了什么是可靠原则，它们试图解决什么，以及什么是SRP(I)、OCP(II)、LSP(III)和ISP(IV)。</p><p id="5d1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在这里看到以前的原则:</p><div class="me mf gp gr mg mh"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-one-35018d53d3e6" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">坚固的雨燕</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">完整指南第一部分</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-two-82ac3c457e4e" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">开闭原理</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">在第一部分，我们描述了什么是坚实的原则和他们试图解决什么，解释了第一…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-three-675672c1ec20" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">利斯科夫替代原理</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">这是关于坚实原理的出版物的第三部分。在以前的文章中，我们讨论了什么是固体…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="mx l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-four-ec31bdb2872" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">界面分离原理</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">坚实的原则通过swift中的例子坚实的Swift这是关于坚实的原则的出版物的第四部分。在…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="my l ms mt mu mq mv lb mh"/></div></div></a></div><p id="5687" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这一部分中，我们将探讨以下原理(DI或DIP):</p><p id="cb6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">依赖倒置从90年代开始流行，但是当Robert C. Martin(著名的Bob叔叔)假定它是面向对象编程的一个伟大原则时，它变得更加流行。</p><p id="f1a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他将其定义为两个部分:</p><blockquote class="mz"><p id="d822" class="na nb it bd nc nd ne nf ng nh ni md dk translated">“高层模块不应该依赖低层模块。两者都应该依赖于抽象。”</p><p id="9503" class="na nb it bd nc nd ne nf ng nh ni md dk translated">“抽象不应该依赖于细节。细节应该依赖于抽象。”</p></blockquote><p id="cd47" class="pw-post-body-paragraph li lj it lk b ll nj kd ln lo nk kg lq lr nl lt lu lv nm lx ly lz nn mb mc md im bi translated">首先，我们来定义一下什么是低级和高级模块。</p><ul class=""><li id="dba7" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md nt nu nv nw bi translated">一个<em class="nx">低级模块</em>是一段代码，它必须实现特定或具体的功能。例如，向我们的API发出请求的类、数据库类或特定的UI元素，如自定义地图。所有这些都提供特定的低级功能。</li><li id="127a" class="no np it lk b ll ny lo nz lr oa lv ob lz oc md nt nu nv nw bi translated">一个<em class="nx">高级模块</em>是一段拥有核心应用功能的代码，它可能需要一些低级模块。例如，一个处理登录用例的<code class="fe od oe of og b">LoginManager</code>类。</li></ul><p id="b10e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实现这一原则的关键是引入一个抽象(Swift的协议)，由高层模块拥有，并反转<strong class="lk jd"> <em class="nx"> </em> </strong>对低层模块的依赖以符合该抽象。</p><p id="b311" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这使得较低级别的模块“依赖”于较高级别的模块所要求的，实现了该原则的第一部分。</p><p id="2c38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">先说个例子。</p><p id="b501" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们假设我们必须从一个API或数据库中获取用户信息，我们做了这样的事情:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用户照片服务</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用户经理</p></figure><p id="d6aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码正在工作，从我们的API中检索最新的用户照片。</p><p id="b8c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们有了一个新的需求，一旦连接丢失，就用数据库请求替换当前的API请求。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用户照片服务</p></figure><p id="76fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们在前面的章节中了解到的，我们正在打破其他原则，例如单一责任和开闭原则。</p><p id="9cc3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用抽象来适当地设计它，使用依赖倒置原则，看看我们如何能避免这种混乱。</p><p id="ee18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先让我们创建我们的抽象:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用户照片服务协议</p></figure><p id="2500" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现这一抽象，我们创建了两个新的服务:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">APIUserPhotoService</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据库用户照片服务</p></figure><p id="358b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而且，我们保持我们的<code class="fe od oe of og b">UserManager</code>干净:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一个用户管理器，现在干净了</p></figure><p id="5193" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用它，我们得到以下结果:</p><pre class="ks kt ku kv gt oj og ok ol aw om bi"><span id="1f7e" class="on oo it og b gy op oq l or os">let apiService = ApiUserPhotoService()</span><span id="ab80" class="on oo it og b gy ot oq l or os">var userManager = UserManager(service: apiService)</span><span id="a174" class="on oo it og b gy ot oq l or os">userManager.fetchUserPhoto(by: “123123”)</span><span id="3e1e" class="on oo it og b gy ot oq l or os">//PRINTED RESULT <strong class="og jd">API REQUEST HERE</strong></span><span id="e806" class="on oo it og b gy ot oq l or os">let dbService = DatabaseUserPhotoService()</span><span id="6dbf" class="on oo it og b gy ot oq l or os">userManager.service = dbService</span><span id="b9ad" class="on oo it og b gy ot oq l or os">userManager.fetchUserPhoto(by: “12313”)</span><span id="02dc" class="on oo it og b gy ot oq l or os">//PRINTED RESULT <strong class="og jd">DB REQUEST HERE</strong></span></pre><p id="87f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里做的是引入一个<code class="fe od oe of og b">UserPhotoService</code>抽象(协议)来定义<code class="fe od oe of og b">fetchUserPhoto(by, completionHandler)</code>方法。</p><p id="9908" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，在两个服务的完成处理程序中，我们将照片作为<code class="fe od oe of og b">Data</code>发回，避免了每个服务类解析时的问题(API响应和数据库响应可能会得到不同的响应类型)。</p><p id="02cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有其他好处，比如如果我们收到一个请求，要将我们的数据库更改为一个<a class="ae lh" href="https://realm.io/products/realm-database/" rel="noopener ugc nofollow" target="_blank">领域</a>的数据库，我们只需要创建一个新的<code class="fe od oe of og b">RealmUserPhotoService</code>，从<code class="fe od oe of og b">UserPhotoService</code>开始实现。</p><p id="d967" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这种方法，我们可以根据需要从我们的<code class="fe od oe of og b">UserManager</code>更改<code class="fe od oe of og b">UserPhotoService</code>，因此如果我们没有使用<code class="fe od oe of og b">APIUserPhotoService</code>的连接，我们可以简单地使用<code class="fe od oe of og b">DatabaseUserPhotoService</code>来代替。</p><p id="80c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当通过使用协议接口抽象将依赖关系相互隔离时，进行更改就变成了换入另一个插件。</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h1 id="ecb9" class="pb oo it bd pc pd pe pf pg ph pi pj pk ki pl kj pm kl pn km po ko pp kp pq pr bi translated">结论</h1><p id="bbe9" class="pw-post-body-paragraph li lj it lk b ll ps kd ln lo pt kg lq lr pu lt lu lv pv lx ly lz pw mb mc md im bi translated">依赖是一种风险，我们通常在类中有很多依赖。根据这个原则，我们分离那些依赖关系，并为可能的变更请求做准备。</p><p id="4ff2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，开发新特性和测试可以是完全独立和有趣的，因为我们只需要实现一个<code class="fe od oe of og b">MockUserPhotoService</code>来测试我们的<code class="fe od oe of og b">UserManager</code>。</p><p id="436d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一原则将指导你未来的应用程序架构设计决策，因为如果你的应用程序架构合理，即使第三方框架(如Realm)关闭，你也可以很容易地用你想要的东西替换它。</p><p id="8dfb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">记住，我们将面临三个常见的问题:脆弱、不动和僵硬，所以让我们运用我们坚实的原则来面对它们。</p><p id="5d19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些原则并不完美，这并不意味着我们将成为最伟大的开发者，但当你不得不做出决定时，它会产生影响。有了可重用和可维护的代码，我们的生活会变得更加有趣。</p><p id="50ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望您喜欢SOLID系列的最后一章，并发现它很有帮助。感谢阅读。</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h1 id="ea3d" class="pb oo it bd pc pd pe pf pg ph pi pj pk ki pl kj pm kl pn km po ko pp kp pq pr bi translated">参考</h1><div class="me mf gp gr mg mh"><a href="https://martinfowler.com/articles/dipInTheWild.html" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">在野外浸泡</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">Brett L. Schuchert Brett是一个多面手，努力做好最基本的事情。他总是在寻找新的…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">martinfowler.com</p></div></div><div class="mq l"><div class="px l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/@mglover/dependency-inversion-principle-c0264a405d57" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">从属倒置原则</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">依存倒置原则(DIP)是其中一个坚实的原则。它涉及模块之间的关系…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://codeburst.io/solid-design-principle-using-swift-fa67443672b8" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">使用Swift的可靠设计原则</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">坚实的原则是实现/创建有效的、可维护的、可扩展的和松散的…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">codeburst.io</p></div></div><div class="mq l"><div class="py l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/swift-india/solid-principles-part-5-dependency-inversion-principle-a0a890de71c2" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">从属倒置原则</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">依赖性反转原理是解耦软件模块的一种特定形式。高级模块提供…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="pz l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/the-aesthetic-programmer/ios-solid-principles-pt-5-dependency-inversion-principle-70f25e86f259" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">iOS —固体原理第5部分—依赖性反转原理</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">DIP——依赖性倒置原则，陈述如下:</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="qa l ms mt mu mq mv lb mh"/></div></div></a></div></div></div>    
</body>
</html>