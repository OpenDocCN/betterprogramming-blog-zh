<html>
<head>
<title>How to Write a Concurrent FTP Server in Go (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中编写并发FTP服务器(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-a-concurrent-ftp-server-in-go-part-2-4a59f4216639?source=collection_archive---------2-----------------------#2020-06-05">https://betterprogramming.pub/how-to-write-a-concurrent-ftp-server-in-go-part-2-4a59f4216639?source=collection_archive---------2-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="add0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更改目录、列出目录内容和下载文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d94ec3222fb5bcf1ce26db10ccee6427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQJTBdEks8432E6R93SkjQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@abrkett?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Adam Birkett </a>在<a class="ae ky" href="https://unsplash.com/s/photos/files?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/@angusmorrison/how-to-write-a-concurrent-ftp-server-in-go-part-1-3904f2e3a9e5" rel="noopener"> <strong class="lb iu">第1部分</strong> </a>中，我们学习了如何并发地服务多个客户端，设计了一个结构来表示FTP连接，将客户端命令路由到它们的服务器端处理程序，并讲述了发送响应的基本知识。现在我们已经准备好FTP的主要部分:操作目录和下载文件。</p><p id="9dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提醒一下，这里有<code class="fe lv lw lx ly b">ftp.Serve</code>，路由器将命令从客户端发送到它们的处理函数。我们今天要研究的就是这些处理函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="784d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">用户</h1><p id="f848" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">当FTP客户端建立到服务器的连接时，它做的第一件事就是提供关于用户的信息。与SFTP(安全FTP)不同，Bog标准FTP依赖于基本的、未加密的用户名和密码传输，容易受到密码嗅探和中间人攻击。</p><p id="d459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将在本地运行您的服务器和客户端，所以我们会以简单的名义忍受那些明显的漏洞——但是请不要尝试运行任何重要的东西。</p><p id="47bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们甚至允许匿名访问我们的FTP服务器，盲目地相信任何连接的人不会去他们不应该去的地方，窃取敏感文件。一个可怕的政策，但它将允许我们快速地为整个服务器建立框架，并根据您的选择进行改进。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="32b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">ftp.Serve</code>遇到<code class="fe lv lw lx ly b">USER</code>命令时，它将参数传递给<code class="fe lv lw lx ly b">ftp.Conn</code> : <code class="fe lv lw lx ly b">(c *Conn) user</code>的处理程序方法。由此，很容易想象如何对照已知用户及其访问权限的数据库来检查细节。一旦通过身份验证，用户名和特权可以作为附加字段存储在<code class="fe lv lw lx ly b">ftp.Conn</code>实例中。</p><p id="2270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们对网络安全如此漠不关心，以至于我们简单地用适当的成功代码将用户名回显给客户机:<code class="fe lv lw lx ly b">230 User %s logged in, proceed.</code></p><p id="18c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在客户端，它看起来类似于这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/6b2d8b673febe53ba58bd4fe4e465338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GI8ds8PeT1H8y4fGcAEv-g.png"/></div></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="750c" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">cd/CWD</h1><p id="f3fe" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">切换目录既简单又重要。当您向FTP客户端提交一个命令(如<code class="fe lv lw lx ly b">cd ../parent_folder</code>)时，它会将该消息作为<code class="fe lv lw lx ly b">CWD ../parent_folder</code>发送给服务器。<code class="fe lv lw lx ly b">ftp.Serve</code>将文件路径传递给<code class="fe lv lw lx ly b">cwd</code>，这是我们专有的<code class="fe lv lw lx ly b">ftp.Conn</code>的一种方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="83a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在检查了参数的数量之后，我们构建了一个“绝对”路径，使用服务器的根目录作为它的根。最简单的形式是将path arg连接到当前工作目录的末尾，然后将结果连接到<code class="fe lv lw lx ly b">rootDir</code>的末尾。</p><p id="79d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在响应更改成功之前，我们需要验证目录是否存在并且可以访问。有可能这个程序，或者如果你已经扩展了<code class="fe lv lw lx ly b">USER</code>处理程序，这个<code class="fe lv lw lx ly b">Conn</code>的用户，没有权限读取目标目录。</p><p id="2d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go的<code class="fe lv lw lx ly b">os.Stat</code>返回关于目标文件的信息和一个错误，如果文件不能被访问，这个错误是非零的。如果是这种情况，我们记录它并响应<code class="fe lv lw lx ly b">550 Requested action not taken. File unavailable.</code>否则，我们更新<code class="fe lv lw lx ly b">ftp.Conn</code>的<code class="fe lv lw lx ly b">workDir</code>并响应一个<code class="fe lv lw lx ly b">200</code>成功消息。</p><p id="dde1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想通过改进这个天真的实现来挑战自己，请考虑如何阻止用户访问服务器根目录下的文件。目前，没有什么可以阻止他们进入<code class="fe lv lw lx ly b">cd ../../../../../../..</code>并接触到各种他们不应该接触的东西。</p><p id="8e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，不断向不断增长的<code class="fe lv lw lx ly b">workDir</code>追加新的路径参数是可怕的内存管理，也会降低文件查找的速度。探索标准库的<code class="fe lv lw lx ly b">filepath.Clean</code>如何帮助解决这个问题。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0cbf" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">ls/列表</h1><p id="ba89" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">既然用户可以改变目录，他们会想知道里面有什么。客户端的<code class="fe lv lw lx ly b">ls path/to/file</code>命令以<code class="fe lv lw lx ly b">LIST path/to/file</code>的形式到达服务器，我们有一个<code class="fe lv lw lx ly b">(c *Conn) list</code>处理函数与之匹配也就不足为奇了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a7fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们从服务器<code class="fe lv lw lx ly b">rootDir</code>、连接的<code class="fe lv lw lx ly b">workDir</code>和提供给<code class="fe lv lw lx ly b">ls</code>的可选文件路径arg中构建一个绝对路径。如果用户没有提供路径参数，我们列出当前<code class="fe lv lw lx ly b">workDir</code>的内容。</p><p id="95c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ioutil.ReadDir</code>是一个非常有用的函数，它返回一段<code class="fe lv lw lx ly b">os.FileInfo</code>，描述一个目录中的每个文件，如果目标文件夹不可访问，则返回一个错误。这样，我们可以在一次操作中验证路径并检索<code class="fe lv lw lx ly b">FileInfo</code>。如果路径是好的，我们发出一个初始响应:<code class="fe lv lw lx ly b">150 File status okay; about to open data connection.</code></p><p id="9035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个比我们迄今为止所见过的更复杂的操作。当发送除状态之外的任何信息时，服务器必须建立到客户机的第二个临时连接，称为数据连接，或<code class="fe lv lw lx ly b">dataConn</code>。此外，必须连接到FTP客户端预先选择的特定端口。</p><p id="9cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是如何实现的？在向服务器发送<code class="fe lv lw lx ly b">LIST</code>指令之前，客户端在后台发送另一个命令:<code class="fe lv lw lx ly b">PORT</code>。<code class="fe lv lw lx ly b">PORT</code>有一个六字节的参数，对应于IP地址的四个部分，加上两个字节来表示最长五位数的端口号，例如<code class="fe lv lw lx ly b">PORT [127,0,0,1,245,1]</code>。请注意，您的客户端可能会使用稍微不同的格式，但是，如果您的服务器有适当的日志记录，您很快就会发现差异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/3bec18a921dc6af7ac832b3266b6d9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3dAdgyk35oNFwCwyrFBRDg.png"/></div></div></figure><p id="d902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ftp.Serve</code>有一个<code class="fe lv lw lx ly b">case</code>用于<code class="fe lv lw lx ly b">PORT</code>命令，将IP地址参数路由到下面的<code class="fe lv lw lx ly b">(c *Conn) port</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们在<code class="fe lv lw lx ly b">ftp.Conn</code>、<code class="fe lv lw lx ly b">dataPort</code>上设置最终缺失字段的机制。<code class="fe lv lw lx ly b">dataPortFromHostPort</code>将六字节的IP地址格式解析成它的部分的结构，我们存储在<code class="fe lv lw lx ly b">ftp.Conn</code>实例中。<code class="fe lv lw lx ly b">toAddress</code>将这个结构转换成传统格式的IP地址加端口，服务器可以用<code class="fe lv lw lx ly b">net.Dial</code>连接到这个端口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="543d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何从两个独立的字节创建一个长达五位数的端口号？<code class="fe lv lw lx ly b">p1&lt;&lt;8 + p2</code>。从将p1左移八位开始。如果<code class="fe lv lw lx ly b">p1 = 00011011</code>，<code class="fe lv lw lx ly b">p1&lt;&lt;8 = 0001101100000000</code>。当您添加p2时，它会填充因移位而空出的八位。<code class="fe lv lw lx ly b">p2 = 11111111</code>；<code class="fe lv lw lx ly b">p1 + p2 = 0001101111111111 = 7167</code>。</p><p id="3c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们获得了客户端提供的IP地址，就可以通过调用<code class="fe lv lw lx ly b">(c *Conn) dataConnect</code>(一个简单的<code class="fe lv lw lx ly b">net.Dial</code>包装器)来建立数据连接。注意<code class="fe lv lw lx ly b">dataConnect</code>返回一个满足<code class="fe lv lw lx ly b">net.Conn</code>接口(<code class="fe lv lw lx ly b">net.TCPConn</code>)的struct，而不是我们自定义的<code class="fe lv lw lx ly b">ftp.Conn</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们的主客户端连接一样，我们必须记住一旦完成就关闭它，这需要一个<code class="fe lv lw lx ly b">defer dataConn.Close()</code>。从那时起，列出目录内容就是遍历<code class="fe lv lw lx ly b">os.FileInfo</code>的切片，将每个文件名写入<code class="fe lv lw lx ly b">dataConn</code>，并使用<code class="fe lv lw lx ly b">EOL</code>应用正确的行终止符。下面是<code class="fe lv lw lx ly b">list</code>的第二部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="e1a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是对包含文件<code class="fe lv lw lx ly b">test.txt</code>和<code class="fe lv lw lx ly b">test_img.png</code>的目录运行<code class="fe lv lw lx ly b">ls</code>的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/4e73d790e2970a2544ec1cdb841417a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2KwKw0OU_Eq9SA4ZTH5_g.png"/></div></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0cc9" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">获取/RETR</h1><p id="20c6" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们一直在等待的部分:从服务器下载文件。现在您已经看到了如何从服务器根构建文件路径并打开数据连接，没有什么让您感到惊讶的了，除了您在客户端输入的<code class="fe lv lw lx ly b">get</code>命令作为<code class="fe lv lw lx ly b">RETR</code>被发送到服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="26f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们没有使用<code class="fe lv lw lx ly b">ioutil.ReadDir</code>获取目录的<code class="fe lv lw lx ly b">FileInfo</code>，而是尝试使用<code class="fe lv lw lx ly b">os.Open</code>打开指定的文件进行读取。如果文件无法访问，使用主连接发送<code class="fe lv lw lx ly b">550 Requested action not taken. File unavailable.</code></p><p id="3c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果文件确实存在，我们用<code class="fe lv lw lx ly b">(c *Conn) dataConnect</code>打开一个新的数据连接。与<code class="fe lv lw lx ly b">list</code>一样，客户端在每个<code class="fe lv lw lx ly b">RETR</code>请求之前都有一个<code class="fe lv lw lx ly b">PORT</code>命令，因此<code class="fe lv lw lx ly b">ftp.Conn</code>的<code class="fe lv lw lx ly b">dataPort</code>字段已经被填充。</p><p id="dffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个基本实现使用<code class="fe lv lw lx ly b">io.Copy</code>将整个文件加载到内存中，并将其直接复制到数据连接。这对于小文件来说很好，但是千兆字节级的文件可能会杀死服务器，尤其是当您考虑到我们正在同时服务多个客户端时。考虑如何通过逐行或以固定字节数读取文件来减少服务器的内存压力。</p><p id="99d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和往常一样，我们使用适合数据类型的FTP行结尾来终止传输，并通过主连接发出成功信号。</p><p id="7ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试一试；您的输出应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/4971055333aa17e8df18fe489347c4e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkOz90Uha5nilHIGvXoLaA.png"/></div></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="fa94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你要的——一个精简的、超轻量级的FTP服务器在Go中的实现，有很大的发展空间。在<code class="fe lv lw lx ly b">ftp.Serve</code>中有一些我们没有讨论的命令，比如<code class="fe lv lw lx ly b">QUIT</code>，以及FTP规范中描述的更多命令，但是我希望这篇温和的介绍已经揭开了文件传输协议的神秘面纱，并为您提供了足够的起点来扩展您的服务器。</p></div></div>    
</body>
</html>