<html>
<head>
<title>Create a Modern Dynamic Sidebar Menu in React Using Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用递归在React中创建一个现代动态侧边栏菜单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-modern-dynamic-sidebar-menu-in-react-using-recursion-f757135045bc?source=collection_archive---------5-----------------------#2019-11-14">https://betterprogramming.pub/create-a-modern-dynamic-sidebar-menu-in-react-using-recursion-f757135045bc?source=collection_archive---------5-----------------------#2019-11-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6377" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React中递归的威力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25958645bb8b6a700f2916cc193646f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5d5UTGOOq72bVnqvwL6RtQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@bundo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">本多·金</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="ee88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于其导航功能，网页中的侧栏是页面上最有用的组件之一。</p><p id="02dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我们将使用递归在react中构建一个现代侧边栏。递归是一种技术，在这种技术中，函数简单地重复调用自己，直到满足某个条件。在本文中使用递归时，递归的三个规则适用:</p><ol class=""><li id="0218" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">函数应该有一个自毁的条件。</li><li id="c57d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">该函数应该有一个基本条件。</li><li id="81dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">该函数应该调用自身。</li></ol><p id="8fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">侧边栏对于一个网页来说确实是必不可少的，即使它们的关注度并不是第一位的。这是因为它们可以帮助用户以不同的方式导航，比如他们可能感兴趣的内容，而不是逻辑导航菜单。</p><p id="09bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们为什么要对侧边栏使用递归呢？与手动写出侧边栏条目相比，这有什么不同？如果你浏览互联网有一段时间了，你可能会遇到一个网站的侧边栏，并意识到一些侧边栏项目有子部分。有些网站有侧边栏，根据用户导航到的页面路径隐藏或呈现某些项目。这是强大的！</p><p id="ab29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们看下面红色圆圈内的图像，编辑器<em class="mj"> </em>部分是侧边栏的一个项目，紧接着下面的三个项目(代码编辑器、Markdown、文本编辑器)是子部分:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c5b827fc77db5e705208363d709cf534.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/0*r3h-8foSc4kFQ_hc.jpg"/></div></figure><p id="6092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章的结尾，你会看到这个看似复杂的工具条实际上只有50行代码。什么？！</p><p id="e2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个基本的例子，说明如何扩展这篇文章中的侧边栏组件，使其更时尚，同时保持简洁:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/7200b479697db719f951e519a1af4569.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/0*JtAqsVP1zpz0ro8C.gif"/></div></figure><p id="148b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧。</p><p id="99d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将使用<a class="ae ky" href="https://create-react-app.dev/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>快速生成一个React项目。</p><p id="e50b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续使用下面的命令创建一个项目。在本教程中，我将我们的项目称为<a class="ae ky" href="https://github.com/jsmanifest/modern-sidebar" rel="noopener ugc nofollow" target="_blank"> modern-sidebar </a>。</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="3401" class="mr ms it mn b gy mt mu l mv mw">npx create-react-app modern-sidebar</span></pre><p id="9a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，现在进入目录:</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="d5dc" class="mr ms it mn b gy mt mu l mv mw">cd modern-sidebar</span></pre><p id="e374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在主条目<code class="fe mx my mz mn b">src/index.js</code>中，我们将对其进行一点清理，这样我们可以只关注组件:</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="fedd" class="mr ms it mn b gy mt mu l mv mw">import React from 'react'<br/>import ReactDOM from 'react-dom'<br/>import App from './App'<br/>import './styles.css'<br/>import * as serviceWorker from './serviceWorker'</span><span id="db2d" class="mr ms it mn b gy na mu l mv mw">ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))</span><span id="fc51" class="mr ms it mn b gy na mu l mv mw">serviceWorker.unregister()</span></pre><p id="6d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在创建<code class="fe mx my mz mn b">src/App.js</code>:</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="9562" class="mr ms it mn b gy mt mu l mv mw">import React from 'react'</span><span id="d002" class="mr ms it mn b gy na mu l mv mw">const App = () =&gt; &lt;div /&gt;</span><span id="1c1a" class="mr ms it mn b gy na mu l mv mw">export default App</span></pre><p id="02f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mx my mz mn b">App</code>将通过创建<code class="fe mx my mz mn b">Sidebar.js</code>来导入和使用我们的<code class="fe mx my mz mn b">Sidebar</code>组件，所以让我们继续创建:</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="b195" class="mr ms it mn b gy mt mu l mv mw">import React from 'react'</span><span id="580d" class="mr ms it mn b gy na mu l mv mw">function Sidebar() {<br/>  return null<br/>}</span><span id="ae51" class="mr ms it mn b gy na mu l mv mw">export default Sidebar</span></pre><p id="5145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我要安装一个CSS库，但是你实际上可以实现侧边栏相同的工作功能，我们将建立没有它。我这样做的原因是，除了让图标随时可用之外，我还喜欢看到额外的涟漪效果。</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="fc55" class="mr ms it mn b gy mt mu l mv mw">npm install @material-ui/core @material-ui/icons</span></pre><p id="61ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦安装完成，我们需要在用户界面中考虑一个基本结构，我们的侧边栏将建立在这个基础上。一个解决方案是使用无序列表(<code class="fe mx my mz mn b">&lt;ul&gt;</code>)元素来呈现列表项(<code class="fe mx my mz mn b">&lt;li&gt;</code>)。我们将从<code class="fe mx my mz mn b">@material-ui/core</code>导入<code class="fe mx my mz mn b">List</code>和<code class="fe mx my mz mn b">ListItem</code>，因为<code class="fe mx my mz mn b">List</code>组件本质上是一个<code class="fe mx my mz mn b">ul</code>元素，而<code class="fe mx my mz mn b">ListItem</code>组件本质上是一个<code class="fe mx my mz mn b">li</code>。</p><p id="335c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始在侧边栏中硬编码几个项目，来想象一下这会如何增强我们的信心。有时候，一点额外的自信可以帮助我们提高工作效率:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="41f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mx my mz mn b">disablePadding</code>和<code class="fe mx my mz mn b">dense</code>被用来稍微缩小每个物品的尺寸，<code class="fe mx my mz mn b">button</code>道具被用来添加令人眩晕的涟漪效果。</p><p id="9ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们目前掌握的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/c7063ba2f0bafd660205f7b2097f57c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F8FqObC9D2pE1TDb.gif"/></div></div></figure><p id="c4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经增强了信心，让我们继续定义<code class="fe mx my mz mn b">props.items</code>，它将被<code class="fe mx my mz mn b">Sidebar</code>使用来呈现它的项目。</p><p id="dadf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我们还将期待一个<code class="fe mx my mz mn b">items</code> prop，它是一个表示侧边栏菜单中每一项的对象数组。我们希望功能尽可能简单，否则我们可能会很快使组件过于复杂。</p><p id="4d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先在<code class="fe mx my mz mn b">App</code>组件中创建条目，并将其作为<code class="fe mx my mz mn b">props.items</code>传递给<code class="fe mx my mz mn b">Sidebar</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将更新<code class="fe mx my mz mn b">Sidebar</code>组件来反映这个数组结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="54f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到的一件事是，我们的边栏实在是太大了。侧边栏通常占据屏幕的一边，所以我们要做的是将其宽度缩小到合适的大小。我们将继续在它上面放置一个<code class="fe mx my mz mn b">200px</code>的<code class="fe mx my mz mn b">max-width</code>。所以我们将创建一个<code class="fe mx my mz mn b">div</code>元素来包装我们的<code class="fe mx my mz mn b">List</code>组件。</p><p id="362c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之所以创建另一个<code class="fe mx my mz mn b">div</code>元素，而不是直接在<code class="fe mx my mz mn b">List</code>组件上应用样式，是因为我们不想让<code class="fe mx my mz mn b">List</code>负责宽度大小。这样，将来我们可以选择将<code class="fe mx my mz mn b">List</code>抽象成一个可重用的侧边栏组件，它可以根据父元素的大小适应任何大小:</p><p id="741f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe mx my mz mn b">Sidebar.js</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="65f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mx my mz mn b">index.css</code>中，我们为<code class="fe mx my mz mn b">sidebar</code>类定义了CSS样式:</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="8459" class="mr ms it mn b gy mt mu l mv mw">.sidebar {<br/>  max-width: 240px;<br/>  border: 1px solid rgba(0, 0, 0, 0.1);<br/>}</span></pre><p id="bdb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Material-UI实际上使用了自己的<a class="ae ky" href="https://material-ui.com/styles/basics/" rel="noopener ugc nofollow" target="_blank"> CSS样式机制</a>，使用CSS-in-JS方法，但是在本文中我们将坚持使用常规CSS，以免事情变得不必要的复杂。</p><p id="362d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经可以让它像这样简单，就到此为止了。但是，它不支持子项。我们希望能够点击一个侧边栏项目，并让它下拉它的子项列表，如果它有任何。拥有子项有助于通过将附加项目分组到另一个侧边栏部分来组织侧边栏:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/6de9e78952f16f4d527afcab0bafdf9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O7VJNX9Bg-Gb8YB_.gif"/></div></div></figure><p id="e50f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们支持这个特性的方式是在每个侧边栏项目中允许另一个选项，组件将使用它来检测它的子项。(能感觉到<em class="mj">递归</em>来了吗？)</p><p id="5ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更改<code class="fe mx my mz mn b">App</code>组件中的items数组，以传入子项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="576f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够呈现侧边栏项目的子项，我们必须在呈现侧边栏项目时注意<code class="fe mx my mz mn b">items</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在…看，我们耀眼的侧边栏组件！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/a0610b8510d71a402cb3206bd1931375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2s85nQUYtVmvYY5s.gif"/></div></div></figure><p id="b61b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还不明白，这不是我们想要的侧边栏外观。</p><p id="4df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，由于我们不希望用户点击浏览器上的关闭按钮，然后再也不回到我们的网站，我们需要找到一种方法，使它看起来不仅对眼睛更有吸引力，对DOM也更有吸引力。</p><p id="1bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会问，“你说的大教堂是什么意思？”</p><p id="c9e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，你仔细看，有问题！如果用户单击一个子项，呈现子项的父项也在使用click处理程序，因为它们是重叠的！这是不好的，会给用户体验带来一些讨厌的意外问题。</p><p id="3d3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的是将父元素与其子元素(子元素)分开，这样它们就可以相邻地呈现子元素，这样鼠标事件就不会发生冲突:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们差不多可以重操旧业了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/b4054fd0ad2cd17661b977c4871172e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ffp8CovHvWvDqRTM.gif"/></div></div></figure><p id="a54d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从屏幕截图来看，我们似乎有了一个新问题:子项比顶级项大得多。我们必须找出一种方法来检测哪些是子项，哪些是顶级项。</p><p id="32bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以对此进行硬编码，然后就到此为止:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们的侧边栏组件应该是动态的。理想情况下，我们希望它根据调用者作为道具传入的项目来生成项目。</p><p id="9c7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一个简单的<code class="fe mx my mz mn b">depth</code>道具，侧边栏项目将使用这个道具，根据深度，它们可以根据<code class="fe mx my mz mn b">depth</code>相应地调整自己的间距，不管它们在树中的位置有多低。我们还将把侧边栏项目提取到它自己的组件中，这样我们可以增加深度，而不必通过引入状态逻辑来使它变得复杂。</p><p id="8545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是怎么回事？</p><p id="e5f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，我们声明了一些强大的道具来配置侧边栏预渲染阶段，如<code class="fe mx my mz mn b">depth</code>和<code class="fe mx my mz mn b">depthStep</code>。<code class="fe mx my mz mn b">SidebarItem</code>被提取到它自己的组件中，在它的渲染块中，它使用<code class="fe mx my mz mn b">depth</code>来计算它的间距。<code class="fe mx my mz mn b">depth</code>越高，它们在树中的位置就越深。</p><p id="2fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一切都是可能的，因为这一行:</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="0d17" class="mr ms it mn b gy mt mu l mv mw">{<br/>  items.map((subItem) =&gt; (<br/>    &lt;SidebarItem<br/>      key={subItem.name}<br/>      depth={depth + 1}<br/>      depthStep={depthStep}<br/>      {...subItem}<br/>    /&gt;<br/>  ))<br/>}</span></pre><p id="7a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当一个新的子项列表变得更深时,<code class="fe mx my mz mn b">depth</code>就增加<code class="fe mx my mz mn b">1</code>。</p><p id="01d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且递归存在于<code class="fe mx my mz mn b">SidebarItem</code>内部，因为它调用自己，直到不再有基本用例。换句话说，当数组为空时，这段代码会自动停止:</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="feef" class="mr ms it mn b gy mt mu l mv mw">{<br/>  items.map((subItem) =&gt; (<br/>    &lt;SidebarItem<br/>      key={subItem.name}<br/>      depth={depth + 1}<br/>      depthStep={depthStep}<br/>      {...subItem}<br/>    /&gt;<br/>  ))<br/>}</span></pre><p id="826d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们测试一下递归化的侧边栏组件:</p><blockquote class="ne nf ng"><p id="2a7b" class="kz la mj lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated"><em class="it"> src/App.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a69db75d1cdd27df80090fe7d7fdea5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/0*xyPqby4G3WsZYR6Y.gif"/></div></figure><p id="5e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做到了！</p><p id="20bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们稍微摆弄一下<code class="fe mx my mz mn b">depthStep</code>，传入一个更高的值:</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="e664" class="mr ms it mn b gy mt mu l mv mw">function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Sidebar items={items} /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/130b90ed79a4ce9d8bef606279ad1b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/0*95otHN-_QGDW677G.gif"/></div></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8d93" class="ns ms it bd nt nu nv nw nx ny nz oa ob jz oc ka od kc oe kd of kf og kg oh oi bi translated">结论</h1><p id="5ebf" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">你可以选择从<a class="ae ky" href="https://github.com/jsmanifest/modern-sidebar" rel="noopener ugc nofollow" target="_blank"> github链接</a>下载回购，并查看侧边栏的其他功能。它具有更奇特的功能，例如在渲染(侧边栏部分)中添加一个额外的层，这导致(分隔符)作为分隔符，侧边栏扩展/折叠，图标等。</p><p id="fadd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>