<html>
<head>
<title>Exploring Application State Management in React With Valtio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React With Valtio中应用程序状态管理的探索</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/magical-experiments-in-react-state-with-valtio-2b40cf159120?source=collection_archive---------0-----------------------#2021-12-31">https://betterprogramming.pub/magical-experiments-in-react-state-with-valtio-2b40cf159120?source=collection_archive---------0-----------------------#2021-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a81d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Valtio库在反应状态下进行(神奇的)实验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/db748c02e478692b40aa50184b7393d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qx3E9anQ6Bjdl6OUopCcMQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">valtio项目的启动画面</p></figure><p id="1caf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="lr ls ep" href="https://medium.com/u/c729ed050916?source=post_page-----2b40cf159120--------------------------------" rel="noopener" target="_blank"> Lee Robinson </a>有一篇名为<a class="ae lt" href="https://leerob.io/blog/react-state-management" rel="noopener ugc nofollow" target="_blank"><em class="lu">React状态管理的过去、现在和未来</em> </a> <em class="lu"> </em>的精彩文章，其中他探讨了React应用程序状态管理的当前状态。</p><p id="7b9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个突出的React州管理库是<a class="lr ls ep" href="https://medium.com/u/70508c010e42?source=post_page-----2b40cf159120--------------------------------" rel="noopener" target="_blank"> Daishi Kato </a>的<code class="fe lv lw lx ly b"><a class="ae lt" href="https://github.com/pmndrs/valtio" rel="noopener ugc nofollow" target="_blank">valtio</a></code>，领先于Lee的文章中列出的多个州库，包括:</p><ul class=""><li id="1874" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated">约泰</li><li id="fbed" class="lz ma iq kx b ky mi lb mj le mk li ml lm mm lq me mf mg mh bi translated">祖斯坦德</li><li id="00ef" class="lz ma iq kx b ky mi lb mj le mk li ml lm mm lq me mf mg mh bi translated">还有其他人！</li></ul><p id="f3d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据他的推文，Kato总结了React应用程序状态管理的决策树:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/b557e301f7581812e41e342ce0774203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mn2fZ9gfKl5k0VGhchu0Jw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">加藤的决策树用于哪个库。</p></figure><p id="bfb2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">报名参加“<strong class="kx ir"> <em class="lu">神奇简单的解决方案</em> </strong>”。</p><p id="2a06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你读过我之前关于YAGNI的文章，你就会知道我是“简单”解决方案的倡导者；当它们“神奇地简单”时就更好了。</p><p id="9567" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了探索<code class="fe lv lw lx ly b">valtio</code>以及它如何处理状态管理，我构建了一个简单的应用程序:</p><ol class=""><li id="50bf" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq mo mf mg mh bi translated">随机增加了一个<code class="fe lv lw lx ly b">Company</code></li><li id="20cf" class="lz ma iq kx b ky mi lb mj le mk li ml lm mm lq mo mf mg mh bi translated">随机添加一个<code class="fe lv lw lx ly b">Employee</code>并将<code class="fe lv lw lx ly b">Employee</code>分配给一个<code class="fe lv lw lx ly b">Company</code></li><li id="60d7" class="lz ma iq kx b ky mi lb mj le mk li ml lm mm lq mo mf mg mh bi translated">按需进行服务呼叫，以检索<code class="fe lv lw lx ly b">Employee</code>的补偿金额</li><li id="f8b9" class="lz ma iq kx b ky mi lb mj le mk li ml lm mm lq mo mf mg mh bi translated">合计给定<code class="fe lv lw lx ly b">Company</code>的所有<code class="fe lv lw lx ly b">Employee</code>的总薪酬</li></ol><p id="4976" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GitHub回购可在处<a class="ae lt" href="https://github.com/CharlieDigital/react-valtio-example" rel="noopener ugc nofollow" target="_blank">获得。</a></p><p id="2eb8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">花点时间看看下面的实际情况，特别注意<code class="fe lv lw lx ly b">Company</code>之后的美元金额:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/dbff29e1ddf1e1ff43474916824fa25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/1*nyI6tzz9UOxIElzvgvUvHA.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个简单而巧妙的反应，valtio，MUI，Vite应用程序。特别注意公司名称和员工数后的美元金额。</p></figure><p id="6d9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Redux基于不可变状态的概念运行，<code class="fe lv lw lx ly b">valtio</code>使用<em class="lu">代理状态</em>。</p><p id="03f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你使用过Vue，那么你已经熟悉了代理状态。至少对我来说，代理状态看起来更自然、更容易推理，而且在实践中也不那么冗长。</p><blockquote class="mq mr ms"><p id="22cd" class="kv kw lu kx b ky kz jr la lb lc ju ld mt lf lg lh mu lj lk ll mv ln lo lp lq ij bi translated">与不可变状态不同，我们改变状态并保持相同的对象。因为JavaScript对象本质上就是可变的，所以可变状态更容易处理。</p><p id="b09e" class="kv kw lu kx b ky kz jr la lb lc ju ld mt lf lg lh mu lj lk ll mv ln lo lp lq ij bi translated">—加藤大司</p></blockquote><p id="95bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用<code class="fe lv lw lx ly b">valtio</code>来看看app状态是什么样子的吧:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">保存我们公司和员工的AppState</p></figure><p id="dd92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样；很简单。我们所需要做的就是在出口前用<code class="fe lv lw lx ly b">proxy</code>包装它。</p><p id="9d9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在显示公司的UI模型中，我们可以通过调用<code class="fe lv lw lx ly b">useSnapshot(appState)</code>来使用状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">请特别注意第44、51和62行</p></figure><p id="4fcf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第27行，对<code class="fe lv lw lx ly b">appState.companies.push()</code>的调用将以一种被动的方式改变我们的状态，并导致UI呈现。</p><p id="d402" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第34行，我们使用一个<em class="lu">快照将状态拉入组件。</em>注意这一点很重要，因为从快照中检索到的对象实例是不可变的。在valtio中，突变必须直接针对状态发生(第27行)。我们一会儿会深入探讨这个问题。</p><p id="f192" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记住第45行。属性<code class="fe lv lw lx ly b">c.salaries</code>表示一个计算值，它是给定公司的所有雇员的工资总和。</p><p id="20b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看<code class="fe lv lw lx ly b">Employee</code>是如何添加到<code class="fe lv lw lx ly b">Company</code>中的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9ac3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lv lw lx ly b">valtio</code>的关键在于，我们可以通过不张扬地更新<code class="fe lv lw lx ly b">appState</code>来直接操纵状态，并且我们得到的相应更新完全符合我们在UI中的预期。</p><p id="7dc4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第45–50行，我们添加了一个新的<code class="fe lv lw lx ly b">Employee</code>，然后将该实例插入到一个<code class="fe lv lw lx ly b">Company</code>中……一切正常。</p><p id="2ddf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第78行开始变得有点有趣。单击按钮<code class="fe lv lw lx ly b">“GET$$”</code>将对web服务进行服务调用，以检索<code class="fe lv lw lx ly b">Employee</code>的补偿。然后将该值分配给<code class="fe lv lw lx ly b">Employee</code>并在<code class="fe lv lw lx ly b">Company</code>上汇总。</p><p id="8f40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看<code class="fe lv lw lx ly b">Employee</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">注意第40行的注释</p></figure><p id="ab2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第35行，我们进行了一个web服务调用来检索一个随机值，作为补偿分配给<code class="fe lv lw lx ly b">Employee</code>。</p><p id="8e84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得注意的是，因为我们已经从<code class="fe lv lw lx ly b">EmployeeGenerator.tsx</code>的<code class="fe lv lw lx ly b">useSnapshot</code>中检索到了<code class="fe lv lw lx ly b">Employee</code>的这个实例，所以它的属性<code class="fe lv lw lx ly b">compensation</code> <em class="lu">不能使用<code class="fe lv lw lx ly b">this.compensation = compensation</code>直接变异</em>(老实说，这只是下一级魔法)。</p><p id="5edb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下图显示了上面清单中的第37–47行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/311322aba2855b30ca561518f9055032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tbqg3TdKe4a11RZS5HpxKw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">更新属性需要我们直接突变状态！</p></figure><p id="b583" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更新补偿，我们需要从state中获取原始值，并对那个进行变异(在这个例子中我使用全名，但是在现实世界中，我们会使用ID)。</p><p id="a89f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更有趣的是当我们看<code class="fe lv lw lx ly b">Company</code>时:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">还记得上面的薪水吗？</p></figure><p id="4b90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看一看<code class="fe lv lw lx ly b">salaries</code>。它是使用getter计算出来的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/bc9ffa3ae24158ed55bba1289486b433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/1*ahsK4BvpbPCb4bkHQawZ2w.gif"/></div></figure><p id="8fab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是当我们更新与这个<code class="fe lv lw lx ly b">Company</code>相关联的<code class="fe lv lw lx ly b">Employee</code>的实例时，这个getter <em class="lu">的值会在组件中自动更新。</em></p><p id="3f81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在一个层面上，<code class="fe lv lw lx ly b">valtio</code>似乎让React状态管理变得愚蠢简单<em class="lu">。另一方面，它是如何做到这一点的，这是相当神奇的。</em></p><p id="3619" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与Tommy Groshong的React MVC相比，valtio使得在React上构建MVC应用程序变得非常简单。</p><p id="45f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我觉得李·罗宾逊对选择标准的看法很有趣:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3cefc2e5178c525c189285513076c8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*GU2wIs1OUYL2ty6pfC0L4w.png"/></div></figure><p id="6d65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">至少对我来说，<code class="fe lv lw lx ly b">valtio</code>感觉绝对，简单得可笑，而且确实相当神奇。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="458f" class="nh ni iq bd nj nk nl nm nn no np nq nr jw ns jx nt jz nu ka nv kc nw kd nx ny bi translated">进一步阅读</h1><p id="1200" class="pw-post-body-paragraph kv kw iq kx b ky nz jr la lb oa ju ld le ob lg lh li oc lk ll lm od lo lp lq ij bi translated"><a class="ae lt" href="https://blog.axlight.com/posts/how-valtio-proxy-state-works-vanilla-part/" rel="noopener ugc nofollow" target="_blank"> Daishi Kato关于valtio </a>内部的博文。</p><p id="4a0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Riccardo Giorato的文章比较了valtio和另一种基于代理的方法mobx。</p></div></div>    
</body>
</html>