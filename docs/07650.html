<html>
<head>
<title>WebSockets and AsyncIO: Beyond 5-line Samples (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebSockets和AsyncIO:超越5行示例(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/websockets-and-asyncio-beyond-5-line-samples-part-1-ddf8699a18ce?source=collection_archive---------0-----------------------#2021-02-05">https://betterprogramming.pub/websockets-and-asyncio-beyond-5-line-samples-part-1-ddf8699a18ce?source=collection_archive---------0-----------------------#2021-02-05</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="21d2" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">关于Python异步并发编程的思考</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/d79650dd8790c14fd9b4a68be6fde0aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IVOt_goVhbuQ8_3uXXHFLg.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">在<a class="ae kw" href="https://unsplash.com/s/photos/software-development?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kw" href="https://unsplash.com/@heylagostechie?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">海拉戈斯蒂奇</a>的照片</p></figure><p id="4fe0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我的团队最近被分配了一项任务，包括编写一个Python客户端来与特定的WebSockets API进行交互。它让我们学习新的东西，这篇文章的目标是分享我们的进步。我们相信总有改进的空间，所以请随时发表评论，并提出您的专业意见。</p><p id="99d0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当我们说“超越5行样本”时，我们的意思是我们在与同事交谈和搜索互联网时找到了指南，但我们错过了将相关技术、设计技巧、编程库和质量保证问题结合在一起的参考资料。我将在接下来的章节中解决这些问题。</p><p id="779c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这篇文章分为两部分。这是介绍部分。在这里，我总结了一些相关的WebSocket方面，以及它们如何通过<code class="fe lt lu lv lw b">websockets</code>库适应Python。在第二部分中，我将注意力转移到异步和并发编程上，更深入地探索<code class="fe lt lu lv lw b">asyncio</code>内置库。</p><p id="2669" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">技术讨论发生在一个虚构的用例之上，引导我涵盖上述主题。</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="2787" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">工作范围</h1><p id="e893" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">让我从虚构的用例提案开始:自动检查公司级文档，例如演示幻灯片或BI仪表板，以进行进一步的法规遵从性分析。它类似于我的团队曾经工作过的那个。</p><p id="d83e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您可以将合规性分析视为检查哪些数据源用于填充构成文档的图表和表格。在此基础上，可以使用算法根据文件给个人数据暴露带来的风险对文件进行评分，这符合GDPR和CCPA等监管计划。</p><p id="c146" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">研究评分算法看起来很酷，但在这里我们将专注于前一步:提取为它们提供信息。这将帮助我们建立一个工作范围，以及编写和测试一些客户端代码。</p><p id="8b00" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="nb">旁注</em> </strong> <em class="nb">:在激发本文的实际挑战中，使用WebSockets API是获得详细文档信息的唯一方法。我们已经用它进行了阅读操作；但是，API也支持编程文档的创建和维护，例如添加/删除组件和刷新演示数据。同时，它允许前端开发人员构建ui，为用户提供生动的体验。虽然没有充分利用WebSockets的全部功能，但是所提议的文档检查用例足以展示本文所涵盖的概念。</em></p><p id="5b1e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">任意事件会启动工作负载。由<code class="fe lt lu lv lw b">E1</code>和<code class="fe lt lu lv lw b">E2</code>表示的这些事件带来要检查的文档的标识符。在这个场景中，文档由更小的组件组成，正式名称为<a class="ae kw" href="https://en.wikipedia.org/wiki/Graphical_widget" rel="noopener ugc nofollow" target="_blank">图形小部件</a>。检查它们包括多个步骤:</p><ol class=""><li id="49f1" class="nc nd ir kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">发送WebSocket消息以获取一般文档信息。</li><li id="382d" class="nc nd ir kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">发送<em class="nb"> n </em>消息来获取详细的小部件容器信息——它们的布局、位置，更重要的是嵌套的小部件标识符。</li><li id="9269" class="nc nd ir kz b la nl ld nm lg nn lk no lo np ls nh ni nj nk bi translated">最后，发送<em class="nb"> n </em>消息来获取特定于小部件的属性，比如类型(图表、表格还是标签？)、调色板、字体大小，以及实际上给当前用例带来价值的东西:底层数据库连接、电子表格链接和SQL语句。</li></ol><p id="a07b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可以在下图中看到工作流程。阅读时，请记住垂直箭头表示顺序处理，而水平方框表示并发。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nq"><img src="../Images/9dcea6bdcf2b18831af0339ae94f3126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPlSf9y3C5f15_QG3tOa5Q.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">图一。虚构的“自动文件检查”工作流程</p></figure><p id="00eb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">从步骤2开始，我们可以利用并发性来获取信息并减少文档检查时间。一旦第一步完成，小部件容器的id就已知了，我们可以使用它们同时构建后续(也称为后续)消息。</p><p id="575f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了简单起见，事件处理本身不在讨论范围之内。因此，总而言之，我们需要这样的代码:给定一个文档的ID，以数组的形式返回其可视组件的详细信息。</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="a704" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">技术背景</h1><h2 id="f6c1" class="nr mf ir bd mg ns nt dn mk nu nv dp mo lg nw nx mq lk ny nz ms lo oa ob mu oc bi translated">WebSockets</h2><p id="d8c3" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">在加入这个项目之前，我们已经使用过REST和GraphQL APIs。我们也听说过WebSockets，但并没有与之合作。</p><blockquote class="od"><p id="3106" class="oe of ir bd og oh oi oj ok ol om ls dk translated">WebSocket通过单个TCP连接提供全双工通信通道。它支持客户端应用程序和web服务器之间的交互，开销比HTTP轮询等半双工方式更低，有助于服务器之间的实时数据传输。</p><p id="76ca" class="oe of ir bd og oh oi oj ok ol om ls dk translated"><a class="ae kw" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank"> —维基百科</a></p></blockquote><p id="04a3" class="pw-post-body-paragraph kx ky ir kz b la on js lc ld oo jv lf lg op li lj lk oq lm ln lo or lq lr ls ik bi translated">记住这些基本的描述，是时候寻找一个Python库来连接API了。我们已经使用了<code class="fe lt lu lv lw b">requests</code>库来处理REST和GraphQL，但是它不能处理WebSockets。</p><h2 id="164c" class="nr mf ir bd mg ns nt dn mk nu nv dp mo lg nw nx mq lk ny nz ms lo oa ob mu oc bi translated">Python库</h2><p id="7782" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">可用的不止一个，我们选择了<a class="ae kw" href="https://github.com/aaugustin" rel="noopener ugc nofollow" target="_blank">a Augustin</a>/<a class="ae kw" href="https://github.com/aaugustin/websockets" rel="noopener ugc nofollow" target="_blank">web sockets</a>，因为:</p><ul class=""><li id="22b1" class="nc nd ir kz b la lb ld le lg ne lk nf lo ng ls os ni nj nk bi translated">使用起来相当简单。</li><li id="c351" class="nc nd ir kz b la nl ld nm lg nn lk no lo np ls os ni nj nk bi translated">它建立在Python的标准异步I/O框架<code class="fe lt lu lv lw b">asyncio</code>之上。</li><li id="1e23" class="nc nd ir kz b la nl ld nm lg nn lk no lo np ls os ni nj nk bi translated">它的GitHub库比“竞争对手”有更多的明星，比如<a class="ae kw" href="https://github.com/websocket-client" rel="noopener ugc nofollow" target="_blank">web socket-client</a>/<a class="ae kw" href="https://github.com/websocket-client/websocket-client" rel="noopener ugc nofollow" target="_blank">web socket-client</a>，这暗示了一种社区偏好。</li></ul><p id="24ae" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">切记<code class="fe lt lu lv lw b">websockets</code>库要求Python ≥ 3.6.1。这对我们来说不是问题，因为该项目还有其他依赖项需要相同的次要版本。相反，<code class="fe lt lu lv lw b">websocket-client</code>适用于旧版本——根据他们的文档，它是在Python 2.7和Python 3.4+上测试的。看起来Python 3的支持仍在进行中。</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="bdcc" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">数据交换规范</h1><p id="3ff8" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">WebSocket消息可以携带文本数据、二进制数据和<a class="ae kw" href="https://tools.ietf.org/html/rfc6455#section-5.5" rel="noopener ugc nofollow" target="_blank">控制帧</a>。</p><blockquote class="od"><p id="75d7" class="oe of ir bd og oh oi oj ok ol om ls dk translated">控制帧不是用于承载应用的数据，而是用于协议级的信令，例如发出应该关闭连接的信号。</p><p id="4ddf" class="oe of ir bd og oh oi oj ok ol om ls dk translated"><a class="ae kw" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank">—</a><a class="ae kw" href="https://tools.ietf.org/html/rfc6455#section-1.2" rel="noopener ugc nofollow" target="_blank">web socket协议</a></p></blockquote><p id="a6e3" class="pw-post-body-paragraph kx ky ir kz b la on js lc ld oo jv lf lg op li lj lk oq lm ln lo or lq lr ls ik bi translated">我不打算讨论控制框架的细节，因为它们是由<code class="fe lt lu lv lw b">websockets</code>库内部处理的。另一方面，这取决于服务器和客户机是否同意它们用来交换数据的标准。这是本节的目的。</p><p id="132a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">JSON和<a class="ae kw" href="https://stomp.github.io/" rel="noopener ugc nofollow" target="_blank"> STOMP </a>似乎是文本数据交换最常用的格式。为了简单起见，我将使用前者，它被广泛使用，当然也更广为人知。</p><p id="6fb2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们假设服务器指定了一个简化的模式来处理虚构用例的所有传入消息:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ot ou l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated"><strong class="ak">代码片段1。</strong> JSON模式用于处理所有服务器传入的消息</p></figure><p id="d6b1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后，为了请求一般的文档信息(检查工作流的步骤1 ),客户端需要以这种方式完成传出消息:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ot ou l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated"><strong class="ak">代码片段2。</strong>获取一般文档信息的JSON示例</p></figure><p id="3329" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">要询问小部件容器信息(步骤2):</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ot ou l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated"><strong class="ak">代码片段3。</strong>获取小部件容器信息的JSON示例</p></figure><p id="b4fb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">诸如此类。我希望我已经通过例子解释清楚了服务器传入消息模式，而不是一个正式的模式！</p><p id="f8b9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您可能注意到我没有在WebSockets通信范围内使用请求/响应。这是为了避免与REST或GraphQL请求/响应混淆。由于WebSockets提供了用于多种目的的双工通信通道，并且消息可以在各种环境中来来去去，因此将它们称为传出/传入消息，甚至消息/回复更有意义。</p><p id="b2c4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">无论是在我用作参考的实际用例中，还是在虚构的用例中，客户端都希望收到对发送的每条数据消息的回复。这就是我们在每条消息上包含一个<code class="fe lt lu lv lw b">id</code>字段的原因。WebSocket协议本身并不保证每条消息都有回复。偶尔的回复也不会按照服务器接收相关消息的顺序出现。因此，在消息中包含一个<code class="fe lt lu lv lw b">id</code>是服务器和客户机之间实现简单消息/回复跟踪机制的又一个协议。</p><p id="ec8f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">也就是说，带有<code class="fe lt lu lv lw b">id = 1</code>的<code class="fe lt lu lv lw b">GetDocument</code>消息可以回复如下:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ot ou l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated"><strong class="ak">代码片段4。</strong>带有一般文档信息的JSON示例</p></figure><p id="93b3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在继续下一步之前，您必须了解:</p><ul class=""><li id="dfbc" class="nc nd ir kz b la lb ld le lg ne lk nf lo ng ls os ni nj nk bi translated">我们的目标是连接到一个指定JSON作为数据交换格式的WebSocket服务器。</li><li id="014e" class="nc nd ir kz b la nl ld nm lg nn lk no lo np ls os ni nj nk bi translated">WebSocket连接通常使用单个URI，例如<code class="fe lt lu lv lw b">wss://documents.example.com</code> — <a class="ae kw" href="https://tools.ietf.org/html/rfc6455#section-3" rel="noopener ugc nofollow" target="_blank">查询字符串和请求头</a>在建立连接时有效。</li><li id="250a" class="nc nd ir kz b la nl ld nm lg nn lk no lo np ls os ni nj nk bi translated">所有通信参数，包括方法和输入参数，都通过消息体发送。</li></ul></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="b18c" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">空谈是廉价的——给我看看代码</h1><p id="c5b5" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">是时候看看Python的东西了！完整示例可在<a class="ae kw" href="https://github.com/ricardolsmendes/websockets-asyncio/blob/main/document_inspector.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="6ac0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们从<code class="fe lt lu lv lw b">websockets</code>库使用开始浏览吧。如前所述，这个库使得实例化客户端以及通过双工通道发送和接收消息变得非常简单。</p><p id="542d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面的代码片段总结了如何使用它:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ot ou l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated"><strong class="ak">代码片段5。</strong> Python websockets库的简单用法</p></figure><p id="5a07" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你会在<a class="ae kw" href="https://github.com/ricardolsmendes/websockets-asyncio/blob/main/document_inspector.py" rel="noopener ugc nofollow" target="_blank">完整示例</a>中找到类似的陈述。</p><p id="b38f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">请注意，消息和回复是分开处理的。如果您使用过REST或GraphQL API，您会知道这是一种不同的行为。REST和GraphQL使用HTTP，所以我们在发送请求后会立即得到响应。当使用WebSockets时，你可以发送<em class="nb"> n </em>条消息，等一会儿，然后接收回复——或者不接收。这幅图说明了我的意思:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ov"><img src="../Images/57cbd54606651da320cd6171cd976381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wrTDVwf3NPuTDld1vsmvQ.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">图二。REST/GraphQL和WebSockets比较</p></figure></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="93f9" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">下一步是什么？</h1><p id="326f" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">并发任务帮助我们处理WebSocket异步通信通道中的消息和回复，尽管存在复杂性权衡。因此，在文章的第二部分<a class="ae kw" href="https://medium.com/better-programming/a-deeper-look-at-async-and-concurrent-programming-in-python-9f2a84adbdd2" rel="noopener">中，它们与<code class="fe lt lu lv lw b">asyncio</code>一起被详细地覆盖。</a></p><p id="965d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">感谢您读到这里！</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="07cc" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">参考</h1><ul class=""><li id="d75a" class="nc nd ir kz b la mw ld mx lg ow lk ox lo oy ls os ni nj nk bi translated">WebSocket协议:<a class="ae kw" href="https://tools.ietf.org/html/rfc6455" rel="noopener ugc nofollow" target="_blank">https://tools.ietf.org/html/rfc6455</a></li><li id="4b69" class="nc nd ir kz b la nl ld nm lg nn lk no lo np ls os ni nj nk bi translated">WebSocket |现代JavaScript教程:<a class="ae kw" href="https://javascript.info/websocket" rel="noopener ugc nofollow" target="_blank">https://javascript.info/websocket</a></li></ul></div></div>    
</body>
</html>