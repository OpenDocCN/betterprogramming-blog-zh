<html>
<head>
<title>Protect Your Static Files With Sub-Resource Integrity (SRI) in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js中的子资源完整性(SRI)保护静态文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/protect-your-static-files-with-sub-resource-integrity-sri-in-node-js-35a7e69abebb?source=collection_archive---------5-----------------------#2022-11-02">https://betterprogramming.pub/protect-your-static-files-with-sub-resource-integrity-sri-in-node-js-35a7e69abebb?source=collection_archive---------5-----------------------#2022-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0ee6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何执行自动SRI生成，以递归地生成子资源完整性哈希来进行身份验证。js和。css文件</h2></div><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="cfcd" class="ko kp iq kk b gy kq kr l ks kt"><strong class="kk ir">Recommendations: </strong>Compatibility test performed with Node.JS 18.10, executed on MacOS Ventura 13.1.</span><span id="effb" class="ko kp iq kk b gy ku kr l ks kt">Libraries Used: fs, path, crypto, Express.js, (optional: Mongoose)</span></pre><figure class="kf kg kh ki gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="8c00" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">子资源完整性(SRI)是一项安全功能，它允许浏览器验证它们获取的文件(例如，从CDN获取的文件)是在没有意外操作的情况下交付的。要使用SRI，希望包含静态资源的网站作者除了指定资源的位置之外，还可以指定资源的加密哈希。然后，获取资源的浏览器可以将网站作者提供的哈希与从资源计算出的哈希进行比较。如果哈希值不匹配，资源将被丢弃。</p><p id="b743" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">integrity属性的值以至少一个字符串开始，每个字符串包括指示特定哈希算法的前缀(当前允许的前缀是sha256、sha384和sha512)，后跟破折号，并以base64哈希本身结束。</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="ae3a" class="ko kp iq kk b gy kq kr l ks kt">&lt;script src="https://cdn.example.com/app.js"<br/>        integrity="sha384-+/M6kredJcxdsqkczBUjMLvqyHb1K/JThDXWsBVxMEeZHEaMKEOEct339VItX1zB"<br/>&gt;&lt;/script&gt;</span></pre><p id="3986" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">本实践教程旨在通过解析目录和子目录来提取静态文件，从而自动化生成加密哈希的过程，以方便对它们的访问。</p><figure class="kf kg kh ki gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lu"><img src="../Images/5282c43c00da45bf7f276d6a696f6a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TuNCuZwfij0v8Scq"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">美国宇航局在<a class="ae mf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="7750" class="mg kp iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">实践教程</h1><p id="c26a" class="pw-post-body-paragraph ky kz iq la b lb mx jr ld le my ju lg lh mz lj lk ll na ln lo lp nb lr ls lt ij bi translated">该算法的核心是递归分析包含站点静态文件的“公共”路径的子文件夹，对每个子文件夹进行单独处理。js或者。css文件并浏览到每个子文件夹。</p><figure class="kf kg kh ki gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="58c8" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请注意，递归函数封装在“get”函数中，旨在容纳各种参数，以便作为模块进行有用的导出，并在<a class="ae mf" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> Express </a>应用程序中正确使用。</p><p id="fddd" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe nc nd ne kk b">get</code>函数有两个参数:包含我们想要从中获取散列的静态文件的<code class="fe nc nd ne kk b">directory</code> ( <code class="fe nc nd ne kk b">string</code>)，以及计算所需的<code class="fe nc nd ne kk b">algorithm</code><code class="fe nc nd ne kk b">sha256</code>、<code class="fe nc nd ne kk b">sha384</code>或<code class="fe nc nd ne kk b">sha512</code> ( <code class="fe nc nd ne kk b">string</code>)。返回<code class="fe nc nd ne kk b">JSON</code>对象。</p><figure class="kf kg kh ki gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="21f6" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">但是，我们希望确保只为。css和。js文件，不包括系统文件、图像和其他文件。然后，创建一个控制函数来分析各种文件的扩展名，以在条件无效的情况下拒绝算法的执行，这就足够了。</p><figure class="kf kg kh ki gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="9ee6" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，在条件验证的框架内，算法将使用加密模块和fs模块来连续访问要研究的文件，并创建关于其内容和由开发者确定的算法的打印。</p><figure class="kf kg kh ki gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="4dc7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这将返回如下内容:</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="8f67" class="ko kp iq kk b gy kq kr l ks kt">[<br/>  {<br/>    filepath: 'public/css/index.css',<br/>    hash: 'sha384-yTRuc6ItZNScTYLXkpwURSAsaZLKgfoWi69Nku5bK2/1HW2O8OOgcli2jdgvIJnE'<br/>  }<br/>]</span></pre><p id="df4e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">然后，我们可以观察到一个JSON元素的创建，该元素包含目录及其子目录中包含的每个文件路径，以及一个惟一散列的赋值，该散列前面带有可以在routes配置文件中直接利用的<code class="fe nc nd ne kk b">"sha256-"</code>、<code class="fe nc nd ne kk b">"sha384-"</code>或<code class="fe nc nd ne kk b">"sha512-"</code>。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/louisbrulenaudet/open-sri" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">GitHub——louisbrulenaudet/open-Sri:超轻、不依赖和极简的开源包…</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">超轻、不依赖和极简的开源包，可递归生成sha-256、sha-384或sha-512…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw lz ni"/></div></div></a></div><h1 id="bc84" class="mg kp iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">MongoDB集成</h1><p id="c96d" class="pw-post-body-paragraph ky kz iq la b lb mx jr ld le my ju lg lh mz lj lk ll na ln lo lp nb lr ls lt ij bi translated">从使用MongoDB和mongose的更加结构化的集成的角度来看，应用相同的处理就足够了，包括管理mongose模式。</p><p id="188a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果这是一个全新的项目，确保先用<code class="fe nc nd ne kk b">npm init</code>命令创建一个<code class="fe nc nd ne kk b">package.json</code>，安装<a class="ae mf" href="https://www.mongodb.org/downloads" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>和Mongoose。</p><h2 id="6eb5" class="ko kp iq bd mh nx ny dn ml nz oa dp mp lh ob oc mr ll od oe mt lp of og mv oh bi translated">正在连接到MongoDB</h2><p id="b1c3" class="pw-post-body-paragraph ky kz iq la b lb mx jr ld le my ju lg lh mz lj lk ll na ln lo lp nb lr ls lt ij bi translated">首先，我们需要定义一个连接。如果你的应用只使用一个数据库，你应该使用<code class="fe nc nd ne kk b">mongoose.connect</code> ( <code class="fe nc nd ne kk b">createConnection</code>取一个<code class="fe nc nd ne kk b">mongodb://</code> URI，或者参数<code class="fe nc nd ne kk b">host, database, port, options</code>)。</p><figure class="kf kg kh ki gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="7bf1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la ir">注意:</strong> <em class="oi">如果本地连接失败，尝试使用127.0.0.1，而不是localhost。当本地主机名更改时，有时可能会出现问题。</em></p><p id="de3e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la ir">重要提示:</strong>mongose会缓冲所有命令，直到它连接到数据库。这意味着您不必等到它连接到MongoDB才定义模型、运行查询等。</p><h1 id="ef97" class="mg kp iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">定义哈希存储模型</h1><p id="55b5" class="pw-post-body-paragraph ky kz iq la b lb mx jr ld le my ju lg lh mz lj lk ll na ln lo lp nb lr ls lt ij bi translated">通过<code class="fe nc nd ne kk b">Schema</code>接口定义模型。我们需要每个文件的路径和散列之间的配对系统，在模式中定义如下:</p><figure class="kf kg kh ki gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="7707" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于本教程，我们做了一些修改，将整个算法集中在一段简短易懂的代码中，允许进行大量的调整和修改:</p><figure class="kf kg kh ki gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="f52b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一旦我们通过<code class="fe nc nd ne kk b">mongoose.model('integrity', IntegritySchema)</code>定义了一个模型，我们就可以通过下面的函数来使用它:</p><figure class="kf kg kh ki gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="7109" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一个参数是描述Mongoose模式的文件的路径，第二个参数是包含一组子文件夹和静态文件的路径，我们希望将子资源完整性签入的散列收集到这些文件中。</p><p id="1230" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">执行<code class="fe nc nd ne kk b">saveSubresourceIntegrityHash</code>功能时，可以在数据库中观察到目录及其子目录中包含的每个文件的对象创建。在绝对访问路径相同的情况下，我们还可以看到它的替换，以及前面带有“sha384-”的唯一散列的分配，如下所示:</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="abb8" class="ko kp iq kk b gy kq kr l ks kt">{<br/>  "_id": {<br/>    "$oid": "6308ca92d8424fda52e63eae"<br/>  },<br/>  "filepath": "public/css/index.css",<br/>  "__v": 0,<br/>  "hash": "sha384-ql4jKwyXlyERdFY59Fq4T+ILy2bHHIusVmm1UBuSl+ddrgTfN/kAlG7lbY2oo645"<br/>}</span></pre><div class="nf ng gp gr nh ni"><a href="https://github.com/louisbrulenaudet/mongoose-subresource-integrity" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">GitHub-louisbrulenaudet/mongose-sub resource-integrity:超轻、非依赖性和极简主义…</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">超轻，不依赖和极简的开源包递归生成sha-384子资源完整性…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="oj l nt nu nv nr nw lz ni"/></div></div></a></div><p id="ecb3" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用CDN托管多个站点之间共享的脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也有风险——如果攻击者控制了CDN，他或她可以将恶意内容注入到文件中(或完全替换它们),因此也可能攻击从该CDN检索文件的所有站点。</p><blockquote class="ok ol om"><p id="ba2f" class="ky kz oi la b lb lc jr ld le lf ju lg on li lj lk oo lm ln lo op lq lr ls lt ij bi translated">子资源完整性检查允许您降低这种攻击的风险，方法是确保您的应用程序或web文档使用的文件(来自CDN或其他地方)在交付时没有任何第三方更改，没有将附加内容注入到文件中，也没有对这些文件进行任何其他类型的更改。</p></blockquote><p id="a9e5" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>