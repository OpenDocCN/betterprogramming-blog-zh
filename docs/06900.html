<html>
<head>
<title>Creating LocalStorage Wrapper With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript创建本地存储包装</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-localstorage-wrapper-with-typescript-7ff6b71b35cb?source=collection_archive---------1-----------------------#2020-11-16">https://betterprogramming.pub/creating-localstorage-wrapper-with-typescript-7ff6b71b35cb?source=collection_archive---------1-----------------------#2020-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a9d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过添加自定义包装器来改进浏览器API的使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6dbf9b6e741eef8c6a4b2d2c71581c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*03TgN5q_4hC1jlnq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Christopher Gower 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="2895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的文章将对前端开发人员有用，他们希望自己的代码是类型安全的，可读性更好。我将向您展示如何包装不同的浏览器API来更好地控制这种情况。例如，我将使用<code class="fe lv lw lx ly b">localStorage</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cf3f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">快速刷新</h1><p id="e17a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">LocalStorage</code>是用于跨浏览器会话存储数据的浏览器存储。和<code class="fe lv lw lx ly b">localStorage</code>一起工作没什么大不了的。它有一个非常简单的界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e9b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，你可能会问，“既然它有这么简单的接口，我们为什么还需要任何包装器呢？”说得好，但是包装器实际上帮助我们涵盖了开发的其他部分，而不是简单的可用性。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ebeb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">优势</h1><ul class=""><li id="85cf" class="nf ng it lb b lc my lf mz li nh lm ni lq nj lu nk nl nm nn bi translated">第一个优点是实现测试会容易得多。您有一个包装器，它在生产中使用真正的API，在测试时使用一个虚拟的API。可以进行不同的模拟，并且可以发现各种弱点。</li><li id="fba3" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">它将为您带来一个单独的地方，您可以在这里定义键的名称。这意味着您不会意外地将数据保存到不同的键中，或者试图从一个不存在的键中获取数据。</li><li id="771f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">还有一个好处:如果你出于某种原因需要重命名你的密钥(例如从<code class="fe lv lw lx ly b">token_v1</code>到<code class="fe lv lw lx ly b">token_v2</code>，可以在你的包装器中完成。</li><li id="80c3" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">最后但同样重要的是，在环境API上编写自己的包装器被认为是一种好的实践。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cbfd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">发展中的</h1><p id="dfe0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">因此，它应该是一个具有泛型的抽象类(稍后我会解释它的用途):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bb30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加一个包含实际存储的属性。在我们这样做之前，我们还需要描述可以存储在该属性中的接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，上面的代码完全重复了浏览器<code class="fe lv lw lx ly b">localStorage</code>。这正是我们所需要的。</p><p id="36fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是具有属性的抽象类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="02b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从哪里可以得到真正的存储？当然，从构造函数中借助<code class="fe lv lw lx ly b">getStorage</code>函数。它默认返回浏览器<code class="fe lv lw lx ly b">localStorage</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b8fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在生产中，我们不需要做任何额外的工作。但是在测试的时候，我们只需要传递以<code class="fe lv lw lx ly b">IStorage</code>为返回值的函数。</p><p id="01ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始添加方法。在我们开始之前，我必须说所有的方法都将受到保护，因为它们在类/实例之外不应该是可见的，并且只有继承者可以访问它们。</p><p id="4576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是<code class="fe lv lw lx ly b">get</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="917d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是<code class="fe lv lw lx ly b">T</code>，我们传递给抽象类的泛型。我们这样做是为了实现额外的类型安全。该方法返回一个值<code class="fe lv lw lx ly b">null</code>。</p><p id="2834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在获取数据之前，我们应该传递它。下一个方法是<code class="fe lv lw lx ly b">set</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为一切都清楚了。</p><p id="9f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只剩下两种方法:<code class="fe lv lw lx ly b">clearItem</code>和<code class="fe lv lw lx ly b">clearItems</code>来移除单个键或它们的数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的最终准则:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，因为我们只有抽象类，我们必须创建一个实例。但在此之前，让我们用我们将要使用的所有键来描述一下<code class="fe lv lw lx ly b">enum</code>。在我们的例子中，这个类将负责令牌:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="299d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们已经将<code class="fe lv lw lx ly b">Locals</code>传递给了<code class="fe lv lw lx ly b">Storage</code>泛型。这意味着只有来自这个<code class="fe lv lw lx ly b">enum</code>的键可以在<code class="fe lv lw lx ly b">get</code>、<code class="fe lv lw lx ly b">set</code>、<code class="fe lv lw lx ly b">clearItem</code>和<code class="fe lv lw lx ly b">clearItems</code>方法中使用。</p><p id="af18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">singleton</code>是有意义的，因为有一个<code class="fe lv lw lx ly b">Token</code>类的实例就足够了。</p><p id="e919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们向构造函数添加了一个私有访问级别，以防止创建实例。此外，还添加了一个实例属性来缓存类实例。静态方法<code class="fe lv lw lx ly b">getInstance</code>将返回缓存的实例或者创建一个新的实例。</p><p id="b70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备创建处理数据的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ae87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的这些方法将用于操作访问令牌。如你所见，我们使用了抽象类中的受保护方法。</p><p id="1973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对刷新令牌做同样的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="34a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们需要以某种方式删除我们的数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="210e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="acb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="73a7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><p id="1344" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">也许不是每个项目都需要这样的方法，但知道它还是好的。我希望你已经发现这篇文章有趣和有用。</p></div></div>    
</body>
</html>