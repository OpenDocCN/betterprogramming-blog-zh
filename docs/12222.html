<html>
<head>
<title>How To Serve a Single-Page Application Using Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Go为单页面应用程序提供服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-serve-a-single-page-application-using-go-4b9a38d92987?source=collection_archive---------1-----------------------#2022-05-20">https://betterprogramming.pub/how-to-serve-a-single-page-application-using-go-4b9a38d92987?source=collection_archive---------1-----------------------#2022-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ecb2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Go的标准HTTP服务器构建Vue SPA的分步指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1a8b5bc874cdde64206b884016fdf7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vXPmgD5i1V9mHD6Q"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯·里德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bb81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">完整源代码可以在</em> <a class="ae kv" href="https://github.com/wolftsao/go_spa_example" rel="noopener ugc nofollow" target="_blank"> <em class="ls">这里找到</em> </a> <em class="ls">。</em></p><h2 id="d18b" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">先决条件</h2><ol class=""><li id="70aa" class="mm mn iq ky b kz mo lc mp lf mq lj mr ln ms lr mt mu mv mw bi translated">npm</li><li id="cc7e" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">Vue CLI</li><li id="8fb3" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">去编译(本例中嵌入1.16+，推荐1.18+)</li><li id="468c" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">(可选)Docker</li></ol><h1 id="7e6e" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">设置我们的项目</h1><p id="b4f9" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">第一件事是建立我们的项目。假设我们的项目名称是<code class="fe nq nr ns nt b">go_spa_example</code>。下面是实现这一点的代码:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="8443" class="lt lu iq nt b gy ny nz l oa ob">mkdir go_spa_example<br/>cd go_spa_example</span><span id="0d5f" class="lt lu iq nt b gy oc nz l oa ob"># create Go module, I am using my Github here<br/>go mod init github.com/wolftsao/go_spa_example</span></pre><p id="64f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后初始化我们的Vue前端:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="6c4f" class="lt lu iq nt b gy ny nz l oa ob"># To make it simple, I just name the Vue project ui<br/># flag -n means no git</span><span id="1808" class="lt lu iq nt b gy oc nz l oa ob">vue create -n ui</span></pre><p id="4e92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，Vue CLI将询问您项目选项。Vue路由器(因为我们正在构建SPA)是最重要的，所以选择“手动选择功能”以下是我的配置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/95fa4ad447123ede67b7248f3067696e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGvBKxlnQl45HdG_-gwTsw.png"/></div></div></figure><p id="e646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的项目设置已经完成。让我们先处理前端。</p><h1 id="06e6" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">Vue前端设置</h1><p id="62dc" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们不打算在这里创建花哨的前端的东西，只是有一个默认的Vue模板页面将包含以下页面可行的例子:</p><ul class=""><li id="d006" class="mm mn iq ky b kz la lc ld lf oe lj of ln og lr oh mu mv mw bi translated">路径为<code class="fe nq nr ns nt b">"/"</code>的索引页面</li><li id="d4ff" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">关于路径为<code class="fe nq nr ns nt b">"/about"</code>的页面</li><li id="9849" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">其他内容将显示未找到页面</li></ul><p id="14a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们需要执行以下操作:</p><ol class=""><li id="0d32" class="mm mn iq ky b kz la lc ld lf oe lj of ln og lr mt mu mv mw bi translated">更改前端构建工件的位置</li><li id="a61e" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">添加未找到的页面</li><li id="06b4" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">设置索引页的别名并捕获未找到页的所有路由</li></ol><h2 id="9771" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">更改前端工件位置</h2><p id="d713" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">如果我们现在构建前端，输出工件将在<code class="fe nq nr ns nt b">ui/dist</code>中，如下所示:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="f378" class="lt lu iq nt b gy ny nz l oa ob">ui/dist<br/>├── css<br/>├── favicon.ico<br/>├── index.html<br/>└── js</span></pre><p id="a1e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">dist</code>现在是服务于前端的根文件夹，里面有各种类型的静态文件，如js、CSS等。，在它自己的文件夹下。</p><p id="3f4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是用Go的标准HTTP库来处理这种常见的布局有点复杂(我将在后面详细解释)。</p><p id="7500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将所有静态文件聚集到一个集中的位置。</p><p id="0864" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe nq nr ns nt b">ui/vue.config.js</code>，然后添加值为<code class="fe nq nr ns nt b">static</code>的属性<code class="fe nq nr ns nt b">assetsDir</code>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">vue.config.js中的assetsDir</p></figure><p id="caa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在工件的结构将会是:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="5332" class="lt lu iq nt b gy ny nz l oa ob">ui/dist<br/>├── favicon.ico<br/>├── index.html<br/>└── static<br/>    ├── css<br/>    └── js</span></pre><p id="acaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有静态文件都在<code class="fe nq nr ns nt b">static</code>文件夹下。</p><p id="37b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于这个配置，我们的索引页面的URL将是:<br/> <code class="fe nq nr ns nt b">http://&lt;domain&gt;:&lt;port&gt;/</code></p><p id="6863" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而CSS文件会是这样的:<br/> <code class="fe nq nr ns nt b">http://&lt;domain&gt;:&lt;port&gt;/static/css/app.9bdcf330.css</code></p><h2 id="57d3" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">创建未找到的页面</h2><p id="b283" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">创建包含以下内容的文件<code class="fe nq nr ns nt b">ui/src/views/NotFound.vue</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Vue未找到模板</p></figure><p id="ac4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们有了一个只有模板的<a class="ae kv" href="https://vuejs.org/guide/scaling-up/sfc.html" rel="noopener ugc nofollow" target="_blank">单文件组件(SFC) </a>。</p><h2 id="da72" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">添加索引页别名和全部捕获路线</h2><p id="bbe0" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">最后，打开<code class="fe nq nr ns nt b">ui/src/router/index.js</code>，然后:</p><ol class=""><li id="ce99" class="mm mn iq ky b kz la lc ld lf oe lj of ln og lr mt mu mv mw bi translated">将别名<code class="fe nq nr ns nt b">alias: ['/index.htm'],</code>添加到索引页面路径中(下面的第7行)。<br/>默认情况下，Vue对待<code class="fe nq nr ns nt b">"/"</code>和<code class="fe nq nr ns nt b">"/index.html"</code>是不同的，所以让我们通过添加这个别名来使它更自然。</li><li id="9928" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">在<code class="fe nq nr ns nt b">routes</code>数组的末尾添加一条全部捕获路线(下面的第20行)。</li></ol><p id="d4ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是实现这一点的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">捕获Vue路由器中的所有路由</p></figure><p id="557b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了。我们已经完成了我们的Vue前端。让我们拥抱最激动人心的部分——Go HTTP服务器。</p><h1 id="abc8" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">创建Go HTTP后端服务器</h1><p id="0a6f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">这将是这个故事的主要部分。然而，为了使事情尽可能简单，我将在单个<code class="fe nq nr ns nt b">main.go</code>文件中定义所有内容。</p><p id="0f7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，我们需要的是:</p><ul class=""><li id="f4ae" class="mm mn iq ky b kz la lc ld lf oe lj of ln og lr oh mu mv mw bi translated">Go嵌入包</li><li id="ffe0" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">转到HTTP服务器</li><li id="40e6" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">多路复用器/路由器</li><li id="4a50" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">提供前端静态文件的HTTP文件服务器</li></ul><p id="7125" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还会说说从Go上服务SPA时的一些误区。</p><h2 id="0aac" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">嵌入我们的前端工件</h2><p id="6617" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们并不真的需要嵌入我们的前端文件，但是<a class="ae kv" href="https://pkg.go.dev/embed" rel="noopener ugc nofollow" target="_blank"> embed </a>有它自己的潜在用法，所以我在这里把它作为一个练习。</p><p id="a728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(我的项目源代码还有另一个分支noembed，它使用普通的文件系统来服务前端。你可以点击查看<a class="ae kv" href="https://github.com/wolftsao/go_spa_example/tree/noembed" rel="noopener ugc nofollow" target="_blank"/></p><p id="390d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用embed的好处是我们可以在任何地方运行我们的SPA，而不用担心前端工件的位置。然而，每次前端发生变化时，我们都需要重新构建我们的程序。</p><p id="e0a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的。让我们创建Go嵌入包文件，<code class="fe nq nr ns nt b">ui/ui.go:</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">转到嵌入包</p></figure><p id="25c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确保文件<code class="fe nq nr ns nt b">ui.go</code>位于<code class="fe nq nr ns nt b">ui</code>文件夹下，而不是项目根目录下。它与其他前端文件共存。</p><p id="9c7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">注意</em> </strong> <em class="ls">:我们可以把</em> <code class="fe nq nr ns nt b"><em class="ls">ui.go</em></code> <em class="ls">放在项目根，在这个例子中把包改成main。但是在一个更大的项目中，我们通常将文件分成不同的包，每个包都有自己的用途。</em> <code class="fe nq nr ns nt b"><em class="ls">ui.go</em></code> <em class="ls">的唯一目的是服务于前端工件。所以，我决定把它放在</em> <code class="fe nq nr ns nt b"><em class="ls">ui</em></code> <em class="ls">文件夹里，但这只是我的看法。</em></p><p id="0c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个包声明了一个用作嵌入文件系统的变量<code class="fe nq nr ns nt b">StaticFiles</code>。</p><p id="7710" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，注意Go指令<code class="fe nq nr ns nt b">//go:embed all:dist</code>，这意味着将所有文件嵌入到<code class="fe nq nr ns nt b">dist </code>文件夹及其子文件夹中。</p><p id="ef70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在1.18之前的Go版本中，embed有一个很大的限制，不能嵌入前缀为<code class="fe nq nr ns nt b">"."</code>或<code class="fe nq nr ns nt b">"_"</code>的文件。一些前端捆绑工具会生成带有该模式的工件。</p><p id="e4f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:这个<a class="ae kv" href="https://github.com/golang/go/issues/43854" rel="noopener ugc nofollow" target="_blank">问题</a>已经在Go 1.18中用embed指令中的特殊术语<code class="fe nq nr ns nt b">all:</code>修复了。但是由于Vue CLI没有生成带有<code class="fe nq nr ns nt b">"."</code>或<code class="fe nq nr ns nt b">"_"</code>前缀的工件，我们不必担心这一点(如果你使用的是更早的Go版本，请将指令改为<code class="fe nq nr ns nt b">//go:embed dist/*</code>，因为<code class="fe nq nr ns nt b">all:</code>是1.18的特性。</p><p id="dbd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果你喜欢尝试其他前端库/框架，或者如果你正在使用更早的Go版本，你需要更加注意这些。</p><h2 id="d576" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">一个简单的Go HTTP服务器</h2><p id="47c6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">现在，在项目根文件夹中创建文件<code class="fe nq nr ns nt b">main.go</code>来服务我们的HTTP服务器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Go HTTP服务器主要功能</p></figure><p id="aa3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">您可能需要调整ui包的导入路径。</em></p><p id="e355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它只是一个普通的Go HTTP服务器(我把服务器端口硬编码为<code class="fe nq nr ns nt b">8888</code>)。</p><p id="00b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，为了使示例尽可能简单，我将每个路由/处理程序放在一个名为<code class="fe nq nr ns nt b">router</code>的函数中。我们来谈谈这个。</p><h2 id="9405" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">我们的多路复用器/路由器</h2><p id="33fc" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated"><code class="fe nq nr ns nt b">router</code>功能将处理三种路线:</p><ol class=""><li id="a8a8" class="mm mn iq ky b kz la lc ld lf oe lj of ln og lr mt mu mv mw bi translated">前端索引页(<code class="fe nq nr ns nt b">"/"</code>或index.html)</li><li id="debe" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">前端静态文件(如JavaScript、CSS等。)</li><li id="cb58" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">蜜蜂</li></ol><p id="595d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如下定义<code class="fe nq nr ns nt b">main</code>功能下的<code class="fe nq nr ns nt b">router</code>功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">转到HTTP路由器</p></figure><ul class=""><li id="b8a4" class="mm mn iq ky b kz la lc ld lf oe lj of ln og lr oh mu mv mw bi translated">在第5行，我们用函数<code class="fe nq nr ns nt b">indexHandler</code>处理索引页面(我稍后会处理这个)</li><li id="cfb9" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">在第8到10行，我们通过创建嵌入式文件系统的子文件夹来定义一个<code class="fe nq nr ns nt b">http.FileServer</code>。这样，我们可以搜索以<code class="fe nq nr ns nt b">"static"</code>而不是<code class="fe nq nr ns nt b">"dist"</code>开头的文件(默认情况下，<code class="fe nq nr ns nt b">http.FileServer</code>启用目录列表；你可以查看<a class="ae kv" href="https://www.alexedwards.net/blog/disable-http-fileserver-directory-listings" rel="noopener ugc nofollow" target="_blank">这篇伟大的文章</a>来禁用那种行为)</li><li id="5703" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">第13行只是一个用于演示的虚拟API(匿名函数)</li></ul><p id="3d1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可能想知道为什么我们将索引处理器(<code class="fe nq nr ns nt b">"/"</code>)从静态文件服务器(<code class="fe nq nr ns nt b">"/static/"</code>)中分离出来。<code class="fe nq nr ns nt b">index.html</code>不就是另一个文件吗？</p><p id="c374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们只有<code class="fe nq nr ns nt b">"/"</code>路径，如果我们走最简单的路径，它服务于我们的文件服务器。我们可以通过执行以下操作来完成此任务:</p><ul class=""><li id="3cd2" class="mm mn iq ky b kz la lc ld lf oe lj of ln og lr oh mu mv mw bi translated">构建并运行程序</li><li id="1643" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">在地址栏中输入<code class="fe nq nr ns nt b">http://localhost:8888</code>，索引页将正确显示</li><li id="9298" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">单击“关于”链接以显示带有正确URL的右侧页面(<code class="fe nq nr ns nt b">http://localhost:8888/about</code>)</li></ul><p id="d10f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一切看起来都很好，直到你直接在地址栏中键入<code class="fe nq nr ns nt b">http://localhost:8888/about</code>，然后点击enter。嘣！用<code class="fe nq nr ns nt b">404 page not found</code>清空页面。</p><p id="e42e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是怎么回事？</p><p id="f720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题是双重的。</p><p id="fdee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，Go通过URL路径搜索文件系统。对于<code class="fe nq nr ns nt b">http://localhost:8888/about</code>的情况。这是告诉Go在文件服务器中搜索<code class="fe nq nr ns nt b">about</code>文件。因为我们没有这样的文件，所以Go HTTP服务器返回默认的404消息。</p><p id="b698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二，<code class="fe nq nr ns nt b">about</code>页面只存在于前端。JavaScript为我们施展了前端路由魔法。从技术上讲，JavaScript/CSS代码确实存在于后端，所以我们需要一个文件服务器来服务这些文件。</p><p id="7513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前端也需要一个入口点来启动SPA，很像Go的<code class="fe nq nr ns nt b">main</code>函数。当浏览器访问索引页面(<code class="fe nq nr ns nt b">"/"</code>，入口点)时，它知道如何获取其他静态文件，启动Vue引擎，然后Vue可以为我们路由和渲染那些页面。</p><p id="3b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们需要专门处理索引路径<code class="fe nq nr ns nt b">"/"</code>的原因。</p><p id="8f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于Go的HTTP路由还有最后一点。早些时候，当我们开发Vue时，我们在<code class="fe nq nr ns nt b">vue.config.js</code>中设置了<code class="fe nq nr ns nt b">assetsDir: 'static'</code>，这是面向Go的路由模式规则的。(如果你不熟悉Go的路由规则，强烈推荐你看<a class="ae kv" href="https://lets-go.alexedwards.net/sample/02.03-routing-requests.html" rel="noopener ugc nofollow" target="_blank">这个</a>。我读过的最棒的围棋书籍之一！)</p><p id="5647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Go，其他处理程序不匹配的所有内容都将退回到索引路径<code class="fe nq nr ns nt b">/</code>。这就是我们想要的效果，所以我们将其设置为我们的索引页面。当用户在地址栏中键入任意URL时，总是回退到<code class="fe nq nr ns nt b">index.html</code>，然后Vue就可以正确的做前端路由了。</p><p id="0f8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe nq nr ns nt b">"/"</code>索引路径已经被<code class="fe nq nr ns nt b">indexHandler</code>使用，我们需要为文件服务器使用另一种模式。但是如果我们没有设置<code class="fe nq nr ns nt b">assetsDir: 'static'</code>，我们需要像这样单独处理每个静态文件类型:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="baa3" class="lt lu iq nt b gy ny nz l oa ob">mux.Handle("/css/", httpFS)<br/>mux.Handle("/js/", httpFS)</span></pre><p id="af79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们花了相当大的篇幅解释Go中的这些错误。让我们继续看最后一段代码，<code class="fe nq nr ns nt b">indexHandler</code>。</p><h2 id="440d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">索引页面处理程序</h2><p id="8d56" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">这样定义<code class="fe nq nr ns nt b">router</code>下的<code class="fe nq nr ns nt b">indexHandler</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="b0f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码读取特定的嵌入文件，然后将它们写入HTTP响应。</p><p id="7025" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是它看起来很混乱，因为我们在这里也处理favicon。</p><p id="ddfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">老实说，我对前端不太熟悉。我没有找到一种简单的方法来改变favicon文件的位置。Vue中的默认位置在根<code class="fe nq nr ns nt b">"/favicon.ico"</code>下，所以我直接在这里处理了。(我们可以用像<code class="fe nq nr ns nt b">mux.Handle("/favicon.ico", faviconHandler)</code>这样的专用处理器来处理它)</p><p id="a9f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经完成了我们的Go SPA。该出发了。</p><h1 id="0395" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">建造并运营我们的水疗中心</h1><p id="34d7" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">首先构建我们的前端，这样就有工件可以嵌入。以下是代码:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="a898" class="lt lu iq nt b gy ny nz l oa ob">cd ui<br/>npm run build</span></pre><p id="e12e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行我们的Go HTTP服务器:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="3d32" class="lt lu iq nt b gy ny nz l oa ob">cd ..<br/>go run main.go</span></pre><p id="0e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们做一些测试。打开<code class="fe nq nr ns nt b"><a class="ae kv" href="http://localhost:8888" rel="noopener ugc nofollow" target="_blank">http://localhost:8888</a></code>(我们将端口硬编码为<code class="fe nq nr ns nt b">8888</code>)，您的浏览器应该显示默认的Vue主页:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/142b53927e4f76e7f6ce9d87366210ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWs7KJQ2-w1PBAc-PCcBtg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Vue默认主页</p></figure><p id="91ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击顶部的“关于”链接，更改“关于”页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/14da3cd8373561ea3c5773addfc2299f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNHtSz2yssZL1Wyb1i1CPg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Vue默认关于页面</p></figure><p id="26c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在地址栏中键入<code class="fe nq nr ns nt b"><a class="ae kv" href="http://localhost:8888/about" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/about</a></code>，然后按回车键。它应该显示相同的关于页面。</p><p id="5c1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">键入类似<code class="fe nq nr ns nt b"><a class="ae kv" href="http://localhost:8888/login" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/login</a></code>的任意URL来显示未找到的页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/7aa22d72c24a84bc3908c1a25a022d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrJnTmELU2PClBsonXzvJQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">找不到Vue页面</p></figure><p id="0ad2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">厉害！一切看起来都很棒。让我们使用CURL来测试我们的虚拟API，使用以下命令:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="356d" class="lt lu iq nt b gy ny nz l oa ob">curl -i "http://localhost:8888/api/v1/greeting"</span></pre><p id="d100" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="98b1" class="lt lu iq nt b gy ny nz l oa ob">HTTP/1.1 200 OK<br/>Date: Fri, 20 May 2022 02:47:58 GMT<br/>Content-Length: 13<br/>Content-Type: text/plain; charset=utf-8</span><span id="225d" class="lt lu iq nt b gy oc nz l oa ob">Hello, there!</span></pre><p id="145b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很好，让我们多测试一下。一个不存在的API怎么样，如果用户输入了错误的地址，就会发生这种情况。</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="5511" class="lt lu iq nt b gy ny nz l oa ob">curl -i "http://localhost:8888/api/v1/greting"</span></pre><p id="9d21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="5ee6" class="lt lu iq nt b gy ny nz l oa ob">HTTP/1.1 200 OK<br/>Date: Fri, 20 May 2022 02:53:18 GMT<br/>Content-Length: 611<br/>Content-Type: text/html; charset=utf-8</span><span id="e1ee" class="lt lu iq nt b gy oc nz l oa ob">&lt;!doctype html&gt;&lt;html lang=""&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;&lt;link rel="icon" href="/favicon.ico"&gt;&lt;title&gt;ui&lt;/title&gt;&lt;script defer="defer" src="/static/js/chunk-vendors.ea2100d5.js"&gt;&lt;/script&gt;&lt;script defer="defer" src="/static/js/app.fc9d9338.js"&gt;&lt;/script&gt;&lt;link href="/static/css/app.9bdcf330.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;strong&gt;We're sorry but ui doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;&lt;/noscript&gt;&lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span></pre><p id="ee9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哎呀…不存在的API调用是如何工作的？</p><p id="c823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细看，响应体其实就是我们前端的<code class="fe nq nr ns nt b">index.html</code>。</p><p id="3222" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是，我们没有任何与那个URL匹配的路由，所以它退回到索引路由<code class="fe nq nr ns nt b">"/"</code>。</p><p id="5ffa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们添加一些保护条款来防止这种情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">转到HTTP索引处理程序</p></figure><ul class=""><li id="300a" class="mm mn iq ky b kz la lc ld lf oe lj of ln og lr oh mu mv mw bi translated">在第2行，我们添加了一个方法检查，只允许GET方法</li><li id="eea1" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr oh mu mv mw bi translated">在第8行，如果<code class="fe nq nr ns nt b">URL.Path</code>以<code class="fe nq nr ns nt b">/api</code>为前缀，我们返回not found响应</li></ul><p id="9c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(理想情况下，在一个组织良好的项目中，最好将这些条件放在像中间件这样的东西中)</p><p id="950d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们重新构建我们的程序，并再次尝试不存在的API。这次应该会返回404:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="194e" class="lt lu iq nt b gy ny nz l oa ob">HTTP/1.1 404 Not Found<br/>Content-Type: text/plain; charset=utf-8<br/>X-Content-Type-Options: nosniff<br/>Date: Fri, 20 May 2022 03:14:42 GMT<br/>Content-Length: 19</span><span id="5cba" class="lt lu iq nt b gy oc nz l oa ob">404 page not found</span></pre><p id="be14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你。我们真的已经走了很长的路，并成功地用Go构建了我们成熟的单页面应用程序。</p><h1 id="5786" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">附加信息— Docker</h1><p id="65cd" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们也可以在Docker中构建我们的应用程序。</p><p id="99d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的项目根目录中创建一个docker文件，内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">去SPA dockerfile</p></figure><p id="d87b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="a89f" class="lt lu iq nt b gy ny nz l oa ob"># 1. build frontend<br/>cd ui<br/>npm run build</span><span id="68a6" class="lt lu iq nt b gy oc nz l oa ob"># 2. build docker image<br/>cd ..<br/>docker build -t go-spa:test .</span><span id="9bce" class="lt lu iq nt b gy oc nz l oa ob"># 3. (optional) remove intermediate images<br/>docker image prune -f</span><span id="a619" class="lt lu iq nt b gy oc nz l oa ob"># 4. run our SPA container<br/>docker run --rm -p "8888:8888" go-spa:test</span></pre><h1 id="282f" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">摘要</h1><p id="afa6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">这是一个很长的故事，但如果你看完整的Go代码，它是非常简短和简单的。我们需要理解Go的HTTP服务器的机制和局限性，并做出一些调整。</p><p id="5239" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些原则是:</p><ol class=""><li id="e60d" class="mm mn iq ky b kz la lc ld lf oe lj of ln og lr mt mu mv mw bi translated">了解前端构建工件的结构，找到并调整可能的配置设置，然后在Go中正确地提供这些文件。</li><li id="7ccd" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">理解Go的HTTP处理程序的模式匹配规则和特点</li></ol><p id="154c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我开始写这个故事之前，我确实花了很多时间去思考如何让这个故事成功。我不是一个有经验的程序员，特别是在前端，所以请让我知道是否有更好的解决方案，或者如果这里有什么不正确的地方。</p><p id="365c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢你的阅读！</p></div></div>    
</body>
</html>