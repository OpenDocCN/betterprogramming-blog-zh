<html>
<head>
<title>The Do’s and Don’ts of Python List Comprehension</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python列表理解的“做”和“不做”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-dos-and-don-ts-of-python-list-comprehension-5cd0f5d18500?source=collection_archive---------4-----------------------#2020-10-09">https://betterprogramming.pub/the-dos-and-don-ts-of-python-list-comprehension-5cd0f5d18500?source=collection_archive---------4-----------------------#2020-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">写出更好的Python，而不会让你的队友感到困惑</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/223de7f160c633744899c29f92cb0710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OMREOHfwYkIKRpRF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mdherren?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Michael Herren </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="93e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解是一个通常不提供给初学者的话题，因为它的语法不太直观，即使对那些有其他编程语言编码背景的人来说也是如此。</p><p id="4585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们有机会接触列表理解时，我们在这里学到了一些东西，在那里学到了一些东西，因此我们没有一个系统的观点来看待我们应该如何在各种场景中使用列表理解。</p><p id="b7db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想尽可能全面地提供可能的使用指南。我希望本文能成为你购买与列表理解相关技术的一站式商店。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce07" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">多的</h1><h2 id="82d5" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">1.在列表理解中不要使用任何可选项</h2><p id="3494" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">列表理解的最基本形式是从一个可迭代对象创建一个列表对象——任何您可以迭代其项目的Python对象。语法如下所示。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="572f" class="mu md it nm b gy nq nr l ns nt">[expression for item in <em class="nu">iterable</em>]</span></pre><p id="baa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段向您展示了一个使用列表理解技术创建列表对象的简单示例。在这个例子中，我们从一个整数列表开始，使用这个列表，我们为每个整数创建了一个正方形和立方体的元组列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本用法</p></figure><p id="707c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上一个示例使用list对象作为iterable。然而，我们应该意识到许多类型的对象都是可迭代的。我们知道常见的数据类型，如列表、集合、字典和字符串，都是可数据项。其他数据类型，如<code class="fe nx ny nz nm b">range</code> <em class="nu"> </em>对象、<code class="fe nx ny nz nm b">map</code> <em class="nu"> </em>对象、<code class="fe nx ny nz nm b">filter</code> <em class="nu"> </em>对象、<a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>‘<code class="fe nx ny nz nm b">Series</code>和<code class="fe nx ny nz nm b">DataFrame</code>对象等都是数据项。下面的代码向您展示了一些使用这些对象的示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">其他项目</p></figure><h2 id="9940" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">2.如果只需要一些项目，一定要应用条件标准</h2><p id="4e6f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">假设只有当元素符合特定标准时，您才希望从iterable创建一个对象列表。语法如下所示。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="a93e" class="mu md it nm b gy nq nr l ns nt">[expression for item in <em class="nu">iterable</em> if condition]</span></pre><p id="2db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">条件检查是通过在iterable之后的<code class="fe nx ny nz nm b">if</code>语句来实现的。下面的代码向您展示了这个用法的一个简单例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用条件标准</p></figure><h2 id="c978" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">3.一定要使用条件表达式</h2><p id="dd0d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">列表理解也可以使用条件赋值，它有以下语法。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5e5c" class="mu md it nm b gy nq nr l ns nt">[expression0 if condition else expression1 for item in <em class="nu">iterable</em>]</span></pre><p id="deaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来和前面的用法有点类似，但是不要和这两个混淆。在这种用法中，条件表达式本身就是一个整体。下面的代码向您展示了一个示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">条件赋值</p></figure><h2 id="b1fa" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">4.如果iterable有嵌套结构，一定要使用嵌套for循环</h2><p id="c028" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">虽然不太常见，但iterable中的元素也可能是iterables。如果您对处理嵌套iterables的元素感兴趣，您可以使用嵌套的<code class="fe nx ny nz nm b">for</code>循环。它具有以下语法。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="901d" class="mu md it nm b gy nq nr l ns nt">[expression for item_outer in iterable for item_inner in item_outer]</span><span id="2e34" class="mu md it nm b gy oa nr l ns nt"># Equivalent to<br/>for item_outer in iterable:<br/>    for item_inner in item_outer:<br/>        expression</span></pre><p id="0b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码展示了一个包含嵌套的<code class="fe nx ny nz nm b">for</code>循环的列表理解的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">嵌套for循环</p></figure><h2 id="26a6" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">5.务必替换高阶函数</h2><p id="a2a5" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">有些人更习惯于函数式编程。一个特殊的应用是使用高阶函数。具体来说，高阶函数是那些使用其他函数作为输入或输出参数的函数。Python中一些常见的高阶函数有<code class="fe nx ny nz nm b">map()</code>和<code class="fe nx ny nz nm b">filter()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">替换高阶函数</p></figure><p id="aa5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的例子所示，列表理解比高阶函数有更多可读的语法，高阶函数有更复杂的嵌入结构。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6a94" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要</h1><h2 id="3cd0" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">1.不要忘记list()构造函数</h2><p id="fb15" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">有些人可能认为列表理解是一个很酷的Python特性，用来炫耀他们的Python技能，即使有更好的选择，他们也倾向于使用它。一个这样的例子是使用<code class="fe nx ny nz nm b">list()</code>构造函数。考虑下面一些琐碎的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表理解</p></figure><p id="3d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们分别使用了一个范围和一个字符串作为iterables。然而，这两种类型的对象都是可迭代的，并且<code class="fe nx ny nz nm b">list()</code>构造函数可以直接获取可迭代的对象来创建一个新的列表对象。更好、更清洁的解决方案如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表构造函数的使用</p></figure><h2 id="3011" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">2.不要忘记生成器表达式</h2><p id="e3d9" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在Python中，生成器是一种特殊的迭代器，它延迟地呈现元素，直到被要求这样做。因此，这是一种非常节省内存的处理大量数据的方式。相比之下，list对象需要预先创建它的所有元素，这样它的元素就可以被计数和索引。与生成器相比，包含相同数量元素的列表需要更多的内存来存储。</p><p id="b45e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建一个生成器，我们可以定义一个生成器函数。然而，我们也可以使用下面的语法来创建一个生成器——一种称为<em class="nu">生成器表达式</em>的技术。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="835d" class="mu md it nm b gy nq nr l ns nt">(expression for item in <em class="nu">iterable</em>)</span></pre><p id="f31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，语法非常类似于list comprehension，除了使用括号而不是方括号。所以区分生成器表达式和列表理解也很重要。</p><p id="4a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面这个微不足道的例子。我们需要计算前一百万个整数的平方和。如果我们使用列表理解，这是我们的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大数之和</p></figure><p id="27d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，list对象占用81528032字节。让我们考虑一个生成器的相同操作，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大数和(生成器)</p></figure><p id="faf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与使用list comprehension的解决方案相比，使用generator表达式的解决方案涉及的对象要小得多，只有96个字节。原因很简单——生成器不需要捕获它们的所有元素。相反，他们只需要知道他们在序列中的位置，并简单地创建下一个适用的元素并呈现它，而不需要将元素保存在内存中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1c59" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b02c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在这篇文章中，我们回顾了使用列表理解的几个关键准则。如您所见，这些该做和不该做的事情非常简单。我想你应该能够在想要的场景中使用列表理解。这里有一个快速回顾。</p><ul class=""><li id="bac4" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">在列表理解中一定要使用任何可重复项。Python中存在许多类型的可重复项，你应该超越基本的类型，比如列表和元组。</li><li id="fa94" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">如果你对保持iterable中的一些元素感兴趣，请在list comprehension </strong>中应用过滤条件。</li><li id="9609" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">如果你想用另一种方法给结果元素赋值，请使用条件表达式。</li><li id="45e2" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">如果你正在处理嵌套的iterables，一定要使用嵌套的 <code class="fe nx ny nz nm b"><strong class="lb iu">for</strong></code> <strong class="lb iu">循环。</strong></li><li id="bc85" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">在许多用例中，一定要使用列表理解来代替高阶函数</strong>。</li><li id="ce6a" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">不要忘记list构造函数</strong>，它使用iterable来创建一个新的list对象。与列表理解相比，如果你直接使用iterable，这是推荐的方法。</li><li id="a4ef" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">不要忘记生成器表达式</strong>，它在语法上类似于列表理解。这是一种处理大量对象的高效内存方式。与生成器不同，列表必须在前面创建，以便以后索引和访问，如果列表有许多元素，这将消耗大量内存。</li></ul></div></div>    
</body>
</html>