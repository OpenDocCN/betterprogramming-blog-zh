<html>
<head>
<title>Using NFC With iOS in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React Native中配合iOS使用NFC</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reading-and-writing-nfc-in-react-native-d504a656eb78?source=collection_archive---------6-----------------------#2019-11-10">https://betterprogramming.pub/reading-and-writing-nfc-in-react-native-d504a656eb78?source=collection_archive---------6-----------------------#2019-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a187" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看一看react-native-nfc-manager</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4dc41b7ebd2489724c772bb0be107f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pg4uXz_hX-csJCnAZ7Lkdg.png"/></div></div></figure><p id="1e7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着iOS 13，苹果终于开放了SDK，在一些最受欢迎的NFC芯片上写入数据。</p><p id="2518" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得庆幸的是，最流行的(据我所知也是唯一的)NFC React原生库之一，<a class="ae lq" href="https://github.com/whitedogg13/react-native-nfc-manager" rel="noopener ugc nofollow" target="_blank"> react-native-nfc-manager </a>，也添加了(一些)支持来做到这一点。让我们看看它在实践中是如何工作的！</p><p id="b918" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TL；博士1:懒得看书？观看视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="52c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TL；博士2:只想要代码？<a class="ae lq" href="https://github.com/lepunk/react-native-nfc-demo/tree/master/RNNFCDemo" rel="noopener ugc nofollow" target="_blank">下面是代码！</a></p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="9bf9" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">安装库</h1><p id="8848" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">安装其实超级简单。首先，我们需要通过<a class="ae lq" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>添加模块。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="a8ce" class="nc mb it my b gy nd ne l nf ng">npm i --save react-native-nfc-manager</span></pre><p id="2c50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于安卓来说，就是这样。对于iOS，你必须做一些额外的步骤。首先，运行pod安装:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="3047" class="nc mb it my b gy nd ne l nf ng">cd ios &amp;&amp; pod install &amp;&amp; cd ..</span></pre><p id="7839" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，您必须将下列行添加到您的<code class="fe nh ni nj my b">info.plist</code>(在<code class="fe nh ni nj my b">ios/YourProject</code>)中:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="2667" class="nc mb it my b gy nd ne l nf ng">&lt;key&gt;NFCReaderUsageDescription&lt;/key&gt;<br/>&lt;string&gt;YOUR_PRIVACY_DESCRIPTION&lt;/string&gt;</span></pre><p id="789e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还需要为您的应用添加“近场通信标签读取”功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/7a92e8668be770dbbeada831bcf6d607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRj6TfCKvI5rf8hE3325mg.png"/></div></div></figure></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="4ce0" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">脚手架</h1><p id="0679" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">首先，让我们制作一些按钮和脚手架代码:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="1dc8" class="nc mb it my b gy nd ne l nf ng">import React, { Component } from 'react';<br/>import {<br/>    SafeAreaView,<br/>    StyleSheet,<br/>    View,<br/>    Text,<br/>    TextInput,<br/>    Alert,<br/>    Platform,<br/>    TouchableOpacity<br/>} from 'react-native';<br/>import NfcManager, { NfcTech } from 'react-native-nfc-manager';</span><span id="a070" class="nc mb it my b gy nl ne l nf ng">class App extends Component {<br/>    constructor(props){<br/>        super(props);</span><span id="6027" class="nc mb it my b gy nl ne l nf ng">this.state = {<br/>            log: "Ready...",<br/>            text: ""<br/>        }<br/>    }</span><span id="2933" class="nc mb it my b gy nl ne l nf ng">componentDidMount(){<br/>        NfcManager.start();<br/>    }</span><span id="bf1d" class="nc mb it my b gy nl ne l nf ng">componentWillUnMount(){<br/>        this.cleanUp();<br/>    }</span><span id="f6ec" class="nc mb it my b gy nl ne l nf ng">cleanUp = () =&gt; {<br/>        NfcManager.cancelTechnologyRequest().catch(() =&gt; 0);<br/>    }</span><span id="88e8" class="nc mb it my b gy nl ne l nf ng">onChangeText = (text) =&gt; {<br/>        this.setState({<br/>            text<br/>        })<br/>    }</span><span id="5550" class="nc mb it my b gy nl ne l nf ng">writeData = async () =&gt; {<br/>        <br/>    }</span><span id="10a3" class="nc mb it my b gy nl ne l nf ng">readData = async () =&gt; {<br/>        <br/>    }</span><span id="7848" class="nc mb it my b gy nl ne l nf ng">render(){<br/>        return (<br/>            &lt;SafeAreaView style={styles.container}&gt;<br/>                &lt;TextInput<br/>                    style={styles.textInput}<br/>                    onChangeText={this.onChangeText}<br/>                    autoCompleteType="off"<br/>                    autoCapitalize="none"<br/>                    autoCorrect={false}<br/>                    placeholderTextColor="#888888"<br/>                    placeholder="Enter text here" /&gt;</span><span id="cd00" class="nc mb it my b gy nl ne l nf ng">&lt;TouchableOpacity<br/>                    onPress={this.writeData}<br/>                    style={styles.buttonWrite}&gt;<br/>                    &lt;Text style={styles.buttonText}&gt;Write&lt;/Text&gt;<br/>                &lt;/TouchableOpacity&gt;</span><span id="a22f" class="nc mb it my b gy nl ne l nf ng">&lt;TouchableOpacity<br/>                    onPress={this.readData}<br/>                    style={styles.buttonRead}&gt;<br/>                    &lt;Text style={styles.buttonText}&gt;Read&lt;/Text&gt;<br/>                &lt;/TouchableOpacity&gt;</span><span id="01e0" class="nc mb it my b gy nl ne l nf ng">&lt;View style={styles.log}&gt;<br/>                    &lt;Text&gt;{this.state.log}&lt;/Text&gt;<br/>                &lt;/View&gt;<br/>            &lt;/SafeAreaView&gt;<br/>        )<br/>    }<br/>}</span><span id="65ca" class="nc mb it my b gy nl ne l nf ng">const styles = StyleSheet.create({<br/>    container: {<br/>        flex: 1,<br/>        flexDirection: 'column',<br/>        justifyContent: 'center'<br/>    },<br/>    textInput: {<br/>        marginLeft: 20,<br/>        marginRight: 20,<br/>        height: 50,<br/>        marginBottom: 10,<br/>        textAlign:'center',<br/>        color: 'black'<br/>    },<br/>    buttonWrite: {<br/>        marginLeft: 20,<br/>        marginRight: 20,<br/>        height: 50,<br/>        marginBottom: 10,<br/>        alignItems: 'center',<br/>        justifyContent: 'center',<br/>        borderRadius: 8,<br/>        backgroundColor: '#9D2235'<br/>    },<br/>    buttonRead: {<br/>        marginLeft: 20,<br/>        marginRight: 20,<br/>        height: 50,<br/>        marginBottom: 10,<br/>        alignItems: 'center',<br/>        justifyContent: 'center',<br/>        borderRadius: 8,<br/>        backgroundColor: '#006C5B'<br/>    },<br/>    buttonText: {<br/>        color: 'white'<br/>    },<br/>    log: {<br/>        marginTop: 30,<br/>        height: 50,<br/>        alignItems: 'center',<br/>        justifyContent: 'center',<br/>    }<br/>});</span><span id="3b67" class="nc mb it my b gy nl ne l nf ng">export default App;</span></pre><p id="ed68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里不多解释了。</p><p id="3744" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经设置了一个输入字段，它将包含我们想要写入标记的文本。还有两个按钮，一个用于书写，一个用于阅读。最后，一个用于记录内容的文本字段。相当基础…</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="95f8" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">写入数据</h1><p id="05f4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">老实说，在写这篇文章之前，我不知道有不同的NFC芯片。我干脆从亚马逊订了最便宜的，正好是Mifare超轻芯片组一。</p><p id="866c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，该库在iOS上对这种芯片组的支持非常基本:你所能做的就是向芯片发送命令。</p><p id="55d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我的第一反应是订购一套支持更好的新标签。但是后来我开始谷歌东西，找到了Mifare Ultralight 的<a class="ae lq" href="https://www.nxp.com/docs/en/data-sheet/NTAG213_215_216.pdf#page=41&amp;zoom=100,0,793" rel="noopener ugc nofollow" target="_blank">文档。</a></p><p id="816f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第41页，文档描述了写入数据时需要发送的命令。下面是它在React Native中的样子:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="03fe" class="nc mb it my b gy nd ne l nf ng">writeData = async () =&gt; {<br/>    if (!this.state.text){<br/>        Alert.alert("Enter some text");<br/>        return;<br/>    }</span><span id="7a46" class="nc mb it my b gy nl ne l nf ng">try {<br/>        let tech = Platform.OS === 'ios' ? NfcTech.MifareIOS : NfcTech.NfcA;<br/>        let resp = await NfcManager.requestTechnology(tech, {<br/>            alertMessage: "Ready for magic"<br/>        });</span><span id="551a" class="nc mb it my b gy nl ne l nf ng">let cmd = Platform.OS === 'ios' ? NfcManager.sendMifareCommandIOS : NfcManager.transceive;<br/>        let text = this.state.text;<br/>        let fullLength = text.length + 7;<br/>        let payloadLength = text.length + 3;</span><span id="fd07" class="nc mb it my b gy nl ne l nf ng">resp = await cmd([0xA2, 0x04, 0x03, fullLength, 0xD1, 0x01]);<br/>        resp = await cmd([0xA2, 0x05, payloadLength, 0x54, 0x02, 0x65]) // T enYourPayload</span><span id="658d" class="nc mb it my b gy nl ne l nf ng">let currentPage = 6;<br/>        let currentPayload = [0xA2, currentPage, 0x6E]; // n</span><span id="6017" class="nc mb it my b gy nl ne l nf ng">for(let i=0; i&lt;text.length; i++){<br/>            currentPayload.push(text.charCodeAt(i));<br/>            if (currentPayload.length == 6){<br/>                resp = await cmd(currentPayload);<br/>                currentPage += 1;<br/>                currentPayload = [0xA2, currentPage]<br/>            }<br/>        }</span><span id="f55a" class="nc mb it my b gy nl ne l nf ng">currentPayload.push(254);<br/>        while(currentPayload.length &lt; 6){<br/>            currentPayload.push(0);<br/>        }</span><span id="cca6" class="nc mb it my b gy nl ne l nf ng">resp = await cmd(currentPayload);<br/>        this.setState({<br/>            log: resp.toString() === "10" ? "Success" : resp.toString()<br/>        })</span><span id="a447" class="nc mb it my b gy nl ne l nf ng">//sendMifareCommandIOS<br/>    } catch(err){<br/>        this.setState({<br/>            log: err.toString()<br/>        })<br/>        this.cleanUp();<br/>    }<br/>}</span></pre><p id="c220" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，别害怕，这其实很简单。我们来分解一下。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="f00a" class="nc mb it my b gy nd ne l nf ng">let resp = await NfcManager.requestTechnology(tech, {<br/>    alertMessage: "Ready for magic"<br/>});</span></pre><p id="3664" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这三行告诉引擎，您正在尝试与Mifare Ultralight芯片通信。iOS将自动呈现标准UI，执行将等待，直到这样的设备非常接近NFC读取器。</p><p id="44e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，芯片已准备好接受命令。在iOS上，你可以用<code class="fe nh ni nj my b">NfcManager.sendMifareCommandIOS</code>发送命令，它接受一个字节列表。</p><p id="09aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据文档，所有的写命令都应该以<code class="fe nh ni nj my b">0xA2</code>开头，后面跟着你正在写的页面的地址。在我的芯片上，所有页面可以包含四个字节，它们的地址在<code class="fe nh ni nj my b">0x02</code>和<code class="fe nh ni nj my b">0x2C</code>之间。</p><p id="ebfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj my b">0x02</code>和<code class="fe nh ni nj my b">0x03</code>其实是保留的，所以你要写的第一页是<code class="fe nh ni nj my b">0x04</code>。</p><p id="5b8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们要写一个文本类型的记录，它应该遵循一定的模式:</p><ol class=""><li id="ff7c" class="nm nn it kw b kx ky la lb ld no lh np ll nq lp nr ns nt nu bi translated">第一个字节是<code class="fe nh ni nj my b">0x03</code>。</li><li id="2965" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated">第二个字节应该是完整有效载荷的长度(它将是文本的长度+ 7)。</li><li id="f540" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated">第三个字节是<code class="fe nh ni nj my b">0xD1</code>。</li><li id="2525" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated">第四个字节是<code class="fe nh ni nj my b">0x01</code>。</li><li id="105d" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated">第五个字节是记录的长度(在文本记录的情况下，它将是文本的长度+ 3)。</li><li id="8e7e" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated"><code class="fe nh ni nj my b">0x54</code>-&gt;“T”字。</li><li id="450b" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated"><code class="fe nh ni nj my b">0x02</code></li><li id="7600" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated"><code class="fe nh ni nj my b">0x65</code> - &gt;字符“e”。</li><li id="1675" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated"><code class="fe nh ni nj my b">0x6E</code> - &gt;人物“n”。</li><li id="2881" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated">你的短信。</li><li id="3939" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated"><code class="fe nh ni nj my b">0xFE</code>关闭记录。</li></ol><p id="fb1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这部分代码负责上述内容:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="8d8f" class="nc mb it my b gy nd ne l nf ng">let text = this.state.text;<br/>        let fullLength = text.length + 7;<br/>        let payloadLength = text.length + 3;</span><span id="eefd" class="nc mb it my b gy nl ne l nf ng">resp = await cmd([0xA2, 0x04, 0x03, fullLength, 0xD1, 0x01]);<br/>        resp = await cmd([0xA2, 0x05, payloadLength, 0x54, 0x02, 0x65]) // T enYourPayload</span><span id="4443" class="nc mb it my b gy nl ne l nf ng">let currentPage = 6;<br/>        let currentPayload = [0xA2, currentPage, 0x6E]; // n</span><span id="ad83" class="nc mb it my b gy nl ne l nf ng">for(let i=0; i&lt;text.length; i++){<br/>            currentPayload.push(text.charCodeAt(i));<br/>            if (currentPayload.length == 6){<br/>                resp = await cmd(currentPayload);<br/>                currentPage += 1;<br/>                currentPayload = [0xA2, currentPage]<br/>            }<br/>        }</span><span id="511e" class="nc mb it my b gy nl ne l nf ng">currentPayload.push(254);<br/>        while(currentPayload.length &lt; 6){<br/>            currentPayload.push(0);<br/>        }</span><span id="69ff" class="nc mb it my b gy nl ne l nf ng">resp = await cmd(currentPayload);</span></pre></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="729f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">读取数据</h1><p id="dc1a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">读取数据其实更简单一点。下面是实现的函数:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="7408" class="nc mb it my b gy nd ne l nf ng">readData = async () =&gt; {<br/>    try {<br/>        let tech = Platform.OS === 'ios' ? NfcTech.MifareIOS : NfcTech.NfcA;<br/>        let resp = await NfcManager.requestTechnology(tech, {<br/>            alertMessage: "Ready for magic"<br/>        });</span><span id="9170" class="nc mb it my b gy nl ne l nf ng">let cmd = Platform.OS === 'ios' ? NfcManager.sendMifareCommandIOS : NfcManager.transceive;</span><span id="a049" class="nc mb it my b gy nl ne l nf ng">resp = await cmd([0x3A, 4, 4])<br/>        let payloadLength = parseInt(resp.toString().split(",")[1]);<br/>        let payloadPages = Math.ceil(payloadLength / 4);<br/>        let startPage = 5;<br/>        let endPage = startPage + payloadPages - 1;</span><span id="b9fc" class="nc mb it my b gy nl ne l nf ng">resp = await cmd([0x3A, startPage, endPage]);<br/>        let bytes = resp.toString().split(",");<br/>        let text = ""</span><span id="0b01" class="nc mb it my b gy nl ne l nf ng">for(let i=0; i&lt;bytes.length; i++){<br/>            if (i&lt;5){<br/>                continue;<br/>            }</span><span id="05e2" class="nc mb it my b gy nl ne l nf ng">if (parseInt(bytes[i]) === 254){<br/>                break;<br/>            }</span><span id="edd4" class="nc mb it my b gy nl ne l nf ng">text = text + String.fromCharCode(parseInt(bytes[i]));<br/>        }</span><span id="0d92" class="nc mb it my b gy nl ne l nf ng">this.setState({<br/>            log: text<br/>        })<br/>    } catch(err){<br/>        this.setState({<br/>            log: err.toString()<br/>        })<br/>        this.cleanUp();<br/>    }<br/>}</span></pre><p id="74bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请求技术后，我们可以开始发送命令。文档的第39页解释了<code class="fe nh ni nj my b">FAST_READ</code>命令，它有一个非常简单的界面:</p><ol class=""><li id="c10c" class="nm nn it kw b kx ky la lb ld no lh np ll nq lp nr ns nt nu bi translated">请求的第一个字节是<code class="fe nh ni nj my b">0x3A</code>。</li><li id="c480" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated">第二个字节是你想读的第一页。</li><li id="d7ba" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated">第三个字节是你想读的最后一页。</li></ol><p id="599f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的实现中，我们首先读取第三页，它包含完整的有效载荷长度。根据有效载荷的长度，我们可以计算出需要请求多少个页面。</p><p id="715f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这一点开始，我们将忽略文本记录的标题(<code class="fe nh ni nj my b">i&lt;5</code>)，继续读取字符，直到<code class="fe nh ni nj my b">0xFE</code>结束符。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="df7e" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结论</h1><p id="cd89" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">仅此而已。当然，这只是一个概念证明。你可以用NFC技术做很多事情。</p><p id="61ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">iOS的这个库现在还处于非常早期的阶段，但是这个库非常活跃，所以我相信很快就会发布一个更好的API。</p></div></div>    
</body>
</html>