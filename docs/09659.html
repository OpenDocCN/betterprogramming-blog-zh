<html>
<head>
<title>Understanding Semantic and Validated Types in TypeScript 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解TypeScript 4中的语义和验证类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-semantic-and-validated-types-in-typescript-4-54ce43d7d90f?source=collection_archive---------9-----------------------#2021-09-22">https://betterprogramming.pub/understanding-semantic-and-validated-types-in-typescript-4-54ce43d7d90f?source=collection_archive---------9-----------------------#2021-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7711" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用TypeScript 4.1中引入的模板文本类型，您可以创建语义和验证类型，使您的代码更加类型安全</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eb2b0791b114c369e85ea4eb99858615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Aea3NL1xVffxeJDK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@markuswinkler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="be1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">📕看看我的新书</strong> <a class="ae kv" href="https://www.amazon.com/Clean-Code-Principles-Patterns-Practitioners-ebook/dp/B0BSDJKYQJ/ref=sr_1_1?crid=8M0CMV4CP6UQ&amp;keywords=clean+code+principles&amp;qid=1674980636&amp;sprefix=clean+code+principle%2Caps%2C175&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">干净代码原则和模式:软件从业者手册</strong> </a>！</p><h1 id="f634" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">语义类型</h1><p id="b62a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/pksilen/validated-types" rel="noopener ugc nofollow" target="_blank"> validated-types </a>是一个使用TypeScript创建语义类型和变量的库。使用语义类型，您可以区分同一基本类型的多种类型。例如，如果一个函数接受两个布尔参数，调用函数可能会以错误的顺序给出这两个参数，但您永远不会注意到这一点，因为它不会生成编译错误。</p><p id="853d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你只是像平常一样嘲笑被调用的函数，你也不会在单元测试中发现它。只有你的集成测试覆盖率足够大，你才能在集成测试中抓住它。</p><p id="e16d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用语义类型，您可以通过给它们两个不同的语义名称来区分这两种布尔类型。那么就不可能以错误的顺序给出这两个论点。语义名称只是描述类型和变量用途的任何字符串。语义名称的类型定义如下:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a7a3" class="mu lt iq mq b gy mv mw l mx my">type SemName&lt;N extends string&gt; = N extends `${infer Name}` ? `${Name}` : never;</span></pre><p id="0375" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的例子使用<code class="fe mz na nb mq b">validated-types</code>库的<code class="fe mz na nb mq b">SemVar</code>(语义变量)声明两个语义类型和两个不同语义名称的布尔类型变量:<code class="fe mz na nb mq b">isRecursiveCall</code>和<code class="fe mz na nb mq b">isInternalCall</code> <em class="nc">。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="c1ff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">验证的类型</h1><p id="60eb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/pksilen/validated-types" rel="noopener ugc nofollow" target="_blank"> validated-types </a>也是TypeScript的类型值验证库。您可以验证整数、浮点数、字符串和数组的值。使用这四个基本验证器，您可以创建被验证的完整对象。例如，对于数字，您可以验证最小值和最大值。对于字符串，您可以验证最小和最大长度，还可以执行语义验证来验证字符串是否应该是有效的URL、IP地址或电子邮件地址。</p><p id="0f55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过对应用程序函数的参数使用经验证的类型，您可以放心，只有正确的值才会传递给函数。您不必在函数内部做任何验证工作，只需使用已经验证过的参数值。值的验证只在构造验证对象时进行一次，因此根据需要多次使用验证值不会影响性能。</p><p id="9d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该在接收未经验证的输入数据的函数中创建经过验证的整数、浮点、字符串和数组对象，然后将经过验证的值传递给应用程序中的其余函数。</p><p id="14a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下列情况下，您的应用程序通常会从外部来源接收未经验证的输入数据:</p><ul class=""><li id="0aba" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">读取命令行参数</li><li id="1165" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">读取环境变量</li><li id="0290" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">读取标准输入</li><li id="2d27" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">从文件系统中读取文件</li><li id="6a6c" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">从套接字读取数据(网络输入)</li><li id="c5c2" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">来自用户界面的最终用户输入</li></ul><h2 id="c1ae" class="mu lt iq bd lu nt nu dn ly nv nw dp mc lf nx ny me lj nz oa mg ln ob oc mi od bi translated">验证整数</h2><p id="0033" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面是一个使用<code class="fe mz na nb mq b">validated-types</code>库的<code class="fe mz na nb mq b">VInt</code>(经验证的整数)创建一个允许值在1到10之间的经验证的整数的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7bb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上例中为<code class="fe mz na nb mq b">VInt</code> <strong class="ky ir"> </strong>给出的泛型类型参数“1，10”与以下类型匹配:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d793" class="mu lt iq mq b gy mv mw l mx my">type IntValidationSpec&lt;ValidationSpec extends string&gt; =<br/> ValidationSpec extends `${infer MinValue},${infer MaxValue}`<br/>    ? `${MinValue},${MaxValue}`<br/>    : never;</span></pre><p id="e15f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你用一个不同的泛型类型参数声明一个<code class="fe mz na nb mq b">VInt</code>，例如‘0，100’，那么它就是它自己的不同类型。你不能用一个类型为<code class="fe mz na nb mq b">VInt&lt;’1,10'&gt;</code>的变量来代替类型为<code class="fe mz na nb mq b">VInt&lt;’0,100'&gt;</code> <strong class="ky ir"> </strong>的变量，反之亦然，你会得到一个编译错误，这就是为什么你的代码更加类型安全。</p><h2 id="5d23" class="mu lt iq bd lu nt nu dn ly nv nw dp mc lf nx ny me lj nz oa mg ln ob oc mi od bi translated">验证字符串</h2><p id="42a3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面是一个使用<code class="fe mz na nb mq b">validated-types</code> <em class="nc"> </em>库的<strong class="ky ir"><em class="nc"/></strong><code class="fe mz na nb mq b">VString</code><em class="nc"/>(经验证的字符串)创建经验证的字符串的示例，该字符串允许URL的最小长度为一个字符，最大长度为1024个字符:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="8e7b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><p id="e6d1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有关<code class="fe mz na nb mq b">validated-types</code> <em class="nc"> </em>库<em class="nc"> </em>和API文档的更多示例，请查看Github中的以下资源库:</p><ul class=""><li id="e312" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated"><a class="ae kv" href="https://github.com/pksilen/validated-types" rel="noopener ugc nofollow" target="_blank">https://github.com/pksilen/validated-types</a></li></ul></div></div>    
</body>
</html>