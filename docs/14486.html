<html>
<head>
<title>Writing a Fully Fledged REST API Using PostgreSQL, Gin, and Gorm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PostgreSQL、Gin和Gorm编写成熟的REST API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-a-fully-fledged-api-using-postgresql-gin-and-gorm-4d5ba73114da?source=collection_archive---------2-----------------------#2022-12-23">https://betterprogramming.pub/writing-a-fully-fledged-api-using-postgresql-gin-and-gorm-4d5ba73114da?source=collection_archive---------2-----------------------#2022-12-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0661" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">一步一步地构建一个速度惊人的API</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/2dd9f84a3102e7fc0445c1201dc91ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rXWSkxXB2Q-TnCaU"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kz" href="https://unsplash.com/it/@geekgunda?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Chinmay Bhattar </a>拍摄的照片</p></figure><p id="8b7b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">无法掩盖的事实是，多年来我一直是C#的坚定拥护者。十多年来，我一直在使用编程语言，近年来，语言本身及其外围框架都取得了长足的进步。</p><p id="4472" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">C#不太吸引人的一个方面是它极其冗长。即使是编写一个相对较小的项目，项目、文件和代码行的数量也会迅速增加。</p><p id="80cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了使事情易于管理，特别是在大型项目中，多年来出现了许多模式和最佳实践。对于大多数现代的C # web项目，依赖注入是标准，数据库通过ORM访问，路由由一个复杂的框架处理。</p><p id="2606" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一切都与复杂性有关。为了管理这种复杂性，引入了像<a class="ae kz" href="https://aevitas.medium.com/the-onion-architecture-in-5-minutes-537e9c31da04" rel="noopener">洋葱架构</a>这样的架构，使事情变得更加复杂。你最终得到一个项目，即使是最基本的改变，你也需要对上面提到的所有概念有一个坚实的理解。</p><p id="92c4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我写代码已经超过十五年了。这些年来，有一个原则是我真正开始考虑的写好代码的基本概念之一:在你写的所有代码中，<em class="lw">无情地删除复杂性。</em></p><p id="fd27" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我认为有一种语言真正体现了一致性和简单性，那就是<a class="ae kz" href="https://go.dev" rel="noopener ugc nofollow" target="_blank"> Go </a>。</p><p id="8c1e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我在过去几个月里写的大部分新代码都在Go中，这是一股新鲜空气。在这篇文章中，我将分享一些我学到的东西，因为我们将构建一个非常基本的API。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj lx"><img src="../Images/c65e36b2d260d08334d2c5bb73287a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1jO2aFSa50LEknVW"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@sebastiansvenson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sebastian Svenson </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="96a0" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">做好准备</h1><p id="f165" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj ms ll lm ln mt lp lq lr mu lt lu lv in bi translated">重要的事情先来。你需要安装<a class="ae kz" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank"> Go开发工具</a>，还需要一个代码编辑器。在我写作的时候，我正在运行Go 1.19，我正在使用带有Go扩展的Visual Studio代码作为我的编辑器。</p><p id="591b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以从命令行直接使用Go做大多数事情，因此IDE是完全可选的。如果你愿意，你甚至可以使用记事本。</p><p id="2930" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">准备就绪后，通过创建一个新文件夹并运行以下命令来验证您已经正确设置了所有内容:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="be29" class="na lz iu mw b be nb nc l nd ne">$ go mod init aevitas.dev/go-api<br/>go: creating new go.mod: module aevitas.dev/go-api</span></pre><p id="1351" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您应该会在新文件夹中看到一个包含以下内容的<code class="fe nf ng nh mw b">go.mod</code>文件:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="e74d" class="na lz iu mw b be nb nc l nd ne">module aevitas.dev/go-api<br/><br/>go 1.19</span></pre><p id="f6f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您愿意，您可以更改包的名称，即<code class="fe nf ng nh mw b">aevitas.dev/go-api</code>——但是请记住，您需要在以后对所有的<code class="fe nf ng nh mw b">import</code>语句应用这个更改！</p><h1 id="68f1" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">主包</h1><p id="db45" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj ms ll lm ln mt lp lq lr mu lt lu lv in bi translated">一个Go应用程序的入口点是<code class="fe nf ng nh mw b">package main</code>——这个包应该包含一个名为<code class="fe nf ng nh mw b">main()</code>的函数，这个函数将在应用程序启动时被调用。</p><p id="9367" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为我们不想自己编写API的所有代码，而是使用包来处理请求路由和获取环境变量，所以我们必须熟悉Go的包管理器。</p><p id="c2d6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不像NuGet或NPM这样的包管理器，Go包管理器可以从你在<code class="fe nf ng nh mw b">go get</code>抛出的任何URL中抓取一个包，只要目的URL包含一个有效的包。</p><p id="d262" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们需要从环境变量中获取数据库连接字符串。您可以直接设置环境变量，或者使用一个<code class="fe nf ng nh mw b">.env</code>文件来存储它们。我们将使用后者。</p><p id="f511" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在您的项目文件夹中，运行<code class="fe nf ng nh mw b">go get github.com/joho/godotenv</code> —这将在您的项目中安装<code class="fe nf ng nh mw b">godotenv</code>包。</p><p id="8beb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦就位，在与<code class="fe nf ng nh mw b">go.mod</code>相同的目录中创建一个名为<code class="fe nf ng nh mw b">main.go</code>的文件，并添加以下代码:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="164d" class="na lz iu mw b be nb nc l nd ne">package main<br/><br/>import (<br/> "log"<br/> "os"<br/><br/> "github.com/joho/godotenv"<br/>)<br/><br/>func main() {<br/> err := godotenv.Load()<br/><br/> if err != nil {<br/>  log.Fatal(err)<br/> }<br/><br/> dsn := os.Getenv("DB_DSN")<br/>}</span></pre><p id="eeeb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可能会得到一个警告，说<code class="fe nf ng nh mw b">dsn</code>未被使用。没错。我们稍后将回到这个文件并修复它。如果真的困扰你，就在开头加上<code class="fe nf ng nh mw b">//</code>注释掉这一行。</p><h1 id="29ad" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">书籍模型</h1><p id="ff76" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj ms ll lm ln mt lp lq lr mu lt lu lv in bi translated">我们将处理——令人惊讶地——书籍作为我们API的主题。在我们这样做之前，我们需要在我们的领域内定义一本书的内容。</p><p id="f77c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这只是我们需要为我们的书创建一个模型的一种奇特的说法。在Go中，任何可能被外部使用的代码都应该放在<code class="fe nf ng nh mw b">pkg</code>文件夹中(反过来，任何<em class="lw">从不</em>被外部使用的代码都应该放在<code class="fe nf ng nh mw b">internal</code>文件夹中)。</p><p id="db23" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为我们正在构建一个API，所以我们确实希望外部用户使用我们的模型代码。因此，在您的项目的根目录中，创建一个包含一个文件的<code class="fe nf ng nh mw b">pkg</code>文件夹:<code class="fe nf ng nh mw b">pkg/book.go</code></p><p id="363e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe nf ng nh mw b">book.go</code>文件中，添加以下代码:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="062b" class="na lz iu mw b be nb nc l nd ne">package pkg<br/><br/>type Book struct {<br/> Id     uint64  `json:"id"`<br/> ISBN   string  `json:"isbn"`<br/> Title  string  `json:"title"`<br/> Author string  `json:"author"`<br/> Price  float64 `json:"price"`<br/>}</span></pre><p id="86c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意包名是如何从<code class="fe nf ng nh mw b">main</code>变成<code class="fe nf ng nh mw b">pkg</code>的——这向编译器表明代码驻留在不同的包中。每个包都被视为一个独立的单元，所以为了使用这段代码，我们必须将其定义为<code class="fe nf ng nh mw b">pkg.Book</code></p><p id="ff11" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为我们的模型最终将被序列化为JSON，所以我们在字段的类型之后提供了序列化属性的名称:<code class="fe nf ng nh mw b">json:"id"</code> —序列化程序将识别这一点并相应地命名属性。</p><p id="c827" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目前关于图书模型的内容已经足够了。让我们添加一些功能。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ni"><img src="../Images/e2d47f2325b720e1479d1b23dea01efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LfGBGDxjtBRkole_"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@s___d___g?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sole D'Alessandro G. </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="66f4" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">服务器</h1><p id="f542" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj ms ll lm ln mt lp lq lr mu lt lu lv in bi translated">在本节开始之前，我想说有许多方法可以解决这个问题，这只是其中之一。我发现在Go中访问数据库的基本问题是，对数据库的访问必须通过程序。</p><p id="2ec6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本指南中，我让<code class="fe nf ng nh mw b">Server</code>类型对此负责。我不确定这是不是最好的方法，但在我见过的方法中，它对我来说最有意义。</p><p id="9ac7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不管怎样，我们开始吧。在您的项目文件夹中，创建<code class="fe nf ng nh mw b">./api</code>文件夹，并添加一个<code class="fe nf ng nh mw b">server.go</code>以便路径<code class="fe nf ng nh mw b">./api/server.go</code>有效。</p><p id="c1ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的服务器由两部分组成:一个数据库指针和一个路由器。为了保持它们有组织，我们在一个<code class="fe nf ng nh mw b">struct</code>中定义它们——一个可以包含这两个元素的数据结构。代码的基本前提是这样的:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="3814" class="na lz iu mw b be nb nc l nd ne">package api<br/><br/>type Server struct {<br/> DB  *gorm.DB<br/> Gin *gin.Engine<br/>}</span></pre><p id="06e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，Gorm和Gin都是在外部包中定义的。我们需要抓住他们:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="d6af" class="na lz iu mw b be nb nc l nd ne">$ go get gorm.io/gorm<br/>$ go get gorm.io/driver/postgres<br/>$ go get github.com/gin-gonic/gin</span></pre><p id="3029" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，在本教程中，我将使用本地PostgreSQL服务器。如果你没有，用SQLite代替也很好——只是用<br/> <code class="fe nf ng nh mw b">go get gorm.io/driver/sqlite</code>代替。</p><p id="a799" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们将编写一些函数来帮助我们设置服务器实例——初始化数据库连接、设置路由器等。我们还将添加一个<code class="fe nf ng nh mw b">Ready()</code>函数来指示服务器是否准备好了:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="31ef" class="na lz iu mw b be nb nc l nd ne">func (s *Server) InitDb(dsn string) *Server {<br/> db, err := gorm.Open(postgres.Open(dsn))<br/><br/> if err != nil {<br/>  log.Fatal(err)<br/> }<br/><br/> s.DB = db<br/><br/> return s<br/>}<br/><br/>func (s *Server) InitGin() *Server {<br/> g := gin.Default()<br/><br/> s.Gin = g<br/><br/> return s<br/>}<br/><br/>func (s *Server) Ready() bool {<br/> return s.DB != nil &amp;&amp; s.Gin != nil<br/>}</span></pre><p id="7b01" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">插入这段代码后，您可能会看到许多红色的曲线，因为编译器无法解析某些引用。在命令行中运行<code class="fe nf ng nh mw b">go mod tidy</code>来缓解这个问题——它将确保所有的包都能正确解析。</p><p id="44e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，如果您正在使用SQLite，用一个<code class="fe nf ng nh mw b">sqlite.Open</code>调用替换<code class="fe nf ng nh mw b">postgres.Open</code>调用，并且只使用一个文件名而不是传入<code class="fe nf ng nh mw b">dsn</code>——结果行看起来类似于:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="d070" class="na lz iu mw b be nb nc l nd ne">db, err := gorm.Open(postgres.Open("books.db"))</span></pre><p id="cb94" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">拥有一个我们无法启动的服务器没有什么意义，所以在文件的底部，添加:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="db18" class="na lz iu mw b be nb nc l nd ne">func (s *Server) Start(ep string) error {<br/> if !s.Ready() {<br/>  return errors.New("server isn't ready - make sure to init db and gin")<br/> }<br/><br/> if err := http.ListenAndServe(ep, s.Gin.Handler()); err != nil {<br/>  log.Fatal(err)<br/> }<br/><br/> return nil<br/>}</span></pre><p id="cf01" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将所有这些函数定义为<code class="fe nf ng nh mw b">Server</code>类型的方法。这意味着我们不能直接调用它们，而是必须创建一个服务器实例，然后调用这些方法。我们会在<code class="fe nf ng nh mw b">main.go</code>文件中解决这个问题。</p><h1 id="52ff" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">主要重访</h1><p id="8ddd" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj ms ll lm ln mt lp lq lr mu lt lu lv in bi translated">回到<code class="fe nf ng nh mw b">main.go</code>，我们现在有了一个服务器类型，我们可以实例化并运行它来服务我们的API。在<code class="fe nf ng nh mw b">dsn</code>定义行周围，添加以下内容:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="5bf1" class="na lz iu mw b be nb nc l nd ne"> srv := &amp;api.Server{}<br/><br/> dsn := os.Getenv("DB_DSN")<br/><br/> srv.InitDb(dsn)<br/> srv.InitGin()<br/><br/> srv.RegisterRoutes()<br/><br/> srv.Start(":8050")</span></pre><p id="45aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里的第一行创建了一个<code class="fe nf ng nh mw b">Server</code>类型的新实例，没有指定它的任何字段。后面的<code class="fe nf ng nh mw b">InitDb</code>和<code class="fe nf ng nh mw b">InitGin</code>调用是我们刚刚实现的，会设置我们的数据库和路由器。</p><p id="c3fa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们最终的<code class="fe nf ng nh mw b">main.go</code>文件应该是这样的:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="bc2b" class="na lz iu mw b be nb nc l nd ne">package main<br/><br/>import (<br/> "log"<br/> "os"<br/><br/> "aevitas.dev/go-books/api"<br/> "github.com/joho/godotenv"<br/>)<br/><br/>func main() {<br/> err := godotenv.Load()<br/><br/> if err != nil {<br/>  log.Fatal(err)<br/> }<br/><br/> srv := &amp;api.Server{}<br/><br/> dsn := os.Getenv("DB_DSN")<br/><br/> srv.InitDb(dsn)<br/> srv.InitGin()<br/><br/> srv.RegisterRoutes()<br/><br/> srv.Start(":8050") // Or grab this from the env, too!<br/>}</span></pre><p id="10dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你们当中善于观察的人会注意到两件事:</p><ol class=""><li id="1aa1" class="nj nk iu lc b ld le lg lh lj nl ln nm lr nn lv no np nq nr bi translated">我们实际上还没有一个API来服务</li><li id="95a5" class="nj nk iu lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated">我们没有在<code class="fe nf ng nh mw b">server.go</code>中实现<code class="fe nf ng nh mw b">RegisterRoutes</code></li></ol><p id="297b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">两者都是正确的。让我们添加一些处理程序，这样我们就可以开始提供一些内容。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nx"><img src="../Images/f2e09397757c617464e0c748be625b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RjWfo7PQf5lzCqBq"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@kencheungphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张艺</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="a232" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">经手人</h1><p id="49af" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj ms ll lm ln mt lp lq lr mu lt lu lv in bi translated">与服务器一样，有很多很多方法可以做到这一点。出于本文的目的，我再次决定保持简单，直接在处理程序中实现逻辑。</p><p id="8dee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe nf ng nh mw b">api</code>文件夹中创建一个名为<code class="fe nf ng nh mw b">add_book.go</code>的文件，并添加以下代码:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="2f6b" class="na lz iu mw b be nb nc l nd ne">package api<br/><br/>import (<br/> "log"<br/> "net/http"<br/><br/> "aevitas.dev/go-books/pkg"<br/> "github.com/gin-gonic/gin"<br/> "github.com/oklog/ulid"<br/>)<br/><br/>func (s *Server) HandleAddBook(ctx *gin.Context) {<br/> var book pkg.Book<br/><br/> err := ctx.BindJSON(&amp;book)<br/><br/> if err != nil {<br/>  ctx.AbortWithError(http.StatusBadRequest, err)<br/>  return<br/> }<br/><br/> book.Id = ulid.Now()<br/><br/> r := s.DB.Create(&amp;book)<br/><br/> if r.Error != nil {<br/>  log.Fatal(r.Error)<br/> }<br/><br/> s.DB.Save(&amp;book)<br/><br/> ctx.JSON(http.StatusOK, &amp;book)<br/>}</span></pre><p id="6a17" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">确保抓住<code class="fe nf ng nh mw b">ulid</code>包，然后运行<code class="fe nf ng nh mw b">go mod tidy</code>。</p><p id="b5eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nf ng nh mw b">ctx</code>参数包含Gin上下文，或者更确切地说是HTTP上下文。这个上下文包含我们从用户那里收到的请求，以及我们将为他们提供的最终响应。</p><p id="bb07" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首要任务是定义我们之前定义的模型的一个<code class="fe nf ng nh mw b">book</code>变量— <code class="fe nf ng nh mw b">pkg.Book</code>接下来，我们将尝试将请求内容反序列化到这个变量上。如果一切顺利，我们将得到一本有标题、ISBN、作者，只要你说得出名字的有效的书。</p><p id="20fc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果没有，我们将通过调用<code class="fe nf ng nh mw b">ctx.AbortWithError</code>来缩短请求，并指定一个错误的请求，以及我们从序列化程序收到的错误。</p><p id="45f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，虽然这确实缩短了响应管道，但代码仍将继续执行——因此出现了<code class="fe nf ng nh mw b">return</code></p><p id="695f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为这个处理程序被声明为<code class="fe nf ng nh mw b">Server</code>的一个方法，所以我们可以访问<code class="fe nf ng nh mw b">s.DB</code>指针来访问数据库。我们将创建并保存这本书，如果一切顺利，将这本书作为JSON对象返回给调用者。</p><p id="1472" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然我们可以创造书籍，我们也应该能够检索它们。添加一个包含以下(非常相似)代码的<code class="fe nf ng nh mw b">get_book.go</code>处理程序:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="2ff1" class="na lz iu mw b be nb nc l nd ne">package api<br/><br/>import (<br/> "net/http"<br/><br/> "aevitas.dev/go-books/pkg"<br/> "github.com/gin-gonic/gin"<br/>)<br/><br/>func (s *Server) HandleGetByISBN(ctx *gin.Context) {<br/> var book pkg.Book<br/><br/> isbn := ctx.Param("isbn")<br/><br/> ret := s.DB.First(&amp;book, "isbn = ?", isbn)<br/><br/> if ret.RowsAffected == 0 {<br/>  ctx.AbortWithStatus(http.StatusNotFound)<br/>  return<br/> }<br/><br/> if ret.Error != nil {<br/>  ctx.AbortWithError(http.StatusBadRequest, ret.Error)<br/>  return<br/> }<br/><br/> ctx.JSON(http.StatusOK, book)<br/>}</span></pre><p id="7033" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如您所看到的，两者之间的主要区别在于，后者从请求参数中获取ISBN(因为请求将是GET而不是POST，因此没有人)并执行简单的DB查询。</p><p id="5d6e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在所缺少的(除了测试！)是<code class="fe nf ng nh mw b">RegisterRoutes</code>功能。</p><h1 id="12e9" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">路线</h1><p id="9d3f" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj ms ll lm ln mt lp lq lr mu lt lu lv in bi translated">Go附带了一个非常可靠的HTTP服务器，包含在<code class="fe nf ng nh mw b">http</code>包中。我们将使用它来服务我们的API，同时使用Gin来处理路由。杜松子酒比我在这篇文章中展示的要强大得多。</p><p id="3855" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe nf ng nh mw b">api</code>包中，创建一个名为<code class="fe nf ng nh mw b">routes.go</code>的文件，并添加以下代码:</p><pre class="kk kl km kn gu mv mw mx bn my mz bi"><span id="9003" class="na lz iu mw b be nb nc l nd ne">package api<br/><br/>func (s *Server) RegisterRoutes() {<br/> s.Gin.GET("/books/:isbn", s.HandleGetByISBN)<br/> s.Gin.POST("/books", s.HandleAddBook)<br/>}</span></pre><p id="1fe2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与单独的处理程序类似，我们将这些函数声明为<code class="fe nf ng nh mw b">Server</code>的方法——即使它们在不同的文件中。这只对同一个包中的文件是可能的，这也是我更喜欢的将功能捆绑在一起的方式。</p><p id="272f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">比方说，你也可以用详细的作者信息来扩展这个API，你可以把我们上面写的处理程序移到一个<code class="fe nf ng nh mw b">books</code>包中，暴露它自己的<code class="fe nf ng nh mw b">RegisterBookRoutes</code>函数或类似的东西，对<code class="fe nf ng nh mw b">authors</code>做同样的事情——这样你就可以把你的API整齐地打包到功能的<a class="ae kz" href="https://jimmybogard.com/vertical-slice-architecture/" rel="noopener ugc nofollow" target="_blank">垂直片</a>中。</p><h1 id="314c" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">跑步</h1><p id="9308" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj ms ll lm ln mt lp lq lr mu lt lu lv in bi translated">仅此而已！现在只需添加一个<code class="fe nf ng nh mw b">.env</code>文件，并用类似下面的代码定义<code class="fe nf ng nh mw b">DB_DSN</code>:</p><p id="395b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nf ng nh mw b">host=localhost user=foo password=bar dbname=books</code></p><p id="96a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你就准备好了。通过运行<code class="fe nf ng nh mw b">go run .</code>来运行您的应用程序，您应该能够在端口8050 上使用<a class="ae kz" href="http://localhost:8050" rel="noopener ugc nofollow" target="_blank">本地主机上的API。</a></p><h1 id="ea05" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">结论</h1><p id="f74a" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj ms ll lm ln mt lp lq lr mu lt lu lv in bi translated">我们已经在Go中构建了一个非常简单的API来访问数据库以存储和检索书籍，并且已经将一些基本结构应用到我们的项目中，以便在将来对其进行扩展。</p><p id="7f84" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">据我所知，不存在像其他语言那样的“最佳实践”或标准的单一结构。这在很大程度上取决于你个人的需求和偏好，最终取决于你能做出什么样的工作。也许这就是为什么我认为这种语言是一股新鲜空气。</p><p id="6b97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本文附带的最终代码可以在<a class="ae kz" href="https://github.com/aevitas/go-books-api" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="22c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读，希望本指南对您有用！</p></div></div>    
</body>
</html>