# 当在软件的边缘保持特定的实现时，处理 PHP OOP 限制的见解

> 原文：<https://betterprogramming.pub/insights-for-dealing-with-php-oop-limitations-when-keeping-specific-implementations-at-the-edges-of-22321bfcd3ac>

## 帮助您的代码更进一步的简短指南

![](img/8262adfa96f77073403871c6da8fb555.png)

本·格里菲斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

将特定的实现放在软件的边缘是软件开发中众所周知的最佳实践，它通常可以作为构建强大的面向对象结构和易于维护的代码的启发。

一般的想法是指让类知道彼此的接口(例如，可以在每个接口上调用哪些操作)，而不知道它们的具体实现或“数据类型”例如，对象属于哪个特定的类或子类)。

通常，这种设计实践是通过根据接口定义软件依赖关系来实现的，因此留下一些依赖注入机制来确定在整个执行线程中应该使用哪些特定的实现。

在进入核心组件之前，特定的实现通常在执行线程的开始，在软件的第一层被定义。我们将这些地方称为“软件的边缘”，它们符合每次执行的实际入口点。

在做了一个无聊的理论 OOP 介绍后，在我作为 PHP 开发人员的几年工作经历中，我多次面对一个特定的有问题的模式。在这里，我描述了它，并提供了一些见解，帮助我在不同的场景中处理它，同时试图坚持上面的设计实践。

# 问题是

有问题的模式可以描述为有一个类利用了另一个类提供的结果。结果是根据通用接口定义的，因此我们可能知道可以在实例上调用的一些操作。但是，结果中也有一些特定的操作和数据片段，是结果消费者想要使用的。

根据每个结果的类型，消费者应该能够通过实现不同的结果处理算法来处理不同的可能结果实例。我们如何在不将实现细节分散到所有代码中的情况下实现这一点呢？

我知道理解起来有点乏味，所以让我们用一个使用命令设计模式设置的具体例子来解决这个问题:

尽管文件数量很多，但这种设置很容易理解:有一个`Command`接口，它返回一个`CommandResult`实例作为执行特定命令的结果。我们有一个`ExecutionContext`类，它定义了特定上下文的一般结构。

上下文将负责处理(执行和处理其结果)每个命令。我们可以看到每个特定的命令结果子类持有不同的操作，但是`ExecutionContex` t 类只知道`CommandResult`接口。我们如何相应地处理每个命令结果类型？

这在很多场合都是我的克星。PHP 中缺少多态类型提示和泛型，这使得在这些场景下工作很困难；不像 Java，对于这种情况有很好的本地解决方案。无论如何，我可以找出三种有用的方法，让我在过去成功地解决了这个问题:

*   将泛型结果强制转换为预期的类型
*   使用`Visitor`模式
*   重组组件设计

# 将泛型结果转换为预期的类型

老实说，这是我最不喜欢的解决方案。因为我们确实知道在一个`CommandResult`实例后面会有一个特定的类实例，我们可以尝试为每个特定的实例提供不同的实现，如下所示:

`processResult`实现询问结果的具体类型，以便对其进行相应的处理。由于每个私有的`processCommandResultX`方法都期望接收一个在其签名上定义的`CommandResultX`实例，我们的 IDE 可以帮助我们在这些方法中自动完成和类型提示。

`processResult`方法可以直接在基类`ExecutionContext`中定义，将每个“`processCommandResultX`”方法的定义留给每个子类。

此外，基类可以为每个特定方法提供默认实现，以及在没有`instanceof`语句捕获到特定命令结果的情况下执行的默认实现(尽管在这种情况下，我们可能希望抛出一个错误，警告我们忘记处理它)。

一个更强大、更灵活的版本将利用*责任链*模式将每个特定的处理定义为一个链条钢。这样，一个钢可以只处理`*CommandResultA*`实例，将所有其他结果类型留给后面的钢，依此类推。

我们可以在链的开始或结尾使用 steels 对所有类型的结果进行额外的处理，例如，为每个结果启用数据记录，而不管它是哪种类型。

尽管有许多`instanceof`检查和处理方法可能有点棘手和冗长，但是第一种方法将特定的实现代码保持在软件的边缘，只要我们将执行上下文类视为边缘的一部分。因此，添加新的命令结果类型需要:

*   在`*ExecutionContext*`层次中添加一个新的特定处理方法，并在子类中实现它
*   在`*processResult*` 方法中增加了新的`instanceof`检查
*   当使用一个责任链时，增加一个新的链钢和可能修改一些现有的

# 使用访问者设计模式

通过`Visitor`设计模式，我们可以得到一个更优雅的组件设置，如下所示:

这里，我们让每个特定的结果控制它应该如何被处理:每个`ExecutionContext`都有一个特定处理方法的集合。具体结果要通过实现`processOnContext`方法来选择合适的。

优雅是因为不必使用`instanceof`语句检查每个结果的类类型。然而，这种方法与前一种方法并没有太大的不同。添加新命令和新命令结果类型将需要:

*   在`*ExecutionContext*`基类中添加一个新的`processCommandResultX`方法，并在每个具体的上下文子类中实现它。

# 重构设计

如果我们再次打开理论模式，我们可能会认为这个问题仅仅是一个设计问题，因此，由于一些错误的概念和假设，当前的设置不能很好地工作。

首先，`ExecutionContext`被设计用来处理`CommandResult`实例。但是我们正在尝试处理`CommandResultA`和`CommandResultB`实例。因此，我们在同一个类中混合了两个不同层次的抽象。在代码的任何一点上，我们都应该在低层次或者高层次的抽象上工作，但是不能同时使用这两种抽象。

其次，`CommandResultA`定义了一个名为`getString`的全新方法，它不是在父类级别定义的。`CommandResultB`也是如此。此外，这两种命令结果类型不能互换。

我们违反了 Likskow 的替代原理，这来自于假设`CommandResultA`和`CommandResultB`是某种`CommandResult`，这反过来是不正确的，因为它们没有任何共同点。既不共享相同的数据字段，也不进行相同的操作。

注意这些设计错误可能会给重构和重新设计当前解决方案带来很好的见解。但是，因为我假设两个命令可以返回不同的数据字段作为结果，所以我肯定希望对它们进行不同的处理。命令结果类型随着处理算法的不同而不同。因此，我们可以尝试将它们都放在软件的最边缘，如下所示:

我添加了一组`ProcessingStrategy`类，它们定义了应该如何处理每种特定的结果类型。`ExecutionContext` 现在是一个核心组件，必须在向它发送命令之前将其设置为处理策略。我们使用这种方法在系统边缘保持结果类型处理，因为它们只在`index.php`文件中定义。

这种方法假设每个命令结果类型有一个特定的处理策略，尽管 `processResult`方法期望一个`CommandResult`实例而不是特定的结果类型(比如`CommandResultA`)。

因此，我显式检查传入结果的类型是否是我期望接收的类型。我使用两种方法:`ProcessingStrategyA`将结果转换为`CommandResultA`，而`ProcessingStrategyB`显式检查给定结果的类型，并依赖 PHPDoc 进行自动完成和类型提示。

注意，也可以提供处理这两种结果的处理策略。因此，这是一种比其他方法更灵活的方法。还要注意，如果我们将一个意外的命令结果类型传递给执行上下文，它将抛出一个错误。一个更安全的替代方案将包括一些错误处理和默认行为机制。

这种方法的一种类型宽松的变体是，`ExecutionContext`类使用一个`processingStrategy`而没有显式定义它的预期类型，您可以在下面看到:

这个版本允许`ExecutionContext`使用任何具有`processResult`方法的东西作为有效的处理策略。通过放宽类型要求，我们可以删除`ProcessingStrategy`的继承，从而明确地说一个`ProcessingStrategyA` 实例将只能处理`CommandResultA` 实例，而不能处理`CommandResult` 实例。这里的主要好处是我们摆脱了`instanceof`检查和类型转换，处理策略如何处理结果的限制变得显而易见。

使用这种布局添加新的命令结果类型需要:

*   添加一个新的处理策略，可以处理新的结果类型，尽管可以重用现有的处理策略。

我希望这篇文章是有帮助的。感谢您的阅读，敬请期待更多内容！