<html>
<head>
<title>Continuous Delivery for Kubernetes With GitOps and Argo CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过GitOps和Argo CD为Kubernetes提供持续交付</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/continuous-delivery-for-kubernetes-with-gitops-and-argocd-589bea494f44?source=collection_archive---------13-----------------------#2020-03-06">https://betterprogramming.pub/continuous-delivery-for-kubernetes-with-gitops-and-argocd-589bea494f44?source=collection_archive---------13-----------------------#2020-03-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6590" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">以声明的方式部署和更新您的应用程序，如果事情没有按计划进行，可以选择回滚</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/7115ed35311b164b122ca9e0e45dee13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*goU7Gu0AYkKKv2ja"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">杰西·拉米雷斯在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9520" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Kubernetes作为在生产中运行大型容器化工作负载的事实上的标准，正在迅速获得关注。Kubernetes采用了一种不同于我们习惯的方法来创建和维护应用程序组件。例如，Kubernetes没有手动配置我们的服务器来处理网络和存储，而是在它的<a class="ae kz" href="https://kubernetes.io/docs/concepts/" rel="noopener ugc nofollow" target="_blank">概念</a>中抽象它们。</p><p id="40eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，如果我们想在互联网上公开一个应用程序，我们可以通过创建一个服务来实现。然后，该服务可以连接到一个云负载平衡器，它会将外部流量导向我们集群中的一个单元。</p><p id="17c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所有这些组件都被定义为名为<em class="lw">清单</em>的YAML文件。对于单个应用程序部署，您通常会得到一些清单文件，这些文件描述了您的应用程序应该如何在Kubernetes集群中运行。</p><p id="5a22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您运行一个只有少量部署的小型集群时，这并不是什么大问题。但是，随着集群的增长，描述其部署的清单数量可能会增长到无法控制的程度。我们需要一种好的方法来管理所有这些清单及其历史。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="2055" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">声明性GitOps</h1><p id="4d92" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">这就是我们部署模型的第一个组件出现的地方。我们正在寻找一种模型，在这种模型中，我们可以管理清单并维护它们的历史，这样我们就可以创建一个自然的审计日志。我们可以从Git中得到所有这些，额外的好处是大多数开发人员已经熟悉了它作为他们源代码的版本控制系统。</p><p id="8bd5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">GitOps是Kubernetes应用程序管理和交付的一种方式。所有清单都存储在一个Git存储库中，该存储库被视为集群状态的唯一来源。如果更新了应用程序的组件，或者创建了一个新的组件，开发人员只需提交一个包含所需清单的pull请求，获得审查，一旦合并，它就可以在几分钟内自动部署到集群。</p><p id="611e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用GitOps模型的好处之一是我们可以有效地在Git版本之间来回滚动。因为每一个版本本质上都代表了集群在那个时间点的状态，如果情况变得糟糕，简单地恢复到旧的提交就成为了一个可行的选择。众所周知，他们迟早都会这么做。</p><p id="5d57" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这种交付模式对于开发人员来说尤其适用，因为运行他们代码的基础设施就在存储库中。每一次部署、服务、数量等。就在那里。最重要的是，处理部署的实际系统是不可知的。你可以自由选择任何你喜欢的系统，从<code class="fe nb nc nd ne b">kubectl</code>到更高级的<a class="ae kz" href="https://argoproj.github.io/argo-cd/" rel="noopener ugc nofollow" target="_blank"> Argo CD </a>我们将在下一节中讨论。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="5009" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">使用Argo CD的连续传送</h1><p id="5cd5" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Argo CD是Argo项目的一部分，该项目由Intuit发起，包含各种项目，使每个人都可以更容易地在Kubernetes上交付、运输和维护云原生应用程序。</p><p id="816b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在前一节中，我们描述了如何使用Git来定义我们的工作负载和应用程序。在本节中，我们将介绍如何使用Argo CD来获取这些定义并将其部署到Kubernetes。</p><p id="88ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们从Argo CD的基本架构开始:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nf"><img src="../Images/3fd6ec9d9abf84cd96910e151064abbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sV0IsRkohIqHwvLU.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://argoproj.github.io/argo-cd/" rel="noopener ugc nofollow" target="_blank"> Argo光盘架构</a></p></figure><p id="eb59" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从开发人员的角度来看，每当他们想要部署或更新Kubernetes工作负载时，他们首先提交一个包含所有必要的基础设施变更的pull请求。这可以是简单的映像版本升级，也可以是全新应用程序及其所有必需组件的部署。</p><p id="3d01" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Argo CD作为Kubernetes控制器存在，并持续监视集群上运行的应用程序。它将它们与Git存储库中定义的状态进行比较。如果它检测到一个偏差，它会将一个应用程序标记为<code class="fe nb nc nd ne b">OutOfSync</code>——表明集群当前没有反映存储库的<code class="fe nb nc nd ne b">master</code>分支。</p><h2 id="da84" class="ng mf iu bd mg nh ni dn mk nj nk dp mo lj nl nm mq ln nn no ms lr np nq mu nr bi translated">同步</h2><p id="5d8a" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">同步是部署应用程序的主要机制。每当应用程序通过Argo CD的web界面或命令行进行同步时，Git存储库中最新版本的清单将被部署到集群，并且部署将被标记为<code class="fe nb nc nd ne b">Synced</code>:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ns"><img src="../Images/fc3ee9920e1512e900ddea22111d4bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*8wYnqpOV4e_XGicDhzOY2w.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Argo光盘中的同步应用程序</p></figure><p id="c90c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它还集成了Kubernetes的健康检查，并方便地显示应用程序所有组件的健康状况。</p><p id="c0fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您更深入地研究应用程序时，您可以看到该应用程序所有单个组件的运行状况和状态。这包括所有对象，如服务、窗格和入口。它们方便地显示在树状视图中:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/24fcb6fa45775ea18041960c0aaf2781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnqgzqGkb7T7yRskuuzu4w.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Argo光盘的应用现状及综述</p></figure><p id="eb51" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每个部署都包括其各自的Git树、提交和作者。</p><h2 id="de38" class="ng mf iu bd mg nh ni dn mk nj nk dp mo lj nl nm mq ln nn no ms lr np nq mu nr bi translated">历史和回滚</h2><p id="fa46" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在部署导致意外副作用的情况下，使用Argo CD内置的历史和回滚功能回滚到以前的版本是很简单的:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/fa66471d46384d059b9c8db2453f9e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eMKgHsXQiXA4uOFPrGdGPQ.png"/></div></div></figure><p id="ad65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这不仅大大提高了应用程序的稳定性，也提高了开发人员的工作效率。如果有任何错误设法通过测试，将整个部署回滚到以前的版本是微不足道的，任何人都可以完成，不仅仅是开发人员。这使得开发人员可以更快地完成工作，因为他们知道有一个安全网可以利用，如果他们需要的话。</p><p id="424b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然这个部署模型中的繁重工作主要是由Git完成的，但是Argo CD提供了一些非常强大的工具，可以使用Git存储库作为可部署工件的来源。</p><p id="2670" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这消除了在给定时间点集群上实际运行的模糊性。由于Argo CD中的每个操作都是可追踪的，并且每个操作都可以追溯到Git提交，所以要弄清楚特定时间点上给定应用程序运行的是什么版本是相对简单的。</p><p id="34cf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以上只是对Argo CD能做什么的简单介绍。一旦你深入到它对Helm charts和Kubernetes的其他包管理器的支持，可能性是巨大的。如果你感兴趣，我在结论中链接了一些资源。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="04bb" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">结论</h1><p id="d14c" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在本文中，我们介绍了使用GitOps和Argo CD作为一种可靠地将应用程序部署到Kubernetes的方法，并探讨了这种方法所提供的各种特性和好处。就个人而言，我认为GitOps为Kubernetes集群管理问题提供了一个非常强大的解决方案，它显式、可靠且易于审计。</p><p id="2900" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然我们只探索了使用简单的Kubernetes清单来定义应用程序，但Argo CD支持许多其他方式来定义您的应用程序，包括:</p><ul class=""><li id="541d" class="nv nw iu lc b ld le lg lh lj nx ln ny lr nz lv oa ob oc od bi translated"><a class="ae kz" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank"> Kustomize </a>应用程序</li><li id="f277" class="nv nw iu lc b ld oe lg of lj og ln oh lr oi lv oa ob oc od bi translated"><a class="ae kz" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">舵图表</a></li><li id="cdb0" class="nv nw iu lc b ld oe lg of lj og ln oh lr oi lv oa ob oc od bi translated"><a class="ae kz" href="https://ksonnet.io/" rel="noopener ugc nofollow" target="_blank"> Ksonnet </a>应用</li><li id="c381" class="nv nw iu lc b ld oe lg of lj og ln oh lr oi lv oa ob oc od bi translated">Jsonnet 应用程序</li></ul><p id="8732" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您认为Argo CD可能适合您，请务必<a class="ae kz" href="https://argoproj.github.io/argo-cd/" rel="noopener ugc nofollow" target="_blank">查看文档页面</a>了解如何将其部署到您的集群的说明。它很容易上手，并且只需要最少的资源。</p><p id="a554" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>