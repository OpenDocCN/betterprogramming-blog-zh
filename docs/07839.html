<html>
<head>
<title>Automating Unit Tests With Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest自动化单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automating-unit-tests-with-jest-b6ba7be8675b?source=collection_archive---------13-----------------------#2021-02-24">https://betterprogramming.pub/automating-unit-tests-with-jest-b6ba7be8675b?source=collection_archive---------13-----------------------#2021-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f11a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Jest单元测试自动化完全初学者指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7836d4877ba28226d13aebf2f658c471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E7aY6K-un6AeJH2S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="5edd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动化测试是对程序自动执行测试的过程。为此，我们需要编写测试脚本，按照测试用例执行测试过程。自动化测试用例的一些好处是:</p><ul class=""><li id="07f6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用更少的时间测试更多的代码</li><li id="76c7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在部署应用程序之前捕获bug</li><li id="4b74" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">放心部署</li><li id="c14a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">毫不费力地重构</li><li id="7dc0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">关注代码质量</li></ul><p id="0713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有没有漏洞的软件。测试的主要目的是让代码失败，并找出至少一个bug。</p><p id="e3d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试用于测试应用程序的单个功能组件，不需要或只需要很少的外部依赖。单元测试编写起来更便宜，执行起来更快。然而，就应用程序的可靠性而言，他们不太确定。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="00d6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">玩笑</h1><p id="8530" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Jest是最新的测试框架，是使用Babel、TypeScript、Node、React、Angular、Vue等测试项目的热门选择。Jest是一个成熟的框架，它提供了一个库和一个测试运行器。</p><ul class=""><li id="2663" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">库:</strong>提供了一组实用函数来编写测试</li><li id="3710" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">测试运行器:</strong>在命令行上执行测试，指出已经通过或者失败的测试</li></ul><p id="dc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jest被像脸书这样的公司用来测试他们在React等JavaScript库上运行的应用程序。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ee60" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设置笑话</h1><h2 id="633b" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">项目文件夹设置</h2><p id="5db0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">创建项目文件夹。出于演示的目的，我将我的项目文件夹命名为<code class="fe nz oa ob oc b">JestUnitTesting.</code>我将使用Visual Studio代码，但是您可以在任何您喜欢的代码编辑器中打开这个项目。进入终端窗口，编写以下命令创建一个<a class="ae ky" href="https://docs.npmjs.com/creating-a-package-json-file#default-values-extracted-from-the-current-directory" rel="noopener ugc nofollow" target="_blank">默认</a>T1】文件:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="ab96" class="nn mr it oc b gy oh oi l oj ok">npm init --yes</span></pre><p id="a968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件的内容如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/3a72de2ededfa6b8fda4387eb6f8d3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sblfgxWVbpNWH2dHTzu0lQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure><h2 id="14e8" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">安装Jest</h2><p id="7bc9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在终端中，运行以下行来安装Jest:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="e73e" class="nn mr it oc b gy oh oi l oj ok">npm i jest --save-dev</span></pre><p id="e201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe nz oa ob oc b">--save-dev</code>标志，我们能够将Jest安装并保存为开发依赖项。我们这样做是因为我们希望在开发环境中执行测试，并且在部署应用程序时，我们不希望将Jest部署到生产环境中而不使其成为生产捆绑包的一部分。</p><p id="2c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过查看<code class="fe nz oa ob oc b">package.json</code>文件来确认<code class="fe nz oa ob oc b">devDependencies</code>下的安装，如下图所示:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="6df1" class="nn mr it oc b gy oh oi l oj ok">"devDependencies": {<br/>    "jest": "^22.2.2"<br/>},</span></pre><h2 id="9fe9" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">配置Jest</h2><p id="42a3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了运行测试，在<code class="fe nz oa ob oc b">package.json</code>文件中，我们需要配置<code class="fe nz oa ob oc b">“scripts”</code>属性，如下所示:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="816d" class="nn mr it oc b gy oh oi l oj ok">"scripts": {<br/>    "tests": "jest --watchAll"<br/>}.</span></pre><p id="c673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性<code class="fe nz oa ob oc b">scripts</code>包含可以在命令行上执行的命令。例如，为了用Jest执行测试，我们运行<code class="fe nz oa ob oc b">npm test</code>。</p><p id="2b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标志确保Jest在运行测试脚本后不会终止。相反，它一直在观察变化。因此，产品代码或测试脚本中的任何更改都会被更改。然后Jest重新运行这些测试，这些变化会被通知，并且可以在终端上看到。</p><h2 id="88bc" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">创建测试文件夹</h2><p id="2b7c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">测试是项目生命周期中一个独立但连续的阶段。因此，测试独立于项目的其他代码行是一个最佳实践。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="b14c" class="nn mr it oc b gy oh oi l oj ok">project-folder<br/>|<br/>|- tests<br/>    |- unit<br/>    |- integration</span></pre><p id="78cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob oc b">project</code>目录下创建一个名为<code class="fe nz oa ob oc b">tests</code>的文件夹。这是所有测试文件将被保存和执行的地方。</p><p id="9849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将单元测试和集成测试分开也是一个很好的实践——在接下来的路中，您可能想要单独执行单元测试或集成测试。因此，在<code class="fe nz oa ob oc b">tests</code>目录中创建一个名为<code class="fe nz oa ob oc b">unit</code>的子目录。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5bcb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">让自己熟悉笑话</h1><p id="be16" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们创建我们的第一个单元测试文件。在<code class="fe nz oa ob oc b">unit</code> <strong class="lb iu"> </strong>子目录下的<code class="fe nz oa ob oc b">tests</code>文件夹中，创建一个如下格式的文件:</p><p id="6990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">module.test.js</code></p><p id="1db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述格式用于在特定模块上执行单元测试。如上图所示:</p><ul class=""><li id="1354" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">module</code>是您要测试的模块或套件的名称</li><li id="1cf7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">test</code>可以命名为<code class="fe nz oa ob oc b">test</code>或<code class="fe nz oa ob oc b">spec</code>，表示是测试文件</li><li id="c51e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">js</code>是JavaScript文件的扩展名，因此它可以被读取</li></ul><h2 id="43ce" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">理解测试语法</h2><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="13eb" class="nn mr it oc b gy oh oi l oj ok">// Familiarizing with the Jest syntax</span><span id="f522" class="nn mr it oc b gy om oi l oj ok">test('Sample test', () =&gt; {} );</span></pre><p id="767d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了编写一个测试，我们调用<code class="fe nz oa ob oc b">test()</code>函数，它有两个参数:</p><ul class=""><li id="2cce" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">测试的名称—在控制台上看到</li><li id="e156" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个函数——我们实现测试的地方。Jest将在我们运行测试时调用这个函数。</li></ul><p id="8c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行<code class="fe nz oa ob oc b">npm test</code>命令时，我们将收到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/0bc933d49c3694be3ba67cc4ed52a631.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*1j1HjZd6qzD8NANX-5xMGg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure><h2 id="e656" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">分组测试</h2><p id="1bb1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">测试时我们必须测试函数中的每一条路径。假设一个测试有三条路径(如下面的程序所示)。在这种情况下，我们必须为每一个都编写一个测试用例。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="9f97" class="nn mr it oc b gy oh oi l oj ok">function absolute(number){<br/>    if (number &gt; 0) return number;           // path 1<br/>    if (number &lt; 0) return -number;          // path 2<br/>    return 0;                                // path 3<br/>}</span></pre><p id="f3dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用<code class="fe nz oa ob oc b">test()</code>函数编写测试脚本，它们看起来会像:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="afdf" class="nn mr it oc b gy oh oi l oj ok">test('absolute - should result path 1', () =&gt; {} );<br/>test('absolute - should result path 2', () =&gt; {} );<br/>test('absolute - should result path 3', () =&gt; {} );</span></pre><p id="be61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得测试脚本拥挤不堪，难以阅读，如下所示。因此，我们遵循最佳实践并使用以下技术:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="06b1" class="nn mr it oc b gy oh oi l oj ok">describe('absolute', () =&gt; {<br/>    it ('should result path 1', ()=&gt; {});<br/>    it ('should result path 2', ()=&gt; {});<br/>    it ('should result path 3', ()=&gt; {})<br/>});</span></pre><p id="697c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">describe()</code>函数将相关的测试组合在一起，如上所示。它由两个参数组成:</p><ul class=""><li id="5946" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">测试组的名称</li><li id="0803" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对覆盖模块每条路径的所有函数进行分组的函数，确保正确的路径覆盖。</li></ul><p id="8b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">it()</code>负责覆盖被测模块的每个路径。它还包含两个参数:</p><ul class=""><li id="1ffc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">测试路径的名称</li><li id="8295" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">测试给定测试路径的函数</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="592e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">写作测试</h1><h2 id="42a8" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">测试数字</h2><p id="17b1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在项目文件夹中，创建一个名为<code class="fe nz oa ob oc b">data.js</code>的文件，并插入以下代码行。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="dabb" class="nn mr it oc b gy oh oi l oj ok">module.exports.absolute = function(number){<br/>    if (number &gt; 0) return number;<br/>    if (number &lt; 0) return -number;<br/>    return 0;<br/>}</span></pre><p id="41da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数返回传递给函数的任何数字的正值，如果<code class="fe nz oa ob oc b">0</code>作为参数传递，则返回<code class="fe nz oa ob oc b">0</code>。</p><p id="4a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob oc b">unit</code>子目录中创建一个名为<code class="fe nz oa ob oc b">data.test.js</code>的文件。在这里，我们将提取以下代码:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="6c2b" class="nn mr it oc b gy oh oi l oj ok">const data = require('../../data');</span><span id="eff4" class="nn mr it oc b gy om oi l oj ok">describe('absolute', () =&gt; {<br/>    it ('should return positive number if positive', ()=&gt; {<br/>        const result = data.absolute(1);<br/>        expect(result).toBe(1);<br/>    });<br/>    it ('should return positive number if negative', ()=&gt; {<br/>        const result = data.absolute(-1);<br/>        expect(result).toBe(1);<br/>    });<br/>    it ('should return zero number if zero', ()=&gt; {<br/>        const result = data.absolute(0);<br/>        expect(result).toBe(0);<br/>    });<br/>});</span></pre><p id="5bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要<code class="fe nz oa ob oc b">data.js</code>模块，并将它的内容保存在一个名为<code class="fe nz oa ob oc b">data</code>的常量中。在上面的<code class="fe nz oa ob oc b">describe()</code>函数中，我们测试了来自<code class="fe nz oa ob oc b">data.js</code>文件的<code class="fe nz oa ob oc b">absolute</code> <em class="oo"> </em>函数。让我们来分解一下:</p><ul class=""><li id="2aa8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">const result = data.absolute(1)</code> <br/>从数据模块调用绝对函数，测试参数<code class="fe nz oa ob oc b">1</code>通过。具有给定参数的绝对函数的结果存储在常量<code class="fe nz oa ob oc b">result</code>中。</li><li id="10ed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">expect(result).toBe(1)</code> <br/> Jest有一个包含<code class="fe nz oa ob oc b">result</code>参数的<code class="fe nz oa ob oc b">expect()</code>函数。<code class="fe nz oa ob oc b">toBe()</code>函数，正如它自己所说，将是预期的结果。</li></ul><p id="8c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/7bb1212a4fa82fe1e06969dd97ff76b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*GHJ_4sCNSmC6Pg2S-WTwIw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure><h2 id="c9df" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">测试字符串</h2><p id="7d17" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在<code class="fe nz oa ob oc b">data.js</code>文件中，我们创建以下模块:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="d276" class="nn mr it oc b gy oh oi l oj ok">module.exports.welcome = function(name){<br/>    return 'Hello' + name;<br/>}</span></pre><p id="e384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户名作为函数的参数传递时，该函数将显示一条欢迎消息。</p><p id="40c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob oc b">data.test.js</code>文件中，让我们编写以下代码来测试字符串:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="0ff8" class="nn mr it oc b gy oh oi l oj ok">describe('welcome', () =&gt; {<br/>    it('should return welcome message', () =&gt; {<br/>        const result = data.welcome('Adam');<br/>        // expect(result).toBe('Hello Adam');   // not recommended<br/>        expect(result).toMatch(/Adam/);      // using regex<br/>        expect(result).toContain('Adam');    // using contains<br/>    })<br/>})</span></pre><p id="f16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这里我们不推荐使用<code class="fe nz oa ob oc b">toBe()</code>功能。这是因为如果我们要对<code class="fe nz oa ob oc b">welcome</code>函数进行修改——比如<code class="fe nz oa ob oc b">return 'Hello there' + name;</code>——那么我们需要重写测试脚本，这可能会很麻烦。因此，在测试字符串时，测试不应该太具体。所以这里有两个选择:</p><ul class=""><li id="021f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用正则表达式<br/><code class="fe nz oa ob oc b">toMatch()</code>允许传递一个正则表达式。有了它，我们将只检查测试数据，<code class="fe nz oa ob oc b">Adam</code>，<em class="oo">，</em>是否在结果中。</li><li id="0da1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<code class="fe nz oa ob oc b">Contain</code> <br/>避免时间构造正则表达式，一个更快的替代方法是使用<code class="fe nz oa ob oc b">toContain()</code>函数，它接受一个字符串参数。我们可以通过测试数据本身。</li></ul><p id="3997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你采取的方法完全取决于你自己，但关键是在正确的场景中选择正确的方法。测试结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/1654f392be67709ca4bb99b593c84777.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*OITgNtQDWjFMyhVy-Wmehg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure><h2 id="6899" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">测试阵列</h2><p id="caa9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在<code class="fe nz oa ob oc b">data.js</code>文件中，创建以下模块:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="3855" class="nn mr it oc b gy oh oi l oj ok">module.exports.sizes = function() {<br/>    return ['S','M','L'];<br/>}</span></pre><p id="09ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数返回一个大小数组。在<code class="fe nz oa ob oc b">data.test.js</code>文件中，让我们测试一下数组:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="5f19" class="nn mr it oc b gy oh oi l oj ok">describe('sizes', () =&gt; {<br/>    it('should return available sizes', () =&gt; {<br/>      const result = ['S','M','L'];<br/>      expect(result).toEqual(expect.arrayContaining(['S','M','L']));<br/>    })<br/>})</span></pre><p id="8221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jest使用<code class="fe nz oa ob oc b">toEqual()</code>，这是检查结果是否与传递给它的参数相似的理想方式。<code class="fe nz oa ob oc b">arrayContaining()</code>以数组为参数。我们可以将值传递到这个数组中，这将根据结果中数组值的存在返回<code class="fe nz oa ob oc b">pass</code>或<code class="fe nz oa ob oc b">fail</code>。结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ad52846994aeeb5978592851234b9fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*VUwY7IqWKHhf1Mttza1fCA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure><h2 id="af7f" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">测试对象</h2><p id="bbc1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在<code class="fe nz oa ob oc b">data.js</code>文件中，创建以下模块:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="1d95" class="nn mr it oc b gy oh oi l oj ok">module.exports.getUser = function(userId) {<br/>    return {id: userId, age: 20 };<br/>}</span></pre><p id="b08f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当输入用户ID时，上面的函数返回一个对象。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="2eb8" class="nn mr it oc b gy oh oi l oj ok">describe('getUser', () =&gt; {<br/>    it('should return user of userId', () =&gt; {<br/>      const result = data.getUser(1)<br/>      // expect(result).toBe({id:1, age:20});           // test fail<br/>      expect(result).toMatchObject({id:1, age:20});  // pass test<br/>      expect(result).toHaveProperty('id', 1);        // pass test<br/>    })<br/>})<!-- -->toBe()<!-- --> will result in an error, as it compares the references of the object in memory with the object passed as the parameter. Therefore, we’re left with the following alternatives: </span></pre><ul class=""><li id="35a3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">匹配对象</strong> <br/> <code class="fe nz oa ob oc b">toMatchObject()</code>允许一个对象作为参数传递。我们可以传递对象的必要属性并验证它的存在。</li><li id="e5a0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">拥有属性</strong><br/><code class="fe nz oa ob oc b">toHaveProperty()</code>通过接受键值对参数在对象中寻找特定的属性。但是，它对数据类型的敏感性要求我们输入正确的数据类型。在这里，我们不必考虑其他属性，只需考虑我们正在寻找的属性。</li></ul><p id="3c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，您采取的方法完全取决于您，但关键是在正确的场景中选择正确的方法。测试结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/cfbebabe339aebb710f10960eaafd9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*J804gvTA_Q8ruDipfs9Cgg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure><h2 id="2265" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">测试异常</h2><p id="e065" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在<code class="fe nz oa ob oc b">data.js</code>文件中，创建以下模块:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="d52f" class="nn mr it oc b gy oh oi l oj ok">module.exports.registerUser = function(email) {<br/>    if (!email) throw new exception('Email required!');<br/>    return {id: 1, email: email};<br/>}</span></pre><p id="9fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">registerUser()</code>将邮件作为参数，如果邮件是<code class="fe nz oa ob oc b">false</code>则抛出异常。这就带来了两条需要测试的路径。因此，我们必须运行两个单元测试，如下所示:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="d916" class="nn mr it oc b gy oh oi l oj ok">describe('regsiterUser', () =&gt; {<br/>    it ('should throw error if email is falsy', ()=&gt; {<br/>        const args = [null, undefined, NaN, 0, '', false]; <br/>        args.forEach(a =&gt; {<br/>            expect(()=&gt;{data.registerUser(a)}).toThrow();<br/>        });<br/>    });<br/>    it ('should return user if valid email', ()=&gt; {<br/>        const result = data.registerUser('adam@email.com');<br/>        expect(result).toMatchObject({email: 'adam@email.com'});<br/>    });<br/>});</span></pre><p id="10f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的测试中，我们执行了两个单元测试——每个路径一个。至于<code class="fe nz oa ob oc b">regsiterUser</code>模块的逻辑，<code class="fe nz oa ob oc b">const args = [null, undefined, NaN, 0, ‘’, false];</code>包含了所有可能抛出异常的错误值。因此，我们采用了一种简洁的方法，遍历<code class="fe nz oa ob oc b">args</code>数组中的每一项。有些人可能不喜欢这种技术，但是为了简单起见，因为逻辑是相同的，所以我们使用了这种方法。测试结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/c30fd89276bb2cbc9d4ec3d1329501cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*KPEMKbWNObHWUl7NAE5PDQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="508c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">模拟功能</h1><p id="64dc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">到目前为止，我们已经测试了不依赖任何外部资源的独立功能。然而，在现实世界的应用程序中，我们可能必须对直接或间接与外部资源对话的函数执行单元测试。</p><h2 id="9241" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">创建简单的模拟函数</h2><p id="de54" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">以下功能为在服装店积分超过10分的忠诚顾客提供20%的折扣。在<code class="fe nz oa ob oc b">data.js</code>文件中，创建以下模块:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="f22e" class="nn mr it oc b gy oh oi l oj ok">const db = require('./fakeDb');</span><span id="a44d" class="nn mr it oc b gy om oi l oj ok">module.exports.discount = function(order){<br/>    const customer = db.getUser(order.userId);<br/>    if (customer.points &gt; 10) <br/>        order.totalAmount *= 20;<br/>}</span></pre><p id="13e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们试图从数据库中获取用户的详细信息。但是，既然建立测试数据库不在我们的讨论范围之内，我们就假装一下吧。</p><p id="ed34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob oc b">project</code>目录下创建一个与<code class="fe nz oa ob oc b">data.js</code>文件平行的<code class="fe nz oa ob oc b">fakeDb.js</code>文件。它将包含以下功能:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="9868" class="nn mr it oc b gy oh oi l oj ok">module.exports.getUser = function(userId){<br/>    console.log('Retreiving user from database...');<br/>    return {id: userId, points:11};<br/>}</span></pre><p id="c344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个场景中需要创建简单的模拟函数来执行单元测试，因为函数<code class="fe nz oa ob oc b">discount()</code>包含了接触外部资源的方法<code class="fe nz oa ob oc b">getUser()</code>(<code class="fe nz oa ob oc b">fakeDB.js</code>文件)。</p><p id="a1ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试必须独立于外部依赖。</p><p id="95d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试的主要目的是将代码从外部依赖中分离出来，因为在运行测试时它可能不可用。</p><p id="78a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设真正的数据库由于某种原因无法运行。单元测试将会失败。这将误导我们认为有一个错误，而实际上并没有。之所以会遇到这个问题，是因为我们依赖这些外部资源。</p><p id="77ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们需要用一个没有任何外部依赖的假/模拟实现替换真实实现，这意味着在<code class="fe nz oa ob oc b">data.test.js</code>文件中没有实际的数据库连接，如下所示:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="3731" class="nn mr it oc b gy oh oi l oj ok">const db = require('../../fakeDb');</span><span id="2df4" class="nn mr it oc b gy om oi l oj ok">describe('discount', () =&gt; {<br/>  it('should apply 20% discount if points greater than 10', () =&gt; {<br/>    db.getUser = function(userId) {<br/>      return {id: userId, points:11};<br/>    }</span><span id="0968" class="nn mr it oc b gy om oi l oj ok">    const order = {userId:1, total:80};<br/>    data.discount(order);<br/>    expect(order.total).toBe(80)  })<br/>})</span></pre><p id="ea13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的测试中，<code class="fe nz oa ob oc b">db</code>常量中需要<code class="fe nz oa ob oc b">fakeDb.js</code>。然后，<code class="fe nz oa ob oc b">db.getUser()</code>被替换为一个模拟函数，该函数返回一个用户对象，如<code class="fe nz oa ob oc b">getUser()</code>中的用户对象。</p><p id="c7ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们像前面在主题测试对象中所做的那样执行测试。测试结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/8afcfce9bb051b34574cf27bea7b7954.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*V78ZA0x9eEffJfJBYGIzBQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure><h2 id="5567" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">交互测试</h2><p id="16c8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在让我们测试一个对象与另一个对象的交互。</p><p id="dc0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将下面的代码复制到<code class="fe nz oa ob oc b">data.js</code>文件中。下面的函数在下订单时通知客户。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="187b" class="nn mr it oc b gy oh oi l oj ok">const db = require('./fakeDb');<br/>const notification = require('./notifications')</span><span id="c39f" class="nn mr it oc b gy om oi l oj ok">module.exports.notifyUser = function(order){<br/>   const customer = db.getUserEmail(order.userId);<br/>   notification.send(customer.email, 'Order placed.');<br/>}</span></pre><p id="56e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数有两个依赖项:</p><ul class=""><li id="2a6a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">fakeData.js</code></li></ul><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="861f" class="nn mr it oc b gy oh oi l oj ok">module.exports.getUserEmail = function(userId){<br/>    console.log('Retreiving user from database...');<br/>    return {email: 'a'};<br/>}</span></pre><ul class=""><li id="dc51" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">notificaitons.js</code></li></ul><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="fe5f" class="nn mr it oc b gy oh oi l oj ok">// Notification.js does not have any code to save us some time. We will mock this functionality using a mock function.</span></pre><p id="6712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对上述功能进行测试:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="3aab" class="nn mr it oc b gy oh oi l oj ok">const data = require('../../data');<br/>const db = require('../../fakeDb');<br/>const notification = require('../../notifications');</span><span id="4c53" class="nn mr it oc b gy om oi l oj ok">describe('notifyUser', () =&gt; {<br/>  it('should notify to customer', ()=&gt; {<br/>    db.getUserEmail = function(userId){<br/>      return {email: 'a'};<br/>    } <br/>    <br/>    let notified = false;<br/>    notification.send = function(email, message) { <br/>      notified= true;<br/>    }</span><span id="8676" class="nn mr it oc b gy om oi l oj ok">    data.notifyUser({userId:1}); <br/>    expect(notified).toBe(true);  <br/>  })<br/>})</span></pre><p id="9a8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/c3c5ebcffe1b85f118e10e9e1f5bd7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*mINkO-j9fEJdezSJDaGPhw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure><h2 id="ed39" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">Jest模拟函数</h2><p id="963a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">您可以使用Jest轻松创建模拟函数，并对它们进行编程，使它们以特定的方式运行。在每个测试中，我们可以有一个行为不同的模拟函数。这有助于简化上述模拟函数的实现。</p><p id="02a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我们使用以下代码行创建简单的模拟函数:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="3683" class="nn mr it oc b gy oh oi l oj ok">const mockFunction = jest.fn()</span></pre><p id="c003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">mock函数是一个空函数，可以简单地用<code class="fe nz oa ob oc b">mockFunction()</code>调用。通过使用mock函数，我们可以访问其他方法来完成以下任务:</p><ul class=""><li id="d618" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">返回值:</li></ul><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="ae74" class="nn mr it oc b gy oh oi l oj ok">mockFunction.mockReturnValue(1); //returns value 1<br/>const value = mockFunction(); </span></pre><ul class=""><li id="bc7b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">退回已解决的承诺:</li></ul><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="c43f" class="nn mr it oc b gy oh oi l oj ok">mockFunction.mockResolvedValue(1);  <br/>const value  = await mockFunction();//after awaiting promise return 1</span></pre><ul class=""><li id="afd1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">退回未兑现的承诺:</li></ul><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="1145" class="nn mr it oc b gy oh oi l oj ok">mockFunction.mockRejectedValue(new Error('Error...!'));  <br/>const value  = await mockFunction();</span></pre><p id="f26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用Jest mock函数执行发送通知测试。下面，我对之前的测试进行了评论，并为您更换了新的测试。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="ab62" class="nn mr it oc b gy oh oi l oj ok">const data = require('../../data');<br/>const db = require('../../fakeDb');<br/>const notification = require('../../notifications');</span><span id="8430" class="nn mr it oc b gy om oi l oj ok">describe('notifyUser', () =&gt; {<br/>  it('should notify to customer', ()=&gt; {<br/>    db.getUserEmail = jest.fn().mockReturnValue({email: 'a'});</span><span id="e588" class="nn mr it oc b gy om oi l oj ok">    // db.getUserEmail = function(userId){<br/>    //  return {email: 'a'};<br/>    //} </span><span id="5599" class="nn mr it oc b gy om oi l oj ok">    notification.send = jest.fn();</span><span id="3659" class="nn mr it oc b gy om oi l oj ok">    // let notified = false;<br/>    // notification.send = function(email, message) { <br/>    //   notified= true;<br/>    // }</span><span id="e2ed" class="nn mr it oc b gy om oi l oj ok">    data.notifyUser({userId:1}); </span><span id="a2b9" class="nn mr it oc b gy om oi l oj ok">    // expect(notified).toBe(true);  <br/>    expect(notification.send).toHaveBeenCalled();<br/>  })<br/>})</span></pre><p id="8c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Jest mock函数，我们可以简单地减少代码行数，提高代码质量，使其更具可读性和可写性。</p><p id="ef07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">toHaveBeenCalled()</code>是一个匹配器，检查<code class="fe nz oa ob oc b">mail.send</code>模拟函数是否被调用。当手动创建模拟函数时，正如我们之前所做的，这是不可能的。</p><p id="f039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，当您想要检查传递给该方法的参数时，这个函数的缺点就出现了。在这个场景中，我们使用<code class="fe nz oa ob oc b">toHaveBeenCalledWith('a', 'message')</code>。</p><p id="ed23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，正如我上面提到的，当测试字符串时，我们不应该是特定的。建议使用这种方法来测试数字、布尔值等。因此，测试参数的最佳方法是:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="0961" class="nn mr it oc b gy oh oi l oj ok">expect(notification.send).toHaveBeenCalled();<br/>expect(mail.send.mock.calls[0][0]).toBe('a');<br/>expect(mail.send.mock.calls[0][1]).toMatch(/Order/);</span></pre><p id="ffa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">mail.send</code>是模拟函数，它有一个属性<code class="fe nz oa ob oc b">mock</code>，这个属性又有一个属性<code class="fe nz oa ob oc b">calls</code>，它跟踪对这个函数的所有调用。测试结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/30436dd4740722a688b903ab5cd1952d.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*6ewOvhUNkEg92GSJNGqsYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片<a class="ae ky" href="https://umayir10.medium.com/" rel="noopener">作者</a></p></figure><p id="a84a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Jest mock函数简化了测试，因为它允许我们以一种简单方便的方式测试函数以及传入和传出函数的参数。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6cbb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">了解单位Tst的内容</h1><p id="a9b2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在真实的应用程序中，当测试路由处理器和认证中间件功能时，我们会遇到对数据库的HTTP请求和响应。在这样的场景中，我们需要模拟请求和响应。因此，我们必须编写的模拟函数的数量增加了。因此，这是我们必须执行集成测试的时候。</p><p id="22d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试时，用零依赖或最小依赖的算法测试函数，这样更容易模仿。如果有太多的嘲笑，那么你最好执行集成测试。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d26c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="9f99" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Jest 使得自动化单元测试变得更加简单、划算和令人兴奋，因为它处理了大量的麻烦。这确保了一个更强大、更自信、更可靠的自动化测试解决方案。</p><p id="3ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从我的<a class="ae ky" href="https://github.com/UmayirFeroze" rel="noopener ugc nofollow" target="_blank"> GitHub </a>档案中访问<a class="ae ky" href="https://github.com/UmayirFeroze/JestUnitTesting.git" rel="noopener ugc nofollow" target="_blank">完整代码</a>。</p><p id="693e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这个故事已经教会了你自动化测试的基础知识，以及如何使用Jest自动化单元测试。享受学习和编码的乐趣！</p></div></div>    
</body>
</html>