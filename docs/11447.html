<html>
<head>
<title>How to Use Multiple GNU/Linux at the Same Time — Bedrock Linux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何同时使用多个GNU/Linux—基岩Linux</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-multiple-gnu-linux-at-the-same-time-bedrock-linux-c172ff7e7b50?source=collection_archive---------9-----------------------#2022-03-21">https://betterprogramming.pub/how-to-use-multiple-gnu-linux-at-the-same-time-bedrock-linux-c172ff7e7b50?source=collection_archive---------9-----------------------#2022-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5cf8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基本Linux元发行版综述</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6a3e41392f55affcc89b3b9007918f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jc3nsebC8hixEJxB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@remyloz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Remy_Loz </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e0e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你好，在这篇文章中，我将谈论基岩Linux，这是一个守护进程，它允许使用来自多个软件包管理器的软件包，同时也在层中安装和使用多个发行版。</p><p id="a907" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然它被描述为一个独立的Linux发行版，但我们可以说它是一个守护进程，将安装到根目录的发行版连接到根目录，然后再分层安装。这是一个系统，允许使用多个不同的软件包以及一个非常有用的和可定制的架构。</p><p id="9a27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解这个架构，我先来说说Linux系统的层次结构。接下来，我将回顾基本的Linux层次结构，并简单解释如何安装和使用它。</p><h1 id="6d23" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Linux系统层次结构</h1><p id="3694" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Linux是一个具有类似Unix设计的操作系统内核。内核由Linus Torvalds设计，目前仍在开源开发中。最新的内核版本是Linux 5.14。并可通过链接获得。Linus Torvalds还拥有git项目、源代码管理和版本控制软件。这种单片内核于1991年命名，广泛用于超级计算机、个人或移动设备使用的操作系统。</p><p id="215a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，Android、Debian、RHEL(Red Hat Enterprise Linux)、CentOS都是GNU/Linux发行版的例子。尤其是Debian和基于Debian的发行版，RHEL和基于RHEL的发行版经常被用作服务器操作系统。Linux和Unix是整体内核。单片内核比微内核占据更大的面积。本质上，使用单片内核的操作系统在“内核模式”，即内核空间中运行所有的操作系统功能。</p><p id="636c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个进程都在独立的地址空间中。内核和操作系统服务在同一个地址空间。进程可以从内核请求服务。这在内核和应用程序之间创建了一个安全层。它还提供了高速度，因为没有消息流量。然而，对内核的更改需要重新编译，内核代码会变得非常复杂。</p><p id="4a9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用微内核的系统中，“内核模式”占用的空间更少。文件系统、虚拟内存管理器和CPU调度程序等系统服务位于内核的“用户模式”区域，每个服务都有自己的地址空间。应用程序也有自己的地址空间。这种核心是可定制的，并且易于扩展。</p><p id="4149" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在微内核中，由于系统架构，组件中的故障不会影响整个系统。在这方面，我们可以说这种架构是持久的。然而，如果单块系统出错，整个系统都会受到影响，因为服务是相互连接的。但在速度方面，它明显优于单片架构。微内核的例子有Symbian、Minix和GNU。大多数Linux发行版不是一个Linux项目，而是一个GNU项目。因为Linux只是一个内核，它只占整个系统的很小一部分。另一方面，混合体系结构结合了单片和微内核的优点，从而减少了缺点。它们在内核空间中保存更多的代码。通信单元和许多驱动程序都嵌入在内核区域。然而，当添加一个新组件时，它不需要像在单片架构中那样重新编译。比如达尔文和macOS内核XNU，基于BSD的FreeBSD，Windows NT都是在这个架构下编码的。现代操作系统更喜欢这种架构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/83bf103bf125cbde473fcde141903cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*4KxfFyRLfovzkNuF.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://en.wikipedia.org/wiki/Monolithic_kernel" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="4a63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图片来源:<a class="ae kv" href="https://en.wikipedia.org/wiki/Monolithic_kernel" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><h1 id="e6e3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">初始化系统</h1><p id="6bbb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">它是GNU/Linux系统上的祖先进程。它将1作为PID，在内核加载后，通过检查<code class="fe mq mr ms mt b">/etc/inittab</code>中的运行级别来决定系统将从哪个运行级别开始，例如我们习惯于从macOS使用的windows或安全模式。下图显示了运行级别。如Centos7系统中的<code class="fe mq mr ms mt b">inittab</code>文件所示，0暂停，1单用户模式，2多用户等。正在被使用。3，即完全多用户模式，默认使用为<code class="fe mq mr ms mt b">initdefault</code>。</p><p id="8032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">init启动后，其他进程依次启动，并在<code class="fe mq mr ms mt b">/etc/rc.d/init.d</code>下使用该模式。比如udev，apache，preload服务可以在init之后启动。这是像<code class="fe mq mr ms mt b">/etc/rc.d/init.d/init3.d/S100preload</code>一样的用法。<code class="fe mq mr ms mt b">init3.d</code>处于第三模式，S100表示预载将从第100个顺序开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/de69d2cdce2709e3d82408965f98c2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*gUWKjkNTD34om9TX.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">inittab-按作者排序的图像</p></figure><p id="4a8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在今天的GNU/Linux发行版中，这种结构并不是首选。其中大部分都默认自带了2010年写的<code class="fe mq mr ms mt b">systemd</code>。它还被用于runit、OpenRC、Upstart等新一代结构中。旧版本是SysV init系统。</p><p id="c47f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在新的结构中，有一些功能，如并行启动进程，自动启动进程需要的进程，如果进程终止，自动重新启动。<code class="fe mq mr ms mt b">systemd</code>是一个比其他系统稍慢的初始化系统。其中启动时间最快的系统是Runit，而且是跨平台的。在GNU/Linux、Solaris、macOS X上可用。</p><h1 id="e71d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">文件系统和目录层次结构</h1><p id="a57b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">文件系统是磁盘上的标记结构，允许操作系统找到文件。GNU/Linux发行版通常使用ext 2–3–4日志系统。它还可以在Windows文件系统NTFS上查找文件跟踪。一切都是一个文件，在目录中按层次顺序设计。文件、驱动程序、可执行文件和库都位于这些目录中。这个目录结构可以在下图中看到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e6c9bba60dfd75a94535ac97d140e95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*rdcPhdM7PKxkeq4-.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">树形文件系统-图片来自作者</p></figure><p id="6026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在正常使用中，我们可以说使用最多的目录是<code class="fe mq mr ms mt b">/var</code>、<code class="fe mq mr ms mt b">/lib</code>、<code class="fe mq mr ms mt b">/usr</code>、<code class="fe mq mr ms mt b">/home</code>。此外，目录将自己分支成树。例如，<code class="fe mq mr ms mt b">/usr</code>目录包含带有二进制文件的<code class="fe mq mr ms mt b">/usr/bin</code>目录。或者目录<code class="fe mq mr ms mt b">/var/lib</code>在<code class="fe mq mr ms mt b">/var</code>下。<code class="fe mq mr ms mt b">/bin</code>目录在引导时加载，包含基本命令。<code class="fe mq mr ms mt b">/sbin</code>包含提供系统信息或进行更改的二进制文件。</p><p id="b07b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">/lib</code>包含共享库，/media包含可移动磁盘，<code class="fe mq mr ms mt b">/mnt</code>包含新挂载的文件系统，<code class="fe mq mr ms mt b">/var</code>包含变量。<code class="fe mq mr ms mt b">/home</code>目录包含用户的私有文件。<code class="fe mq mr ms mt b">/etc</code>包含配置文件。<code class="fe mq mr ms mt b">/boot</code>目录包含了bootloader和一些与系统引导相关的核心文件，比如grub、lilo。这些目录可以分成不同的分区，并连接到系统。这是一种广泛使用的方法。例如，当主目录安装在与根目录不同的分区上时，当重新安装系统或安装不同的GNU/Linux发行版时，安装在用户文件和用户目录中的程序不会被删除。基岩Linux设计者在这个层次上开发了一个不同的模型。</p><p id="6960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基岩Linux基岩Linux是一个面向生产力的守护进程，旨在使用来自许多发行版的模块，定义为一个元发行版，一起放在一个操作系统中。换句话说，你可以在Debian上工作，使用来自Arch Linux的<strong class="ky ir"> Pacman </strong>或<strong class="ky ir"> AUR </strong>包管理器和包。您可以使用不同操作系统中的库和不同系统中安装的字体进行不同的编程。这个系统也有一些缺陷。目前正在0.7 poki minor以上进展。另外，也不能说是以安全为导向。这个系统对于那些不仅想从单个系统中获益，而且想从许多系统中获益，并且想同时使用多个包管理器、不同的包或不同的init系统的用户来说非常有用。你可以从<a class="ae kv" href="https://bedrocklinux.org/index.html" rel="noopener ugc nofollow" target="_blank">链接查看。</a></p><p id="46db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个系统使用起来非常简单。一旦很好地理解了层的概念，对于高级用户来说就很容易适应了。从Github下载一个shell脚本后，它会以root用户身份启动，并要求您确认要执行的操作，以此警告您这些操作是不可撤销的。然后，它获取根目录中的发行版，并将其移动到<code class="fe mq mr ms mt b">/bedrock</code>下的一个层中。您可以使用<code class="fe mq mr ms mt b"><strong class="ky ir">brl</strong></code>命令将其他发行版集成到您的系统中。你也可以在<code class="fe mq mr ms mt b">bedrock.conf</code>文件中配置你的系统。位于<code class="fe mq mr ms mt b">/etc/bedrock</code>下方。</p><p id="35ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b"><strong class="ky ir">brl apply</strong></code>用于应用修改。社区端使用率在基岩Linux官方页面<a class="ae kv" href="https://bedrocklinux.org/0.7/distro-compatibility.html" rel="noopener ugc nofollow" target="_blank">(链接)</a>给出。通常，经常使用的分布的错误率很低。比如Debian，ubuntu，centos，arch都用的比较频繁，没有已知问题。但是很多问题在不同的发行版中都有报道，比如Clear Linux，nixOS。地层的概念将在下一节讨论。</p><h1 id="9fce" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">地层</h1><p id="4ac3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">基岩将每个发行版安装在一个层上，在它们之间建立一个通信桥梁，并为其他交互使用提供适当的环境。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="c489" class="mz lt iq mt b gy na nb l nc nd">$ brl fetch --list</span></pre><p id="f9b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用该命令，可以看到可用作stratum的分布。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="800f" class="mz lt iq mt b gy na nb l nc nd">$ brl fetch void</span></pre><p id="1d77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这个命令可以创建void Linux层。它有void Linux <code class="fe mq mr ms mt b">runit</code> init系统。当基岩初始化接口来的时候，你可以在<code class="fe mq mr ms mt b">init</code>菜单上看到它是<code class="fe mq mr ms mt b"><strong class="ky ir">void:runit</strong></code>。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="f46e" class="mz lt iq mt b gy na nb l nc nd">$ strat -r debian neofetch</span></pre><p id="5039" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用该命令时，Debian stratum中的<code class="fe mq mr ms mt b">neofetch</code>包将运行，并将Debian视为根目录。它将Debian作为操作系统版本输出。但是直接用<code class="fe mq mr ms mt b">neofetch</code>的时候，基岩Linux会被看成os-release。当生成工具扫描环境并从不同的发行版中找到依赖项时发生。</p><p id="794d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果像这样的底层环境引起混淆，可以使用restrict -r参数绕过层间挂钩。如果你用同一个包管理器使用两个发行版，例如，apt和rpm是最常用的包管理器，那么你可以以<code class="fe mq mr ms mt b">apt</code>的身份启动ubuntu。可能需要这样的应用程序，因为源存储库是不同的。</p><p id="6c4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个包存在于多个层中，那么它将在<code class="fe mq mr ms mt b">pinned</code>层中执行。你可以和<code class="fe mq mr ms mt b">brl which</code>核实一下。所有层都可以将<code class="fe mq mr ms mt b">/run</code>、<code class="fe mq mr ms mt b">/temp</code>、<code class="fe mq mr ms mt b">/home</code>目录视为一个全局文件路径。</p><p id="e07f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果需要，您可以启用或禁用某些层。您可以使用<code class="fe mq mr ms mt b">brl enable/disable</code>命令。您可以使用<code class="fe mq mr ms mt b">brl remove -d</code>命令直接删除地层。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="ed08" class="mz lt iq mt b gy na nb l nc nd">$ brl remove -d fedora</span></pre><h1 id="9d64" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">安装、使用和审查</h1><p id="e921" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本节中，将解释一些主题，如如何通过在VirtualBox中基于Ubuntu的虚拟Linux lite上安装基岩来创建和配置一些地层，如何安装软件包。</p><p id="e16a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以选择不同的发行版。特别是，基于常用或经常使用的发行版而没有进行重大更改的发行版可以顺利运行。</p><p id="650c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于安装，可以从链接下载适合CPU架构的脚本。首先，守护进程的安装应该通过以root用户身份运行基岩shell脚本来完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a7ecf6de83b7757fcdba1fa30baab905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*OzbxpicRdFqFdFhZ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的基岩Linux安装图</p></figure><p id="601e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">“不可逆！”</strong>通过键入，您同意这些条款，安装开始。在安装之前，根目录中的操作系统被带到一个临时位置。</p><p id="b854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在根上安装基岩，在一个层中安装临时位置的OS。该过程完成后，您可以看到重启后的init selection文本模式界面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/953a6e46407050e78eec7bbfe74f42a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*MzlW9vuqdPygh5nc.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基岩linux初始化菜单——作者图片</p></figure><p id="dd1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，系统从标有<code class="fe mq mr ms mt b">“*”. /sbin/init</code>的系统引导到这里的<code class="fe mq mr ms mt b">/usr/lib/systemd/systemd</code>。<code class="fe mq mr ms mt b">Systemd</code>启动服务，提供系统引导。当Ubuntu启动时，名为<code class="fe mq mr ms mt b">crossfs</code>和<code class="fe mq mr ms mt b">etcfs</code>的进程是文件系统，用于在层边界之间移动文件、库和字体。此外，包含地层二进制文件的路径被添加到<code class="fe mq mr ms mt b">PATH</code>变量中。这样，我们可以通过bash或任何shells访问它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/5d36a0b28f72172a85a67ec48e49d17f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*rkcpIh2V7OkkKowM.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">neofetch —作者图片</p></figure><p id="ff73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我正在Ubuntu上安装<code class="fe mq mr ms mt b">neofetch</code>包。你可以从Ubuntu apt库安装它。然后，当我使用<code class="fe mq mr ms mt b">neofetch</code>命令时，基本系统显示为基岩。在Ubuntu层运行<code class="fe mq mr ms mt b">neofetch</code>。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="0caf" class="mz lt iq mt b gy na nb l nc nd">$ strat -r ubuntu neofetch</span></pre><p id="0920" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应该使用命令。受限情况下，跨层挂钩被禁用。这种方式<code class="fe mq mr ms mt b">neofetch</code>只会在<code class="fe mq mr ms mt b">ubuntu</code>地层起作用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/11f0d8fd45ad95c0cbd85298357c845a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*2dQBbReMFKZWhfnr.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Ubuntu startum中的nefetch图片由作者提供</p></figure><p id="b3f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创造另一个阶层，</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="36f8" class="mz lt iq mt b gy na nb l nc nd">$ brl fetch --list <br/>alpine<br/>arch<br/>...<br/>...<br/>$ brl fecth void</span></pre><p id="e433" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用命令检查发行版。然后用<code class="fe mq mr ms mt b">brl fetch</code>从stratum mirror下载安装。</p><p id="b92c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如使用<code class="fe mq mr ms mt b">runit</code>的void Linux，拉包之后，可以在init菜单看到void Linux。当<code class="fe mq mr ms mt b">strat -r void neofetch</code>再次运行时，它会警告包不存在。</p><p id="a7f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为中间没有钩子，所以无法到达ubuntu地层中的<code class="fe mq mr ms mt b">neofetch</code>包。在这个层中，用<code class="fe mq mr ms mt b">sudo xbps-install neofetch</code> <strong class="ky ir">安装并运行这个包。</strong></p><p id="9e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统里既有ubuntu又有void <code class="fe mq mr ms mt b">startums</code>。这里<code class="fe mq mr ms mt b">xbps</code>包管理器和apt包管理器可以联合使用。例如</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="b4ee" class="mz lt iq mt b gy na nb l nc nd">$ sudo xbps-install filezilla</span></pre><p id="69c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这个命令，Filezilla可以在ubuntu stratum中安装和运行。反之亦然。例如，在Arch Linux stratum中，您可以从AUR软件包安装一个软件包，并从其他startums访问它。</p><p id="56f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，git可以与Pacman一起安装，spring助手软件可以从GitHub repo安装。使用<code class="fe mq mr ms mt b">yay -Sy brave</code>一个属于拱形地层的包可以被所有地层使用。</p><p id="bb66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一次系统启动时，有三个初始化选择选项。除了使用<code class="fe mq mr ms mt b">systemd</code>的arch和ubuntu，还可以使用使用<code class="fe mq mr ms mt b">runit</code>的void Linux init系统。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/58ba6b3806c31656d64a70717a1568c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/0*_fltWzCoqv-GGLAb.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">filezilla是void stratum，但它可以在Ubuntu stratum-gif上访问</p></figure><p id="e577" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一次系统启动时，有三个初始化选择选项。除了使用<code class="fe mq mr ms mt b">systemd</code>的arch和ubuntu，还可以使用使用<code class="fe mq mr ms mt b">runit</code>的void Linux init系统。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/33d291b2da77aaef2c915dd2faf209be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*WHUvQz7O3owzc7x7.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">初始菜单中有三个发行版——按作者分类的图片</p></figure><p id="e149" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统相关的设置可以在<code class="fe mq mr ms mt b">bedrock.conf</code>文件中进行。比如可以改变默认的init，可以缩短超时时间，可以设置字体所在的目录，也可以进行层间的优先级设置。可以为<code class="fe mq mr ms mt b">brl fetch</code>更换镜像服务器。详细信息可以通过这个<a class="ae kv" href="https://bedrocklinux.org/0.7/configuration.html" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h1 id="3ebc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">总结和结论</h1><p id="1715" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个系统完全以生产力为导向。可能存在一些与安全相关的问题。官方页面为那些有安全顾虑的人提供了一些答案。但是，如果安全性是您最关心的问题，并且希望同时使用多个发行版的特性，那么使用Qubes这样的发行版更合适。</p><p id="f43c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Qubes将每个操作系统虚拟化到下一个级别。这是一个旨在通过隔离提供安全的系统。它默认推荐Whonix，但是你也可以安装windows或者fedora，Debian。安全和生产率/速度在这里是两个相互冲突的概念。我认为这个发行版是一个元发行版，将在主要的1.0.0版本发布后由<strong class="ky ir">发行商</strong>使用。即使这个版本也没有很多问题，用户体验非常稳定。</p><p id="6436" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为它对于使用Linux发行版的开发人员来说也是非常有用的。在Linux发行版中创建一个广泛而强大的开发环境有时可能非常困难，但是这个元发行版允许我们同时使用更多不同的Linux发行版应用程序。在我看来，它将提高每个开发人员或任何执行操作任务的工程师的生产率。</p></div></div>    
</body>
</html>