<html>
<head>
<title>Don’t Do These With Swift Optionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要用Swift选项做这些</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dont-do-these-with-swift-optionals-285e2d99b0ea?source=collection_archive---------6-----------------------#2020-09-01">https://betterprogramming.pub/dont-do-these-with-swift-optionals-285e2d99b0ea?source=collection_archive---------6-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3bc5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Swift中使用选项时的注意事项列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fab04ac07bc99d44bbaca530ca337d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JWjowvOYS3cRbixv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可选变量是Swift中的一个重要概念。在较老的语言中，如C++或Java，所有指针都是可选的，但所有基本类型都不是——除非它们被包装在某种结构中。</p><p id="5ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在内部，<em class="lv">可选</em>是一个有两个变量的结构:</p><ul class=""><li id="5085" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">指示变量是否有值的标志，以及</li><li id="20ad" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">一个值。</li></ul><p id="7ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果标志为false，则忽略该值。如果标志为真，则可以使用该值。</p><p id="c786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑上可以表示为一个盒子，里面可以有一些内容，也可以什么都没有。</p><p id="2210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift的一个优势是可选性被集成到语言本身中。如果你做错了什么，编译器会显示一个编译时错误。但也有例外。在这里，我将尝试回顾如何正确地使用选项，以及如何不使用它们。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="19e7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">选择权声明</h1><p id="07ee" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">有两种方法可以声明选项:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="473d" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">var</strong> a: Int?<br/><strong class="np iu">var</strong> b: Int!</span></pre><p id="d53f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两种方法都声明了可选的整数变量，但是有一个很大的区别。问号(<code class="fe ny nz oa np b">?</code>)不允许我们使用变量，除非我们确定它有一个值。感叹号(<code class="fe ny nz oa np b">!</code>)允许创建一个未初始化的变量，但它不需要进行零检查。如果你把它作为一个参数或者赋给一个非可选的变量，程序会崩溃。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0d12" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Do:</em></strong><br/><strong class="np iu">var</strong> a: Int?      // Declare an optional variable, initialised to nil<br/><strong class="np iu">var</strong> b: Int? = 1  // Declare an optional variable, initialised to 1<br/><strong class="np iu">var</strong> c: Int       // Declare a non-optional variable, must be initialised in constructor. If it's not initialised in constructor, code won't compile<br/><strong class="np iu">var</strong> d: Int!      // Declare an optional variable, not initialised. Do it only if you're 100% sure variable will be initialised. For example, in <strong class="np iu">viewDidLoad</strong> or in <strong class="np iu">@IBOutlet</strong></span><span id="397a" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu"><em class="lv">// Don't:</em></strong><br/><strong class="np iu">var</strong> e: Int! = 1   // It's just useless and can create bugs. You should either make it non-optional, or initialise later<br/><strong class="np iu">var</strong> f: Int! = nil // When we use exclamation mark, we assume that variable will always have a value</span></pre><p id="9dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，用感叹号声明可选选项并不是一个好主意。只要有可能，就用问号代替。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="80da" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">可选类型</h1><p id="6573" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">任何类型都可以是可选的。但是混合不同的“不存在”的值不是一个好主意。例如，类型<code class="fe ny nz oa np b">Void?</code>是一个有效的类型，但是它没有任何意义。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9ded" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Don't:</em></strong><br/><strong class="np iu">var</strong> t: Void? = <strong class="np iu">nil<br/></strong>print(t)   // Prints "nil"</span><span id="699f" class="nt ms it np b gy ob nv l nw nx">t = Void()<br/>print(t)   // Prints "Optional(())"</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4ec1" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">打印选项</h1><p id="1124" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">你不应该直接打印期权。如果它没有任何值，你将得到“nil”，否则它将是“可选的(值)”。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fae5" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Don't:</em></strong><br/><strong class="np iu">var</strong> a: Int? = 1<br/>print(a)   // Prints "Optional(1)"<br/>print(a!)  // Will crash if a is <strong class="np iu">nil</strong></span><span id="fa49" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu"><em class="lv">// Do:</em></strong><br/>print(a ?? "No value")  // Prints value of a or "No value" for <strong class="np iu">nil</strong><br/>print(a ?? "nil")       // Same as print(a), but without "Optional"<br/>print(a ?? "")          // Prints empty line if value is <strong class="np iu">nil</strong></span></pre><p id="dbf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串插值也是如此。例如:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a80e" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">let</strong> str = "\(a)" // str = "Optional(1)"</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3d40" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated"><code class="fe ny nz oa np b">Optional Constants</code></h1><p id="0d2e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">将非零选项定义为常量是没有用的。不要这样做——这让人困惑。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e439" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Don't:<br/></em>let<em class="lv"> </em></strong>c: Int? = 1</span><span id="bb78" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu"><em class="lv">// Do:</em></strong><br/><strong class="np iu">let</strong> d: Int = 1</span></pre><p id="59e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非可选变量(或常量)总是可以分配给可选变量。例如:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="99db" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">let</strong> a: Int = 1<br/><strong class="np iu">var</strong> b: Int? = 2</span><span id="b84a" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu"><em class="lv">// Do:</em></strong><br/>b = a</span><span id="439d" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu"><em class="lv">// Don't</em></strong><br/>a = b     // Compiler will show an error</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="49a2" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">打开</h1><p id="eb87" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果我们需要把一个可选变量赋给一个非可选变量，我们该怎么做？答案是:解开它。正如我前面说过的，可选结构是泛型结构之王。该值被包装到一个结构中。从那里获取值是展开一个可选的。</p><p id="bbbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有四种方法打开它。第一种选择:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d9c9" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Do:</em></strong><br/><strong class="np iu">var</strong> a: Int? = 1<br/><strong class="np iu">var</strong> b: Int = 2</span><span id="d5ee" class="nt ms it np b gy ob nv l nw nx">b = a ?? 0</span></pre><p id="6272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们使用了最常见的展开方式。我们提供一个默认值。如果变量<code class="fe ny nz oa np b">a</code>是<code class="fe ny nz oa np b">nil</code>，我们将<code class="fe ny nz oa np b">0</code>赋值给<code class="fe ny nz oa np b">b</code>。</p><p id="a5a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种选择:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0925" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Do:</em></strong><br/><strong class="np iu">var</strong> a: Int? = 1<br/><strong class="np iu">var</strong> b: Int = 2</span><span id="8ee6" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">guard</strong> <strong class="np iu">let</strong> c = a <strong class="np iu">else</strong> { <strong class="np iu">return</strong> }<br/>b = c</span></pre><p id="5f07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们检查<code class="fe ny nz oa np b">a</code> <em class="lv"> </em>是否不是<code class="fe ny nz oa np b">nil</code>，如果是，我们将其分配给<code class="fe ny nz oa np b">c</code>。否则，我们就从当前函数中选择<code class="fe ny nz oa np b">return</code>。如果我们在一个循环中，我们也可以使用<code class="fe ny nz oa np b">break</code>或<code class="fe ny nz oa np b">continue</code>，或者如果<code class="fe ny nz oa np b">nil</code>值指示一个错误，我们也可以使用<code class="fe ny nz oa np b">throw</code>。换句话说，我们需要在到达任务之前终止当前的作用域。</p><p id="9646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三种选择:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e544" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">// Do:</strong><br/><strong class="np iu">var</strong> a: Int? = 1<br/><strong class="np iu">var</strong> b: Int = 2</span><span id="445c" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">if</strong> <strong class="np iu">let</strong> c = a {<br/>    b = c<br/>}</span></pre><p id="d197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和第二个一样，只是倒置了。如果值是<code class="fe ny nz oa np b">nil</code>，我们不终止当前函数，而是只在值不是<code class="fe ny nz oa np b">nil</code>时执行<code class="fe ny nz oa np b">if</code>范围。</p><p id="24ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四种选择:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="ece1" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Don't:</em></strong><br/><strong class="np iu">var</strong> a: Int? = 1<br/><strong class="np iu">var</strong> b: Int = 2</span><span id="4b5b" class="nt ms it np b gy ob nv l nw nx">b = a!</span></pre><p id="85d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这被称为“强制解包”。如果你想做，再考虑一下。如果你还想做，你可能需要复习你的Swift知识。你正在做的事情很可能有问题。当然，这个功能是存在的。这意味着在某些情况下你可以使用它，但这种情况非常罕见。</p><p id="8d62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这将起作用:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="087f" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Don't:</em></strong><br/><strong class="np iu">var</strong> a: Int? = 1<br/><strong class="np iu">var</strong> b: Int = 2</span><span id="65c7" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">if</strong> a != nil {<br/>    b = a!<br/>}</span></pre><p id="ca0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是很丑。如果<code class="fe ny nz oa np b">a</code>不是<code class="fe ny nz oa np b">nil</code>时需要将<code class="fe ny nz oa np b">a</code>赋值给<code class="fe ny nz oa np b">b</code>，按以下方式操作:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2a3f" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Do:<br/></em>var</strong> a: Int? = <strong class="np iu">nil<br/>var</strong> b: Int = 2</span><span id="f67d" class="nt ms it np b gy ob nv l nw nx">b = a ?? b</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8a8e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">链接</h1><p id="4da6" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我想在这里讨论的下一个主题是链接。</p><p id="54ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个可选的<code class="fe ny nz oa np b">struct</code>或<code class="fe ny nz oa np b">class</code>，它们有可选的属性或方法。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9168" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Do:</em></strong></span><span id="1248" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">struct</strong> C {<br/>    <strong class="np iu">var</strong> a: Int?<br/>    <strong class="np iu">func</strong> getA() -&gt; Int? { a }<br/>}</span><span id="0991" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">struct</strong> D {<br/>    <strong class="np iu">var</strong> c: C?<br/>}</span><span id="5ef4" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">var</strong> d: D? = D()<br/><strong class="np iu">var</strong> a = d?.c?.a</span></pre><p id="5c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们有一个作业，一行有两个问号。工作原理:</p><ol class=""><li id="8b66" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu oc mc md me bi translated">检查<code class="fe ny nz oa np b">d</code>的值是否为<code class="fe ny nz oa np b">nil</code>。如果是<code class="fe ny nz oa np b">nil</code>，它将<code class="fe ny nz oa np b">nil</code>分配给<code class="fe ny nz oa np b">a</code>。</li><li id="1337" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu oc mc md me bi translated">否则，检查<code class="fe ny nz oa np b">d</code> ( <code class="fe ny nz oa np b">struct D</code>)的属性<code class="fe ny nz oa np b">c</code>。同样的逻辑。如果是<code class="fe ny nz oa np b">nil</code>，则<code class="fe ny nz oa np b">a</code>变为<code class="fe ny nz oa np b">nil</code>，代码结束。</li><li id="7ed9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu oc mc md me bi translated">如果<code class="fe ny nz oa np b">d?.c</code>不是<code class="fe ny nz oa np b">nil</code>，它最终将变量<code class="fe ny nz oa np b">d</code>的属性<code class="fe ny nz oa np b">c</code>的属性<code class="fe ny nz oa np b">a</code>的值赋给变量<code class="fe ny nz oa np b">a</code>。</li></ol><p id="98ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个重要的细节:如果你在开始的时候得到一个可选的，你不需要在每个点之前用一个问号。即使值是可选的，只有当变量或属性有可选类型时，才需要使用问号。</p><p id="c27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4d0e" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Do:</em></strong><br/><strong class="np iu">struct</strong> C {<br/>    <strong class="np iu">var</strong> a: Int?<br/>    <strong class="np iu">func</strong> getA() -&gt; Int? { a }<br/>}</span><span id="c450" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">struct</strong> D {<br/>    <strong class="np iu">var</strong> c: C = C()<br/>}</span><span id="f71f" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">var</strong> d: D? = D()<br/><strong class="np iu">var</strong> a = d?.c.getA()</span></pre><p id="c734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">如果一个链中至少有一个可选组件，结果将是可选的。</em> </strong></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="796f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">期权和回拨</h1><p id="0ba7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我想讨论的最后一个主题是混合了异步工作和转义回调的选项。这听起来可能很奇怪，但让我解释一下这里的危险在哪里。</p><p id="54ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个方法为<code class="fe ny nz oa np b">getUser(...)</code>的类<code class="fe ny nz oa np b">API</code>。我们不会深入研究实现，但该方法是异步的，并返回一个可选的用户值和一个可选的错误。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="669e" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">class</strong> API {<br/>    ...</span><span id="f4ef" class="nt ms it np b gy ob nv l nw nx">    <strong class="np iu">func</strong> getUser(delegate: <strong class="np iu">@escaping</strong>(<strong class="np iu">_</strong> user: <strong class="np iu">Any</strong>?, <strong class="np iu">_</strong> error: Error?) -&gt; Void) {<br/>        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {<br/>            delegate(<strong class="np iu">nil</strong>, <strong class="np iu">nil</strong>)<br/>        }<br/>    }<br/>}</span></pre><p id="0dfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数仅在一秒钟后返回<code class="fe ny nz oa np b">nil</code>值。但足以说明想法。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9259" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Don't:</em></strong></span><span id="ab04" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">var</strong> api: API? = API()</span><span id="b625" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">func</strong> login(delegate: <strong class="np iu">@escaping</strong> () -&gt; Void) {<br/>    ....</span><span id="9320" class="nt ms it np b gy ob nv l nw nx">    api?.getUser { (<strong class="np iu">_</strong>, <strong class="np iu">_</strong>) <strong class="np iu">in<br/>        </strong>delegate()<br/>    }<br/>}</span></pre><p id="7e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码有什么问题？变量<code class="fe ny nz oa np b">api</code>是可选的。这意味着如果<code class="fe ny nz oa np b">api</code>是<code class="fe ny nz oa np b">nil</code>，方法<code class="fe ny nz oa np b">getUser</code>将永远不会被调用。并且<code class="fe ny nz oa np b">login</code>方法的<code class="fe ny nz oa np b">delegate</code>函数也不会被调用。大概你的app的UI会显示一些spinner，会旋转，会旋转，永远不会结束。</p><p id="c65a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许可选的API并不常见，但是可选的<code class="fe ny nz oa np b">user</code>却很常见。如果登录失败，可以返回<code class="fe ny nz oa np b">nil</code>。如果<code class="fe ny nz oa np b">User</code>是一个有更多方法的复杂类(例如，向服务器发送推送通知令牌)，在某些时候，你的回调可能在可选代码中。</p><p id="6e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用这种方法，你应该总是检查变量是否是<code class="fe ny nz oa np b">nil</code>，如果是，调用代码的<em class="lv">替代</em> <em class="lv">分支</em>，它调用<code class="fe ny nz oa np b">delegate</code>函数。</p><p id="c877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1222" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu"><em class="lv">// Do:</em></strong></span><span id="88d4" class="nt ms it np b gy ob nv l nw nx"><strong class="np iu">var</strong> api: API? = API()<br/><strong class="np iu">func</strong> login(delegate: <strong class="np iu">@escaping</strong> () -&gt; Void) {<br/>    <strong class="np iu">guard</strong> <strong class="np iu">let</strong> safeApi = api <strong class="np iu">else</strong> {<br/>        delegate()<br/>        <strong class="np iu">return<br/>    </strong>}</span><span id="f25b" class="nt ms it np b gy ob nv l nw nx">    safeApi.getUser { (<strong class="np iu">_</strong>, <strong class="np iu">_</strong>) <strong class="np iu">in<br/>        </strong>delegate()<br/>    }<br/>}</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="27c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift的另一个令人惊叹的特性是扩展。如果你喜欢有用的扩展，看看我的文章:</p><div class="od oe gp gr of og"><a href="https://medium.com/better-programming/10-useful-swift-string-extensions-e4280e55a554" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">10个有用的Swift字符串扩展</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">电子邮件验证、类型转换等等</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://medium.com/better-programming/24-swift-extensions-for-cleaner-code-41e250c9c4c3" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">24个Swift扩展，代码更简洁</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">更高效地构建您的移动应用</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d0cf" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="4508" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">选项是一个非常强大的工具，它有助于避免许多与<code class="fe ny nz oa np b">nil</code>值有关的问题。使用期权有安全和不安全的两种方式。尽可能选择安全的。使用感叹号(<code class="fe ny nz oa np b">!</code>)很少是个好主意。</p><p id="3151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐，下次见！</p></div></div>    
</body>
</html>