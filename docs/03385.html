<html>
<head>
<title>The Component Lifecycle in Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">苗条中的组件生命周期</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-component-lifecycle-in-svelte-1784ecab5862?source=collection_archive---------11-----------------------#2020-02-06">https://betterprogramming.pub/the-component-lifecycle-in-svelte-1784ecab5862?source=collection_archive---------11-----------------------#2020-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="52b6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过准确了解Svelte何时执行组件生命周期的各个部分，构建更健壮的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8cad77a8f01b18cd23681dc0b711e1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byC-Y8kI8TzDDbby0eqSeA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:我</p></figure><p id="e5c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">确切地知道应用程序中发生了什么可能意味着完全控制的感觉或经历深深的挫折之间的差别。就个人而言，未知让我抓狂，这反过来又经常导致各种各样的实验和/或调试会议。在这篇文章中，我想分享其中的一个，并阐明<a class="ae lr" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">svelet</a>中的组件生命周期。</p><p id="e8c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我会把这篇文章写得很短。主要目标是提供各种事件的综合概述以及它们触发的正确顺序。因此，我假设你对苗条有些熟悉。我们将首先看一下相关的概念，但是你也将会发现所有相关的代码以及在作品中更下面的交互式苗条环境的链接。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6ed9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">组件生命周期</h1><p id="90ec" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">Svelte中的每个组件都经历了相似的生命周期:按需创建、安装、更新，最终在不再需要时销毁。虽然Svelte在后台为您处理这些，但它可以通过事件通知您这些事情何时发生。正如我们将看到的，这在您需要直接与DOM交互时特别有用。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6dc7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">重大生命周期事件</h1><p id="729b" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">让我们从头开始。在所有可用的生命周期事件中，您可能会最常用到这两个:<code class="fe mw mx my mz b">onMount</code>和<code class="fe mw mx my mz b">onDestroy</code>。</p><p id="5e82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顾名思义，<code class="fe mw mx my mz b">onMount</code>将在<em class="na">组件刚刚挂载到DOM </em>时被调用。这是访问DOM节点的绝佳位置(例如，聚焦输入或与外部框架交互时)。</p><p id="70b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的对应物是<code class="fe mw mx my mz b">onDestroy</code>，当组件<em class="na">刚刚从DOM </em>中卸载时会被调用。典型的用例包括取消存储订阅或从外部库清理。</p><p id="477c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与以上相关的有<code class="fe mw mx my mz b">beforeUpdate</code>和<code class="fe mw mx my mz b">afterUpdate</code>。这些将分别在DOM更新之前和之后被称为<em class="na"/>。典型的循环如下所示:</p><ul class=""><li id="c817" class="nb nc iq kx b ky kz lb lc le nd li ne lm nf lq ng nh ni nj bi translated">该组件接收更新的属性或状态。</li><li id="ec7a" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><code class="fe mw mx my mz b">beforeUpdate</code>被称为。</li><li id="cd43" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">DOM被更新。</li><li id="41e2" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><code class="fe mw mx my mz b">afterUpdate</code>被称为。</li></ul><p id="0393" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，您可以使用它来更新元素的滚动位置(这也是官方教程中的例子)。</p><p id="10cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，对<code class="fe mw mx my mz b">beforeUpdate</code>的第一次调用甚至发生在组件挂载之前的<em class="na">，所以在试图访问这里的任何DOM元素时要小心。此外，由于这些可能会被调用很多，所以确保这里的代码是有效的可能是谨慎的。如果你想阅读更多关于它们的内容，请阅读API参考文献的相关章节。</em></p><p id="0a06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据我的经验，上述事件应该已经涵盖了您通常会遇到的许多用例。但是，有时您可能想要更多的控制(例如，当转换元素时)。这是下一节要讲的内容。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ee4e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">过渡事件</h1><p id="53d3" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated"><a class="ae lr" href="https://svelte.dev/tutorial/transition" rel="noopener ugc nofollow" target="_blank">过渡</a>本质上是动画，当一个元素被挂载到DOM或者从DOM中卸载时，它被应用到这个元素。一旦你在一个元素上使用了转换，Svelte将会触发几个关于转换的事件。</p><p id="a260" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，从技术上讲，这些不是生命周期事件，而是发生在每个单独分配了转换的DOM元素上。以下是过渡期间发生的情况:</p><ul class=""><li id="e311" class="nb nc iq kx b ky kz lb lc le nd li ne lm nf lq ng nh ni nj bi translated">Svelte调用分配给in-directive(或者transition-directive，如果你使用的话)的函数来创建转换。</li><li id="9bdd" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">调度<code class="fe mw mx my mz b">introstart</code>事件。</li><li id="3001" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">应用入转场(即元素以动画形式出现。注意:如果您使用Javascript进行转换，动画期间的每个更新周期都会调用tick函数。)</li><li id="31dc" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><code class="fe mw mx my mz b">introend</code>事件被调度。</li></ul><p id="1493" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以通过使用<code class="fe mw mx my mz b">on:introstart</code>或<code class="fe mw mx my mz b">on:introend</code>指令轻松地挂钩到这些事件中。</p><p id="cd3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">出转场的工作方式基本相同，只是用“结尾”代替了“开头”所以你会用<code class="fe mw mx my mz b">on:outrostart</code>和<code class="fe mw mx my mz b">on:outroend</code>。</p><p id="3d96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果这仍然是理论上的，我会完全理解。因此，我创造了一个互动的苗条REPL，你可以亲眼目睹这一切的发生。<code class="fe mw mx my mz b">App.svelte</code>主要是设置环境。有趣的部分在<code class="fe mw mx my mz b">Component.svelte</code>里面。代码应该或多或少是不言自明的，但如果有什么不清楚的地方，请在评论中告诉我。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这个REPL 的<a class="ae lr" href="https://svelte.dev/repl/ff7585c7987f4100867655a1cc475819?version=3.18.1" rel="noopener ugc nofollow" target="_blank">中的Component.svelte(为了清楚起见，将其缩短)</a></p></figure><p id="5b97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您按顺序单击所有三个按钮，您应该会得到类似如下的输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/375bf2027c5c08d439f223fec03ecc79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqMI4WBGOx0S1FrfzEKASg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生命周期和过渡事件概述</p></figure><p id="3749" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我鼓励你玩这个。例如，移除出转场以查看不再调度<code class="fe mw mx my mz b">outrostart</code>和<code class="fe mw mx my mz b">outroend</code>事件。</p><p id="dfc8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这几乎结束了生命周期功能的概述。然而，还有一个Svelte提供的功能。它被称为<code class="fe mw mx my mz b">tick</code>，并不是真正的生命周期挂钩，但与生命周期密切相关。一旦你理解了这一点，它可能会帮你省去很多麻烦(还有像<code class="fe mw mx my mz b">setTimeout</code>这样的黑客)。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="92ca" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">奖金:滴答</h1><p id="d32a" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">那么什么是<code class="fe mw mx my mz b">tick</code>？让我们从技术定义开始:无论何时调用<code class="fe mw mx my mz b">tick()</code>，它都将返回<em class="na">一个承诺，这个承诺在DOM已经与所有待定的属性/状态更新</em>同步之后解决。换句话说，你可以等待一个解决的承诺，以确保Svelte已经完成了所有相关的DOM更新。</p><p id="f7de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了说明这意味着什么，让我们看一个简单的例子(注意，有其他方法可以解决这个特殊的问题，但我想说明这一点):假设我们想有条件地显示一个输入，并在输入被挂载后立即聚焦它。我们可以设置一个布尔值来显示输入。这将触发Svelte的内部机制来更新DOM。但是我们如何知道DOM更新何时完成呢？你可能会尝试类似于<code class="fe mw mx my mz b">setTimeout</code>的东西，但那可能感觉像是一个黑客(理应如此)。</p><p id="f2d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，您可以简单地添加<code class="fe mw mx my mz b">tick()</code>并等待它的承诺解决:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用tick等待DOM更新(链接到<a class="ae lr" href="https://svelte.dev/repl/d13c11ee427d4638a1496a5696ad1a8c?version=3.18.1" rel="noopener ugc nofollow" target="_blank">交互式REPL </a></p></figure><p id="0dee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们点击按钮时发生的情况:</p><ul class=""><li id="9c97" class="nb nc iq kx b ky kz lb lc le nd li ne lm nf lq ng nh ni nj bi translated">调用(异步)事件处理程序<code class="fe mw mx my mz b">showInput</code>。</li><li id="50df" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">boolean设置为true，触发Svelte在下一个渲染周期显示输入。</li><li id="73a8" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">我们打电话给<code class="fe mw mx my mz b">tick</code>，等待承诺解决。</li><li id="642d" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">Svelte完成所有的DOM更新(即安装输入)，然后解析<code class="fe mw mx my mz b">tick </code>承诺。</li><li id="3f31" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">我们可以放心地在输入上调用<code class="fe mw mx my mz b">focus()</code> <em class="na"> </em>。</li></ul><p id="35a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您需要等待基于组件内<em class="na">变化的DOM更新，这将特别有用。如果你有条件地安装一个完整的组件，你宁愿使用<code class="fe mw mx my mz b">onMount</code>。</em></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d1c9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="e545" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">理解生命周期事件不仅有助于作为开发人员保持理智，还可以帮助您构建更健壮的应用程序。我希望这个概述能帮助你对苗条组件生命周期的各个部分更有信心。请在评论中告诉我你的想法。我也很想知道你用各种生命周期事件做什么。</p></div></div>    
</body>
</html>