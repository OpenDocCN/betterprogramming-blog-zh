<html>
<head>
<title>Interview Questions: Binary Pattern Search in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试问题:JavaScript中的二元模式搜索</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/binary-pattern-search-in-javascript-3612860428a3?source=collection_archive---------3-----------------------#2020-06-14">https://betterprogramming.pub/binary-pattern-search-in-javascript-3612860428a3?source=collection_archive---------3-----------------------#2020-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0288" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较小写字母a-z的字符串和1和0的模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f58b96ec6e39eae09888bfc77ca12d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fvUXFn7cXh-2zcEP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塔赫勒·阿明在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="35a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你们中的一些人所知，我正在市场上寻找我在web开发方面的下一个机会。这意味着我每天都在办公桌前做两件事之一:</p><ol class=""><li id="6edc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">浏览空缺职位，申请所述职位，并在LinkedIn上与人联系。</li><li id="d3a2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">学习新的概念、框架和技术，因为这很有趣。*</li></ol><p id="084b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">*也是为了在我的简历中添加更多技能，并作为一名开发人员不断成长。</p><p id="4efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想学的东西每天都在增长，但我决定优先考虑JavaScript框架、算法和AWS认证。我在<a class="ae ky" href="https://flatironschool.com/" rel="noopener ugc nofollow" target="_blank">熨斗学校</a>的时间给了我很多实践经验，我喜欢学习足够多的知识来建造一些东西，然后投入其中去建造它。然而，当我毕业时，我很快意识到我还有很长的路要走，还有很多东西要学。</p><p id="5edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还没有完成我的Angular类，但我已经决定投入并最终致力于我的算法技能(我已经在HackerRank和LeetCode上做了一些，但没有太多的主题或目的)。</p><p id="2d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确实明白，算法实际上只是配方，你可以一步一步地将更小的运算组合在一起，处理复杂的算法通常需要善于将挑战分解为更小的可管理的块，但我知道有些配方远非直观。值得学习一些行之有效的技巧。</p><p id="2193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我在Udemy 上与柯尔特·斯蒂尔一起报名参加<a class="ae ky" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank">JavaScript算法和数据结构大师班的原因。</a></p><p id="3ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个类，我不能说太多好的东西，我可以全心全意地把它推荐给任何代码爱好者，他们和我一样，来自非技术背景，但仍然希望更深入地研究一些可怕的概念，如大O、递归、排序算法等等。</p><p id="e93e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">柯尔特是一个很棒的老师，这门课充满挑战，但也足够有趣，让我每天都想回来上更多课。这门课还帮助我完成了最近的一次编码面试。</p><p id="ea81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，一家公司联系了我，希望能更好地了解我这个候选人。我从我最近的经历中学到了一些东西，我在一篇两部分的文章中写道:这里是<a class="ae ky" href="https://medium.com/better-programming/one-rejection-closer-to-success-fa3da3726bc5" rel="noopener"/>，<strong class="lb iu"> <em class="mj"> </em> </strong>，不要太激动，但还是要尽力而为。</p><p id="c796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在周末收到了一份要完成的编码评估，并提醒自己每一次代码挑战、评估和面试都让我成为一名更好的开发人员，让我更接近我的理想工作，即使这次没有成功。</p><p id="b821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我点击了提供给我的链接，开始了挑战，结果是一个由两个算术任务和七个反应问题组成的限时评估。</p><p id="3acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了不影响他们的面试过程，我不会透露网站和公司的详细信息。然而，第二个算术任务非常有趣，值得一写。我将改变一些细节，并在这里解释一下描述。</p><p id="cdae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">任务:</strong>编写一个函数<code class="fe mk ml mm mn b">binaryPatternMatching</code>，它采用一个由1和0组成的序列和一个由小写字母组成的字符串组成的模式。然后，该函数应该返回所有可能匹配的计数，其中0对应于小写元音，1对应于小写辅音(为了澄清，匹配必须具有与模式相同的长度和顺序)。</p><p id="298a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如说。给定一个字符串<code class="fe mk ml mm mn b">010</code>，这是我们的模式，和另一个字符串<code class="fe mk ml mm mn b">amazing</code>，我们将比较我们的模式，我们可以看到我们有两个可能的匹配。</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="d927" class="ms mt it mn b gy mu mv l mw mx"><strong class="mn iu">010</strong><br/><strong class="mn iu">ama</strong>zing</span><span id="4779" class="ms mt it mn b gy my mv l mw mx">  <strong class="mn iu">010</strong><br/>am<strong class="mn iu">azi</strong>ng</span><span id="4e44" class="ms mt it mn b gy my mv l mw mx"><strong class="mn iu">matches = 2</strong></span></pre><p id="c590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试更长的绳子。在这里，我向<a class="ae ky" href="https://randomwordgenerator.com/sentence.php" rel="noopener ugc nofollow" target="_blank">随机句子生成器</a>寻求一些帮助，下面是它得出的结果:</p><blockquote class="mz na nb"><p id="b342" class="kz la mj lb b lc ld ju le lf lg jx lh nc lj lk ll nd ln lo lp ne lr ls lt lu im bi translated">"有三块球形岩石聚集在一个立方体房间里。"</p></blockquote><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="c112" class="ms mt it mn b gy mu mv l mw mx">  <strong class="mn iu">010</strong><br/>Th<strong class="mn iu">ere</strong> were three sphered rocks congregating in a cubed room</span><span id="7cb5" class="ms mt it mn b gy my mv l mw mx">       <strong class="mn iu">010</strong><br/>There w<strong class="mn iu">ere</strong> three sphered rocks congregating in a cubed room</span><span id="f154" class="ms mt it mn b gy my mv l mw mx">                    <strong class="mn iu">010</strong><br/>There were three sph<strong class="mn iu">ere</strong>d rocks congregating in a cubed room</span><span id="7461" class="ms mt it mn b gy my mv l mw mx">                                    <strong class="mn iu">010</strong><br/>There were three sphered rocks congr<strong class="mn iu">ega</strong>ting in a cubed room</span><span id="626b" class="ms mt it mn b gy my mv l mw mx">                                      <strong class="mn iu">010</strong><br/>There were three sphered rocks congreg<strong class="mn iu">ati</strong>ng in a cubed room</span><span id="c48d" class="ms mt it mn b gy my mv l mw mx">                                                  <strong class="mn iu">010</strong><br/>There were three sphered rocks congregating in a c<strong class="mn iu">ube</strong>d room</span><span id="4ef0" class="ms mt it mn b gy my mv l mw mx"><strong class="mn iu">matches = 6</strong></span></pre><p id="79ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于这个任务的考虑，我们假设空格打断了字符串，这意味着它不再是一个匹配，这就是为什么以下内容没有被计算在内:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="9c12" class="ms mt it mn b gy mu mv l mw mx">    <strong class="mn iu">0 10</strong><br/>Ther<strong class="mn iu">e we</strong>re</span><span id="ca28" class="ms mt it mn b gy my mv l mw mx"><strong class="mn iu">01 0</strong><br/><strong class="mn iu">in a</strong> cubed</span><span id="fd91" class="ms mt it mn b gy my mv l mw mx">   <strong class="mn iu">0 10</strong><br/>in <strong class="mn iu">a cu</strong>bed</span></pre><p id="eec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信有几种方法可以完成这项任务，我在这里提出我的解决方案。它并不完美，或许还可以改进，但考虑到时间限制和我目前的知识，我粗略地写了以下内容。</p><p id="4797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我首先查看了我的输入和输出。我的输入是一串1和0以及另一串小写字母。我在我的算法类中见过类似的问题，其中字符串和子字符串(这里称为<em class="mj">模式</em>)都是字母或数字。我设计了一个两步走的计划:</p><ol class=""><li id="a233" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将小写字母字符串转换为1和0，其中辅音将变成1，元音将变成0。</li><li id="4d38" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对两个字符串(string和substring)进行循环，并计算模式匹配的次数。</li></ol><p id="3055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我如何实施第一步的:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="6a7d" class="ms mt it mn b gy mu mv l mw mx">// convert the string into an array of characters<br/>let subStrings = s.split('')</span><span id="a75a" class="ms mt it mn b gy my mv l mw mx">// create a new variable where we will store our 1s and 0s<br/>let arrayInBinary = []</span><span id="9566" class="ms mt it mn b gy my mv l mw mx">// for every element of our chars array<br/>for (let char of subStrings) {</span><span id="f155" class="ms mt it mn b gy my mv l mw mx">    // handy regular expression matching function<br/>    // returns true if the char is a vowel<br/>    if (/[aeiouy]/.test(char) === true) {</span><span id="0e4a" class="ms mt it mn b gy my mv l mw mx">    // we then push a "0" into our new array<br/>        arrayInBinary.push(0)<br/>    <br/>    // we push a "1" into our new array<br/>    } else if (/[bcdfghjklmnpqrstvwxz]/.test(char) === true) {<br/>        arrayInBinary.push(1)<br/>    // if the char is an empty space, we push space into the array<br/>    } else {<br/>        // push an empty space into new array<br/>        arrayInBinary.push(' ')<br/>    }<br/>    // we then convert the array back into a string<br/>    let string = arrayInBinary.join('')</span><span id="9472" class="ms mt it mn b gy my mv l mw mx">}</span></pre><p id="f111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是第一步。我们现在可以处理两个1和0的字符串，这使得这个任务更容易管理。</p><p id="9c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续第2步:</p><p id="3752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要比较这两个字符串并找到匹配的模式。由于我最近搜索算法的实践，我知道了实现这一点的函数。这是我们函数的第二部分:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="1a59" class="ms mt it mn b gy mu mv l mw mx">// a variable to keep track of our matches<br/>let count = 0</span><span id="e810" class="ms mt it mn b gy my mv l mw mx">// I reassigned pattern to a new variable for convenience<br/>let substring = pattern</span><span id="f5fb" class="ms mt it mn b gy my mv l mw mx">// loop over our string (the long one)<br/>for (let i = 0; i &lt; string.length; i++) {</span><span id="5706" class="ms mt it mn b gy my mv l mw mx">    // loop over our substring ("010")<br/>    for (let j = 0; j &lt; substring.length; j++) {</span><span id="c488" class="ms mt it mn b gy my mv l mw mx">        // we are comparing the substring[j] to string[i+j]<br/>        // because 'j' changes inside the loop but 'i' does not<br/>        if (substring[j] !== string[i+j]) {</span><span id="2c1d" class="ms mt it mn b gy my mv l mw mx">            // break out of the loop if no nums not a match<br/>            break</span><span id="bdc1" class="ms mt it mn b gy my mv l mw mx">        // if 'j' made it to the end of the short string<br/>        } else if(j === substring.length -1) {</span><span id="c7f2" class="ms mt it mn b gy my mv l mw mx">            // we have a match and we increase out counter<br/>            count++</span><span id="2eda" class="ms mt it mn b gy my mv l mw mx">        }</span><span id="72b3" class="ms mt it mn b gy my mv l mw mx">    }</span><span id="65a9" class="ms mt it mn b gy my mv l mw mx">}</span></pre><p id="a825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我确信有一个更快的解决方案(这个方案的时间复杂度为O(n**2)，但是我时间很紧，如果我手中已经有了一把非常好的锤子，我也没有心情去寻找钉枪(我喜欢木工和DIY，以防你不知道)。</p><p id="74a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是整个函数——这次没有注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="00f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，由于嵌套循环，我们处理的时间复杂度为O(n**2)，这不是很好。我在此发誓，当我学完我的算法课程，或者在不远的将来，当我更有经验、更有智慧的时候，我会回来重构代码并更新这篇文章。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="9a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编辑:</p><p id="ae6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我收到了一些反馈(有些是建设性的，有些不那么积极),因此我重构了这个函数。</p><p id="9065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一项正在进行的工作，我仍然愿意听取如何摆脱这种嵌套循环的建议。我按照某人的建议尝试使用String.matchAll()，但不幸的是，它忽略了重叠的字符串(给定(' 010 '，' amazing ')，返回1)，因此，返回错误的匹配数。我将把它注释掉。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二版:</p><p id="c1c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一些研究和一些思考，我现在有了这个优雅的解决方案，它使用正则表达式，在比较子串和二进制模式时消除了嵌套循环。低看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="fa4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见！</p></div></div>    
</body>
</html>