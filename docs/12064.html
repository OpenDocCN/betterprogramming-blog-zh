<html>
<head>
<title>Solve Phantom Read in MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决MySQL中的幻影读取</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solve-phantom-read-in-mysql-a1c85f9a8c56?source=collection_archive---------11-----------------------#2022-05-09">https://betterprogramming.pub/solve-phantom-read-in-mysql-a1c85f9a8c56?source=collection_archive---------11-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="70ef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">“创建”数据时写入偏斜的解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/798f60774632538d132c43356d275179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nkj3KriyNGjlu0aO.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tobias Fischer 在<a class="ae kv" href="https://unsplash.com/photos/PkbZahEG2Ng" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="698c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MySQL和它的存储引擎InnoDB的组合几乎是现在使用最广泛的关系数据库，<em class="ls"> Repeatable Read </em>是隔离级别最常见的。</p><p id="b69a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，与PostgreSQL相比，InnoDB有几个问题无法在<em class="ls">可重复读取</em>级别得到很好的解决。</p><ol class=""><li id="8fd7" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">丢失的更新</li><li id="eb64" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">幻像读取</li></ol><p id="91ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PostgreSQL中丢失的更新可以完全解决，无需额外的黑客攻击。至于幻影读取，有一些小技巧可以用，比如<code class="fe mh mi mj mk b">range types</code>等机制。</p><p id="cc49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，MySQL仍然必须小心地识别陷阱，并由开发人员正确地处理它们来解决此类问题。在我之前的文章中，我们介绍了三种解决更新丢失的方法。这些方法为丢失更新提供了更灵活的解决方案，适用于各种场景。</p><p id="8bf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将进一步探讨如何正确解决由幻像读取导致的写入偏斜。</p><p id="46fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有许多类型的场景会导致幻像读取，但一般来说，它们都有以下模式。</p><ol class=""><li id="cd77" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">搜索特定范围。</li><li id="5d25" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">根据范围的结果做一些事情(创建、更新、删除)。</li><li id="6c7d" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">该操作将直接影响原始范围结果。</li></ol><p id="437b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设只是更新或删除，避免写入偏斜的最直接方法是使用排他锁。如果在<code class="fe mh mi mj mk b">SELECT</code>的开头使用<code class="fe mh mi mj mk b">FOR UPDATE</code>，那么两个并发事务将被强制一个接一个地进行，从而有效地避免了竞争条件下的写偏斜。</p><p id="464c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在创建的情况下，解决方案并不那么直观。因为在<code class="fe mh mi mj mk b">SELECT</code>中没有相应的行可以锁定，所以该行是稍后创建的。那么如何解决呢？</p><h1 id="af53" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">会议室预订系统</h1><p id="0654" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在介绍解决方案之前，我们先用一个实际的例子来描述一下幻影读取带来的问题。</p><p id="fdce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个会议室系统，提供用户预定会议室，当用户成功预定会议室后，表格中会增加一个新的对应数据，如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/e1e17f043f862cba3c11541dcd4a1c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3NXQNYuGh7HHswTCHOWfw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预订</p></figure><p id="32b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上表记录了用户<code class="fe mh mi mj mk b">A</code>在5月1日上午10点预订了一个小时的会议室<code class="fe mh mi mj mk b">123</code>。</p><p id="2531" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个系统的行为将类似于下面的伪代码。</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="54c3" class="nn mm iq mk b gy no np l nq nr">count = `SELECT COUNT(*) FROM booking <br/>         WHERE room_id = 123 AND <br/>         start_time &lt; '2022-05-01 11:00' AND <br/>         end_time &gt; '2022-05-01 10:00'`<br/>         <br/>if count == 0:<br/>    `INSERT INTO booking (user, room_id, start_time, end_time)<br/>     VALUES ('A', 123, '2022-05-01 10:00', '2022-05-01 11:00')`</span></pre><p id="6421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户确定会议室在相应的时间段没有人时，用户可以插入一个条目作为预约，下一个用户将不会有时间冲突。这不是很好吗？</p><p id="90a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当两个用户想要同时占用同一个会议室的同一个时间段，并且他们都可以通过第一个<code class="fe mh mi mj mk b">SELECT</code>验证，因此他们都可以插入一个预订时，就会发生冲突。而这样的情况不是加一个锁就能解决的，因为一开始就没有要锁的行。</p><h1 id="ad2f" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">按唯一性求解(不完全解)</h1><p id="e253" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">由于没有办法通过锁将同时操作转变为顺序操作，所以我们让其中一个操作失败。为此，我们需要向表中添加一些约束，例如唯一约束。</p><p id="88a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种方法是在room_id、start_time列上创建一个唯一的约束索引，这样第二个试图预订同一时间段的人就会失败。</p><blockquote class="ns nt nu"><p id="3004" class="kw kx ls ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated">如果我们限制每个房间最多使用一小时，问题就解决了。</p></blockquote><p id="ad5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但如果会议室能订一个多小时，另一个问题就出现了。</p><ol class=""><li id="d172" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">用户A预订了5月1日上午10点到下午12点的时段</li><li id="1577" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">用户B预订了5/1从11:00到12:00</li></ol><p id="9d8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户A和B都在同时操作时，这种唯一的约束显然不能有效，于是会议室周围的冲突仍然存在。</p><h1 id="410f" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">具体化冲突(正确的解决方案)</h1><p id="02e1" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">为了解决这种幻影读取，开发人员必须使用一些技巧来揭示隐藏在同一个表下的冲突。</p><p id="4ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种方法是创建一个新表，并用数据预先填充它，作为同时操作的协调器。在这个会议室系统的例子中，我们可以创建一个表<code class="fe mh mi mj mk b">time_slots</code>,预先列出所有的时间段，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/527dfadf7288d5bc4cb1937ccd02bf20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*LcWy2cRfEA9gzfKpE6DkWA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">时间段</p></figure><p id="d5dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当要预订会议室时，我们不仅在原来的<code class="fe mh mi mj mk b">booking</code>上执行<code class="fe mh mi mj mk b">SELECT</code>，而且在<code class="fe mh mi mj mk b">time_slots</code>上执行<code class="fe mh mi mj mk b">SELECT</code>，并且我们可以添加<code class="fe mh mi mj mk b">FOR UPDATE</code>，因为数据已经存在。值得注意的是，新的<code class="fe mh mi mj mk b">SELECT FOR UPDATE</code>在原来的<code class="fe mh mi mj mk b">SELECT</code>之前执行。</p><p id="1827" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在那种情况下，当两个并发用户的期望时隙重叠时，会被独占锁阻塞，变成一个接一个，后者会因为看到了前一个完成的结果而直接失败。</p><h1 id="8c91" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">结论</h1><p id="0070" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">我不得不说这样的解决方案很难，也不直观。然而，为了在使用MySQL时不牺牲性能，隔离级别没有配置为<em class="ls">可序列化</em>，这意味着在执行过程中必须用复杂性来换取性能。</p><p id="d1e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是复杂性和性能之间的权衡。事实上，在这样的场景中使用<code class="fe mh mi mj mk b">FOR UPDATE</code>来处理同步确实会影响性能，如果<code class="fe mh mi mj mk b">booking</code>是一个可能在所有上下文中都有幻像读取的表，那么单独使<code class="fe mh mi mj mk b">booking</code><em class="ls">可序列化</em>是一个可行的解决方案。</p><p id="a96a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用数据库的时候，一定要知道数据库的能力，了解数据库所有不可解的情况，这样在设计开发的时候才能知道什么样的行为是潜在的风险。</p><p id="04f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如何妥善处理风险也是一个重要的课题。虽然每个人的用例不完全相同，但模式是相似的，学习如何解决每个模式将有助于您在未来快速处理类似的情况。</p><p id="5041" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文为“创建”数据时的写偏斜提供了一个解决方案，而前一篇文章是关于解决“更新”数据时的写偏斜。这些应该涵盖了你可能遇到的大多数情况。如果有人遇到了其他类型的MySQL竞争条件，也请随时与我讨论。</p></div></div>    
</body>
</html>