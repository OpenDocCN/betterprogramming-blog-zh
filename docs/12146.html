<html>
<head>
<title>Run-Time Polymorphism in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的运行时多态性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/run-time-polymorphism-in-c-6f9687857ba6?source=collection_archive---------8-----------------------#2022-05-15">https://betterprogramming.pub/run-time-polymorphism-in-c-6f9687857ba6?source=collection_archive---------8-----------------------#2022-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="28b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">掌握多态性概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b06cef163c7569c54141a398d212929b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lS8dZis6wrB6pE5F"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@euwars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法尔扎德·纳兹菲</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="32a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一篇文章中，我们看到了什么是<a class="ae kv" href="https://medium.com/better-programming/compile-time-polymorphism-in-c-f5ca6934cc55" rel="noopener">方法重载</a>以及我们如何实现它。方法重写是方法重载久违的兄弟，但是它们之间有一个根本的区别。</p><p id="cffc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是多态性系列的第2部分，在这里我们将深入探讨多态性。以下是拼图的三个部分。</p><ol class=""><li id="170c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/compile-time-polymorphism-in-c-f5ca6934cc55">编译时多态性</a></li><li id="b283" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">运行时多态性</li><li id="bbd5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@RikamPalkar/method-hiding-in-c-d653f822ab33" rel="noopener">方法隐藏/隐藏</a></li></ol><p id="bd6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将比较重写和重载，这不仅可以澄清这两者之间的混淆，还可以更好地理解重写。</p><blockquote class="mg mh mi"><p id="7559" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">重载意味着有多个行为，而重写意味着改变行为。</p></blockquote><p id="30ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是重载和重写之间的主要区别。</p><ol class=""><li id="ac17" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在方法重载中，我们必须改变签名，而在方法覆盖中，我们必须保持相同的方法签名，包括<code class="fe mn mo mp mq b">return-type</code>和<code class="fe mn mo mp mq b">access specifier</code>，这是一种可重用的技术。意思是，用完全相同的签名重新定义子类中的父类方法。</li><li id="20af" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">方法可以在同一个类中重载，也可以在子类中重载。尽管重写方法只能在子类中被重写，但是如果您试图使用相同的签名重写同一类中的方法，您将得到如下所示的编译时异常。</li></ol><p id="3068" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">异常:</strong>类型<code class="fe mn mo mp mq b">‘class name’</code>已经定义了具有相同参数类型的成员<code class="fe mn mo mp mq b">‘method name’</code>。</p><p id="de0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">最重要的规则:</strong>你只能覆盖<code class="fe mn mo mp mq b">virtual</code>或<code class="fe mn mo mp mq b">abstract</code>方法，这意味着父类需要用<code class="fe mn mo mp mq b">‘virtual’</code>或<code class="fe mn mo mp mq b">‘abstract’</code>关键字修饰一个方法，让子类可以覆盖。您不能覆盖不是<code class="fe mn mo mp mq b">virtual</code>或<code class="fe mn mo mp mq b">abstract</code>的方法。</p><p id="834f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开始编码吧！</p><blockquote class="mg mh mi"><p id="b30b" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">规则1: </strong>方法签名应该匹配，包括<code class="fe mn mo mp mq b">return-type</code>和<code class="fe mn mo mp mq b">access specifier</code>。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单1:被覆盖的方法GetOS()</p></figure><p id="e105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用它们的<code class="fe mn mo mp mq b">type</code>调用这些方法，看看这是否有效？</p><p id="bece" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在下图-1中看到的，父<code class="fe mn mo mp mq b">class SmartPhone </code>的一个实例正在调用它的<code class="fe mn mo mp mq b">GetOS()</code>版本并打印消息<code class="fe mn mo mp mq b">“Android” </code>，而子<code class="fe mn mo mp mq b">class Iphone</code>的一个实例正在调用它的<code class="fe mn mo mp mq b">GetOS()</code>版本并打印消息<code class="fe mn mo mp mq b">“iOS”</code>。这是因为我们已经成功地覆盖了<code class="fe mn mo mp mq b">class IPhone</code>中的方法<code class="fe mn mo mp mq b">GetOS()</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/9149d280baaa56f69445d096452ee6a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXifJensKDs53ZpU9635RQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:父类和子类对象调用各自的GetOS()方法</p></figure><p id="a89d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果你没有在子类中定义一个方法，那么子类对象将调用父类的方法。如果您有类似清单2的代码，那么您将得到类似image-2的输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单2:方法GetOS()没有在子类中被覆盖</p></figure><p id="71b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下图2中，可以看到父类对象和子类对象都在调用父类对象版本的<code class="fe mn mo mp mq b">GetOs()</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/accc3209166e7e04169c8d42330c6133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjMhc02qOe1gWHZDcXpsHA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:父类和子类对象调用父类的GetOS()方法</p></figure><p id="6830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看下面的几个错误场景，理解它们很重要！！</p><blockquote class="mg mh mi"><p id="183e" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">错误场景1: </strong>如果我试图用不同的<code class="fe mn mo mp mq b">return type</code>覆盖一个方法会发生什么？</p></blockquote><p id="9ca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我得到了下面的异常！</p><blockquote class="mg mh mi"><p id="e31a" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">异常:</strong> <code class="fe mn mo mp mq b">‘IPhone.GetOS()’</code>:返回类型必须是“字符串”才能匹配被覆盖的成员<code class="fe mn mo mp mq b">‘SmartPhone.GetOS()’</code></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/37cf66fd2c9a4de72da774e218474b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hWRlET2t0Fg94wXV_lwvzA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:不同返回类型的编译时异常</p></figure><blockquote class="mg mh mi"><p id="1daf" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">错误场景2: </strong>如果我试图用不同的<code class="fe mn mo mp mq b">access specifier</code>覆盖一个方法会发生什么？</p></blockquote><p id="96fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我得到了下面的异常！</p><blockquote class="mg mh mi"><p id="f304" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">异常:</strong> <code class="fe mn mo mp mq b"><em class="iq">‘IPhone.GetOS()’</em></code>:返回类型必须为‘string’才能匹配被覆盖的成员<code class="fe mn mo mp mq b"><em class="iq">‘SmartPhone.GetOS()’</em></code></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/8fc15ca7e7074462969b0938d0d6de93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cr8OCSw5q7IBTYHI6YCxLA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4:不同访问说明符的编译时异常</p></figure><blockquote class="mg mh mi"><p id="09c4" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">错误场景3: </strong>如果我试图覆盖一个不是<code class="fe mn mo mp mq b">virtual</code>或<code class="fe mn mo mp mq b">abstract</code>的方法会发生什么？</p></blockquote><p id="e8ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我当然得到了下面的例外！</p><blockquote class="mg mh mi"><p id="afca" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">异常:</strong> <code class="fe mn mo mp mq b"><em class="iq">‘IPhone.GetOS()’</em></code>:返回类型必须是“字符串”才能匹配被覆盖的成员<code class="fe mn mo mp mq b"><em class="iq">‘SmartPhone.GetOS()’</em></code></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/a70fc53eac65fa1932591adf517c7668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwJQ0x3ofSqkbyH3Ye9ycQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5:重写非虚方法时抛出编译时异常</p></figure><p id="575f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，你可能会说我可以简单地跳过子类中的override关键字，是的，你可以，但那样它就不是一个被覆盖的方法了。这将是一个属于<code class="fe mn mo mp mq b">type ‘IPhone’</code>的独立方法。</p><p id="4323" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这叫做方法隐藏，当父类和子类有相同的方法名，相同的签名，没有<code class="fe mn mo mp mq b">‘virtual’ </code>或<code class="fe mn mo mp mq b">‘abstract’</code>关键字，那么子类隐藏父类方法的实现。</p><p id="955a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再看一个场景，这也是面试问题之一。如果你有多级遗传呢？类似于清单3:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单3 : SmartPhone </p></figure><p id="0d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">New grandchild  【T5】  has its own version of  【T6】 , So with the object of  【T7】  we get its version of  【T8】 .</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/584280efc3b74dcf2d24da14fcc5ebd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u16lhAy8XzqGo85E4s9JGQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Image 6: Grandchild is calling its own implementation of GetOS()</p></figure><p id="00dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">The real question is, what if grandchild  【T9】  doesn’t have a version of the overridden method? so with its object, will it refer to parent’s  【T10】  or grandparent’s  【T11】 ? Let’s find out.</p><p id="341f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Listing 4 draws this scenario.</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Listing 4: Grandchild missing overridden method</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/2b33119f78adf2f9e1964464b0cc4c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUDHYow_UYDSforMmWA95A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Image 7: Grandchild refers to the immediate overridden method</p></figure><p id="f430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Remember this hierarchy of preferences : Local -&gt;直接父类-&gt;它们的父类-&gt;直到基类。</p><p id="4713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看一下，孙子女最终调用了其父版本的<code class="fe mn mo mp mq b">GetOS()</code>。这是因为如果被覆盖的方法存在，孙首先在自身中查找。如果不存在，那么它将转到父方法，查看是否存在被覆盖方法的版本。因为它确实存在于父类中，所以它停止了搜索并访问了该方法。</p><p id="1441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧！！现在我们知道它在<code class="fe mn mo mp mq b">override</code>的情况下访问immediate方法，但是当方法是<code class="fe mn mo mp mq b">virtual</code>时会发生什么呢？让我们看看。</p><p id="67e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑以下场景:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单5:孙子女可以访问2个虚拟方法</p></figure><p id="b7d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样的规则也适用于这里，它寻找直接的父节点并试图解决问题。在下图中，您可以看到<code class="fe mn mo mp mq b">IPhoneX</code>也在打印<code class="fe mn mo mp mq b">“iOS”</code>，它是<code class="fe mn mo mp mq b">GetOS()</code>的父版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/2b33119f78adf2f9e1964464b0cc4c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUDHYow_UYDSforMmWA95A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图8:孙子引用了父方法的直接虚拟方法</p></figure><p id="802b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了好玩，让我们也删除<code class="fe mn mo mp mq b">GetOS()</code>的父版本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单6:孙子女可以访问祖父母的虚拟方法</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/4c524b709782ef7859f419f2235d25af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uL3YqWYMt72Toe0l-qjhw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图9:孙子女指的是祖父母的直接虚拟方法</p></figure><p id="8b2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在它已经到达了基类<code class="fe mn mo mp mq b">SmartPhone</code>并且找到了具有匹配签名的方法，它停止了搜索并打印了输出“<code class="fe mn mo mp mq b">Android”</code>”。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="232f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们知道了重载和重写的不同方法。以及在重写方法时应该避免什么，以及如何成功地重写它。</p><pre class="kg kh ki kj gt ni mq nj nk aw nl bi"><span id="d092" class="nm nn iq mq b gy no np l nq nr"><strong class="mq ir">Want to Connect?</strong></span><span id="3152" class="nm nn iq mq b gy ns np l nq nr">Hit me up on <a class="ae kv" href="https://www.linkedin.com/in/rikampalkar" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>