<html>
<head>
<title>Building a Scalable Event-Driven Search Architecture With Postgres’ Full-Text Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Postgres的全文搜索构建可扩展的事件驱动搜索架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-scalable-event-driven-search-architecture-with-postgres-full-text-search-4780b87a34ef?source=collection_archive---------0-----------------------#2022-11-07">https://betterprogramming.pub/building-a-scalable-event-driven-search-architecture-with-postgres-full-text-search-4780b87a34ef?source=collection_archive---------0-----------------------#2022-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0e11" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用事件驱动架构设计基于Postgres的全文检索</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ad8b20f7955be71d2067a569ff7733fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*301AT06U4TiY8-2q"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">全文搜索</p></figure><p id="70b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">各种规模和复杂性的软件项目都面临着构建可伸缩搜索解决方案的挑战。谁没见过使用RDBMS SQL语句运行搜索的应用程序？你可能想知道这是不是一个好的解决方案。嗯，看情况。</p><p id="ffe7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用SQL执行搜索对于您的用例来说已经足够了，但是随着项目的增长和更多高级功能(同义词、多语言搜索，甚至启用机器学习等)的出现。)时，关系数据库可能就不够了。</p><p id="bdfc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">PostgreSQL支持全文搜索。全文索引允许对文档进行预处理，并保存索引以供以后快速搜索。</p><p id="98da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在某些情况下，PostgreSQL全文搜索可能就足够了，当然应该考虑使用。出于这个原因和其他原因，许多项目开始使用他们的数据库，随着时间的推移，他们转向像ElasticSearch或Solr这样的搜索引擎。</p><blockquote class="lr ls lt"><p id="577a" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">“……全文搜索是指在全文数据库中搜索单个计算机存储的文档或集合的技术……”</p><p id="afb0" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">—维基百科</p></blockquote><p id="8038" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近，我开始研究全文搜索选项。用例是在由三个可搜索字段组成的文档中搜索包含文档ID的字符串，这三个字段是标题和描述(使用全文搜索)以及文档ID。搜索应该在不超过200毫秒的时间内运行超过一百万个文档。</p><h1 id="18b1" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">术语</h1><h2 id="76f7" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">堵塞物</h2><p id="7632" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">这是一个将单词简化为词干，然后添加到后缀、前缀或词根的过程，称为引理，以确保该单词的变体在搜索过程中与结果匹配。例如，<code class="fe nh ni nj nk b">Managing</code>、<code class="fe nh ni nj nk b">Manager</code>、<code class="fe nh ni nj nk b">Management</code>可以来源于单词<code class="fe nh ni nj nk b">Manag</code>，搜索单词<code class="fe nh ni nj nk b">manag</code>将返回包含该单词任何变体的结果。<a class="ae nl" href="https://toolsaur.com/en/porter-stemmer" rel="noopener ugc nofollow" target="_blank">在线斯特梅尔工具</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/23b5b036a00bb05b59014d182cd02961.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*ZLdN6Z_fn873jbD8TmJ96Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae nl" href="https://thinkinfi.com/difference-between-stemming-and-lemmatizing-and-where-to-use/" rel="noopener ugc nofollow" target="_blank">https://thinkinfo . com/difference-between-stemming-and-lemmatizing-and-where-to-use/</a></p></figure><h2 id="982b" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">NGram</h2><p id="b693" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">它就像一个在单词上移动的滑动窗口——一个特定长度的连续字符序列。例如，术语<code class="fe nh ni nj nk b">word</code>将变成<code class="fe nh ni nj nk b">{'w', 'wo, 'wor', 'ord', 'rd'}</code>。NGram可以用来搜索单词的各个部分，甚至是两部分之间的部分。<code class="fe nh ni nj nk b">NGram</code>最常用的类型是<code class="fe nh ni nj nk b">Trigram</code>。</p><h2 id="32e7" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">模糊</h2><p id="28f8" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">“模糊”是指在比较两个字符串时，解决方案不寻找完美的逐位匹配。相反，它们允许一些不匹配(或“模糊”)。例如，搜索单词<code class="fe nh ni nj nk b">succesful</code>也会返回包含<code class="fe nh ni nj nk b">successful</code>的结果。常见的应用包括拼写检查和垃圾邮件过滤。</p><h2 id="fb39" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">类似</h2><p id="6a58" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">两个词的相似性可以通过计算它们共有的<code class="fe nh ni nj nk b">trigrams</code>的数量来衡量。这个简单的想法对于衡量很多自然语言中单词的相似度非常有效。</p><h2 id="7e9b" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">等级</h2><p id="b32f" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">排名试图测量文档与特定查询的相关程度，以便当有许多匹配时，最相关的文档可以首先显示。Postgres支持排名和加权排名。通常，权重用于标记文档中特殊区域的单词，如标题或初始摘要，以便它们可以比文档正文中的单词更重要或更不重要。</p><h1 id="853e" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">让我们停一会儿</h1><p id="c0d7" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">在我们进一步讨论之前，在匆忙实现全文搜索之前，有几点值得考虑。</p><h2 id="0801" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">了解数据</h2><p id="8119" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">在实现全文搜索之前，我们应该知道数据是什么样的，并理解业务需求。</p><h2 id="df23" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">数据量</h2><p id="7c0d" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">关于数据大小，需要考虑不同的因素，包括存储、保留策略、速度、索引等。可以说，无论数据大小如何，您都需要这种规划，但是必须承认两件事:</p><ol class=""><li id="cc97" class="nn no iq kx b ky kz lb lc le np li nq lm nr lq ns nt nu nv bi translated">规模增加了复杂性。</li><li id="15f3" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated">较小的规模意味着对架构错误(长时间运行的查询、丢失索引等)更宽容。)</li></ol><p id="cb7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于浏览大数据集所需的技术流程，大小很重要。这关系到数据的规划和处理。这关系到工具的选择和数据库的选择。</p><h2 id="9bd7" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">业务需求和功能</h2><p id="0fbb" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">我们必须非常清楚我们希望我们的搜索引擎实现的目标。我们的搜索引擎应该覆盖什么样的信息需求？谁使用搜索引擎？</p><p id="f852" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了全文搜索，我们还应该提供哪些功能？哪些字段应该被索引/搜索？应该支持哪些搜索类型？此外，除了搜索，我们是否希望允许其他功能，如过滤？</p><p id="0f3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，这将我带到最后一点，定义我们的关键性能指标(KPI)来衡量我们的搜索实现的成功。</p><h2 id="116f" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">KPI</h2><p id="8f2e" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">KPI是由软件测试团队测量和分析的详细规范，以确保过程符合业务目标。此外，他们帮助团队在产品性能不符合既定目标的情况下采取必要的措施。</p><p id="6ed6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的目标是在搜索结果的顶部向客户展示最佳匹配结果。在大多数情况下，如果想要的结果不在搜索页面的前X个结果中，或者不在搜索结果的前三页中，客户就会离开。</p><p id="f1f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们知道单个客户不能拥有超过50万个文档；平均而言，客户拥有50K个文档。此外，作为一项业务要求，搜索响应时间不得超过200毫秒。因此，我们决定使用一百万个文档，同时保持200毫秒的响应时间作为我们性能测试的基线。</p><h1 id="ceec" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">为什么是Postgres而不是ElasticSearch？</h1><p id="eb38" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">ElasticSearch仅针对搜索进行了优化，但设置和维护基础设施可能非常耗时。除此之外，自己设置它需要专用的服务器或服务，这比PostgreSQL选项更昂贵。此外，在ElasticSearch中，模式更改需要完全重建索引。默认情况下，返回的结果按相关性排序，最相关的文档排在最前面。但是，按字段值排序也是可能的。ElasticSearch还支持按字段过滤和开箱即用的分页。</p><p id="7ba1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们认为团队已经熟悉Postgres，它已经集成到我们的产品中，使它成为一个更便宜和更快的选择，因为它不需要任何额外的设置和维护。我们知道数据量会随着时间的推移而增长。然而，我们也意识到，随着当前数据的增长，我们的索引和搜索仍将在<a class="ae nl" href="https://elasticsearch-benchmarks.elastic.co/index.html#tracks/pmc/nightly/30d" rel="noopener ugc nofollow" target="_blank"> ElasticSearch </a>的范围内。尽管PostgreSQL速度较慢，结果可能稍差，并且可能受到容量的限制，但在相当大的范围内，它仍然可能“足够好”。</p><h1 id="1034" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">体系结构</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/68111d2eb9143ecfae72505d056ddd8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wr6jFqQ6Kx-S6pzW5BSk2A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。基于事件驱动架构的Postgres全文搜索</p></figure><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/cqrs-software-architecture-pattern-the-good-the-bad-and-the-ugly-e9d6e7a34daf"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">CQRS软件架构模式:好的、坏的和丑陋的</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">用CQRS和事务发件箱模式设计可伸缩架构</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">better编程. pub</p></div></div><div class="oo l"><div class="op l oq or os oo ot kp of"/></div></div></a></div><h2 id="1de0" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">索引服务(写)</h2><p id="1a96" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">索引服务使用包含需要索引的文档数据的事件。任何需要其文档可被搜索的服务都需要发布符合由索引服务维护的预定义模式的事件。</p><pre class="kg kh ki kj gt ou nk ov ow aw ox bi"><span id="c81a" class="mq lz iq nk b gy oy oz l pa pb">{<br/> updated_on: number;<br/> document_id: string;<br/> document_type: string;<br/> document_title: string;<br/> document_description: string;<br/> customer_id: string;<br/> metadata: object; <br/>}</span></pre><p id="6062" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了消费事件之外，索引服务还提供操作API，如运行真空、健康检查、重新索引单个或多个文档、同步等。</p><h2 id="8dd1" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">搜索服务(阅读)</h2><p id="b606" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">搜索服务(不言自明)负责搜索我们产品支持的所有类型的文档。它提供了分页、排序(默认是根据相关性)和过滤等功能。</p><h2 id="ddd9" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">读写分离</h2><p id="5ae7" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">分成两个微服务背后的动机，一个微服务用于索引文档。另一个用于搜索文档，允许我们适当地缩放。索引服务应该比搜索服务更加努力。我们不希望大量文档的索引影响最终用户的搜索功能。因此，让它单独部署而不共享相同的资源和连接池是我们要走的路。</p><h1 id="8847" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">索引存储</h1><p id="6265" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">在研究了如何在Postgres全文搜索过程中优化我们的查询之后，我们得到了以下结果:</p><ul class=""><li id="b2f8" class="nn no iq kx b ky kz lb lc le np li nq lm nr lq pc nt nu nv bi translated">我们在表中添加了一个新列<code class="fe nh ni nj nk b">ts</code>，用于存储预处理后的搜索文档(即词位列表)。<code class="fe nh ni nj nk b">ts</code>是一个<a class="ae nl" href="https://www.postgresql.org/docs/current/ddl-generated-columns.html" rel="noopener ugc nofollow" target="_blank">生成的列</a>(Postgres 12中的新列)，自动与源数据同步。然后我们在类型为<code class="fe nh ni nj nk b">tsvector</code>的<code class="fe nh ni nj nk b">ts</code>列上创建了一个<a class="ae nl" href="https://www.postgresql.org/docs/current/textsearch-indexes.html" rel="noopener ugc nofollow" target="_blank"> GIN索引</a>。</li><li id="6d88" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq pc nt nu nv bi translated">为了支持模糊搜索，我们使用了<code class="fe nh ni nj nk b">pg_trgm</code> Postgres扩展，并在表中添加了一个<code class="fe nh ni nj nk b">words</code>列来存储可搜索的文本。该列存储可搜索字段的串联字符串。</li><li id="14d2" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq pc nt nu nv bi translated">最后，<code class="fe nh ni nj nk b">pg_trgm</code>扩展提供了GiST和GIN索引操作符类。该索引允许我们在<code class="fe nh ni nj nk b">words</code>文本列上创建一个索引，用于快速相似性搜索。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pd pe l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h1 id="73c4" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">基准测试</h1><p id="40c5" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">我们在具有以下规格CPU i9 2.3 GHz (4个内核/线程)和8GB RAM的计算机上运行了基准测试。</p><p id="8e2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们用350万个文档填充了索引存储。我们对一个拥有一百万个索引文档的客户进行了基准测试。</p><p id="f3a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们测试了下面的查询，它使用<a class="ae nl" href="https://www.postgresql.org/docs/current/pgbench.html" rel="noopener ugc nofollow" target="_blank"> pgbench </a>工具返回436行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="2d3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们能够实现每秒170次交易。</p><pre class="kg kh ki kj gt ou nk ov ow aw ox bi"><span id="9199" class="mq lz iq nk b gy oy oz l pa pb">scaling factor: 1<br/>query mode: simple<br/>number of clients: 20<br/>number of threads: 20<br/>duration: 60 s<br/>number of transactions actually processed: 10187<br/>latency average = 58.925 ms<br/>initial connection time = 19.787 ms</span><span id="ec8a" class="mq lz iq nk b gy pf oz l pa pb">tps = 169.707403 (without initial connection time)</span></pre><p id="f271" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，大量数据存储在数据库中，随着数据的增长，性能和可扩展性会受到影响。分区通过将大表分成较小的表来解决这个问题，减少了内存交换问题和表扫描，并提高了性能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="aecf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在对索引存储表进行分区之后，我们在查询性能上实现了将近60%的提高。</p><pre class="kg kh ki kj gt ou nk ov ow aw ox bi"><span id="82ea" class="mq lz iq nk b gy oy oz l pa pb">scaling factor: 1<br/>query mode: simple<br/>number of clients: 20<br/>number of threads: 20<br/>duration: 60 s<br/>number of transactions actually processed: 14936<br/>latency average = 46.390 ms<br/>initial connection time = 26.722 ms<br/>tps = 248.933333 (without initial connection time)</span></pre><p id="9051" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是用<code class="fe nh ni nj nk b">EXPLAIN ANALYZE</code>运行查询的样子:</p><pre class="kg kh ki kj gt ou nk ov ow aw ox bi"><span id="c4f9" class="mq lz iq nk b gy oy oz l pa pb">With partitioning<br/>"Planning Time: 0.230 ms"<br/><em class="lu">"Execution Time: 25.808 ms"</em></span><span id="6acd" class="mq lz iq nk b gy pf oz l pa pb">Without partitioning<br/>"Planning Time: 0.204 ms"<br/><em class="lu">"Execution Time: 32.868 ms"</em></span></pre><h1 id="34b8" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="b1b1" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">Postgres提供了广泛的工具来支持全文搜索。在本文中，您已经看到了我们如何通过将读写分离来将全文搜索集成到我们的产品中，以及一些FTS功能是如何工作的。您还了解了如何利用带有GIN索引的<code class="fe nh ni nj nk b">SearchVectorField</code> ( <code class="fe nh ni nj nk b">tsvector</code>)类来优化性能，以及如何结合表分区来进一步扩展。</p><p id="fef1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你已经有Postgres作为你的堆栈的一部分，在使用一个需要更多关注操作复杂性的外部/昂贵的替代方案之前，值得考虑对它进行试验。</p><p id="6d56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，如果您的项目没有数千万条记录或非常大规模的数据，Postgres全文搜索将是一个很好的选择。</p><h1 id="6543" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">进一步阅读</h1><ul class=""><li id="0810" class="nn no iq kx b ky nc lb nd le pg li ph lm pi lq pc nt nu nv bi translated"><a class="ae nl" href="https://hevodata.com/learn/postgresql-partitions/" rel="noopener ugc nofollow" target="_blank"> Postgres分区</a></li><li id="9876" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq pc nt nu nv bi translated"><a class="ae nl" href="https://www.postgresql.org/docs/current/textsearch-controls.html" rel="noopener ugc nofollow" target="_blank"> Postgres全文搜索控件</a></li><li id="7207" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq pc nt nu nv bi translated"><a class="ae nl" href="https://www.postgresql.org/docs/9.1/pgtrgm.html" rel="noopener ugc nofollow" target="_blank"> Postgres pg_trgm和三元模型概念</a></li><li id="2625" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq pc nt nu nv bi translated"><a class="ae nl" href="https://www.alibabacloud.com/blog/optimizations-with-full-text-search-in-postgresql_595339" rel="noopener ugc nofollow" target="_blank">Postgres中的全文搜索优化</a></li><li id="3d5a" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq pc nt nu nv bi translated"><a class="ae nl" href="https://towardsdatascience.com/postgres-fuzzy-search-with-pg-trgm-smart-database-guesses-what-you-want-and-returns-cat-food-4b174d9bede8" rel="noopener" target="_blank">带pg_trgm的Postgres模糊搜索</a></li></ul><p id="8ffe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>