<html>
<head>
<title>A Beginner’s Guide to Data Encryption With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js数据加密初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginners-guide-to-data-encryption-with-node-js-95d458db1bdd?source=collection_archive---------7-----------------------#2021-03-02">https://betterprogramming.pub/beginners-guide-to-data-encryption-with-node-js-95d458db1bdd?source=collection_archive---------7-----------------------#2021-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c0c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">没有加密，Web开发就无法生存</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/23bc74a515229d12f4454c6fb0b956a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IW6GlCkCDKLY_s-oGGedBQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="1399" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着web应用程序不断获取大量属于个人、组织甚至政府的敏感数据，对数据安全的威胁达到了前所未有的高度。从编程的早期开始，程序员就使用密码术和加密技术来保护这些敏感数据免受恶意方的攻击。特别是在互联网引入后，密码技术在保证数据安全方面发挥了至关重要的作用。</p><p id="95bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在web开发中，当数据通过网络传输或存储在数据库中时，通常使用加密技术来保护数据。大多数加密操作都是在web后端执行的。这就是为什么作为Node.js开发人员，您应该了解如何加密和解密数据，以保护您的系统处理的数据。</p><p id="8107" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天的文章将介绍用于在web开发中保护数据的基本加密技术，并涵盖如何使用Node.js实现它们。Node提供了一个名为<a class="ae lu" href="https://nodejs.org/api/crypto.html" rel="noopener ugc nofollow" target="_blank"> crypto </a>的内置模块来轻松实现这些任务。</p><p id="71cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为第一步，我们必须理解到底什么是密码术(和加密)以及它是如何工作的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fa24" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是密码学？</h1><p id="70d8" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">密码学不是一回事。这是一个完整的研究领域，涉及保持数据安全的技术。为了实现这个目标，它主要是将一组初始数据转换成任何没有正确凭证的人既不能理解也不能转换回初始形式的东西。一些加密技术保证外部方没有改变该数据。</p><p id="2469" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在加密过程中有三个重要的组成部分:明文、密文和算法。加密算法将明文中的数据转换为密文，密文是原始数据的一种加密且不可识别的形式。该算法使用数学计算进行转换。</p><p id="90a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，加密算法在将明文转换为密文时使用一种叫做密钥的东西。只有随身携带正确的密钥，才有可能将密文转换回明文。所以，有特权查看明文的人，一定要把这个密钥存放在最安全的地方，不能让它落入外人之手。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d514" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是加密？</h1><p id="eb4b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">虽然这些术语(加密和密码术)有时可以互换使用，但它们不是一回事。</p><p id="35f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">加密是使用算法将明文转换为密文的过程。这只是密码学的一个方面。加密的对立面——将密文转换回明文的过程——被称为解密。</p><p id="afee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在密码学中，我们可以找到许多用于转换明文的加密算法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2380" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">密码术的类型</h1><p id="38bd" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">密码术有三种基本类型:</p><ul class=""><li id="aac2" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">对称密钥密码术</li><li id="d7de" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">非对称密钥密码术</li><li id="c9da" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">散列法</li></ul><p id="5f5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看每一项在数据安全中的重要性。</p><h2 id="067f" class="nn md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">对称密钥密码术</h2><p id="4228" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在上一节中，我们讨论了加密算法在将明文转换为密文时如何使用密钥，反之亦然。在对称密钥加密中，用于将明文转换为密文的密钥和用于将密文转换回明文的密钥是相同的。这种类型的加密很容易实现，并且比它的对应物非对称密钥加密更快。</p><p id="d142" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是对称密钥加密有一个主要的安全问题。当加密通过网络传输的数据时，这种方法要求发送方和接收方都拥有用于加密的密钥。这造成了加密密钥可能被第三方泄露的情况。</p><p id="bdd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当发送方和接收方试图通过网络交换加密密钥时，第三方就有机会窃取密钥。尤其是当所述网络是互联网时，交换密钥的风险很高。</p><h2 id="21a9" class="nn md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">非对称密钥密码术</h2><p id="f039" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">引入非对称密钥加密是为了克服对称密钥加密的安全性问题。它使用一对称为公钥和私钥的密钥(而不是一个)。公钥仅用于加密数据。私钥仅用于解密数据。您不能使用公钥来解密用它加密的数据，反之亦然。</p><p id="6b29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使公钥在除接收者或发送者之外的其他各方之间共享，它也不会危及系统的安全性。因为公钥在解密中是无用的，所以窃取公钥不会打开读取加密的和私有的用户数据的可能性。</p><h2 id="6277" class="nn md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">散列法</h2><p id="418e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">哈希不同于前两种类型的加密。</p><p id="f315" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对称加密和非对称加密便于将明文转换为密文，以及将密文转换回明文。然而，在散列法中，你只有一个选择:将明文转换成密文。一旦明文被“散列”，就不能再转换回来检查它的原始内容。</p><p id="84d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，您可以做的是检查另一个明文是否生成相同的哈希值，以查看两个明文是否相等。这是可能的，因为哈希算法保证每个唯一的明文生成一个唯一的密文。</p><p id="1881" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">存储密码时经常使用散列法。应用程序从不在数据库中存储明文密码。相反，它们存储密码的散列。在对用户进行身份验证时，我们必须检查由用户提供的密码生成的哈希是否等于存储在数据库中的哈希。如果提供的密码的散列值等于存储的散列值，则系统可以对用户进行身份验证。</p><p id="353b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与对称和非对称加密不同，哈希在哈希过程中不使用密钥。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e4a7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Node.js加密</h1><p id="d814" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Node.js具有内置的加密模块，该模块提供执行加密操作的函数。它包括一组OpenSSL的<code class="fe nz oa ob oc b">hash</code>、<code class="fe nz oa ob oc b">HMAC</code>、<code class="fe nz oa ob oc b">cipher</code>、<code class="fe nz oa ob oc b">decipher</code>、<code class="fe nz oa ob oc b">sign</code>和<code class="fe nz oa ob oc b">verify</code>函数的包装器。</p><p id="14cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本节中，我们将看到如何使用crypto模块实现加密。在我们开始之前，您必须设置通常的节点项目环境，并使用npm安装加密模块。</p><h2 id="184d" class="nn md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">使用Node.js加密数据</h2><p id="b028" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们可以使用crypto模块的<code class="fe nz oa ob oc b">Cipher</code>类来加密数据。那么，让我们实现加密功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a199" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当使用加密模块加密时，我们可以选择在每次调用<code class="fe nz oa ob oc b">encrypt</code>方法时生成一个新的密钥。使用不同的密钥进行加密使得攻击者更难使用暴力破解数据。</p><p id="a2e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，为了生成密钥，我们对加密和解密使用一个共同的秘密。如果解密数据的一方无法获得用于生成加密密钥的秘密，解密过程将会失败。</p><p id="fae2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用的加密算法是AES(高级加密标准)192位(24字节)算法。这里，192位表示密钥的长度。您可以看到我们是如何将密钥长度作为<code class="fe nz oa ob oc b">24</code>传递给密钥生成<code class="fe nz oa ob oc b">scrypt</code>函数的。</p><p id="f4fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当创建一个新的<code class="fe nz oa ob oc b">cipher</code>对象时，我们传递一个名为初始化向量的参数(<code class="fe nz oa ob oc b">IV</code>)。它通常不经过加密过程就被添加到密文中。它用于避免密文中的重复，这样攻击者就无法通过识别加密数据中的模式来解密数据。所以，<code class="fe nz oa ob oc b">IVs</code>应该永远是不可预测的，唯一的。由于这个原因，这个实现使用<code class="fe nz oa ob oc b">randomFill</code>函数生成一个新的<code class="fe nz oa ob oc b">IV</code>。</p><p id="a638" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，使用<code class="fe nz oa ob oc b">write</code>功能完成数据加密。每当从加密的数据流中获得一个数据块时，<code class="fe nz oa ob oc b">cipher</code>对象触发“data”事件，然后这个数据块被附加到加密的字符串中。我们可以通过触发<code class="fe nz oa ob oc b">“end”</code>事件来检测加密何时完成。我们使用另一个事件<code class="fe nz oa ob oc b">“error”</code>来检测加密文本时抛出的错误。</p><h2 id="91a0" class="nn md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">用Node.js解密数据</h2><p id="d87b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了解密数据，我们使用加密模块的<code class="fe nz oa ob oc b">Decipher</code>类。它的实现方式类似于数据加密的实现方式。我们使用这个秘密创建一个新的加密密钥，然后开始用这个密钥解密<code class="fe nz oa ob oc b">cipher</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="090d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要解密密文，需要在<code class="fe nz oa ob oc b">encrypt</code>函数中传递用于加密数据的<code class="fe nz oa ob oc b">IV</code>。</p><h2 id="6a36" class="nn md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">使用Node.js散列</h2><p id="eb4a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">用crypto实现一个<code class="fe nz oa ob oc b">hash</code>函数非常简单。下面是我们创建的<code class="fe nz oa ob oc b">hash</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6eb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nz oa ob oc b">sha256</code>是我们在此实现中使用的哈希算法。使用这种算法，它可以很容易地用<code class="fe nz oa ob oc b">write</code>函数创建一个散列文本。当散列数据在流上可用时，它触发<code class="fe nz oa ob oc b">“readable”</code>事件，我们可以检索散列字符串。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce72" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="1a99" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在本文中，我们讨论了密码学和数据加密的基础知识。我们还使用Node.js内置的加密模块实现了加密操作。由于数据加密对于开发web应用程序至关重要，您可以直接应用我们今天学到的东西，在未来构建更安全可靠的应用程序。</p><p id="0b6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想了解更多关于Node的crypto模块支持的其他类型的加密操作，请阅读<a class="ae lu" href="https://nodejs.org/api/crypto.html" rel="noopener ugc nofollow" target="_blank"> Node的官方文档</a>。</p><p id="a00a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">密码学是一个广阔而迷人的研究领域。它提供了比我们在本文中讨论的更多的数据保护方法。作为一名web开发人员，您对这些方法了解得越多，就越有利于您构建更好的应用程序。所以不要停止学习加密和密码学技术。自己做研究，多学习。</p></div></div>    
</body>
</html>