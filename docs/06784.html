<html>
<head>
<title>Learn About Flutter Widgets by Making a Simple Weather App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过制作一个简单的天气应用程序来了解Flutter Widgets</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-about-flutter-widgets-by-making-a-simple-weather-app-46c8b9e9b24e?source=collection_archive---------4-----------------------#2020-11-04">https://betterprogramming.pub/learn-about-flutter-widgets-by-making-a-simple-weather-app-46c8b9e9b24e?source=collection_archive---------4-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="39d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有什么比边做边学更好的？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3e205178d28554c06f23585fba3fe0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4YR7OV2UGjJUYBDi.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个非常简单的应用程序，有一个非常漂亮的用户界面(图片来源:<a class="ae kv" href="https://dribbble.com/YegorShustov" rel="noopener ugc nofollow" target="_blank">叶戈尔·舒斯托夫</a></p></figure><p id="486b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有什么比通过实施来学习更好的了。通过使用我们正在学习的东西做一些小的辅助项目，我们不仅可以增加我们在该领域的信心，还可以提高我们的技能水平。</p><p id="6c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些天我在<a class="ae kv" href="https://www.udemy.com/course/flutter-bootcamp-with-dart/" rel="noopener ugc nofollow" target="_blank">安吉拉·于博士的颤振发展训练营</a>学习颤振，我可以向你保证<a class="ae kv" href="https://flutter.dev/docs" rel="noopener ugc nofollow" target="_blank">颤振</a>有一个非常平滑的学习曲线。作为一名过去三年的web开发人员，我觉得从web技术过渡到Flutter真的很容易，所以如果你以前有任何其他技术的经验，或者即使你是一个完全的初学者，Flutter也很适合你。</p><p id="f8e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我非常兴奋能和你一起开发这个应用。</p><p id="4301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我在开始时所说的，每当你学习一项新技术时，动手实践是必不可少的。否则，你可能会感到缺乏自信。</p><p id="3a23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是人们通常会问我，“嘿，马达夫，是的，我知道建造东西很重要，但是我要建造什么呢？我没有任何app想法，也不是设计师。我该怎么做呢？”</p><p id="52fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我来帮你。无论何时，当您在处理任何前端技术时，您都可以遵循这个简单的技巧:</p><ul class=""><li id="02ff" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">第一步。想想任何一个应用程序的想法(比如我们的天气应用程序)</li><li id="5716" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">第二步。转到<a class="ae kv" href="https://dribbble.com/" rel="noopener ugc nofollow" target="_blank"> dribbble </a></li><li id="49c7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">第三步。搜索该应用的用户界面设计</li><li id="44b1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">第四步。将这些设计付诸实践</li></ul><p id="1bf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，你就可以用很酷的用户界面构建令人惊叹的应用程序，并以更高效的方式学习。</p><p id="5498" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但请确保您:</p><ol class=""><li id="216f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">不要在你的商业项目中使用别人的设计(这应该只是为了你个人的学习)</li><li id="5e91" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">给予设计者适当的肯定</li></ol></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="83ce" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">我们今天要建造什么？</h1><p id="0921" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我遵循了与上面讨论的完全相同的方法，并且我发现了一些非常酷的简单天气应用程序的设计。</p><p id="7918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢叶戈尔·舒斯托夫如此漂亮的设计。今天我们将从dribbble实现他的设计:<a class="ae kv" href="https://dribbble.com/shots/6887377-Weather-Cards" rel="noopener ugc nofollow" target="_blank">天气卡</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3e205178d28554c06f23585fba3fe0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4YR7OV2UGjJUYBDi.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个非常简单的应用程序，有非常漂亮的用户界面</p></figure><p id="5396" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，你想象的没错，app的流程会很简单。一旦用户打开应用程序，我们将在后台加载用户的当前位置，我们将使用该位置获取当前天气并显示在屏幕上。(背景和图标将基于天气条件。)</p><p id="2a51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果想直接看代码，可以看看我的<a class="ae kv" href="https://github.com/MadhavBahl/Flutter-Simple-Weather" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><p id="4d31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们也来看看应用程序的运行情况。这是我们的应用程序实现后的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/89ca90a39f216c9d8a768c4c10bcbd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*dg_fJf4fcl1xsM9Vrf-pmg.gif"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="67f1" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">一些先决条件</h1><p id="0c28" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在开始之前，这里是设置环境的三个先决步骤。(这个不会花太多时间。)</p><ol class=""><li id="be34" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated"><a class="ae kv" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank">下载并安装Android Studio </a></li><li id="a756" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated"><a class="ae kv" href="https://flutter.dev/docs/get-started/install" rel="noopener ugc nofollow" target="_blank">安装颤振SDK </a></li><li id="7161" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">在<a class="ae kv" href="https://openweathermap.org/api." rel="noopener ugc nofollow" target="_blank"> open weather map </a>上注册(获取API密匙)。</li></ol><p id="9432" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们准备采取一些行动。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="b13e" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">概观</h1><p id="828d" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们将逐步建立这个应用程序。以下是我们今天旅程中要采取的一些步骤。(跟我到最后。)</p><ol class=""><li id="b155" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">设置项目</li><li id="e03c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">创建加载程序</li><li id="19a2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">设置我们的主屏幕(静态设计)</li><li id="e78a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">添加位置逻辑</li><li id="5664" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">使用开放天气地图API获取天气数据</li><li id="daf9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">添加应用程序逻辑</li></ol><p id="b640" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这些简单的步骤中，我们今天会学到很多东西。我对此超级兴奋，所以让我们开始我们的旅程吧。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="22a7" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">第一步。设置项目</h1><p id="a086" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这可能是最简单的一步。你需要做的就是去Android Studio创建一个新的Flutter项目。之后，我们将下载这个项目所需的所有资产。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/a9cc2bdcb1c798b1691d888002ac7148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-cbF-NgOSfYSQ2pjAyVRog.gif"/></div></div></figure><p id="8542" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很简单。</p><ul class=""><li id="c559" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">打开Android Studio</li><li id="ff9d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">转到文件&gt;新建&gt;新建颤振项目</li><li id="8eb5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">选择Flutter应用程序并添加其他信息</li></ul><p id="aa80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你这样做了，Android Studio将为你的Flutter项目生成一些样板代码。</p><p id="bf88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们的源代码(我们将在其上工作)将出现在<code class="fe nn no np nq b">lib/</code>文件夹中，主入口点将是<code class="fe nn no np nq b">main.dart</code>中的<code class="fe nn no np nq b">main</code>函数。</p><p id="1578" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行该代码，它将如下所示(一个简单的计数器应用程序):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/e1671fe2ebd268ad4fa3c521e01e1984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EN3Kut7niNOJ3XZ4da05HQ.png"/></div></div></figure><p id="39b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在移除除main函数和一个空的<code class="fe nn no np nq b">MyApp</code>类之外的所有东西(直到<code class="fe nn no np nq b">MaterialApp</code>，第11行)。这样做之后，几乎所有预先写好的代码都将被删除，我们将从头开始。</p><p id="8f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，在<code class="fe nn no np nq b">MaterialApp</code>内提供一个空的<code class="fe nn no np nq b">Scaffold</code>，默认为黑色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/fafbe535bdeecc1246f47bacf0272fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rt8JVR1HKShT0iik2lXmRw.png"/></div></div></figure><p id="958b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这之后，我们的<code class="fe nn no np nq b">main.dart</code>将看起来有如下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ea8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍微解释一下代码，<code class="fe nn no np nq b">main</code>函数是我们运行<code class="fe nn no np nq b">MyApp</code>小部件的入口点。</p><p id="fec8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np nq b">MyApp</code>是一个无状态的小部件(也就是说，数据不是从<code class="fe nn no np nq b">MyApp</code>小部件直接存储/维护/更改的；我们将在各种子部件中这样做)。</p><p id="5be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，在我们完成第一步之前还有最后一件事:添加静态资产(图片)。一种方法是直接进入我找到设计的dribbble页面，从那里下载各种图片。</p><p id="ceab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让事情变得简单，我将这些图片添加到了一个压缩文件夹中。您可以从这里下载并提取资产:<a class="ae kv" href="https://github.com/MadhavBahl/Flutter-Simple-Weather/blob/master/assets.rar" rel="noopener ugc nofollow" target="_blank">github . com/MadhavBahl/Flutter-Simple-Weather/blob/master/assets . rar</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2c54350987cc6f6c0dcb8b34e4e2abc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*rzSS4JkTdrFOfH5Ht9WD7w.png"/></div></figure><p id="d956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将它们解压到你的项目的根目录下(和<code class="fe nn no np nq b">lib</code>目录在同一层)。资产文件夹将有三个图像-多云、晴朗和夜晚。</p><p id="c654" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在需要做的就是将这些资产添加到我们项目的<code class="fe nn no np nq b">pubspec.yaml</code>中。</p><p id="d69b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想知道<code class="fe nn no np nq b">pubspec.yaml</code>文件是什么，这里有一些信息给你—</p><blockquote class="nw nx ny"><p id="a1b7" class="kw kx nz ky b kz la jr lb lc ld ju le oa lg lh li ob lk ll lm oc lo lp lq lr ij bi translated">“每个发布包都需要一些元数据，这样它就可以指定它的依赖项。与其他人共享的Pub包也需要提供一些其他信息，以便用户可以发现它们。所有这些元数据都放在包的<em class="iq"> pubspec: </em>一个用<a class="ae kv" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>语言编写的名为<code class="fe nn no np nq b">pubspec.yaml</code>的文件中。”— <a class="ae kv" href="https://dart.dev/tools/pub/pubspec" rel="noopener ugc nofollow" target="_blank">灾难援助反应队文件</a></p></blockquote><p id="67de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你来自web开发背景，你可以把它想象成类似于<code class="fe nn no np nq b">package.json</code>文件的东西。</p><p id="5be9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在打开<code class="fe nn no np nq b">pubspec.yaml</code>文件，并添加以下内容:</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="f4e3" class="oh mp iq nq b gy oi oj l ok ol">assets:<br/>  - assets/</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/6e53e0dc70752b2b4ddbadf32790b70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Oi6n4m3IuUW4iecNkXNcEA.gif"/></div></div></figure><p id="ab05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的<code class="fe nn no np nq b">pubspec</code>中添加资产后，不要忘记<code class="fe nn no np nq b">pub get</code>。</p><p id="30de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样，我们完成了第一步。现在让我们继续前进。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="6804" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">第二步。添加加载屏幕</h1><p id="4242" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这个不符合dribbble的设计，但这是我们非常需要的东西。</p><p id="127f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为什么呢？为什么我们需要一个加载屏幕？有什么猜测吗？</p><p id="67d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单:获取位置数据和天气数据将是异步事件，这意味着它们不会立即提供数据；这需要一些时间。</p><p id="8fbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，对于“加载时间”，我们将使用这个微调器。让我们分三步快速完成这一步:</p><ol class=""><li id="7ded" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">为我们的加载屏幕创建一个新文件。</li><li id="60c8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">在其中创建一个有状态的小部件。(为什么有状态？有什么猜测吗？)</li><li id="3e41" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">为加载器/旋转器找到一个好的库。</li><li id="76f1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">整合装载机。</li></ol><p id="36a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相信我，这些步骤听起来很简单，所以让我们开始吧。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="08e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们为我们的屏幕创建一个单独的目录。我将把文件夹命名为<code class="fe nn no np nq b">screens</code>，但是你可以随意选择一个你喜欢的名字。</p><p id="385e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在该目录中，我将创建一个名为<code class="fe nn no np nq b">loading_screen.dart</code>的新Dart文件，并在其中添加新的有状态小部件。</p><p id="cb2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(注意，在我的构建方法中，我将返回一个新的<code class="fe nn no np nq b">Scaffold</code>实例，而不是<code class="fe nn no np nq b">Container</code>。)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/cb9b815a78c196278a44279b52d5a66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hYrzCT-3MGMtf0WouU8OHA.gif"/></div></div></figure><p id="ce56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到你的问题，为什么我们需要一个有状态的部件…</p><p id="2932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单:有状态小部件有各种生命周期方法，允许我们在小部件生命周期的不同部分运行不同的代码块。在我们的例子中，我们希望在应用程序启动时获取位置数据和天气数据(加载屏幕一呈现出来)。</p><p id="830b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了。现在我们已经为加载屏幕准备好了样板文件，让我们添加加载程序。但是等等——如果我们从头开始创建一个加载器，对于一个初级项目来说，这将意味着很多努力。所以让我们寻找一些可以帮助我们的图书馆。</p><p id="1460" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个秘密窍门:每当你需要任何图书馆的帮助时，就去<a class="ae kv" href="https://pub.dev/" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>网站，并尝试搜索它。出结果，查查哪个库人气分好。对你的项目来说，那个可能是个不错的选择。</p><p id="4420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我做了类似的搜索，发现<a class="ae kv" href="https://pub.dev/packages/flutter_spinkit" rel="noopener ugc nofollow" target="_blank"> flutter_spinkit </a>对于我们的用例来说是一个很好的选择，所以让我们试着使用它。</p><p id="f891" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要安装它，请查看安装步骤。通常，步骤很简单。你只需要在你的<code class="fe nn no np nq b">pubspec</code>文件中提到依赖关系，然后运行<code class="fe nn no np nq b">pub get</code>。(附:确保不要弄乱<code class="fe nn no np nq b">pubspec.yaml</code>文件的缩进)</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="0fd3" class="oh mp iq nq b gy oi oj l ok ol">dependencies:<br/>  flutter_spinkit: "^4.1.2"</span></pre><p id="4ef5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们将库导入到我们的加载屏幕中。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="2ca6" class="oh mp iq nq b gy oi oj l ok ol">import 'package:flutter_spinkit/flutter_spinkit.dart';</span></pre><p id="39b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将能够在我们的小部件中使用这个加载器。(我喜欢涟漪效应，所以我将使用这个。但是你可以自由选择你喜欢的。)</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="7961" class="oh mp iq nq b gy oi oj l ok ol">return Scaffold(<br/>  body: Container(<br/>    child: Center(<br/>      child: SpinKitRipple(<br/>        color: Colors.<em class="nz">white</em>,<br/>        size: 150.0,<br/>        duration: Duration(milliseconds: 1200),<br/>      ),<br/>    ),<br/>  ),<br/>);</span></pre><p id="b10d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，确保将<code class="fe nn no np nq b">main.dart</code>文件中的<code class="fe nn no np nq b">home</code>改为<code class="fe nn no np nq b">LoadingScreen()</code>而不是<code class="fe nn no np nq b">Scaffold()</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/2dc2542a223955110d4d49275ff257fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RdjxGIBzcpLiFUFMOvusDA.gif"/></div></div></figure><p id="931b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，它看起来很酷，但是让我们也添加一点背景装饰。在<code class="fe nn no np nq b">Container</code>里面，我们加上这个<code class="fe nn no np nq b">decoration</code>:</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="5485" class="oh mp iq nq b gy oi oj l ok ol">decoration: BoxDecoration(<br/>  gradient: LinearGradient(<br/>    begin: Alignment.<em class="nz">topLeft</em>,<br/>    end: Alignment.<em class="nz">bottomRight</em>,<br/>    colors: [Colors.<em class="nz">purple</em>, Colors.<em class="nz">blue</em>],<br/>  ),<br/>),</span></pre><p id="49f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢渐变背景，加上这些颜色与我们的主要应用程序主题相匹配，所以我添加了这些渐变。您可以随意添加您选择的装饰。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/e7a3dbd8b1f0ac57a0a236a372ca5758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1n6hCt3Q58nLvUQMiPxOLg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">看起来太棒了，不是吗？</p></figure><p id="3685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">酷，我们终于完成了第二步！</p><p id="16a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是目前为止我们的<code class="fe nn no np nq b">loading_screen.dart</code>和<code class="fe nn no np nq b">main.dart</code>的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">main.dart中的代码</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">加载屏幕的代码</p></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="9f44" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">第三步。设置主屏幕(静态设计)</h1><p id="8794" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">还记得在我们的第一步中，我们是如何将那些静态资产添加到<code class="fe nn no np nq b">pubspec</code>文件中的吗？现在我们要用这些。我希望你对这一页感到兴奋。(我超级激动！)</p><p id="57f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是等等——在继续之前，让我们整合一下图标。我们将在这个项目中使用<a class="ae kv" href="https://pub.dev/packages/font_awesome_flutter" rel="noopener ugc nofollow" target="_blank">字体很棒的图标</a>。要集成这个库，请转到您的<code class="fe nn no np nq b">pubspec.yaml</code>文件，并在依赖项下添加最新版本的font_awesome_flutter。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="9cc4" class="oh mp iq nq b gy oi oj l ok ol">font_awesome_flutter: ^8.4.0</span></pre><p id="042d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，像往常一样，<code class="fe nn no np nq b">pub get</code>。</p><p id="4d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们为我们的主屏幕创建另一个小部件——我称它为<code class="fe nn no np nq b">MainScreen </code> —在<code class="fe nn no np nq b">main_screen.dart</code>内(在<code class="fe nn no np nq b">screens</code>目录内)。</p><p id="ff86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们遵循通常的步骤。导入<code class="fe nn no np nq b">material.dart</code>并创建一个有状态的小部件。但是这一次，我们也需要导入字体awesome图标，所以在顶部添加这个import语句。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="3a25" class="oh mp iq nq b gy oi oj l ok ol">import 'package:font_awesome_flutter/font_awesome_flutter.dart';</span></pre><p id="11af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也将在我们的主屏幕上有一个类似的架构。build方法将返回一个<code class="fe nn no np nq b">Scaffold</code>，在其中我们将有一个全屏幕大小的<code class="fe nn no np nq b"> Container</code>和一个背景图像，而<code class="fe nn no np nq b">Containe</code> r的子对象将是一个<code class="fe nn no np nq b">Column</code>小部件。(想一想:为什么我们在这里需要一个列小部件？)下面是我们的<code class="fe nn no np nq b">main_screen.dart</code>代码的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="20c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要一个列小部件，因为根据设计，我们可以清楚地看到，图标和温度在列方向对齐。所以我们的图标和温度文本将是column小部件的子部件。(注意，我们使用一个<code class="fe nn no np nq b">SizedBox</code>小部件来创建距离/边距。记住，解决一个问题有很多方法，我们也可以使用<code class="fe nn no np nq b">Padding</code>。)</p><p id="96c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请注意容器内的盒子装饰。我用它来设置背景图像。我知道，我一气呵成地提到了很多东西，但是不用担心，代码相当简单明了，只要阅读就会很容易理解。尽管如此，如果你有任何疑问，欢迎在评论中问我。</p><p id="2ea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试我们的主屏幕，我们可以暂时从<code class="fe nn no np nq b">main.dart</code>中的<code class="fe nn no np nq b">home</code>属性中移除加载屏幕，并添加主屏幕:</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="7a1b" class="oh mp iq nq b gy oi oj l ok ol">class MyApp extends StatelessWidget {<br/>  // This widget is the root of your application.<br/>  <a class="ae kv" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      theme: ThemeData.dark(),<br/>      home: <strong class="nq ir">MainScreen</strong>(),<br/>    );<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/88854db77ae3da5529ba66579fb4a54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thCoiKIKSoL8zjov4yX4ZA.png"/></div></div></figure><p id="8fff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以撤销<code class="fe nn no np nq b">main.dart</code>中的更改，使加载屏幕成为主页，我们也完成了第三步。还剩三个。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="04cb" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">第四步。添加位置逻辑</h1><p id="7538" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">既然你已经知道如何在你的项目中包含Flutter库，那么这个将会非常简单。我们将使用<a class="ae kv" href="https://pub.dev/packages/location" rel="noopener ugc nofollow" target="_blank">位置库</a>。</p><p id="43bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，第一步是在<code class="fe nn no np nq b">pubspec.yaml</code>和<code class="fe nn no np nq b">pub get</code>中包含依赖关系。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="b67c" class="oh mp iq nq b gy oi oj l ok ol">location: ^3.0.0</span></pre><p id="9219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们创建一个新的类<code class="fe nn no np nq b">LocationHelper</code>来保存fetch和我们的位置数据。我将在<code class="fe nn no np nq b">utils</code>文件夹— <code class="fe nn no np nq b">location.dart</code>中这样做</p><p id="8d70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe nn no np nq b">location.dart</code>的代码。请注意，我已经从库的文档中的示例部分获取了大部分提取位置逻辑，这就是我们开始使用库的方式；).</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f337" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要从<code class="fe nn no np nq b">loading_screen.dart</code>调用这个获取位置逻辑，但是在此之前，你注意到我们在这里使用了一些新的关键字吗？</p><h2 id="2819" class="oh mp iq bd mq oq or dn mu os ot dp my lf ou ov na lj ow ox nc ln oy oz ne pa bi translated">异步和等待</h2><p id="9cc7" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">如果你熟悉用其他语言编程和进行API调用，你可以跳过这个，直接读代码。但是如果你是新来的，一定要读一读。</p><p id="be9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于 <code class="fe nn no np nq b"><a class="ae kv" href="https://dart.dev/codelabs/async-await" rel="noopener ugc nofollow" target="_blank">async</a></code> <a class="ae kv" href="https://dart.dev/codelabs/async-await" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe nn no np nq b"><a class="ae kv" href="https://dart.dev/codelabs/async-await" rel="noopener ugc nofollow" target="_blank">await</a></code> <a class="ae kv" href="https://dart.dev/codelabs/async-await" rel="noopener ugc nofollow" target="_blank">的一切你都可以</a><a class="ae kv" href="https://dart.dev/codelabs/async-await" rel="noopener ugc nofollow" target="_blank">在这里</a>阅读，但我会尽量总结出来供我们使用案例。</p><p id="81cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进行API调用不像做一些算术运算或任何其他同步逻辑那样简单。API的问题在于，我们知道何时进行调用，但不知道API获取结果的确切时间。</p><p id="4152" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当我们进行API调用时，我们没有得到具体的结果，我们得到的是一个类型为<code class="fe nn no np nq b">Future</code>的对象，这类似于一个承诺，即该对象在不久的将来会有一些值(如果API失败，它可能是一个错误消息，如果它通过，则是我们想要的数据)。</p><p id="aa84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们想让代码在进一步处理之前等待<code class="fe nn no np nq b">Future</code>对象获得一些具体数据时，我们就使用关键字<code class="fe nn no np nq b">await</code>。</p><p id="7b06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等待<code class="fe nn no np nq b">Future</code>数据(或使用<code class="fe nn no np nq b">await</code>)的每个方法/函数必须是一个<code class="fe nn no np nq b">async</code>方法。下面是一个简单的例子:</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="9004" class="oh mp iq nq b gy oi oj l ok ol">void getWeather() <strong class="nq ir">async </strong>{<br/>  weather = <strong class="nq ir">await</strong> makeApiCallForWeather();<br/>  ... do something else ...<br/>}</span></pre><p id="b937" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望现在清楚了。让我们继续编码部分，并在加载屏幕中添加获取位置逻辑。</p><h2 id="6621" class="oh mp iq bd mq oq or dn mu os ot dp my lf ou ov na lj ow ox nc ln oy oz ne pa bi translated">当应用程序加载时获取幕后位置</h2><p id="1e75" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在加载界面中，让我们添加一个对象<code class="fe nn no np nq b">LocationHelper</code>，并用它来获取新方法<code class="fe nn no np nq b">getLocationData()</code>中的位置。</p><p id="e8a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，为了测试它，让我们使用有状态小部件中可用的<code class="fe nn no np nq b">initState</code>方法来调用<code class="fe nn no np nq b">getLocationData</code>。注意，对于任何有状态的小部件，每当我们将小部件呈现到屏幕上时，<code class="fe nn no np nq b">initState</code>就会被触发。(BTW，别忘了导入位置助手类。)</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="601a" class="oh mp iq nq b gy oi oj l ok ol">LocationHelper locationData;</span><span id="e3b4" class="oh mp iq nq b gy pb oj l ok ol">Future&lt;void&gt; getLocationData() async {<br/>  locationData = LocationHelper();<br/>  await locationData.getCurrentLocation();</span><span id="66d8" class="oh mp iq nq b gy pb oj l ok ol">  if (locationData.latitude == null || locationData.longitude == null) {<br/>    // todo: Handle no location<br/>  }</span><span id="2a64" class="oh mp iq nq b gy pb oj l ok ol">  print(locationData.longitude);<br/>  print(locationData.latitude);<br/>}</span><span id="65f5" class="oh mp iq nq b gy pb oj l ok ol">@override<br/>void initState() {<br/>  // TODO: implement initState<br/>  super.initState();<br/>  getLocationData();<br/>}</span></pre><p id="23e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇，那很简单。让我们检查一下，是的，应用程序现在要求位置权限。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/1d3bcdaeb510f41c2dcf39d93104dcaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIBG8XQ6ZqgRiI-hACbSFQ.png"/></div></div></figure><p id="7b6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查控制台:它现在也打印您的位置，因为我们在<code class="fe nn no np nq b">getLocationData</code>方法中添加了打印语句。</p><p id="5d8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是目前为止<code class="fe nn no np nq b">loading_screen.dart</code>的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2e0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们也完成了第四步，接下来是第五步。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="9ade" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">第五步。使用开放天气地图API获取天气数据</h1><p id="6764" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">如上所述，我们将使用<a class="ae kv" href="https://openweathermap.org/api" rel="noopener ugc nofollow" target="_blank"> open weather map API </a>来获取天气数据，因此在继续之前，在他们的网站上创建一个帐户，以便您可以获得API密钥。</p><p id="4818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将用来获取天气数据的端点是这样的:</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="51eb" class="oh mp iq nq b gy oi oj l ok ol">api.openweathermap.org/data/2.5/weather?lat={lat}&amp;lon={lon}&amp;appid={API key}&amp;units=metric</span></pre><p id="98bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道这篇文章太长了，但是请原谅我，现在已经快结束了。我们将在<code class="fe nn no np nq b">utils</code>文件夹中创建另一个目录，它将包含我们所有的天气逻辑。如果您对目录结构感到困惑，您可以随时查看我的存储库。</p><p id="e990" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进行API调用，我们将使用<a class="ae kv" href="https://pub.dev/packages/http" rel="noopener ugc nofollow" target="_blank"/><code class="fe nn no np nq b"><a class="ae kv" href="https://pub.dev/packages/http" rel="noopener ugc nofollow" target="_blank">http</a></code><a class="ae kv" href="https://pub.dev/packages/http" rel="noopener ugc nofollow" target="_blank">库。</a>你知道步骤:添加依赖项和<code class="fe nn no np nq b">pub get</code>。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="1e6c" class="oh mp iq nq b gy oi oj l ok ol">http: ^0.12.2</span></pre><p id="7f74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这里是包含我们的<code class="fe nn no np nq b">WeatherData</code>类的<code class="fe nn no np nq b">weather.dart</code>文件的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="be26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有两件重要的事情:</p><ul class=""><li id="789b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在<code class="fe nn no np nq b">apiKey</code>常量中添加您自己的API键。</li><li id="ac34" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">读一遍代码，你就会明白我们得到的是JSON形式的结果。我们使用<code class="fe nn no np nq b">jsonDecode</code>反序列化它。</li></ul><p id="e31e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们在加载屏幕类中添加一个<code class="fe nn no np nq b">getWeatherData</code>方法。此外，一旦我们获取完数据，我们将用主屏幕替换当前屏幕，并传递天气数据。我们将使用Navigator来完成这项工作。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="c664" class="oh mp iq nq b gy oi oj l ok ol">void getWeatherData() async {<br/>  // Fetch the location<br/>  await getLocationData();</span><span id="3015" class="oh mp iq nq b gy pb oj l ok ol">  // Fetch the current weather<br/>  WeatherData weatherData = WeatherData(locationData: locationData);<br/>  await weatherData.getCurrentTemperature();</span><span id="6acb" class="oh mp iq nq b gy pb oj l ok ol">  if (weatherData.currentTemperature == null ||<br/>      weatherData.currentCondition == null) {<br/>    // todo: Handle no weather<br/>  }</span><span id="4c9f" class="oh mp iq nq b gy pb oj l ok ol">  Navigator.pushReplacement(<br/>    context,<br/>    MaterialPageRoute(<br/>      builder: (context) {<br/>        return MainScreen(<br/>          weatherData: weatherData,<br/>        );<br/>      },<br/>    ),<br/>  );<br/>}</span></pre><p id="48f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在我们的<code class="fe nn no np nq b">getWeatherData</code>方法中，我们首先等待<code class="fe nn no np nq b">getLocationData</code>获取位置数据。现在我们可以在<code class="fe nn no np nq b">initState</code>方法中调用<code class="fe nn no np nq b">getWeatherData</code>来代替对<code class="fe nn no np nq b">getLocationData</code>的调用。</p><p id="0060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是你会注意到，现在我们得到了一些错误。这是因为我们试图在<code class="fe nn no np nq b">MainScreen</code>类中传递天气数据，但是我们没有相应的构造函数。那么让我们好好修改一下<code class="fe nn no np nq b">MainScreen</code>类吧。</p><p id="69cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们也给我们的<code class="fe nn no np nq b">MainScreen</code>类添加一个天气数据对象。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="fa00" class="oh mp iq nq b gy oi oj l ok ol">class MainScreen extends StatefulWidget {<br/>  MainScreen({@required this.weatherData}); // constructor<br/><br/><strong class="nq ir">  final WeatherData weatherData;<br/></strong><br/>  @override<br/>  _MainScreenState createState() =&gt; _MainScreenState();<br/>}</span></pre><p id="e364" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可以看到我们的应用程序在后台加载位置和天气数据并显示加载屏幕，一旦数据加载完毕，它就会进入主屏幕。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/61562ac9fe57eb187a638e9c9cf62cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LkBF8k7BBtElomU-apCnYg.gif"/></div></div></figure><p id="a5e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<code class="fe nn no np nq b">_MainScreenState</code>是一个独立的类，那么我们如何访问字段<code class="fe nn no np nq b">weatherData</code>，它是<code class="fe nn no np nq b">_MainScreenState</code>中<code class="fe nn no np nq b">MainScreen</code>类的一部分？</p><p id="89c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单，我们可以通过<code class="fe nn no np nq b">widget.weatherData</code>访问。让我们在最后一步看一下。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="446c" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">第六步。总结应用程序逻辑</h1><p id="1d03" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们的应用程序几乎准备好了。我们现在需要做的就是添加主应用程序逻辑，以在主屏幕上显示正确的温度、背景和图标。</p><p id="a914" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我将在包含图标和背景图像(我们希望在主屏幕上显示的内容)的<code class="fe nn no np nq b">weather.dart</code>文件中再添加一个类。我将调用这个类<code class="fe nn no np nq b">WeatherDisplayData</code>。</p><p id="6fe8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将从<code class="fe nn no np nq b">WeatherData</code>类中的一个新方法返回一个对象<code class="fe nn no np nq b">WeatherDisplayData</code>，这样我们就可以直接使用这个显示数据来填充<code class="fe nn no np nq b">MainScreen</code>中的必填字段。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="f5c5" class="oh mp iq nq b gy oi oj l ok ol">class WeatherDisplayData {<br/>  Icon weatherIcon;<br/>  AssetImage weatherImage;<br/><br/>  WeatherDisplayData({@required this.weatherIcon, @required this.weatherImage});<br/>}</span></pre><p id="f7a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有<code class="fe nn no np nq b">WeatherData</code>类里面的方法<code class="fe nn no np nq b">getWeatherDisplayData</code>:</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="e86b" class="oh mp iq nq b gy oi oj l ok ol">WeatherDisplayData getWeatherDisplayData() {<br/>  if (currentCondition &lt; 600) {<br/>    return WeatherDisplayData(<br/>      weatherIcon: Icon(<br/>        FontAwesomeIcons.cloud,<br/>        size: 75.0,<br/>      ),<br/>      weatherImage: AssetImage('assets/cloud.png'),<br/>    );<br/>  } else {<br/>    var now = new DateTime.now();</span><span id="a2f1" class="oh mp iq nq b gy pb oj l ok ol">    if (now.hour &gt;= 15) {<br/>      return WeatherDisplayData(<br/>        weatherImage: AssetImage('assets/night.png'),<br/>        weatherIcon: Icon(<br/>          FontAwesomeIcons.moon,<br/>          size: 75.0,<br/>          color: Colors.white,<br/>        ),<br/>      );<br/>    } else {<br/>      return WeatherDisplayData(<br/>        weatherIcon: Icon(<br/>          FontAwesomeIcons.sun,<br/>          size: 75.0,<br/>          color: Colors.white,<br/>        ),<br/>        weatherImage: AssetImage('assets/sunny.png'),<br/>      );<br/>    }<br/>  }<br/>}</span></pre><p id="2964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">逻辑很简单。如果天气多云，我们显示多云的背景，与时间无关；否则，我们根据时间显示日/夜图像。</p><p id="a478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们最后的<code class="fe nn no np nq b">weather.dart</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f15f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在到了我们的最后一步，在我们的主屏幕中使用这个逻辑！</p><p id="69e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nn no np nq b">_MainScreenState</code>类中，让我们添加三个属性，用于在屏幕上显示所需的信息。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="4db4" class="oh mp iq nq b gy oi oj l ok ol">int temperature;<br/>Icon weatherDisplayIcon;<br/>AssetImage backgroundImage;</span></pre><p id="eb32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个新函数<code class="fe nn no np nq b">updateDisplayInfo</code>，它接受<code class="fe nn no np nq b">weatherData</code>对象并填充上述字段。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="2847" class="oh mp iq nq b gy oi oj l ok ol">void updateDisplayInfo(WeatherData weatherData) {<br/>  setState(() {<br/>    temperature = weatherData.currentTemperature.round();<br/>    WeatherDisplayData weatherDisplayData =<br/>        weatherData.getWeatherDisplayData();<br/>    backgroundImage = weatherDisplayData.weatherImage;<br/>    weatherDisplayIcon = weatherDisplayData.weatherIcon;<br/>  });<br/>}</span></pre><p id="5b0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这里我们使用了<code class="fe nn no np nq b">setState</code>函数。(用来改变我们app的状态。简而言之，<em class="nz">状态</em>是任何必须在屏幕上显示的数据，并且可以随时间变化。)</p><p id="219e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np nq b">setState</code>只能在有状态的小部件中使用。通过将我们的逻辑封装在<code class="fe nn no np nq b">setState</code>中，我们为它提供了未来改进的灵活性。假设我想更新我的位置。在这种情况下，我们可以从其他地方传递新的<code class="fe nn no np nq b">weatherData</code>(可能)，它会更新值。</p><p id="fe0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步:让我们从我们的<code class="fe nn no np nq b">initState</code>方法中调用这个<code class="fe nn no np nq b">updateDisplayInfo</code>方法，这样一旦呈现了<code class="fe nn no np nq b">MainScreen</code>小部件，我们就可以获取从加载屏幕传来的<code class="fe nn no np nq b">weatherData</code>并更新值。</p><pre class="kg kh ki kj gt od nq oe of aw og bi"><span id="413e" class="oh mp iq nq b gy oi oj l ok ol">@override<br/>void initState() {<br/>  super.initState();<br/>  updateDisplayInfo(widget.weatherData);<br/>}</span></pre><p id="2c7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以使用这些变量<code class="fe nn no np nq b">temperature</code>、<code class="fe nn no np nq b">weatherDisplayIcon</code>和<code class="fe nn no np nq b">backgroundImage</code>来呈现我们的数据，而不是我们正在呈现的静态数据。</p><p id="7d39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最终的<code class="fe nn no np nq b">MainScreen</code>代码看起来会像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6853" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样，我们在Flutter中做了一个简单的天气应用！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/89ca90a39f216c9d8a768c4c10bcbd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*dg_fJf4fcl1xsM9Vrf-pmg.gif"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="4028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章。Flutter真的很神奇。请让我知道我是否能帮你开始，如果你打算做一些更有趣的项目。</p><p id="3c48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想讨论什么，请随时联系我。</p><p id="c02c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>