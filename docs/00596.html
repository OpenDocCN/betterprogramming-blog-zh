<html>
<head>
<title>Learning the Basics of Core Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习核心数据的基础知识</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/core-data-basics-swift-persistent-storage-ba3185fe7061?source=collection_archive---------2-----------------------#2019-06-17">https://betterprogramming.pub/core-data-basics-swift-persistent-storage-ba3185fe7061?source=collection_archive---------2-----------------------#2019-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d825" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速持久存储</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/54c34e8d6f821b3c45e73970b269181a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFyooXiEOK9YaFRRO_eN4g.png"/></div></div></figure><h1 id="e2c0" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">入门指南</h1><p id="b65d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">核心数据是Swift中持久数据的一个很好的选择，但一些人发现在他们的应用程序中使用它的障碍太高了。在这一部分中，我们将研究核心数据栈的主要组成部分，将它们分解开来，并努力使它们的使用对第一次使用的用户来说是容易理解的。</p><h2 id="c04f" class="mi kv it bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated"><strong class="ak">关键词</strong></h2><ul class=""><li id="d61d" class="mu mv it lo b lp lq ls lt lv mw lz mx md my mh mz na nb nc bi translated">核心数据:允许您管理应用程序中的模型层对象的框架。核心数据通过作为对象图管理和持久性框架来实现这一点。</li><li id="c06d" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">过滤:读取数据并删除不需要的数据的系统。</li><li id="b606" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">对象图:对象系统在任何特定时间点的视图。</li><li id="02b4" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">对象图管理:核心数据处理已定义的对象，核心数据跟踪这些对象以及它们之间的关系。</li><li id="6171" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">持久性:在这种情况下，可以从设备或网络位置检索数据。</li><li id="fdb8" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">SQLite:核心数据可以使用的潜在数据存储之一。</li></ul><h2 id="910e" class="mi kv it bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated"><strong class="ak">深入核心数据术语</strong></h2><ul class=""><li id="1240" class="mu mv it lo b lp lq ls lt lv mw lz mx md my mh mz na nb nc bi translated">属性:类似于数据库中表的列。这些存储核心数据记录的值。这些属性包括字符串、日期、整数、浮点数和布尔值。下骆驼案。</li><li id="521d" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">NSEntityDescription (Entity):类似于数据库中的表，但是允许我们访问关于实体的所有可用信息。NSEntityDescription的实例，提供对属性的访问，如名称、定义实体的数据模型以及定义实体的类名。上骆驼案。</li><li id="d1bd" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">NSFetchRequest:表示从持久性存储中检索数据的搜索条件的描述。要使用NSFetchRequest，您需要创建一个请求，该请求需要一个实体名称，以便知道要搜索哪个实体(或实体描述/或NSEntityDescription的实例)。</li><li id="bcc3" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">NSPersistentContainer:从iOS10开始，这使得设置核心数据变得更加容易，隐藏了持久性存储如何配置的实现细节。充当托管对象模型和持久性存储之间的桥梁。通过隐藏实现细节，NSManagedObjectContext不需要知道正在使用哪种持久性存储类型，并且可以通过单个统一接口管理多个持久性存储。只需初始化一个NSPersistentContainer，加载持久性存储，就可以开始了！</li><li id="d4e6" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">NSPersistantStore:读取数据并将其写入后备存储。核心数据允许后备存储是SQLite、二进制、XML和内存中。(虽然iOS上没有XML)。</li><li id="1e1c" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">NSPersistentStoreCoordinator:协调器用于将对象图保存到持久存储中，并检索模型信息。上下文访问模型的唯一方式是通过协调器，提供对底层对象存储的访问。这允许您从应用商店保存和获取应用类型的实例。</li><li id="1cab" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">NSManagedObject:ns object的子类，实现核心数据模型对象所需的行为。它并不总是需要子类NSManagedObject，它们可以直接使用。</li><li id="42dc" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">NSManagedObjectContext(托管对象上下文):我们可以在内存中创建、读取、更新和删除(CRUD)核心数据对象，然后再将它们写回数据库。实际上，它跟踪应用程序类型实例的变化，并作为托管对象的内存版本工作，直到在上下文中调用save。对象上下文还管理其对象的生命周期，并且每个对象必须存在于一个上下文中，并且在其生命周期的持续时间内保持关联，尽管应用程序可以使用多个上下文，并且实际上相同的代码数据对象可以同时加载到两个不同的上下文中。<strong class="lo iu"> </strong>通过设置多个管理对象上下文，可以运行并发操作，并使长时间运行的操作远离主线程<strong class="lo iu">。</strong>上下文不是线程安全的，托管对象也不是，这意味着您只能在创建上下文和托管对象的同一线程上与它们进行交互。</li><li id="92b3" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">NSManagedObjectModel:通常使用数据建模工具创建模型。描述应用程序的类型，包括属性和关系。这意味着如果核心数据栈在幕后使用SQLite，这个模型将代表数据库的模式。</li><li id="cb5b" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">Relationship:这些属性存储对核心数据记录的引用。每种关系都有目的地，许多是相反的关系(一个老师有许多学生，每个学生有那个老师)。下骆驼案。</li><li id="728e" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">xcdatamodel文件:由Xcode中的可视化编辑器编辑。将模型编译成momd文件夹中的一组文件。核心数据使用momd文件夹的编译内容在运行时初始化NSManagedObjectModel。</li></ul><h2 id="3969" class="mi kv it bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated"><strong class="ak">快速笔记</strong></h2><p id="f58a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">您保存的是上下文，而不是对象本身。这是有意义的，因为这是保存托管对象的环境。</p><h2 id="f038" class="mi kv it bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated"><strong class="ak">为什么要使用核心数据？</strong></h2><ul class=""><li id="ce60" class="mu mv it lo b lp lq ls lt lv mw lz mx md my mh mz na nb nc bi translated">可以通过将NSPredicate对象与fetch请求相关联来形成复杂的查询，而不是编写SQL</li><li id="2557" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">更改跟踪</li><li id="c127" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">对象的延迟加载</li><li id="6534" class="mu mv it lo b lp nd ls ne lv nf lz ng md nh mh mz na nb nc bi translated">预建的特性不需要在你的应用中测试</li></ul><h2 id="c994" class="mi kv it bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated"><strong class="ak"> xcdatamodeld </strong></h2><p id="a348" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用coredata时，会创建一个xcdatamodeld文件，这是核心数据模型的源文件。</p><p id="ab7a" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">在其中，您可以添加属性、关系和获取的属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/762301459b64e616f4c96a3cab040af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*XPWti1duVI-hsLka_ry7TA.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">核心数据模型的简单属性</p></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="2ec5" class="ku kv it bd kw kx nz kz la lb oa ld le jz ob ka lg kc oc kd li kf od kg lk ll bi translated"><strong class="ak">存储模型对象</strong></h1><h2 id="adea" class="mi kv it bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated"><strong class="ak"> NSManagedObject上下文</strong></h2><p id="075c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在使用核心数据存储之前，需要确定上下文。每个托管对象实例都存在于特定的上下文中，使其对于特定的上下文是唯一的。您可以使用多个托管对象上下文来简化新项目的添加，并避免阻塞UI。</p><h2 id="6293" class="mi kv it bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated"><strong class="ak"> NSManagedObject </strong></h2><p id="b4f8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">NSManagedObject是一个实现代码数据模型对象行为的类。您可以只在对象图中使用NSManagedObjects，也可以创建NSManagedObjects的子类。我们可以把NSManagedObjects想象成一本字典。</p><p id="659d" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">您可以使用<code class="fe oe of og oh b">value(forKeyPath keyPath: String) -&gt; Any?</code>返回给定关键路径的值。</p><p id="6e2a" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">NSManagedObject不能直接访问属性，所以这种键值编码的方法允许我们访问属性。</p><h2 id="c612" class="mi kv it bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated"><strong class="ak">断层</strong></h2><p id="b6b6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有时，托管对象尚未从数据存储中加载。在这种情况下，将触发故障并检索数据。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="2679" class="ku kv it bd kw kx nz kz la lb oa ld le jz ob ka lg kc oc kd li kf od kg lk ll bi translated">创建一个简单的待办应用</h1><ol class=""><li id="7b54" class="mu mv it lo b lp lq ls lt lv mw lz mx md my mh oi na nb nc bi translated"><strong class="lo iu">创建实体</strong></li></ol><p id="0481" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">很明显，您需要创建一个单视图应用程序。但是，重要的是，您勾选了设置为核心数据的框，以创建必要的文件(但是，在本例中，我们不会使用App delegate中添加的代码)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/aab1c16e3ee8dd7d8b936aa0e1068f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*u0UQQLlABQ2z5Tb924awHg.png"/></div></figure><p id="2f5f" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">这允许我们在xcdatamodelId文件中设置一个简单的任务实体:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/8bd6b4af88f7941afbad246b7eb4e74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*9-LTo7REgGOV0JoIjhn8rQ.png"/></div></figure><p id="72a8" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">如果任务完成，<code class="fe oe of og oh b">Where completed</code>为布尔值，<code class="fe oe of og oh b">task</code>为任务的名称。</p><p id="2d09" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated"><strong class="lo iu"> 2。设置对象上下文和实体</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="d0ef" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">在哪里</p><p id="7ee0" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated"><code class="fe oe of og oh b">appDelegate = UIApplication.shared.delegate <strong class="lo iu">as</strong>? AppDelegate</code></p><p id="d6b2" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">和</p><p id="0705" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated"><code class="fe oe of og oh b">Constants.entityName = “TaskEntity”</code></p><p id="803b" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated"><strong class="lo iu"> 3。设置表格视图</strong></p><p id="ce1d" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">核心数据允许我们使用NSManagedObject的数组，而不是使用字符串或结构和类的数组:</p><p id="cff6" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated"><code class="fe oe of og oh b">var tasks: [NSManagedObject] = []</code></p><p id="e237" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">然后可以将其用作UITableView的数据源，这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4f6f" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">虽然NSManagedObject实际上很像一个字典，意味着我们必须返回。单元格文本标签的值(forKeyPath:):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7e34" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated"><strong class="lo iu"> 4。保存</strong></p><p id="bff3" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">这个不太棘手，简单的取对象调用。之前的setValue。save()当然记得将项目添加到tableview:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">保存核心数据</p></figure><p id="1431" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated"><strong class="lo iu"> 5。正在加载</strong></p><p id="20db" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">这涉及到创建一个在viewWillAppear中调用的NSFetchRequest，以允许在显示视图时发出请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1990" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">NSFetchRequests访问现有数据并描述想要返回的数据。</p><p id="1e00" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">这是通过创建一个获取请求，然后添加一个可选的排序和可选的谓词来实现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="f4dc" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">然后使用托管对象上下文获取:</p><pre class="kj kk kl km gt on oh oo op aw oq bi"><span id="31bf" class="mi kv it oh b gy or os l ot ou">try managedContext.fetch(fetchRequest)</span></pre><p id="9776" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">6。删除</p><p id="a22f" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">这是一个相当简单的，删除一个特定的任务是可能执行的:</p><pre class="kj kk kl km gt on oh oo op aw oq bi"><span id="fca3" class="mi kv it oh b gy or os l ot ou">objectContext.delete(task)</span></pre></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="1df8" class="ku kv it bd kw kx nz kz la lb oa ld le jz ob ka lg kc oc kd li kf od kg lk ll bi translated"><strong class="ak">卷下</strong></h1><p id="7fb9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">核心数据当然有很多优点，也有自己的实现挑战。然而，它并不一定是它所声称的那种大野兽——而且肯定可以通过一些努力被驯服！</p><p id="5db1" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">当然，这里的大问题是核心数据的实现与视图控制器捆绑在一起，这使得几乎不可能进行测试。</p><p id="fa52" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">猜猜未来的媒体文章是关于什么的…</p><p id="b2d8" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated"><strong class="lo iu">想看完整的GitHub链接吗？</strong></p><div class="ov ow gp gr ox oy"><a href="https://github.com/stevencurtis/CoreDataToDo" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">stevencurtis/CoreDataToDo</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">与中级职位测试相关的核心数据。通过创建帐户为stevencurtis/CoreDataToDo开发做贡献…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div><p id="9086" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated"><strong class="lo iu">想取得联系？在Twitter上取得联系:</strong></p><div class="ov ow gp gr ox oy"><a href="https://twitter.com/stevenpcurtis" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">史蒂文·柯蒂斯(@stevenpcurtis) |推特</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">史蒂文·柯蒂斯的最新推文(@stevenpcurtis)。一边学习计算硕士，一边开发iOS应用程序…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">twitter.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ks oy"/></div></div></a></div></div></div>    
</body>
</html>