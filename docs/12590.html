<html>
<head>
<title>Rust as Part of a Microservice Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">铁锈是微服务架构的一部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-as-part-of-a-micro-service-architecture-25d600ecde0?source=collection_archive---------4-----------------------#2022-06-15">https://betterprogramming.pub/rust-as-part-of-a-micro-service-architecture-25d600ecde0?source=collection_archive---------4-----------------------#2022-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd33" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Rust +打字稿</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63397820e3b0a9b13700a6fefb298ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fttqmqpq6DKNX7nJlAGgPw.png"/></div></div></figure><p id="a073" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">早在一段时间前，我已经写过一篇关于如何在全栈web应用中使用Rust的小文章(参见<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/using-the-diesel-orm-for-a-web-app-with-rocket-90e610f6a6cf">这里</a>)。这篇文章旨在通过提供一种替代方法来将Rust包含到应用程序中，从而对此进行跟进。</p><p id="8adb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般来说，我们可能会说:</p><p id="0596" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Rust最明显的优势是解决CPU密集型任务的速度和非常高效的内存处理。后者不需要任何垃圾收集器。</p><p id="acf2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管这些特性很好，但它们也有一点缺点——它要求我们坚持非常严格的所有权模型。但是，并不总是有人认为这是一个缺点，因为坚持所有权模型会产生非常稳定和可维护的代码。</p><p id="7af8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，有时候开发速度是项目中的一个重要因素。特别是，希望将应用程序分成几个部分，并为每个部分使用最合适的语言。实现这个概念的一个解决方案是使用微服务架构，这正是我们在这个故事中要讨论的。</p><p id="b548" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解本文内容的先决条件是Rust和TypeScript的基础知识。两者都可以分别从<a class="ae lq" href="https://medium.com/@applied-math-coding/list/an-introduction-into-rust-22c99777c5e5" rel="noopener">这里</a>获得。<a class="ae lq" href="https://medium.com/@applied-math-coding/list/a-series-in-typescript-6e07e28de652" rel="noopener">此处</a>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="7016" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">总体目标</h1><p id="b863" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了有一个简单的例子，我们将实现三个微服务:</p><ol class=""><li id="ee2e" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">这提供了一个公共API并托管了一个小型的基于Vue的客户端。该语言是类型脚本，我们将使用非常流行的框架<a class="ae lq" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>。</li><li id="069e" class="mv mw it kw b kx ni la nj ld nk lh nl ll nm lp na nb nc nd bi translated"><code class="fe ne nf ng nh b">calc-engine</code>:这是一个Rust服务器，提供一些方法来完成一些CPU密集型的计算。</li><li id="ba2f" class="mv mw it kw b kx ni la nj ld nk lh nl ll nm lp na nb nc nd bi translated"><code class="fe ne nf ng nh b">rabbitmq</code>:它被认为是上述服务之间的消息代理，由<a class="ae lq" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>提供支持。</li></ol><p id="c6ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，所有这些都将部署在docker-compose中，使其易于共享。</p><p id="5fe2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下文中，我将只对实现的最基本部分进行描述，以提供尽可能愉快的阅读体验。完整的代码可以在这个<a class="ae lq" href="https://github.com/applied-math-coding/rust-node-rabbit" rel="noopener ugc nofollow" target="_blank">仓库</a>中查看，该仓库仅用于教育目的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1978" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">计算引擎(生锈)</h1><p id="3638" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这部分是一个典型的基于货物的二进制应用程序。依赖关系如下:</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="70a1" class="nr lz it nh b gy ns nt l nu nv"><strong class="nh iu">amiquip </strong>= { version = "0.4.2", default-features = false }<br/>serde_json = { version = "1.0.81" }<br/>rayon = { version = "1.5.3" }<br/>num_cpus = { version = "1.13.1" }<br/>dotenv = { version = "0.15.0" }</span></pre><p id="7c0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最重要的一个是<code class="fe ne nf ng nh b">amiquip</code>，它支持与RabbitMQ的通信。crate <code class="fe ne nf ng nh b">rayon</code>用于使应用程序使用尽可能多的并行计算。特别是，我们设置了一个线程池，如下所示:</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="17ed" class="nr lz it nh b gy ns nt l nu nv">fn setup_pool() -&gt; rayon::ThreadPool {<br/>    rayon::ThreadPoolBuilder::new()<br/>        .num_threads(num_cpus::get()) <br/>        .build()<br/>        .unwrap()<br/>}</span></pre><p id="ac56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于CPU密集型任务，并行运行的CPU数量不超过可用的CPU数量通常是有意义的。</p><p id="61bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到RabbitMQ的连接是这样获得的:</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="3f9a" class="nr lz it nh b gy ns nt l nu nv">fn setup_connection() -&gt; Connection {<br/>    if let Ok(c) = Connection::insecure_open(&amp;format!(<br/>        "amqp://{}:{}@{}:{}",<br/>        env::var("RABBITMQ_USER").unwrap(),<br/>        env::var("RABBITMQ_PWD").unwrap(),<br/>        env::var("RABBITMQ_HOST").unwrap(),<br/>        env::var("RABBITMQ_PORT").unwrap()<br/>    )) {<br/>        println!("Connected to rabbitmq!");<br/>        c<br/>    } else {<br/>        println!("Failed to connect to rabbitmq. Will retry in 2s.");<br/>        std::thread::sleep(std::time::Duration::from_secs(2));<br/>        setup_connection()<br/>    }<br/>}</span></pre><p id="6667" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了从<code class="fe ne nf ng nh b">.env</code>文件中获取某些值的传统方法之外，我们还通过每隔<code class="fe ne nf ng nh b">2s</code>重试来应对连接失败。这种方法特别适合微服务设置，因为每个涉及的服务都应该能够从其他服务的临时故障中恢复。</p><p id="0f77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为服务之间的通信方式，我们将使用<code class="fe ne nf ng nh b">RPC</code>(远程过程调用)。这并不总是最合适的，但在这里已经足够了。我们“繁重”的CPU任务将是计算河内<a class="ae lq" href="https://applied-math-coding.medium.com/solving-the-tower-of-hanoi-in-rust-243e00e6ac34" rel="noopener">塔</a>的求解步骤。这将在下面解释命名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ed73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里做的第一件事是确保RabbitMQ上存在名为<code class="fe ne nf ng nh b">hanoi</code>的队列。这是通过打开<code class="fe ne nf ng nh b">connection</code>上的<code class="fe ne nf ng nh b">channel</code>，然后声明<code class="fe ne nf ng nh b">queue</code>来完成的。</p><p id="a94e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个<code class="fe ne nf ng nh b">queue</code>被用作跨服务的消息生产/消费。我们可以通过调用<code class="fe ne nf ng nh b">queue.receiver()</code>来监听放在<code class="fe ne nf ng nh b">queue</code>上的消息。这类似于监听Rust的内部<a class="ae lq" href="https://applied-math-coding.medium.com/an-introduction-into-rust-part-14-multi-threading-7bbac4cb0e2f" rel="noopener">通道</a>并确保代码块中的代码一条消息一条消息地运行。</p><p id="39a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个新的<code class="fe ne nf ng nh b">message</code>必须与其类型匹配，原则上是<code class="fe ne nf ng nh b">ConsumerMessage::Delivery</code>或我们在<code class="fe ne nf ng nh b">other</code>中共同处理的一些连接错误。除了<code class="fe ne nf ng nh b">body</code>之外，该消息还有另外两个字段，即<code class="fe ne nf ng nh b">reply_to</code>和<code class="fe ne nf ng nh b">correlation_id</code>。<code class="fe ne nf ng nh b">body</code>表示实际内容(这里是河内游戏中元素的数量)，<code class="fe ne nf ng nh b">reply_to</code>是用于发回结果的“独占”队列，<code class="fe ne nf ng nh b">correlation_id</code>用于匹配请求和响应。</p><p id="c592" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，向<code class="fe ne nf ng nh b">hanoi</code>队列发送消息的客户端会附加一个惟一的<code class="fe ne nf ng nh b">correlation_id</code>,使其能够在以后选择由服务器写入<code class="fe ne nf ng nh b">reply_to</code>队列的结果。为了并行处理尽可能多的CPU任务，我们将当前请求放在线程池的一个闭包中。每个这样的闭包都包含通过<code class="fe ne nf ng nh b">reply_to</code>队列发回结果的逻辑。</p><p id="e77f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">发送是通过使用<code class="fe ne nf ng nh b">channel_for_msg</code>通道的<code class="fe ne nf ng nh b">Exchange::direct</code>实例来完成的。<code class="fe ne nf ng nh b">other</code>的处理方式是每隔<code class="fe ne nf ng nh b">2s</code>重新尝试建立这个监听器构造。同样，这使得我们的服务不受连接失败或RabbitMQ重启的影响。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="7ecc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">主服务器(类型脚本)</h1><p id="fcf5" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">首先，主服务器提供了一个公共API，让客户端请求Hanoi游戏的求解步骤:</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="4793" class="nr lz it nh b gy ns nt l nu nv"><a class="ae lq" href="http://twitter.com/Get" rel="noopener ugc nofollow" target="_blank">@Get</a>('/hanoi')<br/>getHello(<a class="ae lq" href="http://twitter.com/Query" rel="noopener ugc nofollow" target="_blank">@Query</a>('n', ParseIntPipe) n: number): Promise&lt;string&gt; {<br/>  ...<br/>  return this.appService.makeHanoi(n);<br/>}</span></pre><p id="b3ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你从未接触过NestJS，没问题，这是学习web框架最简单的方法，在这个简单易懂的<a class="ae lq" href="https://docs.nestjs.com/first-steps" rel="noopener ugc nofollow" target="_blank">概述</a>中介绍了它的基本概念。</p><p id="2347" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，端点正在委托一个方法<code class="fe ne nf ng nh b">makeHanoi</code>，该方法最终在方法<code class="fe ne nf ng nh b">MessageService.sendMessage</code>处结束。该服务包含连接到RabbitMQ的逻辑，但现在是从主服务器端连接:</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="838a" class="nr lz it nh b gy ns nt l nu nv">async <strong class="nh iu">sendMessage</strong>(n: number): Promise&lt;string&gt; {<br/>        const <strong class="nh iu">channel </strong>= await this.ensureChannel();<br/>        const <strong class="nh iu">replyTo </strong>= await this.ensureResponseQueue(channel);<br/>        const <strong class="nh iu">correlationId </strong>= this.generateUuid();<br/>        channel.sendToQueue(<br/>            this.HANOI_QUEUE,<br/>            Buffer.from(`${n}`),<br/>            {<br/>                correlationId,<br/>                replyTo<br/>            });<br/>        return lastValueFrom(<br/>            this.queueResponse.pipe(<br/>                filter(<br/>                  m =&gt; m?.properties.correlationId === correlationId<br/>                ),<br/>                first(),<br/>                map(m =&gt; m.content.toString())<br/>            )<br/>        );<br/>}</span></pre><p id="b944" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里您可以识别所有以前预约的消息参数，即<code class="fe ne nf ng nh b">replyTo</code>和<code class="fe ne nf ng nh b">correlationId</code>。因为我们在生产者端，所以这些值在生产者端产生，并附加到发送到<code class="fe ne nf ng nh b">hanoi</code>队列的消息上。</p><p id="7515" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在发送到<code class="fe ne nf ng nh b">hanoi</code>队列后，我们在队列上注册了一个一次性监听器，用作<code class="fe ne nf ng nh b">replyTo</code>。更详细地说，这个后面的队列在内部被使用，以向下面的<code class="fe ne nf ng nh b">BehaviorSubject</code>发出值:</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="4584" class="nr lz it nh b gy ns nt l nu nv">private queueResponse = new BehaviorSubject&lt;Message&gt;(null);</span></pre><p id="727a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，上面的代码在第一个匹配的<code class="fe ne nf ng nh b">correlationId</code>上注册了一个订阅，并通过使用操作符<code class="fe ne nf ng nh b">lastValueFrom</code>将其转换为<code class="fe ne nf ng nh b">Promise</code>。</p><p id="e4e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你从未见过这样的东西，这是基于流行的反应库<a class="ae lq" href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank"> rxjs </a>。</p><p id="b7fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在不涉及所有细节的情况下，让我们简短地看一下<code class="fe ne nf ng nh b">ensureChannel</code>的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a97f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，这段代码的核心部分很简单:<code class="fe ne nf ng nh b">connect(...)</code>建立一个<code class="fe ne nf ng nh b">connection</code>到RabbitMQ，<code class="fe ne nf ng nh b">connection.createChannel</code>使用这个连接创建一个<code class="fe ne nf ng nh b">channel</code>断言队列<code class="fe ne nf ng nh b">hanoi</code>存在。</p><p id="37a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">围绕这个方法的所有混乱都是必要的，以确保这个方法在其运行的异步上下文中正确工作。建立的<code class="fe ne nf ng nh b">channel</code>存储在本地字段中，不必在每次发送消息时重新创建。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c0e6" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">客户</h1><p id="3029" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">此外，主服务器还托管一个由<a class="ae lq" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>支持的小型客户端应用程序。如果您对它的实现感兴趣，您可以在前面提到的<a class="ae lq" href="https://github.com/applied-math-coding/rust-node-rabbit" rel="noopener ugc nofollow" target="_blank">库</a>中找到所有代码。它的目的是提供以下简单的用户界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/35acf73b56364d68e0ea5577f48f5485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*epjNwbo3z8LgJk_9sf2rCA.png"/></div></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="71a8" class="nr lz it bd ma nz oa dn me ob oc dp mi ld od oe mk lh of og mm ll oh oi mo oj bi translated">docker-撰写:</h2><p id="3f13" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">所有上述组件被构建并一起放在一个<a class="ae lq" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> docker-compose </a>容器中。以下是对应<code class="fe ne nf ng nh b">docker-compose.yml</code>的内容:</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="d5bd" class="nr lz it nh b gy ns nt l nu nv">version: "3"<br/>services:<br/>  <strong class="nh iu">main-server</strong>:<br/>    build: ./main-server<br/>    env_file: .env<br/>    environment:<br/>      - RABBITMQ_HOST=rabbitmq<br/>    ports:<br/>      - "3000:3000"</span><span id="9722" class="nr lz it nh b gy ok nt l nu nv"><strong class="nh iu">calc-engine</strong>:<br/>    build: ./calc-engine<br/>    env_file: .env<br/>    environment:<br/>      - RABBITMQ_HOST=rabbitmq</span><span id="88c7" class="nr lz it nh b gy ok nt l nu nv"><strong class="nh iu">rabbitmq</strong>:<br/>    image: rabbitmq:3-management</span></pre><p id="7fbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您克隆了存储库并在系统上安装了docker，那么您可以通过从位于存储库根文件夹中的终端发出以下命令来运行代码:</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="9b05" class="nr lz it nh b gy ns nt l nu nv">&gt; docker-compose up</span></pre><p id="d264" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，您可以将浏览器指向<code class="fe ne nf ng nh b"><a class="ae lq" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code>来“享受”上面的UI。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9c07" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="355b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这并不是将一个应用程序的不同部分分成几个编译单元的唯一方法。在Node.js的上下文中，一个非常有前途的方法是使用<a class="ae lq" href="https://napi.rs/" rel="noopener ugc nofollow" target="_blank"> NAPI-RS </a>。</p><p id="9559" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这避免了消息的开销，你可以在这里阅读更多关于这个<a class="ae lq" href="https://applied-math-coding.medium.com/using-rust-from-within-node-js-or-extending-node-js-via-n-api-using-napi-rs-e022c1753cb5" rel="noopener">的内容。另一方面，通过将不同的部分放入独立的服务器(微服务器？)您将获得与众不同的可扩展性。因此，在集群中运行时，每个部分都可以根据需要进行扩展或完成。</a></p><p id="cb06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div></div>    
</body>
</html>