<html>
<head>
<title>Better iOS App Performance Using Swift’s Concurrency Task Groups</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift的并发任务组提高iOS应用性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploiting-multiple-cores-using-concurrency-and-task-groups-in-swift-cfd66b5faf57?source=collection_archive---------5-----------------------#2022-03-25">https://betterprogramming.pub/exploiting-multiple-cores-using-concurrency-and-task-groups-in-swift-cfd66b5faf57?source=collection_archive---------5-----------------------#2022-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3daa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何利用并发的力量大幅提高iOS应用的性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ff037ed9b830606c9c4337e38cf0d7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JGy6BOBOwmxA9ZmX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@haithemfrd_off?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Haithem Ferdi </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="8af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建依赖并行计算的应用程序和软件的能力还有待充分开发。Grand Central Dispatch提供的技术自2009年起就可以使用，这早于Swift的推出。</p><p id="a0d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的几年里，Apple增加了对使用同步和异步执行的多线程处理的支持。</p><p id="a16f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与用于创建和管理<code class="fe ls lt lu lv b">pthreads</code>的旧的和标准的<strong class="ky ir"> POSIX API </strong>不同，Swift允许使用封装低级操作的队列，因为它向软件开发人员展示了一个更简单的API。</p><p id="31e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然应用程序开发人员目前对GCD的大多数使用都是关于与web一起工作以及异步执行任务和请求，但它还可以用于运行并行任务，以优化高负载代码的性能。</p><h1 id="fe79" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">任务</h1><p id="e10b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Swift中的任务是独立于其他代码在处理器上运行的异步工作单元。使用以下语法创建一个<code class="fe ls lt lu lv b">Task</code>:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="4067" class="mx lx iq lv b gy my mz l na nb">let task = Task {<br/>	print ("This is a task")<br/>}</span></pre><p id="418c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦实例化，任务由操作系统自动调度，开发者不能直接选择何时开始执行。</p><p id="77ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于任务的异步特性，任务对于运行独立于其余执行的特定代码非常有用。</p><p id="7246" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用swift中的<code class="fe ls lt lu lv b">await</code>关键字，以如下方式等待任务完成:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="9a12" class="mx lx iq lv b gy my mz l na nb">let taskResult = await task.value</span></pre><p id="b3f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这种语法在等待任务完成时很有用，但返回值也可以用来存储任务正在执行的代码的有意义的结果。</p><p id="41ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，通过在定义闭包参数时采用它，可以指定任务的实际返回类型:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="2616" class="mx lx iq lv b gy my mz l na nb">let task = Task { () -&gt; Int in<br/>	// Some code being exectued<br/>	let result = doSomeStuff()<br/>	return result<br/>}//Somewhere else <br/>let taskResult = await task.value //Waiting for the completion <br/>if taskResult == 0 {<br/>	print("The task has succesfully finished executing")<br/>}<br/>else {<br/>	print("The task failed during its execution")<br/>}</span></pre><h1 id="424c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">任务组</h1><p id="5e37" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在Swift中，任务组是并行运行的动态创建的任务的集合。</p><p id="3e77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与任务不同，任务组通常用于分割正在执行的代码的工作负载，因此可以利用并行性来显著提高当前应用的整体性能。</p><p id="f7b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别是，当所需任务的数量在编译时未知时使用它们，因此在程序运行时动态决定。</p><p id="962f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任务组中的所有任务共享相同的返回类型，并使用Swift标准库的<code class="fe ls lt lu lv b">withTaskGroup</code>函数进行实例化。</p><p id="8619" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，一个任务组可以用来获得一组值，这些值是通过异步计算该组的单个任务获得的。</p><p id="b804" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们定义任务组:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="4ad6" class="mx lx iq lv b gy my mz l na nb">let result : [Float] = withTaskGroup(of: Float.self) { group in <br/>	//Task definition<br/>}</span></pre><p id="9857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">group</code>，闭包的捕获参数，用于引用从属于闭包的代码中新创建的任务组。</p><p id="7968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组中每个任务的返回类型由参数<code class="fe ls lt lu lv b">of:</code>指定，在这种情况下，任务将返回一个浮点数。</p><p id="7596" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，使用<code class="fe ls lt lu lv b">addTask</code>方法，我们可以通过定义必须执行的代码向组中添加一个任务。例如，我们可以用下面的代码动态生成10个任务，这些任务产生一个随机生成的浮点数:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="b53d" class="mx lx iq lv b gy my mz l na nb">let result : [Float] = withTaskGroup(of: Float.self) { group in <br/>	for _ in 0..&lt;10 {<br/>		group.addTask {<br/>			return Float.random(in: -100...100) //Returning a random number in -100 - 100<br/>		}<br/>	}<br/>}</span></pre><p id="0f04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，为了创建最终的数组，最基本的是等待所有任务完成，然后通过追加每个返回值来构造数组。</p><p id="b15e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift通过使用一个<code class="fe ls lt lu lv b">for await</code>循环很容易地实现了这一点，该循环将等待所有任务终止执行的时刻，然后迭代每个返回值</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="5f4f" class="mx lx iq lv b gy my mz l na nb">let result : [Float] = withTaskGroup(of: Float.self) { group in <br/>	let array = [Float]()<br/>	for _ in 0..&lt;10 {<br/>		group.addTask {<br/>			return Float.random(in: -100...100) //Returning a random number in -100 - 100<br/>		}<br/>	}<br/>	for await value in group {<br/>		array.append(value) //Append the value obtained from the task<br/>	}<br/>	return array //Returning the created array<br/>}</span></pre><p id="3997" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过追加来自每个任务的每个值，数组被创建，并因此准备好被返回。</p><h1 id="4550" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">使用Accelerate实现离散傅里叶变换的完整示例</h1><p id="aa19" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">无需深究细节，离散傅里叶变换(DFT)是一种算法，可用于转换信号(如音频信号)以提取其频谱。</p><p id="d849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<strong class="ky ir"> DSP </strong>(数字信号处理)领域，为了节省计算资源，广泛使用一种叫做快速傅立叶变换(FFT)的算法来处理信号，快速获得DFT。</p><p id="b24f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管是实际傅立叶变换的近似，FFT仍然可以归类为依赖于拥有足够的<em class="nc">处理能力</em>以便能够按时执行的代码。</p><p id="8492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">苹果公司的<code class="fe ls lt lu lv b">Accelerate</code>框架的<code class="fe ls lt lu lv b">vDSP</code>包可以用来成功实现dst，而不需要无用的令人费解的代码。通过利用vDSP提供的API，借助封装了所需功能的<code class="fe ls lt lu lv b">DiscreteFourierTransform</code>类可以获得DFT。</p><p id="71f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了计算<em class="nc">快速傅立叶变换</em>，使用了<em class="nc">加速</em> DFT API，如下所示:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="bff1" class="mx lx iq lv b gy my mz l na nb">typealias SignalType = Float<br/>func computeFFT(of signal: [SignalType]) -&gt; [SignalType]{<br/>	var returnedResult: (real: [SignalType], imaginary: [SignalType])?<br/>	do {<br/>		let fwdDFT = try vDSP.DiscreteFourierTransform(<br/>			previous: nil,<br/>			count: signal.count,<br/>			direction: .forward,<br/>			transformType: .complexComplex,<br/>			ofType: SignalType.self)<br/>			// Creating the imaginary part of the signal with zeroes<br/>			let imaginary: [SignalType] = [SignalType](repeating: 0.0, count: signal.count) 			returnedResult = fwdDFT.transform(real: signal, imaginary: imaginary) // Run the transform algorithm<br/>	}<br/>	catch {<br/>		//Print an error in case DiscreteFourierTransform could not be instantiated<br/>		print(error) <br/>	}<br/>	guard let real = returnedResult?.real else {<br/>		return [] <br/>	}<br/>	//We are interested only to the real part of the transformed signal<br/>	return real <br/>}</span></pre><p id="18fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，为了本文的目的，已经实现了一个函数，用于生成具有选择的计数和样本数的随机信号。</p><h1 id="da11" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">顺序计算DFT</h1><p id="906a" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">可以用来计算DFT的第一种方法包括对每个信号(存储在数组中)进行顺序迭代，并对其应用傅立叶变换。由于信号已经以浮点数组的形式存储在内存中，因此使用矩阵来跟踪所产生的信号集合:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="d245" class="mx lx iq lv b gy my mz l na nb">let sigCount = 200<br/>let sampleCount = 2048<br/>let signals = generateSignals(numSignals: sigCount, samples: sampleCount) <br/>//Returns a matrix, each row representing a different signal</span></pre><p id="faf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦有了信号，我们就可以遍历它们，并使用标准for循环应用上面定义的<code class="fe ls lt lu lv b">computeFFT</code>函数:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="8de3" class="mx lx iq lv b gy my mz l na nb">var sequentialResults = [[SignalType]]()<br/>for signal in signals {<br/>	//Append every computed result<br/>	sequentialResults.append(computeFFT(of:signal)) 		<br/>}</span></pre><p id="2cbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，我们需要一种方法来跟踪我们的处理器完成给定任务需要多少时间。</p><p id="563b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，使用了核心基础框架中的<code class="fe ls lt lu lv b">CFAbsoluteTimeGetCurrent()</code>函数。</p><p id="31cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过存储算法开始执行的时间，可以容易地如下计算完成时间:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="e3ca" class="mx lx iq lv b gy my mz l na nb">var sequentialResults = [[SignalType]]()<br/>var startTime = CFAbsoluteTimeGetCurrent() <br/>for signal in signals {<br/>	//Append every computed result<br/>	sequentialResults.append(computeFFT(of:signal)) 		<br/>}<br/>var endTime = CFAbsoluteTimeGetCurrent() //Time of terminationvar elapsedTime = endTime - startTime <br/>print("Sequential algorithm: \(elapsedTime)"</span></pre><p id="dae5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面介绍的代码执行DFT，并在屏幕上显示处理器完成指定任务所需的时间。</p><h1 id="ad97" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">使用任务组并行计算DFT</h1><p id="a73b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了执行智能并行计算，我们需要在所有可用的CPU内核之间分配总工作负载。</p><p id="76d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是通过让<code class="fe ls lt lu lv b">activeProcessorCount</code>通过基础框架来完成的，如下所示:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="19b1" class="mx lx iq lv b gy my mz l na nb">let  processors = ProcessInfo.processInfo.activeProcessorCount</span></pre><p id="300d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该变量包含CPU核心的数量。</p><p id="9fe0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，可以创建负责执行计算的<code class="fe ls lt lu lv b">TaskGroup</code>:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="9afa" class="mx lx iq lv b gy my mz l na nb">let task = Task { () -&gt; [[SignalType]] in <br/>	let concurrentResults : [[SignalType]] = await withTaskGroup(of [[SignalType]].self) {<br/>		group in<br/>		<br/>		// Create an empty matrix that will contain all the Fourier transforms<br/>		var transformedSignals = [[SignalType]]()		<br/>		for i in 0..&lt;Int(processors) {<br/>			group.addTask {<br/>				// For every task create a sub-matrix to be filled<br/>				// with the Fourier transforms of the signals<br/>				var matrix = [[SignalType]]()<br/>				<br/>				//  The bounds for each task range from (i/processors) to ((i+1)/processors)<br/>				//	This will divide the signals equally among the various processors<br/>				let lowerBound = Float(i)/processors * Float(signals.count)<br/>				let upperBound = Float(i+1)/processors * Float(signals.count)				for index in Int(lowerBound)..&lt;Int(upperBound) {<br/>					matrix.append(computeFFT(of signals[index])<br/>				}<br/>				return matrix<br/>			}<br/>		}		// After every task is created and automatically scheduled by the OS, <br/>		// wait for the end of each one and append the sub-matrices to the return variable<br/>		for await value in group {<br/>			transformedSignals.append(contentsOf: value)<br/>		}<br/>		return transformedSignals<br/>	}<br/>	<br/>	return concurrentResults<br/>}</span></pre><p id="a21a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码背后的逻辑实际上非常简单。</p><p id="f17e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了语法之外，实际发生的是在可用的CPU内核之间简单地划分任务总量。</p><p id="6e68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得每个内核与其他内核相比具有相似的工作负载，从而减少了完成执行所需的时间。</p><p id="0ef5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理论上，所选择的产生任务的数量也可以高于实际的处理器数量。</p><p id="0bfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，关于使用提升数量的任务，最相关的问题是实例化多个任务时产生的开销。</p><p id="9a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，在引擎盖下，创建任务并对其进行调度需要CPU执行长时间的调度算法和不同的上下文切换(即，从正在运行的任务到另一个任务来回切换)，因此当操作系统必须调度太多任务/线程时，性能会恶化。</p><p id="bc55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个CPU都有固定数量的逻辑处理器，可以用来同时运行不同的操作。</p><p id="8c5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，一个M1处理器配备了一个8核CPU，这意味着如果我们可以在任何时间点拍摄处理器的快照，那么只有8个线程在该时刻实际运行。因此，实例化比可用逻辑处理器数量更多的任务是多余的，甚至弊大于利。</p><p id="c68a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的具体案例中，在M1上，在任何给定时间只能同时处理八批信号，这意味着拆分工作负载，甚至更多，将迫使组中的一些任务等待CPU被释放，从而成为程序性能的瓶颈。</p><h1 id="8e5b" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结果</h1><p id="6bfa" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了量化并发算法在多大程度上提高了执行效率，我们对不同数量的待转换信号进行了多次测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/4f778278e7fa188c7394893bd38f4d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*enEwSAz7HRPAoUxC.jpg"/></div></div></figure><p id="96af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试清楚地表明，在处理非常繁重的工作负载时，并发算法要好得多。</p><p id="3a21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该图通过对数标度来表示，对数标度更适合于表示彼此相距很远的数字。</p><p id="bffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，对数标度以10的幂来分隔数字，也就是说，在对数标度中，区间[0.1，1]的距离与区间[1，10]，[10，100]等的距离相同。</p><p id="ccd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，由于两条线之间的距离大致保持不变，所以下面的值和上面的值之间的差距会越来越大。</p><p id="4b03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个案例的演示，在这个案例中，并发性极大地改善了特定任务的执行，而iOS环境中仍有许多未探索的路径有待发现。</p><p id="89ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">西蒙·佐丹奴 &amp; <a class="ne nf ep" href="https://medium.com/u/344a2a281ea3?source=post_page-----cfd66b5faf57--------------------------------" rel="noopener" target="_blank">米歇尔·阿韦萨纳</a>撰写</p></div></div>    
</body>
</html>