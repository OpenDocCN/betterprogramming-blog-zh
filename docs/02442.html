<html>
<head>
<title>What Is the Prototype in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的原型是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-the-prototype-in-javascript-a17329f3a364?source=collection_archive---------11-----------------------#2019-12-01">https://betterprogramming.pub/what-is-the-prototype-in-javascript-a17329f3a364?source=collection_archive---------11-----------------------#2019-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="70e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb17a8122bb01706ad486e2aa144d901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NJ8ep2_G3AWHY4Wr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿尔瓦罗·雷耶斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c9a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中的原型是什么，它们是如何工作的？在这篇文章中，我将讨论JavaScript中的原型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0356" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">JavaScript中的构造函数是什么？</h1><p id="40cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要了解原型，先说构造函数。</p><p id="3279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中的<code class="fe mz na nb nc b">Constructor</code>函数是返回对创建实例对象的对象的引用的函数。例如，如果您的对象是数组的实例，其构造函数将引用该数组。这个构造函数总是指向函数本身。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d3f6" class="nh md it nc b gy ni nj l nk nl">let a = [];<br/>a.constructor === Array; // true</span></pre><p id="72d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设有一个名为Tree的函数。使用树函数创建一个新对象:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b830" class="nh md it nc b gy ni nj l nk nl">function Tree() {<br/>  this.name = 'Tree';<br/>}</span><span id="df92" class="nh md it nc b gy nm nj l nk nl">const tree = Tree();<br/>console.dir(tree); // undefined</span></pre><p id="f3d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，<code class="fe mz na nb nc b">tree</code>中没有存储任何东西，因为Tree不返回任何值。在JavaScript中，构造函数是一个函数对象，只有在使用<code class="fe mz na nb nc b">new</code>关键字调用函数Tree时才会被调用。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8541" class="nh md it nc b gy ni nj l nk nl">const tree = new Tree();<br/>console.dir(tree); </span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e0d107e00a5e421a95fe25db3ea937d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*RciFork9ZO-Rj-fLI07quw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">console.dir的结果(树)</p></figure><p id="0aef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到属性<code class="fe mz na nb nc b">name</code>是在我们用<code class="fe mz na nb nc b">new</code>关键字调用Tree之后设置的。那么当我们用<code class="fe mz na nb nc b">new</code>调用一个函数时会发生什么呢？</p><p id="9036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，有两种通过调用函数来创建对象的方法。第一种方法是每个懂JavaScript的人可能都知道的——就像下面这样称呼它。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ad7b" class="nh md it nc b gy ni nj l nk nl">tree();</span></pre><p id="61d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你这样调用它，那么函数Tree的新的词法环境将被创建，JavaScript引擎将从上到下执行<code class="fe mz na nb nc b">tree</code>中的所有代码。如果有return语句，那么<code class="fe mz na nb nc b">tree</code>返回特定的值。如果没有，则默认返回<code class="fe mz na nb nc b">undefined</code>。</p><p id="2f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，使用<code class="fe mz na nb nc b">new</code>关键字，引擎会执行几个步骤。</p><ol class=""><li id="e0cb" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">创建一个空对象<code class="fe mz na nb nc b">{}</code>，并将其分配给<code class="fe mz na nb nc b">this</code>。</li><li id="391f" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">将函数中像这样表示的所有值赋给<code class="fe mz na nb nc b">this</code>。<code class="fe mz na nb nc b">this.name = 'Tree'</code></li><li id="07d1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">返回<code class="fe mz na nb nc b">this</code>并将其存储到一个采用<code class="fe mz na nb nc b">new Tree()</code>返回值的变量中。</li></ol><p id="c8b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果你用<code class="fe mz na nb nc b">new</code>调用一个函数，代码是这样的。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a2e3" class="nh md it nc b gy ni nj l nk nl">function Tree() {<br/>  this = {};<br/>  this.name = 'Tree';<br/>  return this;<br/>}</span></pre><h2 id="bcbf" class="nh md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">我如何知道函数是否是用“new”调用的？</h2><p id="eb25" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从ECMAScript 2015开始，一个新的特性出来了；<code class="fe mz na nb nc b">new.target</code>。这是一个非常简单的特性，让您知道这个函数是否是用<code class="fe mz na nb nc b">new</code>调用的。<code class="fe mz na nb nc b">new.target</code>返回对函数构造函数的引用。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b3d7" class="nh md it nc b gy ni nj l nk nl">function Tree() {<br/>  if (!new.target) { <br/>    console.log('Need new !!!');<br/>  }<br/>}</span><span id="0966" class="nh md it nc b gy nm nj l nk nl">Tree(); // Need new !!!<br/>new Tree(); // Tree {}</span></pre><h2 id="fb04" class="nh md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">我明白什么是构造函数，但这有什么关系呢？</h2><p id="9b7f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所以，如果我们用<code class="fe mz na nb nc b">new</code>调用Tree，那么结果看起来是这样的。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b1c4" class="nh md it nc b gy ni nj l nk nl">function Tree() {<br/>  this.name = 'Tree';<br/>  this.age = 13;<br/>}</span><span id="29ca" class="nh md it nc b gy nm nj l nk nl">const tree = new Tree();<br/>// same as<br/>const tree = {<br/>  name: 'Tree';<br/>  age: 13<br/>};</span></pre><p id="9736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，想象一下，我们想再创造10棵树。如果我们每次都必须用一个<em class="on">字面上的</em>对象来创建一个对象，这难道不令人讨厌吗？<br/>简单地将每个变量或方法放入一个构造函数中，然后用<code class="fe mz na nb nc b">new</code>调用创建一个新对象。这不仅有利于维护代码，而且还可以重用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/e3919323f3894e6984e56ecb9a619073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XqlClna3Mhwn_eNY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chiro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">photo-nic.co.uk NIC</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a522" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是原型？</h1><p id="fbc6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">先说样机。原型是一个函数对象的所有实例之间的共享属性。当使用<code class="fe mz na nb nc b">new</code>调用一个函数时，会生成一个名为<code class="fe mz na nb nc b">prototype</code>的新属性，然后将其设置为<code class="fe mz na nb nc b">this</code>。有趣的是，函数本身的构造函数是原型对象的默认属性。而每一个对象，除了<code class="fe mz na nb nc b">Object.create(null)</code>创建的对象，都有它的原型对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a2e1d42f89cf99566816e102cb5eb550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*MEosYsiuqQaNHzcmgpRTWQ.png"/></div></figure><p id="50d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是您在创建树的新实例时可以看到的。如果您不熟悉JavaScript中的prototype，请记住这一点:prototype只是一个对象，它的名为constructor的属性引用它所属的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="6635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然树没有<code class="fe mz na nb nc b">sayName</code>函数作为它的属性，但是<code class="fe mz na nb nc b">tree1</code>和<code class="fe mz na nb nc b">tree2</code>有<code class="fe mz na nb nc b">sayName</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/51109d4a4ad099d55809707ab01e674d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLA2XZVHooQFnAKCSIlTLQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">树的原型链</p></figure><p id="5a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是树的原型链的全图。我知道，这看起来很混乱。我一个一个解释。</p><ol class=""><li id="3eda" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">树具有<code class="fe mz na nb nc b">prototype</code>属性，用于与从树继承属性的所有实例共享属性，例如变量和函数。</li><li id="d667" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">正如我前面提到的，<code class="fe mz na nb nc b">prototype</code>只是一个内部包含<code class="fe mz na nb nc b">constructor</code>函数的对象，我们在这篇文章的前面已经讨论过了。而<code class="fe mz na nb nc b">constructor</code>指向函数本身。树的<code class="fe mz na nb nc b">prototype</code>有链接到<code class="fe mz na nb nc b">Tree</code>函数的<code class="fe mz na nb nc b">constructor</code>。</li><li id="6d89" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">每个对象都包含一个名为<code class="fe mz na nb nc b">[[prototype]]</code>的属性。在大多数浏览器中，它被称为<code class="fe mz na nb nc b">__proto__</code>。<code class="fe mz na nb nc b">[[prototype]]</code>表示的是函数从其继承属性的对象的<code class="fe mz na nb nc b">prototype</code>属性。比如看图。树的<code class="fe mz na nb nc b">[[prototype]]</code>引用<code class="fe mz na nb nc b">Function.prototype</code>，因为树是函数的实例。</li><li id="1ab9" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">最高的<code class="fe mz na nb nc b">prototype</code>是<code class="fe mz na nb nc b">Object.prototype</code>。<code class="fe mz na nb nc b">Object.prototype</code>不指任何东西。所以<code class="fe mz na nb nc b">Object.prototype.__proto__</code>就是<code class="fe mz na nb nc b">null</code>。</li><li id="724b" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">当一个变量或方法被调用或引用时，JavaScript通过从最底层到最顶层查看所有原型来寻找它，直到它找到它要找的东西或者它从<code class="fe mz na nb nc b">Object.prototype</code>到达<code class="fe mz na nb nc b">null</code>。这个过程叫做<code class="fe mz na nb nc b">Prototype Chain</code>。</li></ol><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6f8e" class="nh md it nc b gy ni nj l nk nl">tree1.sayName(); // Maple</span></pre><p id="6c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">tree1</code>没有<code class="fe mz na nb nc b">sayName</code>作为它的属性。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2466" class="nh md it nc b gy ni nj l nk nl">tree1.hasOwnProperty('sayName'); // false</span></pre><p id="6441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe mz na nb nc b">sayName</code>时，JavaScript在<code class="fe mz na nb nc b">tree1</code>的范围内寻找，但是找不到。然后JavaScript寻找连接到<code class="fe mz na nb nc b">Tree.prototype</code>的<code class="fe mz na nb nc b">tree1</code>的<code class="fe mz na nb nc b">[[prototype]]</code>。JavaScript可以在<code class="fe mz na nb nc b">Tree.prototype</code>的范围内找到<code class="fe mz na nb nc b">sayName</code>，并执行。如果在<code class="fe mz na nb nc b">Tree.prototype</code>中没有<code class="fe mz na nb nc b">sayName</code>，那么JavaScript再次寻找连接到<code class="fe mz na nb nc b">Function.prototype</code>的<code class="fe mz na nb nc b">Tree</code>的<code class="fe mz na nb nc b">[[prototype]]</code>。JavaScript会一直这样做，直到找到它要找的东西或者到达<code class="fe mz na nb nc b">null</code>。</p><h2 id="33cf" class="nh md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">即使我已经用“new”创建了一个对象，我还能在原型中添加方法吗？</h2><p id="8130" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">绝对的。看例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="d8df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以随时在Tree的原型中添加或删除变量或函数。当它的所有实例试图访问它时，它们将动态地引用更新的原型。</p><h2 id="944f" class="nh md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">我可以替换原型吗？</h2><p id="9b47" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当然可以。您可以用新的原型对象重新分配它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="5224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在结果中看到的，Tree的原型被换成了另一个，我做了<code class="fe mz na nb nc b">tree3</code>。但好玩的地方在于<code class="fe mz na nb nc b">tree1</code>和<code class="fe mz na nb nc b">tree2</code>仍然指出之前的<code class="fe mz na nb nc b">sayName</code>打印<code class="fe mz na nb nc b">this.name</code>的功能，而<code class="fe mz na nb nc b">tree3</code>则指出新的<code class="fe mz na nb nc b">sayName</code>。因此，在用新的原型替换现有的原型之前，您应该确保这一点。因为现有实例仍然引用原始原型，所以它们不会像您预期的那样工作。此外，垃圾收集器GC不会清理原始原型，因为它仍然被其他人引用，在本例中是<code class="fe mz na nb nc b">tree1</code>和<code class="fe mz na nb nc b">tree2</code>。因此，改变原型并不被认为是最佳实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="99a2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e54e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">原型是JavaScript中一个非常漂亮的特性，因为它允许许多对象彼此共享数据。但是，您应该小心处理原型，因为如果您更改原型，已经创建的实例必须手动更新，并且很容易产生副作用。下一篇文章，我将使用原型讨论JavaScript中的继承。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="97ab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="06a5" class="no np it lb b lc mu lf mv li ot lm ou lq ov lu ow nu nv nw bi translated"><a class="ae ky" href="https://tc39.es/ecma262/#sec-object-constructor" rel="noopener ugc nofollow" target="_blank"> TC39 — Object.constructor </a></li><li id="1f9f" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu ow nu nv nw bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target" rel="noopener ugc nofollow" target="_blank">MDN中的新目标</a></li><li id="83f9" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu ow nu nv nw bi translated"><a class="ae ky" href="https://javascript.info/constructor-new" rel="noopener ugc nofollow" target="_blank"> JavaScript信息—构造函数</a></li><li id="8aa8" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu ow nu nv nw bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">MDN中的object . prototype</a></li></ul></div></div>    
</body>
</html>