<html>
<head>
<title>How to Change Textures on a Node in ARKit With Touch Gestures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用触摸手势改变ARKit中节点的纹理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tutorial-how-to-change-textures-on-a-node-in-arkit-with-touch-gestures-72dba54aa6b1?source=collection_archive---------22-----------------------#2020-02-03">https://betterprogramming.pub/tutorial-how-to-change-textures-on-a-node-in-arkit-with-touch-gestures-72dba54aa6b1?source=collection_archive---------22-----------------------#2020-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7b4d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">给你的新现实一个新的面貌</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3597fc8c82d1f51a205988956959be83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ED9jz0WmIaxvZjz2"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">paweczerwi324ski</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="2369" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会问自己，为什么要更改节点上的纹理(节点是SceneKit场景中的任何对象)？</p><p id="c3d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多种原因。最简单的是你想要一个你已经与一个节点交互的指示。也许你有一个AR游戏，你想给玩家反馈游戏状态的变化。也许静态纹理时不时会变得很无聊。</p><p id="3bcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管是什么原因，我在这里提供一个简单的教程，介绍如何通过触摸手势改变正在运行的ARKit应用程序上的纹理。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="87e7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">入门指南</h1><p id="459b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先创建一个新项目。与其从头开始实现<code class="fe mw mx my mz b">ARSCNView</code>和样板文件，不如选择增强现实应用作为模板，并确保SceneKit是所选的内容技术。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/d48221c1e27fea90dd7e515d62069416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_8DCu6rfRdR9zlKSfrdhdw.png"/></div></div></figure><p id="e9b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您开始任何代码之前，我们需要为我们的项目添加一些图像。对于这个特定的应用程序，我选择了一个太阳系主题，并收集了地球、月亮和太阳的纹理。</p><p id="9dd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没错——我们将使用我们的应用程序创建行星体。确保分别命名为<code class="fe mw mx my mz b">earth</code>、<code class="fe mw mx my mz b">moon</code>和<code class="fe mw mx my mz b">sun</code>，并将它们直接放入<code class="fe mw mx my mz b">Assets.xcassets</code>文件夹。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="b12f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">ViewController.swift</code>中，通过在<code class="fe mw mx my mz b">viewDidLoad()</code>方法上方声明以下变量开始:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="1e47" class="nf ma iq mz b gy ng nh l ni nj">let textures = ["earth", "moon", "sun"]<br/>var currentIndex = 0<br/>var currentTexture = ""</span></pre><p id="a8db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确保纹理数组中的字符串与资源文件夹中的纹理具有完全相同的名称。在<code class="fe mw mx my mz b">viewDidLoad()</code>方法中，将<code class="fe mw mx my mz b">SCNScene(named: “art.scnassets/ship.scn”)!</code>替换为<code class="fe mw mx my mz b">SCNScene()</code>。在该行下面，使用<code class="fe mw mx my mz b">currentTexture = textures[currentIndex]</code>用<code class="fe mw mx my mz b">textures</code>中的第一个项目初始化<code class="fe mw mx my mz b">currentTexture</code>。</p><p id="6ff1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">viewWillDisappear()</code>方法之后，创建以下函数:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="0ee5" class="nf ma iq mz b gy ng nh l ni nj">func createSphere() -&gt; SCNNode {<br/>  let sphere = SCNSphere(radius: 1)     <br/>  sphere.firstMaterial?.diffuse.contents = UIImage(named:    <br/>  currentTexture)<br/>  let sphereNode = SCNNode(geometry: sphere)<br/>  sphereNode.name = "sphere"<br/>  sphereNode.position = SCNVector3(0, 0, -3)<br/>  return sphereNode<br/>}</span></pre><p id="7b12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用说，这个函数在我们的3D空间中创建了一个球体。我们给球体一个<code class="fe mw mx my mz b">1</code>米的<code class="fe mw mx my mz b">radius</code>(根据ARKit的默认测量单位)并赋予它<code class="fe mw mx my mz b">currentTexture</code>的纹理，应该是<code class="fe mw mx my mz b">earth</code>。</p><p id="9b80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们创建一个<code class="fe mw mx my mz b">SCNNode()</code>并指定它的球体的几何形状——同时给它命名为<code class="fe mw mx my mz b">sphere</code>,这在我们改变纹理时很重要。当应用程序启动并返回<code class="fe mw mx my mz b">sphereNode</code>时，我们将它放在离摄像机三米远的地方。</p><p id="4c6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">viewDidLoad()</code>中，在我们指定<code class="fe mw mx my mz b">currentTexture</code>的地方添加以下内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="f20c" class="nf ma iq mz b gy ng nh l ni nj">sceneView.scene.rootNode.addChildNode(createSphere())</span></pre><p id="cafd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你的手机上测试这个应用程序，如果一切顺利，你应该会在你的眼前看到一个增强现实地球。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7d91" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">强硬的姿态</h1><p id="6dde" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们开始用触摸手势改变纹理。在<code class="fe mw mx my mz b">createSphere()</code>方法下面，实现<code class="fe mw mx my mz b">touchesBegan(_:with:)</code> <em class="nk">。</em>请注意，还有其他实现触摸手势的方法，这只是其中一种。在<code class="fe mw mx my mz b">touchesBegan</code>中添加以下代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="05b6" class="nf ma iq mz b gy ng nh l ni nj">let touch = touches.first!</span><span id="cf9a" class="nf ma iq mz b gy nl nh l ni nj">if touch.view == self.sceneView {<br/>  let viewTouchLocation:CGPoint = touch.location(in: sceneView)<br/>  <br/>  guard let result = sceneView.hitTest(viewTouchLocation, options: nil).first else {<br/>    return<br/>  }</span><span id="6663" class="nf ma iq mz b gy nl nh l ni nj">  if result.node.name == "sphere" {<br/>    let node = result.node<br/>    currentIndex = currentIndex == 0 ? 1 : currentIndex == 1 ? 2 : 0<br/>    currentTexture = textures[currentIndex]<br/>    node.geometry?.firstMaterial?.diffuse.contents = currentTexture<br/>  }<br/>}</span></pre><p id="fcba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下这个代码块。</p><p id="c36c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们第一次检测到触摸。</p><p id="43d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们要确保触摸在<code class="fe mw mx my mz b">sceneView</code>内(如果你一直跟着做，默认情况下<code class="fe mw mx my mz b">sceneView</code>应该覆盖你手机的整个屏幕，因为它自动在每一边都有零边距)。</p><p id="6c61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们得到触摸点相对于屏幕的<code class="fe mw mx my mz b">CGPoint</code>坐标。</p><p id="4fe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们确保通过将<code class="fe mw mx my mz b">sceneView</code>的<code class="fe mw mx my mz b">hitTest</code>分配给<code class="fe mw mx my mz b">result</code>来触发它；否则，我们<code class="fe mw mx my mz b">return</code>。</p><p id="3b5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，代码可以自由地检查我们是否接触了节点。如果我们触摸的节点的名称是<code class="fe mw mx my mz b">sphere</code>(我们之前用过)，那么我们需要改变球体的纹理。因为我只有三个纹理，所以我使用一个三元运算符从0 ➡ 1 ➡ 2开始循环<code class="fe mw mx my mz b">currentIndex</code>，然后回到0。然后我重新分配了<code class="fe mw mx my mz b">currentTexture</code>。最后，我给我们的节点设计了一个新的材质。</p><p id="43a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">咻！运行您的代码，当您触摸球体时，应该会得到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/710ba389c93f1908543962981d6e3e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Pf6yF9Oo9VDmClxM-F2ygg.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">结果呢</p></figure><p id="f4c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已！我希望这能给你一个在ARKit中改变纹理的起点。在这里你可以随意查看完整的源代码<a class="ae kv" href="https://github.com/modium/ARKit-texture-tutorial" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这是我用同样的工作流程创建的</p></figure></div></div>    
</body>
</html>