<html>
<head>
<title>What Can We Expect in Kotlin 1.4?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kotlin 1.4中我们可以期待什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-can-we-expect-in-kotlin-1-4-e5374587e020?source=collection_archive---------3-----------------------#2020-06-05">https://betterprogramming.pub/what-can-we-expect-in-kotlin-1-4-e5374587e020?source=collection_archive---------3-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3386" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Kotlin和Android的未来</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2278db3998fe12a4c38fe8d8e80a0eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VdS5414BthVVzhZ4.png"/></div></div></figure><p id="debc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">科特林语是一种年轻的语言，但它发展很快。Kotlin 1.4的第一个预览版(M1和M2)已经发布了，它们带有许多令人兴奋的特性。</p><p id="ae9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以很容易地写一系列关于这些特性的文章，所以这里我们只关注Kotlin下一个版本中最重要的创新:语言的更新，标准库的新功能，最重要的是，一种全新的多平台项目方法。</p><h2 id="da4e" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">为Kotlin 1.4设置项目</h2><p id="8cbd" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在继续介绍Kotlin 1.4的新特性之前，如果您想现在就开始使用它，这里是必需的<code class="fe mo mp mq mr b">build.gradle.kts</code>(注意，Kotlin 1.4仍处于预览状态)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5869" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，当以JVM为目标时，我们只需用JVM替换“多平台”即可。这里重要的部分是添加预览库的必要性，并将Kotlin的版本设置为“1.4-M2”。</p><h2 id="263b" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">语言更新</h2><p id="4db9" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">该语言的核心并没有真正更新，但有一些受欢迎的变化:</p><ul class=""><li id="c0a1" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><strong class="kw iu">混合命名和位置参数</strong>:在1.4之前，写参数的名称迫使我们写所有参数的名称，但是这个问题已经被修复。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><ul class=""><li id="a5c3" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><strong class="kw iu">Break and continue inside when</strong>:如果我们在一个循环中使用一个<code class="fe mo mp mq mr b">when</code> <em class="nd"> </em>子句，我们现在可以使用<code class="fe mo mp mq mr b">when</code>中的<code class="fe mo mp mq mr b">continue</code> <em class="nd"> </em>和<code class="fe mo mp mq mr b">break</code> <em class="nd"> </em>指令。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><ul class=""><li id="761b" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><strong class="kw iu"/><code class="fe mo mp mq mr b"><strong class="kw iu">typeof</strong></code><strong class="kw iu">函数</strong>:一个新的方便的函数，允许我们获取一个<code class="fe mo mp mq mr b">KType</code>对象，当我们可以获取一个具体化的泛型类型的<code class="fe mo mp mq mr b">KType</code>对象时，这个函数特别有用。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><ul class=""><li id="4083" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><strong class="kw iu">尾随逗号</strong>:现在可以在参数列表的最后一个参数后添加一个尾随逗号，通过复制/粘贴可以更容易地切换参数的位置。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="65b9" class="nl lr it bd ls nm nn no lv np nq nr ly jz ns ka mb kc nt kd me kf nu kg mh nv bi translated">更新的标准库</h1><p id="deb7" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Kotlin的标准库包含了大量的函数和类，方便的完成了Java标准库。随着Kotlin的每一次更新，新的特性都会加入标准库，从而提高Kotlin的可用性。</p><p id="85a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可以通过添加新功能，或者最终取消或删除一些不安全的功能来实现。在删除的功能中，我们可以列举:</p><ul class=""><li id="ef81" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><code class="fe mo mp mq mr b">mod</code>操作员最终被<code class="fe mo mp mq mr b">rem</code>取代。</li><li id="dfb9" class="mu mv it kw b kx nw la nx ld ny lh nz ll oa lp mz na nb nc bi translated">现在不赞成将浮点类型转换为字节和短整型</li></ul><p id="447a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于增加的功能，我们有:</p><ul class=""><li id="c3d8" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">标准库现在对所有平台都是通用的，包括<code class="fe mo mp mq mr b">kotlinx.corountines</code>、<code class="fe mo mp mq mr b">kotlinx.serialization</code>和<code class="fe mo mp mq mr b">kotlinx.io</code>。</li><li id="9372" class="mu mv it kw b kx nw la nx ld ny lh nz ll oa lp mz na nb nc bi translated">反射API现在对所有平台(JVM、JS、Native)都是通用的</li></ul><h2 id="a8b9" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">Kotlin多平台变得更好</h2><p id="4276" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这个新版本中，Kotlin多平台有许多新奇之处:</p><ul class=""><li id="f855" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">统一后端:三个独立的后端(JVM、JS和Native)将合并成一个独特的后端。</li><li id="8fdc" class="mu mv it kw b kx nw la nx ld ny lh nz ll oa lp mz na nb nc bi translated"><strong class="kw iu">多平台项目现在可以分层</strong>:例如，我们可以将目标<code class="fe mo mp mq mr b">linuxX64Main</code>、<code class="fe mo mp mq mr b">mingwX64Main</code>、<em class="nd">、<code class="fe mo mp mq mr b">macosX64Main</code>、<em class="nd">、</em>作为一个公共父目标的子目标，我们可以称之为<code class="fe mo mp mq mr b">nativeMain</code>。这允许更好地分解代码。</em></li><li id="1a12" class="mu mv it kw b kx nw la nx ld ny lh nz ll oa lp mz na nb nc bi translated">多平台项目生成名为<code class="fe mo mp mq mr b">KLib</code>的新包。</li><li id="550e" class="mu mv it kw b kx nw la nx ld ny lh nz ll oa lp mz na nb nc bi translated">多平台项目现在需要Gradle 6.0或更高版本。</li></ul><p id="84d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于那些使用Kotlin多平台项目的人来说，这是个好消息。例如，由于项目的层次结构，我们不必为每个平台重写三次相同的代码。</p><p id="8fc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且<strong class="kw iu">KLib格式似乎真的很有前途</strong>。目前，还没有办法构建一个包含所有目标(JVM、JS、Native)代码的包。如果您的多平台项目依赖于另一个多平台项目，则必须为每个目标添加依赖关系。如果在下一个版本中，有可能只依赖一个包，这将是一个巨大的进步。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="1d50" class="nl lr it bd ls nm nn no lv np nq nr ly jz ns ka mb kc nt kd me kf nu kg mh nv bi translated">全球改进</h1><p id="05e8" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">随着语言、标准库和多平台项目支持的改进，Kotlin也有了一些改进，这将使它更容易使用:</p><ul class=""><li id="9860" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">更强大的类型推断(在更多用例中自动推断类型，lambda的最后一个表达式和可调用引用的智能转换，等等)。)</li><li id="55da" class="mu mv it kw b kx nw la nx ld ny lh nz ll oa lp mz na nb nc bi translated">Kotlin/Native编译和执行的改进性能。</li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="7f4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kotlin 1.4还没有发布，所以在发布之前我们可以期待更多的变化。但是第一次预览是令人兴奋的，特别是如果你正在处理多平台项目。</p><p id="a16c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你不知道它们是什么，你应该看一看这篇文章，这篇文章解释了你如何为JVM、浏览器和本地平台编写相同的代码。</p><p id="0e5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这是一个令人惊叹的特性，但在Kotlin 1.3中，仍然存在一些缺点:标准库的一些功能并不适用于所有平台，打包系统不实用，相似目标之间没有可能的代码分解。看到Kotlin 1.4要修复这些东西，那真是好消息。</p></div></div>    
</body>
</html>