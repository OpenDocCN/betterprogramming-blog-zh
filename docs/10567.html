<html>
<head>
<title>Implementing Type-Safe Tuples With Go 1.18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go 1.18实现类型安全元组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-type-safe-tuples-with-go-1-18-9624010efaa?source=collection_archive---------5-----------------------#2022-01-15">https://betterprogramming.pub/implementing-type-safe-tuples-with-go-1-18-9624010efaa?source=collection_archive---------5-----------------------#2022-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="edda" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及如何用新的泛型特性实现它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/def34d3eda8d56564a68d379c0d14094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I9SXWuLkJSpHRoUv"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@burtonts?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ty suggest</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="daa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，<a class="ae kv" href="https://go.dev/blog/go1.18beta1" rel="noopener ugc nofollow" target="_blank"> Go 1.18 beta发布</a>带有期待已久的泛型特性。</p><p id="153a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名来自C++和Python的开发人员，在过渡到Go时，没有泛型特性对我来说是一个巨大的痛点，我仍然发现自己希望能够有一些函数或结构。幸运的是，现在这变得越来越有可能。</p><p id="1e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">TL；DR </strong>:我为Go 1.18实现类型安全元组的旅程。希望它能让你感受到泛型的新的可能性，以及它的局限性。<br/>你可以在这里找到开源<code class="fe ls lt lu lv b">go-tuple</code>包<a class="ae kv" href="https://github.com/barweiss/go-tuple" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="4903" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><span class="l mv mw mx bm my mz na nb nc di"> A </span>仿制药简介</h1><p id="6915" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在Go 1.18中，我们可以用以下方式定义一个通用函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a341" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nk"> ( </em> <a class="ae kv" href="https://go.dev/play/p/hI60P37OSk3?v=gotip" rel="noopener ugc nofollow" target="_blank"> <em class="nk">围棋游戏</em> </a> <em class="nk"> ) </em></p><p id="9242" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的关键是<code class="fe ls lt lu lv b">[T, U any]</code>部分，它允许我们定义泛型类型参数。<code class="fe ls lt lu lv b">T</code>和<code class="fe ls lt lu lv b">U</code>都是类型参数，它们必须满足<code class="fe ls lt lu lv b">any</code>约束条件(后面会详细介绍)</p><p id="9a52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其实<code class="fe ls lt lu lv b">any</code>简单定义为<code class="fe ls lt lu lv b">interface{}</code>，也可以作为类型使用！</p><p id="72c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型参数打开了很多可能性！例如，我们可以利用Go的一个隐藏特性<a class="ae kv" href="https://stackoverflow.com/a/35274608" rel="noopener ugc nofollow" target="_blank">，其中一个函数的返回值可以作为另一个函数的参数传递</a>，以便创建一个类似于Rust的unwrap的通用“Unwrap”函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6e45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nk"> ( </em> <a class="ae kv" href="https://go.dev/play/p/oV-CkED7-qY?v=gotip" rel="noopener ugc nofollow" target="_blank"> <em class="nk">去游乐场</em> </a> <em class="nk"> ) </em></p><p id="7e30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结构和接口也可以成为泛型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a54a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">元组</h1><p id="4c5b" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在编写Go时，我经常觉得需要在一个元组中存储多个值。这并不是说没有其他方法可以做到这一点，但是我总是认为每次需要对值进行分组时声明一个结构是很乏味的。要么我用一个无意义的名字声明一个结构，比如<code class="fe ls lt lu lv b">personAndCar</code>，要么我可以使用一个未命名的结构，但是这样我就不得不在使用时再次指定定义。</p><p id="9d2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当我听说Go 1.18中增加了泛型，并立即想看看它的工作情况时，我决定创建一个元组类型。</p><h1 id="4825" class="md me iq bd mf mg nl mi mj mk nm mm mn jw nn jx mp jz no ka mr kc np kd mt mu bi translated">实现元组类型</h1><p id="c2bc" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">我的目标是支持这些特性，各种语言的大多数tuple实现都支持这些特性:</p><ul class=""><li id="e490" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">包含固定数量的不同类型的值。<em class="nk">(受支持)</em></li><li id="fe20" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">允许对值进行索引访问。<em class="nk">(受支持)</em></li><li id="1f9f" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">可以解包到命名变量中。<em class="nk">(受支持)</em></li><li id="e6d8" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">元组之间的比较。<em class="nk">(有些支持)</em></li><li id="3167" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">获取子元组<em class="nk">(不支持)</em></li><li id="5973" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">串联元组<em class="nk">(不支持)</em></li></ul><p id="a353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我开始记下一些代码。</p><p id="4ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过之前有一点需要注意:Go不支持可变的泛型参数。这意味着不可能编写一个<code class="fe ls lt lu lv b">Tuple</code>类型。我必须为我希望元组保存的每个不同数量的值实现一个类型。但不代表不能有什么共同的代码。</p><p id="f849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的第一次尝试是使用递归定义实现元组:每个元组类型定义一个新值，并使用较低级别的元组来描述其余的值。例如，我可以这样定义一个由4个值组成的元组:</p><pre class="kg kh ki kj gt oe lv of og aw oh bi"><span id="84f8" class="oi me iq lv b gy oj ok l ol om">type Tuple4[T1, T2, T3, T4] Tuple2[T1, Tuple2[T2, Tuple2[T3, T4]]]</span></pre><p id="cf87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迷惑？是的。但是通过这种方式，我可以在<code class="fe ls lt lu lv b">Tuple2</code>上实现一切，并让所有更高级别的元组基于<code class="fe ls lt lu lv b">Tuple2</code>。此外，用户不必知道元组是如何实现的，这对他们来说不重要。</p><pre class="kg kh ki kj gt oe lv of og aw oh bi"><span id="d510" class="oi me iq lv b gy oj ok l ol om">type Tuple2[T1, T2 any] struct {<br/>    V1 T1<br/>    V2 T2<br/>}</span></pre><p id="a69e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在实现一个<code class="fe ls lt lu lv b">Get</code>方法，返回所请求索引的元组值。</p><pre class="kg kh ki kj gt oe lv of og aw oh bi"><span id="f8a5" class="oi me iq lv b gy oj ok l ol om">func (t Tuple2[T1, T2]) Get(index int)</span></pre><p id="3b7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等。结果的类型是什么？<code class="fe ls lt lu lv b">any</code>？这意味着我会失去类型安全。</p><p id="ca3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我简单地尝试了一种方法，其中<code class="fe ls lt lu lv b">Get</code>是泛型的，调用者将把期望的类型传递给函数，但是除了在语法上不受支持之外，这将导致一个奇怪的、不安全的接口。无论如何，我也不能让<code class="fe ls lt lu lv b">Get</code>在运行时安全使用，因为我必须验证索引没有越界。</p><p id="f859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用说，递归实现在这里不是一个好方法。</p><p id="5ddf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令我沮丧的是，我意识到每种元组类型之间没有多少共同点。每种元组类型都必须单独实现。</p><p id="9c36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，手动编写每个元组类型是不可能的。我不打算单独编写和维护N个元组类型。这正是自动化来拯救的地方。</p><h1 id="ada9" class="md me iq bd mf mg nl mi mj mk nm mm mn jw nn jx mp jz no ka mr kc np kd mt mu bi translated">代码生成</h1><p id="29c7" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">然后……我们达到了元编程。</p><p id="63d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写代码写代码很容易变得混乱。为了尽量减少混乱，我选择使用<code class="fe ls lt lu lv b">text/template</code>引擎来生成实际代码。</p><p id="cac3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我编写了一个快速生成脚本，加载一个<code class="fe ls lt lu lv b">.tpl</code>文件，执行它，并将结果转储到一个<code class="fe ls lt lu lv b">.go</code>文件。这个过程要进行多次，每次迭代都是针对元组可以容纳的不同数量的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="809f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还使用了非常酷的嵌入功能！</p><p id="cb67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成脚本后，我开始使用Go模板编写通用元组实现。使用代码生成来支持我计划的特性要容易得多。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/583aac14be07ea3dd48feeca4f6a0288.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*JLyekGzSPqNU1GG_fDOiJQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="oo">摘自</em><strong class="bd op"><em class="oo">tuple . TPL</em></strong>的一个片段</p></figure><p id="8990" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这不是最容易读懂的。您需要了解许多变量(例如，<code class="fe ls lt lu lv b">$typeRef</code>引用当前的元组类型，<code class="fe ls lt lu lv b">.Indexes</code>是元组的基于1的范围片)，并且理解<code class="fe ls lt lu lv b">{{-</code>和<code class="fe ls lt lu lv b">-}}</code>的意义，但是我确信这比从代码中生成更具可读性。另外，VS代码有一些很好的语法突出显示，这有一点帮助。</p><p id="2787" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用代码生成，我能够实现基本的元组特性。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="aa2e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">元组比较</h1><p id="fe2b" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">这就是我们在Go中遇到泛型限制的地方。</p><p id="7075" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从一个简单的tuple的<code class="fe ls lt lu lv b">LessThan</code>函数开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nk"> ( </em> <a class="ae kv" href="https://go.dev/play/p/CMI3-njYgus?v=gotip" rel="noopener ugc nofollow" target="_blank"> <em class="nk">去游乐场</em> </a> <em class="nk"> ) </em></p><p id="f4c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等，这里有一个编译器错误:</p><pre class="kg kh ki kj gt oe lv of og aw oh bi"><span id="805f" class="oi me iq lv b gy oj ok l ol om">invalid operation: cannot compare host.V1 &lt; guest.V1 (operator &lt; not defined on Ty1)</span></pre><p id="e5a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再来说说约束。</p><p id="9355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Ty1</code>和<code class="fe ls lt lu lv b">Ty2</code>都是用<code class="fe ls lt lu lv b">any</code>约束定义的，这意味着调用者可以将他们喜欢的任何类型传递给函数，但不是任何类型都定义了<code class="fe ls lt lu lv b">&lt;</code>操作符。事实上，能做到这一点的种类非常有限。</p><p id="7fcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">约束帮助我们声明除了类型之外，我们还需要哪些功能。它们非常类似于接口。实际上它们也是用关键字<code class="fe ls lt lu lv b">interface</code>定义的。与接口相比，约束的优势在于它们在类型参数上下文中使用，这意味着它们可以接受类型参数。否则你应该直接使用接口。</p><p id="b918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们排除了具有<code class="fe ls lt lu lv b">&lt;</code>操作符的类型。但是怎么才能指定呢？约束不同于接口的另一个方式是支持联合。约束可以简单地表示预定义的类型选择。</p><pre class="kg kh ki kj gt oe lv of og aw oh bi"><span id="209a" class="oi me iq lv b gy oj ok l ol om">type HasLessThanOperator interface {<br/>    int | uint | string | ...<br/>}</span></pre><p id="fe26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，Go 1.18还引入了<code class="fe ls lt lu lv b">constraints</code>包，其中定义了一些基本约束，我们可以在这里找到<code class="fe ls lt lu lv b">Ordered</code>约束。</p><p id="dc7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，<code class="fe ls lt lu lv b">constraints.Ordered</code>被定义为实现排序操作符<code class="fe ls lt lu lv b">&lt;</code>、<code class="fe ls lt lu lv b">&lt;=</code>、<code class="fe ls lt lu lv b">&gt;</code>、<code class="fe ls lt lu lv b">&gt;=</code>、<code class="fe ls lt lu lv b">==</code>的任何(根据定义内置的)类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5dc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nk">(操场链接</em> <a class="ae kv" href="https://go.dev/play/p/EpPJp2YGX1D?v=gotip" rel="noopener ugc nofollow" target="_blank"> <em class="nk">此处</em> </a> <em class="nk"> ) </em></p><p id="467e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">厉害！那有效！</p><p id="042b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果元组拥有一个自定义结构呢？我们不能在Go中为结构实现<code class="fe ls lt lu lv b">&lt;</code>操作符。对于这种情况，让我们定义一个自定义结构可以实现的约束:</p><pre class="kg kh ki kj gt oe lv of og aw oh bi"><span id="e1a8" class="oi me iq lv b gy oj ok l ol om">type Lesser[T any] interface {<br/>    LessThan(guest T) bool<br/>}</span></pre><p id="615a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看实际情况:</p><pre class="kg kh ki kj gt oe lv of og aw oh bi"><span id="b0c0" class="oi me iq lv b gy oj ok l ol om">func LessThan[Ty1 Lesser[Ty1], Ty2 Lesser[Ty2]](<br/>    host, guest T2[Ty1, Ty2]<br/>) bool {<br/>    return host.V1.LessThan(guest.V1) ||<br/>        (!guest.V1.LessThan(host.V1) &amp;&amp; host.V2.LessThan(guest.V2))<br/>}</span></pre><p id="87c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常管用！但是现在我们已经失去了对<code class="fe ls lt lu lv b">constraints.Ordered</code>类型的支持。我们能为这两个约束建立一个联盟吗？然后我们可以类型断言每个值实现什么约束，并根据约束进行比较。</p><pre class="kg kh ki kj gt oe lv of og aw oh bi"><span id="e476" class="oi me iq lv b gy oj ok l ol om">type LesserOrOrdered[T any] interface {<br/>    constraints.Ordered | Lesser[T]<br/>    // compiler error: cannot use main.Lesser[T] in union<br/>    //(main.Lesser[T] contains methods)<br/>}</span></pre><p id="c99d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有。嗯，也许我们还可以用<code class="fe ls lt lu lv b">any</code>？如果该类型没有实现任何约束，那么我们<code class="fe ls lt lu lv b">panic</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="58b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不，再来一次。似乎最好的选择是执行两次<code class="fe ls lt lu lv b">LessThan</code>。一次用于<code class="fe ls lt lu lv b">Ordered</code>类型，一次用于<code class="fe ls lt lu lv b">Lesser</code>类型(显然它们也必须用不同的名称定义)。这是我能想到的最好的了，但还是不够:</p><ul class=""><li id="e072" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">为了进行比较，元组值必须全部为<code class="fe ls lt lu lv b">constraints.Ordered</code>或<code class="fe ls lt lu lv b">Lesser</code>。不能混搭。</li><li id="9e81" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">用户可以为<code class="fe ls lt lu lv b">Ordered</code>类型实现<code class="fe ls lt lu lv b">Lesser</code>约束，但是这会产生开销，而且并不像我希望的那样微不足道(在r/golang 中有关于这个问题的有趣讨论<a class="ae kv" href="https://www.reddit.com/r/golang/comments/pxv3al/comparable_types_in_generic_go_has_anyone_done/" rel="noopener ugc nofollow" target="_blank">)</a></li></ul><p id="2a5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我用来比较的解决方案。我最终使用了一个<code class="fe ls lt lu lv b">Comparable</code>约束而不是<code class="fe ls lt lu lv b">Lesser</code>，并实现了可能的比较操作矩阵。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1eec" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="2f12" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">希望分享这段旅程能帮助你更深入地理解Go泛型是如何工作的，以及它们的局限性。</p><p id="c35b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，Go 1.18仍处于测试阶段，具体来说，泛型功能仍处于非常早期的阶段。我希望将来他们会为这个用例添加更好的支持。</p><p id="73f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有两个我选择不支持的元组特性:获取子元组和元组串联。实现这些特性需要为每种元组类型实现一个由<code class="fe ls lt lu lv b">Add</code>和<code class="fe ls lt lu lv b">Sub</code>函数组成的矩阵。添加这些功能不仅会使包膨胀，而且会使导航和阅读变得非常困难。</p><p id="47c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到开源的<code class="fe ls lt lu lv b">go-tuple</code>包<a class="ae kv" href="https://github.com/barweiss/go-tuple" rel="noopener ugc nofollow" target="_blank"/>。您可以随意浏览它，甚至在您自己的项目中使用它！</p></div></div>    
</body>
</html>