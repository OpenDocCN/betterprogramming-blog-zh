<html>
<head>
<title>Cross-compiling Rust From Mac to Linux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Mac到Linux的交叉编译Rust</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cross-compiling-rust-from-mac-to-linux-7fad5a454ab1?source=collection_archive---------2-----------------------#2022-06-08">https://betterprogramming.pub/cross-compiling-rust-from-mac-to-linux-7fad5a454ab1?source=collection_archive---------2-----------------------#2022-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7bea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我遇到的问题之旅</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0ff9ca97feddd180fa8656843f511f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e489ug_7SlSjR1AN"/></div></div></figure><p id="bb19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在尝试将rust从Mac交叉编译到Linux时，我遇到了一些问题，所以我想我应该为自己和其他感兴趣的人写一个简单的指南。这主要是我自己的发现，可能并不适用于每个人。</p><h1 id="2d63" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">一般步骤</h1><p id="536c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">要从一个平台交叉编译到另一个平台，仅仅使用<code class="fe mk ml mm mn b"><a class="ae mo" href="https://rustup.rs/" rel="noopener ugc nofollow" target="_blank">rustup</a></code>为目标安装标准库通常是不够的。你还必须为平台安装一个链接器，并告诉<code class="fe mk ml mm mn b">rustc</code>在哪里可以找到它。</p><p id="7de7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于某些平台来说，其他依赖项可能也是必要的，但是在本文中，我将集中讨论从Mac到Linux的编译。</p><p id="1aae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，从一个平台编译到另一个平台需要以下步骤:</p><ul class=""><li id="f595" class="mp mq iq kt b ku kv kx ky la mr le ms li mt lm mu mv mw mx bi translated">使用<code class="fe mk ml mm mn b">rustup target add &lt;target&gt;</code>为目标安装标准库</li><li id="f27d" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">为平台安装一个链接器</li><li id="8654" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated"><a class="ae mo" href="https://doc.rust-lang.org/cargo/reference/config.html#target" rel="noopener ugc nofollow" target="_blank">更新货物配置</a>以便<code class="fe mk ml mm mn b">rustc</code>可以找到链接器</li><li id="5f35" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">在编译期间，将<code class="fe mk ml mm mn b">TARGET_CC</code>环境变量设置为链接器可执行文件</li><li id="37c4" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">将目标标志添加到您的构建命令:<code class="fe mk ml mm mn b">cargo build --release --target &lt;target&gt;</code></li></ul><h1 id="b9f6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">选择构建目标</h1><p id="13c5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当选择正确的构建目标时，我需要在<code class="fe mk ml mm mn b">x86_64-unknown-linux-gnu</code>和<code class="fe mk ml mm mn b">x86_64-unknown-linux-musl</code>之间做出选择。</p><p id="73fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">musl</code>目标使用musl C标准库生成一个静态链接的二进制文件，其目标是非常轻量级和简单。静态链接C标准库的好处是，它基本上可以在任何现代Linux操作系统上运行，没有依赖性。缺点是<code class="fe mk ml mm mn b">musl</code>通常比<code class="fe mk ml mm mn b">glibc</code>慢很多，因此对于许多项目来说不是最佳选择。</p><p id="a80e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一方面，<code class="fe mk ml mm mn b">gnu</code>目标产生一个动态链接的二进制文件，它依赖于安装在主机系统上的<code class="fe mk ml mm mn b">glibc</code>。</p><p id="26c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为<code class="fe mk ml mm mn b">glibc</code>通常比<code class="fe mk ml mm mn b">musl</code>快一点，所以我决定选择<code class="fe mk ml mm mn b">gnu</code>目标。但我也会解释如何为<code class="fe mk ml mm mn b">musl</code>目标进行构建。</p><h2 id="8298" class="nd lo iq bd lp ne nf dn lt ng nh dp lx la ni nj lz le nk nl mb li nm nn md no bi translated">角马</h2><p id="d25a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">第一步总是使用<code class="fe mk ml mm mn b">rustup</code>安装标准库。这可以使用<code class="fe mk ml mm mn b">rustup target add x86_64-unknown-linux-gnu</code>简单地完成。</p><p id="aed2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是为了实际编译到给定的目标，我们还需要一个链接器。为此，我们将使用社区提供的自制公式:</p><pre class="kg kh ki kj gt np mn nq nr aw ns bi"><span id="8fa6" class="nd lo iq mn b gy nt nu l nv nw">brew install SergioBenitez/osxct/x86_64-unknown-linux-gnu</span></pre><p id="7252" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在连接器已经安装好了，我们需要告诉<code class="fe mk ml mm mn b">rustc</code>在哪里可以找到它。这可以通过更新<a class="ae mo" href="https://doc.rust-lang.org/cargo/reference/config.html#hierarchical-structure" rel="noopener ugc nofollow" target="_blank">来完成。cargo/config.toml </a>并为目标添加链接器:</p><pre class="kg kh ki kj gt np mn nq nr aw ns bi"><span id="45cb" class="nd lo iq mn b gy nt nu l nv nw">[target.x86_64-unknown-linux-gnu]<br/>linker = "x86_64-unknown-linux-gnu-gcc"</span></pre><p id="706b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在您可能已经能够使用<code class="fe mk ml mm mn b">cargo build --target x86_64-unknown-linux-gnu</code>编译到目标，但是对于许多项目来说，还需要将<code class="fe mk ml mm mn b">TARGET_CC</code>环境变量设置为链接器可执行文件。因此，完整的构建命令可能如下所示:</p><pre class="kg kh ki kj gt np mn nq nr aw ns bi"><span id="92a5" class="nd lo iq mn b gy nt nu l nv nw">TARGET_CC=<!-- -->x86_64-unknown-linux-gnu cargo build --release --target x86_64-unknown-linux-gnu</span></pre><p id="540a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这个！现在可以从Mac交叉编译到Linux了！<br/>请记住，生成的二进制文件是动态链接的，因此您可能需要在主机系统上安装其他依赖项来使可执行文件工作。</p><h2 id="16a0" class="nd lo iq bd lp ne nf dn lt ng nh dp lx la ni nj lz le nk nl mb li nm nn md no bi translated">MUSL</h2><p id="bd09" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">首先，我们需要使用<code class="fe mk ml mm mn b">rustup</code>安装标准库。这可以通过运行<code class="fe mk ml mm mn b">rustup target add x86_64-unknown-linux-musl</code>简单地完成。</p><p id="01bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实际编译到给定的目标，我们还需要一个链接器。为此，我们将使用社区提供的自制配方:</p><pre class="kg kh ki kj gt np mn nq nr aw ns bi"><span id="c679" class="nd lo iq mn b gy nt nu l nv nw">brew install FiloSottile/musl-cross/musl-cross</span></pre><p id="e372" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然已经安装了链接器，我们需要告诉rustc在哪里可以找到它。这可以通过更新<a class="ae mo" href="https://doc.rust-lang.org/cargo/reference/config.html#hierarchical-structure" rel="noopener ugc nofollow" target="_blank">来完成。cargo/config.toml </a>并为目标添加链接器:</p><pre class="kg kh ki kj gt np mn nq nr aw ns bi"><span id="9c82" class="nd lo iq mn b gy nt nu l nv nw">[target.x86_64-unknown-linux-musl]<br/>linker = "x86_64-linux-musl-gcc"</span></pre><p id="cfce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在您可能已经能够使用<code class="fe mk ml mm mn b">cargo build --target x86_64-unknown-linux-musl</code>编译到目标，但是对于许多项目来说，还需要将<code class="fe mk ml mm mn b">TARGET_CC</code>环境变量设置为链接器可执行文件。因此，完整的构建命令可能如下所示:</p><pre class="kg kh ki kj gt np mn nq nr aw ns bi"><span id="1cb4" class="nd lo iq mn b gy nt nu l nv nw">TARGET_CC=x86_64-linux-musl-gcc<!-- --> cargo build --release --target x86_64-unknown-linux-musl</span></pre><p id="1daf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样！现在可以从Mac交叉编译到Linux。</p><p id="818d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">生成的二进制文件是静态链接的，应该可以在大多数现代Linux操作系统上运行。</p></div></div>    
</body>
</html>