<html>
<head>
<title>Swift 5.1 and Combine Memory Management: A Problem?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.1和组合内存管理:一个问题？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-5-1-and-combine-memory-management-a-problem-14a3eb49f7ae?source=collection_archive---------2-----------------------#2019-06-08">https://betterprogramming.pub/swift-5-1-and-combine-memory-management-a-problem-14a3eb49f7ae?source=collection_archive---------2-----------------------#2019-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9b95468332d2bcf0ef5a5e6fd436b985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BC0gFud8cmz1rKh27pKx7g.png"/></div></div></figure><div class=""/><div class=""><h2 id="f758" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">Combine到底需要一个CancelBag吗？</h2></div><p id="d7e9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以我一直在试验Swift 5.1和Combine，苹果新的反应式框架…我相信我发现了一个问题。</p><p id="cfd3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">更新:这个问题存在，但似乎在Xcode 11 Beta 6中已经被修复。</strong></p><p id="d066" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">当CombineTest超出范围时，闭包捕获的所有变量都会被释放。有问题的接收器现在返回AnyCancellable，它自动定义并拆除订阅流</strong>。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="1588" class="lw lx je bd ly lz ma mb mc md me mf mg kk mh kl mi kn mj ko mk kq ml kr mm mn bi translated">设置</h1><p id="2eb8" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">迄今为止，我看到的大多数代码样本都假设Combine自动管理其订阅，并且不需要类似RxSwift的DisposeBag。事实上，这甚至在赫尔曼·班肯关于联合收割机的优秀文章“第一印象”中被提及。</p><blockquote class="mu"><p id="02c1" class="mv mw je bd mx my mz na nb nc nd lo dk translated">首先，在Rx订阅结果中有一个Disposable，它允许你停止订阅，Combine没有这个。相反，如果您不想接收进一步的更新，您可以取消对发布者链的引用。</p></blockquote><p id="2b3b" class="pw-post-body-paragraph kt ku je kv b kw ne kf ky kz nf ki lb lc ng le lf lg nh li lj lk ni lm ln lo im bi translated">联合收割机没有一次性用品是真的。</p><p id="ba71" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不过，它确实有苹果公司所说的可取消功能。</p><h2 id="4f98" class="nj lx je bd ly nk nl dn mc nm nn dp mg lc no np mi lg nq nr mk lk ns nt mm nu bi translated">可取消</h2><p id="2afe" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">当您使用接收器订阅出版商时，您会收到一个用于“管理”订阅的可取消列表:</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6cd4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">反过来，可取消是一个非常简单的协议:</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="87d8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">根据文件，可取消是一个协议，表明一项活动或行动可能被取消。有点自我指涉，但在意料之中。此外，调用<code class="fe ob oc od oe b">cancel()</code>“释放任何分配的资源。”它还会停止诸如计时器、网络访问或磁盘I/O等副作用。</p><p id="a97d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，苹果倾向于暗示，这是一个方便的功能，人们可以在极少数需要的情况下使用它来管理(即取消)订阅，而不是一直需要它。</p><p id="9183" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">更新:Sink现在返回AnyCancellable，当cancel被调用或cancellable定义时，它会自动取消订阅。</strong></p><p id="356c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但事实真的是这样吗？</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="c871" class="lw lx je bd ly lz ma mb mc md me mf mg kk mh kl mi kn mj ko mk kq ml kr mm mn bi translated">实验</h1><p id="90ab" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">看看下面这个类，它基本上是在发布时发出信号的:</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="040c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在来看看下面的合并示例代码:</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="83f3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里我们创建了一个使用两个定义对象的类对象。第一个，<em class="of"> d1，</em>由类本身捕获。</p><p id="db76" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在查看subscribe函数内部，您会看到我已经做了一些设置，使得<em class="of"> d2 </em>被sink闭包捕获。</p><p id="f666" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">运行<code class="fe ob oc od oe b">CombineTest.test()</code>，您将看到以下输出:</p><pre class="nv nw nx ny gt og oe oh oi aw oj bi"><span id="b67f" class="nj lx je oe b gy ok ol l om on">0 2<br/>1 2<br/>2 2<br/>deinit - 1<br/>deinit - 2</span></pre><p id="bc7f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是意料之中的。我们的初始值0打印，随后是1和2，当我们发送它们。</p><p id="9ecf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">还要注意，我们的deinit函数打印两次，一次是在<em class="of"> t </em>超出范围时为<em class="of"> d1 </em>打印，一次是在关闭被释放时为<em class="of"> d2 </em>打印。</p><h2 id="bd73" class="nj lx je bd ly nk nl dn mc nm nn dp mg lc no np mi lg nq nr mk lk ns nt mm nu bi translated">问题是</h2><p id="7b2d" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">现在删除或注释掉<code class="fe ob oc od oe b">t.cancellable?.cancel()</code>语句，重新运行代码，你会发现当<em class="of"> t </em>超出范围时<em class="of"> d1 </em>像以前一样释放，但是<em class="of"> d2 </em>似乎没有这样做:</p><pre class="nv nw nx ny gt og oe oh oi aw oj bi"><span id="5a88" class="nj lx je oe b gy ok ol l om on">0 2<br/>1 2<br/>2 2<br/>deinit - 1</span></pre><p id="1f3a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">将测试更改为:</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b603" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您将看到<em class="of"> d2 </em>似乎仍然没有释放，即使流已经完成。</p><h2 id="ec5d" class="nj lx je bd ly nk nl dn mc nm nn dp mg lc no np mi lg nq nr mk lk ns nt mm nu bi translated">扩展示例</h2><p id="ff40" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">让我们扩展我们的例子，加入一个map闭包，它捕获另一个名为<em class="of"> d3: </em>的Deinit对象</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ce89" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">运行它，当调用cancel时，您会得到类似的结果:</p><pre class="nv nw nx ny gt og oe oh oi aw oj bi"><span id="a177" class="nj lx je oe b gy ok ol l om on">0 3<br/>0 2<br/>1 3<br/>1 2<br/>2 3<br/>2 2<br/>deinit - 3<br/>deinit - 1<br/>deinit - 2</span></pre><p id="59e3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">而下面的时候就不是了:</p><pre class="nv nw nx ny gt og oe oh oi aw oj bi"><span id="e4a2" class="nj lx je oe b gy ok ol l om on">0 3<br/>0 2<br/>1 3<br/>1 2<br/>2 3<br/>2 2<br/>deinit - 1</span></pre><p id="92a5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当<em class="of"> t </em>超出我们测试函数的范围时，sink闭包和map闭包都没有释放。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="8e6a" class="lw lx je bd ly lz ma mb mc md me mf mg kk mh kl mi kn mj ko mk kq ml kr mm mn bi translated">我们有问题吗？</h1><p id="4bd9" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">这不是结论性的，但它似乎指向了Combine的内存管理代码中的一个bug，或者强烈表明Combine订阅确实需要某种形式的内存管理。</p><p id="e901" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">更新:是一个bug。由AnyCancellable修复。</strong></p><p id="354c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">再次引用赫尔曼的话:</p><blockquote class="mu"><p id="4b71" class="mv mw je bd mx my mz na nb nc nd lo dk translated">有趣的是，Combine<strong class="ak">不</strong>依赖于基础类型，事实上，它位于比基础更低的层次。与苹果工程师交谈，听起来他们真的已经优化了这个框架。引用一位苹果工程师的话:“RxSwift和Combine的内存型号差别很大。联合收割机是专为性能而生的。”</p></blockquote><p id="7c2f" class="pw-post-body-paragraph kt ku je kv b kw ne kf ky kz nf ki lb lc ng le lf lg nh li lj lk ni lm ln lo im bi translated">像SwiftUI一样，Combine很大程度上基于结构，并为其大多数操作符使用值语义，尽管主体很大程度上似乎是类。这使得Combine和SwiftUI都非常轻量级，并且避免了大量的内存分配。</p><p id="6d86" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对Combine做同样的事情是有意义的，并允许它避免RxSwift中固有的许多Sink/Disposable链分配。</p><p id="c58b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，如果是这样的话，那么Combine如何知道何时释放它的闭包和其他捕获的数据呢？毕竟，结构没有告诉我们它们何时被释放的定义函数。</p><p id="77af" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">更新:AnyCancellable是一个类，它有一个deinit函数。</strong></p><p id="6e32" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">也就是说，当捕获引用的最后一个值超出范围时，任何被捕获的引用(如闭包)<em class="of">都应该</em>释放。</p><p id="0112" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">或者说，如果一个cancellable有引用语义并在释放时定义了它，那么在上面的例子中，当Cancellable超出范围时，上面的链为什么不释放呢？</p><p id="eeac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一句话:Combine到底需要一个CancelBag吗？</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="8821" class="lw lx je bd ly lz ma mb mc md me mf mg kk mh kl mi kn mj ko mk kq ml kr mm mn bi translated">完成块</h1><p id="50b7" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">这让我很困扰，所以如果你有什么要补充的或者你能帮忙澄清的，请发表评论。</p><p id="a237" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我也会接受提问，但我和苹果以外的其他人一样，仍然在消化他们在2019年WWDC上放弃的一切。</p><p id="408b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">直到下次。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="44d8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">编辑:Xcode 11 Beta 2刚刚退出，并演示了同样的问题。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="ead4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">更多关于Combine和SwiftUI的恶作剧可以在<a class="ae mt" href="https://medium.com/@michaellong/swiftui-101-how-not-to-initialize-bindable-objects-6e539d1b5344" rel="noopener"> SwiftUI 101:如何不初始化可绑定对象</a>中找到。</p></div></div>    
</body>
</html>