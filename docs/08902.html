<html>
<head>
<title>How To Structure Unit Tests in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Rust中构建单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-structure-unit-tests-in-rust-cc4945536a32?source=collection_archive---------3-----------------------#2021-06-24">https://betterprogramming.pub/how-to-structure-unit-tests-in-rust-cc4945536a32?source=collection_archive---------3-----------------------#2021-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a28b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个模块一个模块地揭示技术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a9580e46728bbb5978cef9a48855e89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdIjERckNFi2sO7oTJ3q0g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尼克·西格雷夫在<a class="ae kv" href="https://unsplash.com/s/photos/map?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="7f8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能有另一种编程语言的背景。一开始，使用Rust进行实验和工作可能会令人困惑——尤其是在涉及到模块以及如何组织它们的时候。单元测试也被构造成模块。因此，有一两件事需要了解，以避免可能导致纯粹沮丧的摩擦。毕竟，你只是想把一个单元测试放在对你的项目结构最有意义的地方，但是Rust开始让你面对错误，说它不能解析符号。</p><p id="bfab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们想要探究是什么导致了这种摩擦，以及如何告诉Rust您想要如何组织您的测试！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="000b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">重述:模块代替文件路径</h1><p id="3069" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您可能已经知道，您将项目的各个部分安排在模块中。当然，您在文件中组织您的源代码，但是与其他语言(例如C#、C++或Dart)不同，您不编写由文件路径组成的导入语句。相反，您用关键字<code class="fe mw mx my mz b">use</code>引用另一个模块。同样的组织也适用于单元测试。</p><p id="729c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我写了一篇关于如何用模块构建你的项目的文章，如果你想了解更多，你应该去看看。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2208" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">简单的单元测试</h1><p id="befd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">下面，你会看到一个用Rust编写的典型单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c047" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过声明<code class="fe mw mx my mz b">#[cfg(test)]</code>，如果您使用命令<code class="fe mw mx my mz b">cargo test</code>运行项目，我们将Rust限制为编译以下代码。换句话说，当您编译并运行项目进行调试或发布时，Rust会忽略这些行，从而缩短编译时间！<em class="nc"> </em> <code class="fe mw mx my mz b">#[test]</code>属性为Rust的测试执行标记以下拾取功能。</p><p id="e84d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一部分是模块<code class="fe mw mx my mz b">mod tests</code>,包含您想要以这个名字构建的测试。正如您可能已经猜到的，该模块仅仅作为一种分组机制。但是，您也可以将测试放在模块之外，并在一个组中编写多个测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ce0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当在您的项目上运行<code class="fe mw mx my mz b">cargo test</code>时，所有将运行通过！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7b92" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在目录和文件中构建测试</h1><p id="c9d2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="nc"> Rust Book </em> <a class="ae kv" href="https://doc.rust-lang.org/book/ch11-03-test-organization.html" rel="noopener ugc nofollow" target="_blank">告诉我们</a>应该将单元测试放在与待测试代码相同的文件中。这个位置可能在产品代码的下面，甚至在上面。不利的一面是，您失去了一个概览，以及产品和测试代码之间的清晰分离。此外，文件可能会变得很大，同时包含两者！</p><p id="061f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，您可以将测试放在一个文件中，将生产代码放在另一个文件中。为此，您必须使用模块系统。一旦你理解了这一点，构建你的文件或模块的过程将需要更少的努力。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ff32" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">演练:要测试的模块</h1><p id="dc78" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设我们想出了一个实现一个私有方法的小结构。我们将<code class="fe mw mx my mz b">SomeStructure</code>放在一个名为<code class="fe mw mx my mz b">utils</code>的模块中。文件系统中的结构如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/bee9f80e7fcfa15f3f9bc5c6b9c31e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*ugrwrwW67XZF0eThWUSDsg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:项目结构</p></figure><p id="5c39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到我们将测试放在<code class="fe mw mx my mz b">some_structure_tests.rs</code>中，而不是放在产品代码旁边。但是首先，我们应该看一下代码本身。所以这里是<code class="fe mw mx my mz b">some_structure.rs</code>的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7d18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有<code class="fe mw mx my mz b">some_structure_tests.rs</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4b71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在上面的<em class="nc">图1 </em>中所看到的，我们将这些文件放在与我们的<code class="fe mw mx my mz b">utils</code>模块<em class="nc"> </em>相对应的<code class="fe mw mx my mz b">utils</code>文件夹下(参见模块概述)。这里我们介绍两个模块，<code class="fe mw mx my mz b">some_structure</code>和<code class="fe mw mx my mz b">some_structure_tests</code>，正如我们将它们定义为<code class="fe mw mx my mz b">utils</code>文件夹下的文件一样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9b22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在构建时，我们会看到这些错误消息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9f5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rust告诉我们，在编译测试代码<em class="nc">时，它无法解析<code class="fe mw mx my mz b">some_structure</code>模块的私有元素。所以我们必须解决一个额外的问题！</em></p><p id="8b71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在与关联的生产代码相同的模块中编写，单元测试可以访问私有方法和函数。不幸的是，当我们将测试转移到另一个文件时，我们切断了这种关系，现在我们必须重新建立这种关系。为此，我们使用Rust为子模块提供的特性，子模块可以访问其超级模块的私有部分。为了将<code class="fe mw mx my mz b">some_structure_tests.rs</code>中的<code class="fe mw mx my mz b">some_structure_tests</code>模块定义为<code class="fe mw mx my mz b">some_structure</code>的子模块，我们在<code class="fe mw mx my mz b">some_structure.rs </code>中引入，而不是在<code class="fe mw mx my mz b">utils.rs</code>中。首先，我们调整<code class="fe mw mx my mz b">utils.rs</code>并移除<code class="fe mw mx my mz b">some_structure_tests</code>的线条:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ee89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将删除的两行添加到<code class="fe mw mx my mz b">some_structure</code>，使其成为子模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="35a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在模块的层次结构已经改变。变更前，<code class="fe mw mx my mz b">some_structure_tests</code>是<code class="fe mw mx my mz b">utils</code> <em class="nc">的子模块。</em>现在我们把它作为<code class="fe mw mx my mz b">some_structure</code>的一个子模块来介绍。为了反映层次结构的变化，我们必须调整解决单元测试中<code class="fe mw mx my mz b">some_structure</code>依赖的<code class="fe mw mx my mz b">use</code>路径:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2692" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构建项目时，Rust抱怨它找不到我们定义<code class="fe mw mx my mz b">some_structure_tests</code>模块的文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rust寻找一个<code class="fe mw mx my mz b">some_structure_tests</code>文件夹，确切地说是它如何将<code class="fe mw mx my mz b">utils.rs</code>中的<code class="fe mw mx my mz b">utils</code>模块与<code class="fe mw mx my mz b">utils</code>文件夹连接起来。为了正确显示Rust，我们明确指出了位置。为此，我们使用<code class="fe mw mx my mz b">#[path]</code>属性并再次调整<code class="fe mw mx my mz b">some_structure.rs</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ae3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，一切都准备好了！我们在项目中执行<code class="fe mw mx my mz b">cargo test</code>并检查结果。现在已经通了，所有测试都是绿色的！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7727" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="a3d3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="nc">图2 </em>展示了我们在本文中使用的模块和文件之间的关系，它们的最终关系如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/b11ac324c6d26de25f8e6db355123822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*oJPuAd0ysYXPdTSK59sYYQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:超级模块和子模块的结构</p></figure><p id="1b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们想要将单元测试从产品代码(<code class="fe mw mx my mz b">some_structure</code>)中分离出来时，我们在Rust文件中引入一个子模块(<code class="fe mw mx my mz b">some_structure_tests</code>)，待测试的模块就在这个文件中(<code class="fe mw mx my mz b">some_structure.rs</code>)。这个子模块可以用<code class="fe mw mx my mz b">#[path]</code>属性指向它的相关文件(<code class="fe mw mx my mz b">some_structure_tests.rs</code>)。这种技术保留了访问模块私有元素的能力，同时也使我们能够按照自己的意愿在文件中组织我们的测试。</p><p id="6b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您来自其他编程语言，并且习惯于将测试放在专用文件中，Rust初看起来可能很难——特别是因为<em class="nc"> Rust Book </em>没有提到如何以不同于同一文件的另一种方式构建测试和生产代码。对我来说，这意味着我要花些时间去琢磨，直到有了概念。最后，我可以用对我来说更自然的方式编写我的测试。</p><p id="0fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望我在本文中的发现可以加快您对Rust中处理单元测试的理解。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9fcb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><ul class=""><li id="fc6e" class="ne nf iq ky b kz mr lc ms lf ng lj nh ln ni lr nj nk nl nm bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/ch11-03-test-organization.html" rel="noopener ugc nofollow" target="_blank">https://doc . rust-lang . org/book/ch11-03-test-organization . html</a></li></ul></div></div>    
</body>
</html>