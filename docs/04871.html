<html>
<head>
<title>What’s New in Swift 5.3?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.3有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-swift-5-3-f5584dd4e4ed?source=collection_archive---------10-----------------------#2020-05-18">https://betterprogramming.pub/whats-new-in-swift-5-3-f5584dd4e4ed?source=collection_archive---------10-----------------------#2020-05-18</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="350b" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">可比枚举、多模式catch子句、闭包中不需要self等等</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/1b9c860dc74b1ed0cbae7a39888e021c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDGXYZAIXe2uXuJyUgzSsg.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@alexacea?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alexandru Acea </a>在<a class="ae kw" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><a href="https://raulferrer.dev"><div class="gi gj kx"><img src="../Images/4559de80fb63bfa9a7c3d7a9ceaa962f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JG2ALPF7dH51wuAxTnReEQ.png"/></div></a></figure><p id="cf21" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">Swift 5.3中的新功能(其发布流程由苹果公司于3月25日宣布)可以在代码级别(例如，多模式捕捉、多结尾闭包)和Swift包管理器的使用(添加二进制依赖项或资源)中找到。在这里，我详细介绍了Swift 5.3中的一些新功能(请记住，我们希望在WWDC20上看到Swift 5.3的新测试版，尽管为了测试它，您可以在<a class="ae kw" href="https://swift.org/download/#snapshots" rel="noopener ugc nofollow" target="_blank">Swift.org</a>下载它)。</p><h1 id="6b63" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">枚举的综合“可比”符合性(<a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0266-synthesized-comparable-for-enumerations.md" rel="noopener ugc nofollow" target="_blank"> SE-0266 </a>)</h1><p id="bee8" class="pw-post-body-paragraph ky kz ir la b lb mm js ld le mn jv lg lh mo lj lk ll mp ln lo lp mq lr ls lt ik bi translated">由于这个新的增加，我们可以在没有关联值的<code class="fe mr ms mt mu b">enum</code> s中采用<code class="fe mr ms mt mu b">Comparable</code>协议，或者有关联值但它们采用了<code class="fe mr ms mt mu b">Comparable</code>协议。这样，所实现的是能够使用例如&gt;或&lt;来比较相同<code class="fe mr ms mt mu b">enum</code>的两种情况。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><h1 id="fa50" class="lu lv ir bd lw lx ne lz ma mb nf md me jx ng jy mg ka nh kb mi kd ni ke mk ml bi translated">在上下文通用声明中使用“where”</h1><p id="6072" class="pw-post-body-paragraph ky kz ir la b lb mm js ld le mn jv lg lh mo lj lk ll mp ln lo lp mq lr ls lt ik bi translated">我们希望通过这次修改来消除将<code class="fe mr ms mt mu b">where</code> <strong class="la is"> <em class="nj"> </em> </strong>子句附加到只能引用外部泛型参数的成员声明的限制。例如:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="2715" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">用<strong class="la is"> </strong> Swift 5.3，可以表达为如下:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><h1 id="c02e" class="lu lv ir bd lw lx ne lz ma mb nf md me jx ng jy mg ka nh kb mi kd ni ke mk ml bi translated">“didSet”语义的重新定义(<a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0268-didset-semantics.md" rel="noopener ugc nofollow" target="_blank"> SE-0268 </a>)</h1><p id="d30c" class="pw-post-body-paragraph ky kz ir la b lb mm js ld le mn jv lg lh mo lj lk ll mp ln lo lp mq lr ls lt ik bi translated">在Swift 5.3之前，当使用的<em class="nj">在属性中进行设置时，getter总是被调用来获取该属性的<code class="fe mr ms mt mu b">oldValue</code>(尽管这个值没有被引用)，从而对性能产生影响。在Swift 5.3中，流程的效率已经提高，因为现在如果我们不在<code class="fe mr ms mt mu b">didSet</code>内部调用<code class="fe mr ms mt mu b">oldValue</code>，就不会访问它。</em></p><h1 id="9d4a" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">如果没有给定参考循环，则消除闭合中的“自我使用”(<a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0269-implicit-self-explicit-capture.md" rel="noopener ugc nofollow" target="_blank"> SE-0269 </a>)</h1><p id="222c" class="pw-post-body-paragraph ky kz ir la b lb mm js ld le mn jv lg lh mo lj lk ll mp ln lo lp mq lr ls lt ik bi translated">直到现在，在闭包内部，显式地使用<code class="fe mr ms mt mu b">self</code>是必要的，即使引用循环不会发生。例如:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="350e" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">有了<strong class="la is"> </strong> Swift 5.3，<code class="fe mr ms mt mu b">self</code>可以被删除:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><h1 id="9c04" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">多模式“捕获”条款(<a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0276-multi-pattern-catch-clauses.md" rel="noopener ugc nofollow" target="_blank"> SE-0276 </a>)</h1><p id="a7ab" class="pw-post-body-paragraph ky kz ir la b lb mm js ld le mn jv lg lh mo lj lk ll mp ln lo lp mq lr ls lt ik bi translated">到目前为止，Swift只允许每个<code class="fe mr ms mt mu b">catch</code>块使用一种错误类型，这使得我们可以减少错误处理中的重复代码。也就是说:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="ec72" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">现在有了Swift 5.3，我们可以将两个错误合并到一个<code class="fe mr ms mt mu b">catch</code>块中:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><h1 id="5a57" class="lu lv ir bd lw lx ne lz ma mb nf md me jx ng jy mg ka nh kb mi kd ni ke mk ml bi translated">一种新的“浮动16”型(<a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0277-float16.md" rel="noopener ugc nofollow" target="_blank"> SE-0277 </a></h1><p id="2afd" class="pw-post-body-paragraph ky kz ir la b lb mm js ld le mn jv lg lh mo lj lk ll mp ln lo lp mq lr ls lt ik bi translated">在Swift 5.3中，由于在移动图形、HDR图像和机器学习中的广泛使用，增加了这种新类型。</p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><h1 id="0a85" class="lu lv ir bd lw lx ne lz ma mb nf md me jx ng jy mg ka nh kb mi kd ni ke mk ml bi translated">多个尾随闭包(<a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0279-multiple-trailing-closures.md" rel="noopener ugc nofollow" target="_blank"> SE-0279 </a>)</h1><p id="576b" class="pw-post-body-paragraph ky kz ir la b lb mm js ld le mn jv lg lh mo lj lk ll mp ln lo lp mq lr ls lt ik bi translated"><em class="nj">尾随闭包</em>是指Swift中函数的最后一个参数是一个闭包。在这种情况下，Swift允许您直接在括号内传递这个闭包，而不是作为参数传递:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="66d4" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">在Swift 5.3中，这个选项不局限于函数的最后一个参数，所以现在我们必须在函数中添加多个闭包(简单地通过添加新标签):</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><h1 id="b519" class="lu lv ir bd lw lx ne lz ma mb nf md me jx ng jy mg ka nh kb mi kd ni ke mk ml bi translated">Swift包管理器改进</h1><p id="2e57" class="pw-post-body-paragraph ky kz ir la b lb mm js ld le mn jv lg lh mo lj lk ll mp ln lo lp mq lr ls lt ik bi translated">对于我们这些使用Swift Package Manager创建和导入Swift包的人来说，Swift 5.3提供了一些非常有趣的改进:</p><ul class=""><li id="6494" class="nk nl ir la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated"><strong class="la is">包经理资源(</strong> <a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0271-package-manager-resources.md" rel="noopener ugc nofollow" target="_blank"> <strong class="la is"> SE-0271 </strong> </a> <strong class="la is">)。</strong>现在，Swift软件包可以整合资源(如图像、音频)。不仅如此，还可以应用某些规则来处理这些资源。</li><li id="7db0" class="nk nl ir la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><strong class="la is">包管理器二进制依赖关系(</strong><a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0272-swiftpm-binary-dependencies.md" rel="noopener ugc nofollow" target="_blank"><strong class="la is">SE-0272</strong></a><strong class="la is">)。</strong>您可以使用二进制格式的依赖项，如Firebase或Google Analytics。</li><li id="c496" class="nk nl ir la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><strong class="la is">条件依赖(</strong><a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0273-swiftpm-conditional-target-dependencies.md" rel="noopener ugc nofollow" target="_blank"><strong class="la is">SE-0273</strong></a><strong class="la is">)。</strong>该选项允许根据平台指定添加哪些依赖项。</li><li id="c2ec" class="nk nl ir la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><strong class="la is">本地化资源(</strong><a class="ae kw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0278-package-manager-localized-resources.md" rel="noopener ugc nofollow" target="_blank"><strong class="la is">SE-0278</strong></a><strong class="la is">)。</strong>除了向Swift产品包添加资源的可能性，它们还可以本地化。</li></ul></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><h1 id="50fa" class="lu lv ir bd lw lx ne lz ma mb nf md me jx ng jy mg ka nh kb mi kd ni ke mk ml bi translated">结论</h1><p id="4165" class="pw-post-body-paragraph ky kz ir la b lb mm js ld le mn jv lg lh mo lj lk ll mp ln lo lp mq lr ls lt ik bi translated">Swift 5.3包括代码或Swift包管理级别的有趣改进。但也有其他改进值得期待，例如Swift 5.3将支持Windows等平台和新的<a class="ae kw" href="https://swift.org/blog/additional-linux-distros/" rel="noopener ugc nofollow" target="_blank"> Linux </a>发行版。</p></div></div>    
</body>
</html>