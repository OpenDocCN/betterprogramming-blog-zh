# 为什么应该使用受控组件

> 原文：<https://betterprogramming.pub/controlled-components-are-awesome-and-we-dont-talk-about-it-enough-6bb21ce8256a>

## 他们很棒——而我们对此谈论得不够

![](img/e64e7dc91566fdd4e3c6166ae29d691d.png)

亚历克斯·约马尔([https://pixabay.com/fr/users/yomare-539547/](https://pixabay.com/fr/users/yomare-539547/))

*受控组件*，一个由 [React](https://reactjs.org/) 推广的术语，是简单的组件，它们从赋予它们的属性中获得它们的整个状态，而不是通过保存内部数据。我认为它们是制作一个可维护的 UI 的最重要的成分之一，在 React 社区之外还没有被充分讨论(也许在 it 界也是如此)。受控组件使测试变得更容易，只需很少的额外努力就能提供可定制性，并且本质上是可组合的。

# 什么是受控组件？

受控组件只是其状态由其父组件管理而非内部管理的组件。这是一个简单的想法，但是它确实改变了你创建组件的方式。

为了使本文尽可能与框架无关，我们将尝试用纯 JavaScript 制作我们自己的简单输入组件——它采用一个选择器(显示在 DOM 中的何处插入组件)、一个标签、一个值和一个回调(当输入发生变化时通知它)。

这就是 React、 [Vue](https://vuejs.org/) 、 [Angular](https://angular.io/) 和任何其他 SPA 框架中的组件最终简化成的样子。

让我们考虑一个简单的非受控组件:

类似的受控组件可以写成:

组件根本不更新模型，而不是更新组件内部的模型并在事后通知父组件。相反，组件把对其状态的控制让给了它的父组件，父组件可以随心所欲地处理值。

这个琐碎的例子看起来像是做了很多额外的工作，却没有任何好处——我们只是添加了额外的步骤来做同样的事情。

# 为什么要使用受控元件？

使用受控组件使我们能够以我们想要的任何方式改变组件的内部状态。

例如，考虑如果我们想防止用户在添加无效字符时更改输入会发生什么。

在不受控制的组件示例中，我们需要在内部处理每一种不同类型的验证——因此，如果我们需要模式验证，我们需要将它与最大长度分开添加。

如果我们天真地这样做，它会看起来像这样:

对于受控组件，组件的实现不需要改变，因为父组件决定哪些值可以通过，哪些不可以。

当然，大多数没有受控组件的框架不会这样做，而是提供一个您可以自己编写的验证器函数的通用实现——接受值并返回 true 或 false 的函数。

但这是由受控组件解决的单一症状的单一解决方案。

让我们看一个不同的例子—如果您想在有人输入值时格式化输入，该怎么办？假设我们想为数字添加一个千位分隔符。

对于我们的不受控制的组件示例，我们将这样做:

虽然我们的非受控组件示例变得越来越复杂，但我们最初的受控组件示例可以处理一切，而无需更改。

受控组件不费吹灰之力就给了我们很多功能。通过这种方式，对高层关注点有更好理解的调用者可以处理业务逻辑，而我们的组件可以保持精简并处理与 DOM 交互的低层方面。

# 组件使测试变得容易

测试 UI(在本例中是 DOM)既复杂又耗时。为了说明这一点，考虑一个针对我们之前的未受控组件的简单测试——我们想要测试对`1`的`maxLength`验证。

你不仅需要启动整个浏览器(或者至少是一个模拟的 dom 环境，比如 [jsdom](https://github.com/jsdom/jsdom) )，你还需要不断地进行复杂、容易出错且耗时的 DOM 调用，比如`querySelector`和`triggerEvent`，你还需要知道组件如何工作的内部机制——在这种情况下，它只有一个输入。(即使您使用了为您包装这些操作的测试工具，也需要完成这些操作。)

您需要对输入的每个变化都这样做(模式可能有几十个需要您验证有效性的例子)。

另一方面，对于受控组件，您可以很容易地将测试分成两部分——测试组件是否根据提供给它的更改正确地更新，一旦您相信您的组件在输入时表现正常，您就可以测试`onChange`功能了。不需要启动浏览器会话或进入 DOM 内部。

受控组件在组件的责任和调用者的责任之间定义了一个严格的屏障。反过来，它们消除了测试组件特性的所有排列的需要，让您可以分别测试组件和业务逻辑。

# 权衡

当然，编程中没有免费的午餐，受控组件是有成本的——它们有更多的样板文件。因为不受控制的组件处理它们自己的状态，所以你不需要代码来处理你的父组件的状态。对于简单的用例，这通常是每个应用程序中的大多数，这变得乏味和低效。

它们还会阻止组件最大限度地利用本地 APIs 考虑我们最初验证非法输入`length`和`pattern` *的例子。*

`HTMLInput`元素已经为这些类型的验证提供了内置的 API，它们甚至可能提供额外的优势(例如，在移动设备上，如果你为输入验证提供某种模式，你可以得到不同的键盘)。

该示例应该写成这样:

值得吗？我的经验告诉我，是的。总有那么一点点特性或用例，不适合组件的可用定制。通常，为这种用例同步状态的努力掩盖了重复使用受控组件的样板文件。你的里程可能会有所不同。

# 受控组件不限于表单

大多数关于受控/非受控组件的文章(包括本文)都围绕表单输入展开，但是任何对变化做出反应的东西都可以成为受控组件。

例子包括*可折叠/可折叠*、*列表*、*桌子*，任何真正互动的东西。