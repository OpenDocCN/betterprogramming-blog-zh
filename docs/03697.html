<html>
<head>
<title>Get Your Android Project on the fastlane</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的Android项目走上快车道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/get-your-android-project-on-the-fastlane-279bc88f8d8c?source=collection_archive---------9-----------------------#2020-02-27">https://betterprogramming.pub/get-your-android-project-on-the-fastlane-279bc88f8d8c?source=collection_archive---------9-----------------------#2020-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f018" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">自动化耗时的Android任务，如构建和分发应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bca9241d7501a91bf56ba1e1d7bf4f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F6QkwtROivh5jGAa"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">罗伯特·都德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="18b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，这篇文章是关于用fastlane自动化你的Android开发工作流程的。</p><p id="0196" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会想，“但是，嗯，自动化是通用的，几乎适用于你能想到的任何东西，尤其是在构建软件的时候。所以你能更准确一点吗？”</p><p id="ba80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，我实际上指的是以下几点:</p><ul class=""><li id="c160" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">使用构建变体来指示您的应用程序是运行在测试端点上还是生产端点上</li><li id="459c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">为每个变体分配一个签名配置</li><li id="ca4d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用版本控制方案和工具自动执行版本控制</li><li id="73ce" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用fastlane运行测试；通过Firebase应用程序分发来构建和分发我们的应用程序</li></ul><p id="bf98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，最后一部分将只对Mac OS和Unix用户可用，因为fastlane还不正式支持Windows OS。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="293f" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">构建变体</h1><p id="35f6" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">构建变体是Android的一个强大特性，它允许我们为我们的构建拥有不同的配置。构建变体由构建类型和风格组合而成。我建议你多读一些关于<a class="ae kv" href="https://developer.android.com/studio/build/build-variants" rel="noopener ugc nofollow" target="_blank">构建变体</a>的文章，如果你还没有的话。</p><p id="df73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用Android的经验告诉我，对于一个简化的开发环境，除非企业另有规定，否则至少需要四个版本——例如，高级和免费应用程序版本。我们要实现的构建变体如下:</p><ul class=""><li id="4e84" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">为了我们的日常发展</li><li id="ef2b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">productionDebug</code>:在极端(或不那么极端)的情况下，我们需要用生产数据检查一个bug</li><li id="e1d2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">developmentRelease</code>:该变种将通过Firebase Crashlytics分发给我们的QA团队。它将是我们Play Store版本的复制品——除了它将使用我们的测试服务器。</li><li id="62dd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">productionRelease</code>:播放商店版本</li></ul><p id="641a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，每个构建版本都有自己独特的<code class="fe nk nl nm nn b">applicationId</code>，这意味着您可以将所有四个构建版本作为不同的应用程序同时安装在您的设备上。为了识别哪个是哪个，我将向您展示如何更改它们的名称，这也可以应用于拥有不同的启动器图标。</p><h2 id="cc68" class="no mo iq bd mp np nq dn mt nr ns dp mx lf nt nu mz lj nv nw nb ln nx ny nd nz bi translated">构建类型</h2><p id="fc67" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">当我们创建一个新的Android项目时，我们默认得到两种构建类型，<code class="fe nk nl nm nn b">debug</code> <em class="oa"> </em>和<code class="fe nk nl nm nn b">release</code> <em class="oa">。</em>如果你检查你的app模块的<code class="fe nk nl nm nn b">build.grade</code>，调试被省略。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">默认生成类型</p></figure><p id="de72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果您检查可以在View &gt; Tool Windows下找到的构建变体，并选择Active Build Variant下拉菜单，您将会看到两个变体。Android默认提供<code class="fe nk nl nm nn b">debug</code>构建类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/0dfa7afeb3fd0e947541cc9fdfc0237e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvzvE3FrJ4rZUZK87wLnEQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">默认构建变体</p></figure><p id="ae61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢冗长，所以首先，我们将在Gradle文件中显式定义<code class="fe nk nl nm nn b">debug</code>构建类型。您的文件应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4f5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第4行，我们还提供了一个<code class="fe nk nl nm nn b">applicationIdSuffix</code>。因此，我们的<code class="fe nk nl nm nn b">debug</code>构建将以<code class="fe nk nl nm nn b">.debug</code>为后缀，这意味着如果我们的应用程序ID是<code class="fe nk nl nm nn b">com.example.myapp</code>，那么调试构建将是<code class="fe nk nl nm nn b"> com.example.myapp.debug</code>。</p><h2 id="31db" class="no mo iq bd mp np nq dn mt nr ns dp mx lf nt nu mz lj nv nw nb ln nx ny nd nz bi translated">构建风味</h2><p id="6709" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">构建风格是构建类型的(可选)兄弟。我们将使用两种风格来反映我们的服务器:<code class="fe nk nl nm nn b">development</code>和<code class="fe nk nl nm nn b">production</code>。所以回到你的应用程序的构建Gradle，在我们之前添加的<code class="fe nk nl nm nn b">buildTypes</code>块之前添加以下内容(顺序在这里很重要)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">产品风味</p></figure><p id="6ca9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第1行，我们定义了一个新的维度，<code class="fe nk nl nm nn b">server</code>，它被用作我们的<code class="fe nk nl nm nn b">development</code>和<code class="fe nk nl nm nn b">production</code>风格的维度。我们还为口味定义了<code class="fe nk nl nm nn b">applicationIdSuffix</code>。</p><p id="c71a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，执行Gradle sync，并再次检查构建变体。您应该看到这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/d7fe2642db3d6639ddf2855c50ff1dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5CQcb4cjSXVm4TnZHx75Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">构建变体</p></figure><h2 id="c695" class="no mo iq bd mp np nq dn mt nr ns dp mx lf nt nu mz lj nv nw nb ln nx ny nd nz bi translated"><strong class="ak">应用名称</strong></h2><p id="3dd6" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">既然我们已经有了构建变体集，如果我们为每个变体取一个稍微不同的名字会更方便。所以继续添加三个新的字符串资源文件(右键单击&gt; New &gt; Android Resource File)，每个文件对应一个额外的变体。我们将使用我们的<code class="fe nk nl nm nn b">productionRelease</code>变体的主源集。在显示的对话框中，从源集合下拉列表中选择变体，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/5da7a4fb9c1e3bca52544ac0f40414ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-pqCav8-XRLeT9WD038tA.png"/></div></div></figure><p id="35cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该操作将创建适当的源集合，并将新创建的<code class="fe nk nl nm nn b">strings.xml</code>添加到每个源集合中。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="9577" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">签名配置</h1><p id="2185" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在构建和发布阶段之前，让我们的签名自动化也很重要。为此，我们将使用属性文件来保存关于密钥库文件路径、密钥库密码、密钥别名和密钥密码的信息。该文件的格式如下。</p><p id="a430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">警告:</strong>不要在你的Git中添加这些文件，尤其是如果你决定保留你的Play Store证书的话。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2cb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要签署我们的<code class="fe nk nl nm nn b">releaseDevelopment</code>变体，它将通过Firebase应用程序分发交付给我们的测试团队。现在类似于版本控制部分，我们需要一个函数来解析这些文件中的签名属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">解析签名属性</p></figure><p id="110d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使用这个，我们需要定义一个新的签名配置。仍然在您的Gradle文件中，在Android块内，添加下面的<code class="fe nk nl nm nn b">signingConfigs</code>块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">签名配置</p></figure><p id="de57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，用以下内容更新发布版本类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带签名配置的发布开发</p></figure><p id="e5ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第4行，我们显式地设置了用于<code class="fe nk nl nm nn b">developmentRelease</code>变体的Frebase签名配置。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="1482" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">版本控制</h1><p id="8106" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Android版本控制非常简单，但它根本不是自动化的。为了更新您的<code class="fe nk nl nm nn b">versionCode</code>和<code class="fe nk nl nm nn b">versionName</code>，您必须编辑您的应用程序的<code class="fe nk nl nm nn b">build.gradle</code>并设置所需的值。事实上，这项任务必须由人一次又一次地完成，这使得它很容易出错。对于这个例子来说，版本名称的版本化方案是<code class="fe nk nl nm nn b">major.minor.patch</code>,版本代码的版本号是递增的。</p><p id="8ffd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开您的构建Gradle文件，并在dependencies块下添加以下函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阅读版本</p></figure><p id="2697" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，<code class="fe nk nl nm nn b">readVersion</code>将尝试打开位于根目录中的<code class="fe nk nl nm nn b">version.properties</code>文件，并读取其中的主要、次要、修复和代码属性。如果文件不存在或者属性不存在，则默认为major=1，minor=0，patch=0，code=1。<code class="fe nk nl nm nn b">readVersion</code>的结果用于<code class="fe nk nl nm nn b">readVersionName</code>和<code class="fe nk nl nm nn b">readVersionCode</code>。</p><p id="59a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在继续更新您的<code class="fe nk nl nm nn b">versionCode</code>和<code class="fe nk nl nm nn b">versionName</code>属性。在默认配置中，替换它们的值以匹配以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">默认配置</p></figure><p id="84a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，到目前为止，我们可以从版本属性中读取我们的版本名称和代码，但是为了自动更新它，我们需要能够编写。还添加了以下功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">增加构建版本和分级任务</p></figure><p id="8db5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里提供的代码声明了一个函数<code class="fe nk nl nm nn b">incrementBuildVersion</code>，给定一个参数，它将增加适当的属性并保存到我们的文件中。此外，我们将这个函数封装成四个不同的任务，这样我们就可以通过终端来使用它。</p><p id="420e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开一个终端并键入<code class="fe nk nl nm nn b">./gradlew doBuildNumberIncrement</code>将会触发后面的任务运行，而后者又会调用<code class="fe nk nl nm nn b">incrementBuildVersion</code>。切换到项目视图，您将看到新创建的文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/3beb56eb8dad073794e285e90bef515d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2WXe4E6F58xG4sa8w4s4A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">版本属性</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="2a27" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">测试、构建和分发</h1><h2 id="b9ee" class="no mo iq bd mp np nq dn mt nr ns dp mx lf nt nu mz lj nv nw nb ln nx ny nd nz bi translated">快车道</h2><p id="e8d1" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">fastlane是一个开源的自动化工具，正如其网站上所说，“处理繁琐的任务，这样你就不用做了。”由于它最初是为iOS和Mac OS应用程序中的几个任务的自动化而开发的，fastlane附带了Android的基本功能。作为补偿，它的API是开放的，你可以写自己的代码。</p><p id="afcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装fastlane有几种方法，我会选择通用的方法。fastlane是一块宝石(这意味着它是用Ruby编写的，因此Ruby是您唯一的依赖)。所以打开一个终端键入<code class="fe nk nl nm nn b">sudo gem install fastlane -NV</code>，然后回车。要检查您的安装是否一切正常，键入<code class="fe nk nl nm nn b">fastlane — version</code>，您应该会看到可执行文件的路径和版本。</p><p id="f338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要为我们的项目初始化快车道。为此，你所要做的就是<code class="fe nk nl nm nn b">cd to/your/project/directory</code>，键入<code class="fe nk nl nm nn b">fastlane init</code>，然后按回车键。快车道会问你一些问题，你不妨全部跳过。我们会写自己的球道。</p><h2 id="baac" class="no mo iq bd mp np nq dn mt nr ns dp mx lf nt nu mz lj nv nw nb ln nx ny nd nz bi translated">Firebase应用程序分发</h2><p id="2c04" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">但是在写我们自己的球道之前，还有一件事。实际上是两个。第一个是Firebase CLI，可以通过键入<code class="fe nk nl nm nn b">curl -sL <a class="ae kv" href="https://firebase.tools" rel="noopener ugc nofollow" target="_blank">https://firebase.tools</a> | bash</code>并将其输入到您的终端来安装。</p><p id="4077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要安装Firebase插件，因此移动到您的项目目录并键入<code class="fe nk nl nm nn b">fastlane add_plugin firebase_app_distribution</code>，然后点击enter。</p><p id="7ec2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仍然在您的终端中，键入<code class="fe nk nl nm nn b">firebase login</code>。它将打开您的默认浏览器，并要求您登录您的帐户。我们快到了。</p><p id="2fb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了登录之外，您必须在Firebase控制台中设置一个项目和您的应用程序。如果你还没有，现在是一个好时机。在分发步骤中，我们需要这个应用ID。</p><p id="b74b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于CI/CD构建，您应该使用<code class="fe nk nl nm nn b">firebase login:ci</code>，它将返回一个刷新令牌，您可以稍后在<code class="fe nk nl nm nn b">firebase_app_distribution action</code>中使用它。</p><h2 id="8a72" class="no mo iq bd mp np nq dn mt nr ns dp mx lf nt nu mz lj nv nw nb ln nx ny nd nz bi translated"><strong class="ak">测试、构建和分发</strong></h2><p id="8e68" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">终于，我们到了。让我们写我们的车道，分发我们的应用程序。打开您的快速文件，并替换其内容以匹配以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">快速文件</p></figure><p id="4ba6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我解释一下我们创造的东西。首先在项目目录中打开一个终端，然后键入<code class="fe nk nl nm nn b">fastlane lanes</code>。您应该会看到如下所示的内容:</p><pre class="kg kh ki kj gt oh nn oi oj aw ok bi"><span id="928c" class="no mo iq nn b gy ol om l on oo">--------- android---------<br/>----- <strong class="nn ir">fastlane android test</strong><br/>Runs all the tests</span><span id="9b8b" class="no mo iq nn b gy op om l on oo">----- fastlane android firebase<br/>Submit a new build to firebase app distribution<br/>Usage:<br/><strong class="nn ir">fastlane firebase</strong><br/>Params:<br/>versionChange:"minor|major|patch" to explicitly increase version<br/>notes:"Release notes about the build"<br/>branch:"branch_name" If specified will commit version.properties file and push it to track remote branch</span></pre><p id="5540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我强调了我们感兴趣的两个部分。这是我们的两条路线——第一条是我们运行测试的路线。如果我们键入<code class="fe nk nl nm nn b">fastlane test</code>，我们将看到我们的应用程序正在构建，我们的测试将最终运行。</p><p id="949a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们的测试执行没有任何错误，我们得到一个<code class="fe nk nl nm nn b">fastlane.tools finished successfully 🎉</code>消息，我们就可以开始了。在极少数情况下，我们的测试失败了，除了许多其他日志之外，我们得到一个很好的输出来指示失败的测试，如下所示。</p><pre class="kg kh ki kj gt oh nn oi oj aw ok bi"><span id="f2e7" class="no mo iq nn b gy ol om l on oo">com.max.hackernews.ExampleUnitTest &gt; addition_isCorrect FAILED<br/>    java.lang.AssertionError at ExampleUnitTest.kt:15</span><span id="924e" class="no mo iq nn b gy op om l on oo">1 test completed, 1 failed</span></pre><p id="514e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后一个领域，Firebase，是另一个故事。一步一步地分解，我们注意到，在第一步，我们通过使用我们在版本控制部分定义的任务，在第37-45行增加了构建号。如果为<code class="fe nk nl nm nn b">versionName</code> param提供了minor、major或patch值中的任何一个，那么版本化方案的等效部分将会改变。</p><p id="2eb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在版本更新之后，第47-51行包含构建步骤。在这里，我们指定构建类型和将要构建的风格，并调用assemble任务。输出的<code class="fe nk nl nm nn b">.apk</code>文件可以在<code class="fe nk nl nm nn b">app/build/outputs/development/release</code>目录下找到。</p><p id="a65a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第53行负责我们的发布说明，关于将到达我们的QA团队的构建。如果指定了notes参数，这将是发行说明消息；否则，它会退回到我们最近的提交。</p><p id="6094" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有我们的构建工件，我们有我们的发布说明——剩下的就是把它们全部上传到Firebase。这就是我们在第55-59行所做的。</p><p id="a494" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在通道的第一部分，我们增加了版本号；因此我们修改了<code class="fe nk nl nm nn b">version.properties</code>。第61–68行，如果给定了分支名称，自动与远程分支同步。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="66c0" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">摘要</h1><p id="7a1d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">尽管众所周知，拥有像Jenkins这样的CI/CD工具来运行这些任务是最理想的情况，但是在本地运行这个管道将会令人满意地完成工作。当您获得CI/CD基础结构时，您可以立即将它与这个管道结合起来。</p><p id="aade" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们第一次在我目前工作的地方开始我们的开发团队时，几乎有五个月我们没有Jenkins，fastlane为我们节省了很多时间——它很容易设置，维护根本不是问题。</p></div></div>    
</body>
</html>