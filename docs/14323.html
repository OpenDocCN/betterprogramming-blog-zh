<html>
<head>
<title>Building a TreeTable Using Ant Design System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用蚂蚁设计系统构建树表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-treetable-using-ant-design-system-8048cb93afe3?source=collection_archive---------4-----------------------#2022-11-29">https://betterprogramming.pub/building-a-treetable-using-ant-design-system-8048cb93afe3?source=collection_archive---------4-----------------------#2022-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建树表组件的10个步骤</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/7f7c0d012de336aad257102bce82d5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*PZvCvAHzPUDKnQrv5sK8dg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">照片由<a class="ae ku" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>在<a class="ae ku" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄|图像高度改变</p></figure><p id="2623" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ku" href="https://en.wikipedia.org/wiki/Table_(information)" rel="noopener ugc nofollow" target="_blank">表</a>，也称为数据网格，是行和列中的数据排列，或者可能是更复杂的结构。它是用户界面的重要组成部分。</p><p id="7988" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">TreeTable是支持树状层次结构的表的扩展，通常位于第一列。作为树，层次结构是由父子关系决定的。</p><p id="3862" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们已经介绍了具有排序、过滤、分页、行选择、无限滚动和更多特性的Ant表。在本文中，我们将使用它的嵌套表功能构建一个TreeTable。构建需要十个步骤，你可以一直向下滚动到最后查看最终的源代码。</p><h1 id="4bf7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">建立工作环境</h1><p id="239d" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们使用<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/an-in-depth-guide-for-create-react-app-5-cra-5-b94b03c233f2"> Create React App </a>作为探索TreeTables的基础。以下命令创建一个React项目:</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="a430" class="mt ls it mp b be mu mv l mw mx">% yarn create react-app react-tree-table<br/>% cd react-tree-table</span></pre><p id="3c32" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们安装了三个额外的软件包:</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="3317" class="mt ls it mp b be mu mv l mw mx">% yarn add antd styled-components unique-names-generator</span></pre><ul class=""><li id="4f96" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/understanding-the-ant-design-system-a-ui-design-for-enterprises-39afdb188b06">antd</a></code> : Ant Design System是企业级UI设计语言和React UI库的开源代码。我们使用<code class="fe nh ni nj mp b">antd</code>的Table组件来构建一个TreeTable。</li><li id="14cd" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/styled-components-a-css-in-js-approach-755f6a196c42">styled-components</a></code>:这是一个React特有的CSS-in-JS样式化解决方案，用JavaScript编写CSS代码来样式化组件。我们使用<code class="fe nh ni nj mp b">styled-components</code>来设计TreeTable的样式。</li><li id="6d5d" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b"><a class="ae ku" href="https://github.com/andreasonny83/unique-names-generator" rel="noopener ugc nofollow" target="_blank">unique-names-generator</a></code>:这是一个生成独特且容易记忆的名字字符串的工具。我们使用<code class="fe nh ni nj mp b">unique-names-generator</code>来生成树表内容。</li></ul><p id="5af5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">安装后，这些包成为<code class="fe nh ni nj mp b">package.json</code>中<code class="fe nh ni nj mp b"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/package-jsons-dependencies-in-depth-a1f0637a3129">dependencies</a></code>的一部分:</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="36fc" class="mt ls it mp b be mu mv l mw mx">"dependencies": {<br/>  "antd": "^5.0.0",<br/>  "styled-components": "^5.3.6",<br/>  "unique-names-generator": "^4.7.1"<br/>}</span></pre><p id="132e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">工作环境已经准备好构建一个TreeTable。</p><h1 id="70e3" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">第一步:制作一个平板桌子</h1><p id="32d8" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">TreeTable首先是一个表。让我们从下面的平面表开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/789a6f1c6f41911dad637246bd3d912e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ObVVeSrc77v0pWIijL3rA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="1057" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该表有四列:</p><ul class=""><li id="c196" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">Name</code>:这是一个由颜色、形容词和动物连接而成的名字。名称由<code class="fe nh ni nj mp b">uniqueNamesGenerator</code>生成。</li></ul><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="f226" class="mt ls it mp b be mu mv l mw mx">const createName = () =&gt;<br/>  uniqueNamesGenerator({<br/>    dictionaries: [colors, adjectives, animals],<br/>    style: 'capital',<br/>    separator: ' ',<br/>  });</span></pre><ul class=""><li id="2609" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">County</code>:由<code class="fe nh ni nj mp b">uniqueNamesGenerator</code>生成的国家名称。</li></ul><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="4880" class="mt ls it mp b be mu mv l mw mx">const createCountryName = () =&gt;<br/>  uniqueNamesGenerator({<br/>    dictionaries: [countries],<br/>    style: 'capital',<br/>  });</span></pre><ul class=""><li id="ab7a" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">Add</code>:增加动作是在当前行下增加一个子节点。此时，它是一个没有任何动作的纯链接。</li></ul><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="6ac0" class="mt ls it mp b be mu mv l mw mx">render: () =&gt; &lt;a&gt;Add a child&lt;/a&gt;</span></pre><ul class=""><li id="7e29" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">Remove</code>:删除当前行及其子行的操作。此时，它是一个没有任何动作的纯链接。</li></ul><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="a2da" class="mt ls it mp b be mu mv l mw mx">render: () =&gt; &lt;a&gt;Remove the node&lt;/a&gt;</span></pre><p id="e9e4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们构建一个方法<code class="fe nh ni nj mp b">createNewRow</code>来生成一个新行，它有三个属性<code class="fe nh ni nj mp b">key</code>、<code class="fe nh ni nj mp b">name</code>和<code class="fe nh ni nj mp b">country</code>。</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="0c36" class="mt ls it mp b be mu mv l mw mx">const createNewRow = () =&gt; {<br/>  const name = createName();<br/>  return {<br/>    key: name,<br/>    name,<br/>    country: createCountryName(),<br/>  };<br/>};</span></pre><p id="f6c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">方法<code class="fe nh ni nj mp b">createTableData</code>用于生成具有指定行数的表格数据(<code class="fe nh ni nj mp b">rowCount</code>)。</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="0e46" class="mt ls it mp b be mu mv l mw mx">const createTableData = (rowCount) =&gt;<br/>  Array(rowCount)<br/>    .fill(1)<br/>    .map(() =&gt; createNewRow());</span></pre><p id="ae64" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">将<code class="fe nh ni nj mp b">src/App.js</code>修改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="2a6d" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">在第40行，创建了包含10行的初始表。</li><li id="c473" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第42–64行，定义了表<code class="fe nh ni nj mp b">columns</code>。</li><li id="8358" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第67–71行，app返回一个表格组件，关闭<code class="fe nh ni nj mp b">pagination</code>(第68行)，设置<code class="fe nh ni nj mp b">columns</code>(第69行)和<code class="fe nh ni nj mp b">dataSource</code>(第70行)。</li></ul><p id="0670" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行<code class="fe nh ni nj mp b">yarn start</code>，我们看到一个平面表。</p><h1 id="486d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤2:实现添加子操作</h1><p id="98fc" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">要有一个TreeTable，我们需要实现<code class="fe nh ni nj mp b">Add a child</code>动作。单击单元格时，会在当前行下创建一个子节点。</p><p id="1d8f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是修改后的<code class="fe nh ni nj mp b">columns</code>表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="6af1" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">在第14–25行，添加了<code class="fe nh ni nj mp b">onCell</code>属性，为单元格设置属性。道具之一可以是<code class="fe nh ni nj mp b">onClick</code>回调(第16–23行)。它还将当前行的<code class="fe nh ni nj mp b">record</code>作为参数传入(第14行)。</li><li id="57fe" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在<code class="fe nh ni nj mp b">antd</code>中，如果其<code class="fe nh ni nj mp b">record</code>的<code class="fe nh ni nj mp b">children</code>属性是一个记录数组(对于动态加载可以是一个空数组)，则一个表格行是一个父行。</li><li id="7bf7" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第18行，<code class="fe nh ni nj mp b">record.children</code>被设置为<code class="fe nh ni nj mp b">[]</code>，如果它还没有初始化的话。</li><li id="2c1a" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第21行，新生成的行被添加到<code class="fe nh ni nj mp b">record.children</code>。正如我们通过改变<code class="fe nh ni nj mp b">record.children</code>来改变<code class="fe nh ni nj mp b">tableData</code>一样，调用<code class="fe nh ni nj mp b">setTableData</code>来更新引用。</li></ul><p id="7e7a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行<code class="fe nh ni nj mp b">yarn start</code>。单击第一行的<code class="fe nh ni nj mp b">Add a child</code>，我们会看到一个<code class="fe nh ni nj mp b">+</code>图标出现。表示<code class="fe nh ni nj mp b">Tomato Outdoor Impala</code>是父母。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/278c967c4f14ece9bc4c92cd66714a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GckddqaHipZiv2jgYQboBA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="f7e3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">再次点击第一行的<code class="fe nh ni nj mp b">Add a child</code>，没有任何反应。新添加的孩子隐藏在<code class="fe nh ni nj mp b">+</code>图标后面。</p><p id="7e16" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们希望展开一个父节点，使新添加的行可见。这就引出了下一步。</p><h1 id="addf" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤3:展开活动父节点</h1><p id="efbd" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们如何展开父节点？</p><p id="51c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Table有一个<code class="fe nh ni nj mp b">expandable</code>属性来控制打开哪些父表。<code class="fe nh ni nj mp b">expandable</code>是一个子表，甚至可以有一个独立的列标题。对于TreeTable，不需要子表的列标题。相反，以下配置属性是相关的:</p><ul class=""><li id="af11" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">defaultExpandAllRows</code>:指定是否初始展开所有行，默认值为false。</li><li id="4817" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">defaultExpandedRowKeys</code>:指定初始展开的行键，类型为<code class="fe nh ni nj mp b">string[]</code>。</li><li id="9e82" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">expandedRowClassName</code>:指定展开行的<code class="fe nh ni nj mp b">className</code>，类型为<code class="fe nh ni nj mp b">function(record, index, indent): string</code>。</li><li id="6b49" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">expandedRowKeys</code>:指定节点打开的行键，类型为<code class="fe nh ni nj mp b">string[]</code>。</li><li id="86fe" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">expandIcon</code>:定制行扩展图标，类型为<code class="fe nh ni nj mp b">function({ expanded, onExpand, record })): ReactNode</code>。</li><li id="3de2" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">indentSize</code>:指定一个子树的缩进大小，类型为<code class="fe nh ni nj mp b">number</code>。</li><li id="9b1c" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">onExpand</code>:点击行扩展图标时调用的回调函数。其类型为<code class="fe nh ni nj mp b">function(expanded, record)</code>。</li><li id="f608" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">onExpandedRowsChange</code>:是一个回调函数，当展开的行发生变化时调用。它的型号是<code class="fe nh ni nj mp b">function(expandedRows)</code>。</li></ul><p id="e88b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在TreeTable中，<code class="fe nh ni nj mp b">expandedRowKeys</code>用于控制树节点是否展开。在<code class="fe nh ni nj mp b">expandedRowKeys</code>中有键的行被展开。否则，这些行将被折叠。因为我们控制了<code class="fe nh ni nj mp b">expandedRowKeys</code>，所以每当用户单击一个行扩展图标时，它的值都需要被管理。</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="74cb" class="mt ls it mp b be mu mv l mw mx">expandable={{<br/>  expandedRowKeys,<br/>  onExpandedRowsChange: (expandedRows) =&gt; {<br/>    setExpandedRowKeys(expandedRows);<br/>  },<br/>}}</span></pre><p id="0391" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是改进后的<code class="fe nh ni nj mp b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="09d0" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">在第8行，创建了州名<code class="fe nh ni nj mp b">expandedRowKeys</code>。</li><li id="a528" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第32行，新添加的孩子的父关键字被添加到<code class="fe nh ni nj mp b">expandedRowKeys</code>。</li><li id="56ef" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第52–57行，定义了表格的<code class="fe nh ni nj mp b">expandable</code>属性。</li></ul><p id="7149" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行<code class="fe nh ni nj mp b">yarn start</code>。每当我们添加一个子节点时，父节点就会自动展开。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/d2fc3333b9613d6de3797b0886b65db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CONPjU8mn6khxiRKa9XQiA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="fa69" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以看到更多的孩子。但是，加了几个孩子之后，我们就搞不清哪个是新加的了。TreeTable需要进一步改进。</p><h1 id="ce37" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">第4步:突出显示新添加的孩子</h1><p id="f146" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">有许多方法可以设置行的样式。为了简单起见，我们使用表的<code class="fe nh ni nj mp b">rowSelection</code>来突出显示新添加的行。如果配置了工作台的<code class="fe nh ni nj mp b">rowSelection</code>属性，则选中的行会高亮显示。在<code class="fe nh ni nj mp b">rowSelection</code>的众多道具中，我们设定了其中的两个:</p><ul class=""><li id="8aa5" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">selectedRowKeys</code>:指定选中的行键，类型为<code class="fe nh ni nj mp b">string[]</code>。</li><li id="f384" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">type</code>:指定类型，不是<code class="fe nh ni nj mp b">checkbox</code>就是<code class="fe nh ni nj mp b">radio</code>。默认值为<code class="fe nh ni nj mp b">checkbox</code>。</li></ul><p id="a068" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们为<code class="fe nh ni nj mp b">rowSelection</code>选择<code class="fe nh ni nj mp b">radio</code>，因为<code class="fe nh ni nj mp b">radio</code>不允许多选。</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="b0b8" class="mt ls it mp b be mu mv l mw mx">rowSelection={{ selectedRowKeys, type: 'radio' }}</span></pre><p id="281e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这纯粹是黑。或者，我们可以使用<code class="fe nh ni nj mp b">className</code>突出显示该行。可以根据其键是否等于将在下一步中定义的<code class="fe nh ni nj mp b">newRowKey</code>来有条件地设置<code class="fe nh ni nj mp b">className</code>。</p><p id="e2d7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是修改后的<code class="fe nh ni nj mp b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="3be8" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">在第9行，创建了状态<code class="fe nh ni nj mp b">selectedRowKeys</code>。</li><li id="5bd3" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第34行，新创建的子密钥被添加到<code class="fe nh ni nj mp b">selectedRowKeys</code>。</li><li id="a23f" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第52行，定义了表格的<code class="fe nh ni nj mp b">rowSelection</code>属性。</li><li id="4e3e" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第59行，当用户单击行扩展图标时，清除高亮显示。</li></ul><p id="a0b0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行<code class="fe nh ni nj mp b">yarn start</code>。新添加的孩子被突出显示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/5b1e4b7aa591d99822e28f1cc3072bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jv5TT5oYWxj2Q53N6qQrZw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="d323" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们继续添加更多的孩子，最终，新添加的孩子就看不见了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/10c222d3630727fe78ae39c768612dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yngldiCO_mf6MgFAg7mNQA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="0175" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们需要另一项改进。</p><h1 id="4092" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤5:将新添加的孩子滚动到视图中</h1><p id="33bd" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">JavaScript元素有一个方法<code class="fe nh ni nj mp b">scrollIntoView()</code>，该方法滚动其祖先的容器以使元素可见。</p><p id="44d0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它有三种格式:</p><ul class=""><li id="e29b" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">scrollIntoView()</code>:没有参数，滚动到祖先容器的顶部。</li><li id="ba8a" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">scrollIntoView(alignToTop)</code> : <code class="fe nh ni nj mp b">alignToTop</code>为布尔值。如果为true，则滚动到祖先容器的顶部。否则，它将滚动到祖先容器的底部。</li><li id="4ea4" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">scrollIntoView(scrollIntoViewOptions)</code> : <code class="fe nh ni nj mp b">scrollIntoViewOptions</code>是具有以下属性的对象:<br/>–<code class="fe nh ni nj mp b">behavior</code>:定义过渡动画，可以是<code class="fe nh ni nj mp b">auto</code>或<code class="fe nh ni nj mp b">smooth</code>，默认值为<code class="fe nh ni nj mp b">auto</code>。<br/>–<code class="fe nh ni nj mp b">block</code>:定义垂直对齐，可以是<code class="fe nh ni nj mp b">start</code>、<code class="fe nh ni nj mp b">center</code>、<code class="fe nh ni nj mp b">end</code>或<code class="fe nh ni nj mp b">nearest</code>，默认值为<code class="fe nh ni nj mp b">start</code>。<br/>–<code class="fe nh ni nj mp b">inline</code>:定义水平对齐，可以是<code class="fe nh ni nj mp b">start</code>、<code class="fe nh ni nj mp b">center</code>、<code class="fe nh ni nj mp b">end</code>或<code class="fe nh ni nj mp b">nearest</code>，默认值为<code class="fe nh ni nj mp b">nearest</code>。</li></ul><p id="1035" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj mp b">scrollIntoView(true)</code>相当于<code class="fe nh ni nj mp b">scrollIntoViewOptions({block: "start", inline: "nearest"})</code>。<code class="fe nh ni nj mp b">scrollIntoView(false)</code>相当于<code class="fe nh ni nj mp b">scrollIntoViewOptions({block: "end", inline: "nearest"})</code>。</p><p id="6b8e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用<code class="fe nh ni nj mp b">scrollIntoView</code>，可以将新添加的孩子滚动到视图中。</p><p id="0761" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是修改后的<code class="fe nh ni nj mp b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="ab0b" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">在第9行，创建了状态<code class="fe nh ni nj mp b">newRowKey</code>。</li><li id="97fe" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第12-19行，当<code class="fe nh ni nj mp b">newRowKey</code>改变时<code class="fe nh ni nj mp b">useEffect</code>被调用。它找到新添加的行元素(第14–16行)，并调用<code class="fe nh ni nj mp b">scrollIntoView</code>(第17行)将其滚动到视图中。</li><li id="0284" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第44行，用新添加的孩子的<code class="fe nh ni nj mp b">key</code>更新<code class="fe nh ni nj mp b">newRowKey</code>。</li><li id="1c25" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第71行，在行扩展改变时清除<code class="fe nh ni nj mp b">newRowKey</code>。</li></ul><p id="b871" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行<code class="fe nh ni nj mp b">yarn start</code>。持续点击行上的<code class="fe nh ni nj mp b">Add a child</code>、<code class="fe nh ni nj mp b">Olive Personal Owl</code>，新添加的孩子总是在视野中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nw"><img src="../Images/170cf11a1fd4840cd83fcb72582596b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nI1MtQwj4EOKQgM-T27d8Q.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h1 id="2520" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤6:实现删除节点操作</h1><p id="a431" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们有<code class="fe nh ni nj mp b">Add a child</code>在工作。下一步是让<code class="fe nh ni nj mp b">Remove the node</code>发挥作用。</p><p id="a33b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj mp b">removeRowFromTableData</code>是一个从输入列表<code class="fe nh ni nj mp b">data</code>中删除带有特定<code class="fe nh ni nj mp b">key</code>的行的方法。这种方法有两个用例:</p><ul class=""><li id="5f75" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">如果某行没有父行，则该行将从表数据中删除。在这种情况下，数据是<code class="fe nh ni nj mp b">tableData</code>。</li><li id="2d09" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">如果某行有父行，则该行将从其父行的子列表中移除。这种情况下，数据是<code class="fe nh ni nj mp b">record.parent.children</code>。</li></ul><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="5f6a" class="mt ls it mp b be mu mv l mw mx">const removeRowFromTableData = (data = [], key) =&gt; {<br/>  if (key) {<br/>    const index = data.findIndex((item) =&gt; item.key === key);<br/>    if (index !== -1) {<br/>      data.splice(index, 1);<br/>    }<br/>  }<br/>};</span></pre><p id="32fd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是修改后的表格<code class="fe nh ni nj mp b">columns</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="2339" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">要知道<code class="fe nh ni nj mp b">record.parent</code>,<code class="fe nh ni nj mp b">Add</code>列<code class="fe nh ni nj mp b">onCell</code>的<code class="fe nh ni nj mp b">onClick</code>回调(第14–29行)为新添加的孩子(第21行)保存了一个父引用。</li><li id="6de4" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第36–55行，<code class="fe nh ni nj mp b">Remove</code>列添加了<code class="fe nh ni nj mp b">onCell</code>属性。它的回调函数<code class="fe nh ni nj mp b">onClick</code>处理移除操作。如果<code class="fe nh ni nj mp b">record</code>有一个父节点，它将从父节点的子节点列表中移除(第41行)。否则，从<code class="fe nh ni nj mp b">tableData</code>(第46行)中删除。</li><li id="d20f" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第42–44行，它删除了一个空的<code class="fe nh ni nj mp b">children</code>。这将删除父节点的扩展图标。</li><li id="d56c" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第48–52行，组件的状态被更新:<br/>–<code class="fe nh ni nj mp b">tableData</code>被更新为一个新的引用(第48行)。<br/>–<code class="fe nh ni nj mp b">expandedRowKeySet</code>通过删除<code class="fe nh ni nj mp b">record.key</code>(第49–50行)进行更新。<br/>–<code class="fe nh ni nj mp b">newRowKey</code>更新为<code class="fe nh ni nj mp b">undefined</code>(第51行)。<br/>–<code class="fe nh ni nj mp b">selectedRowKeys</code>更新为<code class="fe nh ni nj mp b">[]</code>(第52行)。</li></ul><p id="42fb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行<code class="fe nh ni nj mp b">yarn start</code>。点击某一行上的<code class="fe nh ni nj mp b">Remove the node</code>，该行及其子行(如果有)将被删除。</p><h1 id="4ab4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤7:为可树表的子对象实现有角度的线条</h1><p id="48ca" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">这是一个展开了多个父节点的树表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nw"><img src="../Images/3a06d45a9874ea454683b41f92284425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ubalfP5qLfMHqQJ44j5jtA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="3c49" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当列表很长时，将父母和他们的孩子联系起来可能并不简单。我们想要添加从父母指向他们的孩子的有角度的线。</p><p id="3d7c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里是图标，<code class="fe nh ni nj mp b">EnterOutlined</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/8195b6b475a8a484a8e36dbf80b8cdcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*N0CeLYFHtngTIgOaJ93mlw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="958c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们沿着x轴翻转它，以显示从父节点到每个子节点的关联。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ae61a7288efafb7c1a80aed6cf4b404d.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*2D8E_A5wfEl7-nnkCbLI9g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="b7ce" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里是<code class="fe nh ni nj mp b">src/App.js</code>与角度线的变化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="cd3a" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">在第8–22行，定义了一个<code class="fe nh ni nj mp b">Container</code>来托管第60行的表。<code class="fe nh ni nj mp b">Container</code>确保内容不换行。如果溢出部分没有足够的空间，它将被隐藏并显示一个椭圆。</li><li id="1c96" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第24–33行，图标<code class="fe nh ni nj mp b">EnterOutlined</code>沿x轴翻转成一条有角度的线。</li><li id="519a" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第46–51行，<code class="fe nh ni nj mp b">render</code>被添加到<code class="fe nh ni nj mp b">Name</code>列。如果<code class="fe nh ni nj mp b">record</code>有一个父节点，那么<code class="fe nh ni nj mp b">FlippedEnterIcon</code>会被添加到名字的前面(第48行)。</li></ul><p id="ee5a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行<code class="fe nh ni nj mp b">yarn start</code>。使用有角度的线，父子关系看起来更清晰。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/7f2c15d687e66247cf148b78d0a653a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJN7UzQ7MF-a9-s5hjumuQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h1 id="b07c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤8:实现TreeTable的总计数</h1><p id="2caf" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">对于部分展开的TreeTable，很难判断有多少行(节点)。如果显示总数会有所帮助。</p><p id="0b76" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们需要一种计算计数的方法。</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="fb23" class="mt ls it mp b be mu mv l mw mx">const getTableRowCount = (data = []) =&gt;<br/>  data.reduce(<br/>    (count, item) =&gt;<br/>      item.children ? count + getTableRowCount(item.children) + 1 : count + 1,<br/>    0<br/>  );</span></pre><p id="24cf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是更新后的<code class="fe nh ni nj mp b">App</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="0848" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">在第6行，创建了状态<code class="fe nh ni nj mp b">tableNodeCount</code>。</li><li id="078b" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第10行，当<code class="fe nh ni nj mp b">tableData</code>改变时<code class="fe nh ni nj mp b">useEffect</code>被调用。它重新计算计数并更新<code class="fe nh ni nj mp b">tableNodeCount</code>。</li><li id="5e92" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第18–22行，定义了表格的<code class="fe nh ni nj mp b">footer</code>属性，其中显示<code class="fe nh ni nj mp b">tableNodeCount</code>(第20行)。</li><li id="072a" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第34行，最大垂直高度被设置为<code class="fe nh ni nj mp b">700px</code>，以保持<code class="fe nh ni nj mp b">footer</code>可见。</li></ul><p id="2439" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行<code class="fe nh ni nj mp b">yarn start</code>。将显示总计数，无论树节点是展开还是折叠，总计数都不会改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/7ceeddc720bf43e8f295760e1d9184e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zn70Llv0ih-iei8eEcCuQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h1 id="fcb4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤9:实现全部打开和全部折叠按钮</h1><p id="da84" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">树表中还缺少什么吗？</p><p id="13da" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">是的，如果我们有<code class="fe nh ni nj mp b">Open All</code>和<code class="fe nh ni nj mp b">Collapse All</code>按钮来一键打开或折叠所有的树节点就好了。</p><p id="7d4b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">点击<code class="fe nh ni nj mp b">Collapse All</code>按钮清除所有状态。</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="c96c" class="mt ls it mp b be mu mv l mw mx">&lt;ButtonAction<br/>  onClick={() =&gt; {<br/>    setExpandedRowKeys([]);<br/>    setSelectedRowKeys([]);<br/>    setNewRowKey();<br/>  }}<br/>&gt;<br/>  Collapse All<br/>&lt;/ButtonAction&gt;</span></pre><p id="d9da" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj mp b">Open All</code>按钮需要一个方法来获取所有的父节点键。</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="cf07" class="mt ls it mp b be mu mv l mw mx">const getAllParentNodeKeys = (data = []) =&gt;<br/>  data.reduce(<br/>    (list, item) =&gt;<br/>      item.children<br/>        ? [...list, item.key, ...getAllParentNodeKeys(item.children)]<br/>        : list,<br/>    []<br/>  );</span></pre><p id="23c3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么它可以定义如下:</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="2141" class="mt ls it mp b be mu mv l mw mx">&lt;ButtonAction<br/>  onClick={() =&gt; {<br/>    setExpandedRowKeys(getAllParentNodeKeys(tableData));<br/>    setSelectedRowKeys([]);<br/>    setNewRowKey();<br/>  }}<br/>&gt;<br/>  Open All<br/>&lt;/ButtonAction&gt;</span></pre><p id="2f58" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下是完整的<code class="fe nh ni nj mp b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="f9d1" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">在第29–31行，它设计了一个动作按钮，在左侧有一个<code class="fe nh ni nj mp b">10px</code>间距。</li><li id="abd6" class="my mz it kx b ky nk lb nl le nm li nn lm no lq nd ne nf ng bi translated">在第184–206行，<code class="fe nh ni nj mp b">footer</code>包括<code class="fe nh ni nj mp b">Open All</code>按钮(第187–195行)和<code class="fe nh ni nj mp b">Collapse All</code>按钮(第196–204行)。</li></ul><p id="a8a7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行<code class="fe nh ni nj mp b">yarn start</code>。<code class="fe nh ni nj mp b">Open All</code>和<code class="fe nh ni nj mp b">Collapse All</code>按钮在<code class="fe nh ni nj mp b">footer</code>可用，连同总计数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/71671081f695cec5096f268e299c1337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmU2tcRkmh0rn8DLpxvmAw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h1 id="eafd" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">第十步:分解成不同的文件</h1><p id="2c7c" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">上面的TreeTable代码可以工作，但是它违反了设计原则，关注点分离。我们应该将长的<code class="fe nh ni nj mp b">src/App.js</code>分成不同的部分，每一部分解决一个单独的问题。</p><p id="d3e6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们把上面的<code class="fe nh ni nj mp b">src/App.js</code>分解成三个文件。</p><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="cc1b" class="mt ls it mp b be mu mv l ny mx">src<br/>├── App.js<br/>├── TreeTable.js<br/>└── utils.js</span></pre><ul class=""><li id="bee5" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">src/App.js</code>:这是一个使用TreeTable组件的应用程序。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="be20" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">src/utils.js</code>:这是一个提供帮助器方法的util集合。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="21c5" class="my mz it kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated"><code class="fe nh ni nj mp b">src/TreeTable</code>:是TreeTable实现。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="94c5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">完整的示例位于<a class="ae ku" href="https://github.com/JenniferFuBook/react-tree-table" rel="noopener ugc nofollow" target="_blank">这个资源库</a>中，这里有一个<a class="ae ku" href="https://jenniferfubook.github.io/react-tree-table/?path=/story/tree-table-story--tree-table-story" rel="noopener ugc nofollow" target="_blank">故事书链接</a>用于现场演示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nz"><img src="../Images/2e0d90f84da3db90023c9f8fc749bfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70kaH7QGj_PHRuBfU-tH-Q.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="5cf1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/build-advanced-react-input-fields-using-styled-components-and-storybook-js-a231b9b2438#e765-bf98276875df">本文</a>描述了如何设置storybook来显示组件，以及如何通过GitHub页面将它放到网上。</p><h1 id="fa4b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="c8e6" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">使用Ant Design System的嵌套表功能构建一个树表需要十个步骤。TreeTable可以在当前行下添加子级。添加子节点时，父节点将自动打开。新添加的孩子被突出显示(从单选按钮中选择)并滚动到视图中。删除一行将删除该行及其所有子行(如果有)。</p><p id="d5c5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">TreeTable页脚显示节点总数，无论这些树节点是打开的还是折叠的。页脚也有按钮<code class="fe nh ni nj mp b">Open All</code>和<code class="fe nh ni nj mp b">Collapse All</code>所有树节点。</p><p id="71b6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢阅读。</p><blockquote class="oa ob oc"><p id="06db" class="kv kw od kx b ky kz ju la lb lc jx ld oe lf lg lh of lj lk ll og ln lo lp lq im bi translated">感谢李依琳、S·斯里拉姆、苏什米塔·艾萨、彭德里·拉克西米·普拉桑纳和悉达多·钦塔帕利与我一起在“树桌”上工作。</p></blockquote><pre class="kj kk kl km gt mo mp mq bn mr ms bi"><span id="ba2f" class="mt ls it mp b be mu mv l ny mx"><strong class="mp iu">Want to Connect?</strong><br/><br/>If you are interested, check out <a class="ae ku" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">my directory of web development articles</a>.</span></pre></div></div>    
</body>
</html>