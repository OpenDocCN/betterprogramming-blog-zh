<html>
<head>
<title>What Are JavaScript Constructor Functions?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是JavaScript构造函数？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-javascript-constructor-functions-f10f58e5ad7a?source=collection_archive---------4-----------------------#2019-12-19">https://betterprogramming.pub/what-are-javascript-constructor-functions-f10f58e5ad7a?source=collection_archive---------4-----------------------#2019-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f2e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解返回函数的函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dc91da68bd9d69570aebf4df206c7d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wGpOknSHqk4_vRig"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，函数可以用作创建其他对象的模板。这些函数称为构造函数，具有不同于常规函数的特殊属性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d257" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义构造函数</h1><p id="b22e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以用关键字<code class="fe mz na nb nc b">new</code>调用它们，从构造函数中构造一个对象的新实例。</p><p id="2cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它们不同于常规函数，因为它们的名称应该以大写字母开头。</p><p id="32c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构造函数的一个简单示例如下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1f6c" class="nh md it nc b gy ni nj l nk nl">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}</span></pre><p id="8bda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，我们使用了<code class="fe mz na nb nc b">function</code>关键字来定义构造函数。我们需要使用它，因为箭头函数不能用来定义构造函数。</p><p id="2ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">this</code>是一个对象，拥有由<code class="fe mz na nb nc b">new</code>关键字创建的对象实例的数据。</p><p id="d0a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个函数，我们可以通过编写以下内容来创建一个新的<code class="fe mz na nb nc b">Person</code>对象:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1655" class="nh md it nc b gy ni nj l nk nl">let person = new Person('Joe', 10);</span></pre><p id="c5a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">Person</code>函数中，<code class="fe mz na nb nc b">this.name</code>和<code class="fe mz na nb nc b">this.age</code>是使用<code class="fe mz na nb nc b">new</code>操作符创建的对象实例的属性。</p><p id="4652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">person</code>对象的<code class="fe mz na nb nc b">this.name</code>的值为<code class="fe mz na nb nc b">'Joe'</code>，而<code class="fe mz na nb nc b">this.age</code>的值为10。</p><p id="e9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们通过编写……来创建另一个<code class="fe mz na nb nc b">Person</code>对象的实例</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f853" class="nh md it nc b gy ni nj l nk nl">let jane = new Person('Jane', 11);</span></pre><p id="7d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…那么<code class="fe mz na nb nc b">jane </code>对象的<code class="fe mz na nb nc b">this.name</code>将具有值<code class="fe mz na nb nc b">'Jane'</code>，而<code class="fe mz na nb nc b">this.age</code>将具有值11。</p><p id="8b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Person</code>构造函数的每个实例都有自己的属性值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e45" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构造函数中的方法</h1><p id="9473" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了让用构造函数创建的对象实例做一些事情，我们可以向它添加方法。</p><p id="70a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过编写以下代码在构造函数中定义方法:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0eaf" class="nh md it nc b gy ni nj l nk nl">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>  this.greet = function(){<br/>   return `Hi ${this.name}`;<br/>  }<br/>}</span></pre><p id="9f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe mz na nb nc b">this.greet</code>属性是一个<code class="fe mz na nb nc b">Person</code>实例的方法。所以如果我们用构造函数创建一个新的<code class="fe mz na nb nc b">Person</code>对象，并如下调用<code class="fe mz na nb nc b">greet</code></p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a7be" class="nh md it nc b gy ni nj l nk nl">let person = new Person('Joe', 10);<br/>console.log(person.greet());</span></pre><p id="0c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后我们从<code class="fe mz na nb nc b">console.log</code>输出中得到<code class="fe mz na nb nc b">'Hi Joe'</code>。</p><p id="ebbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们使用了<code class="fe mz na nb nc b">function</code>关键字来定义方法。我们必须用它来获取<code class="fe mz na nb nc b">Person</code>构造函数的实例作为<code class="fe mz na nb nc b">this</code>的值。</p><p id="00c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们创建另一个<code class="fe mz na nb nc b">Person</code>对象的实例，如下…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="61f3" class="nh md it nc b gy ni nj l nk nl">let jane = new Person('Jane', 11);</span></pre><p id="0798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…当我们如下调用<code class="fe mz na nb nc b">jane</code>上的<code class="fe mz na nb nc b">greet</code>方法时…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4575" class="nh md it nc b gy ni nj l nk nl">console.log(jane.greet());</span></pre><p id="a2d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后我们从<code class="fe mz na nb nc b">console.log</code>输出中得到<code class="fe mz na nb nc b">'Hi Jane’</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0abd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构造器模式测试</h1><p id="5375" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不使用<code class="fe mz na nb nc b">new</code>关键字很容易错误地调用构造函数。我们可以通过使用<code class="fe mz na nb nc b">new.target</code>属性来检查我们是否使用了<code class="fe mz na nb nc b">new</code>关键字来调用构造函数。</p><p id="ceab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有<code class="fe mz na nb nc b">Person</code>构造函数…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8a4f" class="nh md it nc b gy ni nj l nk nl">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;  <br/>}</span></pre><p id="bdb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后我们可以记录<code class="fe mz na nb nc b">new.target</code>属性，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a3f6" class="nh md it nc b gy ni nj l nk nl">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>  console.log(new.target);<br/>}</span></pre><p id="7cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，一旦我们用<code class="fe mz na nb nc b">new</code>操作符创建了一个新的<code class="fe mz na nb nc b">Person</code>，如下…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="343d" class="nh md it nc b gy ni nj l nk nl">let person = new Person('Joe', 10);</span></pre><p id="8e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们记录了函数的代码，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5792" class="nh md it nc b gy ni nj l nk nl">ƒ Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>  console.log(new.target);<br/>}</span></pre><p id="59b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们调用<code class="fe mz na nb nc b">Person</code>函数而不使用<code class="fe mz na nb nc b">new</code>运算符，如下…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="005d" class="nh md it nc b gy ni nj l nk nl">Person('Joe', 10);</span></pre><p id="71a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们得到从<code class="fe mz na nb nc b">console.log</code>返回的<code class="fe mz na nb nc b">undefined</code>。</p><p id="e8a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们想检查构造函数是否被<code class="fe mz na nb nc b">new</code>操作符调用，我们可以检查<code class="fe mz na nb nc b">new.target</code>属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/0ff78784c30906a0613a43174aa020ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pQkC-mIQYunS7SAA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历山大·席默克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f25" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从构造函数返回</h1><p id="acd2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就像常规函数一样，我们可以在构造函数中有一个<code class="fe mz na nb nc b">return</code>语句。</p><p id="224b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，与常规函数不同，有一些规则控制构造函数中返回的内容。</p><p id="f7c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果用对象调用<code class="fe mz na nb nc b">return</code>，则返回对象而不是<code class="fe mz na nb nc b">this</code>。当我们用<code class="fe mz na nb nc b">new</code>操作符创建一个新的对象实例时，我们得到的是返回的对象，而不是<code class="fe mz na nb nc b">this</code>的值。</p><p id="7eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果用原始对象调用<code class="fe mz na nb nc b">return</code>，那么它将被忽略。</p><p id="2295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有其他情况下，即使没有指定任何内容，也会返回<code class="fe mz na nb nc b">this</code>。</p><p id="438e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过编写以下代码来返回一个除了<code class="fe mz na nb nc b">this</code>之外的对象:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3422" class="nh md it nc b gy ni nj l nk nl">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>  return {<br/>    name: 'Mary'<br/>  };<br/>}</span></pre><p id="dab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们用关键字<code class="fe mz na nb nc b">new</code>创建一个<code class="fe mz na nb nc b">Person</code>的实例时，如下…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="dbbe" class="nh md it nc b gy ni nj l nk nl">let person = new Person('Joe', 10);<br/>console.log(person.name);</span></pre><p id="5b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们让<code class="fe mz na nb nc b">'Mary'</code>登录。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c5b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">省略括号</h1><p id="0150" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果不需要传入任何参数，我们可以在调用构造函数时省略括号。例如，如果我们写…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="106d" class="nh md it nc b gy ni nj l nk nl">function Employee() {<br/>  this.name = "John";<br/>}</span><span id="1d31" class="nh md it nc b gy nn nj l nk nl">let employee = new Employee;<br/>console.log(employee.name);</span></pre><p id="7364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们从<code class="fe mz na nb nc b">console.log</code>输出得到<code class="fe mz na nb nc b">'John'</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b023" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">检查对象是否是构造函数的实例</h1><p id="456c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以通过使用<code class="fe mz na nb nc b">instanceof</code>操作符来检查一个对象是否是一个构造函数的实例。</p><p id="9995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有一个<code class="fe mz na nb nc b">Person</code>构造函数和一个从它创建的<code class="fe mz na nb nc b">person</code>对象，如下…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a744" class="nh md it nc b gy ni nj l nk nl">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>  this.greet = function(){<br/>   return `Hi ${this.name}`;<br/>  }<br/>}</span><span id="3b20" class="nh md it nc b gy nn nj l nk nl">let person = new Person('Joe', 10);</span></pre><p id="0cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们可以使用如下的<code class="fe mz na nb nc b">instanceof</code>操作符来检查<code class="fe mz na nb nc b">person</code>是否是从<code class="fe mz na nb nc b">Person</code>构造函数创建的:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3f32" class="nh md it nc b gy ni nj l nk nl">console.log(person instanceof Person);</span></pre><p id="0311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe mz na nb nc b">console.log</code>应该显示<code class="fe mz na nb nc b">true</code>。如果一个对象不是从给定的构造函数中创建的，那么将会是<code class="fe mz na nb nc b">false</code>。</p><p id="3691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e85a" class="nh md it nc b gy ni nj l nk nl">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>  this.greet = function(){<br/>   return `Hi ${this.name}`;<br/>  }<br/>}</span><span id="5646" class="nh md it nc b gy nn nj l nk nl">function Foo(){</span><span id="35d2" class="nh md it nc b gy nn nj l nk nl">}</span><span id="0347" class="nh md it nc b gy nn nj l nk nl">let person = new Person('Joe', 10);<br/>console.log(person instanceof Foo);</span></pre><p id="1cf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后<code class="fe mz na nb nc b">console.log</code>显示<code class="fe mz na nb nc b">false</code>，因为<code class="fe mz na nb nc b">person</code>不是从<code class="fe mz na nb nc b">Foo</code>构造函数创建的。</p><p id="0097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构造函数是创建对象的模板。我们可以用它来创建使用相同构造函数的不同对象，这些构造函数具有相同的实例方法和属性，但非方法属性的值不同。</p><p id="3e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mz na nb nc b">instanceof</code>操作符来检查一个对象是否是从构造函数中创建的。</p></div></div>    
</body>
</html>