<html>
<head>
<title>How to Handle and Raise Exceptions in Python — 12 Things to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中处理和引发异常——需要知道的12件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-handle-and-raise-exceptions-in-python-12-things-to-know-4dfef7f02e4?source=collection_archive---------0-----------------------#2020-06-09">https://betterprogramming.pub/how-to-handle-and-raise-exceptions-in-python-12-things-to-know-4dfef7f02e4?source=collection_archive---------0-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a073" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让您的Python代码更加健壮</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4126c9543c37e3b733b58a659e64ab4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1W0uwNZJYvyytLC2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@hhh13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">傅甬 华</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="b38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们学习Python中的编码时，我们不可避免地会犯各种各样的错误，大多数时候是语法上的，有时是语义上的。例如，我不知道有多少次忘记了跟在<code class="fe lv lw lx ly b">if</code>语句或函数声明后面的冒号，这导致了下面的<code class="fe lv lw lx ly b">SyntaxError</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">句法误差</p></figure><p id="e578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些语法错误，也称为解析错误，在Python中通常由一个向上的小箭头表示，如上面的代码片段所示。除了配对错误之外，我们的代码可能包含更多逻辑问题的其他错误。例如，<code class="fe lv lw lx ly b">TypeError</code>是我们经常遇到的另一个错误消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例外示例</p></figure><p id="4f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们试图连接字符串。然而，数字2020属于<code class="fe lv lw lx ly b">int</code>类型，不能用于仅与<code class="fe lv lw lx ly b">str</code>对象一起工作的字符串串联。在这种情况下，我们会遇到<code class="fe lv lw lx ly b">TypeError</code>。用更精确的术语来说，<code class="fe lv lw lx ly b">TypeError</code>异常是<em class="mb">引发的</em>或者Python <em class="mb">引发</em>异常。</p><p id="f256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lv lw lx ly b">TypeError</code>一样，当Python试图执行这些代码行时，这些类型的错误(例如<code class="fe lv lw lx ly b"> ValueError</code>和<code class="fe lv lw lx ly b">ZeroDivisionError</code>)就会发生。在Python中，<em class="mb">我们通常将这些非语法错误称为异常，</em>使它们不同于语法错误。对于语法错误，我们必须使用可接受的语法来更新受影响的代码行。对于异常，我们可以通过适当实现相关技术来优雅地处理它们。</p><p id="6bd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先来看看如何处理异常。在后半部分，我们将学习Python中的异常引发。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="2224" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">异常处理</h1><h2 id="a09d" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">1.处理异常的基本形式</h2><p id="741e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">处理异常的标准方法是使用<code class="fe lv lw lx ly b">try…except</code>块。如果你有这样的背景，它很像许多其他编程语言中的<code class="fe lv lw lx ly b">try…catch</code>块。</p><p id="447c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">try</code>子句包含可能引发异常的代码。如果在<code class="fe lv lw lx ly b">try</code>子句中一切正常，那么<code class="fe lv lw lx ly b">except</code>子句中的任何代码都不会被执行。<code class="fe lv lw lx ly b">try…except</code>程序块完成，程序将继续进行。</p><p id="0219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果在<code class="fe lv lw lx ly b">try</code>子句中出现异常，Python将停止执行该子句中的任何代码，并将异常传递给<code class="fe lv lw lx ly b">except</code>子句，以查看该特定错误是否得到处理。</p><p id="faaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个最基本的异常处理形式的简单例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异常处理的基本形式</p></figure><p id="7a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，当除法按预期工作时，这个除法的结果(即2.0)被打印出来。然而，当我们试图用零除这个数时，Python抛出了<code class="fe lv lw lx ly b">ZeroDivisionError</code>。幸运的是，我们的函数被编写来处理这个错误和消息“你不能用零除12”打印出来通知用户这个错误。</p><h2 id="a7d0" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">2.为什么要处理异常？</h2><p id="8b15" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们现在了解了如何使用<code class="fe lv lw lx ly b">try…except</code>块处理异常。但是我们为什么要费心处理异常呢？最重要的好处是通知用户错误，同时仍然允许程序继续运行。让我们看看一些类似的函数，有和没有处理异常:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异常已处理与未处理</p></figure><p id="c86a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，当我们调用处理异常的函数时，我们看到程序一直执行到函数结束(第15–17行)。相比之下，当我们调用不处理异常的函数时，我们看到程序不能完成到函数的结尾(第18–22行)。</p><h2 id="24f8" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">3.变量赋值</h2><p id="48f1" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们可以将异常赋给一个变量，这样我们就可以检索关于异常的更多信息。在下面的代码中，我们可以将处理过的异常<code class="fe lv lw lx ly b">TypeError</code>赋给变量<code class="fe lv lw lx ly b">e</code>，这样我们就可以让Python为我们打印错误消息。如第10行所示，打印出错误消息，告诉我们不能将字符串与整数连接起来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异常的变量赋值</p></figure><h2 id="9eb9" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">4.多重例外</h2><p id="0062" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们可以在<code class="fe lv lw lx ly b">except</code>子句中处理多个异常。我们将简单地将可能的异常封装在一个元组中，如下面代码片段中的第6行所示。当我们调用该函数时，我们通过分别引发<code class="fe lv lw lx ly b">ValueError</code>和<code class="fe lv lw lx ly b">ZeroDivisionError</code>来故意制造两个不同的错误。这些消息清楚地告诉我们处理了什么异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多重例外</p></figure><h2 id="c3ae" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">5.多重except子句</h2><p id="088d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">与上一节相关，当我们期望不同的异常时，我们实际上可以有多个<code class="fe lv lw lx ly b">except</code>子句，每个子句处理一些特定的异常。让我们修改上面的函数(即<code class="fe lv lw lx ly b">divide_six</code>)来创建除子句之外的多个<em class="mb">，如下所示。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多重Except子句</p></figure><p id="7575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修改之后，当我们两次调用该函数，并打算每次引发两个不同的异常时，将为每个<code class="fe lv lw lx ly b">except</code>子句打印预期的消息。</p><h2 id="1bfa" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">6.else子句</h2><p id="82cb" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们可以在<em class="mb"> </em> <code class="fe lv lw lx ly b">try…except</code>块中使用一个<code class="fe lv lw lx ly b">else</code>子句。需要注意的是，<code class="fe lv lw lx ly b">else</code>子句需要出现在<code class="fe lv lw lx ly b">except</code>子句之后。当<code class="fe lv lw lx ly b">try</code>子句完成且未引发任何异常时，<code class="fe lv lw lx ly b">else</code>子句中的代码运行。让我们看看它的使用情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Else子句的异常处理</p></figure><p id="0f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码中有一个函数在<code class="fe lv lw lx ly b">try…except</code>块中使用了一个<code class="fe lv lw lx ly b">else</code>子句。如您所见，<code class="fe lv lw lx ly b">else</code>子句中的代码仅在<code class="fe lv lw lx ly b">try</code>子句完成且没有引发异常时运行。另一方面，当引发和处理异常时，代码不会运行。</p><h2 id="25f5" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">7.finally子句</h2><p id="fc64" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">除了使用<code class="fe lv lw lx ly b">else</code>子句，我们还可以在<code class="fe lv lw lx ly b">try…except</code>块中使用<code class="fe lv lw lx ly b">finally</code>子句。请注意，<code class="fe lv lw lx ly b">finally</code>子句需要放在块的末尾，在<code class="fe lv lw lx ly b">except</code>子句或<code class="fe lv lw lx ly b">else</code>子句(如果设置的话)的下面。<code class="fe lv lw lx ly b">finally</code>子句中的代码将在整个<code class="fe lv lw lx ly b">try…except</code>块完成之前运行(在执行<code class="fe lv lw lx ly b">try</code>或<code class="fe lv lw lx ly b">except</code>子句中的代码之后)。重要的是，<code class="fe lv lw lx ly b">finally</code>子句中的代码将运行，而不管异常引发和处理状态如何。让我们看看它是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Finally子句处理异常</p></figure><p id="ffe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码片段所示，我们有一个包含<code class="fe lv lw lx ly b">finally</code>子句的函数。我们调用该函数两次，第二次调用引发异常。在这两种情况下，<code class="fe lv lw lx ly b">finally</code>子句中的代码都能成功运行。</p><p id="a726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">finally</code>子句需要注意的另一件重要事情是，如果try子句包含一个<code class="fe lv lw lx ly b">break</code>、<code class="fe lv lw lx ly b">continue</code>和<code class="fe lv lw lx ly b">return</code>语句，那么<code class="fe lv lw lx ly b">finally</code>子句将在执行<code class="fe lv lw lx ly b">break</code>、<code class="fe lv lw lx ly b">continue</code>或<code class="fe lv lw lx ly b">return</code>语句之前首先运行。这里很多人都会犯错。下面我们来看一个微不足道的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行顺序(最终)</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="5dd0" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">引发异常</h1><h2 id="f756" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">8.引发异常的基本形式</h2><p id="fb77" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在上一节中，我们学习了在Python中使用<code class="fe lv lw lx ly b">try…except</code>块处理异常的各种特性，这对于更健壮的代码来说肯定是必要的。但是，如果您知道如何正确地引发异常，您的代码还可以进一步增强。我们先来看一个基本形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">引发异常:基本形式</p></figure><p id="d58b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，我们使用了<code class="fe lv lw lx ly b">raise</code>关键字(在其他编程语言中，它被称为<code class="fe lv lw lx ly b">throw</code>)，后跟异常类(例如<code class="fe lv lw lx ly b">Exception</code>、<code class="fe lv lw lx ly b">NameError</code>)。我们也可以使用异常类构造函数来创建一个实例，就像<code class="fe lv lw lx ly b">ValueError()</code>。这两种用法没有区别，前者只是后者使用构造函数的语法糖。</p><h2 id="c321" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">9.带有自定义消息的异常</h2><p id="dc36" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们还可以提供关于我们正在引发的异常的附加信息。最简单的方法就是使用异常类构造函数并包含适用的错误消息来创建实例。这非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义消息</p></figure><h2 id="0dfb" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">10.再加注，然后冒泡</h2><p id="790e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如图所示，所有的异常在被捕获时都会被处理。然而，我们可以重新引发异常，并将异常传递到外部范围，看看它是否可以被处理。这种将异常传递到外部的过程也称为冒泡或传播。</p><p id="8709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们编写包含嵌套结构的复杂代码时(例如，一个函数调用另一个函数，而另一个函数又可能调用另一个函数)，这个特性会更加有用。通过异常再引发，我们可以决定在哪里处理特定的异常。当然，处理特定异常的确切位置是根据具体情况决定的。在这里，我可以向您展示如何重新引发异常。我们先来看一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">再次引发异常</p></figure><p id="87f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有两个函数，<code class="fe lv lw lx ly b">run_cast_number</code>调用另一个函数<code class="fe lv lw lx ly b">cast_number</code>。我们用一个字符串调用这个函数两次，两次都导致了一个异常，因为这个异常是在<code class="fe lv lw lx ly b">cast_number</code>函数中处理的，所以显示了消息“转换失败”。然而，第二次，我们调用函数，我们要求<code class="fe lv lw lx ly b">cast_number</code>函数重新引发异常(第8–9行)，这样<code class="fe lv lw lx ly b">except</code>子句在<code class="fe lv lw lx ly b">run_cast_number</code>函数中运行(第15&amp;22–23行)。</p><h2 id="5f42" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">11.用户定义的异常</h2><p id="1081" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在许多情况下，我们可以使用<a class="ae ky" href="https://docs.python.org/3/library/exceptions.html#bltin-exceptions" rel="noopener ugc nofollow" target="_blank">内置异常</a>来帮助我们在项目中引发和处理异常。然而，Python为我们提供了创建自定义异常类的灵活性。如果您不知道如何创建Python定制类，请参考我以前的相关文章:</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/swlh/declare-your-first-python-class-understand-3-basic-components-15768c8d35b0" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">声明您的第一个Python类——了解3个基本组件</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">使用自定义类更好地组织代码</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><p id="62c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，我们需要声明一个类作为内置<code class="fe lv lw lx ly b">Exception</code>类的子类。按照惯例，您应该以Error结尾来命名您的类(例如，<code class="fe lv lw lx ly b">MediumDataError</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义异常类</p></figure><p id="467c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们创建了一个名为<code class="fe lv lw lx ly b">FileExtensionError</code>的定制异常类。当我们抛出这样一个异常时，只使用类名是行不通的，如第10–13行所示。相反，我们应该通过为构造函数方法设置两个位置参数来实例化这个异常。如第17行所示，通过实现<code class="fe lv lw lx ly b">__str__</code>方法，我们可以看到定制的异常消息。换句话说，异常消息是通过调用<code class="fe lv lw lx ly b">str()</code>函数生成的。</p><h2 id="80f2" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">12.何时加注</h2><p id="e50c" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们已经学习了如何引发内置和自定义异常。当我们学习Python的时候，很多时候，我们只需要知道如何处理异常。然而，随着您的Python技能的进步，您可能想知道何时应该引发异常。</p><p id="1c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验法则是<em class="mb">当你的代码可能运行到某些无法继续执行的场景时，你应该抛出一个异常</em>。通过引发适当的异常，它将允许代码的其他部分正确处理异常，以便执行可以继续。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">何时引发异常</p></figure><p id="6ab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们首先定义了一个可以读取文件的函数<code class="fe lv lw lx ly b">read_data</code>。假设另一个函数<code class="fe lv lw lx ly b">process_data</code>是一个公共API，我们不能很好地控制用户将要传递的文件类型。因此，当我们使用<code class="fe lv lw lx ly b">read_data</code>函数读取数据时，我们想要引发一个异常，因为没有正确的数据，我们的程序无法继续运行。</p><p id="8c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们调用公共API <code class="fe lv lw lx ly b">process_data</code>函数两次，一次使用错误的数据类型，另一次使用正确的数据类型。对于前一种情况，异常被正确地引发和处理，这样我们的程序就不会崩溃，并且用户也会被告知关于API使用的错误。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="b065" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="9334" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在本文中，我们回顾了Python中处理和引发异常的各个方面。通过在项目中引入异常，您的代码将变得更加健壮，并且您不太可能遇到执行无法恢复的情况。</p><div class="ns nt gp gr nu nv"><a href="https://docs.python.org/3/tutorial/errors.html" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">8.错误和异常- Python 3.8.3文档</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">到目前为止，错误消息还没有被提及，但是如果你已经尝试过这些例子，你可能已经…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">docs.python.org</p></div></div></div></a></div></div></div>    
</body>
</html>