# PHP:一个在 jQuery 中使用 JSON Web 令牌的简单例子

> 原文：<https://betterprogramming.pub/simple-example-using-json-web-tokens-with-php-and-jquery-c648a80854c>

## 了解如何实现用于身份验证的 JSON Web 令牌

![](img/7d965c63e221d07f3970acddda683026.png)

图片由作者提供

最近，我想学习更多关于 JSON Web 令牌(jwt)及其工作原理的知识。我找到了一些服务器端的例子和一些客户端的例子，但是真的没有找到一个地方展示了整个周期。所以我创造了我自己的，并在这里分享。

历史上，我使用 PHP 会话变量来管理安全性，这是一种有一些缺点的方法。首先，如果您要对多个 web 服务器进行负载平衡，它需要一些服务器端管理。您可能需要实现一个缓存解决方案，如 Redis 或 Memcache，并定义一个缓存服务器来存储会话。第二，在客户端，PHP 存储了一个会话 cookie，这可能会暴露您的身份验证方案中使用的会话变量信息。

jwt 通过使用一个在服务器上创建的令牌来解决这个问题，该令牌包含经过哈希和编码的身份验证客户端的特定信息。然后将这个令牌返回给客户机，客户机可以在以后的 API 请求中使用这个令牌，而不需要进一步的身份验证。

# JWT 崩溃

jwt 由三部分组成:头部、有效负载和签名。

**报头**包含关于使用哪种算法来散列令牌的信息。在我们的例子中，我们将使用 HMAC-SHA256，一种使用秘密密钥的算法。

**有效载荷**(也称为令牌的*声明*)包含存储在令牌内部的数据。在我们的示例中，我们将在有效载荷中存储经过身份验证的用户的用户 id。尽管我们将只在有效负载中存储一项，但是您可以存储任意多的声明。请记住，在这样做时，您应该考虑性能，并记住令牌不是用来作为传输数据请求的工具，而仅仅是用于数据请求身份验证的工具。

在我们的示例中，令牌中的用户 id 可以在服务器上用作索引键，以在后续请求中查询特定于已通过身份验证的用户的信息，而不要求用户再次标识自己的身份—例如，将用户导航到显示其订单列表的页面。

还有一些标准声明可以包含在有效负载中，例如`exp`(到期日期和时间)和`nbf`(不在日期和时间之前)，它们标识了开始接受 JWT 进行处理的时间。我们的例子将包括在您的测试中包含`exp`和`nbf`的能力。您可以查看 jwt 的维基百科页面，了解其他标准字段。

**签名**是报头和有效载荷的散列表示。头和负载分别进行 base64url 编码，然后用一个`period header.payload`连接在一起成为一个新变量。然后，该变量被散列到一个新的变量中，在我们的示例中，该变量使用带有密钥的 HS256 算法，然后该变量也被 base64url 编码到签名中。签名被附加到头部和有效载荷变量，另一个句点`header.payload.signature` 成为最终变量，这是我们的令牌，它被传递回客户端。

这就是它的工作原理。有很多文章也解释了这一点，但至少我们已经为我们的例子搭建了舞台。让我们开始吧。

# 例子

我的例子使用了三个文件，它们可以从我的存储库免费下载。

## index.html

这是一个简单的登录页面，提供了演示与服务器上的`app_client.php`文件交互的不同示例的按钮。

*   **良好登录** —提交帖子，用户名为 *john.doe* ，密码为 *foobar* 。如果认证成功，则返回一个令牌。客户端可以决定如何存储令牌以备将来使用。在我们的例子中，我们将把它存储在浏览器`localStorage`中。
*   **错误登录**——提交一篇帖子，用户名为 *john.doe* 和无效密码 *foobarfoobar* 。这将导致`app_client`拒绝认证尝试，并显示错误和无令牌。收到错误后，客户端将清除任何现有令牌，并要求用户使用 Good Login 按钮获得一个新令牌，然后才能进行任何进一步的测试。
*   **测试是否登录** —将使用`localStorage`中存储的令牌发出 GET。如果成功，`app_client`将返回我们存储在令牌有效负载中的用户 id。
*   **注销并清除令牌** —简单地清除`localStorage`中的任何现有令牌，并在任何进一步的测试工作之前，强制用户使用“良好登录”按钮获得一个新令牌。

## app _ 客户端. php

这个服务器端 PHP 文件接受来自`index`的方法请求，并相应地处理它们。

POST 请求接受用户名和密码字段并验证它们，如果它们无效，则返回一个错误。如果它们是有效的，那么就包含了 `jwt.php`文件来处理所有的令牌函数。然后创建一些在 JWT 创建中使用的变量。

第一个是用户 id，它被用作有效负载中的第一个声明:

```
$userId = 'USER123456';
```

这简单地证明了我们可以将我们想要的任何数据放入索赔中。在本例中，我们包含了一些有用的信息，稍后我们可以在服务器上使用这些信息来查询特定于该用户的数据，而不需要进一步的身份验证或选择。

接下来的两个变量用于控制令牌的生命周期:

```
$nbf = strtotime('2021-01-01 00:00:01');

$exp = strtotime('2021-01-01 00:00:01');
```

`$nbf`和`$exp`变量对应于它们在有效载荷中的标准字段对应项。在上面的示例中，将`**nbf**` (不是之前)日期设置为 2021 年 1 月 1 日上午 12:01 生成的令牌不允许在该日期之前进行验证。您可以在您的开发环境中对此进行测试，方法是取消对该行的注释，并将其设置为适当的测试日期和时间。

在上面的示例中，将`exp`(到期)日期设置为 2021 年 1 月 1 日上午 12:01 时生成的令牌将仅在该日期和时间之前有效，届时它将到期并不再有效。您可以在您的开发环境中对此进行测试，方法是取消对该行的注释，并将其设置为适当的日期和时间。

如果违反了这两个日期/时间变量中的任何一个，`app_client`将向`**index**`返回异常错误。

最后一个变量是一个服务器密钥(在本例中是一个 GUID ),我们将在签名中使用它作为散列算法。在我们的例子中，只有服务器知道密钥；因此，创建的令牌只能由服务器解码:

```
$serverKey = '5f2b5cdbe5194f10b3241568fe4e2b24';
```

下一个代码块将我们的声明变量打包到一个有效载荷数组中，然后将它和服务器密钥一起传递给`jwt.php`以编码成一个令牌:

```
// create a token
$payloadArray = array();
$payloadArray['userId'] = $userId;
if (isset($nbf)) {$payloadArray['nbf'] = $nbf;}
if (isset($exp)) {$payloadArray['exp'] = $exp;}
$token = JWT::encode($payloadArray, $serverKey);

// return to caller
$returnArray = array('token' =&gt; $token);
$jsonEncodedReturnArray = json_encode($returnArray, JSON_PRETTY_PRINT);
echo $jsonEncodedReturnArray;
```

然后将生成的令牌打包成一个 JSON 编码的返回数组，并返回给`index`。

## jwt.php

这个类库基于诺伊曼·冯和阿南特·纳拉亚南写的原始 Firebase/JWT 源代码，在这里找到:[https://github.com/firebase/php-jwt](https://github.com/firebase/php-jwt)。

为了简化这个简单的例子，我去掉了对编写器依赖、名称空间引用和特殊错误异常的需求。所有其他功能和界面保持不变。一旦你掌握了这些概念，我鼓励你安装他们的 JWT 类库，因为这将为你提供库的持续更新。

`jwt.php`类库提供了编码和解码 JSON Web 令牌的所有功能，包括处理有效负载标准字段。

# 试试吧！

你可以从 GitHub 下载这三个文件。将它们都放在开发环境中的同一个文件夹中，并进行试验。该代码是为了清晰和易于调试而特意编写的。

我希望这有助于您理解如何在您的身份验证堆栈中使用 JSON Web 令牌！