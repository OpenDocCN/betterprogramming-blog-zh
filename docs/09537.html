<html>
<head>
<title>You Didn’t Truly Understand the Famous Python Trick: a, b= b, a</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你没有真正理解著名的Python技巧:a，b= b，a</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/you-didnt-truly-understand-the-infamous-python-trick-a-b-b-a-2e4e8634f5a9?source=collection_archive---------1-----------------------#2021-09-07">https://betterprogramming.pub/you-didnt-truly-understand-the-infamous-python-trick-a-b-b-a-2e4e8634f5a9?source=collection_archive---------1-----------------------#2021-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d0e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">引擎盖下到底发生了什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/df821fd7ce8f0f27d1abd7a2bb8ae6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M1Pz-NUpYwpAe0_q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@vincentvanzalinge?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">文森特·范·扎林格</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="0d5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当人们学习用Python编程时，许多人喜欢阅读“你可能不知道的X Python技巧”等文章，包括Medium。在这些文章中，经常提到的一个著名技巧是在没有中间变量的情况下交换两个变量，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5d3d" class="ma mb it lw b gy mc md l me mf"># instead of doing:<br/>temp = a<br/>a = b<br/>b = temp</span><span id="5200" class="ma mb it lw b gy mg md l me mf"># do this:<br/>a, b = b, a</span></pre><p id="e97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您真的知道这行看似简单的代码在幕后做了什么吗？</p><p id="a663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于更深入地研究这种技术的。当然，这不仅仅是发现它本身是如何工作的；在探索过程中学习相关技术更为重要。</p><p id="bc9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧。</p><h1 id="fdd0" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">赋值语句</h1><p id="5038" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，你必须明白这个操作<code class="fe nd ne nf lw b">a, b = b, a</code>是Python中的一个语句，而不是一个表达式。表达式是计算出一个值的代码。相比之下，语句执行一个操作而不计算值。更具体地说，该语句是一个赋值语句，因为它使用了赋值运算符——等号。</p><p id="2eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在赋值操作符的右边，您正在创建一个tuple对象。请注意，即使您在正常创建元组时看不到括号，但是使用逗号符号表示创建了元组对象，即使只有一个项目，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="93df" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; a = 5, 6<br/>&gt;&gt;&gt; b = 4,<br/>&gt;&gt;&gt; type(a)<br/>&lt;class 'tuple'&gt;<br/>&gt;&gt;&gt; type(b)<br/>&lt;class 'tuple'&gt;</span></pre><h1 id="300f" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">元组解包</h1><p id="79ad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">与左侧包含单个变量的典型赋值语句不同，上面的操作左侧有两个变量。它的特别之处在于，右边元组的项会被顺序赋给左边的两个变量，这个操作被称为元组解包。</p><p id="cd02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更具体地说，当两边的项目编号都匹配时，拆封被称为一对一拆封，即左边的项目将具有右边匹配位置的项目的值。例如，这样的操作可以发生在三个、四个甚至更多的项目上。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6033" class="ma mb it lw b gy mc md l me mf">a, b, c = c, b, a<br/>a, b, c, d = d, c, b, a<br/>a, b, c, d, e = e, d, c, b, a<br/>...</span></pre><p id="37d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上所有的开箱操作都是一对一的那种。虽然这里不太相关，但是有各种各样的解包技术，包括使用带星号的表达式来捕获全部内容，使用下划线来表示解包中不需要的项目。相关的例子如下所示，供您快速参考，但我不打算在这里展开这个主题。感兴趣的读者可以在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/6-essential-python-tuple-unpacking-techniques-you-can-use-fc5d56a2c5f4">我之前的文章</a>中找到更多信息。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4662" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; numbers = (1, 2, 3, 4, 5)<br/>&gt;&gt;&gt; a, *b, c = numbers<br/>&gt;&gt;&gt; _, *d = numbers<br/>&gt;&gt;&gt; print(a, b, c, d, _, sep="___")<br/>1___[2, 3, 4]___5___[2, 3, 4, 5]___1</span></pre><h1 id="bee1" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">元组解包真的有用吗？</h1><p id="b721" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">基于对元组解包技术的理解，你可能会猜到<code class="fe nd ne nf lw b">a, b = b, a</code>是这样的:在右边，我们创建了一个元组<code class="fe nd ne nf lw b">(b, a)</code>，通过解包，<code class="fe nd ne nf lw b">a</code>得到<code class="fe nd ne nf lw b">b</code>的值，而<code class="fe nd ne nf lw b">b</code>得到<code class="fe nd ne nf lw b">a</code>的值。很有道理，不是吗？</p><p id="6b64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这个操作到底发生了什么，让我们利用<code class="fe nd ne nf lw b"><a class="ae ky" href="https://docs.python.org/3/library/dis.html#module-dis" rel="noopener ugc nofollow" target="_blank">dis</a></code>模块(代表反汇编)，它允许我们分析<a class="ae ky" href="https://en.wikipedia.org/wiki/CPython" rel="noopener ugc nofollow" target="_blank"> CPython </a>实现中的字节码。</p><p id="8095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，实现Python和CPython有不同的方法，CPython是用C和Python编写的，它是默认的和最广泛使用的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="148c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了研究这个操作，我们用内置的<code class="fe nd ne nf lw b">compile</code>函数创建一个用于反汇编分析的<code class="fe nd ne nf lw b">Bytecode</code>对象。使用<code class="fe nd ne nf lw b">dis</code>函数，我们可以检索关于代码对象操作的详细步骤。让我们来分析这些命令。</p><p id="4656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于分析的目的，我们还通过访问<code class="fe nd ne nf lw b">co_names</code>属性来检索代码对象使用的两个变量名:<code class="fe nd ne nf lw b">(‘a’, ‘b’)</code>。</p><p id="d345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这两个变量名是字符串(为简单起见，我们称之为<code class="fe nd ne nf lw b">label 'a’</code>和<code class="fe nd ne nf lw b">label 'b’</code>)，你应该把它们看作标签，它们引用内存中的底层对象(为简单起见，我们称之为<code class="fe nd ne nf lw b">object a</code>和<code class="fe nd ne nf lw b">object b</code>)。</p><p id="1e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要理解标签(即变量的名称)和对象(即内存中的数据)之间的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/357260c1cdc4dd8a8b930c63e50a97b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPwrsiasYQm_hwOf0-6XBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">交换两个变量</p></figure><p id="f3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助您理解这个过程，我创建了一个图表，如上所示。</p><p id="1c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个<code class="fe nd ne nf lw b">LOAD_NAME</code>将变量<code class="fe nd ne nf lw b">label 'a’</code>(你可以把它想象成<code class="fe nd ne nf lw b">object a</code>)的对象引用加载到堆栈中(旁注:你可以把堆栈概念化为一个线性数据模型，你可以从顶部添加和移除项目)。</p><p id="a391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个<code class="fe nd ne nf lw b">LOAD_NAME</code>将<code class="fe nd ne nf lw b">label 'b’</code> ( <code class="fe nd ne nf lw b">object b</code>)的对象引用加载到堆栈中，这使得它位于<code class="fe nd ne nf lw b">object a</code>的顶部。</p><p id="4a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf lw b">ROT_TWO</code>命令是最有趣的部分。</p><p id="64cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，它与元组解包无关。对于好奇的读者，我们来看看这个命令的<a class="ae ky" href="https://github.com/python/cpython/blob/main/Python/ceval.c" rel="noopener ugc nofollow" target="_blank">源代码</a>。给定有意义的函数名，操作应该简单明了。</p><p id="93d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所猜测的，<code class="fe nd ne nf lw b">ROT_TWO</code>通过将第二个放在顶部，同时将顶部的一个作为第二个，直接交换堆栈的两个项目。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="56f4" class="ma mb it lw b gy mc md l me mf">TARGET(ROT_TWO): {            <br/>    PyObject *top = TOP();            <br/>    PyObject *second = SECOND();            <br/>    SET_TOP(second);            <br/>    SET_SECOND(top);            <br/>    DISPATCH();        <br/>}</span></pre><p id="5940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交换后，第一个<code class="fe nd ne nf lw b">STORE_NAME</code>存储堆栈的顶部(也将从顶部移动)，这是对<code class="fe nd ne nf lw b">object a</code>到<code class="fe nd ne nf lw b">co_varnames</code>中的<code class="fe nd ne nf lw b">label ‘b’</code>的引用。</p><p id="0ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为栈顶现在变成了对<code class="fe nd ne nf lw b">object b</code>的引用，第二个<code class="fe nd ne nf lw b">STORE_NAME</code>将把对<code class="fe nd ne nf lw b">object b</code>的引用存储到<code class="fe nd ne nf lw b">label ‘a’</code>。至此，Python完成了交换。</p><p id="92c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf lw b">LOAD_CONST</code>操作加载常量，在本例中为<code class="fe nd ne nf lw b">None</code>。每个Python操作都可以返回值—在本例中，<code class="fe nd ne nf lw b">RETURN_VALUE</code>返回隐式返回值— <code class="fe nd ne nf lw b">None</code>。</p><p id="d519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，您可能会注意到，这里在命令前使用了偶数0、2、4…因为Python需要两个字节来表示每个指令。</p><h1 id="05f5" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">拆包对对换没有作用吗？</h1><p id="4a96" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经知道Python(更准确地说是CPython实现)本质上是使用<code class="fe nd ne nf lw b">ROT_TWO</code>来交换两个变量，而没有使用任何解包技术。您可能想知道拆包根本不涉及交换。为了回答这个问题，我们来尝试一些实验。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6a53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了三个变量，一切都保持不变，除了<code class="fe nd ne nf lw b">ROT_THREE</code>的引入，它“将第二个和第三个堆栈项目向上提升一个位置，将顶部向下移动到位置三”(<a class="ae ky" href="https://docs.python.org/3/library/dis.html#opcode-ROT_THREE" rel="noopener ugc nofollow" target="_blank">来源</a>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ee1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了四个变量，事情就变了。如您所见，该操作涉及两个命令:<code class="fe nd ne nf lw b">BUILD_TUPLE</code>和<code class="fe nd ne nf lw b">UNPACK_SEQUENCE</code>，这两个命令创建tuple并在接下来解包它。可以想象，当变量超过四个时，会应用相同的命令，有兴趣的读者可以自己试试。</p><h1 id="b292" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="d228" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在本文中，我们使用<code class="fe nd ne nf lw b">dis</code>模块来研究一个广为流传的技巧——交换两个变量而不交换第三个变量:<code class="fe nd ne nf lw b">a, b = b, a</code>。以下是要点的快速回顾:</p><ul class=""><li id="9ac8" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">元组解包是一种将多个项目的元组映射到多个变量的技术。当数字匹配时，就是一对一的拆包。</li><li id="66f3" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">看来<code class="fe nd ne nf lw b">a, b = b, a</code>涉及到了一对一的拆包。然而，事实证明Python使用了优化的操作(即<code class="fe nd ne nf lw b">ROT_TWO</code>)来交换栈上的引用。</li><li id="d0f5" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">当涉及到三个变量时，就会发生这种交换。然而，当有四个变量时，元组创建和解包就开始起作用了。</li><li id="9c4c" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">应该注意的是，这里讨论的所有内容都属于Python语言的CPython实现的范畴。对于这种特定的操作，还有其他可能具有不同实现机制的实现。</li><li id="f5e3" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">CPython是默认的、使用最广泛的实现。</li></ul></div></div>    
</body>
</html>