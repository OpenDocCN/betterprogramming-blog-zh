<html>
<head>
<title>Data Replication for DBMS Using the Commit Log</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用提交日志的DBMS数据复制</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-replication-for-dbms-using-the-commit-log-b665ce48330e?source=collection_archive---------9-----------------------#2021-07-07">https://betterprogramming.pub/data-replication-for-dbms-using-the-commit-log-b665ce48330e?source=collection_archive---------9-----------------------#2021-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a53" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">完整的数据复制解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/554d181eb164421155d54752af09576a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JdkKjZDNeZfDTceM.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://www.gateworld.net/wiki/File:Replicators.jpg" rel="noopener ugc nofollow" target="_blank"> GateWorld </a>。由作者编辑。</p></figure><p id="3c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看到开发人员如何通过跨多个系统复制数据来打破他们的团队和业务的信息孤岛。</p><p id="f023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将回顾为什么开发人员要为云复制数据和考虑事项。第二，<a class="ae ky" href="https://stargate.fandom.com/wiki/Replicator" rel="noopener ugc nofollow" target="_blank">我们将准备与复制者</a>的战争。然后，我们将研究Postgres和MySQL的架构，以及它们的提交日志如何使我们能够制作数据的精确副本。最后，我们将Debezium连接到Postgres，以获得一个完整的数据复制解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c2df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据复制简介</h1><p id="8081" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数据复制是针对各种业务用例在不同数据库系统之间移动数据的过程。在典型的SaaS(软件即服务)应用程序中，数据存储在MySQL、PostgreSQL、Oracle等运营数据库中。还有其他的数据库系统，比如为特定用例构建的数据仓库和搜索系统。在这些系统之间移动数据被称为数据复制。</p><p id="2267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">注意:相同数据库系统之间的数据复制是为了可用性，不要与本文中讨论的数据复制混淆。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="405a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么我们需要复制？</h1><p id="1572" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">信息孤岛是企业从数据中发掘价值和保护资产的最大障碍之一。</p><ul class=""><li id="7343" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">运营效率低下是这些孤岛带来的第一个问题。信息被锁定在一个特定的业务部门，或者只有少数人可以访问，进一步开发和扩展应用程序变得非常困难。</li><li id="848a" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">接下来是技术限制，底层的单个数据库/应用程序无法扩展并满足分析、搜索甚至人工智能的业务需求。</li><li id="8cb3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">有了备份和多个数据库系统，发生严重故障时的灾难恢复就容易多了。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0e64" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据平台—云与内部部署</h1><p id="4a54" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据底层架构的不同，实现民主化的数据访问可能会非常具有挑战性。云计算在过去几十年中发展如此之快，以至于一些管理自己数据中心的大公司都已经转移到了云上。数据管道、数据湖、数据仓库和完全托管的数据系统等云原生架构很常见。没有一家公司愿意把钱花在基本系统的维护上，而是花在核心业务的建设上。通过托管自己的基础架构(内部)来节省几美元不再有利可图。</p><p id="cbb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，云带来了一系列不同的挑战，例如:</p><ul class=""><li id="e3c1" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">安全性</li><li id="2c0f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">供应商锁定</li><li id="3bd9" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">云支持和开销</li></ul><p id="b91f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管底层架构是什么(例如，是云还是内部部署)，人们都可以选择抽象设计，这样就可以轻松地进行移植，甚至是混合设计。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/707b2c9981546bd6ee8e41769b7f3f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cXGUDTPR4wrP22H6.png"/></div></div></figure><p id="5661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将专门关注第一部分(即复制)。这一层是实现更多业务层的关键。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2908" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据复制是如何工作的？</h1><p id="e34f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在深入研究解决方案之前，我们需要了解复制如何与标准操作数据库(关系数据库)一起工作。</p><h2 id="9593" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">Postgres数据库日志架构</h2><p id="6989" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">关系数据库系统维护一种称为提交日志的东西(在PostgreSQL中，它被称为预写日志或WAL日志)。每当发生数据库事务提交时，都会写入这些提交日志。不管我们使用什么数据库，几乎所有的数据库日志都具有以下属性:</p><ul class=""><li id="ffac" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">数据库日志是磁盘上的物理文件。</li><li id="4c3f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">对数据库日志的写入是连续有序的。</li><li id="33f6" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">WAL日志是只附加的日志。对现有数据的任何编辑都会作为新条目显示在日志中。</li><li id="0bee" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">日志条目总是在实际数据写入磁盘之前出现。</li><li id="3ebe" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">除非日志文件提交完成，否则不会提交事务，无论事务处理了多少条记录。</li><li id="6a42" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在任何时间点，PostgreSQL都会维护一个称为重做点的东西。数据库重启时，记录从WAL日志中的该点开始回放。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/c9bb75538ef2fa031479b9ca07abaaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*A_x9PplWxmIuA8sl.png"/></div></figure><h2 id="a648" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">什么是数据库一致性保证？</h2><p id="c8e1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">关系数据库系统的日志体系结构是我们今天拥有的最古老和最久经考验的工程思想之一。许多较新的系统从中汲取了他们的想法和灵感。为什么会有这样的日志系统存在？</p><ul class=""><li id="96b9" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">内存/RAM易失。数据库通常被视为事实的来源，每当系统重启时，数据库都需要依赖一个可靠的机制，以便在启动时进行恢复。表格格式不太适合这种情况。它更加面向服务查询。</li><li id="1a16" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">依赖于主数据库的副本数据库也依赖于WAL日志来与主数据库同步。</li><li id="1b73" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">它还支持在线备份和时间点恢复。</li><li id="1b10" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">由于日志是按顺序写入磁盘的，并且提供了重做保证，所以表记录可以在很久以后以更有组织的/批处理的方式刷新到磁盘。它们不需要在每次表更改/事务时立即写入磁盘。这也有助于缓存。</li></ul><p id="42bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些性质有助于我们建立一个坚实的基础，在此基础上建立进一步的系统。</p><h2 id="8d39" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">PostgreSQL WAL/Binlog文件</h2><p id="a403" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">MySQL的架构与PostgreSQL非常相似，但PostgreSQL的WAL日志同时结合了InnoDB的事务日志和二进制日志。因为MySQL实现了多个存储引擎，所以使用被分离到不同的日志中。存储引擎部分不在本文的讨论范围之内，因此我将坚持使用PostgreSQL示例。</p><p id="b186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WAL文件实际上是一个二进制文件，位于PostgreSQL安装的<code class="fe oc od oe of b">pg_wal</code>目录中。典型的目录结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/756c54cb7ffb88d3311b7a1335193ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/0*T5XUUpEk8vaGmAl0.png"/></div></figure><p id="a319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们尝试查看内容时，它会是如下所示的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/96195d79fa42d9aba048be51031ea1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6lsEm0QOQozmKPgX.png"/></div></div></figure><p id="7214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PostgreSQL提供了一个名为<code class="fe oc od oe of b"><a class="ae ky" href="https://www.postgresql.org/docs/current/pgwaldump.html" rel="noopener ugc nofollow" target="_blank">pg_waldump</a></code>的工具来读取这些文件。我们可以使用<code class="fe oc od oe of b">pg_waldump /path/to/wal/file</code>，它会将整个文件解码成人类可读的文本。下文摘录了该案文:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="32b4" class="np md it of b gy om on l oo op">rmgr: Btree       len (rec/tot):     80/    80, tx:        564, lsn: 0/2F106698, prev 0/2F1065E8, desc: INSERT_LEAF off 41, blkref #0: rel 1663/16385/2658 blk 16<br/>rmgr: Btree       len (rec/tot):     64/    64, tx:        564, lsn: 0/2F1066E8, prev 0/2F106698, desc: INSERT_LEAF off 292, blkref #0: rel 1663/16385/2659 blk 10<br/>rmgr: Heap        len (rec/tot):    175/   175, tx:        564, lsn: 0/2F106728, prev 0/2F1066E8, desc: INSERT off 43 flags 0x00, blkref #0: rel 1663/16385/1249 blk 56<br/>rmgr: Btree       len (rec/tot):     72/    72, tx:        564, lsn: 0/2F1067D8, prev 0/2F106728, desc: INSERT_LEAF off 41, blkref #0: rel 1663/16385/2658 blk 16<br/>rmgr: Btree       len (rec/tot):     64/    64, tx:        564, lsn: 0/2F106820, prev 0/2F1067D8, desc: INSERT_LEAF off 293, blkref #0: rel 1663/16385/2659 blk 10<br/>rmgr: Heap        len (rec/tot):    175/   175, tx:        564, lsn: 0/2F106860, prev 0/2F106820, desc: INSERT off 44 flags 0x00, blkref #0: rel 1663/16385/1249 blk 56<br/>rmgr: Btree       len (rec/tot):     72/    72, tx:        564, lsn: 0/2F106910, prev 0/2F106860, desc: INSERT_LEAF off 47, blkref #0: rel 1663/16385/2658 blk 16<br/>rmgr: Btree       len (rec/tot):     64/    64, tx:        564, lsn: 0/2F106958, prev 0/2F106910, desc: INSERT_LEAF off 294, blkref #0: rel 1663/16385/2659 blk 10<br/>rmgr: Heap        len (rec/tot):    175/   175, tx:        564, lsn: 0/2F106998, prev 0/2F106958, desc: INSERT off 45 flags 0x00, blkref #0: rel 1663/16385/1249 blk 56<br/>rmgr: Btree       len (rec/tot):     80/    80, tx:        564, lsn: 0/2F106A48, prev 0/2F106998, desc: INSERT_LEAF off 42, blkref #0: rel 1663/16385/2658 blk 16</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="705d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据库复制技术</h1><p id="6be1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们一直以抽象的方式看待事物。我们从为什么公司需要释放其数据库的全部潜力开始，这导致了数据复制和数据平台。为了理解复制是如何工作的，本文的后续部分将重点关注一个特定的数据库平台:PostgreSQL。对于其他数据库系统来说，大多数概念也是类似的，因此这可以用作参考，以形成围绕数据库复制本身的心理框架。</p><p id="9344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到了WAL如何使数据库在系统关闭时保持数据完整性和一致性，甚至从数据损坏中回滚。像许多其他系统一样，PostgreSQL也是从底层发展起来的，因此，我们需要了解复制在同一个数据库的两个节点中是如何工作的，以及我们如何将它扩展到其他数据系统。不管我们下面讨论的是什么复制机制，它都依赖于WAL进行复制。</p><h2 id="8863" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">物理复制</h2><p id="39d9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">物理复制在PostgreSQL中已经存在很长时间了。它用于通过物理复制或逐字节复制来复制整个数据库。对主数据库所做的任何更改也会无任何更改地反映在副本数据库中。副本可以选择成为热备用节点(即主数据库出现故障，副本作为主数据库接管)。</p><p id="d981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种类型的物理复制，如日志传送、流复制等。，但它们大体上可以分为两类:</p><ul class=""><li id="36e6" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">同步复制</li><li id="d71e" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">异步复制</li></ul><p id="8e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种类型的复制有几个限制(监听数据库也应该在相同的主版本中，不能复制部分内容，等等)。由于这些原因，物理复制通常用于在两个PostgreSQL数据库系统之间同步数据—主要是为了高可用性。</p><h2 id="62ef" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">逻辑解码</h2><p id="00e1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在版本10之前(如下所示)，其他选项允许开发人员/工程师在没有逻辑复制的情况下复制到其他下游系统。顾名思义，逻辑解码将WAL内容解码成人类可读的格式，并将其复制给不同的消费者。这种方法有利也有弊。尽管如此，由于这一步骤需要在主机数据库系统中安装插件/安装程序，因此通常很难维护——尤其是在云环境中。</p><h2 id="0389" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">逻辑复制</h2><p id="e4b1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从PostgreSQL版本10开始，<a class="ae ky" href="https://www.postgresql.org/docs/current/logical-replication.html" rel="noopener ugc nofollow" target="_blank">逻辑复制</a>可用于从PostgreSQL数据库复制数据。正如文档中提到的，逻辑复制基于发布-订阅模型。一个或多个订阅者可以选择收听发布的数据，并且只发布和订阅特定的数据库/表。</p><p id="754a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，逻辑复制的目标更多地是复制到其他数据系统，比如消息传递系统、数据湖和数据仓库。从多个数据库监听也容易得多。</p><p id="88d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将选择一个名为<a class="ae ky" href="https://debezium.io/documentation/reference/1.5/postgres-plugins.html" rel="noopener ugc nofollow" target="_blank"> Debezium </a>的开源工具来构建我们的复制管道。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d8c8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基于Debezium的开源数据复制架构</h1><p id="fd70" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本节中，我们将看到一个演示，演示如何使用Debezium在PostgreSQL源数据库中进行变更数据捕获(CDC)。我们将使用Docker来快速设置数据库，并使用Debezium连接器来监听更改。</p><p id="b9f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们写了一个关于使用Docker 设置Debezium和Postgres的详细教程。下面描述了最重要的部分，但请参见上面的文章了解所有细节！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e668" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为PostgreSQL设置Debezium连接器</h1><p id="28f5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们激活Debezium之前，我们需要通过做一些配置更改来准备Postgres。Debezium利用了我们上面描述的WAL。Postgres使用该日志来确保数据完整性并管理行版本和事务。Postgres的WAL有几种模式可以配置，为了让Debezium工作，WAL级别必须设置为<code class="fe oc od oe of b">replica</code>。现在让我们改变这一点:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="092a" class="np md it of b gy om on l oo op">psql&gt; alter system set wal_level to 'replica';</span></pre><p id="4130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能需要重新启动Postgres容器，以使此更改生效。</p><p id="ccca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个Postgres插件不包括在我们使用的图像中，我们将需要它:<code class="fe oc od oe of b">wal2json</code>。Debezium可以和<code class="fe oc od oe of b">wal2json</code>或者<code class="fe oc od oe of b">protobuf</code>一起工作。对于本教程，我们将使用<code class="fe oc od oe of b">wal2json</code>。顾名思义，它将Postgres的预写日志转换为JSON格式。</p><p id="3c7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着Docker应用程序的运行，让我们使用aptitude手动安装<code class="fe oc od oe of b">wal2json</code>。要进入Postgres容器的外壳，首先找到容器ID，然后运行以下命令打开bash:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="ffb5" class="np md it of b gy om on l oo op">$ docker ps<br/><br/>CONTAINER ID   IMAGE               <br/>c429f6d35017   debezium/connect    <br/>7d908378d1cf   debezium/kafka      <br/>cc3b1f05e552   debezium/zookeeper  <br/>4a10f43aad19   postgres:latest     <br/><br/>$ docker exec -ti 4a10f43aad19 bash</span></pre><p id="14dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们在容器内部，让我们安装<code class="fe oc od oe of b">wal2json</code>:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="cde3" class="np md it of b gy om on l oo op">$ apt-get update &amp;&amp; apt-get install postgresql-13-wal2json</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a86" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">激活Debezium</h1><p id="6442" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们准备好激活Debezium了！</p><p id="e029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过向Debezium发出HTTP请求来与它通信。我们需要发出一个POST请求，其数据是JSON格式的配置。这个JSON定义了我们试图创建的连接器的参数。我们将配置JSON放到一个文件中，然后使用<code class="fe oc od oe of b">curl</code>将其发送到Debezium。</p><p id="ef3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您有几个配置选项。如果您只想让Debezium对某些表进行流式处理(或者避开某些表)，那么您可以在这里使用白名单或黑名单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="927b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以将这个配置发送到Debezium:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="4711" class="np md it of b gy om on l oo op">$ curl -i -X POST \<br/>         -H "Accept:application/json" \<br/>         -H "Content-Type:application/json" \<br/>         127.0.0.1:8083/connectors/ \<br/>         --data "@debezium.json"</span></pre><p id="a272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应将是新启动的连接器的JSON表示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="fdc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Arctype团队已经在另一篇文章中介绍了安装、设置和演示。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8593" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据质量、一致性和其他挑战</h1><p id="053f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">重要的是要明白，一旦我们使用Debezium并监听日志，我们就离开了具有ACID保证的关系数据库领域，进入了分布式系统的世界。当我们选择Kafka作为消息传递系统时，它遵循的<a class="ae ky" href="https://kafka.apache.org/documentation/#semantics" rel="noopener ugc nofollow" target="_blank">语义</a>决定了我们如何将数据复制/分发到更下游的系统。</p><ul class=""><li id="3c9f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">如果我们正在进行这些更改，并将它们直接保存在一个搜索索引(如弹性搜索)中，那么“至少一次——消息永远不会丢失，但可能会重新发送”可能更合适。</li><li id="c824" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果数据正在被传递给机器学习算法，那么选择“最多一次——消息可能会丢失，但永远不会重新传递。”</li><li id="a2f0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果我们向数据仓库交付数据，那么就选择“恰好一次——每条消息只交付一次”</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os or l"/></div></figure><p id="33a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三种消息传递机制在分布式系统中难以解决。Kafka是大规模解决这一问题的系统之一，但每个系统在吞吐量、规模和准确性方面都有自己的缺点。一个人必须做出明智的选择来权衡什么是必要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ba94" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8a25" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">随着业务的扩展，在道德上利用数据的需求不再是奢侈品，而是必需品。数据平台变得越来越普遍，甚至在中型企业中也是如此。它们支持:</p><ul class=""><li id="5245" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">有效性</li><li id="7fe8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">管理</li><li id="80af" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">安全性</li><li id="cda6" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">商业策略</li></ul><p id="537a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是释放数据价值的最佳时机。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e65" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="d750" class="na nb it lb b lc mu lf mv li ot lm ou lq ov lu nf ng nh ni bi translated"><a class="ae ky" href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" rel="noopener ugc nofollow" target="_blank">日志:关于实时数据的统一抽象，每个软件工程师都应该知道的事情</a></li><li id="e965" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://dev.to/arctype/streaming-data-with-postgresql-kafka-debezium-part-1-4e39" rel="noopener ugc nofollow" target="_blank">使用PostgreSQL + Kafka + Debezium传输数据流</a></li></ul></div></div>    
</body>
</html>