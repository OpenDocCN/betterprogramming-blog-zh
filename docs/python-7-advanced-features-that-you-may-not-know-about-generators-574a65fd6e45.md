# Python:你可能不知道的关于生成器的 7 个高级特性

> 原文：<https://betterprogramming.pub/python-7-advanced-features-that-you-may-not-know-about-generators-574a65fd6e45>

## 更深入地了解 Python 生成器

![](img/b9e911bba4e34f2086a2e200eb61db8a.png)

[德乐思教授](https://unsplash.com/@andreasdress?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

# 介绍

## 发电机

生成器是 Python 中一个很好的特性，它实现了惰性求值范式。不像其他的 iterables，比如 lists 和 sets，它们将所有的元素加载到内存中，生成器在请求时一次呈现一个元素。因此，它们的内存效率非常高，在涉及内存消耗大的操作时尤其有用。下面是 Python 中生成器的一个非常常见的用例。

发电机示例

如上面的代码所示，假设我们正在处理一个非常大的文件。当它被读取时，Python 为我们创建了一个文件对象，它的功能相当于一个生成器。当我们迭代 file 对象时，我们每次获得一行数据(即，一次一个元素)，与可能必须将所有行加载到内存中的其他方法相比，这节省了大量内存。

## 生成器创建

要创建一个定制的生成器，我们通常需要定义一个生成器函数，这个函数通常被认为是工厂函数。作为一个*工厂*意味着调用特定的函数将为我们制造一些东西，在这种情况下，当函数被调用时，一个生成器工厂制造一个生成器。让我们看看下面这个创建简单生成器的例子。

简单生成器

如上所示，生成器函数的神奇之处在于使用了`yield`关键字，它为调用者生成所需的元素。重要的是，生成器本身会记住元素呈现序列的状态，并根据需要生成下一个元素。如前所述，调用 generator 函数将创建一个生成器，如代码所示，生成器被赋给一个名为`abc_gen`的变量。使用这个创建的生成器，我们可以在`for`循环中使用它，如上面的第 10–12 行所示。我们还可以使用内省函数`type()`来验证我们从生成器函数中得到的确实是一个生成器对象。

创建生成器的另一种常见方式是使用生成器表达式，它具有以下语法:`(expression for x in iterable)`。语法非常类似于列表理解，除了使用圆括号代替方括号。请不要混淆这两种技术。如果您不小心使用了 list comprehension，将会生成一个包含所有元素的列表，这与使用生成器节省内存的目的背道而驰。

让我们看一个使用生成器表达式创建生成器的简单示例。

生成器表达式

## 前提

在这个简短的概述之后，我希望您对 Python 生成器有一个基本的了解。除此之外，我假设您已经对生成器有了很好的理解，并在适用的地方使用了它们，比如在上面给出的例子中。然而，有几个关于生成器的特性你们中的一些人可能不知道，缺乏这样的知识可能会导致代码中出现意想不到的错误。在本文中，我想强调 7 个不太为人所知的生成器特性和/或缺陷。

# 功能/缺陷亮点

## 1.发电机没有长度

上面显示的例子都涉及到在`for`循环中使用生成器。众所周知，`for`循环通过遍历从可迭代对象创建的迭代器来运行。在我们学习过程的早期，Python 中最常见的可迭代对象是内置数据类型，包括列表和集合。值得注意的是，这些数据类型的一个共同特征是长度特征。换句话说，我们可以使用内置的`len()`函数找出这些可重复项中有多少元素。

因此，在某些情况下，当我们想找出一个发生器的长度时，应用同样的原理可能是有诱惑力的。例如，在消耗了生成器的一些元素后，我们可能想知道还剩多少元素可用于进一步生成。可惜生成器没有这样的功能，如下图。请注意，为了简化代码演示，我将只使用生成器表达式来创建生成器，除非另有说明。

没有发电机的长度信息

如上所示，我们无法得到发电机的长度。实际上，这个特性(即缺少长度)不仅适用于生成器，也适用于迭代器。您可能想知道这些生成器和迭代器之间有什么关系，这将我们带到下一节。

## 2.生成器是迭代器

我们都知道`for`循环中使用迭代器，也使用生成器，如上图。所以你可能假设生成器也是迭代器。的确，你的假设是正确的。生成器是一种特殊的迭代器。迭代器通常通过使用内置的`iter()`函数来创建。例如，下面的代码向您展示了我们如何使用`iter()`函数为列表和字典创建迭代器。

Iter()函数

迭代器一个更显著的特征是使用`next()`函数获取下一项。因为生成器也是迭代器，所以它们也可以使用`next()`函数。考虑这个特性的下面的小例子。正如你所看到的，我们能够通过使用生成器调用`next()`函数一次检索一个项目，就像其他迭代器一样。

作为迭代器的生成器

## 3.生成器是穷举的

首先，这个特性实际上不是生成器所独有的，但是所有迭代器也可以是穷举的。*穷举*是什么意思？在我解释之前，先看一个简单的例子。

穷尽性

如上图所示，多次调用`next()`函数后，我们遇到了`StopIteration`异常。这个异常意味着我们已经“耗尽”了生成器或迭代器的元素，更一般地说。这就是为什么有人说我们“消耗”了发电机的元素，因为被消耗的元素不会再从发电机中产出。

值得注意的是，这个`StopIteration`异常是在标准操作中内部处理的，比如`for`循环和理解。因此，我们在这些操作中从未看到过这种异常。然而，不了解生成器的详尽本质可能是代码中一些错误的根源。

考虑以下可能的情况。正如你所看到的，如果有人在多个`for`循环中使用同一个生成器，那么在后面的迭代中将不会执行更多的动作，因为生成器已经耗尽了它们的元素。更重要的是，由于在`for`循环迭代中对`StopIteration`异常的内部处理，不会抛出异常。

多次使用同一个发电机

关于生成器的穷举性，有一些例外，比如无限生成器`iter(int, 1)`，它会无限次地呈现 0。因此，我们永远不会穷尽这些无限的生成器，尽管它们在现实生活项目中并不经常使用。

## 4.括号有时可以省略

如前所述，在生成器表达式中，我们需要用括号将表达式的主体括起来，我说过我们不应该与列表理解混淆，列表理解使用方括号将表达式括起来。然而，有一个语法上的好处，当生成器是函数调用中唯一的参数时，我们可以省略括号。下面我们来考虑一些简单的例子。

生成器表达式中圆括号的省略

如果您想知道我们如何知道生成器或其他东西(例如，列表)是否被用作中间对象，这里有一个有趣的技巧来检查表达式解释了什么。如下面的代码片段所示，我们使用内置的`type()`函数，该函数使用不带括号的生成器表达式。如您所见，被解释的对象确实是一个生成器。如果你想对底层的实现机制有一个更深入的理解，你可以使用 [dis 模块](https://docs.python.org/3/library/dis.html)，它将允许我们知道在一个函数调用期间发生了什么，并且你将能够发现一个生成器被创建作为一个中间步骤。

不带括号的生成器的类型检查

## 5.你可以选择从哪里屈服

我们已经知道，当调用者请求生成器时，我们使用`yield`关键字来产生一个元素。然而，`yield`有一个特殊的用法，通过与`from`结合，我们可以指定从哪个生成器中检索元素。当您有多个生成器要处理并且想要集成它们时，这非常有用。下面的代码向您展示了我们如何模仿`chain()`函数的行为，它是标准库的一部分，是 itertools 模块中的一个迭代工具。

产生自的发电机

如您所见，我们为`custom_chain`函数提供了两个可迭代变量。使用一个`for`循环，我们依次迭代这两个 iterable，对于每次迭代，我们要求被迭代的 iterable 为我们产生适用的元素。从输出中，您可以看出我们使用了`yield from`特性的定制链函数完成了内置`chain()`函数的工作。

## 6.将信息发送回生成器

到目前为止，生成器作为单向流量工作，仅在被请求时输出值。虽然它们在大多数场景下服务于我们的业务需求，但单向流量有点无聊，不是吗？实际上，我们可以将信息发送回生成器，使其成为更有趣的双向流量。让我们通过下面这个简单的例子来探索这个特性。

双向发电机

在上面的代码中，我们定义了一个生成器函数，它在池中呈现货币。在初始游戏设置后，池中有$100，我们通过使用`next()`函数检索初始值来学习。随着游戏的进行，用户下注更多的钱，我们通过调用`send()`函数将数据注入生成器来实现。在这种情况下，两轮的赌注是 20 和 50。如您所见，这些数量被添加到生成器生成的运行总数中。

## 7.用生成器抛出异常

上一节回顾了我们如何使用`send()`函数与生成器通信。实际上，还有另一种方式可以实现这种双向通信——`throw`功能。让我们看看它是如何在现实环境中使用下面的例子的。

投入发电机

在上面的代码中，我们模仿了沙子计时器的工作方式。开始时，这个水平是 100 个单位，我们假设每过一段时间，它就会下降 5 个单位。然而，如果我们翻转计时器，它将再次从 100 个单位开始。为了模仿翻转行为，我们在生成器上调用了`throw()`函数。值得注意的是，在捕获和处理异常之后，生成器继续运行，并向我们呈现下一个级别(即 95)。

# 结论

在本文中，我们回顾了 Python 中关于生成器的七个高级特性。了解这些特性不仅可以帮助您避免由于错误使用生成器而可能导致的错误，还可以让您有机会利用这些特性在 Python 代码中创建更健壮的生成器(例如，发送和抛出的双向交互)。