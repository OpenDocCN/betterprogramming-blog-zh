<html>
<head>
<title>Automation With JIRA Webhook and GitHub Actions Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JIRA Webhook和GitHub操作流程的自动化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automation-with-jira-webhook-and-github-actions-workflow-fcd7efbf6688?source=collection_archive---------3-----------------------#2022-05-25">https://betterprogramming.pub/automation-with-jira-webhook-and-github-actions-workflow-fcd7efbf6688?source=collection_archive---------3-----------------------#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5224" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一步一步的指南，介绍如何使用存储库调度从JIRA自动化GitHub actions工作流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/320590398307f9ad6670b63620b2653b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3V9YE8CPlniQjNjxhb1Ijg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@filipbaotic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Filip baoti</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的图像背景</p></figure><p id="6ec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动化使我们能够专注于重要的工作，通过允许我们自动化我们的流程和工作流，消除了执行手动重复任务的需要。JIRA提供了一个简单而强大的规则生成器，我们可以配置自动化规则来处理最复杂的场景。</p><p id="83c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本案例中，我们将探讨如何自动更新JIRA问题状态，以触发GitHub actions工作流，从而为不同环境将Spring Boot微服务工件部署到ECS Fargate。我们的目标:</p><ul class=""><li id="19ee" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用户将JIRA问题的状态更新为<code class="fe me mf mg mh b">DEV</code>；工件通过GitHub actions工作流部署到<code class="fe me mf mg mh b">DEV</code>环境中。</li><li id="5379" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">用户将JIRA问题的状态更新为<code class="fe me mf mg mh b">QA</code>；工件然后相应地被部署到<code class="fe me mf mg mh b">QA</code>环境中。</li><li id="4dbb" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">Prod部署遵循同样的方式。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/67059b47746373f1cbbee0a145aee9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*9nEUvMgFNq9wG9uiZ6p8bA.png"/></div></figure><p id="4900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在JIRA定义一个自动化规则来处理我们用例中的工作流。见下面截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/0c316881ff7f34e1bb05e77f68e7a209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xcq8s-bnWG3ae54mF9eipA.png"/></div></div></figure><p id="a756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几点需要提及:</p><ul class=""><li id="f1a2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">由于用例以JIRA问题中的<code class="fe me mf mg mh b">status</code>字段为中心，我们从<code class="fe me mf mg mh b">When: Issue transitioned</code>开始我们的规则。</li><li id="6322" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">我们使用<code class="fe me mf mg mh b">if/else</code>条件来阐明规则细节。</li><li id="479d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">如果status等于<code class="fe me mf mg mh b">DEV</code>，我们触发一个webhook调用，向GitHub actions工作流发送一个存储库分派事件，以将工件部署到<code class="fe me mf mg mh b">DEV</code>环境中。</li><li id="846b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">如果status等于<code class="fe me mf mg mh b">QA</code>，我们触发一个webhook调用，向GitHub actions工作流发送一个存储库分派事件，以将工件部署到<code class="fe me mf mg mh b">QA</code>环境中。</li><li id="800d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">如果status等于<code class="fe me mf mg mh b">PROD</code>，我们将触发一个webhook调用，向GitHub actions工作流发送一个存储库分派事件，以将工件部署到<code class="fe me mf mg mh b">PROD</code>环境中。</li></ul><p id="7343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mp">假设:该规则只能由对JIRA的特定项目具有管理员权限的用户创建。</em></p><h1 id="12cf" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Webhook配置</h1><p id="96f5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们仔细看看如何在规则中定义webhook。见下面截图。这个webhook本质上是对<a class="ae ky" href="https://docs.github.com/en/rest/repos/repos#create-a-repository-dispatch-event" rel="noopener ugc nofollow" target="_blank"> GitHub的仓库调度API </a>的REST API调用。存储库调度只是对我们的存储库的HTTP请求，要求GitHub启动任何操作或webhook。</p><p id="b66a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用这个特性，我们既可以使用存储库调度来手动触发GitHub动作，也可以设置一个像JIRA这样的应用程序，通过发送web请求来触发动作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/c27746a5f204ee1ea18435aec7281723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5IR2PTw-Zfv2ipJ2EmjrGw.png"/></div></div></figure><p id="71ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要指出几件事:</p><ul class=""><li id="918d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">此端点需要对存储库的写访问权限。标题部分的<code class="fe me mf mg mh b">Authorization</code>需要有值为<code class="fe me mf mg mh b">Bearer &lt;github token&gt;</code>。否则，调用将失败。</li><li id="cf55" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">自定义数据部分。设计如下:</li><li id="3018" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">event_type</code>:我们可以将事件类型定义为<code class="fe me mf mg mh b">event-triggered-by-jira</code>。稍后，在GitHub Actions工作流中，我们根据这个特定的事件类型进行过滤以进行处理。只要这里定义的事件类型与GitHub actions工作流中的事件类型相匹配，我们就可以随意命名。</li><li id="299b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">client_payload</code>参数可用于我们的工作流可能需要的任何额外信息。该参数是一个JSON负载，将在调度webhook事件时传递。在我们的例子中，我们定义了两个参数:</li><li id="63cb" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">jira-issue</code>:这是JIRA发行号，以JIRA smart value <code class="fe me mf mg mh b">{{issue.key}}</code>的形式。我们可以在GitHub操作工作流的提交注释中使用这个JIRA问题编号。</li><li id="92e5" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">env</code>:这是我们想要传递给GitHub actions workflow的环境，因此工件可以部署在这里定义的特定环境中。</li></ul><p id="dfa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规则定义方面就是这样。现在，让我们转到GitHub。</p><h1 id="b7da" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">GitHub环境</h1><p id="79df" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">GitHub环境用于描述一般的部署目标，如<code class="fe me mf mg mh b">DEV</code>、<code class="fe me mf mg mh b">QA</code>或<code class="fe me mf mg mh b">PROD</code>。我们可以用特定于环境的秘密来配置环境。存储库机密充当默认/备份机密。环境机密会覆盖存储库机密。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/47afbd7fee9ef8d359e59b3195d7db9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51aMnLpzg8AVh6f0ZFRInQ.png"/></div></div></figure><p id="c03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以为更高的环境设置环境保护规则，比如<code class="fe me mf mg mh b">PROD</code>。我们可以配置多达六个审核者，以确保部署到<code class="fe me mf mg mh b">PROD</code>确实是有意的并得到批准。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/32762f8a9eff8f1a68151a88274b8164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-pojCNlR3XT-X734MaLREg.png"/></div></div></figure><h1 id="ccbd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">GitHub操作工作流程</h1><p id="80df" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是实际的工件部署发生的地方。完整<code class="fe me mf mg mh b">workflow.yml</code>见下面截图。这个yml文件中添加了注释来解释每个操作的目的。请注意，没有硬编码的环境或其他变量，因此我们可以使用相同的工作流yml部署到基于JIRA <code class="fe me mf mg mh b">status</code>触发器的其他环境中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="339e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几件需要注意的事情:</p><ul class=""><li id="2789" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第34–36行:这是我们通过JIRA自动化规则中的webhook定义的触发器。确保事件类型的值与webhook自定义数据中定义的值完全相同。否则，将不会触发此工作流。</li><li id="8064" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">第58行:这就是GitHub环境施展魔法的地方。我们以<code class="fe me mf mg mh b">${{ github.event.client_payload.env }}</code>的形式传入webhook自定义数据中定义的<code class="fe me mf mg mh b">env</code>值。这告诉GitHub提取该特定环境的秘密，并根据其保护规则进行验证，以将工件部署到该特定环境。</li><li id="be09" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">第188–193行:在上述步骤之后添加了一条注释，以便观看此回购的用户通过电子邮件得到通知，特定的JIRA问题已被部署到在JIRA选择的环境中。</li></ul><h1 id="085b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">决赛成绩</h1><p id="4464" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">以下是由JIRA问题引发的简化部署流程概述:</p><ol class=""><li id="d5dc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ns mb mc md bi translated">一个开发人员被分配到一个JIRA票证上工作，该开发人员从主分支中创建一个特性分支，用JIRA发行号命名该分支，推送代码，提出PR，并在批准后合并PR。</li><li id="34c2" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ns mb mc md bi translated">用户(开发人员或产品所有者？)将JIRA机票状态更改为<code class="fe me mf mg mh b">DEV</code>，JIRA自动化触发GitHub actions工作流将工件部署到<code class="fe me mf mg mh b">DEV</code>环境。</li><li id="3005" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ns mb mc md bi translated">对于任何bug修复，开发者修复代码，推送代码，提出PR，审批后合并PR。</li><li id="4d48" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ns mb mc md bi translated">在错误修复的情况下，JIRA状态可以被更改为不同的值，比如<code class="fe me mf mg mh b">IN PROGRESS</code>，然后被更改回<code class="fe me mf mg mh b">DEV</code>，这将再次触发对<code class="fe me mf mg mh b">DEV</code>环境的最新工件部署。</li><li id="00f5" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ns mb mc md bi translated">一旦<code class="fe me mf mg mh b">DEV</code>测试完成，用户将JIRA状态更改为<code class="fe me mf mg mh b">QA</code>，按照上述相同的流程继续到更高的环境，如<code class="fe me mf mg mh b">PROD</code>。</li><li id="17f7" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ns mb mc md bi translated">可以随时为所有打开的票证调出JIRA报告，其状态字段反映其部署状态的各个阶段。</li><li id="b493" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ns mb mc md bi translated">在GitHub端，所有工件都驻留在主分支中。一个工作流使用从JIRA自动化规则传入的环境变量和JIRA问题编号来处理所有环境的CI和CD。</li><li id="be24" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ns mb mc md bi translated">鼓励在GitHub中配置环境保护规则，至少对于较高的环境是如此，因此每个部署都需要由一个或多个指定人员批准。这也是为了避免肥手指在JIRA的状态更新。</li></ol><h1 id="2edd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="9401" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我们探讨了JIRA自动化规则、webhook配置细节、GitHub环境和GitHub操作工作流。展现JIRA和GitHub之间的自动化魔力很有趣。</p><p id="a606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真正令人兴奋的是，这仅仅是一个用例，我们可以在JIRA和GitHub之间自动化更多的流程。探索愉快！</p><h1 id="b895" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">参考文献</strong></h1><p id="a974" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://www.atlassian.com/software/jira/guides/expand-jira/automation" rel="noopener ugc nofollow" target="_blank">吉拉软件自动化:基础|亚特兰大</a></p><p id="0b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.github.com/en/rest/repos/repos#create-a-repository-dispatch-event" rel="noopener ugc nofollow" target="_blank">仓库— GitHub文档</a></p><p id="0e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment" rel="noopener ugc nofollow" target="_blank">使用部署环境— GitHub文档</a></p></div></div>    
</body>
</html>