<html>
<head>
<title>Composable Reactive UI — Preview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可组合的反应式用户界面—预览</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/composable-reactive-ui-preview-d197cbbc0a71?source=collection_archive---------3-----------------------#2019-05-26">https://betterprogramming.pub/composable-reactive-ui-preview-d197cbbc0a71?source=collection_archive---------3-----------------------#2019-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a225" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过制作ToDo应用程序展示CRUI功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d8933d81c9c8f4357672ed1900eab66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_uBkDS7hTfhKX21thiJPQ.jpeg"/></div></div></figure><p id="35a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用户界面(UI从现在开始)是面向用户的应用程序确保最大参与度的最重要因素之一，然而构建它们并不容易。</p><p id="e345" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使构建UI具有挑战性的是它们的动态性、有状态性和交互性；每个用户的动作都会改变应用程序状态的某个部分，并可能引发许多其他副作用，比如从服务器请求一些新的信息，切换语言等…</p><p id="79ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与编程一样，我们有许多方法来解决同一个问题，并且解决方案根据上下文的不同而不同。</p><p id="66a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CRUI(Composable Reactive UI)是一个新的库，通过以声明的方式关注反应性，同时确保一切都可以很好地组合在一起，来帮助您为Web应用程序构建出色的UI。</p><p id="2937" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">免责声明:</strong> <em class="lo"> CRUI目前只有Typescript版本，还在alpha阶段！从现在开始，你会读到的所有东西都会发生巨大的变化。<br/>本文使用的版本为</em> <code class="fe lp lq lr ls b"><em class="lo">0.1.0-alpha.11</em></code></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="5e97" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">ToDo示例</h1><p id="dec5" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">按照惯例，让我们制作一个ToDo应用程序来展示CRUI功能。</p><p id="e12a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您不熟悉，我们的验收标准将是:</p><ul class=""><li id="7836" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">向待办事项列表添加新任务</li><li id="5db6" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">显示待办事项列表</li><li id="ebe3" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">按可见性过滤待办事项:<br/> *所有<br/> *要完成的任务<br/> *已经完成</li></ul><p id="c9b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们的应用程序的主要组件将是:</p><ul class=""><li id="f146" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">标题</li><li id="25dd" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">添加新的</li><li id="b882" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">待办事项列表</li><li id="b162" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">过滤</li></ul><p id="0b89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">先从最简单的说起:题目。</p><h2 id="760b" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">标题</h2><p id="fd0c" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">标题是一个静态组件，它不会因任何用户交互而改变。在CRUI中实现这一点非常简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b741" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">恭喜，我们刚刚声明了我们的第一个组件！</p><p id="d6e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们声明Title是一个带有子文本节点<code class="fe lp lq lr ls b">TODO App</code>的<code class="fe lp lq lr ls b">h1</code>标签。<br/>我们使用<code class="fe lp lq lr ls b">hc</code>来声明一个带有子元素的元素，而<code class="fe lp lq lr ls b">text</code>用于创建一个文本节点。使用文本节点对于防止XSS攻击很重要，默认情况下，这是使用CRUI插入文本的唯一方法。</p><p id="fee8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您熟悉React，您可能会对直接为孩子使用数组感到惊讶，但对于CRUI，这完全没问题，而且确实有助于可组合性。</p><p id="372b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到用文本显示元素很常见，我们也有一个快捷方式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="66bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组件只是需要做什么的定义，要实际呈现它，我们需要将它安装在DOM中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d46d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第三个参数是上下文，您可以忽略这个细节，因为本文不会涉及到它。</p><h2 id="3e16" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">投入</h2><p id="70a2" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">现在让我们关注与用户的交互。我们希望他们能够在列表中输入新的待办事项。</p><p id="3c52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将需要一个输入标签，让我们也给它添加一些样式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="bfda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是通用元素，也是大多数其他元素的基础。它接收一个<code class="fe lp lq lr ls b">Setup</code>，在这种情况下，它将为这个特定的元素设置<code class="fe lp lq lr ls b">className</code>属性。</p><p id="ce4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">鉴于我们使用的是Typescript，<code class="fe lp lq lr ls b">props</code>将确保只传递有效的属性，因此您不可能错误地使用<code class="fe lp lq lr ls b">class</code>。</p><p id="d01b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使这个组件有用，我们还需要提取用户输入的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="16d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lp lq lr ls b">on</code>将设置一个特定事件，在本例中为<code class="fe lp lq lr ls b">input</code>事件。考虑到我们还需要设置<code class="fe lp lq lr ls b">props</code>，我们需要使用<code class="fe lp lq lr ls b">sc2</code>:<strong class="kt ir">s</strong>etup<strong class="kt ir">c</strong>om bine 2将两个设置合并为一个。</p><h2 id="e6b8" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">反应</h2><p id="66ae" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">这个<code class="fe lp lq lr ls b">core</code>包是关于可组合性和构建ui的，因此，它根本不关心设计的反应性，它只是设置了支持它的基础。</p><p id="a1c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种选择的一个好结果是，CRUI中的reactivity只是一个库，因此可以用许多不同的方式实现。</p><p id="70ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CRUI官方R来自<code class="fe lp lq lr ls b">@crui/reactive</code>包:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8712" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们再次声明了我们的输入组件，但是这次我们用StreamBox绑定了它的值。</p><p id="c753" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们决定避免虚拟DOM，而是使用流作为反应性构建块。流在概念上是可观察的:每次<code class="fe lp lq lr ls b">$box</code>中的值改变时，它都会通知所有的观察者。</p><p id="f82d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lp lq lr ls b">bindValue</code>将确保<code class="fe lp lq lr ls b">$box</code>和输入值始终同步，相应地改变两侧。</p><p id="93e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着如果我们运行:</p><pre class="kg kh ki kj gt nz ls oa ob aw oc bi"><span id="144f" class="nl mb iq ls b gy od oe l of og">$box.set('hello!')</span></pre><p id="654f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输入值也会立即改变。</p><h2 id="10d9" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">使服从</h2><p id="3ea9" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">既然我们有了捕捉用户输入的好方法，我们需要一个按钮来触发新todo的创建:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a25b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lp lq lr ls b">sc</code>将任意数量的<code class="fe lp lq lr ls b">Setup</code>组合成一个。<br/> <code class="fe lp lq lr ls b">ctext</code>是<code class="fe lp lq lr ls b">child</code>和<code class="fe lp lq lr ls b">text</code>的组合，因此会增加一个新的文本节点。<br/>顾名思义，<code class="fe lp lq lr ls b">onClick</code>会设置一个<code class="fe lp lq lr ls b">click</code>事件处理程序。</p><p id="f7a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">声明部分现在应该很熟悉了，重要的是理解如何实际执行这个操作。</p><p id="e0b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从概念上讲，我们需要从输入中获取值，然后将它放入某种todo列表中。就像在生活中，当你不知道如何做某事时，就去问别人！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0e2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">细心的读者会注意到，我们也在清理，确保一个美好的UX。</p><h2 id="2c83" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">添加更多结构</h2><p id="5c55" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">如果你想以库的形式发布一个组件，只公开我们需要的是最好的方法，但是，如果我们想在这里构建一个应用程序，我们可以更进一步，给它更多的结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2f51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请记住，由于订阅机制的工作方式，垃圾收集器将无法清理流，因此在不需要时销毁它们以避免内存泄漏非常重要。</p><p id="8e80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理解流的所有者(即:谁将破坏它)是正确使用流的基础，但是跟踪它可能是棘手的，并且容易出现错误。猜猜谁擅长记录？一个编译器！</p><p id="da2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么我们提供了一套接口，使工作与流相当愉快。让我们来关注一下<code class="fe lp lq lr ls b">getInput</code>型签名:</p><pre class="kg kh ki kj gt nz ls oa ob aw oc bi"><span id="2635" class="nl mb iq ls b gy od oe l of og">getInput(): RW$B&lt;string&gt;</span></pre><p id="7b34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个有趣的返回类型代表<strong class="kt ir">R</strong>EAD-<strong class="kt ir">W</strong>rite<strong class="kt ir">$</strong>Stream<strong class="kt ir">B</strong>ox，它给了我们一个可以自由操纵，但不能破坏的流！为了能够被破坏，它还应该包括接口<code class="fe lp lq lr ls b">Destroyable</code>。通过限制暴露类型，我们确保没有其他人可以破坏它，同时也承诺我们会保护它。</p><p id="9f6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">新的submit元素将类似于:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="89cc" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">更新输入</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="667b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">setup <code class="fe lp lq lr ls b">bindValue</code>期望对所提供的流拥有完全的所有权，这意味着它将销毁它。然而，我们刚刚说过，TodoStore是输入流的实际所有者，因此我们需要克隆所提供流的读写版本，这正是<code class="fe lp lq lr ls b">cloneRW</code>所做的。</p><h2 id="3040" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">AddTodo</h2><p id="f149" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">现在我们已经拥有了创建AddTodo所需的全部内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="9e6a" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">待办事项列表</h2><p id="6607" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">我们需要显示一个所有待办事项的列表，我们已经有了这样一个列表，所以我们可能会写类似这样的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2e1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将为第一次渲染工作，但同样没有反应的知识。</p><p id="6582" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要另一个流，而<code class="fe lp lq lr ls b">@crui/reactive</code>提供了一个优化列表的流:StreamList。</p><pre class="kg kh ki kj gt nz ls oa ob aw oc bi"><span id="464d" class="nl mb iq ls b gy od oe l of og">type TodoList = R$L&lt;Todo&gt;</span></pre><p id="d1f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们将暴露类型进一步限制为<strong class="kt ir">R</strong>EAD<strong class="kt ir">$</strong>stream<strong class="kt ir">L</strong>ist，因此我们只能从中读取值，而不能更改或破坏它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1dad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">唯一值得一提的是，<code class="fe lp lq lr ls b">DRW$L</code>代表<strong class="kt ir">D</strong>estroyable<strong class="kt ir">R</strong>EAD-<strong class="kt ir">W</strong>rite<strong class="kt ir">$</strong>stream<strong class="kt ir">L</strong>ist。</p><p id="94e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来是实际的待办事项列表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8a28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TodoList现在是反应式的，每个新的todo都会像预期的那样自动添加到DOM中。</p><h2 id="d924" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">切换待办事项状态</h2><p id="a04e" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">我们的Todo目前只是文本，但我们也需要将其标记为已完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c1ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到现在为止，您应该已经意识到这是多么具有宣示性了。通过查看类型，您可以推断出<code class="fe lp lq lr ls b">done</code>属性将随着时间而改变，而<code class="fe lp lq lr ls b">text</code>将保持不变。</p><p id="4d53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们更新我们的TodoStore:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c17c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后是我们的Todo元素:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4ae5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">待办事项文本附近将显示一个复选框。值得一提的是，<code class="fe lp lq lr ls b">bindChecked</code>将只适用于<code class="fe lp lq lr ls b">input</code> HTML标签，如果你试图通过其他任何东西，Typescript会抱怨！<code class="fe lp lq lr ls b">bindChecked</code>也会将输入<code class="fe lp lq lr ls b">type</code>属性设置为<code class="fe lp lq lr ls b">checkbox</code>。</p><p id="d779" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe lp lq lr ls b">hcc</code>中，我们进一步抽象了具有CSS类和子元素的元素的概念，这对于创建小的、集中的实用函数来说是很棒的，这使得代码更易于维护。</p><h2 id="a5be" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">过滤器</h2><p id="ffd5" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">接下来，我们需要处理3个过滤器。为了建立它们，我们首先必须从可见性的概念开始，即:我们可以过滤什么。</p><pre class="kg kh ki kj gt nz ls oa ob aw oc bi"><span id="b659" class="nl mb iq ls b gy od oe l of og">enum Visibility {<br/>    ALL,<br/>    TODO,<br/>    DONE,<br/>}</span></pre><p id="9748" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单个过滤器可以只是一个将设置适当可见性的按钮:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="69e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将收到一个可见性的读写流和一个由这个特定过滤器表示的可见性。</p><p id="6318" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">值得一提的是，<code class="fe lp lq lr ls b">map</code>将创建另一个StreamBox，它将相应地更新其父流；一旦不再需要，就会清理干净。</p><p id="51bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们更新商店以支持可见性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b286" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们只包括了我们需要添加到前面的TodoStore定义中的内容，以便不使读者感到困惑。</p><h2 id="32af" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">过滤</h2><p id="a644" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">这个现在很简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="f039" class="nl mb iq bd mc nm nn dn mg no np dp mk la nq nr mm le ns nt mo li nu nv mq nw bi translated">过滤TodoList</h2><p id="8c1c" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">即使我们添加了可见性的概念，我们的列表也不知道它。</p><p id="3340" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的列表需要对3种不同的用户交互做出反应:</p><ul class=""><li id="1013" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">一个新项目被推入列表</li><li id="292a" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">应用了新的可见性过滤器</li><li id="6b5f" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">todo项目状态被切换</li></ul><p id="c5ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经讨论了第一种情况，并且已经有了一个可见性流，所以我们可以将它放入谓词流中:</p><pre class="kg kh ki kj gt nz ls oa ob aw oc bi"><span id="26a2" class="nl mb iq ls b gy od oe l of og">Predicate&lt;T&gt; = (val: T) =&gt; boolean</span></pre><p id="afd6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的第一次尝试可能是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d030" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可以做到，但是切换todo项目状态不会再次激活过滤器逻辑，所以我们真正需要的是我们称之为谓词流的流:</p><pre class="kg kh ki kj gt nz ls oa ob aw oc bi"><span id="cc2b" class="nl mb iq ls b gy od oe l of og">$Predicate$&lt;T&gt; = R$B&lt;Predicate$&lt;T&gt;&gt;<br/>Predicate$&lt;T&gt; = (val: T) =&gt; DR$B&lt;boolean&gt;</span></pre><p id="4cbf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TodoStore将成为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4db1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lp lq lr ls b">clone</code>将创建一个只读的、可销毁的流副本，这有助于避免代码的其他部分与原始流混淆。</p><p id="a105" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最难的部分已经完成了，现在我们可以声明我们的TodoList被一个$Predicate$过滤。幸运的是，有一个函数可以做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d419" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lp lq lr ls b">c$filter$$</code>类似于<code class="fe lp lq lr ls b">c$map</code>，但是除了映射项目之外，它还会相应地过滤它们。考虑到它期望过滤器生成一个布尔流，一旦不再需要它们，它也会负责销毁所有的布尔流。切换过滤器会破坏当前的过滤器逻辑和它使用的所有流，这就是为什么使用<code class="fe lp lq lr ls b">clone</code>很重要。</p><p id="374e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想指出的一点是，这个函数和<code class="fe lp lq lr ls b">c$map</code> <strong class="kt ir">都不会在每次有变化时重新计算整个列表</strong>，而是会根据流更新来外科手术式地更新DOM。这意味着从列表中添加/删除元素的算法复杂度与<code class="fe lp lq lr ls b">Array.prototype.splice</code>相同。</p><p id="51f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是拼图的最后一块，我们的实现也随之结束了！你可以在GitHub上看到完整的例子:<a class="ae ln" href="https://github.com/cruijs/crui/tree/master/packages/eg-reactive-todos" rel="noopener ugc nofollow" target="_blank"> CRUI Todos </a></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2cb0" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">谢谢大家！</h1><p id="a38d" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">如果你一直读到这里，非常感谢，非常感激！</p><p id="3bbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这至少能激起你的兴趣。我正计划发布更多的文章:一篇关于事物如何在幕后工作，另一篇解释这个库背后的动机。</p><p id="06ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">敬请期待，下期再见！</p></div></div>    
</body>
</html>