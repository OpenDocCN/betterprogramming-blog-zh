<html>
<head>
<title>How To Process Video With FFmpeg and NodeJs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用FFmpeg和NodeJs处理视频</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-process-video-with-ffmpeg-and-nodejs-940a8e510791?source=collection_archive---------0-----------------------#2022-10-06">https://betterprogramming.pub/how-to-process-video-with-ffmpeg-and-nodejs-940a8e510791?source=collection_archive---------0-----------------------#2022-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在这里，我们揭示了用FFmpeg处理视频的一些方法，以及如何在JS栈中使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d679728547043c13dd051598a5469de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwvqredc69hEjjnHqyc5ew.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ffef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">应用程序中的视频处理是当今的主流，我们作为开发人员应该遵循它。乍一看，这似乎是一个非常困难的话题，需要特殊的知识和教育。幸运的是，一些框架旨在简化这一过程，并提供一种声明性的方式来表达我们需要以何种方式处理视频的意图。</p><p id="b7fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一个框架叫做<a class="ae lu" href="https://ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> FFmpeg </a>。它提供了一个特殊的命令行界面(CLI ),看起来它可以完成所有需要的事情。作为工程师，我们只需要查看文档并创建一个特殊的命令。</p><h1 id="6a8c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先决条件</h1><p id="a5d3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在这篇文章中，我们将实现一个特定的项目，并获得足够的知识用于您的个人项目。</p><p id="179c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整的代码将会在GitHub资源库中提供，你可以在这里找到<a class="ae lu" href="https://github.com/vladimirtopolev/ffmpeg-composition-tutorial" rel="noopener ugc nofollow" target="_blank">。自述文件中有关于如何运行和使用服务器的说明。该项目用FFmpeg版本4.4.1和NodeJS版本16.15.0进行了测试。</a></p><p id="b0c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们开始之前，我强烈推荐阅读这篇文章，因为它提供了FFmpeg语法的一般概述，并解释了过滤器如何工作，因为过滤器是这个框架的核心，我们将进一步使用它们。</p><blockquote class="ms mt mu"><p id="8f04" class="ky kz mv la b lb lc ju ld le lf jx lg mw li lj lk mx lm ln lo my lq lr ls lt im bi translated">注意FFmpeg是在<a class="ae lu" href="http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html" rel="noopener ugc nofollow" target="_blank"> GNU宽松通用公共许可证(LGPL)版本2.1 </a>或更高版本下。在任何商业项目中使用FFMPEG组件之前，您应该咨询法律团队并研究FFmpeg网站的<a class="ae lu" href="https://www.ffmpeg.org/legal.html" rel="noopener ugc nofollow" target="_blank">法律部分</a></p></blockquote><p id="806c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，最初的任务如下——用户应该记录他们对一些面试问题的回答；然后，前端(FE)将这些视频块发送到服务器，并附带与每个视频块相关联的元数据(在我们的例子中，是问题本身以及用户的名字和姓氏)。</p><p id="be93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我跳过了FE部分的实现，将摄像机录制的视频直接放入服务器<code class="fe mz na nb nc b">/src/media/camera</code>。它包括两个录制的MP4格式的视频，分辨率为1280x720(也可能以WebM格式交付，但这并不重要，因为FFmpeg可以轻松地将视频从一种格式转换为另一种格式)。</p><p id="bf16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要从所有记录的块中创建一个视频组合，并在每个块之前放置一些封面(图1):</p><ul class=""><li id="2978" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">用标题覆盖——在这里我们需要包含用户的名字和姓氏(图片。1: 1)</li><li id="71b6" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">用一个问题覆盖——在每个记录的组块之前，我们需要在那里加入一个问题(图片。1: 2, 4)</li><li id="3ba6" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">记录块-我们需要把一个标志水印放在里面，并调整它以适应预期的分辨率9x16(图片。1: 3, 5 )</li><li id="1109" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">片尾——这一大块将由Motion Designer准备，我们不需要做任何修改，只需将其连接到最终的视频(图片。1: 6)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/2d3f4b89880dc7c54cfa12fff1cb4015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pi7xhdLgT7Aj4yvsZv3HXg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1 —最终视频合成方案</p></figure><p id="7d3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，动作设计师还应该为屏幕1、2和6准备视频封面，只跳过那些被认为是可变的元素(例如，名字、姓氏或问题)。您可以在项目资源库文件夹<code class="fe mz na nb nc b">/src/media/covers</code>中找到所有这些封面</p><p id="d5c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面你可以看到我们将要创作的最终作品:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="75eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，您可以看到如何以编程方式更改名字或姓氏并生成新组合的过程(当然，您可以根据需要更改任何其他初始数据):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nt l"/></div></figure><h1 id="36f1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.使用FFmpeg的方法</h1><p id="c9d4" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">有很多方法可以使用这个框架。让我们来看看其中一些可能有趣的。</p><h2 id="06cb" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">1.1.在本地机器的终端中运行FFmpeg命令</h2><p id="c95c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">首先，您需要在本地机器上安装FFmpeg(要了解更多信息，请参见这个<a class="ae lu" href="https://ffmpeg.org/download.html" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><p id="45fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装后，确保FFmpeg可用:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="a13e" class="nv lw it nc b gy ol om l on oo">ffmpeg -version</span></pre><p id="e2a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一切正常，您可以创建特定的命令。例如，这个将两个视频<code class="fe mz na nb nc b">in1.avi</code>和<code class="fe mz na nb nc b">in2.avi</code>连接成一个名为<code class="fe mz na nb nc b">out.avi</code>的视频</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="05a5" class="nv lw it nc b gy ol om l on oo">&gt;  ffmpeg -i in1.avi -i in2.avi -filter_complex concat out.avi</span></pre><h2 id="334d" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">1.2.在NodeJS服务器上将FFmpeg作为命令运行</h2><p id="7303" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们假设我们的服务器应该在Docker容器中启动。当然，我们需要把它安装在里面。您的Docker文件可能如下所示:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="9668" class="nv lw it nc b gy ol om l on oo">FROM node:16 AS deps<br/>WORKDIR /app<br/>COPY . .<br/>RUN wget <a class="ae lu" href="https://www.johnvansickle.com/ffmpeg/old-releases/ffmpeg-4.4.1-arm64-static.tar.xz" rel="noopener ugc nofollow" target="_blank">https://www.johnvansickle.com/ffmpeg/old-releases/ffmpeg-4.4.1-arm64-static.tar.xz</a> &amp;&amp;\<br/>    tar xvf ffmpeg-4.4.1-arm64-static.tar.xz &amp;&amp;\<br/>    mv ffmpeg-4.4.1-arm64-static/ffmpeg /usr/bin/ &amp;&amp;\<br/>    mv ffmpeg-4.4.1-arm64-static/ffprobe /usr/bin/ <br/>#RUN apt install -y ffmpeg<br/>RUN yarn install<br/>RUN yarn build</span><span id="7c62" class="nv lw it nc b gy op om l on oo">EXPOSE 3000</span><span id="8fbf" class="nv lw it nc b gy op om l on oo">ENV PORT 3000</span><span id="bcfb" class="nv lw it nc b gy op om l on oo">CMD [ "node", "dist/index.js" ]</span></pre><p id="ac0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，您可以在NodeJS服务器上以这种方式执行任何FFmpeg命令:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="660b" class="nv lw it nc b gy ol om l on oo">import { exec } from 'child_process';</span><span id="38d4" class="nv lw it nc b gy op om l on oo">exec('ffmpeg -i in1.avi -i in2.avi -filter_complex concat out.avi')</span></pre><p id="b58b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在docker容器中安装FFmpeg并不是最好的选择，所以我们要使用<a class="ae lu" href="https://www.npmjs.com/package/@ffmpeg-installer/ffmpeg" rel="noopener ugc nofollow" target="_blank">@ FFmpeg-installer/FFmpeg</a>NPM依赖。它为当前平台安装了一个<code class="fe mz na nb nc b">ffmpeg</code>的二进制文件，并提供了一个到框架的路径。代码看起来像这样:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="d6e5" class="nv lw it nc b gy ol om l on oo">import { path as ffmpeg } from '@ffmpeg-installer/ffmpeg';<br/>import { exec } from 'child_process';</span><span id="4108" class="nv lw it nc b gy op om l on oo">exec(`${ffmpeg} -i i1.avi -i i2.avi -filter_complex concat out.avi`)</span></pre><p id="d4fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对了，如果这种情况下需要使用<code class="fe mz na nb nc b">ffprobe</code>，还有另外一个安装程序——<a class="ae lu" href="https://www.npmjs.com/package/@ffprobe-installer/ffprobe" rel="noopener ugc nofollow" target="_blank">@ ff probe-installer/ff probe</a>，工作方式也是一样的:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="9a50" class="nv lw it nc b gy ol om l on oo">import { path as ffprobePath } from '@ffprobe-installer/ffprobe';<br/>import { exec } from 'child_process';</span><span id="d488" class="nv lw it nc b gy op om l on oo">exec(`${ffprobePath} -v quiet \<br/>   -print_format json \<br/>   -show_format \<br/>   -show_streams \<br/>   /path/to/input.mp4 \ <br/>   &gt; <!-- -->/path/to/file/where/with/meta.json<!-- -->`<br/>)</span></pre><p id="a49f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该命令从视频<code class="fe mz na nb nc b">/path/to/input.mp4</code>中提取元信息，并以JSON格式打印在文件<code class="fe mz na nb nc b">/path/to/file/where/with/meta.json</code>中</p><h2 id="622a" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">1.3.在NodeJS服务器上用特殊的包装器运行FFmpeg</h2><p id="954b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">尽管FFmpeg命令看起来非常具有声明性，但它仍然不是在服务器上将该命令作为字符串处理并以编程方式连接不同部分的最方便的方式。在这种情况下，你可以使用库<a class="ae lu" href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg" rel="noopener ugc nofollow" target="_blank"> fluent-ffmpeg </a>。我们通过构建器模式构建FFmpeg字符串命令，可以链接不同的逻辑部分。</p><p id="0b89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，这个命令</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="fb2e" class="nv lw it nc b gy ol om l on oo">exec(`${ffmpeg} -i i1.avi -i i2.avi -filter_complex concat out.avi`)</span></pre><p id="9f89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以这样改写:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="23a5" class="nv lw it nc b gy ol om l on oo">import * as ffmpeg from 'fluent-ffmpeg';</span><span id="cc94" class="nv lw it nc b gy op om l on oo">ffmpeg()<br/>  .input('i1.avi')<br/>  .input('i2.avi')<br/>  .filterComplex('concat)<br/>  .output('out.avi')</span></pre><p id="a2f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也许，这个命令没有给人留下深刻的印象，也没有显示出所有的好处，但无论如何，使用起来还是很舒服的。</p><p id="2277" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便说一下，如果你想使用安装程序安装的框架<a class="ae lu" href="https://www.npmjs.com/package/@ffmpeg-installer/ffmpeg" rel="noopener ugc nofollow" target="_blank">@ ffmpeg-installer/ffmpeg</a>或<a class="ae lu" href="https://www.npmjs.com/package/@ffprobe-installer/ffprobe" rel="noopener ugc nofollow" target="_blank">@ ff probe-installer/ff probe</a>——你应该定义这些路径:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="98bb" class="nv lw it nc b gy ol om l on oo">import { path as ffmpegPath } from '@ffmpeg-installer/ffmpeg';<br/>import { path as ffprobePath } from '@ffprobe-installer/ffprobe';<br/>import * as ffmpeg from 'fluent-ffmpeg';</span><span id="a0fe" class="nv lw it nc b gy op om l on oo">// set paths<br/>ffmpeg.setFfmpegPath(ffmpegPath);<br/>ffmpeg.setFfprobePath(ffprobePath);</span></pre><p id="9ce8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不设置这些路径，<code class="fe mz na nb nc b">fluent-ffmpeg</code>将试图直接调用<code class="fe mz na nb nc b">ffmpeg</code>(所以它应该在你的<code class="fe mz na nb nc b">PATH</code>)。</p><h2 id="e186" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">1.4在浏览器中运行FFmpeg</h2><p id="756d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">它太酷了，你甚至可以在浏览器中运行FFmpeg。我不打算在本文中重点讨论这个问题，但是您可以在这里自己探索一下——一个名为FFMPEG的项目。WASM</p><h1 id="1481" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.项目执行</h1><p id="c649" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">看起来我们准备好开始了。</p><h2 id="b693" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">2.1调整视频录制块的分辨率</h2><p id="38f3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">首先，我们录制的组块的分辨率是1280x720 (16x9)，但是根据构图(图1)，应该调整为9x16分辨率的视频。</p><p id="a965" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们可以使用<code class="fe mz na nb nc b">crop</code>滤波器(文档在此处为<a class="ae lu" href="https://ffmpeg.org/ffmpeg-filters.html#crop" rel="noopener ugc nofollow" target="_blank"/>)。在图2中，我们反映了任务的参数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/ce66e6afcc42c323641e6f31f5df6612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ya2zHM1cDW7ELy4uY1zFyg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片2 —将分辨率为16x9的视频调整为分辨率为9x16的视频</p></figure><p id="e846" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，过滤器参数可能被设置为数学表达式，您可能包括文档中列出的所有内容，在我们的例子中，我们有一种方法来提取输入宽度/高度(<code class="fe mz na nb nc b">in_w/in_h</code>)和输出宽度/高度(<code class="fe mz na nb nc b">ow/oh</code>)</p><p id="b525" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们编写命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or nt l"/></div></figure><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="5406" class="nv lw it nc b gy ol om l on oo">Sometimes, it’s pretty important to see the final command that <!-- -->fluent-ffmpeg<!-- --> compile and we achieve that with the following event:</span><span id="172a" class="nv lw it nc b gy op om l on oo">ffmpegCommand<br/>   .on('start', (commandLine) =&gt; {<br/>      console.log(`Spawned command: ${commandLine}`);<br/>   })<br/>   .run()</span></pre><p id="686f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的例子中，它用下面的命令编译:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="7cc7" class="nv lw it nc b gy ol om l on oo">ffmpeg \ <br/>   -i /path/to/input/video \<br/>   -filter:v crop=w=in_h*9/16:h=in_h:x=(in_w-ow)/2:y=0 \ <br/>   /path/to/output/video</span></pre><h2 id="4e10" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">2.2在记录的块下放置水印</h2><p id="04fb" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">为此，FFmpeg有一个特殊的<code class="fe mz na nb nc b">overlay</code>视频滤镜(文档是<a class="ae lu" href="https://ffmpeg.org/ffmpeg-filters.html#overlay-1" rel="noopener ugc nofollow" target="_blank">这里是</a>)。它有两个输入，一个输出。第一个输入是第二个输入覆盖的“主”视频。第二输入可以是视频或图像。</p><p id="f82c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该命令的原始结构如下所示:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="af7c" class="nv lw it nc b gy ol om l on oo">ffmpeg <br/>   -i /path/to/main/video<br/>   -i /path/to/overlaid/content<br/>   -filter_complex overlay=x:y<br/>   /path/to/output</span></pre><p id="96b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，我们只需要计算出所需的<code class="fe mz na nb nc b">x</code>和<code class="fe mz na nb nc b">y</code>坐标，并根据设计进行调整(图1；3d屏幕):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/a8bc6ef3abc16db5684e6ba937ec1a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZDHdp1Uoyt9mAHCVtDj9A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3-叠加滤镜设置</p></figure><p id="c258" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe mz na nb nc b">fluent-ffmpeg</code>可以将该命令转换为以下命令:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="81de" class="nv lw it nc b gy ol om l on oo">ffmpeg()<br/>   .input('./input/video.mp4')<br/>   .input('./input/logo.png')<br/>   .complexFilter(['overlay=W/2-w/2:H-h-30'])<br/>   .output('./output.mp4')</span></pre><h2 id="6882" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">2.3代码优化</h2><p id="af66" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们可以创建两个单独的命令(像2.1和2.2中那样)一个接一个地应用于记录的块。但是在这种情况下，每个命令的FFmpeg应该为每个命令编码和解码媒体——这不是一种非常有效的方式。</p><p id="326b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Fmpeg允许我们使用一个过滤图将所有内容组合在一个命令中(让我提醒您，详细的解释在文章<a class="ae lu" href="https://medium.com/numatic-ventures/how-to-process-video-with-ffmpeg-framework-syntax-from-zero-to-hero-81812e8e8785" rel="noopener">这里</a>中提供)。</p><p id="0cdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们描述一下为新命令提供心理感知的过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/e3675e917e5871562436461d777a6d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xb5gyrr4BFa7WdMvEwSS_w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4 —通过一个命令中的过滤器图连接一些过滤器</p></figure><p id="f7ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个合并在一个命令中的过滤图如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or nt l"/></div></figure><h2 id="1de7" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">2.4在标题封面中包含名字和姓氏</h2><p id="269e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这里我们有名字和姓氏的具体值。此外，正如我之前提到的那样，运动设计师初步为这个封面准备了一个带动画的视频，没有被认为是可变的元素(图片1:屏幕1)。这个视频可以在项目资源库文件夹中找到:<code class="fe mz na nb nc b">src/media/covers/start.mp4</code></p><p id="ed0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了在视频中融入文字，FFmpeg有一个特殊的<code class="fe mz na nb nc b">drawtext</code>滤镜(文档在这里是<a class="ae lu" href="https://ffmpeg.org/ffmpeg-filters.html#drawtext-1" rel="noopener ugc nofollow" target="_blank"/>)。了解了滤镜属性后，让我们根据设计来定义我们的期望(图1:屏幕1):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/e005057082e8c3cb405f301a6480c048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOX9m8zF6-0GJ__cF0z6pg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5 —绘图文本过滤器的计算</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or nt l"/></div></figure><h2 id="71af" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">2.5纳入问题文本</h2><p id="4f76" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我将跳过这一部分的解释，但简单地说，我们将再次使用<code class="fe mz na nb nc b">drawtext</code>过滤器，其方法与2.5节中描述的完全相同。此外，您还有机会在这里查看项目资源库<a class="ae lu" href="https://github.com/vladimirtopolev/ffmpeg-composition-tutorial" rel="noopener ugc nofollow" target="_blank">中的代码。</a></p><h2 id="fbed" class="nv lw it bd lx nw nx dn mb ny nz dp mf lh oa ob mh ll oc od mj lp oe of ml og bi translated">2.6将所有视频合并在一起</h2><p id="139c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在到达这一部分时，我们应该已经处理了所有的块，我们只需要将它们连接在一起。FFmpeg有一个特殊的<code class="fe mz na nb nc b">concat</code>滤镜(文档是<a class="ae lu" href="https://ffmpeg.org/ffmpeg-filters.html#concat" rel="noopener ugc nofollow" target="_blank">这里是</a>)。在拼接之前，我们应该确保所有合并的部分具有相同的分辨率(在我们的项目中，我们遵循这种方法，所有块都具有404x720的分辨率)和相同的FPS(每秒帧数)。</p><p id="d22b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个函数，它接受应该被污染的输入路径的数组和输出路径的字符串。我们的函数将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or nt l"/></div></figure><blockquote class="ms mt mu"><p id="15ee" class="ky kz mv la b lb lc ju ld le lf jx lg mw li lj lk mx lm ln lo my lq lr ls lt im bi translated">注意:如果您想跟踪进度，您可以像我们在上面代码中所做的那样订阅一个<code class="fe mz na nb nc b"><em class="it">progress</em></code>事件。</p></blockquote><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="ecfa" class="nv lw it nc b gy ol om l on oo">ffmpegCommand.on('progress', (progress) =&gt; console.log(progress))</span></pre><h1 id="e41f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.把所有东西放在一起</h1><p id="3937" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在我们已经实现了应用程序的主要部分。最后一步是把所有东西粘在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or nt l"/></div></figure><h1 id="b1ae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5c99" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">FFmpeg是一个健壮的视频处理解决方案，你可以将它与JS栈集成。FFmpeg有许多可以组合在一起并创建复杂结构的过滤器。我希望这个小项目证明它并不像看起来那么难。</p><p id="5efc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我提醒你，代码可能在GitHub库<a class="ae lu" href="https://github.com/vladimirtopolev/ffmpeg-composition-tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="c704" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">来源</h1><ol class=""><li id="d575" class="nd ne it la b lb mn le mo lh ov ll ow lp ox lt oy nj nk nl bi translated"><a class="ae lu" href="https://medium.com/numatic-ventures/how-to-process-video-with-ffmpeg-framework-syntax-from-zero-to-hero-81812e8e8785" rel="noopener">如何用FFmpeg处理视频？从零到英雄的框架语法。</a></li><li id="454c" class="nd ne it la b lb nm le nn lh no ll np lp nq lt oy nj nk nl bi translated"><a class="ae lu" href="https://medium.com/numatic-ventures/top-17-ffmpeg-commands-of-video-processing-64b587325d9e" rel="noopener">视频处理的前17个FFmpeg命令</a></li><li id="aaaf" class="nd ne it la b lb nm le nn lh no ll np lp nq lt oy nj nk nl bi translated"><a class="ae lu" href="https://ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> FFmpeg官方网站</a></li><li id="9ea4" class="nd ne it la b lb nm le nn lh no ll np lp nq lt oy nj nk nl bi translated"><a class="ae lu" href="http://www.ffmpeg.org/ffmpeg-filters.html" rel="noopener ugc nofollow" target="_blank"> FFmpeg滤波器文档</a></li><li id="f7c8" class="nd ne it la b lb nm le nn lh no ll np lp nq lt oy nj nk nl bi translated"><a class="ae lu" href="http://ffmpeg.tv/" rel="noopener ugc nofollow" target="_blank"> FFmpeg基础知识。使用快速音频和视频编码器进行多媒体处理</a></li></ol></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="57fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢阅读这篇文章。很高兴看到任何关于应该被涵盖的项目的评论。感谢任何有助于改进文章的帮助。谢谢你。</p></div></div>    
</body>
</html>