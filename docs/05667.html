<html>
<head>
<title>Why Python Written in Python Is Faster Than Regular Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么用Python写的Python比普通Python快</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-python-written-in-python-is-faster-than-regular-python-b682992d5812?source=collection_archive---------1-----------------------#2020-07-27">https://betterprogramming.pub/why-python-written-in-python-is-faster-than-regular-python-b682992d5812?source=collection_archive---------1-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="83cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们需要更深入</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98d36a66b7ea5960a7d6f693cee7f599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B3e_kXF59m_6sgKJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯蒂安·恩格梅尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="7263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实话实说:Python很慢。当我说<em class="lv"> Python </em>时，我指的是CPython，它的参考基于C的实现。这就是PyPy发挥作用的地方。它是用Python(！)比CPython快4.4倍。怎么会？请继续阅读。</p><blockquote class="lw"><p id="20a8" class="lx ly it bd lz ma mb mc md me mf lu dk translated">"如果你想让你的代码运行得更快，你应该使用PyPy . "——<a class="ae ky" href="https://www.pypy.org/" rel="noopener ugc nofollow" target="_blank">吉多·范·罗苏姆</a>(字面意思是创造了Python)</p></blockquote><p id="56f7" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">有竞争力的程序员是第一批利用PyPy能力的人。有时候，用Python编写的解决方案会耗时太长而失败，但是用PyPy运行的相同代码会成功通过。怎么会？</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="3eb5" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">不同的方法</h1><p id="cff2" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">你可能知道Python是我们所说的<em class="lv">解释的</em>语言。CPython逐行读入源代码并执行它。解释语言(包括JavaScript)有许多优点:</p><ul class=""><li id="cc3f" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">解释器非常容易编写。</li><li id="930d" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://everyday.codes/python/abstract-classes-and-meta-classes-in-python/" rel="noopener ugc nofollow" target="_blank">强大的元编程能力</a>。</li><li id="5b53" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">没有编译时失败。</li></ul><p id="0c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，也有一些缺点:</p><ul class=""><li id="544f" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">运行时解析源代码的严重性能开销。</li><li id="d62c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">没有编译时失败。</li></ul><p id="d36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到我在优点和缺点中包括了“没有编译时失败”。可能有些时候你需要不同的行为(例如，当你在做原型或者生产的时候)，但是我仍然倾向于把它看作一个缺点。</p><p id="fd39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyPy做事有点不一样。这不是一个纯粹的解释器，而是实现了跟踪实时(JIT)编译。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5b11" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">即时编译</h1><p id="2909" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">即时编译是解释和常规提前编译之间的中间地带。实时编译器不执行源代码本身，而是生成一组几乎立即执行的低级指令(通常是汇编指令)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2caf2b0b13e3dd8e71b3a27fa6b5e3b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*jh17v5Aa5EtrWGrB"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="6666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个插图应该有助于你理解其中的区别。在编译语言(C，C++，Rust)中，编译阶段被严格划分到开发环境中。它生成一个可运行的二进制文件，然后发送到生产环境。在解释语言中，情况正好相反:源代码(after * entification，hello JS)被完整地推向生产，在那里解释器将执行它。JIT语言也提供源代码(或字节码，如Java或C#)，但它是作为常规编译语言编译和运行的，而不是逐行解释的。</p><p id="d57a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不是说一种方法比另一种好。每个用例都会根据其独特的需求做出正确的选择。但是，如果性能很重要，并且您喜欢使用Python解释器，PyPy将是您的选择。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="f076" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">跟踪实时编译</h1><p id="3230" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">就像编译或解释一样，有不同的方法来实现实时编译。传统的是方法/函数范围的。当您的代码调用一个函数时，JIT编译器将获取它的源代码，编译并提供可执行的二进制文件。PyPy采用了稍微不同的方法，这是由Python的独特特性和用例决定的。</p><p id="2f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyPy的编译器评估循环，而不是每个方法调用。由于Python大量用于数据科学、机器学习以及高级算法和数据结构的广泛使用，这是最有意义的。简而言之，PyPy是Python之上的一个优化层。</p><p id="d1e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyPy并不严格处理你所理解的循环。除了常规的<code class="fe oe of og oh b">for</code>和<code class="fe oe of og oh b">while</code>构造，如果PyPy检测到编译工作值得的话，它会优化任意代码块。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="181f" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">缺点</h1><p id="dc39" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">当然，PyPy也是一个有缺点的工具。即使您获得了巨大的性能提升，也要记住以下几点:</p><ul class=""><li id="1283" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">并非所有Python都受支持。你的大部分代码都是这样，但是如果你处理低级别的CPython实现细节或者有一些Cython绑定，这就不行了。</li><li id="927f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">回到未来。PyPy的当前版本是3.4，而Python目前稳定在3.8。但是回溯是我们Python们非常擅长的事情(现在对Python v2开发人员大喊)。</li><li id="1fac" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">优化是好的，但这不是编写糟糕代码的借口。如果你的代码人类无法读懂，你怎么能指望PyPy理解它呢？</li><li id="f956" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank"/><strong class="lb iu"/>还在。如果您做一些繁重的多线程工作，请继续阅读其他实现。</li></ul><p id="c883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与任何工具一样，在采用它之前，您应该考虑所有的细节。但是下次你登录Codeforces进行挑战的时候，试试PyPy吧。你的<code class="fe oe of og oh b">O(n^3)</code>怪物有可能通过，而只有纯Python的<code class="fe oe of og oh b">O(n log n)</code>才能通过。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b773" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">源代码</h1><p id="cb43" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">虽然CPython和PyPy的源代码超出了这篇更一般的文章的范围，但我在<a class="ae ky" href="https://github.com/python/cpython/blob/master/Modules/mathmodule.c" rel="noopener ugc nofollow" target="_blank"> CPython (C代码)</a>和<a class="ae ky" href="https://github.com/mozillazg/pypy/blob/50d6bf76ef1f93c234ab42d4dd4a3b974f9665d6/pypy/module/math/app_math.py" rel="noopener ugc nofollow" target="_blank"> PyPy (Python代码)</a>中找到了这些实现阶乘函数的文件。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="0bb0" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">其他实现</h1><p id="bccb" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">除了CPython和PyPy，还有其他著名的Python实现:</p><ul class=""><li id="ab92" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><a class="ae ky" href="https://github.com/stackless-dev/stackless/wiki" rel="noopener ugc nofollow" target="_blank">无栈Python </a>。这是同样的蟒蛇，但没有GIL。它最显著的用途是作为在线游戏的后端。</li><li id="0961" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">IronPython 是Python的. NET实现，为你的Python和C#代码提供了非常简单的互操作。</li><li id="709b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://www.jython.org/" rel="noopener ugc nofollow" target="_blank"> JPython </a>是一样的东西，但是用Java。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c4d0" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结束语</h1><p id="5f89" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">谢谢你的阅读，我希望你喜欢我的文章。请在评论中告诉我你和PyPy的经历吧！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d94b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">资源</h1><ul class=""><li id="c553" class="np nq it lb b lc nk lf nl li oi lm oj lq ok lu nu nv nw nx bi translated"><a class="ae ky" href="https://doc.pypy.org/en/latest/faq.html" rel="noopener ugc nofollow" target="_blank"> PyPy常见问题解答</a></li><li id="34f2" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation" rel="noopener ugc nofollow" target="_blank">追踪即时编译</a></li><li id="e9bc" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank">CPython中的全局解释器锁</a></li><li id="4d55" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://medium.com/better-programming/take-a-look-at-the-awesome-new-features-coming-in-python-3-9-8753c494de39" rel="noopener">Python 3.9的新特性</a></li></ul></div></div>    
</body>
</html>