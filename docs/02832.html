<html>
<head>
<title>Diving Deep Into SwiftUI (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入SwiftUI(第3部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/diving-deep-into-swiftui-part-3-853173868f07?source=collection_archive---------15-----------------------#2020-01-03">https://betterprogramming.pub/diving-deep-into-swiftui-part-3-853173868f07?source=collection_archive---------15-----------------------#2020-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="08aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在SwiftUI中使用锚点首选项</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0315b397c7ffc7f16c52212c02c8bc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9avPACM9dEExUh18H8f42g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@crew?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">剧组</a>在<a class="ae kv" href="https://unsplash.com/s/photos/computer-settings?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="d6a7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="43df" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是五部分系列的第三部分。如果您从第2部分以外的地方来到这里，您可以从<a class="ae kv" href="https://github.com/tugayac/swiftui-custom-tab-bar-tutorial/commit/8fe86edaabbe91b8dcbda040b4fdcb1261f2a089" rel="noopener ugc nofollow" target="_blank">这个</a>提交开始。</p><p id="9abe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，使用视图首选项代替锚点首选项是完全可以的。在传递与视图相关的几何体数据时，锚点首选项会隐式执行一些操作，这就是为什么当您不想详细传递几何体数据时，它们可能是首选项。</p><ul class=""><li id="1ec4" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">在<a class="ae kv" href="https://medium.com/@ardactugay/diving-deep-into-swiftui-a-simple-custom-tab-bar-part-1-of-5-680d05d7f99b" rel="noopener">第1部分</a>中，我们设置了自定义选项卡栏项目，没有使用视图首选项，只简单使用了一次<code class="fe my mz na nb b">GeometryReader</code>。我们将模仿默认iOS标签栏的功能。</li><li id="213f" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated">在第2部分的<a class="ae kv" href="https://medium.com/better-programming/diving-deep-into-swiftui-using-view-preferences-part-2-of-5-ebd8a91d6c3e" rel="noopener">中，我们深入探讨了如何使用视图首选项，并使我们的视图层次结构更像SwiftUI。</a></li><li id="bfca" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated"><strong class="lq ir">在第3部分中，我们将研究用锚点首选项替换一些视图首选项。</strong></li></ul><p id="21af" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nh">快速提示:最初，我打算将这个系列分成5部分，但是自从写了这些文章，我就转向了Flutter。然而，这些文章的所有3个部分中的信息仍然是相关的，所以如果您想了解更多关于SwiftUI的信息，请继续阅读！</em></p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="c2b5" class="kw kx iq bd ky kz np lb lc ld nq lf lg jw nr jx li jz ns ka lk kc nt kd lm ln bi translated"><strong class="ak">什么是主播偏好？</strong></h1><p id="94bc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在用锚点首选项替换视图首选项之前，我们先来讨论一下它们是什么。</p><p id="9d97" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nh">锚点首选项</em>是视图首选项的子集，也就是说，您可以在视图首选项中使用它们，而不是用这个新概念完全替换视图首选项。这意味着大部分代码将保持不变；您的<code class="fe my mz na nb b">PreferenceKey</code>和偏好数据只会略有变化。</p><p id="5439" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们来看文档。SwiftUI <code class="fe my mz na nb b"><a class="ae kv" href="https://developer.apple.com/documentation/swiftui/view" rel="noopener ugc nofollow" target="_blank">View</a></code>下有两种方法处理锚偏好:</p><pre class="kg kh ki kj gt nu nb nv nw aw nx bi"><span id="ffb2" class="ny kx iq nb b gy nz oa l ob oc">func anchorPreference&lt;A, K&gt;(key: K.Type, value: Anchor&lt;A&gt;.Source, transform: (Anchor&lt;A&gt;) -&gt; K.Value) -&gt; View</span><span id="2029" class="ny kx iq nb b gy od oa l ob oc">func transformAnchorPreference&lt;A, K&gt;(key: K.Type, value: Anchor&lt;A&gt;.Source, transform: (inout K.Value, Anchor&lt;A&gt;) -&gt; Void) -&gt; View</span></pre><p id="0081" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，这两种方法通常与视图首选项的方法完全相同:</p><pre class="kg kh ki kj gt nu nb nv nw aw nx bi"><span id="8ae1" class="ny kx iq nb b gy nz oa l ob oc">func preference&lt;K&gt;(key: K.Type, value: K.Value) -&gt; View</span><span id="0c2e" class="ny kx iq nb b gy od oa l ob oc">func transformPreference&lt;K&gt;(K.Type, (inout K.Value) -&gt; Void) -&gt; View</span></pre><p id="bca5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">唯一不同的是<code class="fe my mz na nb b">value: K.Value</code>现在是第一个类似方法的<code class="fe my mz na nb b">value: Anchor&lt;A&gt;.Source</code>，并且<code class="fe my mz na nb b">transform:</code>现在除了接收<code class="fe my mz na nb b">K.Value</code>之外还接收<code class="fe my mz na nb b">Anchor&lt;A&gt;</code>(这里的K值是<code class="fe my mz na nb b">TabBarPreferenceData</code>)。</p><h2 id="2455" class="ny kx iq bd ky oe of dn lc og oh dp lg lx oi oj li mb ok ol lk mf om on lm oo bi translated">什么是主播<a>？</a></h2><p id="64ca" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/swiftui/anchor" rel="noopener ugc nofollow" target="_blank">我们来看看文档</a>:</p><blockquote class="op oq or"><p id="549c" class="lo lp nh lq b lr mk jr lt lu ml ju lw os mm lz ma ot mn md me ou mo mh mi mj ij bi translated">从定位点源和特定视图派生的不透明值。</p><p id="1a39" class="lo lp nh lq b lr mk jr lt lu ml ju lw os mm lz ma ot mn md me ou mo mh mi mj ij bi translated"><code class="fe my mz na nb b">struct Anchor&lt;Value&gt;</code></p><p id="eaa2" class="lo lp nh lq b lr mk jr lt lu ml ju lw os mm lz ma ot mn md me ou mo mh mi mj ij bi translated">通过使用<code class="fe my mz na nb b">LayoutContext</code>指定目标视图，可以将锚点转换为目标视图坐标空间中的<code class="fe my mz na nb b">Value</code>。</p></blockquote><p id="97a4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这里帮不上什么忙，但我们确实得到了一些我们应该四处搜索的信息:</p><ul class=""><li id="4504" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">有一种价值来源于“锚源”和“特定视图”这意味着锚点以某种方式与视图相关。</li><li id="2651" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated">我们可以通过使用一个叫做<code class="fe my mz na nb b">LayoutContext</code>的东西来指定这个目标视图，将锚点转换为目标视图的“坐标空间”中的一个值。这意味着锚偏好以某种方式与视图的坐标空间一起工作。这个<code class="fe my mz na nb b">Anchor&lt;A&gt;</code>允许我们将一些锚点转换成我们可以在指定视图的坐标空间中使用的值。</li></ul><p id="ee1b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">谢天谢地，在文档的底部，我们可以转到另一个相关的主题，<code class="fe my mz na nb b"><a class="ae kv" href="https://developer.apple.com/documentation/swiftui/anchor/source" rel="noopener ugc nofollow" target="_blank">Anchor.Source</a></code>。去那里给了我们更多的信息:</p><blockquote class="op oq or"><p id="b1db" class="lo lp nh lq b lr mk jr lt lu ml ju lw os mm lz ma ot mn md me ou mo mh mi mj ij bi translated">产生给定类型的锚定值的类型擦除几何值。</p><p id="fd5d" class="lo lp nh lq b lr mk jr lt lu ml ju lw os mm lz ma ot mn md me ou mo mh mi mj ij bi translated"><code class="fe my mz na nb b">struct Anchor&lt;Value&gt;.Source</code></p><p id="01b1" class="lo lp nh lq b lr mk jr lt lu ml ju lw os mm lz ma ot mn md me ou mo mh mi mj ij bi translated">SwiftUI通过首选项键在视图树中传递锚定的几何图形值。然后通过<code class="fe my mz na nb b">LayoutContext</code>将它们转换回本地坐标系，例如在布局的<code class="fe my mz na nb b">situate(_:updating:in:)</code>功能中。</p></blockquote><p id="b20a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在开始变得更有意义了。概述为我们提供了重要信息:</p><blockquote class="op oq or"><p id="9021" class="lo lp nh lq b lr mk jr lt lu ml ju lw os mm lz ma ot mn md me ou mo mh mi mj ij bi translated">SwiftUI通过首选项键在视图树中传递锚定的几何图形值。然后将它们转换回本地坐标系。</p></blockquote><p id="8696" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">还有更多；如果你看文档的底部，你会看到更多的类型属性，比如<code class="fe my mz na nb b">bottom</code>和<code class="fe my mz na nb b">bounds</code>。</p><p id="fd66" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以推导出锚偏好，允许我们检索关于视图的边界和锚信息(底部、尾部等)，相对于视图的坐标空间，而不必在我们的视图层次上指定一个<code class="fe my mz na nb b">coordinateSpace(name:)</code>。</p><p id="52a2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从这个信息中我们还知道<code class="fe my mz na nb b">Anchor&lt;Value&gt;</code>中的<code class="fe my mz na nb b">Value</code>不是<code class="fe my mz na nb b">CGPoint</code>就是<code class="fe my mz na nb b">CGRect</code>。</p><p id="0a61" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe my mz na nb b">Source</code>是用于导出您正在寻找的几何信息的源视图。</p><p id="08c9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">尽管如此，我们仍然不知道<code class="fe my mz na nb b">LayoutContext</code>是什么或者<code class="fe my mz na nb b">situate(_:updaing:in:)</code>是做什么的(没有关于这些的官方文档)。这些都是SwiftUI内部的，我们无法访问源代码。不过没关系；它们只是实现细节，我们不需要了解它们就可以使用anchor参数。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="2cb8" class="kw kx iq bd ky kz np lb lc ld nq lf lg jw nr jx li jz ns ka lk kc nt kd lm ln bi translated">使用锚点首选项</h1><p id="b320" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你只需要做最小的改变就可以让锚点首选项工作。您将在<code class="fe my mz na nb b">ContentView.swift</code>中进行所有更改。</p><p id="44d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，用以下内容替换<code class="fe my mz na nb b">TabBarPreferenceData</code>中的<code class="fe my mz na nb b">tabBarBounds</code>类型:</p><pre class="kg kh ki kj gt nu nb nv nw aw nx bi"><span id="ddd3" class="ny kx iq nb b gy nz oa l ob oc">var tabBarBounds: Anchor&lt;CGRect&gt;? = nil</span></pre><p id="45e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是我怎么知道为类型参数指定什么呢？因为我们在寻找标签栏的边界，所以它必须是一个<code class="fe my mz na nb b">CGRect</code>。但你不用猜。如果您查看<code class="fe my mz na nb b">Anchor&lt;A&gt;.Source</code>文档，正如我们在上面看到的，您会看到下面的类型属性:</p><pre class="kg kh ki kj gt nu nb nv nw aw nx bi"><span id="ca65" class="ny kx iq nb b gy nz oa l ob oc">static var bounds: Anchor&lt;CGRect&gt;.Source</span></pre><p id="1ae0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">SwiftUI为<code class="fe my mz na nb b">bounds</code>锚提供了一个<code class="fe my mz na nb b">CGRect</code>。</p><p id="9544" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，您需要用<code class="fe my mz na nb b">transformAnchorPreference(key:value:transform:)</code>替换<code class="fe my mz na nb b">overlay(_:alignment:)</code>方法。该文件中只有一个<code class="fe my mz na nb b">overlay</code>方法，因此您可以搜索它并进行以下更改:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将首选项更改为锚点首选项</p></figure><p id="5e98" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe my mz na nb b">value</code>参数的用法已经改变，现在有一个<code class="fe my mz na nb b">transform</code>参数:</p><ul class=""><li id="abf8" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><code class="fe my mz na nb b">value</code>:此参数允许您选择您想要访问当前视图的锚值。这里的值是 <code class="fe my mz na nb b"><a class="ae kv" href="https://developer.apple.com/documentation/swiftui/anchor/source" rel="noopener ugc nofollow" target="_blank">Anchor&lt;A&gt;.Source</a></code> <a class="ae kv" href="https://developer.apple.com/documentation/swiftui/anchor/source" rel="noopener ugc nofollow" target="_blank">文档</a>中列出的<a class="ae kv" href="https://developer.apple.com/documentation/swiftui/anchor/source" rel="noopener ugc nofollow" target="_blank">类型属性之一。在这种情况下，您使用<code class="fe my mz na nb b">.bounds</code>,因为您需要标签栏视图的边界。</a></li><li id="6b9d" class="mp mq iq lq b lr nc lu nd lx ne mb nf mf ng mj mu mv mw mx bi translated"><code class="fe my mz na nb b">transform</code>:该参数给出了您选择使用的<code class="fe my mz na nb b">value</code>和现有的<code class="fe my mz na nb b">TabBarPreferenceData</code>对象，它希望您根据需要转换首选项。</li></ul><p id="e3c1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是为什么需要用<code class="fe my mz na nb b">transformAnchorPreference</code>方法而不是<code class="fe my mz na nb b">anchorPreference</code>方法呢？因为在到达这个方法之前，子视图(T8)已经初始化了T9。如果您使用<code class="fe my mz na nb b">anchorPreference</code>，那么您将用<code class="fe my mz na nb b">nil</code>替换所有由孩子设置的数据，并且当使用该首选项时，将没有任何内容要显示。因此需要使用<code class="fe my mz na nb b">transformAnchorPreference</code>。</p><p id="ce42" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，如果您仍然使用<code class="fe my mz na nb b">overlay</code>方法，您可以使用<code class="fe my mz na nb b">anchorPreference</code>，因为覆盖图会在子视图之前被初始化。</p><p id="d5c3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，您不再需要<code class="fe my mz na nb b">GeometryReader</code>的<code class="fe my mz na nb b">GeometryProxy</code>值，这就是您完全替换<code class="fe my mz na nb b">overlay</code>方法的原因。锚点首选项隐式读取您调用它们的视图的几何图形，因此不再需要<code class="fe my mz na nb b">GeometryReader</code>。</p><p id="8d83" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，您不再需要在主视图的末尾定义一个<code class="fe my mz na nb b">coordinateSpace(name:)</code>，因此您也可以删除它。坐标空间是通过锚点首选项隐式管理的。</p><p id="a3d3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，你必须改变<code class="fe my mz na nb b">createTabBarContentOverlay(_:_:)</code>方法的第一部分来考虑锚的偏好:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">替换方法的第一部分以使用锚点首选项</p></figure><p id="1280" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您只需要更改<code class="fe my mz na nb b">tabBarBounds</code>变量来使用锚点首选项。这里需要使用<code class="fe my mz na nb b">geometry</code>,因为没有几何参考系，<code class="fe my mz na nb b">Anchor</code>值没有任何意义。</p><p id="2fa6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你在这里看到的符号，<code class="fe my mz na nb b">geometry[preferences.tabBarBounds!]</code>，是迅捷的<code class="fe my mz na nb b"><a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/Subscripts.html" rel="noopener ugc nofollow" target="_blank">subscript</a></code>符号。<a class="ae kv" href="https://developer.apple.com/documentation/swiftui/geometryproxy" rel="noopener ugc nofollow" target="_blank">你可以在</a> <code class="fe my mz na nb b"><a class="ae kv" href="https://developer.apple.com/documentation/swiftui/geometryproxy" rel="noopener ugc nofollow" target="_blank">GeometryProxy</a></code> <a class="ae kv" href="https://developer.apple.com/documentation/swiftui/geometryproxy" rel="noopener ugc nofollow" target="_blank">文档中看到它的列表；</a>它返回<code class="fe my mz na nb b">CGRect</code>，因为方法签名是<code class="fe my mz na nb b">subscript&lt;T&gt;(Anchor&lt;T&gt;) -&gt; T</code>。</p><h2 id="5cc9" class="ny kx iq bd ky oe of dn lc og oh dp lg lx oi oj li mb ok ol lk mf om on lm oo bi translated">坐标空间与几何代理下标</h2><p id="a94e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您可能想知道是否可以使用任何几何图形来获取选项卡栏的bounds锚点值。您可以使用任何祖先视图的几何图形来获得相对于该视图几何图形的锚点值。然而，值得注意的是，我还没有在兄弟几何体上尝试过，所以在使用锚点首选项时要考虑到这一点。</p><p id="a00b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在当前的几何和锚点使用方式下，选项卡栏边界看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/887af4295b87831c66b5741ac62092e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*ovnmzCPlyBKUrdG3ZVA-sw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标签栏边界</p></figure><p id="a8b2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">绿色和红色坐标轴表示<code class="fe my mz na nb b">ContentView</code>中根视图的正<em class="nh"> x </em>和<em class="nh"> y </em>轴，即<code class="fe my mz na nb b">VStack</code>。</p><p id="87f7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为您正在调用<code class="fe my mz na nb b">geometry[preferences.tabBarBounds!]</code>，所以您将获得相对于<code class="fe my mz na nb b">VStack</code>视图的几何图形的标签栏边界。在这种情况下，标签栏的左上角坐标是(0，761.5)，其宽度和高度是(414，56.5)。如果你要提供一个不同的几何图形，那么它的边界会改变，它会显示在该几何图形的参照系中。</p><p id="8825" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可以这样想:如果你在你用来定义坐标空间的层次上得到一个几何图形的锚值，那么你将得到和我们在第2部分中用<code class="fe my mz na nb b">geometry.frame(in:)</code>调用所做的一样的答案。因此，我们在这里对锚点首选项所做的与我们在第2部分中对坐标空间和首选项所做的一样。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="4865" class="kw kx iq bd ky kz np lb lc ld nq lf lg jw nr jx li jz ns ka lk kc nt kd lm ln bi translated">相同的功能，更少的代码</h1><p id="16b5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">就是这样！现在运行应用程序，您应该会看到什么都没有改变。然而，我们现在让SwiftUI在内部处理一些几何相关的功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/68af383976f21826de820bb2a46c66a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/1*RgoF0rd7Ecr3MuT_DrglZw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">视觉上不是很令人兴奋，但是同样的功能用更少的代码总是更好</p></figure><p id="cf6a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里是提交,包含到这里为止的所有内容。</p><p id="62cb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>