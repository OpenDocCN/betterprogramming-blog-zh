<html>
<head>
<title>A Multi-Platform Library With Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin的多平台库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-multi-platform-library-with-kotlin-episode-1-6c0f46d49944?source=collection_archive---------0-----------------------#2019-08-03">https://betterprogramming.pub/a-multi-platform-library-with-kotlin-episode-1-6c0f46d49944?source=collection_archive---------0-----------------------#2019-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9854" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第一部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5323f32390cf50d1f58a72fd1e0f0456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Rxk4sH4HW9dn2B1oCMXxw.png"/></div></div></figure><p id="9fcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对我来说，移动应用程序开发的优势之一就是尽可能地偏好原生开发。也就是说，如果有一个足够大的团队，两个应用程序可以同时存在于Android和iOS(可能更多)上，做同样的事情，支持同样的操作。</p><p id="e89b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优势有很多，我们甚至不需要开始列举它们。</p><p id="d9ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">缺点只有一个:无论团队投入多少时间来解决这个问题，这两个应用程序的行为总是会有点不同。它可以很小，就像不同的标签或略有不同的错误处理策略，但它也可以很大:发送到后端的不同结构的输入检查过于松散或错误实现的逻辑。您可以使用UML图、PowerPoint演示文稿或几乎任何工具来解决这个问题，但最终，会有两个人在同一概念上工作。他们最终总是会写出不同的东西。</p><p id="8614" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以接受这一点，并依靠你的QA来找出这些差异，或者你可以强迫开发人员互相交流，让他们在两个平台上进行一些结对编程。或者，您可以跟随我在Kotlin中编写跨平台库的旅程，以支持iOS和Android的中型应用程序的开发。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="14d6" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">目标</h1><p id="1e9d" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我的示例应用程序分为两部分:一部分是逻辑/后端，称为<em class="mr">核心</em>(谈谈想象力，嗯？)和一个UI/前端侧。我的目标是将尽可能多的<em class="mr">内核</em>移植到一个可以在Android和iOS上使用的共享模块中。我们将把那个模块叫做… &lt;鼓声&gt; <em class="mr">多核</em>。</p><p id="e068" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这第一集，我还不会把多核放到实际的应用中。我们将看到它在两个空白应用程序中运行，以隔离更大代码库可能出现的任何问题。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="5a92" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">创建库</h1><p id="aea4" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在Kotlin中开始开发跨平台库的第一件事是创建一个新的多平台项目。要做到这一点，我们得下载Android Studio的老大哥:IntelliJ IDEA。不用担心；即使听起来很贵，也有适合我们需求的免费版本。你可以在这里找到<a class="ae ms" href="https://www.jetbrains.com/idea/download/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/55edbcf92bcc565d8b1808888fa595bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8R37_isGDktH5IAcYXYWsg.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">“移动共享图书馆”，又名。“欢迎来到多平台世界。”</p></figure><p id="d3e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">IntelliJ在配置我们的项目方面做得非常好。我们必须输入一个名字并选择一个地点，剩下的事情就交给我们了。</p><p id="82a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认配置创建三个模块，并为每个模块创建一个测试模块，总共六个模块:</p><ul class=""><li id="60e9" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">这是真正的魔法发生的地方。这个模块包含了所有用纯Kotlin编写的共享逻辑。这里的任何类都可以在任何平台上共享。</li><li id="36fb" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated"><code class="fe nh ni nj nk b">iosMain</code>:链接Cocoa框架的模块，允许我们编写只能在iOS上运行的Kotlin代码。</li><li id="9073" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated"><code class="fe nh ni nj nk b">jvmMain</code>:编译成Kotlin/JVM，链接Android框架的模块。这只适用于Android系统。</li></ul><p id="f94f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用它们来编写我们的库。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="5fcc" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">配置</h1><p id="6de6" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">很容易相信项目配置已经足够好了。不幸的是，IntelliJ没有更新到最新最棒的Kotlin跨平台开发。这主要是因为Kotlin进展如此之快，以至于完全脱离了IntelliJ发布周期。</p><p id="9c79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无论如何，更新项目是很容易的。</p><p id="7846" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先我们要把Gradle更新到最新版本；IntelliJ选择了4.10版本，这是第一个支持跨平台项目的版本，但有些东西(我们将在下一集看到)不太好用。</p><p id="067e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要更新Gradle，打开<code class="fe nh ni nj nk b">gradle/wrapper/gradle-wrapper.properties</code>并在<code class="fe nh ni nj nk b">distributionUrl</code>属性中更改版本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8e72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在撰写本文时，最新版本是5.5.1，但是您可以在这里查看新版本<a class="ae ms" href="https://gradle.org/releases/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="965d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更改该文件后，IntelliJ将要求您重新加载项目并下载新版本。这可能需要一段时间，具体取决于您的连接。</p><p id="a616" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">转到<code class="fe nh ni nj nk b">build.gradle</code>文件，如果你习惯于Android开发，你会发现这与正常情况有点不同。我们在顶部有<code class="fe nh ni nj nk b">plugins</code>声明，它导入了<code class="fe nh ni nj nk b">kotlin-multiplatform</code>，我们有通常的<code class="fe nh ni nj nk b">repositories</code>部分，然后我们有一个新的<code class="fe nh ni nj nk b">kotlin</code>块。</p><p id="7935" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个块定义了两件事:</p><ul class=""><li id="806f" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">我们库的目标，基本上是我们想要支持的目标平台。这些默认设置为<code class="fe nh ni nj nk b">jvm()</code>(又名。Android)和<code class="fe nh ni nj nk b">iOSX64("ios")</code>(又名。iPhone模拟器)。</li><li id="f6f2" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">我们库的源集，它定义了我们的模块和它们的依赖关系。默认情况下，<code class="fe nh ni nj nk b">common</code>和<code class="fe nh ni nj nk b">android</code>导入Kotlin标准库，而<code class="fe nh ni nj nk b">ios</code>不导入任何东西。</li></ul><p id="1600" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种配置是错误的，原因有很多:</p><ul class=""><li id="3e62" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">首先，我们只支持iPhone模拟器，这对于简单的测试有意义，但不适合真实的应用程序。</li><li id="a8ef" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">其次，我们没有利用Kotlin提供的预设配置。</li></ul><p id="a539" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按如下方式更改<code class="fe nh ni nj nk b">build.gradle</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="29a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不同之处在于<code class="fe nh ni nj nk b">kotlin</code>模块:我们现在从预设开始配置目标；此外，我们根据Xcode在编译期间设置的<code class="fe nh ni nj nk b">SDK_NAME</code>环境变量来选择iOS架构。这样，我们将能够构建一个在我们将要运行的架构上工作的框架，而无需每次都更改构建脚本。</p><p id="3bfd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">IntelliJ会警告Gradle文件中的许多问题，但它会编译得很好。</p><p id="447c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然来了，不妨为Xcode准备好一切。让我们将这个Gradle任务集成到我们的<code class="fe nh ni nj nk b">build.gradle</code>文件的底部:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a2c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个任务，如这里的<a class="ae ms" href="https://kotlinlang.org/docs/tutorials/native/mpp-ios-android.html#tuning-the-gradle-build-script" rel="noopener ugc nofollow" target="_blank">所描述的</a>，构建本地库并将其打包到<code class="fe nh ni nj nk b">.framework</code>目录中。这还会生成一个<code class="fe nh ni nj nk b">gradlew</code>可执行文件，Xcode可以使用它来与iOS项目一起构建框架。不过，我们将使用另一个解决方案，因为使用生成的Gradle包装器要求我们在从Xcode构建所有东西之前至少手动运行一次这个任务。</p><p id="2797" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您将Gradle与更改同步时，您可能会注意到IntelliJ发出的绿色消息，警告您一些模块将从项目中删除；这是正确的，因为我们已经将默认的“JVM”目标重命名为更容易理解的“android”要做到这一点，我们还必须更新文件系统中实际文件夹的名称:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/7a421131ed4a65170c51fd7165d8d3a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKcLmbEkJXppnESTURttsg.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">你在“src”文件夹里看到“jvm”的地方，只要把它改成“android”就行了。</p></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="fa5c" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">写一些代码</h1><p id="52f2" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">就是这个！我们准备开始在我们的模块中编写一些代码。但是要测试它是否工作，我们不需要:我们只需要使用IntelliJ为我们生成的<code class="fe nh ni nj nk b">Sample</code>类。</p><p id="7969" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该示例定义了一个打印<code class="fe nh ni nj nk b">Hello from &lt;platform name&gt;</code>的<code class="fe nh ni nj nk b">hello()</code>函数，该函数根据运行它的平台而变化。这使用了许多Kotlin多平台特定的命令，我们将在下一集看到，但请随意查看。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="f032" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">Android项目</h1><p id="7953" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们将把这个库集成到一个新的Android应用程序中，因此启动Android Studio并打开一个新项目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/fcb8d242dd164b566247707602f34298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RtB07uVeIQcPgGwQ8L37g.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">一个空洞的活动正是我们所需要的。</p></figure><p id="06f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了在iOS和Android团队之间轻松共享库，我为跨平台库创建了一个Git repo，并将其作为子模块导入到现有的Android repo中。你可以通过终端或者你最喜欢的Git客户端来完成。关于子模块的更多信息可在<a class="ae ms" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" rel="noopener ugc nofollow" target="_blank">这里</a>获得；如果你没有喜欢的Git客户端，你可以得到<a class="ae ms" href="https://fork.dev" rel="noopener ugc nofollow" target="_blank"> Fork </a>，这是一个非常好的免费客户端，也支持子模块。</p><p id="e8d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦您导入了您的子模块，您就可以像对待任何其他外部模块一样，将它包含在您的主项目中。</p><p id="06f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将此添加到您的<code class="fe nh ni nj nk b">settings.gradle</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="063a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该更改写在<code class="fe nh ni nj nk b">settingsDir</code>之后的路径，指向您克隆子模块的文件夹。</p><p id="f6bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你也可以包含这个库，而不需要创建两个单独的Git repos，但是你将被迫为两个应用程序创建一个单独的库，以使一切都在源代码控制之下。在我看来，这并不理想；根据处理同一个repo的人数，可能会在跨平台项目中更改相同的文件，您可能会遇到奇怪的合并冲突。</p><p id="06df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，如果一个团队比另一个团队快，拥有单一回购意味着一旦跨平台项目被更新以支持新功能，两个应用程序必须同时更新。否则，留下的那个可能无法建造。可以想象，这在CI/CD环境中并不理想。</p><p id="ff29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Android Studio会友好地要求您执行Gradle sync它会失败。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/eb5ae6f0f44aff7b715ee9ccf88fcfe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2aZKyGf2elo-CSC5E7N3A.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">“对已经在类路径上的插件的插件请求不能包含版本”:非常清楚，不是吗？</p></figure><p id="4632" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你点击错误日志中的“打开文件”，Android Studio会在第2行打开跨平台项目的<code class="fe nh ni nj nk b">build.gradle</code>，我们已经在这里导入了<code class="fe nh ni nj nk b">kotlin-multiplatform</code>插件。你可以看到，有一个版本号写在那里，Gradle不喜欢这个。</p><p id="f8fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们在IntelliJ中编辑我们的项目时，我们使用了一个单一的Gradle脚本:跨平台项目中的那个。但现在我们正试图将这个项目作为另一个项目的模块导入，所以我们正在将跨平台的Gradle脚本嵌入Android系统。这意味着我们将继承我们在Android项目中包含的所有<code class="fe nh ni nj nk b">classpaths</code>和<code class="fe nh ni nj nk b">plugins</code>，Kotlin也是其中之一，拥有自己的版本。</p><p id="11e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对我们来说幸运的是，有人已经设法解决了这个问题:在Gradle论坛上(<a class="ae ms" href="https://discuss.gradle.org/t/error-plugin-already-on-the-classpath-must-not-include-a-version/31814/3" rel="noopener ugc nofollow" target="_blank">这里是</a>)你可以找到一个非常有用的函数，它只在以前没有应用过<code class="fe nh ni nj nk b">kotlin-multiplatform</code>插件的情况下才应用这个插件。</p><p id="d5b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，删除<code class="fe nh ni nj nk b">build.gradle</code>文件第一部分中的<code class="fe nh ni nj nk b">plugins</code>块，使它看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f126" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其工作原理如下:</p><ul class=""><li id="6caa" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">在我们的Android项目中构建库时，Kotlin插件已经在那里了；您用于Android代码的Kotlin版本也将用于跨平台项目。</li><li id="b48a" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">当从Xcode构建库时，我们的脚本将自动应用我们在上面<code class="fe nh ni nj nk b">ext.kotlin_version</code>中指定的版本的Kotlin插件。</li></ul><p id="c2f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您再次同步您的项目，它现在应该可以完美地工作了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/f6d30d41238ae9c550e6ec7739cf05d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLargvose55nyQUqzTs3GA.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">格拉德现在很开心！</p></figure><p id="d527" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还有一个步骤:既然跨平台已经包含在我们的主项目中，我们必须告诉Gradle我们的应用程序需要它作为一个依赖项。这很简单，只需在安卓应用<code class="fe nh ni nj nk b">build.gradle</code>和其他<code class="fe nh ni nj nk b">dependencies</code>中添加这一行:</p><pre class="kg kh ki kj gt nw nk nx ny aw nz bi"><span id="4b83" class="oa lv iq nk b gy ob oc l od oe">implementation project(path: ':multicore')</span></pre></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="20df" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">释放力量</h1><p id="1fba" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">现在我们的Android项目中有了这个库，让我们开始MainActivity并调用IntelliJ在跨平台项目中为我们定义的<code class="fe nh ni nj nk b">hello</code>函数。</p><p id="d200" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以稍微修改一下<code class="fe nh ni nj nk b">activity_main.xml</code>布局，为“Hello World”标签添加一个ID，然后调用<code class="fe nh ni nj nk b">MainActivity.kt</code>中的<code class="fe nh ni nj nk b">onCreate</code>方法中的<code class="fe nh ni nj nk b">hello</code>函数，并将返回值设置为TextView的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/9cfd05b31921320729125b00f06a0b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcHeibKUfxUd8DWabb9_Mw.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">示例包中的hello()函数！</p></figure><p id="f2d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建并运行，这就是您得到的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/7599fdc70598308791e676d67c22766f.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*1dsm-UkqdZURQcZP4knV4g.png"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">你能感觉到力量，对吗？</p></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="e67e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">iOS项目</h1><p id="8b17" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">到目前为止，我们所做的只是在一个Kotlin项目中添加一个Kotlin库；听起来不复杂吧？</p><p id="d44f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在是时候更进一步，在iOS应用中使用我们的跨平台库了。让我们打开Xcode，创建一个新的iOS应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/dff4cb481aa0e95f859558a44cda1285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AgR9b9AucQ_FKuSXaf2TQ.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">单一视图应用程序正是我们所需要的。</p></figure><p id="c618" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将一个<code class="fe nh ni nj nk b">UILabel</code>添加到<code class="fe nh ni nj nk b">Main.storyboard</code>文件中的默认视图控制器，并在我们的视图控制器实现中将它连接到一个<code class="fe nh ni nj nk b">IBOutlet</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/cb8994dea64b3b81d91d167c3318f4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKYJMEk0LSN1EAC2ue1n0Q.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">您还应该设置AutoLayout，使文本字段在屏幕上居中。</p></figure><p id="f97a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们的UI已经准备好了，我们应该动手做点什么，在Xcode中放一些Gradle。首先要做的是将子模块克隆到我们的iOS repo中。然后我们必须设置Xcode来导入Kotlin库。</p><p id="4545" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还记得我们之前添加到<code class="fe nh ni nj nk b">build.gradle</code>中的<code class="fe nh ni nj nk b">packForXcode</code>任务吗？现在是使用它的时候了。我们必须运行该任务来生成一个可以导入到我们项目中的<code class="fe nh ni nj nk b">.framework</code>文件夹。但是要运行这个任务，我们需要一个Gradle实例…</p><p id="347b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Android上工作，我们习惯于在我们的根文件夹中总有一个配置好的Gradle，在<code class="fe nh ni nj nk b">gradlew</code>可执行文件下。显然，Xcode没有为我们生成包装器。在他们的<a class="ae ms" href="https://kotlinlang.org/docs/tutorials/native/mpp-ios-android.html#tuning-the-gradle-build-script" rel="noopener ugc nofollow" target="_blank">指南</a>中，JetBrains建议从Android Studio或IntelliJ运行一次任务，然后在Xcode中使用生成的<code class="fe nh ni nj nk b">gradlew</code>。我不喜欢这种解决方案，因为这意味着当第一次克隆repo时，每个人都必须在Android Studio中打开子模块并运行一次任务，才能成功地用Xcode构建。此外，它使持续集成解决方案的配置变得复杂。</p><p id="ec85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我宁愿安装一个Gradle实例并从Xcode使用它。用<a class="ae ms" href="https://brew.sh" rel="noopener ugc nofollow" target="_blank">家酿</a>很容易做到这一点:如果你还没有在Mac上安装，你应该检查一下。</p><p id="e525" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Gradle需要Java 1.8或更高版本。如果你没有安装，家酿将返回一个错误，并建议你通过木桶打开JDK；您也可以从Oracle网站下载普通安装程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/e82158690ee14e758041f512a977a983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTqLIK0lHFx6H6tZmae_OQ.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">爬起来跑！</p></figure><p id="7be3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要将Gradle的这个实例与您在Android上工作时通常使用的实例相混淆。IntelliJ和Android Studio捆绑了他们的Gradle版本，默认情况下，即使你安装了另一个版本，也要使用它。另外，当Gradle包装文件可用时，两个ide都会更喜欢这个版本。您可以(但不应该)在IDE设置中更改这种行为。</p><p id="31ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了Gradle，我们可以配置Xcode项目在构建时运行Gradle任务。</p><ul class=""><li id="767a" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">从Xcode导航器中选择iOS项目，然后点按“构建阶段”</li><li id="6dfb" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">单击视图右上角的“+”并选择“新运行脚本阶段”这将在列表底部创建一个“运行脚本”项目。</li><li id="303e" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">打开新阶段并输入以下脚本，确保将<code class="fe nh ni nj nk b">cd</code>之后的路径更改为子模块相对于<code class="fe nh ni nj nk b">${SRCROOT}</code>(iOS项目的根文件夹)的实际路径:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="1b5a" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">将“运行脚本”阶段重命名为更容易理解的名称(比如“Gradle”)，然后将它移到列表的顶部，就在“目标依赖项”之后</li><li id="82c4" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">构建项目！</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/259cd5e4c39acd73060db21901026584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQZ2Lpiz7lHsztexRQZ1Iw.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">Xcode正在运行Gradle！</p></figure><p id="553b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一次构建将花费更长的时间，因为Gradle必须打开一个环境，下载所有的依赖项，并构建Kotlin项目。后续的构建会更快，因为Gradle在内存中保持环境就绪。</p><p id="74e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你在<code class="fe nh ni nj nk b">build/bin/ios/MultiCoreDebugFramework/</code>查看跨平台项目，你会发现我们的<code class="fe nh ni nj nk b">.framework</code>文件(带有调试符号！)准备导入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/51677b5640755f2efffc75863a80927a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48ziSe-5uRFPYildlK7M8Q.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">这很容易，不是吗？</p></figure><p id="e35b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，就像我们在Android项目中告诉Gradle将跨平台库作为一个依赖项包括在内一样，我们需要告诉Xcode将该框架包括在我们的应用程序中:</p><ul class=""><li id="9e82" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">再次从Xcode导航器中选择iOS项目。</li><li id="b18e" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">切换到“常规”选项卡。</li><li id="39b1" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">向下滚动到“嵌入式二进制文件”并点击“+”按钮。</li><li id="ad8e" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">如果你已经将跨平台项目作为子模块包含，Xcode会自动找到<code class="fe nh ni nj nk b">.framework</code>文件，放入列表中；如果没有，可以点击“添加其他”，手动选择。在任何情况下，确保关闭“如果需要，拷贝项目”</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/7a68f5808ed8542897ce6966b2f3af3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HF-TFWk3ZjDxmB320NHjkA.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">这就是我们的框架！</p></figure><p id="cc7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您使用“添加其他”来选择框架，还有一个额外的步骤:Xcode不会在构建时自动知道在哪里寻找框架，所以即使您正确地添加了框架，您也会得到一个错误。</p><ul class=""><li id="40ac" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">打开Finder，导航到跨平台项目，然后导航到<code class="fe nh ni nj nk b">build/bin/ios</code>。</li><li id="548f" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">选择<code class="fe nh ni nj nk b">MultiCoreDebugFramework</code>文件夹并记下路径。</li><li id="09b3" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">返回Xcode，切换到“构建设置”标签，点击顶栏中的“全部”来移除“基本”过滤器。</li><li id="65dc" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">使用搜索栏过滤“框架搜索路径”</li><li id="f021" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">双击右边的空白区域，然后按弹出窗口中的“+”按钮。</li><li id="4c5b" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">输入从<code class="fe nh ni nj nk b">${SRCROOT}</code>到<code class="fe nh ni nj nk b">MultiCoreDebugFramework</code>文件夹的相对路径。</li><li id="f620" class="my mz iq kt b ku nl kx nm la nn le no li np lm nd ne nf ng bi translated">再次建造；如果输入正确的路径，构建将成功结束。</li></ul></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="e213" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">再次释放力量</h1><p id="1635" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">现在我们终于有了包含在项目中的框架，我们可以像在Android上一样使用它了。</p><p id="4489" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开<code class="fe nh ni nj nk b">ViewController.swift</code>，从导入<code class="fe nh ni nj nk b">MultiCore</code>框架开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/82f72e3f2600eeeb39da71e5c24bb565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ojwlaf4mv653ruJIH078yA.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">Xcode知道我们的框架！</p></figure><p id="9b8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，Kotlin编译器为我们生成了一个Swift可以看到的模块。但是，我们不能直接调用<code class="fe nh ni nj nk b">hello</code>函数。</p><p id="7975" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不在类中的Kotlin函数不会直接转换为Swift函数。为了访问<code class="fe nh ni nj nk b">hello</code>函数，Kotlin生成了一个<code class="fe nh ni nj nk b">SampleKt</code>类，它将该函数公开为一个静态方法。</p><p id="d9a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我们的<code class="fe nh ni nj nk b">ViewController.swift</code>文件变成了这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a28a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建并运行，您将得到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f6a0c15c84ee37871c04c0c32e543ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*wL_CH5IJMPDy-1JtFmkPOw.png"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">现在我确信你能感受到这种力量！</p></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="24b5" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="0298" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们已经成功创建了一个Kotlin跨平台库，并将其包含在一个新的iOS应用程序和一个新的Android应用程序中。我们现在可以做和探索的事情有一长串，但这一集已经够长了。</p><p id="8ca7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还在GitHub 上创建了一个<a class="ae ms" href="https://github.com/MrAsterisco/KotlinMultiPlatformPlayground" rel="noopener ugc nofollow" target="_blank">配套repo，它包含了对本文中的结构稍加修改的结构，但是在已经配置好的环境中测试Kotlin多平台技术是很有用的。</a></p><p id="e939" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ms" href="https://link.medium.com/jPdbH9iWlZ" rel="noopener">第二集</a>现已上映！</p></div></div>    
</body>
</html>