# JavaScript 中的发布者/订阅者模式

> 原文：<https://betterprogramming.pub/the-publisher-subscriber-pattern-in-javascript-2b31b7ea075a>

## 发布/订阅，简化

![](img/c14fbd465d81dd26928930b9327ad70f.png)

*照片由* [*诺德伍德主题*](https://unsplash.com/@nordwood) *上*[*Unsplash*](https://unsplash.com/)

在本文中，我们将讨论 JavaScript 中的发布/订阅模式，看看它在我们的 JavaScript 应用程序中实现起来有多简单(但功能强大)。

发布者/订阅者模式是一种设计模式，它允许我们创建功能强大的动态应用程序，这些应用程序的模块可以相互通信，而不直接相互依赖。

这种模式在 JavaScript 中很常见，并且在工作方式上与观察者模式非常相似——除了在观察者模式中，观察者通过其主题直接得到通知，而在发布者/订阅者方法中，订阅者通过发布者和订阅者之间的通道得到通知，该通道来回传递消息。

当我们实现这个时，我们将需要一个发布者、订阅者和一些存储从订阅者注册的回调的地方。

让我们来看看这在代码中是什么样子的。我们将使用一个[工厂](https://www.sitepoint.com/factory-functions-javascript/)函数(您不必使用这种模式)来创建发布者/订阅者实现。

我们要做的第一件事是在函数内部声明一个局部变量来存储订阅的回调:

```
function pubSub() {
  const subscribers = {}
}
```

接下来，我们将定义负责向`subscribers`插入回调的`subscribe`方法:

这里发生的事情是，在尝试为事件名注册回调监听器之前，它检查在`subscribers`存储中的`eventName`属性是否已经是一个`array`。如果不是，它假设这将是第一个注册的对`subscribers[eventName]`的回调，并将其初始化为一个数组。然后，它继续将回调推入数组。

当`publish`事件触发时，它将接受两个参数:

1.  `eventName`
2.  任何将被传递给在`subscribers[eventName]`中注册的每个回调的`data`

让我们来看看这在代码中是什么样子的:

在对`subscribers`中的回调列表进行迭代之前，它将检查它是否确实作为数组存在于对象中。如果没有，它会认为`eventName`以前从未注册过，所以它会简单地返回。这是防止潜在崩溃的安全措施。

之后，如果程序到达了`.forEach`行，那么我们知道`eventName`在过去注册了一个或多个回调。程序将安全地循环通过`subscribers[eventName]`。

对于它遇到的每个回调，它调用带有作为第二个参数传入的`data`的回调。

如果我们订阅了这样一个函数，就会发生这样的情况:

```
function showMeTheMoney(money) {
  console.log(money)
}const ps = pubSub()ps.subscribe('show-money', showMeTheMoney)
```

如果我们在将来的某个时候调用`publish`方法:

```
ps.publish('show-money', 1000000)
```

然后，除了接收作为`money`参数的`1000000`之外，我们注册的`showMeTheMoney`回调将被调用:

```
function showMeTheMoney(money) {
  console.log(money) *// result: 10000000*
}
```

这就是发布者/订阅者模式的工作方式。我们定义了一个`pubSub`函数，并为存储回调的函数提供了一个本地位置，一个`subscribe`方法用于注册回调，一个`publish`方法用于迭代和调用所有带有任何数据的已注册回调。

不过，还有一个问题。在实际的应用程序中，如果我们订阅了许多回调，我们可能会遭受永无止境的内存泄漏，如果我们对此不做任何事情，这将是非常浪费的。

因此，我们最后需要的是一种方法，当订阅的回调不再必要时，可以将其删除。在这种情况下经常发生的是某个`unsubscribe`方法被放置在某个地方。实现这一点最方便的地方是来自`subscribe` 的返回值，因为在我看来，当我们在代码中看到这一点时，这是最直观的:

在这个例子中，我们需要一个索引。因此，我们确保删除了正确的条目，因为我们使用了`.splice`，它需要一个准确的索引来删除我们正在寻找的条目。

你也可以这样做；然而，它的性能较差:

# 不足之处

尽管这种模式有巨大的好处，但也有毁灭性的缺点，可能会花费我们大量的调试时间。

我们如何知道我们之前是否订阅了相同的回调？除非我们实现一个映射列表的实用程序，否则真的没有办法知道，但是那样我们会让 JavaScript 做更多的任务。

在现实世界中，我们越是滥用这种模式，维护我们的代码就越困难。事实上，回调在这种模式中是分离的，当回调到处做这做那时，很难跟踪每一步。

# 结论

这篇文章到此结束。我希望你发现这是有价值的，并期待在未来更多！