<html>
<head>
<title>Serverless on AWS Lambda With Kotlin + Micronaut + Graal VM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda上无服务器，带Kotlin + Micronaut + Graal虚拟机</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/serverless-on-aws-lambda-with-micronaut-kotlin-7aac485f066e?source=collection_archive---------7-----------------------#2022-02-08">https://betterprogramming.pub/serverless-on-aws-lambda-with-micronaut-kotlin-7aac485f066e?source=collection_archive---------7-----------------------#2022-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb36" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">快速浏览Caribou——SaaS开发人员工具，有助于技术债务度量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4dc43db605f81a8023e0c0bc6e491c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CJhffrfVUxBVT561"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马克·赖歇尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4ee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将回顾<a class="ae kv" href="http://hellocaribou.com/" rel="noopener ugc nofollow" target="_blank"> Caribou </a>的技术堆栈决策，这是一个开发工具，帮助开发人员使用数据驱动的见解来管理他们的技术债务。我们将探讨无服务器架构的一些优点和缺点，以及在JVM语言中使用无服务器有多容易。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="3a1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大约一年前，我们开始讨论我们将用来构建<a class="ae kv" href="https://www.hellocaribou.com/" rel="noopener ugc nofollow" target="_blank"> Caribou </a>的主要组件和软件堆栈。</p><p id="2492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Caribou是一个SaaS开发者工具，可以作为GitHub应用程序安装在你的GitHub帐户上，并提供关于你如何从代码库中移除技术债务的见解。</p><p id="bc8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果你想将你的项目从Java迁移到Kotlin，并且你想跟踪这个迁移，那么你需要做的就是定义一个<a class="ae kv" href="https://www.hellocaribou.com/documentation/migrations/#migrating-from-java-to-kotlin" rel="noopener ugc nofollow" target="_blank">规则</a>来告诉Caribou你想跟踪哪个文件。</p><p id="5637" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Caribou然后在每个pull请求被合并后运行一个分析，为您提供关于迁移进展如何、预计完成日期是什么时候、谁在做贡献等等的实时数据！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/c5379cb6fe7491a1760b213d3902205f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AL9Pp-N_KTHpgVnI"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">驯鹿在行动！</p></figure><p id="80e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Caribou需要的主要技术组件有:</p><ul class=""><li id="4246" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">一个Web应用程序，使用户能够定义他们的迁移，并查看他们引入的代码更改的所有迁移指标。</li><li id="6320" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">一个带有REST API的后端，为web应用程序提供服务，还有一个数据库，用于存储关于用户定义的迁移及其进展情况的元数据。</li><li id="7690" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">一种用户认证和提供Caribou访问他们的GitHub存储库的机制，这样它可以监视传入的pull请求，并在需要时进行分析。</li></ul><p id="9520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当设计我们的解决方案和做出技术决策时，最重要的标准是开发速度；我们希望快速获得一个MVP，然后根据用户的反馈进行迭代。这意味着选择我们熟悉的技术和工具，优先使用现成的产品而不是我们自己构建的东西，选择学习曲线最小或者周围有良好文档和社区可以帮助我们快速上手的工具。</p><p id="530f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将关注后端的3个主要决策选择，即:</p><ul class=""><li id="e80e" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">用什么语言来构建它。</li><li id="87a2" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">我们将使用什么样的框架来完成繁重的工作。</li><li id="00ae" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">我们是否会利用“无服务器”这一新生事物，或者我们是否会采用现有的整体式或微服务方法。</li></ul><p id="6f78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最终得到的是一个用<a class="ae kv" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>编写的后端，在<a class="ae kv" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>上使用<a class="ae kv" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut框架</a>构建的无服务器架构。现在让我们更详细地看一下这3个选项:</p><h2 id="e0ce" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">为什么选择AWS Lambda</h2><p id="46a3" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我们为自己设定的第一个问题是，我们是将无服务器架构用于我们的后端，还是坚持在容器内部署一个或多个服务的更传统的解决方案。</p><p id="93a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到我们最初对速度的要求，无服务器引起了我们的兴趣，因为这意味着我们需要处理的事情会更少。对于第一次进入后端开发的人来说，无数的AWS容器服务(<a class="ae kv" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank"> ECS </a>、<a class="ae kv" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> EKS </a>、<a class="ae kv" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> Fargate </a>、<a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>等等)有一个相当陡峭的学习曲线。</p><p id="1988" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，就基础设施和可伸缩性而言，无服务器有一个非常简单的模型，允许您只担心正在执行的代码，而让平台服务提供商担心所有其他事情。</p><p id="aac4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试我们的假设，即对于我们来说，使用无服务器比使用容器更快更简单，我们构建了一个简单的虚拟后端，其中AWS Lambda连接到一个REST API(使用<a class="ae kv" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>),并设法了解哪一个是为我们构建最快的。AWS lambda轻松获胜。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6c55507b11d6fe1135c0edd0d967dfc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*TtUssnHWhvL7ypAo.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基础设施vs容器vs功能即服务，来自<a class="ae kv" href="https://tinyurl.com/caas-faas" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/caas-faas</a></p></figure><p id="c709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，值得注意的是:</p><ul class=""><li id="ad21" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">用一个无服务器的架构来构建也意味着我们最终会得到一个模块化的系统，其中每个lambda函数只做一件事，有一个非常清晰的接口，并且可以独立部署。</li><li id="efcb" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">许多平台提供商提供了慷慨的免费层(例如AWS每月免费提供1，000，000次函数调用)，这意味着我们暂时不需要为我们的lambda执行支付任何费用🙂。</li></ul><p id="b051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，也有一些缺点:</p><ul class=""><li id="0198" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">无服务器服务出现的时间没有容器服务长，我们打算将它与Kotlin一起使用，这意味着网上不会有太多关于这个主题的内容来指导我们。</li><li id="e031" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">如果我们将它与任何JVM语言(如Kotlin)一起使用，我们将需要为<a class="ae kv" href="https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/" rel="noopener ugc nofollow" target="_blank">冷启动问题</a>找到一个解决方案:执行基于JVM的语言需要更长的时间，因为在第一次lambda调用时，您需要等待运行时环境初始化，而随后的调用不会面临同样的问题。这听起来可能是个小问题，但是让REST API在10-15秒内返回确实会扼杀用户体验，即使这种情况并不经常发生。</li><li id="4a10" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">另一个我们认为无服务器可能会遇到的问题是，我们的一个函数需要执行一个<code class="fe nn no np nq b">git clone</code>操作(为了执行<a class="ae kv" href="https://www.hellocaribou.com/documentation/#how-the-tool-works" rel="noopener ugc nofollow" target="_blank"> Caribou提供的</a>技术债务分析)，这可能会在无服务器架构中超时，因为所有的提供者对他们的函数调用都有特定的<a class="ae kv" href="https://acloudguru.com/blog/engineering/serverless-showdown-aws-lambda-vs-azure-functions-vs-google-cloud-functions#5b" rel="noopener ugc nofollow" target="_blank">超时限制</a>(例如AWS Lambda目前有一个<a class="ae kv" href="https://docs.aws.amazon.com/whitepapers/latest/serverless-architectures-lambda/timeout.html" rel="noopener ugc nofollow" target="_blank"> 900秒</a>超时)。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="8def" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调查了上面提到的这些潜在问题后，我们决定继续使用无服务器，具体如下:</p><ul class=""><li id="a66e" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">我们发现<a class="ae kv" href="https://www.graalvm.org/reference-manual/native-image/" rel="noopener ugc nofollow" target="_blank"> GraalVM本地映像</a>有助于减少冷启动时间，我们将在本文后面看到这一点。</li><li id="2168" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">在测试了甚至更大的git仓库的<code class="fe nn no np nq b">git clone</code>操作后，我们认为它们不太可能花费超过15分钟的时间，所以我们将其视为一种边缘情况。如果我们曾经遇到过这个问题，那么<a class="ae kv" href="https://git-scm.com/docs/git-sparse-checkout" rel="noopener ugc nofollow" target="_blank">稀疏校验</a>可能是它的答案。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2b6898ba3571ca325f459e120e46390a.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*11mhGjOU5LDoUEcb_YSFSw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们尝试用Caribou克隆了一些相当大的git库。基于此，我们对AWS lambda上900秒的超时限制相当满意。</p></figure><p id="dc13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们特别决定使用<a class="ae kv" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>而不是<a class="ae kv" href="https://azure.microsoft.com/en-gb/solutions/serverless/" rel="noopener ugc nofollow" target="_blank"> Azure </a>或<a class="ae kv" href="https://cloud.google.com/serverless" rel="noopener ugc nofollow" target="_blank"> GCP </a>，主要是因为对过去的AWS有些熟悉，但也是因为一个亲密的朋友在AWS平台方面有丰富的经验，这意味着如果有什么可怕的错误，我们可能会获得一些帮助！</p><p id="20fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，如果你想深入了解无服务器架构，一定要看看这篇文章。</p><h2 id="1f93" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">为什么是科特林</h2><p id="cd75" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">Kotlin 是一种现代语言，为来自<a class="ae kv" href="https://www.jetbrains.com/" rel="noopener ugc nofollow" target="_blank"> JetBrains </a>的JVM而构建。它大约在10年前问世，但在2018年随着其在Android开发中的<a class="ae kv" href="https://developer.android.com/kotlin" rel="noopener ugc nofollow" target="_blank">引入而真正变得更加流行。</a></p><p id="a453" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我自己也有Android开发背景，看到这种语言使用起来有多棒，它如何帮助我们编写更简洁、错误更少的代码，以及围绕它的工具/IDE有多完善(JetBrains在这方面做得非常好🙂)，我自然也倾向于用它来饲养驯鹿。使用Kotlin还意味着我们能够使用Gradle作为我们的构建系统，并利用多年来使用Gradle进行移动开发的经验。</p><p id="ca2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过一段时间的调查，如果我们要走无服务器路线，主要的挑战似乎是上面讨论的JVM启动时间。用Kotlin进行的快速测试(最初的测试是用<a class="ae kv" href="https://spring.io/projects/spring-cloud-function" rel="noopener ugc nofollow" target="_blank"> Spring Cloud Function </a>进行的)显示，一个AWS Lambda函数执行起来确实需要大约15秒。谢天谢地，发生了三件事:</p><ul class=""><li id="ee90" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">我们发现了一些其他更轻量级的框架，如<a class="ae kv" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a>和<a class="ae kv" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>，它们专注于更快的启动时间和更小的内存占用。稍后会有更多的介绍。</li><li id="3c24" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">我们发现了<a class="ae kv" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank"> GraalVM本地图像</a>的奇迹。</li><li id="e228" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">有一些迹象表明，AWS本身已经承认了这个问题，并提出了一个解决方案，<a class="ae kv" href="https://aws.amazon.com/blogs/aws/new-provisioned-concurrency-for-lambda-functions/" rel="noopener ugc nofollow" target="_blank">提供并发</a>，这基本上保持了一些lambda函数随时准备启动，完全消除了冷启动问题。</li></ul><p id="648a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些发现让我们最终决定去找科特林，从此我们再也没有回头。我们最终没有使用提供的并发性，因为保持lambda函数始终准备好启动本质上模拟了一个始终运行的后端，这有点违背了无服务器的目的(更不用说它实际上更加昂贵)。</p><h2 id="563d" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">为什么选择Micronaut</h2><p id="a020" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">如上所述，第一次尝试是使用<a class="ae kv" href="https://spring.io/projects/spring-cloud-function" rel="noopener ugc nofollow" target="_blank">弹簧</a>，但这被证明是困难的，因为:</p><ul class=""><li id="de3d" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">功能的启动时间很长。Spring是一个相当大的框架，它依赖于反射来启动，减慢它的速度。</li><li id="13b4" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">当时在Spring框架中对AWS lambda的支持并不多(我相信从那以后事情已经有所改善)。</li><li id="60d6" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">当时没有对GraalVM原生映像的支持(最近似乎有一些<a class="ae kv" href="https://github.com/spring-projects-experimental/spring-native" rel="noopener ugc nofollow" target="_blank">实验支持</a>)</li></ul><p id="f18a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，鉴于Spring不打算削减它，我们开始寻找上面提到的其他框架，这些框架专注于启动时间速度。我们最初决定从Micronaut开始评估Quarkus和Microanut，但我们对Micronaut非常满意，所以我们决定继续进行！总的来说，它似乎更关注无服务器场景，以及具体的AWS教程。事实上，我们很快就有了一个lambda函数，Micronaut在AWS上运行，它比Spring更快(然而，在使用GraalVM之前，它仍然没有达到可接受的水平)。除此之外，Micronaut:</p><ul class=""><li id="ad0e" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">在Gitter 上有一个很棒的<a class="ae kv" href="https://gitter.im/micronautfw/questions" rel="noopener ugc nofollow" target="_blank">支持社区</a></li><li id="894a" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">有一大堆关于如何使用这个框架的例子的文档。</li><li id="a8b2" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">允许为单元测试构建整个Micronaut框架，使得运行端到端测试变得非常容易，根本不需要模仿任何东西。这允许我们有数百个这样的集成测试，而不会对测试执行时间产生大的影响。我不得不说，没有什么比在真正的框架上运行测试更好的了，没有任何模仿。</li><li id="ae5f" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">有一个真正令人敬畏的<a class="ae kv" href="https://www.jetbrains.com/help/idea/micronaut.html" rel="noopener ugc nofollow" target="_blank"> IntelliJ IDEA插件</a>(仅用于<a class="ae kv" href="https://www.jetbrains.com/idea/" rel="noopener ugc nofollow" target="_blank"> IntelliJ IDEA终极版</a>)，它使得定义<a class="ae kv" href="https://micronaut-projects.github.io/micronaut-data/latest/guide/#querying" rel="noopener ugc nofollow" target="_blank">数据库查询</a>变得非常容易，只需按照特定的命名约定定义接口函数名称，然后让Micronaut用执行SQL操作的代码为您实现这些接口。</li><li id="9115" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">内置了对Swagger的支持，这使得向前端团队提供关于API的必要细节变得非常容易。</li></ul><blockquote class="ns"><p id="1d5f" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated">Micronaut实现其<a class="ae kv" href="https://micronaut.io/2020/04/28/practical-performance-comparison-of-spring-boot-micronaut-1-3-micronaut-2-0/" rel="noopener ugc nofollow" target="_blank">性能</a>的方法是完全不使用反射，而是使用<a class="ae kv" href="https://medium.com/@jintin/annotation-processing-in-java-3621cb05343a" rel="noopener">注释处理</a>来生成框架运行所需的所有代码。</p></blockquote><h2 id="0ddd" class="mo mp iq bd mq mr oc dn mt mu od dp mw lf oe my mz lj of nb nc ln og ne nf ng bi translated">GraalVM</h2><p id="0343" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我认为GraalVM值得作为本文的一部分，因为它突然出现并赢得了许多开发人员的青睐，它提供了JVM的替代方案，具有更好的性能特征，并使无服务器运行JVM语言成为可能。它有很多用途，从在你的项目中使用其他语言编写的库，一直到在同一个文件中组合使用JavaScript、Java、Ruby和R。</p><p id="6c3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将它与Micronaut和AWS lambda集成的经历无疑让我们度过了几个不眠之夜，因为在某些情况下，使用<a class="ae kv" href="https://www.graalvm.org/reference-manual/native-image/Reflection/" rel="noopener ugc nofollow" target="_blank">反射</a>或<a class="ae kv" href="https://www.graalvm.org/reference-manual/native-image/DynamicProxy/" rel="noopener ugc nofollow" target="_blank">动态代理</a>的库需要定制配置，但是一旦您理解了GraalVM原生映像是如何工作的，它就变成了一个非常简化的过程，很少需要关注。</p><p id="4bd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么使用GraalVM值得吗？绝对的！使用Micronaut执行冷启动的REST API调用需要大约10秒钟才能返回，而使用<a class="ae kv" href="https://www.graalvm.org/reference-manual/native-image/" rel="noopener ugc nofollow" target="_blank"> Graal VM本机映像</a>时只需要大约2秒钟！(其中冷启动大约为800毫秒)</p><h1 id="547c" class="oh mp iq bd mq oi oj ok mt ol om on mw jw oo jx mz jz op ka nc kc oq kd nf or bi translated">最终结果</h1><p id="0b98" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">以下是我们最终构建的系统的主要组件:</p><ul class=""><li id="19ba" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">整个后端用<a class="ae kv" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>编写，使用<a class="ae kv" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut框架</a>和<a class="ae kv" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank"> GraalVM </a>。</li><li id="2cac" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">我们使用<a class="ae kv" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>来构建我们的后端Kotlin项目</li><li id="8b02" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">通过<a class="ae kv" href="https://www.jetbrains.com/teamcity/cloud/" rel="noopener ugc nofollow" target="_blank"> TeamCity Cloud </a>的CI/CD:我们最初参与了<a class="ae kv" href="https://blog.jetbrains.com/teamcity/2019/12/sign-up-for-the-teamcity-cloud-beta/" rel="noopener ugc nofollow" target="_blank"> TeamCity Cloud Beta </a>，在那里我们获得了一个相当慷慨的免费信用包，以换取试用TeamCity的云产品。一旦测试版在2021年6月完成，使用该系统的体验，加上他们无与伦比的支持和帮助意愿，最终将我们转化为付费客户。值得注意的是，我们所有的CI/CD配置实际上都是使用他们的<a class="ae kv" href="https://www.jetbrains.com/help/teamcity/kotlin-dsl.html" rel="noopener ugc nofollow" target="_blank"> Kotlin DSL </a>编写的！</li><li id="89b5" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">后端是一个Rest API(通过<a class="ae kv" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>服务),服务于下一个<a class="ae kv" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank"> React </a> <a class="ae kv" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">。Js </a> Web应用托管在<a class="ae kv" href="https://aws.amazon.com/amplify/" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>上。</li><li id="b8e7" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">所有API端点都被<a class="ae kv" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html" rel="noopener ugc nofollow" target="_blank">代理</a>到<a class="ae kv" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS lambda </a>函数，与<a class="ae kv" href="https://aws.amazon.com/rds/" rel="noopener ugc nofollow" target="_blank"> MySQL RDS数据库</a>对话。</li><li id="9dae" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">我们使用一个<a class="ae kv" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank"> Cognito </a> <a class="ae kv" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html" rel="noopener ugc nofollow" target="_blank">用户池</a>进行认证和用户管理，它通过一个<a class="ae kv" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html" rel="noopener ugc nofollow" target="_blank"> Cognito授权器</a>连接到AWS API网关。我们还通过GitHub使用<a class="ae kv" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> Open ID Connect </a> (OIDC ),并将<a class="ae kv" href="https://github.com/TimothyJones/github-cognito-openid-wrapper" rel="noopener ugc nofollow" target="_blank">GitHub-cognito-OpenID-wrapper</a>库作为lambdas部署到我们的AWS基础设施，使GitHub OIDC兼容，以便我们可以将其连接到cogni to。</li><li id="2961" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">所有AWS基础设施都通过<a class="ae kv" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> AWS CloudFormation </a>进行管理。</li><li id="eda7" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">我们使用<a class="ae kv" href="https://aws.amazon.com/serverless/sam" rel="noopener ugc nofollow" target="_blank"> AWS无服务器应用模型</a>来帮助管理我们的无服务器基础设施。</li><li id="ff9c" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">3个环境:开发、试运行和生产，由相同的云形成脚本配置。</li></ul><h1 id="c176" class="oh mp iq bd mq oi oj ok mt ol om on mw jw oo jx mz jz op ka nc kc oq kd nf or bi translated">最后的想法</h1><p id="3c90" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">回顾过去，我们对自己做出的技术选择非常满意:AWS Lambda与Kotlin和Micronaut一起帮助这个项目快速向前发展，更不用说构建这些系统真的很有趣！</p><p id="c768" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正是这些技术加上GraalVM的结合导致了这个结果，所以我们很幸运，当我们开始构建Caribou时，这些技术已经足够成熟了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt os nq ot ou aw ov bi"><span id="9247" class="mo mp iq nq b gy ow ox l oy oz">You can help your teams fight the war against technical debt by checking out Caribou <a class="ae kv" href="https://www.hellocaribou.com/" rel="noopener ugc nofollow" target="_blank">here</a>.</span></pre></div></div>    
</body>
</html>