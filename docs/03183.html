<html>
<head>
<title>Swipe the Page With SwiftUIPager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUIPager滑动页面</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swipe-the-page-with-swiftuipager-981e379e3bbd?source=collection_archive---------8-----------------------#2020-01-27">https://betterprogramming.pub/swipe-the-page-with-swiftuipager-981e379e3bbd?source=collection_archive---------8-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="147b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">仅使用本地组件在SwiftUI中实现一个寻呼机，并以您想要的方式进行定制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/047b4b3672f2168bd4b4814ea8c976cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*y6hPB1mX_qRTwq8kA3b8Ag.png"/></div></figure><h1 id="87e7" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">介绍</h1><p id="7444" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个新框架已经存在了一段时间，你们大多数人都已经能够对它进行一些研究了。你可能听说过，尽管它是一个强大的框架，被认为是iOS开发的未来，但它仍然缺少许多功能，这些功能目前由<code class="fe me mf mg mh b">UIKit</code>提供。</p><p id="004a" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">在<code class="fe me mf mg mh b">SwiftUI</code>中没有的一个元素是<code class="fe me mf mg mh b">Pager</code>。如果你在谷歌上搜索“SwiftUI中的寻呼机”，你会发现大多数人的解决方案是将一个<code class="fe me mf mg mh b">UIPageViewController</code>包装成一个<code class="fe me mf mg mh b">UIViewControllerRepresentable</code>。还有其他解决方案吗？没有人用<code class="fe me mf mg mh b">SwiftUI</code>组件实现类似的东西吗？</p><p id="eddd" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated"><code class="fe me mf mg mh b">SwiftUIPager</code> <em class="mn"> </em>来救援了！<em class="mn"> </em>在本教程中，我们将介绍一个原生构建的解决方案:<code class="fe me mf mg mh b"><a class="ae mo" href="https://github.com/fermoya/SwiftUIPager" rel="noopener ugc nofollow" target="_blank">SwiftUIPager</a></code>。</p><div class="mp mq gp gr mr ms"><a href="https://github.com/fermoya/SwiftUIPager" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">fermoya/SwiftUIPager</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">SwiftUIPager提供了一个用SwiftUI本机组件构建的Pager组件。寻呼机是一个视图，它呈现一个可滚动的…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ko ms"/></div></div></a></div></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="79b2" class="kq kr it bd ks kt no kv kw kx np kz la jz nq ka lc kc nr kd le kf ns kg lg lh bi translated">SwiftUIPager:基础知识</h1><p id="ce6a" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">SwiftUIPager</code> <em class="mn"> </em>自带一个叫<code class="fe me mf mg mh b">Pager</code>的组件。这个组件建立在<code class="fe me mf mg mh b">SwiftUI</code>本地组件之上——也就是说，它根本不依赖于<em class="mn"> UIKit </em>。这可能看起来不重要，但实际上很重要，因为<code class="fe me mf mg mh b">SwiftUI</code>在幕后使用<code class="fe me mf mg mh b">Metal</code>渲染，这使得它比它的前身快得多。</p><p id="2890" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated"><code class="fe me mf mg mh b">Pager</code>是一个可滚动的容器，显示一些可回收的视图。这需要:</p><ul class=""><li id="e7a1" class="nt nu it lk b ll mi lo mj lr nv lv nw lz nx md ny nz oa ob bi translated">绑定到页面索引</li><li id="821b" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated">用于填充页面的项目数组</li><li id="4eaa" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated">工厂方法来创建每个页面</li></ul><p id="74b6" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated"><code class="fe me mf mg mh b">Pager</code>回收视图，这样你就不用担心内存问题——不用调用<code class="fe me mf mg mh b">applicationDidReceiveMemoryWarning</code>，这有多好？！</p><p id="4afc" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">好吧——太多单词了。让我们看看它是如何工作的:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="e4f0" class="ol kr it mh b gy om on l oo op">Pager(page: self.$pageIndex,<br/>      data: self.items,<br/>      content: { item in<br/>           // create a page based on item<br/>      self.pageView(item)<br/>})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/8ab22d09c86719f0e2eb5cba60f4079c.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*fXfmATZyWKdNppVmdcHNuw.gif"/></div></figure><p id="bb96" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">就这样。就是这么简单！难以置信。</p><p id="947d" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">有一堆修改器可以用来定制它:</p><ul class=""><li id="1cdb" class="nt nu it lk b ll mi lo mj lr nv lv nw lz nx md ny nz oa ob bi translated"><code class="fe me mf mg mh b">alignment</code>改变焦点页面在容器中的位置:开始、居中或结束。</li><li id="1016" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated"><code class="fe me mf mg mh b">itemSpacing</code>给元素之间留出空间。</li><li id="3a4d" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated"><code class="fe me mf mg mh b">itemApectRatio</code>根据可用空间和此<em class="mn">宽高比</em>配置页面尺寸。</li><li id="1a2f" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated"><code class="fe me mf mg mh b">pageOffset</code>动态改变<code class="fe me mf mg mh b">Pager</code>偏移量。</li><li id="1244" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated"><code class="fe me mf mg mh b">itemTappable</code>使页面可点击。</li></ul><p id="edb2" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">到目前为止还好吗？但是等等——还有更多！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="a706" class="kq kr it bd ks kt no kv kw kx np kz la jz nq ka lc kc nr kd le kf ns kg lg lh bi translated">SwiftUI方式</h1><p id="b611" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有两种方法可以制作分页动画。我们可以通过使用<code class="fe me mf mg mh b">interactive</code>修改器给滚动添加一个收缩效果:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="1e79" class="ol kr it mh b gy om on l oo op">Pager(...)<br/>    .itemAspectRatio(0.6)<br/>    .itemSpacing(10)<br/>    .padding(8)<br/>    .interactive(0.8)</span></pre><p id="2e47" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">注意到了<code class="fe me mf mg mh b">0 &lt; value &lt; 1</code>。否则默认为<code class="fe me mf mg mh b">1</code>，无交互。让我们看看这是什么样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/efe790278de850ce50839b6519b9b9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*xDDLwOjNaXPYS6KKO7piFA.gif"/></div></figure><p id="673f" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">它看起来令人惊奇不是吗？我们还要看更多吗？</p><p id="946e" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们看看剩下的可用动画— <code class="fe me mf mg mh b">rotation3D</code>:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="2d42" class="ol kr it mh b gy om on l oo op">Pager(...)<br/>    .itemAspectRatio(0.6)<br/>    .itemSpacing(10)<br/>    .padding(8)<br/>    .rotation3D()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/3eee6fad0d104459ae4a5823e99c684d.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*G26cI4Zc9cV-rcvmcdmv-g.gif"/></div></figure><p id="971e" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">太棒了，我们有一个漂亮的旋转，我们几乎不需要任何代码！</p><p id="3db3" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">结束了吗？<em class="mn">没有</em>，还有更多！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="e43a" class="kq kr it bd ks kt no kv kw kx np kz la jz nq ka lc kc nr kd le kf ns kg lg lh bi translated">支持不同的方向和滑动方向</h1><p id="8b47" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">Pager</code>使改变分页方向变得容易。只需添加<code class="fe me mf mg mh b">vertical</code>修饰符:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="e88f" class="ol kr it mh b gy om on l oo op">Pager(...)<br/>    .vertical()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/15d6cea9d0a87611ed8f74b041e12911.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*hW6Jy_7HTjjfc5sgzX-8GA.gif"/></div></figure><p id="c196" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">谁说传呼机一定要一直往同一个方向刷？使用<code class="fe me mf mg mh b">horizontal</code>或<code class="fe me mf mg mh b">vertical</code>修饰键改变分页方向:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="defe" class="ol kr it mh b gy om on l oo op">Pager(...)<br/>    .itemSpacing(10)<br/>    .alignment(.start)<br/>    .horizontal(.rightToLeft)<br/>    .itemAspectRatio(0.6)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/1e6f802d0edd55b74860722a2f0aa9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*ZAm2_3jzFk5xDfBiDWTs2Q.gif"/></div></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="949e" class="kq kr it bd ks kt no kv kw kx np kz la jz nq ka lc kc nr kd le kf ns kg lg lh bi translated">更多功能</h1><p id="0409" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有两个特性值得一提。其中一个就是<code class="fe me mf mg mh b">onPageChanged</code>修改器。该便利函数接受一个回调，每次<code class="fe me mf mg mh b">pageIndex</code>改变时都会执行该回调:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="741c" class="ol kr it mh b gy om on l oo op">Pager(...)<br/>    .onPageChanged({ index in<br/>        // do something<br/>    })</span></pre><p id="6a02" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">这允许您对<code class="fe me mf mg mh b">Pager</code>上的任何变化做出反应。你听到我在那里做了什么吗——<em class="mn">反应！是的，反应式编程是当今的一个热门话题。为尽可能多的事件服务。</em></p><p id="5e8c" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">最后但同样重要的是，<code class="fe me mf mg mh b">pageOffset</code>允许您动态改变<code class="fe me mf mg mh b">Pager</code>偏移。请注意，传递的值是相对于页面之间的距离。</p><p id="8ef6" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">假设您想以交互和增量的方式管理屏幕任何其他部分的偏移。您可以轻松使用<code class="fe me mf mg mh b">pageOffset</code>让<code class="fe me mf mg mh b">Pager</code>为您滚动:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="26a6" class="ol kr it mh b gy om on l oo op">Pager(...)<br/>    .pageOffset($someOffset)</span></pre><h1 id="6e30" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">结论</h1><p id="7a7c" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">SwiftUIPager</code>为您带来功能强大的本地寻呼机:</p><ul class=""><li id="2ab5" class="nt nu it lk b ll mi lo mj lr nv lv nw lz nx md ny nz oa ob bi translated">水平和垂直寻呼机。</li><li id="8bf4" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated">不同的方向，取决于方向:从右到左，从上到下。</li><li id="af76" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated">更改屏幕对齐和位置的选项。</li><li id="d6dd" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated">动画效果，给滚动增加一点趣味。</li></ul></div></div>    
</body>
</html>