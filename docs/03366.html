<html>
<head>
<title>10 Tiny Python Idioms for Collections and Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集合和数据结构的10个小Python习惯用法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-tiny-python-idioms-for-collections-and-data-structures-2f0d2923832?source=collection_archive---------8-----------------------#2020-02-05">https://betterprogramming.pub/10-tiny-python-idioms-for-collections-and-data-structures-2f0d2923832?source=collection_archive---------8-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f77" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以最Pythonic化的方式使用容器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5d08fa4f4ce367d19778c461690bba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*duiAdFFsBeLdI5mNiwbzJg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jruscello?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰西卡·鲁斯切洛</a>在<a class="ae ky" href="https://unsplash.com/s/photos/collection?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="258c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每项任务都可以用几种不同的方法来解决。这是编程的基本假设之一。虽然有些解决方案可能会变得太复杂，但其他解决方案可能非常简单。</p><p id="23a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种想法应该可以引导你学习Python语言。对我来说，它允许开发人员创建每行都有意义的最紧凑的程序。</p><p id="2f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在处理列表、字典、元组等容器时，这一点变得尤为明显。您需要一个命令，它同时应用于每个元素，并为整个集合提供修改。</p><p id="fbbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不应该为每一个元素而烦恼，而是一次为整个数据集而烦恼。这对数据科学家来说尤其重要。</p><p id="e65f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我来介绍一些Python的习惯用法，作为这些词的论据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="af10" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">字典中的最大值</h1><p id="73bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们测试几种不同的方法。</p><p id="9a91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅最大值:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a787" class="ne md it na b gy nf ng l nh ni">max(some_dict.values())</span></pre><p id="6c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最大值的关键:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="78fc" class="ne md it na b gy nf ng l nh ni">max(some_dict, key <strong class="na iu">=</strong> new_dict.get)</span></pre><p id="b6d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们两个:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f6b0" class="ne md it na b gy nf ng l nh ni">max(some_dict.items(), key <strong class="na iu">=</strong> <strong class="na iu">lambda</strong> x: x[1])</span></pre><p id="d088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更通用的方法:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a650" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">import</strong> operator<br/>max(some_dict.items(), key <strong class="na iu">=</strong> operator.itemgetter(1))</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d5f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">获取几个字典的元素</h1><p id="4f37" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这将有助于从多个来源创建独特元素的列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fc60" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从列表中获取唯一元素</h1><p id="16e1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我最喜欢的习语和最短的一个。</p><p id="9cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建列表:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bde3" class="ne md it na b gy nf ng l nh ni">new_list <strong class="na iu">=</strong> [random.randint(0,9) <strong class="na iu">for</strong> el <strong class="na iu">in</strong> range(1,1001)]</span></pre><p id="9fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和类型:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f973" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">set</strong>(new_list)</span><span id="aeb4" class="ne md it na b gy nl ng l nh ni">Out[1]: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98ec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">列表中的重复次数</h1><p id="b8bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们采用与前一个命令相同的列表。纯蟒道:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0873" class="ne md it na b gy nf ng l nh ni">{el : new_list.count(el) <strong class="na iu">for</strong> el <strong class="na iu">in</strong> set(new_list)}</span><span id="8be2" class="ne md it na b gy nl ng l nh ni">Out[1]: {0: 76, 1: 92, 2: 103, 3: 113, 4: 85, 5: 112, 6: 109, 7: 116, 8: 93, 9: 101}</span></pre><p id="cd74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更通用的方法(输出相同):</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="70f5" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">from</strong> itertools <strong class="na iu">import</strong> groupby</span><span id="afc0" class="ne md it na b gy nl ng l nh ni">{key : len(list(group)) <strong class="na iu">for</strong> key, group <strong class="na iu">in</strong> groupby(sorted(new_list))}</span></pre><p id="93f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最短的一个(输出也是相同的):</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c3c8" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">from</strong> collections <strong class="na iu">import</strong> Counter<br/>dict(Counter(new_list))</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0bf8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反转字符串(或列表)</h1><p id="0f18" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是所有Python程序中被过度使用的最著名的习语:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="192e" class="ne md it na b gy nf ng l nh ni">new_str <strong class="na iu">=</strong> "Abcd efgh ijk lmn opq rstu v w xyz"<br/>new_str[::<strong class="na iu">-</strong>1]</span><span id="0de0" class="ne md it na b gy nl ng l nh ni">Out[1]: 'zyx w v utsr qpo nml kji hgfe dcbA'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8f43" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">序列最长的Zip</h1><p id="4abf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最有用的Python内置函数之一(<code class="fe nm nn no na b">zip</code>)接受几个列表(或其他可迭代对象)并通过成对匹配遍历它们。尽管当最短列表结束时该功能停止。</p><p id="016b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，还有另一个函数可以迭代，直到最长的序列结束。所有缺失的值都用<code class="fe nm nn no na b">None</code>填充。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a092" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">清单的快速副本</h1><p id="0d23" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当然，Python有一个专门的模块，可以在几乎每个数据结构中与方法copy一起复制。虽然有一种制作列表、字符串或其他可迭代对象的副本的最有效的方法——切片:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="92f0" class="ne md it na b gy nf ng l nh ni">list_a <strong class="na iu">=</strong> [1,2,3,4,5]<br/>list_a_copy <strong class="na iu">=</strong> list_a<strong class="na iu">[:]</strong></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f94" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对整个列表进行快速操作</h1><p id="9700" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以找到一个非常有趣的替代方法来代替需要遍历每个元素的循环。Python允许下一个技巧:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ab9d" class="ne md it na b gy nf ng l nh ni">list(map(<strong class="na iu">lambda</strong> x: x<strong class="na iu">**</strong>2, list_a))</span></pre><p id="7f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经在一行代码中对每个列表元素应用了一个操作。甚至，我们可以对几个序列重复操作:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="963d" class="ne md it na b gy nf ng l nh ni">list(map(<strong class="na iu">lambda</strong> a, b: a<strong class="na iu">+</strong>b, list_a, list_b))</span></pre><p id="b5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回成对总和的列表。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aec9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">空值过滤</h1><p id="8930" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们有一个稀疏列表，里面有很多零。或者更像是一个数据科学的例子:有很多缺失值的列。我们应该如何获得真实的值？下一个习语就是为此而生的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fb24" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">转置和列提取</h1><p id="298d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个简单的数学运算——转置矩阵——可能需要几行代码和一对循环。尽管Python几乎对所有事情都采用一句话的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="74cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果我们需要矩阵的单个列:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="64ba" class="ne md it na b gy nf ng l nh ni">col1, col2, _ <strong class="na iu">=</strong> zip(<strong class="na iu">*</strong>table)<br/>col2</span><span id="909c" class="ne md it na b gy nl ng l nh ni">Out[1]: (2, 5, 8, 0)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be1e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="7e7f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python充满了单短语习惯用法，在其他编程语言中，这些习惯用法可能采用几种代码结构。我喜欢紧凑整洁的代码，这就是我有一天开始学习Python的原因。</p><p id="8a8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在我的GitHub中找到整个工作笔记本:</p><div class="np nq gp gr nr ns"><a href="https://github.com/Midvel/medium_jupyter_notes/blob/master/python_tiny_tips/containers-tips.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">中级/中等_jupyter_notes</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">permalink dissolve GitHub是4000多万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div><p id="d38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分享你最喜欢的Python习惯用法或库中的工具，它们可以最小化你的代码。</p></div></div>    
</body>
</html>