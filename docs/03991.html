<html>
<head>
<title>React useState in Imperative and Declarative Ways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以命令和声明的方式对使用状态做出反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/master-usestate-in-imperative-and-declarative-ways-e298f6d9c352?source=collection_archive---------12-----------------------#2020-03-17">https://betterprogramming.pub/master-usestate-in-imperative-and-declarative-ways-e298f6d9c352?source=collection_archive---------12-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5098" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何以多种方式使用useState来获得最佳结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9361e747927ab169a8a06913bcd0d8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EfQjJ9vvo4bEdORG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗伯特·阿纳施在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2019年2月6日，对于React社区来说是个好日子。React团队最终发布了16.8稳定版的Hooks API。它是巨大的。人们对此非常兴奋。人们已经等待这个改变游戏规则的API好几个月了，它终于出现了。</p><p id="75e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们记住<a class="lv lw ep" href="https://medium.com/u/b610e3f3fee2?source=post_page-----e298f6d9c352--------------------------------" rel="noopener" target="_blank"> Sophie Alpert </a>和<a class="lv lw ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----e298f6d9c352--------------------------------" rel="noopener" target="_blank"> Dan Abramov </a>在React Conf 2018上宣布Hooks API的那些激动人心的日子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="772a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Hooks API改变了我们编写React组件的方式。我们都告别了类组件，用爱拥抱了功能组件。原因很清楚。组件变得更加清晰，共享逻辑变得更加容易，等等。</p><p id="8390" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Hooks API有很多方法。核心方法之一是<code class="fe lz ma mb mc b">useState</code>钩子，这个故事就是专门为它而写的。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="ecd0" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">介绍</h1><p id="57d7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我将向您展示用<code class="fe lz ma mb mc b">useState</code>解决相同问题的许多不同方法。你会看到<code class="fe lz ma mb mc b">useState</code>的能力和问题。这将帮助你更有意识地使用它，并从中获得最大收益。</p><p id="5cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在这个故事中找不到任何与<code class="fe lz ma mb mc b">useReducer</code>相关的东西，这是故意的。当然，根据上下文的不同,<code class="fe lz ma mb mc b">useReducer</code>有优点也有缺点。</p><p id="8520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象你有一个<code class="fe lz ma mb mc b">useState</code>挑战。您需要找到仅用<code class="fe lz ma mb mc b">useState</code>解决相同问题的最佳方法。用<code class="fe lz ma mb mc b">useReducer</code>解决同样的问题是另一个故事的主题。</p><p id="e0a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反例很酷，但我们需要更多的东西。为了更好地理解这个主题，我们将创建一些您可以在现实世界中使用的东西。我们将创建一个名为<code class="fe lz ma mb mc b">useUndo</code>的定制钩子，它可以为状态提供撤销和重做能力。</p><p id="ce37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意这些示例是在TypeScript中。但是不用担心。即使你对TypeScript一无所知，也可以忽略你不懂的语法。剩下的就是JavaScript了。</p><p id="29f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这个CodeSandbox中找到所有示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ly l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Codesandbox上的示例</p></figure><p id="2928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以在页面底部的“资源”部分找到一些好的资源来深化和改进您的学习。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="48fe" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">多重使用状态</h1><p id="929f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">许多开始<code class="fe lz ma mb mc b">useState</code>的人都在用这种方法。真的很好理解，很容易上手。规则很简单。为你需要的大州的每一部分创建一个新的州。然后使用相关的变量和更新函数。</p><p id="2fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了构建一个<code class="fe lz ma mb mc b">useUndo</code>钩子，我们需要两个最基本的状态:作为数组的状态历史和指向历史中当前条目的索引号。</p><p id="65aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是使用这种方法的<code class="fe lz ma mb mc b">useUndo</code>钩子的完整实现。请仔细阅读代码，并尝试理解这两种状态是如何相互依赖的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni ly l"/></div></figure><p id="8e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe lz ma mb mc b">history</code>和<code class="fe lz ma mb mc b">presentIndex</code>状态是如何相互依赖的。为了计算<code class="fe lz ma mb mc b">past</code>、<code class="fe lz ma mb mc b">present</code>和<code class="fe lz ma mb mc b">future</code>状态，我们需要这两种状态。</p><p id="a7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果这些部分几乎不相互依赖，那么创建多个状态的意义何在？</p><p id="47a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个包含所有状态的对象。这样，如果我们有50个状态，我们可以避免创建50个不同的<code class="fe lz ma mb mc b">setState</code>函数。</p><p id="98fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在下一个例子中解决这个问题。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="b3ea" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">单一使用状态</h1><p id="b5d7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如果你有一个庞大的国家，各个部分相互依赖，最好将所有这些部分组合在一个对象中。否则，我们将会有如此多的状态更新，这将很容易变成一个地狱。</p><p id="3993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们的示例状态很小，但是将<code class="fe lz ma mb mc b">history</code>和<code class="fe lz ma mb mc b">presentIndex</code>组合成一个对象仍然是有意义的。这样，我们可以使用相同的<code class="fe lz ma mb mc b">setState</code>函数更新状态的任何部分，并使用状态对象访问任何部分。</p><p id="09e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是上面例子的重构版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni ly l"/></div></figure><p id="9b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，状态被合并，<code class="fe lz ma mb mc b">setState</code>函数的数量减少了，但是我们真的从这个具体的例子中得到任何好处吗？好吧，这是可以讨论的。</p><p id="bf31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然你可以争论单个<code class="fe lz ma mb mc b">useState</code>的好处，但我想指出一些严重的问题。上面的例子有一个令人讨厌的缺陷。我们需要一些示例代码来演示它。</p><p id="9970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">附:特别感谢<a class="lv lw ep" href="https://medium.com/u/db72389e89d8?source=post_page-----e298f6d9c352--------------------------------" rel="noopener" target="_blank">肯特·c·多兹</a>为<a class="ae ky" href="https://kentcdodds.com/blog/should-i-usestate-or-usereducer" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。同样的问题在那里凸显。我强烈推荐你阅读它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni ly l"/></div></figure><p id="1273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将在<code class="fe lz ma mb mc b">console.log</code>输出中看到第一个问题。以下是预期输出和实际输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni ly l"/></div></figure><p id="5e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们运行了<code class="fe lz ma mb mc b">set</code>函数四次，但是我们只看到了最后一次的结果。你能猜出问题吗？</p><p id="4348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是配料。React批处理连续的<code class="fe lz ma mb mc b">setState</code>调用，因此，组件不会为每个调用重新呈现。让我们一步一步来看看会发生什么。</p><ul class=""><li id="779e" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">应用程序被渲染。状态被设置为<code class="fe lz ma mb mc b">{ history: ['first'], presentIndex: 0 }</code>。</li><li id="d9d6" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lz ma mb mc b">useEffect</code>被触发。</li><li id="bb24" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lz ma mb mc b">set('second')</code>正在运行。<code class="fe lz ma mb mc b">set</code>函数根据来自函数顶层的<code class="fe lz ma mb mc b">past</code>和<code class="fe lz ma mb mc b">present</code>计算状态。国家计算为<code class="fe lz ma mb mc b">{ history: ['first', 'second'], presentIndex: 1}</code>。因为React批处理了<code class="fe lz ma mb mc b">setState</code>调用，所以组件没有被重新呈现。</li><li id="bcad" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lz ma mb mc b">set('third')</code>正在运行。<code class="fe lz ma mb mc b">set</code>函数根据来自该函数顶层的<code class="fe lz ma mb mc b">past</code>和<code class="fe lz ma mb mc b">present</code>计算状态。由于之前的调用没有导致重新渲染，这些值仍然与第一个组件渲染相同。状态将其计算为<code class="fe lz ma mb mc b">{ history: ['first', 'third'], presentIndex: 1}</code>，但是同样，由于批处理，组件没有被重新呈现。</li><li id="9889" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lz ma mb mc b">set('forth')</code>同上。</li><li id="9ec0" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lz ma mb mc b">set('fifth')</code>同上。不过这一次，React完成了配料。组件将重新呈现。状态更新为<code class="fe lz ma mb mc b">{ history: ['first', 'fifth'], presentIndex: 1}</code>。</li></ul><p id="913c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解流程，您可以将一些<code class="fe lz ma mb mc b">console.log</code>表达式放入实现中，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni ly l"/></div></figure><p id="0747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你可能已经意识到的，我们使用<code class="fe lz ma mb mc b">useCallback</code>来防止在每次重新渲染时创建新的<code class="fe lz ma mb mc b">set</code>函数。<code class="fe lz ma mb mc b">useCallback</code>依赖于从状态计算出来的<code class="fe lz ma mb mc b">past</code>数组。所以，每次<code class="fe lz ma mb mc b">past</code>改变，一个新的<code class="fe lz ma mb mc b">set</code>被创建，而不是每次重新渲染。</p><p id="ca20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能认为如果我们将<code class="fe lz ma mb mc b">set</code>放入<code class="fe lz ma mb mc b">useEffect</code>依赖项中，这个问题就可以解决。</p><p id="ea48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不完全是。这就产生了另一个问题。因为每次调用<code class="fe lz ma mb mc b">set</code>函数，都会创建一个新的<code class="fe lz ma mb mc b">past</code>值。因此，这会导致<code class="fe lz ma mb mc b">useEffect</code>不断重复运行。</p><p id="ee65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们主要是以命令的方式使用<code class="fe lz ma mb mc b">useState</code>。一般来说，我们发现自己在用上面两种方法编写命令式代码。两者都有问题，而且共事起来也不愉快。</p><p id="13eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是下一个方法，它修复了我们遇到的问题，并鼓励我们编写更多的声明性代码。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="e8f6" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">使用状态的功能更新形式</h1><p id="06c9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><code class="fe lz ma mb mc b">useState</code>钩子有两种不同的方法来更新状态。作为参数和函数更新器形式的新状态。</p><pre class="kj kk kl km gt nx mc ny nz aw oa bi"><span id="50df" class="ob ml it mc b gy oc od l oe of">1. setState(newState)<br/>2. setState(prevState =&gt; newState)</span></pre><p id="a268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后退一步，再次查看前面实现的代码。您将看到我们传递了从状态中计算出来的<code class="fe lz ma mb mc b">useCallback</code>依赖项。</p><p id="356a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用函数更新的形式，我们可以得到以前的状态作为一个参数，这可以消除所有那些需要的依赖。</p><p id="a477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将始终可以访问最新计算的状态。不需要重新渲染组件来更新状态和计算新的状态。这样可以解决我们的批量问题。</p><p id="603b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是带有功能更新程序表单的示例的重构版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni ly l"/></div></figure><p id="46e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方法，我们消除了所有的<code class="fe lz ma mb mc b">useCallback</code>依赖性。我们将只创建一次函数，在第一个组件渲染时。</p><p id="39e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，无论组件是否重新呈现，状态更新逻辑总是可以访问最新计算的状态。</p><p id="7770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用新方法尝试下面的例子，看看结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni ly l"/></div></figure><p id="08d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息是好的。bug被修复了，我们很高兴。但是既然我们已经接触了一点函数式编程，我们能更进一步吗？有没有更好的方法来解决同样的问题？</p><p id="8c16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始了。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="bfcc" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">使用状态的函数式编程</h1><p id="97c7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><code class="fe lz ma mb mc b">useState</code>的功能更新形式很棒。解决了一些问题，并鼓励我们编写更多的声明性代码。</p><p id="51d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在不太疯狂的情况下，将这与一些基本的函数式编程概念(如纯函数和curry)结合起来，会不会更好？</p><p id="3489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先我来问这个问题:“你愿意看到身体<code class="fe lz ma mb mc b">useUndo</code>勾成这样吗？”</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni ly l"/></div></figure><p id="c9be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果答案是肯定的，请原谅我。下面是完整的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni ly l"/></div></figure><p id="abcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这个功能性的<code class="fe lz ma mb mc b">useState</code>到底是怎么回事呢？</p><p id="9484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，它使我们的代码更容易阅读。当您查看<code class="fe lz ma mb mc b">useUndo</code>主体时，您可以立即理解发生了什么，而无需深入实现细节。</p><p id="b899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，代码更容易测试。现在我们大部分都是纯函数，对React一无所知。每个职能部门负责一项工作。想象一下这将如何使测试变得更容易。</p><p id="86a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些优势很酷，但让我们回顾一下我们是如何实现的。</p><p id="5b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一些curry函数来创建其他函数，我们可以将这些函数作为参数传递给<code class="fe lz ma mb mc b">setState</code>调用。</p><p id="95c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么库里函数？因为我们可能需要向<code class="fe lz ma mb mc b">setState</code>回调函数传递额外的参数，比如<code class="fe lz ma mb mc b">newPresent</code>或<code class="fe lz ma mb mc b">initialPresent</code>。并不是所有的函数都需要参数，但是从一致性的角度来说，让我们保留所有的curry函数。</p><p id="6586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一些选择器来获取计算数据，如<code class="fe lz ma mb mc b">past</code>、<code class="fe lz ma mb mc b">present</code>、<code class="fe lz ma mb mc b">future</code>等。好处是我们的<code class="fe lz ma mb mc b">useUndo</code>钩子不关心实现细节。</p><p id="fcbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了我们在<code class="fe lz ma mb mc b">useUndo</code>主体中需要什么，我们定义了我们的API，剩下的就是幕后了。即使逻辑的实现细节发生了变化，<code class="fe lz ma mb mc b">useUndo</code>主体大部分保持不变。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="42d4" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="52ce" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如果没有任何错误或问题，以上所有方法都是有效的。你可能更喜欢对小的使用多个<code class="fe lz ma mb mc b">useState</code>或者更喜欢全功能的方法。一切都很好。</p><p id="8803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是理解<code class="fe lz ma mb mc b">useState</code>是如何工作的，以及它在不同方法上的表现。对它有了很好的了解之后，剩下的就看语境和喜好了。</p><p id="7ab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持动力，继续编码！</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="44b8" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">资源</h1><ul class=""><li id="a95e" class="nj nk it lb b lc nc lf nd li og lm oh lq oi lu no np nq nr bi translated"><a class="ae ky" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">使用状态挂钩</a></li><li id="9960" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><a class="ae ky" href="https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function" rel="noopener ugc nofollow" target="_blank">为什么我在函数中看到陈旧的属性或状态？</a></li><li id="ce84" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><a class="ae ky" href="https://redux.js.org/recipes/implementing-undo-history/" rel="noopener ugc nofollow" target="_blank">执行撤销历史</a></li><li id="535e" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><a class="ae ky" href="https://github.com/omnidan/redux-undo" rel="noopener ugc nofollow" target="_blank">还原-撤销</a></li><li id="0744" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><a class="ae ky" href="https://github.com/xxhomey19/use-undo" rel="noopener ugc nofollow" target="_blank">使用-撤销</a></li><li id="dfbd" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><a class="ae ky" href="https://kentcdodds.com/blog/should-i-usestate-or-usereducer" rel="noopener ugc nofollow" target="_blank">我应该用State还是useReducer？</a></li></ul></div></div>    
</body>
</html>