<html>
<head>
<title>Split Angular Nested Forms Into Subform Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将角形嵌套形状拆分为子形状构件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/split-angular-nested-forms-into-subform-components-dcf32d1fb10d?source=collection_archive---------2-----------------------#2022-06-07">https://betterprogramming.pub/split-angular-nested-forms-into-subform-components-dcf32d1fb10d?source=collection_archive---------2-----------------------#2022-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ffca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何将有角度的嵌套窗体变成更小的子窗体组件。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00a447bf66b43abf70cbae5d293d0266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAATEFQHSbRLt_b6CrKC5w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.istockphoto.com/portfolio/DTatiana8" rel="noopener ugc nofollow" target="_blank"> DTatiana8 </a>拍摄</p></figure><p id="b0ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<a class="ae ky" href="https://javascript.plainenglish.io/angular-custom-form-controls-nested-form-groups-made-easy-2ac09e91cf67" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我们讨论了如何创建高度可重用和可移植的嵌套表单组。</p><p id="5981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管有时我们不得不处理更简单的情况，这并不证明实现像<code class="fe lv lw lx ly b"><a class="ae ky" href="https://angular.io/api/forms/ControlValueAccessor" rel="noopener ugc nofollow" target="_blank">ControlValueAccessor</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://angular.io/api/forms/Validator" rel="noopener ugc nofollow" target="_blank">Validator</a></code>这样的接口是正确的。</p><p id="8b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们可能希望遵循嵌套表单的子表单组件方式。在这种方法中，我们将大的表单分成更小的子表单，这些子表单在子组件中实现。</p><p id="a85c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，没有进一步的到期，让我们开始吧！</p><h1 id="0819" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">利弊:何时使用</h1><p id="60b7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在我们深入研究实现细节之前，有必要提一下这种方法的主要优缺点，这样我们就知道会发生什么了。</p><p id="7bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要的好处是我们得到了更小的子表单和更简单的实现。较小的代码片段更容易理解和维护。</p><p id="b725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要的缺点是，我们只能将这些子表单与一个表单模块一起使用，这是实现中所选择的模块。所以，要么是模板驱动的表单，要么是反应式表单。不是两者都有。</p><p id="ba41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长话短说，我们有意为了简单而牺牲可移植性。</p><h1 id="c49d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">模板驱动的表单</h1><p id="6080" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们将从模板驱动的表单开始。</p><p id="b704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">父组件通常包含两个子表单的所有代码。然而，根据这个解决方案，子表单是在单独的组件中实现的。因此，父组件具有以下模板:</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="6978" class="na ma it ly b be nb nc l nd ne">&lt;form&gt;<br/>  &lt;app-personal&gt;&lt;/app-personal&gt;<br/>  &lt;app-address&gt;&lt;/app-address&gt;<br/>&lt;/form&gt;</span></pre><p id="c45b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把注意力转向子表单组件之一，<code class="fe lv lw lx ly b">personal</code>组件，它有以下模板:</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="1cf2" class="na ma it ly b be nb nc l nd ne">&lt;div ngModelGroup="personal" #personal="ngModelGroup"&gt;<br/>  &lt;p class="display-6"&gt;Personal Information&lt;/p&gt;<br/>  &lt;app-required-field name="first" ngModel placeholder="First name"&gt;<br/>  &lt;/app-required-field&gt;<br/>  &lt;app-required-field name="last" ngModel placeholder="Last name"&gt;<br/>  &lt;/app-required-field&gt;<br/>  &lt;app-required-select<br/>    placeholder="Select gender..."<br/>    [options]="genderOptions"<br/>    name="gender"<br/>    ngModel<br/>  &gt;&lt;/app-required-select&gt;<br/>  &lt;ng-container *ngIf="personal?.value?.gender === 'Other'"&gt;<br/>    &lt;app-required-field name="genderOther" ngModel placeholder="Specify"&gt;<br/>    &lt;/app-required-field&gt;<br/>  &lt;/ng-container&gt;<br/>&lt;/div&gt;h</span></pre><p id="a691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nf">如果您想知道如何在我们的一个组件上直接使用</em> <code class="fe lv lw lx ly b"><em class="nf">ngModel</em></code> <em class="nf">，这在我们的</em> <a class="ae ky" href="https://javascript.plainenglish.io/angular-custom-form-controls-nested-form-groups-made-easy-2ac09e91cf67" rel="noopener ugc nofollow" target="_blank"> <em class="nf">上一篇文章</em> </a> <em class="nf">中有很好的解释。</em></p><p id="9a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有人可能会认为<code class="fe lv lw lx ly b">NgModelGroup</code>会和顶级的<code class="fe lv lw lx ly b">NgForm</code>合作。但事实并非如此。相反，我们将在控制台中得到一个“没有ControlContainer的提供者”错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/59e114b8f5e65897516fc9f917b1e787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*JOKHOp7-kzxWnogTX_enuw.png"/></div></figure><p id="f544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的解决方法很简单。这是组件的类文件中的一行代码。不幸的是，解释没有修复本身那么简短。</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="0082" class="na ma it ly b be nb nc l nd ne">@Component({<br/>  selector: 'app-personal',<br/>  templateUrl: './personal.component.html',<br/>  styleUrls: ['./personal.component.scss'],<br/>  viewProviders: [{ provide: ControlContainer, useExisting: NgForm }]<br/>})<br/>export class PersonalComponent implements OnInit {<br/>  // ...<br/>}</span></pre><p id="0f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们需要在<code class="fe lv lw lx ly b">viewProviders</code>中提供<code class="fe lv lw lx ly b">ControlContainer</code>？</p><p id="f6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://angular.io/api/forms/ControlContainer" rel="noopener ugc nofollow" target="_blank">ControlContainer</a></code>类是<code class="fe lv lw lx ly b">NgForm</code>、<code class="fe lv lw lx ly b">NgModelGroup</code>、<code class="fe lv lw lx ly b">NgFormGroupDirective</code>、<code class="fe lv lw lx ly b">FormGroupName</code>和<code class="fe lv lw lx ly b">FormArrayName</code>的超类。</p><p id="c43a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个指令，<code class="fe lv lw lx ly b">NgModelGroup</code>将在树中查找它的父表单。其父级可能是:</p><ul class=""><li id="efea" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">另一个组，因为我们的表单可能有一个非常深的嵌套结构，一个组在另一个组中，等等</li><li id="3944" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">实际的父表单，就像我们的简单例子中只有一个嵌套层次</li></ul><p id="7203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管是哪种情况，它最终都必须解析为父表单，因为父表单完成了大部分繁重的工作。</p><p id="729e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们有一个<code class="fe lv lw lx ly b">NgModelGroup</code>找不到它需要的<code class="fe lv lw lx ly b">NgForm</code>。但是在它的正上方有一个<code class="fe lv lw lx ly b">NgForm</code>！为什么它找不到？</p><p id="9ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看<code class="fe lv lw lx ly b">NgModelGroup</code>的构造函数(原始源代码可以在<a class="ae ky" href="https://github.com/angular/angular/blob/main/packages/forms/src/directives/ng_model_group.ts" rel="noopener ugc nofollow" target="_blank">这里找到</a>):</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="79dd" class="na ma it ly b be nb nc l nd ne">export class NgModelGroup extends AbstractFormGroupDirective implements OnInit, OnDestroy {<br/>  constructor(<br/>    @Host() @SkipSelf() parent: ControlContainer,<br/>    @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],<br/>    @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators: (AsyncValidator|AsyncValidatorFn)[]) {<br/>    super();<br/>    // ...<br/>  }<br/>}</span></pre><p id="a0d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注入的<code class="fe lv lw lx ly b">ControlContainer</code>实例有一个<code class="fe lv lw lx ly b">@Host()</code>装饰器。<code class="fe lv lw lx ly b">@Host()</code>装饰器限制<code class="fe lv lw lx ly b">NgModelGroup</code>从其视图上方查看其<code class="fe lv lw lx ly b">ControlContainer</code>依赖关系。所以它建立了某种界限。</p><p id="14d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，默认情况下，<code class="fe lv lw lx ly b">NgModelGroup</code>只允许在当前组件视图中查找树。但是在我们的方法中，父表单和<code class="fe lv lw lx ly b">NgModelGroup</code>不在同一个组件中。<code class="fe lv lw lx ly b">NgModelGroup</code>在一个单独的子组件中！</p><p id="54df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之所以有这样的限制，是因为急于跨组件边界注册可能会有风险。例如，第三方组件将能够达到所有的方式，并注册到任何东西，导致意想不到的副作用。</p><p id="4df4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这个一行程序让我们绕过注册限制，提供缺失的<code class="fe lv lw lx ly b">ControlContainer</code>，并使用依赖注入链中现有的<code class="fe lv lw lx ly b">NgForm</code>。</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="4a68" class="na ma it ly b be nb nc l nd ne">viewProviders: [{ provide: ControlContainer, useExisting: NgForm }]</span></pre><h2 id="c538" class="nv ma it bd mb nw nx dn mf ny nz dp mj li oa ob ml lm oc od mn lq oe of mp og bi translated"><strong class="ak">为什么我们用</strong> <code class="fe lv lw lx ly b"><strong class="ak">viewProviders</strong></code> <strong class="ak">代替</strong> <code class="fe lv lw lx ly b"><strong class="ak">providers</strong></code> <strong class="ak">？</strong></h2><p id="e49a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">他们说一幅画胜过千言万语。因此，图表会使解释更容易理解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/26ca3c64ea6f633fd389c7f9480ea033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8nd0uRQcgeV-KR1taU0cw.png"/></div></div></figure><p id="24fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚线是由<code class="fe lv lw lx ly b">@Host()</code>装饰器创建的边界。<code class="fe lv lw lx ly b">ControlContainer</code>可以提供两种不同的电平。</p><p id="7e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用<code class="fe lv lw lx ly b">providers</code>提供<code class="fe lv lw lx ly b">ControlContainer</code>，那么<code class="fe lv lw lx ly b">NgModelGroup</code>仍然无法到达并看到它。相反，我们需要使用<code class="fe lv lw lx ly b">viewProviders</code>在下面的级别提供它。</p><p id="c8c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的长篇大论到此结束。但是，如果你需要使用它，解决方案只是一行代码。</p><p id="c368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在下面的StackBlitz找到一个工作演示。你可能也想<a class="ae ky" href="https://vkagklis.medium.com/subscribe" rel="noopener">订阅我的时事通讯</a>来关注更多类似的内容！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="e554" class="lz ma it bd mb mc or me mf mg os mi mj jz ot ka ml kc ou kd mn kf ov kg mp mq bi translated">反应形式</h1><p id="8d7e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">同样的事情也适用于反应形式。嗯，差不多！</p><p id="7abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于反应式表单，父组件的模板如下:</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="657b" class="na ma it ly b be nb nc l nd ne">&lt;form [formGroup]="form"&gt;<br/>   &lt;app-personal&gt;&lt;/app-personal&gt;<br/>   &lt;app-address&gt;&lt;/app-address&gt;<br/>&lt;/form&gt;</span></pre><p id="8d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还必须在父组件类中实例化表单组。代码如下:</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="202e" class="na ma it ly b be nb nc l nd ne">@Component({<br/>  selector: 'app-parent-form',<br/>  templateUrl: './parent-form.component.html',<br/>  styleUrls: ['./parent-form.component.scss']<br/>})<br/>export class ParentFormComponent implements OnInit {<br/>  public form: FormGroup = new FormGroup({});<br/>  // ...<br/>}</span></pre><p id="2b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且<code class="fe lv lw lx ly b">personal</code>组件具有以下模板:</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="de14" class="na ma it ly b be nb nc l nd ne">&lt;div formGroupName="personal"&gt;<br/>  &lt;p&gt;Personal Information&lt;/p&gt;<br/>  &lt;app-required-field formControlName="first" placeholder="First name"&gt;<br/>  &lt;/app-required-field&gt;<br/>  &lt;app-required-field formControlName="last" placeholder="Last name"&gt;<br/>  &lt;/app-required-field&gt;<br/>  &lt;app-required-select<br/>    formControlName="gender"<br/>    placeholder="Select gender..."<br/>    [options]="genderOptions"<br/>  &gt;&lt;/app-required-select&gt;<br/>  &lt;ng-container *ngIf="parentForm.get('personal')?.get('gender')?.value === 'Other'"&gt;<br/>    &lt;app-required-field formControlName="genderOther" placeholder="Specify"&gt;<br/>    &lt;/app-required-field&gt;<br/>  &lt;/ng-container&gt;<br/>&lt;/div&gt;</span></pre><p id="53fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须再次提供缺失的<code class="fe lv lw lx ly b">ControlContainer</code>，除了因为我们使用了反应式表单，我们需要使用依赖注入链中现有的<code class="fe lv lw lx ly b">FormGroupDirective</code>。</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="408d" class="na ma it ly b be nb nc l nd ne">@Component({<br/>  selector: 'app-personal',<br/>  templateUrl: './personal.component.html',<br/>  styleUrls: ['./personal.component.scss'],<br/>  viewProviders: [{ provide: ControlContainer, useExisting: FormGroupDirective }]<br/>})<br/>export class PersonalComponent implements OnInit {<br/>  // ...<br/>}</span></pre><p id="75ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还没完呢！</p><p id="3aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应式表单注册指令，其工作是获取我们已经创建的现有表单组和表单控件，并将它们与DOM匹配。</p><p id="b14a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们没有在父表单中定义表单控件。</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="bd48" class="na ma it ly b be nb nc l nd ne">public form: FormGroup = new FormGroup({});</span></pre><p id="21db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没问题！我们可以在<code class="fe lv lw lx ly b">PersonalComponent</code>中这样做。我们可以注入<code class="fe lv lw lx ly b">FormGroupDirective</code>并在那里添加表单控件。</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="04ba" class="na ma it ly b be nb nc l nd ne">export class PersonalComponent implements OnInit, OnDestroy {<br/>  parentForm!: FormGroup;<br/>  constructor(<br/>    private parent: FormGroupDirective,<br/>    private fb: FormBuilder,<br/> ) { }<br/><br/>  ngOnInit(): void {<br/>    this.parentForm = this.parent.form;<br/>    this.parentForm.addControl(<br/>      'personal',<br/>      this.fb.group({<br/>        first: ['', Validators.required],<br/>        last: ['', Validators.required],<br/>        gender: ['', Validators.required],<br/>        genderOther: ['', Validators.required]<br/>      })<br/>    );<br/>    // ...<br/>  }<br/>}</span></pre><p id="5289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们完成了！😄</p><p id="008c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在下面的StackBlitz找到一个工作演示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="00b6" class="lz ma it bd mb mc or me mf mg os mi mj jz ot ka ml kc ou kd mn kf ov kg mp mq bi translated">结论</h1><p id="845f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在本文中，我们研究了嵌套表单的不同方式。我们讨论了它的主要优点和缺点，以及何时使用它。最后，我们演示并解释了两种表单模块的方法，即模板驱动表单和反应式表单。</p><p id="fa34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在AngularConnect 2017的<a class="ae ky" href="https://twitter.com/karaforthewin?lang=en" rel="noopener ugc nofollow" target="_blank"> Kara Erickson </a>精彩的<a class="ae ky" href="https://www.youtube.com/watch?v=CD_t3m2WMM8" rel="noopener ugc nofollow" target="_blank">演讲</a>中了解更多关于角形的知识。</p><p id="8ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章，并且你学到了一些新的东西。</p><p id="3a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="fd65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nf">供进一步阅读:</em> </strong></p><div class="ow ox gp gr oy oz"><a href="https://javascript.plainenglish.io/angular-zone-js-3b5e2347b7" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">关于Angular你应该知道的10件事</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">Zone.js是什么？如何有角度地使用它？本问答指南将回答这些问题以及更多问题。</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ks oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://javascript.plainenglish.io/angular-component-communication-81e5e02c6cbe" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">角分量通信:6种方式可供选择</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">了解Angular中数据共享和组件通信的6种不同方式。</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pi l"><div class="po l pk pl pm pi pn ks oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://javascript.plainenglish.io/creating-reusable-configurable-angular-components-b7fcba2f5f38" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">创建可重复使用和可配置的角度组件</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">使用NgTemplateOutlet和NgComponentOutlet指令创建可重复使用的角度组件。</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pi l"><div class="pp l pk pl pm pi pn ks oz"/></div></div></a></div></div></div>    
</body>
</html>