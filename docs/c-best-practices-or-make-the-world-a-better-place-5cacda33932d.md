# C++的 5 个编码最佳实践

> 原文：<https://betterprogramming.pub/c-best-practices-or-make-the-world-a-better-place-5cacda33932d>

## 让世界变得更美好

![](img/e61c69b8036a858068aabfce9170fbf8.png)

图片来自[皮克斯拜](https://pixabay.com/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=1127666)的罗尼·欧瓦特

我第一次尝到了用 C++进行高级编程的滋味。代码被编写、删除、再重写，战斗有输有赢，奇怪的 bug 让我在它们最终被修复之前的许多个夜晚都无法入睡。

我将向您讲述我的故事，以及您如何避免我在早期职业生涯中不得不处理的一些最烦人的错误。

# 目标受众

希望更好地理解这种语言的 C++程序员，或者具有其他语言经验、希望学习更多 C++知识的程序员。

# 我们将涵盖的内容

*   编译器警告
*   常数说明符
*   变量初始化
*   编译器自动生成的方法
*   覆盖说明符

# 编译器是你最好的朋友。不要忽视警告

一开始，编译器警告让我觉得:“感谢上帝，这不是一个错误，尽管它确实存在，但我的代码仍然可以编译。唷！”。

然后在经历了一些非常奇怪的 bug 之后，这些 bug 占用了我生命中最美好的几年，让我的头上多了几根白发，我意识到编译器警告是来帮助我的。在理想的情况下，你的编译过程应该包括一个将警告视为错误的标志，以确保你的代码没有错误。

记住:每一个警告都是程序员因为一个奇怪的错误而失去理智的结果。如果编译没有警告，下面描述的一些错误可以很容易地避免。

# Const 是你第二好的朋友。尽可能使用它

const 说明符起初看起来可能是多余的，因为…那么，它是做什么的呢？它只会鼓励编译器不给我二进制文件，因为我给一个非常数变量赋了一个常数值。对吗？

不对。随着项目的增长，const specifier 为您的代码提供文档和安全性。

我曾经不得不调试一些变量的奇怪状态。代码库很大，很难理解，我必须找出可能发生变化的地方。它是一个在整个代码库中作为非常数引用传递的对象。在大多数地方，它被用来阅读。实际上只有三个地方可能发生更新，其中一个是误发生的。那个错误就是 bug，花了两天时间才证明。

如果在代码中应用了常量说明符，两个问题就可以解决了:

1.  如果我的变量被编译器显式指定为只读，也就是 const，它就不会被更新。
2.  如果所有其他方法都有 const 说明符，我可能要花四分钟来跟踪 bug，但是我不得不浏览一半的代码库来验证问题只存在于那个方法中。

请花点时间阅读更多关于[的内容，在这里您可以应用 const 说明符。](https://www.geeksforgeeks.org/const-keyword-in-cpp/)

# 初始化你的变量

如果你来自一种不存在未初始化变量的语言，你应该注意这一点。

如果你不初始化你的变量，你仍然可以使用它们。其中一些将被[初始化为零](https://www.geeksforgeeks.org/g-fact-53/)，而其他的可能只是[包含该内存先前用于](https://www.geeksforgeeks.org/uninitialized-primitive-data-types-in-c-c/)的值。这意味着从未初始化的变量中读取会导致未定义的行为*。作为一名程序员，你绝不会希望这种情况发生在你的代码上，因为尽可能确定的代码是我们的目标。*

请养成在尽可能靠近你声明变量的地方初始化变量的习惯。如果可以，也行。

[2022 年 3 月 3 日更新:注意，初始化对所有变量都很重要，对类中的成员初始化也是如此。感谢 [**Rud Merriam**](https://rud-merriam.medium.com/) 的评论。]

# 编译器会自动生成并调用类方法。意识到它们

每次编译一个类时，编译器都会寻找一些最基本的过程所需要的方法。如果你没有声明这些方法，它会自动生成它们。你应该知道它实际上意味着什么。

编译器需要什么，它可能生成什么？

*   它需要一种方法来创建你的对象，所以如果你没有声明任何构造函数，它会生成一个默认的构造函数。
*   当然它也需要销毁你的对象，所以如果你没有声明一个析构函数，它也会为你生成一个析构函数。
*   另外，编译器可能需要复制你的对象，所以如果你还没有实现它们，它会生成一个复制构造函数和一个赋值操作符。

默认构造函数的实现就像您用默认值初始化了所有成员一样。[对于原始类型，基本上是未定义的行为](https://www.geeksforgeeks.org/uninitialized-primitive-data-types-in-c-c/)。对于用户定义的类型，将调用它们的默认构造函数。

生成的析构函数调用所有成员的析构函数，这意味着如果你已经动态分配了内存，并以原始形式保存在内存中，它不会被默认的析构函数删除，这意味着:祝贺你！你让自己的内存泄漏:)

复制构造函数和赋值操作符的实现就像你在每个成员上调用它们一样，这叫做[浅复制](https://www.geeksforgeeks.org/shallow-copy-and-deep-copy-in-c/)。换句话说，不会动态分配内存来创建新对象。如果你的一个成员是指针会怎么样？自动生成的副本只会创建一个指向原始内存地址的指针。想象一下，如果你改变了一个对象的值，却没有意识到你也改变了另一个对象的值，那该有多可怕。

【2022 年 3 月 3 日更新:编译器提供的另一个默认实现，是 [**move 构造函数**](https://en.cppreference.com/w/cpp/language/move_constructor) 和 move [**赋值运算符**](https://en.cppreference.com/w/cpp/language/move_assignment) 。它们的实现方式与复制构造函数和赋值操作符相同，只是它们通常会“窃取”被复制对象所拥有的资源。感谢 **Alexander Kushnir** 的评论。]

怎么做才能避免相关 bug？

*   确保你知道编译器在什么地方可以自己处理问题。
*   考虑显式定义这些方法或使用默认说明符来提高可读性。
*   使用 delete 说明符禁止自动生成不打算使用的方法。

例如，类“不可复制”使用删除说明符来禁止复制构造函数和赋值运算符的自动生成:

**个人建议:**您可以将这个类放在一个‘utils’库中，并在每次想要禁止复制一个类时从它继承:

[2022 年 3 月 3 日更新:如果你已经在你的程序中使用了 [boost](https://www.boost.org/) ，你可以使用它的[不可复制](https://www.boost.org/doc/libs/1_68_0/libs/core/doc/html/core/noncopyable.html)类实现，而不是自己实现它。感谢 Alexander Kushnir 的评论。]

# 总是在重写的方法上使用重写说明符

有一次我遇到了一个非常烦人的 bug，花了我一个星期才解决。我有一个基类和一个从它继承的类。为了好玩和原创，姑且称之为基础和衍生。他们的实现是这样的:

这段代码已经运行了很长时间，许多人都想知道这些类是谁，并将其称为 WhoAmI()。

过了一段时间，我们不得不增加“参数”可以为派生类支持的值的数量。一个程序员把它改成了 long 类型而不是 int 类型，但只是针对派生类，没有意识到这个方法是对基类方法的重写。

我不怪他们。这只能通过访问基类并主动检查是否有任何具有相同签名的方法来发现。

不管怎样，现在派生的代码看起来像这样:

但是等等！这样，派生类不会*覆盖*基 WhoAmI()，而不是*重载*它。

当使用 int 参数调用派生类的 WhoAmI()时，现在会发生什么？调用 Base::WhoAmI()。彻底的灾难！

这正是我们产品中大多数时候发生的事情，除了一个新的地方，程序员用一个长。

很难跟踪这种错误，尤其是如果您的方法不打印调用它的人，而是改变对象的状态。我花了将近一周的时间和大量的咖啡才弄明白这个问题。

**如何避免这种情况？**

有一个说明符可以帮你省去所有这些麻烦:**覆盖**。像这样在你的派生类中使用它:

在这种情况下，如果有一天您需要将参数的类型更改为 long，并且您没有更新基类，您的程序将无法编译，并且您可以省去这一周的搜索:

所以，请，请使用覆盖。真的很简单，省去了你以后很多麻烦。

我希望你会采用这些实践，并通过留下一个更无错误和易于维护的代码来使世界变得更好。

# 资源

*   Scott Meyers 的书:有效的 C++
*   我自己的痛苦经历:)