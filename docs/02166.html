<html>
<head>
<title>Building an End-to-End Encrypted Chatbot With Stream React Chat, Virgil Security, and Google Dialogflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Stream React Chat、Virgil Security和Google Dialogflow构建一个端到端的加密聊天机器人</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-an-end-to-end-encrypted-chatbot-with-stream-react-chat-virgil-security-and-google-c000bb585453?source=collection_archive---------11-----------------------#2019-11-11">https://betterprogramming.pub/building-an-end-to-end-encrypted-chatbot-with-stream-react-chat-virgil-security-and-google-c000bb585453?source=collection_archive---------11-----------------------#2019-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">安全是基本的互联网，对吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c34720bc30fe627e5d7393fa1f0dad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IXw0QNQgsiarjMUtoLfxkA.jpeg"/></div></div></figure><p id="2708" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着银行技术的进步，安全的实时通信对于任何现代银行应用都变得越来越重要。在保护客户隐私和数据的同时，提供客户期望的技术体验至关重要。</p><p id="e344" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将通过使用<a class="ae lq" href="https://getstream.io/chat/" rel="noopener ugc nofollow" target="_blank">流聊天</a>结合<a class="ae lq" href="https://dialogflow.com/" rel="noopener ugc nofollow" target="_blank">对话流</a>，使用<a class="ae lq" href="https://virgilsecurity.com/end-to-end-encrypted-chat" rel="noopener ugc nofollow" target="_blank">维吉尔安全</a>进行加密，来创建一个完整的端到端加密聊天机器人解决方案。</p><p id="01a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结合这些服务，开发人员可以创建现代聊天机器人体验，同时保持敏感信息的加密。</p><p id="c72e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该应用程序嵌入了Virgil Security的<a class="ae lq" href="https://github.com/VirgilSecurity/virgil-e3kit-js" rel="noopener ugc nofollow" target="_blank"> eThree Kit </a>和<a class="ae lq" href="https://github.com/GetStream/stream-chat-react" rel="noopener ugc nofollow" target="_blank"> Stream Chat React </a>的组件。React应用程序与后端通信，后端使用Stream的webhook集成和Dialogflow来响应用户。该应用程序的所有源代码都可以在<a class="ae lq" href="https://github.com/psylinse/stream-banking-chatbot" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="50ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Stream Chat、Virgil和Dialogflow可以轻松构建一个具有出色安全性和所有预期功能的解决方案。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c632" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么是端到端加密？</h1><p id="5498" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">端到端加密意味着他们只能读取两个人之间发送的消息。为此，消息在离开用户的设备之前被加密，并且只能由预定的接收者解密。</p><p id="3e12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Virgil Security是一家供应商，它将使我们能够通过公钥/私钥技术创建端到端加密。Virgil提供了一个平台和JavaScript SDK，使我们能够创建、存储和提供强大的端到端安全加密。</p><p id="033a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将创建一个流聊天应用程序，该应用程序使用Virgil的加密来防止除预定方之外的任何人阅读消息。</p><p id="16c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您公司中的任何人，或者您使用的任何云提供商，都无法阅读这些消息。即使一个恶意的人获得了包含消息的数据库的访问权，他们所看到的也只是加密的文本，称为密文。</p><p id="0012" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了构建这个应用程序，我们将依赖几个库:</p><ul class=""><li id="a57c" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><a class="ae lq" href="https://www.npmjs.com/package/stream-chat-react" rel="noopener ugc nofollow" target="_blank">流反应聊天</a></li><li id="fd9e" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><a class="ae lq" href="https://www.npmjs.com/package/virgil-sdk" rel="noopener ugc nofollow" target="_blank">维吉尔SDK </a></li><li id="1aa9" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><a class="ae lq" href="https://www.npmjs.com/package/virgil-crypto" rel="noopener ugc nofollow" target="_blank">维吉尔加密</a></li><li id="abe2" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><a class="ae lq" href="https://github.com/googleapis/nodejs-dialogflow" rel="noopener ugc nofollow" target="_blank">谷歌对话流</a></li></ul><p id="1f86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的最终产品将在发送消息到流聊天之前在浏览器中加密文本。加密的消息将通过Stream的webhooks转发到我们的后端。</p><p id="4c9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在传递给Dialogflow进行解释之前，解密和验证将在后端进行。一旦确定了<a class="ae lq" href="https://cloud.google.com/dialogflow/docs/intents-overview" rel="noopener ugc nofollow" target="_blank">意图</a>，后端就会执行任何必要的动作，加密响应，并通过流通道进行转发。</p><p id="dada" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的聊天机器人将有三个用户可以执行的意图，在我们不明白说什么的情况下有一个后备。这些是问候，检查余额，并转移帐户之间的钱。</p><p id="35fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们完成了，我们将有一个聊天机器人能够做到这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/c988d8b58eed946a4654662f890aeddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IWNa3RtdbSE1WZUr"/></div></div></figure><p id="8938" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，应用程序执行以下过程:</p><ul class=""><li id="5dc0" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">用户通过您的后端进行身份验证。</li><li id="3df3" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户的应用程序从后端请求流身份验证令牌和API密钥。浏览器为该用户创建一个<a class="ae lq" href="https://getstream.io/chat/docs/#init_and_users" rel="noopener ugc nofollow" target="_blank">流聊天客户端</a>。</li><li id="8008" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户的应用程序从后端请求一个Virgil身份验证令牌，并向Virgil注册。这将生成他们的私钥和公钥。私钥存储在本地，公钥存储在Virgil中。</li><li id="d3c6" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户通过聊天机器人加入<a class="ae lq" href="https://getstream.io/chat/docs/#initialize_channel" rel="noopener ugc nofollow" target="_blank">流聊天频道</a>。</li><li id="0c24" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">浏览器应用向Virgil索要chatbot的公钥。</li><li id="e7d9" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户键入一条消息并将其发送到stream。在发送之前，该应用程序将聊天机器人的公钥传递给维吉尔，以加密消息。消息通过流聊天经由webhook中继到后端。流接收密文，这意味着他们永远看不到原始消息。</li><li id="752f" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">当后端收到消息时，应用程序使用Virgil解密消息。Virgil使用发送者的公钥验证消息的真实性。</li><li id="ce1c" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">后端将解密后的文本传递给Dialogflow，以确定用户的意图。Dialogflow返回一个结果，其中包含后端决定如何响应所必需的信息。</li><li id="1bd9" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">后端接收Dialogflow响应，决定要采取的操作，并创建响应文本。</li><li id="cbb8" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">使用Virgil，后端加密响应文本，并通过流聊天通道响应用户。客户端解密消息。</li></ul><p id="481d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这看起来令人生畏，但幸运的是，Stream、Virgil和Dialogflow为我们做了繁重的工作。作为使用这些服务的开发人员，我们的责任是正确地将它们连接在一起。</p><p id="c427" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码在包含在<code class="fe nk nl nm nn b">frontend</code>文件夹中的React前端和位于<code class="fe nk nl nm nn b">backend</code>文件夹中的Express (Node.js)后端之间拆分。</p><p id="aad7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看每个文件夹中的<code class="fe nk nl nm nn b">README.md</code>，查看安装和运行说明。如果您想继续运行代码，请确保在继续之前让<code class="fe nk nl nm nn b">backend</code>和<code class="fe nk nl nm nn b">frontend</code>都运行起来。</p><p id="f73e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们浏览一下，看看每个步骤所需的必要代码。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="cec7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">先决条件</h1><p id="564d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">遵循本教程需要React和Node.js的基础知识。此代码旨在在您的计算机上本地运行。</p><p id="f020" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你将需要一个与<a class="ae lq" href="https://getstream.io/accounts/signup/" rel="noopener ugc nofollow" target="_blank">流</a>、<a class="ae lq" href="https://dashboard.virgilsecurity.com/signup" rel="noopener ugc nofollow" target="_blank">维吉尔</a>和<a class="ae lq" href="https://dialogflow.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌对话流</a>的帐户。</p><p id="b9fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Dialogflow有点棘手，所以请遵循他们的<a class="ae lq" href="https://github.com/googleapis/nodejs-dialogflow" rel="noopener ugc nofollow" target="_blank"> Node.js库</a>和<a class="ae lq" href="https://cloud.google.com/docs/authentication/getting-started" rel="noopener ugc nofollow" target="_blank">如何使用Google的云API</a>进行认证中的说明。</p><p id="4a6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建帐户后，将凭证放入<code class="fe nk nl nm nn b">backend/.env</code>。您可以使用<code class="fe nk nl nm nn b">backend/.env.example</code>作为需要凭据的证明人。</p><p id="bea6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程使用以下软件包版本:</p><ul class=""><li id="1a4f" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">节点11.14.0</li><li id="d15c" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">纱线1.17.0</li><li id="9180" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">流聊天0.13.3</li><li id="47ee" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">流聊天反应0.6.26</li><li id="f11a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">维吉尔加密3.2.0</li><li id="9b62" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">Virgil SDK 5.3.0</li><li id="6b55" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">Virgil e3Kit 0.5.3</li><li id="e36b" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">对话流0.12.2</li><li id="7fd8" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">快递4.17.1</li></ul><p id="3e22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了<code class="fe nk nl nm nn b">node</code>和<code class="fe nk nl nm nn b">yarn</code>之外，所有这些依赖项都在<code class="fe nk nl nm nn b">backend/package.json</code>和<code class="fe nk nl nm nn b">frontend/package.json</code>中声明。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="007b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤1.1:设置对话流</h1><p id="9486" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了让我们的聊天机器人正确响应，我们需要在我们的对话流中设置几个<a class="ae lq" href="https://cloud.google.com/dialogflow/docs/intents-overview" rel="noopener ugc nofollow" target="_blank">意图</a>和一个<a class="ae lq" href="https://cloud.google.com/dialogflow/docs/entities-overview" rel="noopener ugc nofollow" target="_blank">实体</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/92448c6b674740b3281a2a5159b9dc94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3xhT5xrFeh8AEAwm"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/58b896ba437369d55fe81d49f6c31bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E26mYllktLKcvRPF"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/bee80e4d2cdd8ad5757f41fd8173ff89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7kU22at0ws7lis-J"/></div></div></figure><p id="218b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果设置正确，您应该在Dialogflow控制台中看到这四个意图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/3b304653d0e3cdbe9cdb34674ef27cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eMWsH3stLrfsygPH"/></div></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c7db" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤1.2设置流网络挂钩</h1><p id="1ba3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了监控和回复用户的聊天信息，我们需要通过<a class="ae lq" href="https://getstream.io/chat/docs/js/#webhooks" rel="noopener ugc nofollow" target="_blank"> webhooks </a>连接到Stream。</p><p id="f9e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从您的Stream dashboard中，导航至<em class="np">聊天</em>-&gt;-聊天概述<em class="np">并查找<em class="np">聊天事件</em>部分。将webhook切换到<em class="np">活动状态</em>，并添加您的服务器的URL。</em></p><p id="1804" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于本地开发，您可以使用类似于<a class="ae lq" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>的服务来使您的本地主机在线可路由。我们将使用的路径是<code class="fe nk nl nm nn b">/v1/message</code>来处理所有的流事件。</p><p id="937f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了方便起见，我们将关闭授权/许可检查。在生产环境中，确保不要绕过这些，并实现必要的代码来保护您的流帐户。</p><p id="a1cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你的webhook应该是这样的，带有你的ngrok，或者其他的URL，而不是ngrok URL。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/3b4a284c639d42f89b60de49c31c6dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WfmJ-iorLPr0G8gF"/></div></div></figure><p id="b809" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在步骤9中查看<code class="fe nk nl nm nn b">/v1/message</code>的实现。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6a47" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤2:设置后端以允许用户获取凭证</h1><p id="2dff" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了让React前端与Stream和Virgil交互，应用程序提供了三个端点:</p><ul class=""><li id="b489" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><code class="fe nk nl nm nn b">POST /v1/authenticate</code>:这个端点生成一个auth令牌，允许React前端与<code class="fe nk nl nm nn b">/v1/stream-credentials</code>和<code class="fe nk nl nm nn b">/v1/virgil-credentials</code>通信。为了简单起见，这个端点允许客户机是任何用户。前端告诉后端它想要认证为谁。在您的应用程序中，这应该替换为您的API的身份验证端点。</li><li id="b05a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe nk nl nm nn b">POST /v1/stream-credentials</code>:返回React应用程序与Stream建立会话所需的数据。为了返回这个信息，我们需要告诉Stream这个用户的存在，并要求他们创建一个有效的auth令牌:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="52ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">响应负载的形状如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="73cf" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><code class="fe nk nl nm nn b">apiKey</code>:您的流实例的流帐户标识符。需要确定您的前端正在尝试连接哪个帐户。</li><li id="fd46" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe nk nl nm nn b">token</code> : JWT令牌，对前端进行流授权。</li><li id="9890" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe nk nl nm nn b">user</code>:这个对象包含前端需要连接和渲染用户视图的数据。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="139f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，前端只需要auth令牌。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="786c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤3:用户通过后端进行身份验证</h1><p id="4338" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">既然我们已经设置并运行了后端，那么是时候对后端进行身份验证了。如果您正在运行该应用程序，您将看到如下屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/34885f1ca9ce5fc1641941d0a6ea2df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IQg-WU-kLI_hPMaQ"/></div></div></figure><p id="46ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个纯React表单，它接受所提供的输入，将其存储在状态中作为<code class="fe nk nl nm nn b">sender</code>，并使用该信息对后端进行身份验证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2bdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们用auth令牌创建了发送者身份，我们就可以连接到Stream和Virgil。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="da69" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤4:用户连接到流</h1><p id="c89a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">使用步骤3中的凭证，我们可以从后端请求流凭证。使用这些，我们将前端客户端连接到流:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f704" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将从<code class="fe nk nl nm nn b">Stream Chat React</code>库中初始化<code class="fe nk nl nm nn b">StreamChat</code>对象，并使用后端生成的令牌对用户进行身份验证。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="eebe" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤5:用户连接到Virgil</h1><p id="dc48" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">同样，使用在步骤3中获得的凭证，我们要求后端生成一个Virgil auth令牌。使用这个令牌，我们从维吉尔的<code class="fe nk nl nm nn b">e3kit</code>库中初始化<code class="fe nk nl nm nn b">EThree</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="32ca" class="ly lz it bd ma mb nu md me mf nv mh mi jz nw ka mk kc nx kd mm kf ny kg mo mp bi translated">步骤6:创建流聊天频道</h1><p id="d932" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一旦我们连接到Stream和Virgil，我们就可以开始和我们的聊天机器人聊天了。为此，客户端在它们和聊天机器人之间创建了一个通道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a761" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在状态中访问的客户机是在步骤4中创建的客户机。呼叫<code class="fe nk nl nm nn b">.channel</code>将根据会员的身份创建或加入一个独特的频道。只有用户和聊天机器人被允许进入。</p><p id="e2ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这不足以保护Stream或其他人查看这些用户的消息。接下来，我们将使用维吉尔加密信息。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="bddf" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤7:查找Virgil公钥</h1><p id="f2a7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要在通过流通道发送消息之前对其进行加密，我们需要查找接收方的公钥:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="da5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们状态中的<code class="fe nk nl nm nn b">eThree</code>实例来自步骤5。假设发送者的身份是<code class="fe nk nl nm nn b">will</code>，这将返回一个类似如下的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="46a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为为了显示和方便起见，我们需要解密收到的消息，所以我们同时要求两个公钥。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="17df" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤8:发送方加密消息并通过流发送</h1><p id="9f39" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们拥有通过Stream发送安全的端到端加密消息所需的一切。该聊天了！首先，我们需要向用户展示聊天室:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="cc4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这呈现了Stream React聊天组件，为我们的用户创建了出色的开箱即用体验。如果你继续看下去，你会看到这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/effe0e288acb967bba181242a2599b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mtt5IRSDQlfMZMAS"/></div></div></figure><p id="5c0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意我们包含自定义类<code class="fe nk nl nm nn b">MessageInputEncrypted</code>的那一行。</p><p id="4a42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该组件使用来自Virgil的发送者公钥来加密，然后在通过流通道发送消息之前包装流React <code class="fe nk nl nm nn b">MessageInput</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c093" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在所有流将看到的是密文！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b4ad" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤9:后端从Stream接收一个Webhook，将其发送给Dialogflow，并作出响应</h1><p id="eccd" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在，我们可以在后端对发件人的消息做出反应，通过Dialogflow找出用户的意图，执行操作(如果有的话)，并做出响应。</p><p id="cc33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于Stream会向我们发送为我们的帐户发生的每个事件，我们需要首先决定是否应该采取行动。我们只想在有来自任何用户的<code class="fe nk nl nm nn b">message.new</code>事件时做一些事情，除了<code class="fe nk nl nm nn b">chatbot</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a9ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们确定这是一条需要回复的消息，我们需要解密消息，解释它，决定如何回复，加密回复，并通过聊天频道发送。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1d9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解释消息，我们使用步骤1.1中配置的Dialogflow设置。我们解密用户的消息，并将解密的消息发送到Dialogflow:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3f16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们理解了信息，我们就可以决定如何回应和采取什么行动。</p><p id="1b51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个简单的应用程序中，我们有两个我们关心的显式操作，“检查账户”和“转账”。否则，我们退回到Dialogflow中配置的<code class="fe nk nl nm nn b">fullfillmentText</code>。</p><p id="d6b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这要么来自<code class="fe nk nl nm nn b">Default Welcome Intent</code>要么来自<code class="fe nk nl nm nn b">Default Fallback Intent</code>的意图。</p><p id="f3e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在“检查帐户”的情况下，我们查找用户的帐户余额并作出响应。对于“转账”，我们确定方向，执行余额转账，然后响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="640a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">服务器到此为止。即使在这个受限的示例中，您也可以看到Stream、Virgil和Dialogflow在构建安全聊天机器人时所提供的强大功能。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="578a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤10:在客户端解密响应消息</h1><p id="ea9b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">最后，我们可以展示服务器。为了解密消息，我们遵循与步骤8相似的模式。如果你看看我们是如何创建<code class="fe nk nl nm nn b">MessageList</code>的，你会看到一个名为<code class="fe nk nl nm nn b">MessageEncrypted</code>的定制<code class="fe nk nl nm nn b">Message</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7c03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们需要提供解密道具来向我们的自定义<code class="fe nk nl nm nn b">Message</code>组件添加用于解密的道具，所以我们将它们添加到Stream React传递的道具中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4acd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们有了我们需要的道具，我们就可以解密每条信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f4ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个类在呈现来自流聊天反应的<code class="fe nk nl nm nn b">MessageSimple</code>组件之前解密消息。</p><p id="169e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们首先使用Stream的<code class="fe nk nl nm nn b">.isMyMessage</code>确定该消息是否是我们的消息。然后我们找到正确的公钥，并要求维吉尔解密。</p><p id="11dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦完成，我们就可以将密钥和其余的道具一起传递给流的<code class="fe nk nl nm nn b">MessageSimple</code>组件。</p><p id="b870" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b">_isMounted</code>标志防止在消息被解密后更新组件。如果你滚动得很快，或者页面加载时有很多消息，就会发生这种情况。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5db0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">下一步是什么</h1><p id="5267" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">本教程旨在让您尽快上手并运行。因此，您的应用程序可能会缺少一些关键功能。以下是关于如何使用你的应用程序的一些提示。</p><ul class=""><li id="e9eb" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">配置更深入的聊天机器人体验。Dialogflow有大量的功能，例如<a class="ae lq" href="https://cloud.google.com/dialogflow/docs/contexts-overview" rel="noopener ugc nofollow" target="_blank"> context </a>，可以构建健壮的聊天机器人体验。</li><li id="6ac8" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">建立真实用户注册，保护身份注册。本教程简化了注册和检索有效令牌，以便与Stream和Virgil进行交互。</li><li id="cfbd" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">备份用户的私钥以恢复会话并用于多台设备。使用维吉尔的<code class="fe nk nl nm nn b">eThree.backupPrivateKey(pwd)</code>将安全地存储私钥，以便在任何设备上恢复。</li></ul></div></div>    
</body>
</html>