<html>
<head>
<title>How To Return a Response From Asynchronous Calls in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中从异步调用返回响应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-return-a-response-from-asynchronous-calls-in-javascript-d20e6f49651b?source=collection_archive---------13-----------------------#2021-01-25">https://betterprogramming.pub/how-to-return-a-response-from-asynchronous-calls-in-javascript-d20e6f49651b?source=collection_archive---------13-----------------------#2021-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0025" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在异步函数中利用承诺</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b10704a671422195e2515a7c80f8c1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vefjR5BCu0A-cnWg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@angeloabear?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安杰洛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的Abear </a>拍摄。</p></figure><p id="1f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不熟悉异步编程的人通常会对以下情况感到困惑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="cd7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个例子展示了AJAX调用的一个特定用例，但它代表了一个更一般的模式:同步返回异步函数的结果。虽然在JavaScript中将异步调用转换成同步调用是不可能的，但是我将向您展示如何在不破坏异步编程背后的思想的情况下解决您的问题。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1547" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">异步函数的类型</h1><p id="e570" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在我们下结论之前，我们应该快速看一下最常见的异步函数类型。它们的不同之处在于它们提供异步收集的值的方式(或者仅仅是它们如何完成它们应该做的事情)。有三种突出的方法可以做到这一点:</p><h2 id="f0b6" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">1.复试</h2><p id="fa4b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">一个函数可能会将回调函数作为参数，并在完成时用要求的值调用这个函数。这方面的一个例子是前面显示的<code class="fe nn no np nq b">ajaxCall</code>函数，它将回调函数作为其第一个参数。每当<code class="fe nn no np nq b">ajaxCall</code>完成它的HTTP请求时，这个回调函数就会被调用。此外，回调函数将请求的结果作为其第一个参数。这就是你获得价值的方式。</p><h2 id="a940" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">2.承诺</h2><p id="a1f3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">ECMAScript 6 (ES2015)带来了承诺。承诺是从异步函数立即(同步)返回的对象，使您能够跟踪该函数的状态。承诺可以处于以下状态之一:</p><ul class=""><li id="0f06" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe nn no np nq b">pending</code>:(初始)既不履行也不拒绝</li><li id="04d2" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nn no np nq b">fulfilled</code>:操作成功完成。</li><li id="22e1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nn no np nq b">rejected</code>:操作失败。</li></ul><p id="2d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">承诺值得拥有自己的文章。所以如果你想了解更多，可以查看一下<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Promise API </a>。</p><h2 id="77d3" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">3.异步/等待</h2><p id="41d3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated"><code class="fe nn no np nq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">async/await</a></code>是Promise API的语法糖。它更容易阅读，看起来更同步。您可以通过使用它来防止长的和嵌套的承诺链。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="408a" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">返回结果</h1><p id="33e8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我答应告诉你如何解决图示的问题。最干净的解决方法是返回一个承诺，而不是直接的结果。这将使函数的调用者能够在结果到达时立即处理它。我们将在这里使用<code class="fe nn no np nq b">async/await</code>。</p><p id="f288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说试镜。我们将再次查看我们示例的修改版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了什么事？我们正在回报一个承诺。如上所述，这是一个立即返回的对象，可用于跟踪异步调用的状态。每当我们调用<code class="fe nn no np nq b">resolve</code>函数时，我们发出异步调用已经完成的信号(承诺已经<em class="of">解决</em>)。我们在这里不处理错误的情况。然而，要指出错误，只需调用<code class="fe nn no np nq b">reject</code>函数即可。<code class="fe nn no np nq b">async/await</code>语法是处理承诺的一种简洁方式。如你所见，我们可以简单地<code class="fe nn no np nq b">await</code>由<code class="fe nn no np nq b">myFunction</code>返回的承诺。这读起来几乎像同步代码。</p><p id="6197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一点需要考虑:你只能在声明为<code class="fe nn no np nq b">async</code>的函数中使用<code class="fe nn no np nq b">await</code>。因此，如果你在程序的全局执行上下文中，你需要将你的代码包装成一个异步的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">生命</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="4674" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">承诺呢？</h2><p id="c850" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">如果你的异步函数已经使用了承诺，那只会变得更容易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<code class="fe nn no np nq b">async</code>函数只是一个返回承诺的函数。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="a448" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="a638" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">不可能真正将异步函数转换成同步函数。然而，你不需要。使用<code class="fe nn no np nq b">async/await</code>，你可以用一种读起来几乎像同步代码的方式组织你的代码，并且你不会失去异步代码提供的灵活性。</p><p id="64e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您发现自己处于想要始终同步您的异步代码的情况，我建议您更熟悉异步编程的概念，因为您可能没有最佳地使用它。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="f3d6" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">参考</h1><ul class=""><li id="accf" class="nr ns it lb b lc mw lf mx li og lm oh lq oi lu nw nx ny nz bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Promise</a></li><li id="ad9a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/async _ function</a></li></ul></div></div>    
</body>
</html>