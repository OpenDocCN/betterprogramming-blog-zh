<html>
<head>
<title>Modularize an iOS App With SPM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SPM模块化iOS应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modularize-an-ios-app-with-spm-c3f51f03bb0b?source=collection_archive---------2-----------------------#2021-06-21">https://betterprogramming.pub/modularize-an-ios-app-with-spm-c3f51f03bb0b?source=collection_archive---------2-----------------------#2021-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3716" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Swift Package Manager为您的应用程序定义模块</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d19192f27f22f778779582d2890887a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KHKHHUHOeJCsl0kp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@raagesh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Raagesh C </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到2018年，WWDC期间，苹果公布了<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2018/411/" rel="noopener ugc nofollow" target="_blank"> Swift包管理器</a> (SPM或SwiftPM)。SPM的目标是允许开发人员定义可以跨不同应用程序和平台重用的模块。举例来说，一个软件包可以被定义为既适用于iOS又适用于macOS，因此它的特性可以在这些平台上的工具和应用程序之间共享。</p><p id="1452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一开始，包管理器非常有限:例如，它不支持特定于模块的资源。在接下来的几年里，SPM有了很大的改进。它现在允许开发者定义<a class="ae ky" href="https://github.com/apple/swift-package-manager/blob/main/Documentation/Usage.md#creating-an-executable-package" rel="noopener ugc nofollow" target="_blank">可执行文件</a>而不是包和库。它支持<a class="ae ky" href="https://github.com/apple/swift-package-manager/blob/main/Documentation/Resources.md" rel="noopener ugc nofollow" target="_blank">资源</a>以便我们可以，例如，直接在UI模块中添加图像并重用它们。最近，它还替换了Xcodeproj文件:Xcode现在能够从<code class="fe lv lw lx ly b">Package.swift</code>定义开始动态创建项目了！</p><p id="cb77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它仍然有一些限制:例如，它不能自动处理iOS应用程序。然而，有一种方法可以让它工作，今天我想和你一起探索如何用SPM创建一个模块化的iOS应用程序。</p><h1 id="880a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">开始</h1><p id="58ac" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">使用SPM创建模块化应用程序的第一步是为项目创建一个文件夹。打开终端并运行以下命令:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="22ea" class="na ma it ly b gy nb nc l nd ne">mkdir SPMApp<br/>cd SPMApp<br/>mkdir SPMAppKit<br/>cd SPMAppKit<br/>swift package init --name SPMAppKit</span></pre><p id="0e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些命令创建了一个名为<code class="fe lv lw lx ly b">SPMApp</code>的文件夹和另一个名为<code class="fe lv lw lx ly b"> SPMAppKit</code>的文件夹，并将我们移入其中。我们需要这个嵌套来保持项目的整洁。在本文的后面，我们将为iOS应用程序创建一个文件夹，因为SPM不允许直接创建iOS应用程序。整个应用程序代码将留在<code class="fe lv lw lx ly b">SPMAppKit</code>包中；<code class="fe lv lw lx ly b">SPMApp</code>将作为包裹的容器。最后，通过最后一个命令，它创建了一个名为<code class="fe lv lw lx ly b">SPMAppKit</code>的包。</p><p id="3c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ff78a24f63768e2ddaa4e11a11412bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HsFepzdkns3eEWZFb1vfA.png"/></div></div></figure><p id="13b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SPM正在创建<code class="fe lv lw lx ly b">Package.swift</code>文件，这是我们的项目定义文件。然后它创建一个标准的<code class="fe lv lw lx ly b">README.md</code>,只包含一个标题、一个默认描述和一个预定义的<code class="fe lv lw lx ly b">.gitignore</code>,这样我们就可以立即将项目添加到Git存储库中。</p><p id="e12d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更有趣的是，它为我们的代码创建了一个默认的文件夹结构。它创建了一个名为<code class="fe lv lw lx ly b">SPMAppKit</code>的主模块，在<code class="fe lv lw lx ly b">Sources</code>文件夹中包含了它的所有源代码，还创建了一个名为<code class="fe lv lw lx ly b">SPMAppKitTests</code>的测试模块，在<code class="fe lv lw lx ly b">Tests</code>文件夹下包含了一个单元测试的模板。</p><p id="574a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们键入以下内容，Xcode应该会打开我们的项目:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="87a4" class="na ma it ly b gy nb nc l nd ne">open Package.swift</span></pre><p id="2205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在项目导航器中，您应该可以看到我上面描述的结构。看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/15c6c9ebcab881276adc44616e9df012.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*YfeZcPyHv5Lj7XLAEPf3tA.png"/></div></figure><h2 id="35b7" class="na ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated">检查包裹</h2><p id="a35c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们的目标是创建一个iOS应用程序，但SPM目前不支持。这就是为什么我们称我们的包为<code class="fe lv lw lx ly b">SPMAppKit</code>:它生成一个包含应用程序所需的一切的库，但它不能是应用程序。</p><p id="6931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了用SPM创建我们需要的所有模块，我们需要修改我们的<code class="fe lv lw lx ly b">Package.swift</code>文件。初始文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="878e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件结构非常简单。它指定了包的名称和产生的内容:一个名为<code class="fe lv lw lx ly b">SPMAppKit</code>的库，它依赖于一个同名的目标。然后是外部依赖列表，目前是空列表。最后，它定义了我们项目的当前目标树(模块<code class="fe lv lw lx ly b">SPMAppKit</code>和相应的测试模块)。</p><p id="bbcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个目标都可能依赖于其他目标或外部依赖性。例如，<code class="fe lv lw lx ly b">SPMAppTests</code>需要访问<code class="fe lv lw lx ly b">SMPApp</code>模块来运行测试，因此它依赖于那个模块。</p><p id="93a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有定义<code class="fe lv lw lx ly b">platforms</code>属性。SPM假设我们需要一个没有版本限制的多平台库。这暂时没问题:如果我们需要添加它们，我们可以随时定制<code class="fe lv lw lx ly b">Package.swift</code>文件。</p><p id="f12f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以从目标列表中选择一部iPhone，如下图所示，然后按<code class="fe lv lw lx ly b">⌘ + b</code>来构建目标。通过按下<code class="fe lv lw lx ly b">⌘ + u</code>，我们可以在模拟器上构建并运行测试。</p><h1 id="5e12" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">将包链接到应用程序</h1><p id="32aa" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这一步可能会延迟到开发过程的最后。然而，我们都希望确保我们在朝着正确的方向努力。</p><p id="3bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个完美的时刻，让我们看看如何创建一个iOS应用程序并访问新创建的包。</p><h2 id="706b" class="na ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated">创建Xcode应用程序</h2><p id="2362" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">作为第一步，让我们创建一个新的iOS应用程序。让我们从Xcode开始:</p><ol class=""><li id="1a6a" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">按<code class="fe lv lw lx ly b">⌘ + ⇧ + N</code>创建一个新项目。</li><li id="d376" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">从顶部的选项卡中选择<code class="fe lv lw lx ly b">iOS</code>，从预定义的模板中选择<code class="fe lv lw lx ly b">App</code>。</li><li id="e1e5" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">将我们的应用命名为<code class="fe lv lw lx ly b">SPMApp</code>，使用<code class="fe lv lw lx ly b">SwiftUI</code>作为界面。</li><li id="9383" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">将我们的应用程序保存在我们之前创建的<code class="fe lv lw lx ly b">SPMApp</code>文件夹中。</li></ol><p id="8e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode为我们创建了一个可以运行的项目。结构大概是这样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/831d6cd7bc79f35c0487365b69d2b163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*KHlyYksS3zI2bT5hkKML_w.png"/></div></figure><h2 id="2578" class="na ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated">为包创建Git repo</h2><p id="a8a5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在是将包链接到应用程序的时候了。SPM生来就与<code class="fe lv lw lx ly b">git</code>一起工作，以便能够获取软件包的正确版本。SPM也支持本地存储库:没有必要仅仅为了测试而在线托管一个未完成的包。</p><p id="bb16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再次打开终端并导航到<code class="fe lv lw lx ly b">SPMAppKit</code>文件夹。在那里，我们可以运行以下命令:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="fa50" class="na ma it ly b gy nb nc l nd ne">git init<br/>git add .<br/>git commit -m "initial commit"</span></pre><p id="c7ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些命令创建一个空的Git存储库，跟踪文件夹中的所有文件(记住SPM还为我们创建了一个默认的<code class="fe lv lw lx ly b">.gitignore</code>！)并提交存储库中的工作。</p><h2 id="b028" class="na ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated">在应用程序中导入包</h2><p id="b42e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们现在可以切换回我们的iOS应用程序。我们可以利用IDE与SPM的集成来向我们的项目添加一个包。为此，我们可以点击文件&gt; Swift软件包&gt;添加软件包依赖性...菜单，然后按照提示进行操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/cc7568c900e385973d74b8e78610a7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvCjcsZKBHG12EqqGPCPWQ.png"/></div></div></figure><p id="e4f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该选项会弹出一个对话框，要求输入URL。诀窍是使用我们的包的完全限定的URL。我们可以通过在终端中运行<code class="fe lv lw lx ly b">pwd</code>命令并在前面加上<code class="fe lv lw lx ly b">file://</code>方案来实现。</p><p id="0e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在我的例子中，当我运行<code class="fe lv lw lx ly b">pwd</code>时，我得到:</p><p id="8658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">/Users/riccardocipolleschi/Documents/Personal2/SPMApp/SPMAppKit</code></p><p id="c4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本地包的正确URL是<code class="fe lv lw lx ly b">file:///Users/riccardocipolleschi/Documents/Personal2/SPMApp/SPMAppKit</code></p><p id="c37a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们在<code class="fe lv lw lx ly b">repository</code>文本字段中插入这个URL，下一步按钮就变成可点击的了。让我们点击它，出现在这个屏幕上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/41d1e67bf40522181674d36c19846e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRItN1UavdmZfyEc9MK-wQ.png"/></div></div></figure><p id="fa40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还没有发布我们的包，因此我们不能遵循第一条规则:还没有可用的版本。我们可以选择第二个规则，指定我们正在处理的当前分支。在我的例子中，它仍然是<code class="fe lv lw lx ly b">main</code>，所以我可以在分支名称的文本字段中保留默认值。</p><p id="b0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击Next，我们将看到最后一个屏幕，屏幕上会询问我们要将包的产品添加到哪个目标。我们可以保留默认值，然后单击Finish。</p><p id="ddd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在应用程序可以使用我们正在开发的包了！例如，如果我们打开<code class="fe lv lw lx ly b">SPMAppApp.swift</code>文件，我们可以输入<code class="fe lv lw lx ly b">import SPMAppKit</code>,应用程序应该可以完美构建。</p><p id="ffc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新项目现在看起来像这样。Swift Package Dependencies部分包含由我们的应用程序导入的所有包的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/4b5d2b0525fe3a8577b3ee7ec910bb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*RZb3uen9J-i1bwMfAaWBNQ.png"/></div></figure><h1 id="7879" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">向SPMAppKit添加新模块</h1><p id="632c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们回顾一下目前的情况。我们有:</p><ul class=""><li id="a5bd" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu om oa ob oc bi translated">SPM包</li><li id="b4e2" class="nu nv it lb b lc od lf oe li of lm og lq oh lu om oa ob oc bi translated">一款iOS应用</li></ul><p id="9338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且app是和套餐挂钩的，可以使用。</p><p id="0948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们研究包中的代码，它没有<code class="fe lv lw lx ly b">public</code>成员:应用程序可以访问模块，但是没有它可以使用的实体。</p><p id="bec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过使用SwiftUI添加一个<code class="fe lv lw lx ly b">AppSetupView.swift</code>来解决这个问题。一个<code class="fe lv lw lx ly b">AppSetupView</code>是一个视图，当应用程序启动它需要的所有资源时，它作为第一个视图被加载到应用程序中。</p><p id="c140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于这是一个UI，具有非常具体的语义和职责，我们希望在一个单独的模块中创建它。为此，我们可以修改<code class="fe lv lw lx ly b">Package.swift</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="69fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有两个重要的变化:</p><ol class=""><li id="2882" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated"><code class="fe lv lw lx ly b">product</code>现在导出另一个目标，即<code class="fe lv lw lx ly b">AppSetupView</code>。</li><li id="8d95" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">我们在第28行定义了一个新的目标，它的名字是<code class="fe lv lw lx ly b">AppSetupView</code>，并且有一个指向<code class="fe lv lw lx ly b">AppSetupView</code>文件夹的相对路径。</li></ol><p id="4abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢<code class="fe lv lw lx ly b">path</code>属性，我们可以在磁盘和项目中保持一个整洁的文件夹结构。然而，SPM现在正在通过Xcode进行投诉。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/7c70a2b7f2bcedc5c5504758838875e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jjTRJ7UBei2FWIy9PEcvA.png"/></div></div></figure><p id="de7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在定义文件中定义了一个新的模块，但是Xcode找不到对应的文件和文件夹。要解决这个问题，让我们创建它们。让我们从<code class="fe lv lw lx ly b">SPMAppKit</code>文件夹中运行以下命令:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="80d2" class="na ma it ly b gy nb nc l nd ne">mkdir AppSetupView<br/>cd AppSetupView<br/>touch AppSetupView.swift</span></pre><p id="9780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个新文件夹，它位于<code class="fe lv lw lx ly b">Package.swift</code>文件中指定的同一路径。它将我们移入其中，并创建一个名为<code class="fe lv lw lx ly b">AppSetupView.swift</code>的新的空文件。</p><p id="c96f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在检查Xcode，错误应该会得到解决，新文件夹应该会自动添加到我们的工作区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/7bc571c409d5908f75b9edf57828f945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qdaoLalEhnV1eXao0h8qXg.png"/></div></figure><p id="7b28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>我们需要在每次创建新模块时创建适当的文件夹和第一个空文件，以满足SPM的要求，但是我们只需要为每个模块创建一次。通过使用<code class="fe lv lw lx ly b">⌘ + N</code>快捷方式并选择正确的目标成员，我们总是可以以标准的方式向现有模块添加新文件。</p><p id="f1a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以创建SwiftUI视图了。让我们通过添加以下代码来修改空文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c0f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件创建一个新的SwiftUI视图，在屏幕中间显示一个<code class="fe lv lw lx ly b">loading...</code>文本。视图是<code class="fe lv lw lx ly b">public</code>以及它的<code class="fe lv lw lx ly b">init</code>，这样我们可以在另一个模块中创建它。</p><p id="6424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不想在发布库时发布预览版代码；因此，我们在SwiftUI预览的代码周围包装了一个<code class="fe lv lw lx ly b">#if DEBUG</code>编译条件。这也会让我们的库在发布的时候变小！</p><p id="4eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，Xcode还在抱怨。SwiftUI是一些非常具体的macOS和iOS版本提供的功能，但我们没有在我们的<code class="fe lv lw lx ly b">Package.swift</code>中指定它们。让我们通过如下修改<code class="fe lv lw lx ly b">Package.swift</code>来修复这个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ba4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第3行，我们添加了所需的平台和一些合适的版本。</p><p id="9a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以键入<code class="fe lv lw lx ly b">⌘+b</code>并看到项目正在构建。我们甚至可以使用预览来查看它在屏幕上是如何呈现的。在我们可以在应用程序中使用这个视图之前，我们还缺少一个步骤:我们需要将这些更改提交到本地包存储库中。让我们运行以下命令:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="e5f1" class="na ma it ly b gy nb nc l nd ne">git add -A<br/>git commit -m "feat: add AppSetupView module"</span></pre><h2 id="056e" class="na ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated">使用AppSetupView</h2><p id="458f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们回到我们的应用程序，插入新的视图。作为第一件事，我们需要将我们对<code class="fe lv lw lx ly b">SPMAppKit</code>包所做的新改变引入到项目中。</p><p id="cb83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用“文件”&gt;“Swift软件包”菜单中的“更新至最新软件包版本”选项来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/0eda83d384e7df6acb14195c279fe6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsNZtfgyN19s4FC0kSm4AA.png"/></div></div></figure><p id="57aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令为我们获取项目中包含的所有Swift包中的所有变更。事实上，新的项目结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/46564b92d3ad70dd8acec04558ffae2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*bqSn2VHmlXPMJT-QvRwz9Q.png"/></div></figure><p id="34e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到Swift Package Dependencies部分现在包含了<code class="fe lv lw lx ly b">AppSetupView</code>模块。</p><p id="98ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是修改<code class="fe lv lw lx ly b">SPMAppApp.swift</code>文件以使用新的<code class="fe lv lw lx ly b">AppSetupView</code>。让我们将代码修改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们正在导入新的<code class="fe lv lw lx ly b">AppSetupView</code>模块，并在<code class="fe lv lw lx ly b">WindowGroup</code>中创建视图。现在让我们按<code class="fe lv lw lx ly b">⌘+r</code>来运行应用程序:我们应该看到新的应用程序设置视图出现了。</p><h1 id="d93e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="c764" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在今天的文章中，我们谈到了几个概念。我们看到了如何创建SPM包，如何将其集成到应用程序中，以及如何在同一个包中创建不同的模块。</p><p id="6032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的真正优势在于，应用程序的全部代码实际上都可以在SPM环境中开发，只有在最后或需要演示时才集成到真正的应用程序中。单个模块的构建时间非常快。Xcode只能重建那些实际上已经改变的模块。因此，我们不必每次模块改变时都等待应用程序的完全重建。</p><p id="13d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们可以使用SwiftUI预览快速检查UI的外观(甚至可以使用UIKit 进行预览)，应用程序的逻辑可以隔离在特定的模块中，这些模块可以单独测试。</p></div></div>    
</body>
</html>