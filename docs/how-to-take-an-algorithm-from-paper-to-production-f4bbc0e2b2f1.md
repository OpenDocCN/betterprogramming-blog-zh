# 如何将一个算法从纸上变成产品

> 原文：<https://betterprogramming.pub/how-to-take-an-algorithm-from-paper-to-production-f4bbc0e2b2f1>

## 构建算法开发管道

![](img/94f5540d92c7beab9cd082ba2efc3644.png)

迈克尔·泽兹奇在 [Unsplash](https://unsplash.com/s/photos/algorithm?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

算法是现代创新的基础。在科技报道中经常出现的短语“*X 的新技术… 【T5”)，通常指的是一段或大或小的代码，它赋予算法生命，以实现某个通常模糊的目标。这种创新在老牌科技巨头和初创公司之间形成了竞争，因为这种新技术，即算法，实际上比以前的解决方案更好地帮助解决了客户的问题。*

算法可能是以下内容的一部分:

*   一个简单的移动应用程序(*一个跟踪你的应用程序使用和电池性能的应用程序；一个允许你记录每天跑步和健康指标的应用程序；甚至尤其是游戏，从糖果粉碎到沥青 9* 。
*   一个操作系统( *Android OS 架构，Windows 和 Mac 等等*)。
*   一个推荐服务(*认为网飞在暗示电影，或者语义学者在暗示学术文献*)。
*   投资组合管理工具(*伯克希尔·哈撒韦公司的经理如何管理其资产？*)
*   拼车服务(*给定的出行请求分配哪个司机/出租车？*)
*   搜索工具(*谷歌在 0.08 秒内提供数十亿个搜索结果，或者基因组数据库中的搜索工具*
*   一款虚拟/增强现实应用(*渲染你身边地上的皮卡丘；Magic Leap apps*
*   高保真建模工具(*模拟能源需求或石油经济，模拟生物大分子；迪士尼动画辛巴与超现实主义的次表面光散射；Adobe After Effects 允许您从视频剪辑中移除移动的对象，同时保留其环境*。

要点很简单——现代创新是基于算法的。随着我们能够想象越来越大的需求，算法工具包也在同步扩展。不言而喻，数学工具包扩展了，代码工具包也扩展了。解决这些即将到来的问题变得越来越困难。

让事情更复杂的是，并非所有的问题都是一样的。另外，算法是知识产权和商业秘密——通常只有初级算法是开源的。

每一个新问题都需要一个已知解决方案的稍微定制的实现。一些问题将需要突破性创新，在这种情况下，这可能意味着数学方法、实现范式(*如新的操作系统或代码库*)或硬件(*如处理能力的提高可以使某些问题的实现成本可行*)的创新。

***免责声明*** *:为了简单起见，这里不加区分地使用了* ***【算法】*** *。不过，一般来说，它的本意是一组方法和逻辑进展，这些方法和逻辑进展处理某些数据以提供某些有用的输出。显然，它指的是数学和代码。就本文的范围而言，该术语旨在涵盖所有级别的复杂性——从简单的 if/for/switch 逻辑，到非线性动态编程，再到大数据集群和深度学习。*

从算法的概念化到部署的整个过程由七个关键(但不一定容易)步骤组成:

1.公式化问题

2.模型

3.密码

4.准备数据

5.评价

6.选择和优化

7.部署

根据您的最终目标、产品或专业/角色，您的起点可能是这些步骤中的任何一个。

但是如果你只有一个想法和纸笔——或者，嗯，一台笔记本电脑——你就会一头扎进为复杂问题开发算法的密集世界，首先要明确你想要实现的是什么。

# 第一步:阐明问题

*知道自己需要什么。描述一下你想要的。*

*   生成问题陈述或领域的数学抽象。在这里，细节的层次应该捕获将要开发的特性/产品的整个范围。
    ( *从简介列表中选择一个例子，花些时间了解和研究你所选择的功能/产品背后的核心问题的表述。*)
*   只要有可能，功能性和非功能性需求都会被记录下来，包括与实际算法开发无关的需求。这些需求可能来自您的开发/部署环境、更广泛的产品范围等等。
*   确定所需信息和可用信息(以及差距)。根据解决方法确定问题的类别。(例如，简单的双变量目标最小化可以是线性优化问题，但是容量约束问题可以是复杂得多的背包问题的变体)。
*   同时，尝试指定问题的预期最终操作环境—使用哪种语言(C++，Java)编程，部署在哪里(AWS，自有服务器/计算集群，个人笔记本电脑)等。尝试确定父产品的更广泛的架构:要部署的算法是内部工具的一部分，还是面向客户的？要求实时吗？在部署状态期间，数据将来自哪里(例如，来自数据库、来自移动/web 上的客户端应用程序等。)?

# 第二步:建模

用全面的术语写下预期的解决方案。

![](img/b903a3efcb7609f7fd34856ccfc28b96.png)

等等，不是这个“模型”……(照片由[克雷格·麦克戈尼格尔](https://unsplash.com/@craigewmcg123?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 上拍摄)

*   一旦根据问题的解决方法确定了问题的类别，就为问题的预期解决方法创建一个*框架*(这是框架的第一次迭代)。框架是组成完整问题/特性/产品的子问题的一套全面的子解决方案。
*   为了获得框架的最佳第一次迭代，**非常重要的一点是，要了解围绕具有相似基础模型的问题的解决方案的(学术)文献** —这些问题可能来自不同的领域。通常情况下，解决复杂问题所需的数学或统计数据是高级水平的，并且最佳解决方案会非常快速地得到改进。
    (例如，隐马尔可夫模型用于映射和路由问题以及计算生物学，其中潜在的参数现象是相同的，因此通过 hmm 建模。)
*   使用该框架，添加不同程度的细节，为每个子问题创建实际的数学模型，每个子问题都适当地相互关联。
*   在上一步中，根据最终的模型定义，将预测的数据需求映射到实际的数据需求。为模型操作过程中需要和生成的数据和数据集创建规范。(例如，GIS 数据、人口数据、机械故障率数据、过去的财务数据等。可能需要，具体取决于您的应用。)
*   最后，为模型和子模型生成性能指标。度量应该反映抽象问题(仅数学)和部署性能(运行时)的性能参数。度量可以是与解决方案相关的(结果的效率、误差、精度)、时间性能(时间复杂度、实际机器相关的性能)、空间性能(空间复杂度)等。度量标准可以/应该从文献中的已知实现中借用。

# 第三步:编码

让键盘噼啪作响。在你选择的编程语言中生成逻辑。

*   为了评估效率和准备就绪，必须编写测试代码和生产就绪代码。典型地，测试代码可能首先被写出来，以挑选出任何不必要的错误或者适应模型框架的变化。测试代码可以在任何合适的环境中编写，例如 MATLAB、Eclipse (Java、C/C++)等。
*   以模块化方式编写测试代码，以便能够使用适当的输入参数和数据集独立测试每个模块和子模块。这可能与模型的数学以及测试代码的代码设置和环境有关。
*   根据测试代码和从测试代码中获得的知识，根据需要编写产品级代码。

# 步骤 4:准备数据

*没有数据，没有收获。准备数据从哪里来，以什么形式。*

*   根据之前制定的数据要求，以适当的格式准备样本或真实数据(视情况而定)。
*   对于大多数问题，需要高质量的数据。根据您所在的领域，这些数据可能随时可用，也可能随时不可用。(*例如，用于训练 ML 模型的图像数据集今天可能很容易获得，但是很难获得所有城市交通模式的高保真交通数据。* )
    仔细考虑这些数据的确切性质和使用案例，以便在测试和部署时做好更充分的准备。想办法得到那些不容易得到的东西——产品成功本身可能就取决于它！
*   根据您的应用程序，可能会出现一些架构上的考虑，例如，使用 SQL 还是 NoSQL 数据库，本地数据还是云存储数据。应该适当地准备数据。测试代码和生产级代码的数据要求可能不同。
*   准备好测试代码和生产级代码的某些部分后，明智的做法是花一些时间来微调代码中使用的实际*数据结构*以及它们在真实数据集中的对等物。代码可能需要将可用数据转换为适当数据结构的接口，或者数据准备步骤本身可能包括自动将数据集从标准数据结构转换为定制数据结构*的原位*。

# 第五步:评估

***生成并运行测试。了解什么有效。***

*   *对于测试代码*:基于问题陈述中预期的可变性、数据不足等，创建各种模拟场景。模拟各种场景的测试代码。根据前面概述的指标测试性能。测试技术指标很重要，例如时间和空间复杂性。
*   *对于生产级代码*:确定测试生产级代码的行业最佳实践，并尽可能使用标准测试框架。
*   使用测试结果，迭代测试代码/产品级代码，并重复相关步骤。尽可能多的迭代(在时间和成本限制下的最佳结果)。

# 第六步:选择和优化

***优化就是竞争力。优化就是价值。***

*   根据测试结果，最终确定用于部署的框架和模型。选择效果最好的。将其他文件存档以备将来使用。
*   如果问题/特性/产品很复杂——正如今天的大多数——为每个步骤以及每个迭代创建适当的文档。

# 步骤 7:部署

*任其横行。但是要善于观察。*

*   实现最终代码并部署到生产环境中。这一步完全取决于最终应用——该算法可能是 MMORPG 游戏后端的一部分，或者是实时乘车共享服务的一部分，或者是高级材料建模和 GPU 渲染的一次性实验的一部分。充分了解您的生产环境变量。
*   定期监控性能，直到可以在生产环境中进行无人监管(或半监管)的部署。
*   联系到核心问题框架的任何更新，以及逻辑和测试代码的更新，包括模块化、未来特性就绪性等等。

就是这样，就是这七个步骤！乍一看，这似乎是一个简单的逻辑过程，但当涉及到复杂的产品和系统时，实际上很难遵循和管理。这就是管道存在的原因，对吗？

# 进一步参考

下面是与一种称为地图匹配的算法相关的文档列表，该算法通常用于使用车辆的 GPS 轨迹(比如从驾驶员的手机上)来识别车辆在已知地图(可用的 GIS 数据)上所走的路线。这个想法是使用每一个已知的 GPS 位置，并将其“捕捉”到车辆最有可能经过的适当路段。

但是由于 GPS 轨迹存在误差，并且是一个离散的数据集，并且大多数城市的道路网络非常复杂，所以估计车辆从 A 点到 b 点时使用哪条道路是一个困难的计算问题。

*   《全市浮动车数据地图匹配的算法与实现》，韩 2015，TU Munich
    *可用*:[https://cartographymaster . eu/WP-content/thesis/2015 _ 陆毅 _Thesis.pdf](https://cartographymaster.eu/wp-content/theses/2015_Luyi_Thesis.pdf)
*   「带行程时间约束的地图匹配」，微软研究院
    *可用*:[https://www . Microsoft . com/en-us/Research/WP-content/uploads/2016/11/Map-Matching-HMM-01 . pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/map-matching-HMM-01.pdf)
*   《通过噪声和稀疏进行隐马尔可夫图匹配》，微软研究院
    *可用*:[https://www . ismll . uni-hildesheim . de/lehre/SEM spatial-10s/script/6 . pdf](https://www.ismll.uni-hildesheim.de/lehre/semSpatial-10s/script/6.pdf)
*   https://www.github.com/Project-OSRM/osrm-backend:地图匹配
    *项目 OSRM 源代码*

这些论文描述了使用各种方法的地图匹配的算法和实现，但是集中于一种涉及使用隐马尔可夫模型(HMM)的方法。最后一个链接是一个非常著名的开源程序(OSRM 计划)的源代码，它基于基于 HMM 的算法实现了地图匹配。

通过仔细阅读这些资源，你可以开始了解如何从数学到代码，最后到产品。

正如您在简介中看到的，当今世界种类繁多，无法在一个地方提供全面的资源。

这里希望上面的例子，顺便说一下，不被认为是一个非常困难的问题，为您未来的自学铺平道路，并帮助您制定出范围和价值不断增加的算法解决方案！

*本文基于作者对产品开发、复杂系统架构、一点点编程、工程领域知识的理解。作者不是全职开发人员，也不是执业 IT 系统架构师，只是和产品架构紧密相关。当涉及到您的实际问题/功能/产品时，建议您始终参考行业最佳实践。*