<html>
<head>
<title>Using Events in Node.js (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中使用事件(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-events-in-node-js-the-basics-9a9c44dcbe30?source=collection_archive---------5-----------------------#2019-12-04">https://betterprogramming.pub/using-events-in-node-js-the-basics-9a9c44dcbe30?source=collection_archive---------5-----------------------#2019-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8000" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何发出和监听事件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9f4bf76dd790698251a2a6d18622cc4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*DY7TZYQtJRzSv6bpjUYdYg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:<a class="ae ku" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fcommons.wikimedia.org%2Fwiki%2FFile%3ANode.js_logo.svg&amp;psig=AOvVaw2fYyIekeh0RMO3t7TO8irB&amp;ust=1575656878456000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCPCbkbiRn-YCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">维基共享资源</a></p></figure><p id="cd4c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Node.js的核心特性是异步编程。这意味着Node.js中的代码可能不会按顺序执行。因此，数据可能无法在固定的时间内确定。这意味着，为了获得我们需要的所有数据，我们必须在获得数据时在应用程序中传递数据。这可以通过在Node.js应用程序中发出、侦听和处理事件来实现。当发出具有给定名称的事件时，如果侦听器被指定侦听具有该名称的事件，则该事件可以侦听侦听器。事件发射器函数被同步调用。事件侦听器代码是一个回调函数，它接受数据的参数并对其进行处理。Node.js有一个<code class="fe lr ls lt lu b">EventEmitter</code>类——可以通过创建一个新类来扩展它，以发出可以被事件监听器监听的事件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="db37" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义事件发射器</h1><p id="1dc0" class="pw-post-body-paragraph kv kw it kx b ky mu ju la lb mv jx ld le mw lg lh li mx lk ll lm my lo lp lq im bi translated">下面是一个创建和使用<code class="fe lr ls lt lu b">EventEmitter</code>类的简单例子:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="cdb4" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');</span><span id="e186" class="nd md it lu b gy ni nf l ng nh">class Emitter extends EventEmitter {}</span><span id="5026" class="nd md it lu b gy ni nf l ng nh">const eventEmitter = new Emitter();<br/>eventEmitter.on('event', () =&gt; {<br/>  console.log('event emitted!');<br/>});</span><span id="e2f6" class="nd md it lu b gy ni nf l ng nh">eventEmitter.emit('event');</span></pre><p id="ec2d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应该得到“事件发射！”在控制台日志中。在上面的代码中，我们创建了扩展<code class="fe lr ls lt lu b">EventEmitter</code>类的<code class="fe lr ls lt lu b">Emitter</code>，该类具有我们在最后一行中调用的<code class="fe lr ls lt lu b">emit</code>函数。<code class="fe lr ls lt lu b">emit</code>函数的参数是事件的名称，我们在下面的代码块中听到了这个名称:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="1b7d" class="nd md it lu b gy ne nf l ng nh">eventEmitter.on('event', () =&gt; {<br/>  console.log('event emitted!');<br/>});</span></pre><p id="5b2d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的<code class="fe lr ls lt lu b">'event'</code>参数之后的回调函数是事件处理函数，在接收到事件时运行。</p><p id="88e8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的代码中，我们发出了一个事件。然而，这不是很有用，因为当我们发出事件时，我们没有传递任何数据，所以它没有做太多。因此，我们希望用事件发送数据，这样我们就可以传递数据，这样我们就可以在事件侦听器中做一些有用的事情。为了在发出事件时传递数据，我们可以在第一个参数(即事件名称)之后传入额外的参数。例如，我们可以编写以下代码:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="591f" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();</span><span id="ec43" class="nd md it lu b gy ni nf l ng nh">eventEmitter.on('event', (a, b) =&gt; {<br/>  console.log(a, b);<br/>});</span><span id="d418" class="nd md it lu b gy ni nf l ng nh">eventEmitter.emit('event', 'a', 'b');</span></pre><p id="de86" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们运行上面的代码，我们会在事件处理程序回调函数的<code class="fe lr ls lt lu b">console.log</code>语句中得到‘a’和‘b’。正如我们看到的，我们可以用<code class="fe lr ls lt lu b">emit</code>函数传递多个参数，将数据传递给订阅事件的事件处理程序。在第一个之后，<code class="fe lr ls lt lu b">emit</code>函数调用中的参数都作为参数传递给事件监听器的回调函数，因此可以在事件监听器回调函数中访问它们。</p><p id="2173" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们还可以访问事件监听器回调函数中的事件发射器对象。我们所要做的就是将回调的箭头函数更改为传统函数，如以下代码所示:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="2b63" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();</span><span id="5680" class="nd md it lu b gy ni nf l ng nh">eventEmitter.on('event', function(a, b){<br/>  console.log(a, b);<br/>  console.log(`Instance of EventEmitter: ${this instanceof EventEmitter}`);<br/>  console.log(`Instance of Emitter: ${this instanceof Emitter}`);<br/>});</span><span id="7167" class="nd md it lu b gy ni nf l ng nh">eventEmitter.emit('event', 'a', 'b');</span></pre><p id="b729" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们运行上面的代码，我们会在事件监听器回调函数内的<code class="fe lr ls lt lu b">console.log</code>语句中记录这一点:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="63bf" class="nd md it lu b gy ne nf l ng nh">a b<br/>Instance of EventEmitter: true<br/>Instance of Emitter: true</span></pre><p id="253c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">另一方面，如果我们有以下情况:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="fb7f" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();</span><span id="a410" class="nd md it lu b gy ni nf l ng nh">eventEmitter.on('event', (a, b) =&gt; {<br/>  console.log(a, b);<br/>  console.log(`Instance of EventEmitter: ${this instanceof EventEmitter}`);<br/>  console.log(`Instance of Emitter: ${this instanceof Emitter}`);<br/>});</span><span id="d3f3" class="nd md it lu b gy ni nf l ng nh">eventEmitter.emit('event', 'a', 'b');</span></pre><p id="9a19" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们在事件监听器回调函数中的<code class="fe lr ls lt lu b">console.log</code>语句中记录这一点。：</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="91c1" class="nd md it lu b gy ne nf l ng nh">a b<br/>Instance of EventEmitter: false<br/>Instance of Emitter: false</span></pre><p id="115a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是因为箭头功能不会改变其内部的<code class="fe lr ls lt lu b">this</code>对象。然而，传统函数<em class="nj">会改变<code class="fe lr ls lt lu b">this</code>对象的内容。</em></p><p id="ee73" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">EventEmitter</code>按照注册的顺序同步调用所有监听器。这消除了竞争条件和其他逻辑错误的可能性。为了异步处理事件，我们可以使用<code class="fe lr ls lt lu b">setImmediate()</code>或<code class="fe lr ls lt lu b">process.nextTick()</code>方法:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="f455" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();</span><span id="3527" class="nd md it lu b gy ni nf l ng nh">eventEmitter.on('event', (a, b) =&gt; {<br/>  setImmediate(() =&gt; {<br/>    console.log('event handled asychronously');<br/>  });<br/>});<br/>eventEmitter.emit('event', 'a', 'b');</span></pre><p id="31c8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的代码中，我们将<code class="fe lr ls lt lu b">console.log</code>放在<code class="fe lr ls lt lu b">setImmediate</code>函数的回调函数中，该函数将异步而不是同步运行事件处理代码。</p><p id="1947" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">事件在每次发出时都会被处理。例如，如果我们有:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="f006" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();<br/>let x = 1;</span><span id="9798" class="nd md it lu b gy ni nf l ng nh">eventEmitter.on('event', (a, b) =&gt; {<br/>  console.log(x++);<br/>});</span><span id="e7ac" class="nd md it lu b gy ni nf l ng nh">for (let i = 0; i &lt; 5; i++){<br/>  eventEmitter.emit('event');<br/>}</span></pre><p id="c8c1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因为我们发出了“event”事件五次，所以我们得到:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="f74b" class="nd md it lu b gy ne nf l ng nh">1<br/>2<br/>3<br/>4<br/>5</span></pre><p id="a73a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们想发出一个事件，并且只在第一次发出时处理它，那么我们使用<code class="fe lr ls lt lu b">eventEmitter.once()</code>函数，如下面的代码所示:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="4092" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();<br/>let x = 1;</span><span id="f0bc" class="nd md it lu b gy ni nf l ng nh">eventEmitter.once('event', (a, b) =&gt; {<br/>  console.log(x++);<br/>});</span><span id="8b13" class="nd md it lu b gy ni nf l ng nh">for (let i = 0; i &lt; 5; i++){<br/>  eventEmitter.emit('event');<br/>}</span></pre><p id="7e28" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如所料，我们只在上面的事件处理程序的<code class="fe lr ls lt lu b">console.log</code>语句中记录了这一点:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="9ea2" class="nd md it lu b gy ne nf l ng nh">1</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="040e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">错误处理</h1><p id="94b8" class="pw-post-body-paragraph kv kw it kx b ky mu ju la lb mv jx ld le mw lg lh li mx lk ll lm my lo lp lq im bi translated">如果在出现错误的情况下发出错误事件，它将被视为Node.js中的特殊情况。如果<code class="fe lr ls lt lu b">EventEmitter</code>没有至少一个错误事件监听器寄存器，并且发出了错误，则抛出该错误，并且将打印错误的堆栈跟踪，该流程将退出。例如，如果我们有以下代码:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="ed26" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();</span><span id="f6b1" class="nd md it lu b gy ni nf l ng nh">eventEmitter.emit('error', new Error('Error occured'));</span></pre><p id="9538" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后我们得到这样的结果，程序退出:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="dd7f" class="nd md it lu b gy ne nf l ng nh">Error [ERR_UNHANDLED_ERROR]: Unhandled error. (Error: Error occured<br/>    at evalmachine.&lt;anonymous&gt;:5:28<br/>    at Script.runInContext (vm.js:133:20)<br/>    at Object.runInContext (vm.js:311:6)<br/>    at evaluate (/run_dir/repl.js:133:14)<br/>    at ReadStream.&lt;anonymous&gt; (/run_dir/repl.js:116:5)<br/>    at ReadStream.emit (events.js:198:13)<br/>    at addChunk (_stream_readable.js:288:12)<br/>    at readableAddChunk (_stream_readable.js:269:11)<br/>    at ReadStream.Readable.push (_stream_readable.js:224:10)<br/>    at lazyFs.read (internal/fs/streams.js:181:12))<br/>    at Emitter.emit (events.js:187:17)<br/>    at evalmachine.&lt;anonymous&gt;:5:14<br/>    at Script.runInContext (vm.js:133:20)<br/>    at Object.runInContext (vm.js:311:6)<br/>    at evaluate (/run_dir/repl.js:133:14)<br/>    at ReadStream.&lt;anonymous&gt; (/run_dir/repl.js:116:5)<br/>    at ReadStream.emit (events.js:198:13)<br/>    at addChunk (_stream_readable.js:288:12)<br/>    at readableAddChunk (_stream_readable.js:269:11)<br/>    at ReadStream.Readable.push (_stream_readable.js:224:10)</span></pre><p id="d2f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了防止Node.js程序崩溃，我们可以使用新的事件侦听器来侦听错误事件，并在错误事件处理程序中优雅地处理错误。例如，我们可以写:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="a1fb" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();</span><span id="91d6" class="nd md it lu b gy ni nf l ng nh">eventEmitter.on('error', (error) =&gt; {<br/>  console.log('Error occurred');<br/>});</span><span id="911b" class="nd md it lu b gy ni nf l ng nh">eventEmitter.emit('error', new Error('Error occurred'));</span></pre><p id="4855" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后我们得到“错误发生”记录。我们也可以用事件处理程序回调函数的<code class="fe lr ls lt lu b">error</code>参数获取错误内容。如果我们记录它，如下面的代码所示:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="d7ca" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();</span><span id="69d8" class="nd md it lu b gy ni nf l ng nh">eventEmitter.on('error', (error) =&gt; {<br/>  console.log(error);<br/>});</span><span id="02fc" class="nd md it lu b gy ni nf l ng nh">eventEmitter.emit('error', new Error('Error occurred'));</span></pre><p id="6ada" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们会得到这样的结果:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="a1ce" class="nd md it lu b gy ne nf l ng nh">Error: Error occurred<br/>    at evalmachine.&lt;anonymous&gt;:7:28<br/>    at Script.runInContext (vm.js:133:20)<br/>    at Object.runInContext (vm.js:311:6)<br/>    at evaluate (/run_dir/repl.js:133:14)<br/>    at ReadStream.&lt;anonymous&gt; (/run_dir/repl.js:116:5)<br/>    at ReadStream.emit (events.js:198:13)<br/>    at addChunk (_stream_readable.js:288:12)<br/>    at readableAddChunk (_stream_readable.js:269:11)<br/>    at ReadStream.Readable.push (_stream_readable.js:224:10)<br/>    at lazyFs.read (internal/fs/streams.js:181:12)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2728" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更多处理事件的方法</h1><p id="1194" class="pw-post-body-paragraph kv kw it kx b ky mu ju la lb mv jx ld le mw lg lh li mx lk ll lm my lo lp lq im bi translated"><code class="fe lr ls lt lu b">Node.js</code>将在不编写任何代码的情况下发出一个特殊事件:T2。在将侦听器添加到内部侦听器数组之前，会发出<code class="fe lr ls lt lu b">newListener</code>事件。例如，如果我们有以下代码:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="705d" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter {}<br/>const eventEmitter = new Emitter();<br/>eventEmitter.on('newListener', (<!-- -->event, listener<!-- -->) =&gt; {<br/>  console.log(<!-- -->event<!-- -->);<br/>});</span></pre><p id="2cd4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后我们得到这样的记录:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="8ed1" class="nd md it lu b gy ne nf l ng nh">Emitter {<br/>  _events: [Object: null prototype] { newListener: [Function] },<br/>  _eventsCount: 1,<br/>  _maxListeners: undefined }</span></pre><p id="dee9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">即使没有事件发出，也会发生这种情况。对于任何其他事件，处理程序中的任何内容都将在事件处理程序中的代码之前运行。</p><p id="07cd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">removeListener</code>函数可以用来阻止事件监听器函数监听事件。这需要两个参数:第一个是表示事件名称的字符串，第二个是您想要停止使用来监听事件的函数。例如，如果我们想用监听器函数停止监听“event”事件，那么我们可以这样写:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="2e84" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter { }<br/>const eventEmitter = new Emitter();</span><span id="2f74" class="nd md it lu b gy ni nf l ng nh">const listener = () =&gt; {<br/>  console.log('listening');<br/>}</span><span id="f960" class="nd md it lu b gy ni nf l ng nh">eventEmitter.on('event', listener)</span><span id="3134" class="nd md it lu b gy ni nf l ng nh">setInterval(() =&gt; {<br/>  eventEmitter.emit('event');<br/>}, 300);</span><span id="3f50" class="nd md it lu b gy ni nf l ng nh">setTimeout(() =&gt; {<br/>  console.log("removing");<br/>  eventEmitter.removeListener('event', listener);<br/>}, 2000);</span></pre><p id="f845" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后我们在输出中得到这样的结果:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="abec" class="nd md it lu b gy ne nf l ng nh">Timeout {<br/>  _called: false,<br/>  _idleTimeout: 2000,<br/>  _idlePrev: [TimersList],<br/>  _idleNext: [TimersList],<br/>  _idleStart: 1341,<br/>  _onTimeout: [Function],<br/>  _timerArgs: undefined,<br/>  _repeat: null,<br/>  _destroyed: false,<br/>  [Symbol(unrefed)]: false,<br/>  [Symbol(asyncId)]: 10,<br/>  [Symbol(triggerId)]: 7 }listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>removing</span></pre><p id="ca59" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">事件发射器每300毫秒发出一次上面代码中的“event”事件。这由<code class="fe lr ls lt lu b">listener</code>函数监听，直到通过在<code class="fe lr ls lt lu b">setTimeout</code>函数的回调中调用事件名称为<code class="fe lr ls lt lu b">listener</code>事件监听器函数的<code class="fe lr ls lt lu b">removeListener</code>函数来阻止它再次监听。</p><p id="5472" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">多个事件侦听器可以注册一个事件。默认情况下，事件侦听器的最大数量限制为十个。我们可以用<code class="fe lr ls lt lu b">EventEmitter</code>类中的<code class="fe lr ls lt lu b">defaultMxListeners</code>函数来改变这一点。我们可以把它设为任何正数。如果不是正数，那么抛出一个<code class="fe lr ls lt lu b">TypeError</code>。如果注册的侦听器超过了限制，则会输出一个警告。例如，如果我们运行以下代码为“event”事件注册11个事件侦听器:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="2628" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter { }<br/>const eventEmitter = new Emitter();</span><span id="2f06" class="nd md it lu b gy ni nf l ng nh">const listener = () =&gt; {<br/>  console.log('listening');<br/>}</span><span id="af12" class="nd md it lu b gy ni nf l ng nh">for (i = 1; i &lt;= 11; i++){<br/>  eventEmitter.on('event', listener);<br/>}</span><span id="6267" class="nd md it lu b gy ni nf l ng nh">eventEmitter.emit('event');</span></pre><p id="c91a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们运行上面的代码时，我们得到这样的结果:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="b457" class="nd md it lu b gy ne nf l ng nh">listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>(node:345) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 event listeners added. Use emitter.setMaxListeners() to increase limit</span></pre><p id="0a32" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是，如果我们调用<code class="fe lr ls lt lu b">setMaxListeners</code>将其设置为<code class="fe lr ls lt lu b">getMaxListeners() + 1</code>，即11个侦听器，如下面的代码所示:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="7f66" class="nd md it lu b gy ne nf l ng nh">const EventEmitter = require('events');<br/>class Emitter extends EventEmitter { }<br/>const eventEmitter = new Emitter();<br/>eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() + 1);</span><span id="2876" class="nd md it lu b gy ni nf l ng nh">const listener = () =&gt; {<br/>  console.log('listening');<br/>}</span><span id="3a49" class="nd md it lu b gy ni nf l ng nh">for (i = 1; i &lt;= 11; i++){<br/>  eventEmitter.on('event', listener);<br/>}</span><span id="14f0" class="nd md it lu b gy ni nf l ng nh">eventEmitter.emit('event');</span></pre><p id="ba0d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们记录了以下内容:</p><pre class="kj kk kl km gt mz lu na nb aw nc bi"><span id="034b" class="nd md it lu b gy ne nf l ng nh">listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening<br/>listening</span></pre><p id="6e8e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Node.js的一个重要特性就是异步编程。这意味着Node.js中的代码可能不会按顺序执行。数据可能无法在固定的时间内确定。这意味着，要获得我们需要的所有数据，我们必须在获得数据时在应用程序周围传递数据。我们可以发出事件并在Node.js应用程序中处理它们。</p><p id="7a64" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当发出具有给定名称的事件时，如果侦听器被指定侦听具有该名称的事件，则该事件可以侦听侦听器。事件发射器函数被同步调用。事件侦听器代码是一个回调函数，它接受数据的参数并对其进行处理。Node.js有一个<code class="fe lr ls lt lu b">EventEmitter</code>类，可以通过我们创建的一个新类来扩展，以发出可以被事件监听器监听的事件。使用<code class="fe lr ls lt lu b">EventEmitter</code>类，我们可以创建新的<code class="fe lr ls lt lu b">EventEmitter</code>类来发出和监听事件。我们可以在一个事件上附加多个事件监听器，它们可以做不同的事情。此外，我们可以根据需要设置事件侦听器的最大数量。最后，我们可以选择异步处理事件，而不是同步。</p></div></div>    
</body>
</html>