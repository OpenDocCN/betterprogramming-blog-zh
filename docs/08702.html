<html>
<head>
<title>3 Algorithm Runtimes Visualized With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python可视化的3个算法运行时</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-algorithm-runtimes-visualized-with-python-e51441827917?source=collection_archive---------2-----------------------#2021-06-02">https://betterprogramming.pub/3-algorithm-runtimes-visualized-with-python-e51441827917?source=collection_archive---------2-----------------------#2021-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e10" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用代码来可视化和确定不同算法的运行时复杂性。具有Matplotlib和NumPy</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/24035492c23c2f0374a1aa56b95435ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5BXb9jSrtQHUDZzk"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JOSHUA COLEMAN 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8e9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用Python中的可视化库和软件，我们能够确定不同算法的运行时复杂性。我们将首先回顾运行时复杂性和运行时复杂性分析的基础。然后，我们将介绍<a class="ae kv" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>用于可视化2D图和<a class="ae kv" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>用于计算最佳拟合线的基本用法，并通过将这些库的运行时图与已知函数(例如<code class="fe ls lt lu lv b">y = n^2</code>、<code class="fe ls lt lu lv b">y = 2^n</code>)的运行时图进行比较，找出如何使用这些库来确定它们的运行时复杂性。</p><p id="6bdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有兴趣下载本文中的代码，请访问我的GitHub上的<a class="ae kv" href="https://github.com/chroline/visualizingRuntimes" rel="noopener ugc nofollow" target="_blank">这个资源库(ch roline/visualizing runtimes)</a>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="28ff" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">什么是运行时复杂性？</h1><p id="1c58" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><em class="na">运行时复杂性</em>，更确切地说是<em class="na">运行时复杂性分析</em>，是一种衡量算法在所需运算量增加时运行速度的方法。在我们开始可视化不同算法的运行时之前，让我们看几个基本的例子来解释这个概念。</p><p id="a9bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的<code class="fe ls lt lu lv b">add</code>函数。它接受两个参数<code class="fe ls lt lu lv b">a</code>和<code class="fe ls lt lu lv b">b</code>，并对<code class="fe ls lt lu lv b">a</code>和<code class="fe ls lt lu lv b">b</code>进行加法运算。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="58f3" class="nf me iq lv b gy ng nh l ni nj">def add(a, b):<br/>    return a + b</span></pre><p id="0d9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当给定任意两个参数(1和2，2和3，29347和93648)时，运算量不变。因此，我们说算法以恒定的时间运行。</p><p id="18bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，现在考虑下面的<code class="fe ls lt lu lv b">permutations</code>函数。它接受一个主参数<code class="fe ls lt lu lv b">string</code>，并打印该字符串的所有排列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ab24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以想象，这个函数将比前面的<code class="fe ls lt lu lv b">add</code>函数花费更长的时间；事实上，这个函数将在所谓的<em class="na">阶乘</em>时间内运行，表示为<code class="fe ls lt lu lv b">O(n!)</code>。这是因为随着<code class="fe ls lt lu lv b">string</code>中字符数量的增加，寻找所有排列所需的运算次数也会成倍增加。</p><p id="209c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当直观地比较两个函数的运行时时，您会注意到它们所生成的图形有着鲜明的对比。对于<code class="fe ls lt lu lv b">add</code>函数，您会观察到一条平坦的线，因为函数的输入不影响函数所需的运算次数。然而，对于<code class="fe ls lt lu lv b">permutations</code>函数，您会观察到一条直线急剧上升(直线的斜率接近无穷大),因为随着输入大小的增加，运算次数会以阶乘方式增加。</p><p id="5c41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经介绍了运行时复杂性分析的基础，我们可以开始编写代码来可视化不同算法的运行时。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="2d93" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">初始化</h1><p id="7590" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在运行任何可视化之前，我们必须首先导入必要的库并初始化它们。</p><ul class=""><li id="3508" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">Matplotlib是一个创建和显示图形的库。</li><li id="b64b" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">NumPy是一个包含许多数学实用函数的库。</li><li id="bcc0" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit</a></code>是一个库，我们将使用它来计算每次调用算法所花费的时间。</li><li id="f592" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://docs.python.org/3/library/math.html?highlight=math#module-math" rel="noopener ugc nofollow" target="_blank">math</a></code>是基本的Python数学库。</li><li id="2d52" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://docs.python.org/3/library/random.html" rel="noopener ugc nofollow" target="_blank">random</a></code>是基本的Python随机化库。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="faa1" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">示范</h1><p id="08c2" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">下面是演示如何使用Matplotlib和NumPy的一些代码段。</p><h2 id="2f64" class="nf me iq bd mf oa ob dn mj oc od dp mn lf oe of mp lj og oh mr ln oi oj mt ok bi translated"><code class="fe ls lt lu lv b">sum</code>功能</h2><p id="f07c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">内置的Python <code class="fe ls lt lu lv b">sum</code>函数计算提供的<code class="fe ls lt lu lv b">Iterable</code>的所有元素的总和。这个函数实现了一个运行时复杂度为<code class="fe ls lt lu lv b">O(n)</code>的算法。</p><p id="ee13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试这一点，我们将使用NumPy库中的<code class="fe ls lt lu lv b">linspace</code>方法来生成一个iterable，它有50个均匀分布的值，范围从10到10，000。该图虽然不是一条完美的直线，但也说明了这一点。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="5ff2" class="nf me iq lv b gy ng nh l ni nj">ns = np.linspace(10, 10_000, 50, dtype=int)<br/>ts = [timeit.timeit('sum(range({}))'.format(n), number=100)<br/>      for n in ns]</span><span id="67a2" class="nf me iq lv b gy ol nh l ni nj">plt.plot(ns, ts, 'or')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/76581cb592aed795909bb43c96ce517e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*B_XSe_AD0g6AMTz4QivpBw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="5d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以添加一条最佳拟合线(使用四次函数)来进一步举例说明这一点。图表永远不会是一条完美的直线，但应该很接近。</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="39da" class="nf me iq lv b gy ng nh l ni nj">degree = 4<br/>coeffs = np.polyfit(ns, ts, degree)<br/>p = np.poly1d(coeffs)<br/>plt.plot(ns, ts,'or')<br/>plt.plot(ns, [p(n)for nin ns],'-b')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/ebc207aac5745ecc4f3ac1441582c89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*r5oVQnR26G7rfv5vruYfTQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><h2 id="cd90" class="nf me iq bd mf oa ob dn mj oc od dp mn lf oe of mp lj og oh mr ln oi oj mt ok bi translated">列表索引</h2><p id="c26a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">从列表中检索一个条目(列表索引)以<code class="fe ls lt lu lv b">O(1)</code>运行时复杂性运行，这意味着列表中条目的数量不会影响算法运行的时间。这在图表中是如何表示的？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/7bf5365333fcc099bbdd683db0560c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*6ccezgQ9vX_6OvHuulIthQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9d25" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">算法</h1><p id="384f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">现在，我们将查看由以下算法生成的图表:</p><ul class=""><li id="1fb2" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">线性搜索</li><li id="db51" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">二进位检索</li><li id="2996" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">插入分类</li></ul><h2 id="37fc" class="nf me iq bd mf oa ob dn mj oc od dp mn lf oe of mp lj og oh mr ln oi oj mt ok bi translated">线性搜索</h2><p id="d527" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">线性搜索的运行时复杂度为<code class="fe ls lt lu lv b">O(n)</code>，将用一条近似直线来表示。</p><p id="4bca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">红色曲线</strong>演示在混排列表中搜索元素，<strong class="ky ir">蓝色曲线</strong>演示搜索列表中不存在的元素。</p><p id="7ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">红色图的最佳拟合线通常小于蓝色图的最佳拟合线，因为搜索列表中不存在的元素需要遍历整个列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/9615d8f0f078c75c2bc3056bb09aedd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*q9U9PkX2e1ig4EU3RTIOog.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><h2 id="7b9f" class="nf me iq bd mf oa ob dn mj oc od dp mn lf oe of mp lj og oh mr ln oi oj mt ok bi translated">二进位检索</h2><p id="4e6b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">二分搜索法运行与<code class="fe ls lt lu lv b">O(log n)</code>运行时的复杂性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9ccb6f218d665f134cacc125dcc4f8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*KBkX7O6JA6VLl8WaOFUR2w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="e4d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多次运行后，上面是近乎完美的模拟图。如您所见，存在一些异常值，在完美的模拟中，最佳拟合线与对数函数相同。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="f6ee" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">插入排序</h1><p id="c427" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">插入排序有什么运行时复杂度？我们可以使用其运行时的图，并将这些图与已知运行时的图进行比较，以确定哪个是最接近的匹配。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/452ce09b367d79c1a601b1510e542adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*uPX_TvXHHhYCIbSKYufRBQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="37b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将该图与不同运行时的图进行比较，以最终确定哪一个最相似以及插入排序具有哪种运行时复杂性。</p><p id="a6f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">红色图</strong>代表<code class="fe ls lt lu lv b">O(log n)</code>，<strong class="ky ir">蓝色图</strong>代表<code class="fe ls lt lu lv b">O(n^2)</code>，<strong class="ky ir">绿色图</strong>代表<code class="fe ls lt lu lv b">O(2^n)</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/772a7874cb9859d0ed5fae7dfd69f608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*AIlZd2VriUIfA2vP3N1XOg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="cc17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于这些图表，可以安全地假设插入排序在<code class="fe ls lt lu lv b">O(n^2)</code>时间内运行。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0c09" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">神秘函数运行时分析</h1><p id="ef71" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们可以使用神秘函数运行时的可视化来确定它们的运行时复杂性吗？</p><h2 id="990f" class="nf me iq bd mf oa ob dn mj oc od dp mn lf oe of mp lj og oh mr ln oi oj mt ok bi translated">神秘功能#1</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/01f0731a633739baffacddfc8bf01114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*4IFDDOqbYMBHK38w6QmriA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="f09e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">甚至不用将这个图与可能的运行时图进行比较，我们就可以安全地假设这个函数在<code class="fe ls lt lu lv b">O(n)</code>运行时运行。</p><h2 id="e767" class="nf me iq bd mf oa ob dn mj oc od dp mn lf oe of mp lj og oh mr ln oi oj mt ok bi translated">神秘功能#2</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/a6a67987c9bacbc7379ba6b556e8c7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*EYaSOB9QGKMNEtv30r3F5g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="b73b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个图看起来非常类似于插入排序的图，所以我们可以确定这个函数的运行时复杂度是<code class="fe ls lt lu lv b">O(n^2)</code>。</p><h2 id="a1ea" class="nf me iq bd mf oa ob dn mj oc od dp mn lf oe of mp lj og oh mr ln oi oj mt ok bi translated">神秘功能#3</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/ac6231f6e8602f2aba4c8d4b0dfa9a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*vdKvkHW6e4W-bC7zmio8Gw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="d1e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数比前两个更模糊。显然，其运行时间必须大于<code class="fe ls lt lu lv b">O(n)</code>，因为斜率随着<code class="fe ls lt lu lv b">n</code>的增加而增加。让我们考虑红色<strong class="ky ir">中的<code class="fe ls lt lu lv b">O(n^2)</code>和蓝色<strong class="ky ir">中的<code class="fe ls lt lu lv b">O(2^n)</code>的运行时图。</strong></strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/c2e91badcf3c2ced1948e810450b74c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*f6jAJDByskEx39F_86l3Og.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="34f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">神秘函数#3的运行时间的图形更类似于蓝色曲线，因此神秘函数#3的运行时间复杂度是<code class="fe ls lt lu lv b">O(2^n)</code>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="2684" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="933b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">使用这些可视化库，我们能够通过将函数和算法与已知运行时的图进行比较来确定它们的运行时复杂性(例如，将插入排序运行时的图与<code class="fe ls lt lu lv b">y=n^2</code>进行比较)。除了确定运行时的复杂性，这种方法还可以用来比较不同算法的速度。只需几行代码，您就可以快速看到您选择的算法在处理大量数据时的运行速度！</p><h1 id="3b07" class="md me iq bd mf mg ot mi mj mk ou mm mn jw ov jx mp jz ow ka mr kc ox kd mt mu bi translated">资源</h1><ul class=""><li id="11ac" class="nm nn iq ky b kz mv lc mw lf oy lj oz ln pa lr nr ns nt nu bi translated"><a class="ae kv" href="https://matplotlib.org/stable/tutorials/introductory/pyplot.html" rel="noopener ugc nofollow" target="_blank"> Pyplot教程— Matplotlib 3.4.2文档</a></li><li id="7258" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><a class="ae kv" href="https://numpy.org/doc/stable/reference/generated/numpy.polyfit.html" rel="noopener ugc nofollow" target="_blank"> numpy.polyfit — NumPy v1.20手册</a></li><li id="8557" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><a class="ae kv" href="https://www.programiz.com/python-programming/examples/fibonacci-recursion" rel="noopener ugc nofollow" target="_blank">使用递归(programiz.com)显示斐波那契数列的Python程序</a></li><li id="e8da" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><a class="ae kv" href="https://www.tutorialspoint.com/How-to-find-all-possible-permutations-of-a-given-string-in-Python#:~:text=To%20find%20all%20possible%20permutations%20of%20a%20given%20string%2C%20you,in%20the%20iterable%20as%20tuples." rel="noopener ugc nofollow" target="_blank">如何在Python中找到给定字符串的所有可能排列？(tutorialspoint.com)</a></li><li id="ad55" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><a class="ae kv" href="https://adrianmejia.com/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/" rel="noopener ugc nofollow" target="_blank">每个程序员都应该知道的8个时间复杂性|阿德里安·梅希亚博客</a></li></ul></div></div>    
</body>
</html>