<html>
<head>
<title>Building a Stopwatch Android App Using Foreground Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用前台服务构建秒表Android应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-foreground-service-in-android-building-a-stopwatch-app-5a1da85d929f?source=collection_archive---------2-----------------------#2022-05-11">https://betterprogramming.pub/implementing-a-foreground-service-in-android-building-a-stopwatch-app-5a1da85d929f?source=collection_archive---------2-----------------------#2022-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9ffb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个简单的实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/49faeb5549e1193ead21e707cb755bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFMzwUb48RN_XjMV-Tt60A.png"/></div></div></figure><p id="36ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你有没有想过，一些像Spotify、Google Maps、Google Meet这样的应用，即使在用户/系统已经杀死了应用之后，它们是如何继续运行的？嗯，你猜对了，是因为前台服务。</p><p id="4f47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将构建一个简单的秒表应用程序，它将使用一个服务来支持所有的秒表功能。一旦应用程序进入后台，我们将把后台服务转换为前台服务，这样即使应用程序在后台，我们的秒表仍然可以工作。</p><p id="c208" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将实际构建的应用程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/46efc47336926ddeac3060592e862fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/1*N_LKAnOnWQnIDheHg6IW9A.gif"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="b41e" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">前台服务到底是什么？</h2><p id="f4a6" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">这就是Android官方文档所述:</p><blockquote class="mt mu mv"><p id="b021" class="kr ks mw kt b ku kv jr kw kx ky ju kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated">前台服务执行用户可以注意到的操作。</p><p id="4704" class="kr ks mw kt b ku kv jr kw kx ky ju kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated">前台服务显示一个<a class="ae na" href="https://developer.android.com/guide/topics/ui/notifiers/notifications" rel="noopener ugc nofollow" target="_blank">状态栏通知</a>，这样用户就能主动意识到你的应用程序正在前台执行一项任务，并且正在消耗系统资源。除非服务被停止或从前台删除，否则无法解除通知。</p></blockquote><p id="7069" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我给你说清楚一点。</p><p id="5de0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">任何服务都可以执行后台任务，只要你的应用对用户可见，这就没问题，但一旦应用被用户杀死或长时间闲置，Android可能会决定杀死进程，这将导致你的服务依次被杀死。</p><p id="d725" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们使用前台服务，确保我们的服务不会在应用程序处于后台时被Android杀死。</p><p id="f822" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于安全原因，前台服务总是需要显示一个通知，在任务完成之前不能被取消，以便用户知道后台正在发生什么</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/ff295332805ac3a8374510ec99720645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o4XyyKmPHcfldCM4YMU_MQ.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">前台服务的通知示例</p></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="7fc1" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">是时候构建秒表应用程序了</h2><p id="f516" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">是的，我们已经完成了理论，现在让我们建立应用程序。</p><p id="5d7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们添加使用前台服务所需的权限。</p><p id="fe48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在您的<code class="fe ng nh ni nj b">AndroidManifest.xml</code>中添加以下行</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d5ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是呈现秒表用户界面的布局文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="147c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们将开始构建<code class="fe ng nh ni nj b">StopwatchService</code>，它将处理秒表功能的核心逻辑。</p><p id="57a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建服务类别:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a977" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在需要让Android系统知道我们有一项服务。为此，我们将把它添加到应用程序标签下的<code class="fe ng nh ni nj b">AndroidManifest.xml</code> <em class="mw"> </em>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5f9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在<em class="mw"> StopwatchService.kt </em>中创建一些常量，帮助我们与服务进行通信:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="42ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">服务类要求我们覆盖两个函数。让我们现在做那件事。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e5a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从Android 8.0开始，我们需要创建一个通知通道。</p><p id="72ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同时，我们还将创建一个函数来访问系统的<code class="fe ng nh ni nj b">NotificationManager</code>以备将来使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8072" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们定义每个功能并设置它们的功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3709" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经成功实现了所有的功能，只要应用程序还活着，我们就可以使用这项服务来运行秒表。</p><p id="8627" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是现在让我们来实现允许我们构建、更新通知和启动/停止前台服务的功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cca5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">现在让我们使用MainActivity中的服务来使应用程序发挥作用</strong></p><p id="c458" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">定义两个广播接收机。一个负责接收秒表的状态，另一个负责接收经过的时间。</p><blockquote class="mt mu mv"><p id="ef98" class="kr ks mw kt b ku kv jr kw kx ky ju kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated"><em class="iq">广播接收器</em> ( <em class="iq">接收器</em>)是一个Android组件，允许您注册系统或应用程序事件。一旦事件发生，Android运行时会通知事件的所有注册接收者。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7f10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ng nh ni nj b">onResume</code>中，我们将以如下方式初始化<code class="fe ng nh ni nj b">BroadcastReceivers</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7ef0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">功能<code class="fe ng nh ni nj b">updateLayout</code>和<code class="fe ng nh ni nj b">updateStopwatchValue</code> <strong class="kt ir"> <em class="mw"> </em> </strong>用于用从广播接收器接收的适当值更新布局</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="39db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Android组件(服务、接收者、活动)可以通过<code class="fe ng nh ni nj b">startService(intent)</code>方法触发服务的执行。</p><p id="6144" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果调用了<code class="fe ng nh ni nj b">startService(intent)</code>方法，而服务尚未运行，则创建服务对象并调用服务的<code class="fe ng nh ni nj b">onCreate()</code>方法。</p><p id="42b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦<em class="mw">服务</em>被启动，就会调用<em class="mw">服务</em>中的<code class="fe ng nh ni nj b">onStartCommand(intent)</code>方法。它从<code class="fe ng nh ni nj b">startService(intent)</code> <strong class="kt ir"> </strong>调用中传递意向对象。</p><p id="6342" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们定义并添加将用于与服务通信的所有函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bb6b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ng nh ni nj b">onCreate</code>中点击按钮时触发适当的功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="72de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在对于最后一部分，我们需要分别从<code class="fe ng nh ni nj b">onPause</code>和<code class="fe ng nh ni nj b">onStart</code>调用<code class="fe ng nh ni nj b">moveToForeground</code>和<code class="fe ng nh ni nj b">moveToBackground</code>函数来适时地启动和停止前台服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="93c8" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">项目存储库</h2><div class="nm nn gp gr no np"><a href="https://github.com/rithikjain/stopwatch-app" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">GitHub-rithikjain/stopwatch-app:一个利用前台服务的简单秒表应用程序。</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kp np"/></div></div></a></div><h2 id="1d70" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">几个指针</h2><ul class=""><li id="5b02" class="oe of iq kt b ku mo kx mp la og le oh li oi lm oj ok ol om bi translated">如果从后台调用startService，它将抛出一个<code class="fe ng nh ni nj b">IllegalStateException</code>并崩溃</li><li id="cf12" class="oe of iq kt b ku on kx oo la op le oq li or lm oj ok ol om bi translated">您可以使用<code class="fe ng nh ni nj b">startForegroundService</code>(或<code class="fe ng nh ni nj b">ContextCompat.startForegroundService</code>)让系统了解您的服务性质。如果这样做，您需要在5秒钟内从您的服务类调用<code class="fe ng nh ni nj b">startForeground</code>方法</li><li id="a717" class="oe of iq kt b ku on kx oo la op le oq li or lm oj ok ol om bi translated">ID为0的前台服务将无法工作(我对此一无所知，不得不花费数小时调试为什么我的前台服务无法工作)</li></ul><p id="2942" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>