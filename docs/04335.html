<html>
<head>
<title>Smart Contracts: Don’t Reinvent the Wheel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合同:不要重新发明轮子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/smart-contracts-dont-reinvent-the-wheel-63cee4370d19?source=collection_archive---------19-----------------------#2020-04-06">https://betterprogramming.pub/smart-contracts-dont-reinvent-the-wheel-63cee4370d19?source=collection_archive---------19-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a6d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">总是使用OpenZeppelin</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ad5c74153288166c961554959178694e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4G_wNGRDJvj25hQmbo7r0w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔恩·卡塔赫纳在<a class="ae ky" href="https://unsplash.com/s/photos/wheel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="a56e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要误解我，从头开始写智能合同是一个很好的学习工具。从头到尾让自己创建一个符合ERC20的合同是理解其背后逻辑的最佳方式之一。</p><p id="e118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，对于生产应用程序，不要重新发明轮子。</p><p id="2af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<a class="ae ky" href="https://openzeppelin.com/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>这样的库受到以太坊开发社区的广泛关注。它们不断被更新和审查。他们也可以公开访问，易于使用。当这样的库存在时，创建自己的库是没有意义的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cd6e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">正在导入OpenZeppelin</h1><p id="22f7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="mz">注意:更高的版本是可用的，但我们使用的是库版本2.5.0，因为它是运行Solidity版本0.5.x的OpenZeppelin contracts的最后一个版本</em></p><p id="54c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将OpenZeppelin安装到您的项目中，请运行以下命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="09af" class="nf md it nb b gy ng nh l ni nj">npm install @openzeppelin/contracts@2.5.0 --save</span></pre><p id="40d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会将所有智能合约下载到<code class="fe nk nl nm nb b">node_modules/</code>中。</p><p id="b697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装后，您可以将智能合同导入您自己的合同。这是一个在智能合约中导入OpenZeppelin <code class="fe nk nl nm nb b">ERC20</code>令牌合约的示例:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="dcec" class="nf md it nb b gy ng nh l ni nj">pragma solidity ^0.5.5;</span><span id="b41a" class="nf md it nb b gy nn nh l ni nj">import "@openzeppelin/contracts/token/ERC20/ERC720.sol";</span><span id="a1d8" class="nf md it nb b gy nn nh l ni nj">contract MyContract is ERC20 { ...</span></pre><p id="671a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一些来自OpenZeppelin的有用的令牌、数学、实用程序和可拥有的契约，您可以轻松地在项目中实现它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d158" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代币</h1><h2 id="cbdf" class="nf md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated"><strong class="ak"> ERC20 </strong></h2><p id="e4f5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有六个公开可用的函数<code class="fe nk nl nm nb b">ERC20</code>契约需要实现，以及两个事件。通过导入OpenZeppelin的<code class="fe nk nl nm nb b">ERC20</code>契约，你不需要自己实现这些。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ERC20令牌示例。</p></figure><p id="79ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nb b">ERC20Detailed</code>用于初始化令牌的名称、符号和小数，但是如果您的项目不需要命名的<code class="fe nk nl nm nb b">ERC20</code>令牌，就不需要它们。</p><h2 id="0257" class="nf md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">ERC721</h2><p id="bf0a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为<code class="fe nk nl nm nb b">ERC721</code>标记是唯一的，所以通常使用一个结构和一个结构数组来存储它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ERC721令牌示例。</p></figure><p id="eb76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个契约继承了所有九个函数和三个事件，并公开了创建新的<code class="fe nk nl nm nb b">Person</code>令牌的能力，而不是实现所有九个函数和三个事件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a67d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数学</h1><h2 id="aa1e" class="nf md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated"><strong class="ak">安全数学</strong></h2><p id="827a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在大多数现代编程语言中，算术运算的安全性是要考虑的，所以很少考虑它们的实现。然而，在坚固性方面，溢出和下溢存在安全风险。</p><p id="a8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nb b"><a class="ae ky" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol" rel="noopener ugc nofollow" target="_blank">SafeMath</a></code>是一个库，它通过在超出整数数据类型的界限时恢复事务来确保安全的算术运算。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SafeMath示例。</p></figure><p id="ca8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nb b">using</code>语句向编译器表明，契约正在使用在<code class="fe nk nl nm nb b">SafeMath</code>中为<code class="fe nk nl nm nb b">uint</code>操作定义的函数。不使用算术运算符(<code class="fe nk nl nm nb b">+</code>、<code class="fe nk nl nm nb b"> -</code>、<code class="fe nk nl nm nb b">*</code>、<code class="fe nk nl nm nb b"> /</code>、<code class="fe nk nl nm nb b">%</code>)，而是使用函数<code class="fe nk nl nm nb b">add()</code>、<code class="fe nk nl nm nb b">sub()</code>、<code class="fe nk nl nm nb b">mul()</code>、<code class="fe nk nl nm nb b">div()</code>和<code class="fe nk nl nm nb b">mod()</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0717" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实用工具</h1><h2 id="7678" class="nf md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated"><strong class="ak"> SafeCast </strong></h2><p id="75d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将<code class="fe nk nl nm nb b">uint</code>变量转换为较小的整数可能会有溢出的风险。使用<code class="fe nk nl nm nb b">SafeCast</code>将较大的整数数据类型转换为较小的整数数据类型(即<code class="fe nk nl nm nb b">uint256</code>到<code class="fe nk nl nm nb b">uint8</code>)。</p><p id="634c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可与仅在<code class="fe nk nl nm nb b">uint256</code>上执行算术运算的<code class="fe nk nl nm nb b">SafeMath</code>一起使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SafeCast示例。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cee8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">所有权</h1><h2 id="6468" class="nf md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated"><strong class="ak">可拥有的</strong></h2><p id="e1b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时需要限制对智能协定中某些函数的访问，以便只有协定的所有者才能成功调用它们。一个常见的模式是在函数定义中使用<code class="fe nk nl nm nb b">onlyOwner</code>修饰符。OpenZeppelin的<code class="fe nk nl nm nb b">Ownable</code>合同为你做了这些，而不是你自己编码这个模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可拥有的例子。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8594" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="db61" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于编码标准的最基本的实现，总是使用库。在这一点上，业界最好的是OpenZeppelin。这比你自己重新发明轮子更安全、更快捷、更清洁、更容易。</p></div></div>    
</body>
</html>