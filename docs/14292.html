<html>
<head>
<title>Heroku Alternatives? Here’s How to Deploy Web Apps to AWS EC2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Heroku替代品？以下是如何将Web应用程序部署到AWS EC2的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/migrate-from-heroku-to-aws-ec2-756328d8e58a?source=collection_archive---------9-----------------------#2022-11-24">https://betterprogramming.pub/migrate-from-heroku-to-aws-ec2-756328d8e58a?source=collection_archive---------9-----------------------#2022-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e4ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过为您的Python和PHP web应用程序设置连续部署工作流，从Heroku迁移您的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e73bcf939961d578433af7636c8c8c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lhiVr8bUKGc8lklrOKcEw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">鲁拜图·阿扎德在<a class="ae kv" href="https://unsplash.com/s/photos/3d-logo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="39e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Heroku反对在2022年11月28日之前部署网络应用的免费层。如果你像我一样有许多低流量的投资组合项目，在一个VPS上托管它们要比为一个PaaS解决方案(如AWS Elastic Beanstalk或DigitalOcean的应用平台)按应用付费更便宜。</p><p id="346e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您是第一次部署Flask或Django web应用程序，以前没有使用过Heroku，这篇文章也将帮助您部署应用程序。</p><p id="a6ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在遵循本教程之后，当你将提交推送到GitHub时，你的VPS将创建一个新的Docker映像，在其中安装你的应用程序的依赖项，然后自己运行那个容器；你可以通过浏览器监控这一切。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/82ed6b2cc9a3763e7ec99c078796c85c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GmQe3qthSGgJFT5a5V8Q0w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">持续部署机制</p></figure><h2 id="fc57" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">目录</h2><ol class=""><li id="f3d9" class="mm mn iq ky b kz mo lc mp lf mq lj mr ln ms lr mt mu mv mw bi translated"><strong class="ky ir">启动并配置一个AWS EC2实例<br/> </strong> 1.1。安装EBS卷<br/> 1.2。重启后自动挂载存储卷<br/> 1.3。在AWS仪表板上设置入站规则以打开端口</li><li id="2488" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><strong class="ky ir">安装并配置Docker <br/> </strong> 2.1。安装<br/> 2.2。将您的用户添加到Docker组<br/> 2.3。让Docker使用附带的卷</li><li id="1704" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><strong class="ky ir">安装并配置ca cover<br/></strong>3.1。配置DNS记录<br/> 3.2。安装顶盖<br/> 3.3。配置ca cover<br/>3.4。安装您的第一个应用程序</li><li id="24ed" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">将你的应用从Heroku移动到新的服务器<br/>4.1。创建一个GitHub Repo(如果不存在)<br/> 4.2。将你的Python应用【Dockerize。在ca cover<br/>4.4上创建新的应用程序。设置持续部署工作流</li><li id="1c9a" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><strong class="ky ir">迁移一个PostgreSQL数据库<br/> </strong> 5.1。从Heroku <br/> 5.2出口。迁移数据库</li><li id="67fc" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><strong class="ky ir">多余的</strong> <br/> 6.1。PHP应用呢？<br/> 6.2。我的app不是“无状态”怎么办？</li></ol><h1 id="a139" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">1.启动并配置AWS EC2实例</h1><p id="01cc" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们将从在AWS仪表板上创建EC2实例开始。如果你需要的话，你可以跟随像<a class="ae kv" href="https://docs.aws.amazon.com/efs/latest/ug/gs-step-one-create-ec2-resources.html" rel="noopener ugc nofollow" target="_blank">这个</a>这样的向导。出于我的需要，我在t2.micro上选择了Ubuntu 22.04，并添加了第二个20 GB容量的弹性块存储(EBS)卷。</p><h2 id="63fb" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">1.1.连接EBS卷</h2><p id="8fc1" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">一旦您通过ssh进入您的服务器，使用以下命令列出所有分区。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="2ac3" class="nv lu iq nr b be nw nx l ny nz">lsblk -o NAME,FSTYPE,LABEL,SIZE,MOUNTPOINT</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/9c02e80f5c07b10a2b0c7cd06f95b8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9h9EzSAoGwYnf9qs1KOJg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安装EBS卷之前的分区</p></figure><p id="1495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于上面的输出，我们想要挂载名为<code class="fe ob oc od nr b">xvdb</code>的20GB卷；但是我们在<code class="fe ob oc od nr b">xvdb</code>下没有看到FSTYPE，就像我们在<code class="fe ob oc od nr b">xvda</code>下看到的一样，这意味着这是一个空卷。因此，我们将首先在其上创建一个文件系统。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="99c6" class="nv lu iq nr b be nw nx l ny nz">sudo mkfs -t xfs /dev/xvdb</span></pre><p id="5c10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，让我们创建一个装载点:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="b51a" class="nv lu iq nr b be nw nx l ny nz">sudo mkdir /mnt/ebs1</span></pre><p id="12aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以将EBS卷挂载到这个目录，如下所示。请注意，我们已经在上面的卷名前添加了<code class="fe ob oc od nr b">/dev/</code>:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="ebf4" class="nv lu iq nr b be nw nx l ny nz">sudo mount -t auto -v /dev/xvdb /mnt/ebs1</span></pre><p id="f1dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们再次运行以下命令:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="853a" class="nv lu iq nr b be nw nx l ny nz">lsblk -o NAME,FSTYPE,LABEL,SIZE,MOUNTPOINT</span></pre><p id="2d82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到EBS卷被装载到<code class="fe ob oc od nr b">/mnt/ebs1</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/11ff6aa40230d9e7f408752558ab3248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqVTOeO46Oxv2y8Es7qIyw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">挂载EBS卷后的分区</p></figure><h2 id="dc9f" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">1.2.重新启动后自动装载存储卷</h2><p id="e0df" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">重新启动后，EBS卷将不再保持装载状态，除非我们将其设置为automount。我们可以通过编辑<code class="fe ob oc od nr b">/etc/fstab</code>来实现。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="79ce" class="nv lu iq nr b be nw nx l ny nz">sudo nano -w /etc/fstab</span></pre><p id="5638" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用前面看到的<code class="fe ob oc od nr b">lsblk</code>命令替换挂载点和文件系统类型之后，添加下面一行。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="2b8a" class="nv lu iq nr b be nw nx l ny nz">/dev/xvdb /mnt/ebs1 xfs defaults 0 2</span></pre><p id="160f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">重要提示:</strong>如果您在<code class="fe ob oc od nr b">fstab</code>中有无效配置，您的服务器将无法启动！在使用下面的命令重新启动之前，请验证这些设置。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="b922" class="nv lu iq nr b be nw nx l ny nz">sudo findmnt --verify</span></pre><p id="ad4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您没有看到成功消息，请检查您的<code class="fe ob oc od nr b">/etc/fstab</code>文件是否有错误。否则，您可以重新启动:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="74a3" class="nv lu iq nr b be nw nx l ny nz">sudo reboot</span></pre><p id="67c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…并查看您的卷已装入:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="7498" class="nv lu iq nr b be nw nx l ny nz">lsblk -o NAME,FSTYPE,LABEL,SIZE,MOUNTPOINT</span></pre><p id="3431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您遇到有关您的卷的任何错误，请参见<a class="ae kv" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-using-volumes.html" rel="noopener ugc nofollow" target="_blank">EBS卷的AWS指南</a>。</p><h2 id="3b20" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">1.3.在AWS仪表板上设置入站规则以打开端口</h2><p id="0fdb" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">现在，我们需要通过创建入站规则来打开一些端口。在AWS仪表板上选择EC2实例id，选择security选项卡，然后单击Security组的ID。然后单击“编辑入站规则”按钮，至少为端口22、80、443、3000和5432添加TCP规则。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/08eaca6adcfeab59060150ae6b8cfc08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zh0DVWWjMbEE0LmeUKVs7w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">EC2实例的安全组的入站规则</p></figure><p id="aae9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ob oc od nr b">CapRover</code>设置之后，您可以删除TCP/3000规则。如果您计划使用需要其他端口的应用程序，您也可以在此处添加它们。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h1 id="cea7" class="nc lu iq bd lv nd on nf ly ng oo ni mb jw op jx me jz oq ka mh kc or kd mk nm bi translated">2.安装和配置Docker</h1><p id="358d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们将使用CapRover，它是一个平台即服务(Paas)，来处理自动部署、Nginx配置等等。CapRover将使用Docker容器来部署你的应用程序，所以我们需要先安装Docker。</p><h2 id="b0e5" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">2.1.装置</h2><p id="9219" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">首先，运行以下命令来更新apt软件包索引并安装软件包，以允许apt通过HTTPS使用存储库:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="3e6c" class="nv lu iq nr b be nw nx l ny nz">sudo apt-get update<br/>sudo apt-get install ca-certificates curl gnupg lsb-release</span></pre><p id="459c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，添加Docker的官方GPG密钥并设置存储库:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="f795" class="nv lu iq nr b be nw nx l ny nz">sudo mkdir -p /etc/apt/keyrings<br/>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg<br/>echo \<br/>  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \<br/>  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></pre><p id="54a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以安装Docker引擎了。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="4831" class="nv lu iq nr b be nw nx l ny nz">sudo apt-get update<br/>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span></pre><p id="a32d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果运行以下命令时一切顺利:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="c019" class="nv lu iq nr b be nw nx l ny nz">sudo docker run hello-world</span></pre><p id="b99e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…您应该会看到下面的消息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/d0b07394ab7797ae52d0c3a3f9852aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTSMnqioIBQzdbklof0LqQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">名为hello-world的docker映像的成功输出</p></figure><p id="8d43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您遇到任何错误，请参见<a class="ae kv" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">本指南</a>。</p><h2 id="336b" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">2.2.将您的用户添加到Docker组</h2><p id="a97c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">如果您想避免在每个docker命令前键入<code class="fe ob oc od nr b">sudo</code>,运行下面的命令将您的系统用户添加到docker组并激活对组的更改。如果需要，用你的用户名替换ubuntu。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="84e9" class="nv lu iq nr b be nw nx l ny nz">sudo usermod -aG docker ubuntu<br/>newgrp docker</span></pre><h2 id="55bf" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">2.3.让Docker使用附带的卷</h2><p id="d7d6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">如果您希望docker映像保存在挂载的卷中，请运行以下命令:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="f9df" class="nv lu iq nr b be nw nx l ny nz">sudo mkdir -p /etc/systemd/system/docker.service.d<br/>sudo nano /etc/systemd/system/docker.service.d/docker-storage.conf</span></pre><p id="49ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在用您之前创建的路径更新<code class="fe ob oc od nr b">/mnt/ebs1</code>之后放置以下内容。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="de82" class="nv lu iq nr b be nw nx l ny nz"># For docker after 17.06-ce:<br/>[Service]<br/>ExecStart=<br/>ExecStart=/usr/bin/dockerd -H fd:// --data-root="/mnt/ebs1"</span></pre><p id="8fea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重启Docker:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="88a8" class="nv lu iq nr b be nw nx l ny nz">sudo systemctl daemon-reload<br/>sudo systemctl restart docker</span></pre><p id="19d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">旧的Docker目录将不再使用，因此您可以通过以下方式删除它:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="d352" class="nv lu iq nr b be nw nx l ny nz">sudo rm -rf /var/lib/docker</span></pre><p id="cccc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有任何问题，请参见此处的<a class="ae kv" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank"> Docker安装指南</a>。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h1 id="3641" class="nc lu iq bd lv nd on nf ly ng oo ni mb jw op jx me jz oq ka mh kc or kd mk nm bi translated">3.安装和配置CapRover</h1><p id="e501" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">首先，您需要选择主域，该主域将在其子域中部署web应用程序。主域本身可以是子域。对于这个例子，我将使用<code class="fe ob oc od nr b">test.cansin.net</code>作为我的主域，应用程序将安装在子域，如<code class="fe ob oc od nr b">flaskapp.test.cansin.net</code>。</p><h2 id="45fe" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">3.1.配置DNS记录</h2><p id="17fd" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">为了实现这一点，我们需要设置两个DNS记录:一个用于子域，另一个通配符用于所有二级子域。在谷歌域名，这些记录如下，它应该类似于你的注册。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/3d3d8ebe132c607bd5159e0c8a72632b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FAQzC9iPjDYKePh6PC18BQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用测试子域及其二级子域的DNS记录示例</p></figure><p id="277c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将34.238.245.243替换为EC2实例的公共IP地址，将“test”替换为您想要使用的子域。</p><p id="1874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想使用根域名(如example.com)并将应用程序部署为一级子域(如flaskapp.example.com)，则删除第一个A记录中的“test”并将其留空(或替换为example.com，具体取决于注册商)，然后删除。test”从第二条记录中删除，只留下星号(*)。</p><h2 id="1992" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">3.2.安装盖罩</h2><p id="7440" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">现在我们准备安装我们的PaaS，CapRover。它就像运行任何其他Docker容器一样:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="5afc" class="nv lu iq nr b be nw nx l ny nz">docker run -p 80:80 -p 443:443 -p 3000:3000 -v /var/run/docker.sock:/var/run/docker.sock -v /captain:/captain caprover/caprover</span></pre><p id="fc34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果安装成功，您将看到下面的消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/8726896729935cdd981ba6847eabfea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2HMD5gF86ySzHEhbtEJ0A.png"/></div></div></figure><p id="fd05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用带有防火墙的现有VPS，您将在此步骤中收到一个错误。如果是这样，请配置您的防火墙打开我们在第1.3节AWS仪表板上打开的端口。更多信息参见<a class="ae kv" href="https://caprover.com/docs/get-started.html" rel="noopener ugc nofollow" target="_blank">ca cover安装文档</a>。</p><h2 id="feb9" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">3.3.配置CapRover</h2><p id="1da5" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">现在，我们可以通过导航到EC2实例的IP地址的端口3000来登录CapRover仪表板。使用默认密码captain42登录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/75fdff6af9d2583201f01fa1117cf1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-u8M_w0yPwgF9GDSfm5--w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CapRover登录屏幕</p></figure><p id="00d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">登录后，您将看到以下配置您的主域的表单。输入你的域名，点击“更新域名”,这将引导你再次登录。当你这样做时，点击“启用HTTPS”，然后“强制HTTPS”让certbot给你一个SSL证书，并根据需要更新它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/7c76b6d668d09f10e0015e6194edd797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*d3Oied6gge0_tQE-5dT-Wg.png"/></div></figure><p id="94b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，从设置菜单中更改默认密码。</p><h2 id="f8c5" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">3.4.安装您的第一个应用程序</h2><p id="34a1" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们将从一键式应用程序选项开始启动PostgreSQL服务器。当您在应用程序页面上选择此选项时，您将看到大量可供选择的应用程序，只需一次点击即可部署。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/18c09fffd59fbf72f96dc10158193719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5KbouY2Jijl7copfreZ8xA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一键式应用程序页面</p></figure><p id="885c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，搜索PostgreSQL，选择它，给它一个应用程序名称，然后单击部署。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/f7f64f54a8c3accd73dfe3e96a6b3452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qKgYMiThJYKsbFcR9GV1A.png"/></div></div></figure><p id="7c2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在安装了PostgreSQL的服务器上创建一个docker映像。</p><p id="d422" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要导入我们正在迁移的应用程序的现有数据库，我们需要从本地计算机连接到此数据库。因此，我们需要将这个容器的端口5432映射到我们主机上的同一个端口。为此，转到应用程序页面，选择我们创建的PostgreSQL应用程序，找到添加端口映射按钮，并在两个框中添加一个5432规则，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/9ccf99c3584178f477447c9b8f04f7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsIPnHOKy26XTZjb8-IkZw.png"/></div></div></figure><p id="70ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，点击保存和更新。</p><p id="650c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第5节中，我们将把一个数据库移到这个容器中。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h1 id="38c4" class="nc lu iq bd lv nd on nf ly ng oo ni mb jw op jx me jz oq ka mh kc or kd mk nm bi translated">4.将你的应用移动到新服务器</h1><p id="ee3d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">在本节中，我们将部署<a class="ae kv" href="https://github.com/cansinacarer/flask-migration-demo" rel="noopener ugc nofollow" target="_blank">这个测试瓶应用程序</a>，并建立一个持续的部署工作流，以便在我们向GitHub推送每个提交时重新部署它。</p><p id="1a40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您是第一次部署应用程序，您可以遵循这些相同的步骤。</p><h2 id="e34c" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">4.1.创建一个GitHub Repo(如果不存在)</h2><p id="772c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">这部分将取决于您现有的工作流程。如果您已经将GitHub存储库连接到Heroku帐户进行自动部署，那么您可以跳过这一节。</p><p id="6ef8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的项目在GitHub上还没有资源库，请创建一个。如果你之前使用的是Heroku git，你可以从那里拉出来，推到新的GitHub库。</p><h2 id="8d21" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">4.2.将您的Python应用程序Dockerize(参见PHP的结尾)</h2><p id="e07e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我更喜欢使用docker文件，而不是CapRover本机Captain定义文件，以防将来我想使用不同的容器服务。在存储库的根目录下添加一个名为Dockerfile的文件，其内容如下。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="b01f" class="nv lu iq nr b be nw nx l pa nz">FROM ubuntu:22.04<br/>RUN apt-get -y update<br/>RUN apt-get install --no-install-recommends -y python3 python3-dev python3-venv python3-pip python3-wheel build-essential libmysqlclient-dev &amp;&amp; \<br/> apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*<br/>ADD . /my-flask-app<br/>WORKDIR /my-flask-app<br/>RUN pip install -r requirements.txt<br/>EXPOSE 5000<br/><br/># Ensure that the python outputs are streamed to the terminal<br/>ENV PYTHONUNBUFFERED=1<br/><br/># Run the app with gunicorn on port 5000 with 4 workers, using gevent worker<br/>CMD ["gunicorn","-b", "0.0.0.0:5000", "-w", "4", "-k", "gevent", "--worker-tmp-dir", "/dev/shm", "wsgi:app"]</span></pre><p id="7bb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次CapRover在容器中部署你的app的新实例，Docker都会使用这些指令用Ubuntu 22.04创建一个新的镜像，在requirements.txt中安装python和依赖项，然后用gunicorn从<code class="fe ob oc od nr b">wsgi.py</code>文件运行app函数。</p><p id="466a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你的<code class="fe ob oc od nr b">requirements.txt</code>中，你将需要一些版本的<code class="fe ob oc od nr b">gevent</code>和<code class="fe ob oc od nr b">gunicorn</code>。在这里看我的测试app的<a class="ae kv" href="https://github.com/cansinacarer/flask-migration-demo/blob/main/requirements.txt" rel="noopener ugc nofollow" target="_blank"> requirements.txt。</a></p><p id="d4ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于PHP应用程序，请参见本文最后一节的docker文件示例。</p><h2 id="fb23" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">4.3.在CapRover上创建一个新的应用程序</h2><p id="e964" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">在CapRover的应用程序页面，为你的应用程序选择一个名字，然后点击创建新应用程序。此名称将成为此应用的默认子域(<a class="ae kv" href="http://flaskapp.test.cansin.net/" rel="noopener ugc nofollow" target="_blank">http://flaskapp.test.cansin.net</a>)，但你也可以为此应用配置其他域。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/33019e369f63408de344f456eb6bb13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oquKEZtcjdILMG-igu2Xdw.png"/></div></div></figure><p id="2224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们希望这个应用程序在flaskapp.cansin.net。在我们的注册商网站上为flaskapp添加了一个A记录后，我们点击我们刚刚创建的应用程序，并键入新的域名，如下所示；然后点击连接新域。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/10a7ae2cb6dc40991024141dcd60fadd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pf-6q-T6EK5dlFu7Rif7Sw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将新域解析到您的应用程序</p></figure><p id="3882" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后单击“启用HTTPS”，选择“强制HTTPS”选项，在“容器HTTP端口”字段中键入5000(除非您在docker文件中选择了另一个端口)，然后单击“保存并更新”。这将自动完成必要的Nginx和certbot配置，不过如果需要，您可以在这里添加您的自定义Nginx规则。</p><p id="8e08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果需要设置数据库或SMTP凭据等环境变量，可以在应用程序配置页面上输入这些变量。</p><h2 id="a4e5" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">4.4.设置持续部署工作流</h2><p id="a870" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">现在，您可以在Deployment选项卡上部署您的应用程序了。虽然您可以在这个选项卡上简单地上传文件，但本文将描述一个工作流，它将使您推送到GitHub的提交触发CapRover自动从GitHub部署。</p><h2 id="912c" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated"><strong class="ak"> 4.4.1。授权CapRover访问您的存储库</strong></h2><p id="2868" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">如果您使用的是公共存储库，可以跳过这一步。如果您的存储库是私有的，CapRover将需要一个SSH密钥向GitHub认证并查看您的存储库。虽然从技术上讲，您可以在这里粘贴GitHub帐户的SSH密钥，但是更安全的方法是使用<a class="ae kv" href="https://docs.github.com/en/developers/overview/managing-deploy-keys#deploy-keys" rel="noopener ugc nofollow" target="_blank"> deploy keys </a>，它只提供对特定存储库的访问。</p><p id="7368" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>作为使用部署密钥的替代方法，您可以创建一个新的GitHub用户，将其作为协作者添加到您将部署到CapRover的存储库中，为该用户创建SSH密钥，并将这些密钥添加到该用户的GitHub帐户中。然后，您可以将该用户的SSH密钥用于所有存储库。</p><p id="6063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">创建部署密钥</strong></p><p id="bf7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的服务器上运行以下命令来创建ssh密钥。在下一个提示中为该密钥选择一个自定义名称，然后再次按Enter键跳过设置密码短语。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="7f0b" class="nv lu iq nr b be nw nx l ny nz">ssh-keygen -t ed25519 -C "Caprover Flask Deployment Key"</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/a310ac87b44f8d849519b152db4acd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuCFzA3eNdrQq9DrHB3C3Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建SSH密钥</p></figure><p id="4216" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用以下命令启动ssh-agent之后，将这个密钥添加到它。用您在上一步中选择的键名替换<code class="fe ob oc od nr b">flaskApp</code>。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="7d4e" class="nv lu iq nr b be nw nx l ny nz">eval "$(ssh-agent -s)"<br/>ssh-add ~/.ssh/flaskApp</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/26819941a1cf0abfef52db4fb138881b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1S6ZtjjU_3VQZS2wTFyEg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">向ssh代理添加SSH密钥</p></figure><p id="3829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您的公钥和私钥创建在<code class="fe ob oc od nr b">~/.ssh/flaskApp.pub</code>和<code class="fe ob oc od nr b">~/.ssh/flaskApp</code>文件中，除非您更改了上面的示例代码。如果您选择了不同的路径或文件名，请相应地更改下面的命令。</p><p id="3984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">给GitHub和CapRover添加部署密钥</strong></p><p id="4851" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行以下命令并复制您的公钥:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="7cd1" class="nv lu iq nr b be nw nx l ny nz">cat ~/.ssh/flaskApp.pub</span></pre><p id="9d5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在GitHub上打开你的存储库页面，进入设置→部署密钥，点击添加部署密钥。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/f42fbd937e9098238db3edaf9cef6f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAaUJHx5LKqP-r4SnFjNJg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如何向GitHub存储库添加部署密钥</p></figure><p id="c812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在这里添加您的公钥的内容，并单击Add key。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/967c7e213eed095557dda3e56a6f7b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aI847SvHq5u2ewnlOf_6Vg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将部署密钥保存到存储库中</p></figure><p id="76ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，运行以下命令并复制您的私钥:</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="351d" class="nv lu iq nr b be nw nx l ny nz">cat ~/.ssh/flaskApp</span></pre><p id="31f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在CapRover上，点击你的应用程序，进入部署选项卡。在“方法3”部分，添加您的存储库URL、分支名称和您复制的私钥(即，默认情况下，您的id_rsa文件的内容)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/c07b9a67324c1db3adec2202a85ce6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJ7Ibe9xPeLgTBPshtDANA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在CapRover的deployment选项卡上添加您的部署密钥</p></figure><p id="b81e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击保存和更新，然后强制构建。</p><p id="6d2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">设置GitHub Webhook </strong></p><p id="b4b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在CapRover上保存GitHub凭证后，API端点的URL将出现在存储库URL的上方。复制此URL。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/0372b3151d28d645089332e57cb61ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G61NIW0_LoMvMShZz61LzQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CapRover接口上的API端点URL</p></figure><p id="f98b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在GitHub上打开你的存储库页面，进入设置→ Webhooks，将这个URL粘贴到Payload URL字段，点击添加webhook。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/bd7a3ea8f30f36718c2d3f7758b6baf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hd79l4M4FaUFJdFLz3mPLg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">向GitHub存储库添加webhook</p></figure><p id="eeb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在向您的存储库提交一个commit，并在CapRover上的Deployment选项卡上查看您的应用程序的构建日志。您应该会看到下面的成功消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/fceac33cca768ebfc7adac42377d1187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5McKlAuc3nXqprR2ZLzOQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示“构建已成功完成！”在CapRover的构建日志部分。</p></figure><p id="12d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。现在每次你推GitHub，webhook都会触发CapRover部署你的应用的新版本。如果有任何错误，比如缺少依赖项，您将能够在构建日志部分看到它们。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h1 id="8729" class="nc lu iq bd lv nd on nf ly ng oo ni mb jw op jx me jz oq ka mh kc or kd mk nm bi translated">5.迁移PostgreSQL数据库</h1><p id="14b8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">本例中的测试应用程序使用了Heroku的PostgreSQL数据库。我们将把它迁移到我们在第3节中创建的PostgreSQL服务器上。</p><h2 id="8e95" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">5.1.从Heroku出口</h2><p id="bbf3" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">在Heroku上选择您的应用程序后，您的数据库的连接字符串可以在<code class="fe ob oc od nr b">Settings → Config Vars → DATABASE_URL</code>中找到。如果您从另一个平台迁移，请在应用程序的环境变量或设置中找到数据库连接字符串。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="e799" class="nv lu iq nr b be nw nx l ny nz">postgres://qzhzootzdkvfdi:19813b61af59c9711899304ccfe2db0cb0c402f317e90754788eb0770ff6aeb9@ec2-54-163-34-107.compute-1.amazonaws.com:5432/db4ejdhq0vnp5r</span></pre><p id="454d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用找到的凭证使用pgAdmin连接到该数据库。右键单击服务器组并选择注册→服务器，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/879d04184905113e13427be77fb4084e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBwyPkQwdeSuLLa-oQqQQA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如何在pgAdmin 4上添加新的PostgreSQL服务器连接</p></figure><p id="753d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后填写Heroku提供的凭证，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/a9527d95f093e68c041a7d8389b116f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRl2dKc_9zDOub7JIVL5bQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">连接到pgAdmin 4上的Heroku PostgreSQL服务器</p></figure><p id="5a2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该服务器上将有许多数据库，我们将在我们的连接字符串中找到这个数据库:db4ejdhq0vnp5r。然后，右键单击它，选择备份，并保存备份文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/1cc2ed85aa68983bfbe2fc1d82325cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*g-MRrupj1b5yJcyuNbUVUw.png"/></div></figure><h2 id="6986" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">5.2.迁移数据库</h2><p id="13e3" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">在您创建的PostgreSQL应用程序的应用程序配置菜单中，在CapRover上找到您的新PostgreSQL数据库凭据，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/74b7b3c943e7cfbbf1e05b6bc8639119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzp235b0o2KT5sbM60GRgg.png"/></div></div></figure><p id="fad5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用这些凭证和EC2实例的IP地址，使用pgAdmin连接到这个数据库，就像我们对Heroku上的数据库所做的那样。不要忘记使用EC2服务器的IP或主机名来更改主机名。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/671d6c334193006f59037fea2972c6bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFw7qh6VdmPrs0x-_y94DA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用pgAdmin 4连接到新的PostgreSQL服务器</p></figure><p id="428e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您连接到新服务器时，它将出现在左栏中。展开它，右键单击登录/组角色。然后选择创建→登录/组角色，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/ee4873d42c427a37b857508892df486e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRb5854wjkne-4PZHNiYeA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从pgAdmin 4向PostgreSQL数据库添加新用户</p></figure><p id="d938" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在常规选项卡中设置用户名，在定义选项卡中设置其密码，启用“可以登录吗？”选项，然后单击保存。</p><p id="0bc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以为我们的应用程序创建一个数据库，方法是右键单击Databases并选择Create →Database，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/ac73281af0991438de7972882e520340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJTQVSat7eNRy-aSZABrdw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从pgAdmin 4向PostgreSQL服务器添加新数据库</p></figure><p id="b35d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在General选项卡中，设置数据库名称，并从下拉列表中选择新创建的用户作为所有者，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/762c6a9029349b4dc983b12366bcb21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JykuO6y0Iqgr84BODJFVcw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在pgAdmin 4上选择PostgreSQL数据库所有者</p></figure><p id="5e4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有一个要继续使用的数据库，请右键单击您创建的数据库并选择restore。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/78555b91b9373247508abb467f059d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*jkZQF8GCeIw1sHAprFVZIA.png"/></div></figure><p id="ec7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后选择您之前使用备份选项从Heroku PostgreSQL数据库导出的文件，然后单击Restore按钮。然后右键单击数据库，选择Properties，然后选择Default Privileges选项卡。在这里，请确保您新创建的用户被分配了必要的权限。</p><p id="52fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您的web应用程序应该能够连接到这个新数据库。不要忘记更改您的应用程序设置，以将其连接到新的数据库。</p><p id="4e60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个测试应用程序使用硬编码的凭证(不再使用)，但是您应该在CapRover上的Settings → Config Var中将它们设置为环境变量，并让您的应用程序从环境变量中读取凭证。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h1 id="0ff1" class="nc lu iq bd lv nd on nf ly ng oo ni mb jw op jx me jz oq ka mh kc or kd mk nm bi translated">6.临时演员</h1><h2 id="0a41" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">6.1.PHP应用呢？</h2><p id="c777" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">如果您的应用程序是无状态的，除了使用不同的docker文件之外，您可以按照相同的步骤来部署您的应用程序。下面的例子将把你的存储库的内容放入容器的/var/www目录中，假设你希望这个应用程序在那个域的根目录中。</p><pre class="kg kh ki kj gt nq nr ns bn nt nu bi"><span id="2f2e" class="nv lu iq nr b be nw nx l pa nz">FROM php:7.3-apache-stretch<br/><br/>COPY . /var/www/html<br/>WORKDIR /var/www/html<br/>EXPOSE 80</span></pre><h2 id="50c4" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">6.2.我的app不是“无状态”怎么办？</h2><p id="f9b5" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">持续部署工作流只适合只做计算的无状态应用。如果存储库中的文件在应用程序运行时发生变化(例如，如果应用程序将上传的文件存储在子文件夹中)，则下次从存储库中部署应用程序时，这些文件将被覆盖。为了防止这种情况，您可以部署一次您的应用程序，并在CapRover上为您的应用程序启用“具有持久数据”选项。点击阅读更多关于CapRover <a class="ae kv" href="https://caprover.com/docs/persistent-apps.html" rel="noopener ugc nofollow" target="_blank">上持久应用的信息。</a></p></div></div>    
</body>
</html>