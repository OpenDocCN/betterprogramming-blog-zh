<html>
<head>
<title>Atomic Pointers in Go 1.19</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 1.19中的原子指针</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/atomic-pointers-in-go-1-19-cad312f82d5b?source=collection_archive---------0-----------------------#2022-08-06">https://betterprogramming.pub/atomic-pointers-in-go-1-19-cad312f82d5b?source=collection_archive---------0-----------------------#2022-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="96d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻松管理共享资源</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7c27bdd62c8bd31767b22fbd3157b18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMvESigFKZzGXXbMNyqyFw.png"/></div></div></figure><p id="9ee9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“原子的”，在计算机编程中，指的是一次执行一个操作。Objective-C具有原子属性，它确保从不同的线程安全地读写属性。</p><p id="eb98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Objective-C中，它用于不可变类型。这是因为不可变类型实际上是为了改变它而“重新创建”的。换句话说，在代码中更改不可变类型不会导致编译器抛出错误。</p><p id="86f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，当你这样做时，它将实例化一个新的对象。一个例子是Go的<code class="fe ln lo lp lq b">append</code>函数，它在数组容量满的时候生成一个新的数组。在Obj-C中，原子属性将确保操作一个接一个地执行，以防止线程同时访问一个内存地址。因为Go是多线程的，所以它也支持原子操作。</p><p id="4729" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Go 1.19引入了新的原子类型。我最喜欢的附加功能是<code class="fe ln lo lp lq b">atomic.Pointer</code>，它为<code class="fe ln lo lp lq b">atomic.Value</code>提供了一个圆滑的替代方案。这也很好地展示了泛型是如何增强开发人员体验的。</p><h1 id="979f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">原子。指针</h1><p id="c77c" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated"><code class="fe ln lo lp lq b">atomic.Pointer</code>是通用类型。与<code class="fe ln lo lp lq b">Value</code>不同，它不需要声明你的存储值来访问它。下面是定义和存储指针的代码块:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="7c88" class="ms ls iq lq b gy mt mu l mv mw">package main</span><span id="a936" class="ms ls iq lq b gy mx mu l mv mw">import (<br/> "fmt"<br/> "net"<br/> "sync/atomic"<br/>)</span><span id="f1d0" class="ms ls iq lq b gy mx mu l mv mw">type <strong class="lq ir">ServerConn</strong> struct {<br/> Connection net.Conn<br/> ID string<br/> Open bool<br/>}</span><span id="e5a7" class="ms ls iq lq b gy mx mu l mv mw">func main() {<br/> p := atomic.Pointer[<strong class="lq ir">ServerConn</strong>]{}</span><span id="481e" class="ms ls iq lq b gy mx mu l mv mw"> s := ServerConn{ ID : "first_conn"}<br/> p.<strong class="lq ir">Store</strong>( &amp;s )</span><span id="0746" class="ms ls iq lq b gy mx mu l mv mw"> fmt.Println(p.Load()) // Will display value stored.<br/>}</span></pre><p id="98a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将变量<code class="fe ln lo lp lq b">p</code>实例化为一个结构文字。然后，我继续将变量<code class="fe ln lo lp lq b">s</code>的指针存储在<code class="fe ln lo lp lq b">p</code>中，<code class="fe ln lo lp lq b">s</code>表示一个服务器连接。瞧，我们已经向原子性迈出了第一步。</p><p id="7ec8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过将变量存储为原子值，我们将确保不会同时访问内存地址。例如，如果一个程序同时被读取和写入，映射将导致它死机。锁是防止这些混乱发生的好方法，原子操作也是如此。</p><h1 id="1010" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">我的原子指针用例</h1><p id="2940" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">为了构建前面提供的代码块，我将使用一个<code class="fe ln lo lp lq b">atomic.Pointer</code>每13秒重新创建一个数据库连接。我将从编写一个用于每10秒记录一次连接ID的函数开始。</p><p id="1ae9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的机制是查看新的连接对象是否已经被传播。然后我将定义一个内联函数来每13秒改变一次连接。下面是代码的样子:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="744f" class="ms ls iq lq b gy mt mu l mv mw">...</span><span id="a73d" class="ms ls iq lq b gy mx mu l mv mw">func ShowConnection(p * <strong class="lq ir">atomic.Pointer</strong>[ServerConn]){</span><span id="e90d" class="ms ls iq lq b gy mx mu l mv mw">for {<br/>  time.Sleep(10 * time.Second)<br/>  fmt.Println(p, <strong class="lq ir">p.Load()</strong>)<br/> }<br/> <br/>}</span><span id="cfa0" class="ms ls iq lq b gy mx mu l mv mw">func main() {</span><span id="c734" class="ms ls iq lq b gy mx mu l mv mw"> c := make(chan bool)<br/> p := <strong class="lq ir">atomic.Pointer</strong>[ServerConn]{}<br/> s := ServerConn{ ID : "first_conn"}<br/> p.Store( &amp;s )</span><span id="b75d" class="ms ls iq lq b gy mx mu l mv mw"> go ShowConnection(&amp;p)</span><span id="3b66" class="ms ls iq lq b gy mx mu l mv mw"> go func(){<br/>   for {<br/>    time.Sleep(13 * time.Second)<br/>    newConn := ServerConn{ ID : "new_conn"}<br/>    p.<strong class="lq ir">Swap</strong>(&amp;newConn)<br/>   }<br/>  }()</span><span id="f204" class="ms ls iq lq b gy mx mu l mv mw">  &lt;- c<br/>}</span></pre><p id="e5f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ShowConnection</code>作为Goroutine调用。内联函数将实例化一个<code class="fe ln lo lp lq b">ServerConn</code>对象，并与当前的连接对象交换。这仅用指针是可能的，然而，它需要实现一个“锁定-解锁”系统。</p><p id="4597" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">原子包对此进行了抽象，并确保每次加载和保存都一个接一个地进行。这是一个简单的例子，也是一个不常见的用例。另外，<code class="fe ln lo lp lq b">atomic.Pointer</code>的使用可能是一种“过度工程化”的情况，因为我的程序的Goroutines在不同的时间间隔运行。我将使用Go的<code class="fe ln lo lp lq b">race</code>标志来查看我的程序的Goroutines是否同时访问同一个内存地址。我还将重写上面的代码，使用指针代替<code class="fe ln lo lp lq b">atomic.Pointer</code>。</p><h1 id="6e45" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">数据竞赛</h1><p id="cb85" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">“当两个goroutines同时访问同一个变量，并且其中至少有一个访问是写操作时，就会发生数据竞争。”为了快速验证数据竞争，您可以执行带有标志<code class="fe ln lo lp lq b">race</code>的<code class="fe ln lo lp lq b">go run</code>来执行测试。为了演示原子类型如何防止这种情况，我重写了上面的例子，使用经典的Go指针。下面是代码的样子:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="8b20" class="ms ls iq lq b gy mt mu l mv mw">package main</span><span id="b843" class="ms ls iq lq b gy mx mu l mv mw">import (<br/> "fmt"<br/> "net"<br/> "time"<br/>)</span><span id="7871" class="ms ls iq lq b gy mx mu l mv mw">type ServerConn struct {<br/> Connection net.Conn<br/> ID string<br/> Open bool<br/>}</span><span id="5851" class="ms ls iq lq b gy mx mu l mv mw">func ShowConnection(p * <strong class="lq ir">ServerConn</strong>){</span><span id="e0d3" class="ms ls iq lq b gy mx mu l mv mw">for {<br/>  time.Sleep(10 * time.Second)<br/>  fmt.Println(p, *p)<br/> }<br/> <br/>}</span><span id="df6c" class="ms ls iq lq b gy mx mu l mv mw">func main() {</span><span id="ef08" class="ms ls iq lq b gy mx mu l mv mw"> c := make(chan bool)<br/> p :=  ServerConn{ ID : "first_conn"}</span><span id="9152" class="ms ls iq lq b gy mx mu l mv mw"> go ShowConnection(<strong class="lq ir">&amp;p</strong>)</span><span id="bcf8" class="ms ls iq lq b gy mx mu l mv mw"> go func(){<br/>   for {<br/>    time.Sleep(13 * time.Second)<br/>    newConn := ServerConn{ ID : "new_conn"}<br/>    <strong class="lq ir">p = newConn</strong><br/>   }<br/> }()</span><span id="139d" class="ms ls iq lq b gy mx mu l mv mw"> &lt;- c<br/>}</span></pre><p id="49f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">检查数据竞争后，终端上的输出如下:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="e501" class="ms ls iq lq b gy mt mu l mv mw">cheikh@cheikh-s5-1110:~/go/src/atomic$ go run -race main_classic.go <br/>&amp;{&lt;nil&gt; first_conn false} {&lt;nil&gt; first_conn false}<br/>==================<br/>WARNING: DATA RACE<br/>Write at 0x00c000074570 by goroutine 8:<br/>  main.main.func1()<br/>      /home/cheikh/go/src/atomic/main_classic.go:37 +0x6f</span><span id="06b1" class="ms ls iq lq b gy mx mu l mv mw">Previous read at 0x00c000074570 by goroutine 7:<br/>  runtime.convT()<br/>      /usr/lib/go-1.18/src/runtime/iface.go:321 +0x0<br/>  main.ShowConnection()<br/>      /home/cheikh/go/src/atomic/main_classic.go:19 +0x65<br/>  main.main.func2()<br/>      /home/cheikh/go/src/atomic/main_classic.go:30 +0x39</span><span id="7786" class="ms ls iq lq b gy mx mu l mv mw">Goroutine 8 (running) created at:<br/>  main.main()<br/>      /home/cheikh/go/src/atomic/main_classic.go:33 +0x16e</span><span id="a233" class="ms ls iq lq b gy mx mu l mv mw">Goroutine 7 (running) created at:<br/>  main.main()<br/>      /home/cheikh/go/src/atomic/main_classic.go:30 +0x104<br/>==================<br/>&amp;{&lt;nil&gt; new_conn false} {&lt;nil&gt; new_conn false}<br/>&amp;{&lt;nil&gt; new_conn false} {&lt;nil&gt; new_conn false}<br/>&amp;{&lt;nil&gt; new_conn false} {&lt;nil&gt; new_conn false}</span></pre><p id="3231" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管这两个函数以不同的时间间隔运行，但它们会在某个点发生冲突。具有原子指针的代码没有返回关于数据竞争的反馈。这是一个原子指针在多线程环境中表现更好的例子。</p><h1 id="94a1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="0737" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">Go原子类型是管理共享资源的一种简单方法。它消除了不断实现互斥体来控制资源访问的需要。</p><p id="b500" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这并不意味着互斥体已经过时，因为在某些操作中仍然需要它们。</p><p id="0237" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总之，<code class="fe ln lo lp lq b">atomic.Pointer</code>是将原子内存原语引入程序的好方法。这是一种简单的方法来防止数据竞争，而不需要花哨的互斥代码。下面是这篇文章中使用的代码的链接。</p><div class="my mz gp gr na nb"><a href="https://go.dev/doc/articles/race_detector" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">数据竞争检测器——Go编程语言</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">数据竞争是并发系统中最常见也是最难调试的错误类型之一。当…时，会发生数据竞争</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">go.dev</p></div></div><div class="nk l"><div class="nl l nm nn no nk np kp nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://github.com/cheikhshift/medium_examples/tree/main/atomic" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">medium _ examples/原子at main cheikh shift/medium _ examples</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">中型文章的代码示例。在GitHub上创建一个帐户，为cheikhshift/medium_examples开发做贡献。</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np kp nb"/></div></div></a></div></div></div>    
</body>
</html>