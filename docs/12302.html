<html>
<head>
<title>Custom Pull to Refresh in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jetpack撰写中自定义提取以刷新</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-pull-to-refresh-in-jetpack-compose-9abc01472851?source=collection_archive---------4-----------------------#2022-05-26">https://betterprogramming.pub/custom-pull-to-refresh-in-jetpack-compose-9abc01472851?source=collection_archive---------4-----------------------#2022-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3293" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建直观的Android用户界面</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1bdfa13d3d0c3a3f4d056e8a37556572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Ruxz4k-yc27gH3chiLG1g.png"/></div></div></figure><p id="f06d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">拉至刷新是一种常见的设计模式，用户使用它来刷新项目列表。在Jetpack Compose中，我们可以使用伴奏者库来实现大多数材质设计应用程序中的默认实现。</p><p id="94a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是考虑到这种设计模式的交互性，有很多机会可以用动画和反馈来取悦用户。</p><p id="e82d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天，我们将学习如何在compose中实现自定义拉取来刷新动画。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/f8b7bde5bcfc4eb3c1ba6ef2cac38e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*eQi2wBw5z5rvO2Rp.gif"/></div></figure><h1 id="c1db" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">基本实现</h1><p id="57d0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们将基于可用的伴奏库<a class="ae ml" href="https://google.github.io/accompanist/swiperefresh/" rel="noopener ugc nofollow" target="_blank">进行构建。</a></p><p id="9ea8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它确实有默认的实现，但是它也提供了根据我们的喜好进行定制的自由。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="5781" class="mr lp iq mn b gy ms mt l mu mv">// Add the library to your project<br/>implementation "com.google.accompanist:accompanist-swiperefresh:0.24.9-beta"</span></pre><p id="f275" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将创建一个可组合的包装器，在这里我们将实现我们的自定义逻辑并用一个示例UI填充它。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="4a98" class="mr lp iq mn b gy ms mt l mu mv">CustomPullToRefresh(  <br/>    isRefreshing = isRefreshing,  <br/>    onRefresh = { refresh() }  <br/>) {  <br/>    LazyColumn {  <br/>        items(100) { index -&gt;  <br/>            ListItem(index = index)  <br/>        }  <br/>    }<br/>}</span></pre><p id="e53e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe mw mx my mn b">CustomPullToRefresh</code> composable中，我们可以从伴奏库中添加<code class="fe mw mx my mn b">SwipeRefresh</code> composable。</p><p id="8cca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe mw mx my mn b">indicator</code>参数中，我们可以决定自定义指示器应该是什么样子。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="3ba5" class="mr lp iq mn b gy ms mt l mu mv"><a class="ae ml" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a>  <br/>fun CustomPullToRefresh(  <br/>    modifier: Modifier = Modifier,  <br/>    isRefreshing: Boolean,  <br/>    onRefresh: () -&gt; Unit,  <br/>    content: <a class="ae ml" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a> () -&gt; Unit,  <br/>) {<br/> ...<br/> SwipeRefresh(  <br/>     modifier = modifier,  <br/>     state = pullState,  <br/>     onRefresh = onRefresh,  <br/>     refreshTriggerDistance = trigger,  <br/>     indicator = { state, triggerSize -&gt;  <br/>   // Custom indicator logic here<br/>     }  <br/> ) {<br/>  // List content<br/> }<br/>}</span></pre><p id="5d6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mw mx my mn b">indicator</code>参数接受一个可组合的函数，并传递我们可以用来构建自定义指示器的数据。</p><p id="f308" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mw mx my mn b">state</code>变量保存用户滑动了多远以及列表是否还在刷新等数据，而<code class="fe mw mx my mn b">triggerSize</code>是触发区域有多大。</p><p id="2da4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于我的自定义实现，我使用三种状态来构建UI:</p><ul class=""><li id="30a5" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ne nf ng nh bi translated"><code class="fe mw mx my mn b">isSwiping</code>(用户当前正在刷卡)</li><li id="34e7" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated"><code class="fe mw mx my mn b">willRefresh</code>(用户已经刷过了<code class="fe mw mx my mn b">triggerSize</code>。此时的释放将触发刷新)</li><li id="07a0" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated"><code class="fe mw mx my mn b">isRefreshing</code>(正在刷新)</li></ul><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="3cd4" class="mr lp iq mn b gy ms mt l mu mv">val willRefresh = state.indicatorOffset.roundToInt() &gt; triggerPx  <br/>  <br/>offset = when {  <br/>    willRefresh -&gt; triggerPx.roundToInt() + (state.indicatorOffset.roundToInt() * .1f).roundToInt() // willRefresh<br/>    state.isRefreshing -&gt; triggerPx.roundToInt() // isRefreshing<br/>    else -&gt; state.indicatorOffset.roundToInt()  //isSwiping<br/>}</span></pre><p id="4708" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用这些状态向用户提供反馈。在这种情况下，我们使用它们来确定指示器的偏移。</p><p id="a5ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一个版本将导致刷新，我们可以通过将偏移弹出一点点来告知用户。当达到这一点时，我们还可以添加一些触觉反馈。</p><p id="69c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当刷新发生时，我们将偏移值保持在触发位置。如果这些都不成立，我们使用<code class="fe mw mx my mn b">state.indicatorOffset</code>。</p><p id="debe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于测试，我们可以使用这些值来创建一个基本指标:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="4f0b" class="mr lp iq mn b gy ms mt l mu mv">Box(  <br/>    modifier = Modifier  <br/>        .offset { IntOffset(0, -indicatorPx.roundToInt()) }  <br/>        .offset { IntOffset(y = offset, x = 0) }  <br/>        .background(  <br/>            color = when {  <br/>                willRefresh -&gt; Color.Magenta  <br/>                state.isRefreshing -&gt; Color.Green  <br/>                else -&gt; Color.DarkGray  <br/>            },  <br/>        )  <br/>        .size(indicator)  <br/>)</span></pre><p id="9144" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将创建一个正方形，它随着偏移量移动，并根据我们定义的三种状态改变颜色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/001f227d41aa5aa2def207f3e3e3aad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*5KIwSXP-WEibKkli.gif"/></div></figure><h1 id="4725" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">奇特的实现</h1><p id="7009" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">基本的实现有助于理解如何扩展<code class="fe mw mx my mn b">SwipeRefresh</code>，但是它不应该出现在生产中的应用程序中。</p><p id="fbe9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们将使用这些状态加上一些动画来创建一个我们可以引以为豪的更好的实现。</p><h1 id="dbc0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">动画显示列表内容</h1><p id="a3d1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">列表占据了屏幕的很大一部分，所以动画可以给用户更多的反馈，告诉他们将要刷新列表。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="0389" class="mr lp iq mn b gy ms mt l mu mv">val scale by animateFloatAsState(  <br/>    targetValue = if (willRefresh) .95f else 1f,  <br/>    animationSpec = spring(  <br/>        dampingRatio = Spring.DampingRatioMediumBouncy,  <br/>    )  <br/>)  <br/>  <br/>Box(modifier = Modifier  <br/>    .scale(scale)  <br/>    .offset { IntOffset(x = 0, y = animatedOffset) }  <br/>    .clip(RoundedCornerShape(topStart = 20.dp, topEnd = 20.dp))  <br/>    .fillMaxSize()  <br/>    .background(MaterialTheme.colors.surface)  <br/>) {  <br/>    content()  <br/>}</span></pre><p id="167b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在使用偏移量来下移列表。这有两个主要目的。</p><p id="0059" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，将内容下移，这样我们就可以在上面的空间放置我们的动画了。</p><p id="0dc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二，当<code class="fe mw mx my mn b">willRefresh</code>为真时，我们得到弹出偏移的视觉反馈的好处。</p><p id="fe71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些其他的添加是当<code class="fe mw mx my mn b">willRefresh</code>为真时添加一个缩放动画，并在列表顶部添加圆角。</p><h1 id="ee27" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">自定义刷新指示器</h1><p id="3759" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">对于我心目中的指标，我希望它在用户下拉列表时从列表后面显示出来。</p><p id="7a47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出于这个原因，我将该指标添加到列表后面的<code class="fe mw mx my mn b">SwipeRefresh</code>内容中。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="830f" class="mr lp iq mn b gy ms mt l mu mv">FancyRefreshAnimation(  <br/>    modifier = Modifier  <br/>        .align(Alignment.TopCenter)  <br/>        .fillMaxWidth(),  <br/>    isRefreshing = { pullState.isRefreshing },  <br/>    willRefresh = { offset &gt; triggerPx },  <br/>    offsetProgress = { min(animatedOffset / triggerPx, 1f) }  <br/>)</span></pre><p id="831f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此时，想象力和创造力开始发挥作用，您可以使用compose提供的动画工具来制作一些漂亮的东西。</p><p id="6414" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个选择是，如果你有一个设计团队或者擅长创作动画，你可以在这里实现一个定制的<a class="ae ml" href="https://github.com/airbnb/lottie/blob/master/android-compose.md" rel="noopener ugc nofollow" target="_blank">洛蒂</a>动画。</p><p id="d57d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的例子中，我只是做了一些圆形的彩色盒子，并在刷新时旋转它们。您可以在这里找到<code class="fe mw mx my mn b">FancyRefreshAnimation</code>可组合的<a class="ae ml" href="https://github.com/sinasamaki/LoadingAnimation/blob/master/app/src/main/java/com/sinasamaki/loadinganimation/FancyRefreshAnimation.kt" rel="noopener ugc nofollow" target="_blank"/>以及剩余的<a class="ae ml" href="https://github.com/sinasamaki/LoadingAnimation" rel="noopener ugc nofollow" target="_blank">示例项目</a>。</p><p id="a9eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读，祝你好运！</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="78b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nu">原载于</em><a class="ae ml" href="https://sinasamaki.com/post/2022-05-26-pull-to-refresh/" rel="noopener ugc nofollow" target="_blank"><em class="nu">https://sinasamaki.com</em></a><em class="nu">。</em></p></div></div>    
</body>
</html>