<html>
<head>
<title>Python’s GIL vs. C++ With Mutexes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的GIL与带互斥体的C++</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pythons-gil-vs-c-with-mutexes-301b244e42?source=collection_archive---------6-----------------------#2022-11-24">https://betterprogramming.pub/pythons-gil-vs-c-with-mutexes-301b244e42?source=collection_archive---------6-----------------------#2022-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="965d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python的GIL通过一个多线程应用实例进行了解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ab206bb2a904df1039d02a85e5f7105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFTnQ-0nXmS4Rot_Y9QV_g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">免费视频上rawpixel.com的图片</p></figure><p id="40b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将关注Python的全局解释器锁——GIL。我们将讨论它是什么，为什么它在那里，它带来了什么优点/缺点，然后用一个实际的例子结束这篇文章。我们比较了Python和C++中的一个简单多线程应用程序，并展示了GIL如何有效地将任何多线程Python应用程序转变为单核应用程序。</p><h1 id="6a0e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是GIL？</h1><p id="2602" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">全局解释器锁，缩写为GIL，是Python中的中央解释器锁。执行Python字节码的任何一行都需要获得这个锁。这实质上使得任何Python程序都是单线程的——也就是说，如果我们有一个受CPU限制的程序，旋转多个线程不会使它更快。</p><h1 id="d417" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么引入了GIL？</h1><p id="9065" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python使用引用计数进行垃圾收集:它计算当前程序执行中对任何对象的引用数，当达到0时销毁该对象。我们会在多线程应用中遇到竞争情况，以及错误更新这些引用计数器的危险。一种解决方案是给每一个对象或每一组对象加锁，但这也带来了其他缺点，因此引入了一个单一的中央锁——GIL。</p><h1 id="e3e8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">GIL的优点和缺点是什么？</h1><p id="b1e6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，与其他垃圾收集方法相比，GIL易于实现，并且在单线程应用程序中表现非常好。此外，例如，非线程安全的C库可以更容易地被集成。所有这些都使得GIL非常适合Python，并帮助这种语言今天获得了流行。</p><p id="c5ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，你可能已经从上面的字里行间看出，GIL不仅有优势，也有劣势。特别是，它本质上把任何Python程序变成了单线程程序。这是巨大的，尤其是在当今世界，越来越多的应用被并行化，机器配备了越来越多的计算能力。</p><p id="d32a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于为什么GIL没有被删除，我不想评论更多，除了它有它的缺点和优点，如上所述。如果你感兴趣，更多信息请点击<a class="ae ky" href="https://realpython.com/python-gil/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="f69d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">行动中的GIL</h1><p id="1263" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在让我们从理论上实际测试一下上面描述的东西。为此，我们实现了一个简单的多线程程序，共同计数到100K。我们在Python和C++中分别做了一次——显示了这样的C++程序在使用更多线程时变得更快，因为使用了多个内核，而Python不是这样。</p><p id="4644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Python代码:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="b614" class="mx lw it mt b be my mz l na nb">import threading<br/><br/>MAX_COUNT = 50000<br/><br/>counter = 0<br/>lock = threading.Lock()<br/><br/># Function which iteratively increases the global variable counter up to max_count.<br/>def count_to(max_count):<br/>    global counter<br/>    for _ in range(max_count):<br/>        lock.acquire()<br/>        counter += 1<br/>        lock.release()<br/><br/><br/># Initialize two counter threads.<br/>t1 = threading.Thread(target=count_to, args=(MAX_COUNT,))<br/>t2 = threading.Thread(target=count_to, args=(MAX_COUNT,))<br/># Start them.<br/>t1.start()<br/>t2.start()<br/># Join them, i.e. wait for them to finish.<br/>t1.join()<br/>t2.join()<br/><br/>print(f"Counting done, reached: {counter}")</span></pre><p id="f361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义一个函数<code class="fe nc nd ne mt b">count_to(N)</code>，它迭代地增加一个全局变量计数器到<code class="fe nc nd ne mt b">N</code>，同时保持一个锁。注意，我们必须对counter使用global关键字，而不是对lock使用，是因为后者是可变的(比较<a class="ae ky" href="https://medium.com/@hrmnmichaels/variable-scopes-in-python-f32c7c640715" rel="noopener">这篇文章</a>)。然后，我们用参数50K启动两个线程运行这个函数。因此，总的来说，我们期望<code class="fe nc nd ne mt b">counter</code>最终等于100K，事实就是如此。</p><p id="23a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，即使对于Python来说，在前面介绍了GIL之后，我们仍然需要锁定:GIL只保证在每个时间步长只有一个Python线程被执行——但是不能保证上下文切换何时发生。特别是，增量操作符在Python中不是原子的——因此，如果我们运气不好，解释器可能会决定在这个操作中切换上下文，产生错误的最终结果。</p><p id="5be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公平地说，对于这个简单的例子，即使有许多线程，并且计数到相对较高的数字时，我也不能强制这种行为。然而，不手动锁定相互代码和资源是危险的，也是错误的。很容易想象更复杂的场景，其中错误的行为实际上显示。我们可以通过人为分割和减慢执行来强制执行，例如:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="f454" class="mx lw it mt b be my mz l na nb">tmp = counter<br/>tmp += 1<br/>time.sleep(0.000001)<br/>counter = tmp</span></pre><p id="cc2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相应的C++代码如下所示:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="d5ad" class="mx lw it mt b be my mz l na nb">#include &lt;iostream&gt;<br/>#include &lt;mutex&gt;<br/>#include &lt;thread&gt;<br/><br/>constexpr int kMaxCount = 50000;<br/><br/>int counter = 0;<br/>std::mutex counter_mutex;<br/><br/>// Function which iteratively increases the global variable counter up to<br/>// max_count.<br/>void countTo(int max_count) {<br/>  for (int i = 0; i &lt; max_count; i++) {<br/>    {<br/>      std::lock_guard&lt;std::mutex&gt; guard(counter_mutex);<br/>      counter++;<br/>    }<br/>  }<br/>}<br/><br/>int main() {<br/>  // Start two threads counting to kMaxCount.<br/>  std::thread t1(countTo, kMaxCount);<br/>  std::thread t2(countTo, kMaxCount);<br/>  // Join these threads (wait for them to finish).<br/>  t1.join();<br/>  t2.join();<br/>  std::cout &lt;&lt; "Counting done, reached: " &lt;&lt; counter;<br/>  return 0;<br/>}</span></pre><h1 id="6d10" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">GIL导致的经济放缓</h1><p id="9a8c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了结束这篇文章，让我们更好地理解GIL的缺点，也就是我们上面的陈述:它将每个Python程序变成了单线程程序。</p><p id="3431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解这一点，我们修改了上面介绍的计数示例，不再使用全局变量，而是让每个函数自己计数:这模拟了一些CPU密集型、可并行化的应用程序——也就是说，我们不需要锁定对象。让我们从C++开始:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="c113" class="mx lw it mt b be my mz l na nb">#include &lt;chrono&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;mutex&gt;<br/>#include &lt;thread&gt;<br/>#include &lt;vector&gt;<br/><br/>constexpr int kMaxCount = 50000000;<br/>// Number of threads to employ.<br/>constexpr int kNumThreads = 1;<br/><br/>// Mock some CPU-heavy operation, i.e. simply count up to max_count.<br/>void countTo(int max_count) {<br/>  int counter = 0;<br/>  for (int i = 0; i &lt; max_count; i++) {<br/>    counter++;<br/>  }<br/>}<br/><br/>int main() {<br/>  auto t_start = std::chrono::high_resolution_clock::now();<br/>  // Create kNumThreads, start them and move them to a vector.<br/>  std::vector&lt;std::thread&gt; threads;<br/>  for (int i = 0; i &lt; kNumThreads; i++) {<br/>    std::thread t(countTo, kMaxCount / kNumThreads);<br/>    threads.push_back(std::move(t));<br/>  }<br/>  // Join all threads.<br/>  for (auto&amp; t : threads) {<br/>    t.join();<br/>  }<br/>  auto t_end = std::chrono::high_resolution_clock::now();<br/>  double elapsed_time_ms =<br/>      std::chrono::duration&lt;double, std::milli&gt;(t_end - t_start).count();<br/>  std::cout &lt;&lt; "Execution done, time elapased [ms[: " &lt;&lt; elapsed_time_ms;<br/>  return 0;<br/>}</span></pre><p id="546a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码运行需要大约90毫秒(在我的旧笔记本电脑上)。但是，当我们将线程数量增加到8和32时，所需的时间分别减少到24和18毫秒，即没有线性加速，并且回报递减，但计算机仍然可以有效地并行运行线程，特别是使用更多(所有可用)内核。</p><p id="fd9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将它与Python进行比较:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="32e0" class="mx lw it mt b be my mz l na nb">import threading<br/>import time<br/><br/>MAX_COUNT = 50000000<br/>NUM_THREADS = 1<br/>MS_PER_S = 1000<br/><br/><br/># Mock some CPU-heavy operation, i.e. simply count up to max_count.<br/>def count_to(max_count):<br/>    counter = 0<br/>    for _ in range(int(max_count)):<br/>        counter += 1<br/><br/>t_start = time.time()<br/><br/># Create NUM_THREADS threads, append to list and start them.<br/>threads = []<br/>for _ in range(NUM_THREADS):<br/>    t = threading.Thread(target=count_to, args=(MAX_COUNT / NUM_THREADS,))<br/>    threads.append(t)<br/>    t.start()<br/><br/># Join all threads.<br/>for t in threads:<br/>    t.join()<br/><br/>print(f"Execution done, time elapsed [ms]: {(time.time() - t_start) * MS_PER_S}")</span></pre><p id="27c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要大约1200毫秒来运行。将线程数增加到8和32会产生大约1500和大约1400毫秒→执行时间不会随着线程数的增加而减少。在这个例子中，GIL是有效的，它使得线程的数量变得无关紧要！因为所有线程都需要等待GIL锁，所以拥有多个内核没有任何优势。</p><p id="2c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢收听。我希望你喜欢这次短途旅行。请放弃下面的任何问题或评论！</p><p id="c75e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:在以前的版本中，我错误地声称Python中的增量操作符是原子的，因此我们不需要锁定。这是错误的。我为此道歉！</p></div></div>    
</body>
</html>