<html>
<head>
<title>How To Implement a TypeScript Web App With Clean Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用干净的架构实现TypeScript Web应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-a-typescript-web-app-with-clean-architecture-27c7eb745ab4?source=collection_archive---------0-----------------------#2022-08-05">https://betterprogramming.pub/how-to-implement-a-typescript-web-app-with-clean-architecture-27c7eb745ab4?source=collection_archive---------0-----------------------#2022-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="625d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何构建下一个web应用程序的详细指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/50bcc5dd4da99d9a664e9155157942cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SUOfdtc3hIG3mCSr"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">里卡多·维亚纳在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><pre class="kg kh ki kj gt kw kx ky kz aw la bi"><span id="5929" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">Table of Contents</strong></span><span id="c6d2" class="lb lc iq kx b gy lh le l lf lg"><a class="ae kv" href="#0cc9" rel="noopener ugc nofollow">Intro</a></span><span id="9c10" class="lb lc iq kx b gy lh le l lf lg"><a class="ae kv" href="#57c7" rel="noopener ugc nofollow">Getting Started</a><br/> —  <a class="ae kv" href="#585f" rel="noopener ugc nofollow">Layers of the architecture</a><br/> —  <a class="ae kv" href="#25ac" rel="noopener ugc nofollow">General File Structure</a><br/> —  <a class="ae kv" href="#a5a6" rel="noopener ugc nofollow">Defining an example application</a><br/> —  <a class="ae kv" href="#a7db" rel="noopener ugc nofollow">Writing your first entity and use case</a><br/> —  <a class="ae kv" href="#280d" rel="noopener ugc nofollow">Creating Data Sources</a><br/> —  <a class="ae kv" href="#a8bb" rel="noopener ugc nofollow">Dependency Injection (with a little help from Angular)</a><br/> —  <a class="ae kv" href="#96fd" rel="noopener ugc nofollow">Creating a UI component that interacts with a use case</a><br/> —  <a class="ae kv" href="#7297" rel="noopener ugc nofollow">Testing</a></span><span id="1c2b" class="lb lc iq kx b gy lh le l lf lg"><a class="ae kv" href="#9984" rel="noopener ugc nofollow">Closing Notes</a></span><span id="2a53" class="lb lc iq kx b gy lh le l lf lg"><a class="ae kv" href="#6910" rel="noopener ugc nofollow">References and Links</a></span></pre><p id="b9c6" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在本指南中，我将向你展示如何使用我在本文中创建的<a class="ae kv" href="https://medium.com/@aziznal/creating-the-ultimate-clean-architecture-template-for-typescript-projects-e53936269bb9" rel="noopener">的clean architecture模板编写你的应用程序。</a></p><div class="me mf gp gr mg mh"><a href="https://medium.com/@aziznal/creating-the-ultimate-clean-architecture-template-for-typescript-projects-e53936269bb9" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd ir gy z fp mm fr fs mn fu fw ip bi translated">为Typescript应用程序创建最终的干净架构模板</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">遵循干净架构原则创建基于层的typescript项目模板的指南</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div></div></a></div><p id="3ae1" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">为什么要清洁建筑？因为，根据你的应用程序的大小,“继续编码，希望不会出问题”的架构只能带你到这里！</p><blockquote class="mq mr ms"><p id="2d48" class="li lj mt lk b ll lm jr ln lo lp ju lq mu ls lt lu mv lw lx ly mw ma mb mc md ij bi translated">“走得快唯一的方法就是走得好。”—鲍伯·马丁</p></blockquote><h1 id="0cc9" class="mx lc iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">介绍</h1><p id="61b0" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">我认为我们在制作应用程序时过于依赖web框架。虽然他们处理了很多无聊的事情，但是他们夺走了我们对应用程序的控制权。</p><p id="60b0" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我制作了一个项目模板，通过将应用程序的不同层隔离到包中，将控制权从框架中拿走。</p><p id="ca68" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">最后你会注意到，我们实际上根本不需要Angular，我们可以很容易地把它换成任何其他框架，这就是干净架构的全部要点。</p><h2 id="f274" class="lb lc iq bd my nt nu dn nc nv nw dp ng lr nx ny ni lv nz oa nk lz ob oc nm od bi translated"><strong class="ak">这种架构的优势</strong></h2><ul class=""><li id="728c" class="oe of iq lk b ll no lo np lr og lv oh lz oi md oj ok ol om bi translated">明确定义的层边界</li><li id="1d3e" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">由于缓存，构建和测试运行时间更快</li><li id="a815" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">由于松耦合，编写测试明显更容易</li><li id="51a4" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">不依赖于Web框架、数据库等细节</li><li id="18f0" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">促进代码重用</li></ul><h2 id="daaf" class="lb lc iq bd my nt nu dn nc nv nw dp ng lr nx ny ni lv nz oa nk lz ob oc nm od bi translated"><strong class="ak">缺点</strong></h2><ul class=""><li id="f38b" class="oe of iq lk b ll no lo np lr og lv oh lz oi md oj ok ol om bi translated">一些样板代码</li><li id="8752" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">需要经验(我在这篇文章里解释了一切，所以不用担心！)</li></ul><h1 id="57c7" class="mx lc iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">入门指南</h1><p id="3053" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">接下来的章节结构如下:</p><ul class=""><li id="c094" class="oe of iq lk b ll lm lo lp lr os lv ot lz ou md oj ok ol om bi translated"><a class="ae kv" href="#585f" rel="noopener ugc nofollow">架构的层次</a></li><li id="5e7d" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="#25ac" rel="noopener ugc nofollow">通用文件结构</a></li><li id="5ef3" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="#a5a6" rel="noopener ugc nofollow">定义示例应用</a></li><li id="a0f0" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="#a7db" rel="noopener ugc nofollow">编写我们的第一个实体、用例以及存储库</a></li><li id="5f27" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="#280d" rel="noopener ugc nofollow">创建数据源</a></li><li id="fd9a" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="#a8bb" rel="noopener ugc nofollow">依赖注入(在Angular的一点帮助下)</a></li><li id="1d39" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="#96fd" rel="noopener ugc nofollow">创建与用例交互的UI组件</a></li><li id="a01c" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="#7297" rel="noopener ugc nofollow">测试</a></li></ul><p id="d725" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在本文的底部，您会找到一个指向最终实现的链接。</p><h2 id="585f" class="lb lc iq bd my nt nu dn nc nv nw dp ng lr nx ny ni lv nz oa nk lz ob oc nm od bi translated">架构的层次</h2><p id="525f" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">我们将把我们的应用分成三个主要层:</p><ul class=""><li id="7678" class="oe of iq lk b ll lm lo lp lr os lv ot lz ou md oj ok ol om bi translated">核心:包含我们的实体、用例以及存储库接口。这是应用程序的核心(因此得名)。</li><li id="c441" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">数据:包含用于从本地和远程存储中检索数据的存储库的实现。这就是我们获取和存储数据的方式。</li><li id="efb9" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">表示层:这一层是用户看到我们的应用程序并与之交互的方式。它包含我们的角度或反应代码。</li></ul><p id="3b20" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">还有第四个辅助层，叫做DI(依赖注入)。这一层的工作是防止表示和数据之间的直接依赖，同时允许表示通过核心使用数据。</p><p id="0880" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">核心层包含我们的应用程序逻辑，并为数据层实现的存储库定义接口。用例使用存储库对数据进行操作，但是核心层并不关心数据来自哪里或者如何保存。它将责任委托给数据层，数据层决定数据是来自本地缓存还是远程API等。</p><p id="9812" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">接下来，表示层使用核心层的用例，并允许用户与应用程序进行交互。请注意，表示层不与数据层交互，因为表示层也不关心数据来自哪里。核心是将应用层联系在一起的东西。</p><p id="1e4c" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">下图解释了层之间和层内部的依赖关系。请注意，最终，一切都指向核心层。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/e8cda84099281dea4e65aa532d44e3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3E5OeWIGDoRzvjWBfESKFA.png"/></div></div></figure><p id="7bd1" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">至于数据流，一切都始于用户点击按钮或提交表单时的表现。演示调用一个用例，调用存储库中检索/存储数据的方法。这些数据是从本地数据源、远程数据源或者两者中检索的。存储库将调用的结果返回给用例，用例将其返回给表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/42209c527957c61a61ba5503fce22935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gANVjGjo0UwgBkAV4oe30Q.png"/></div></div></figure><p id="3ca7" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们将通过将存储库接口的实现从数据注入到核心层来实现这个数据流。通过这种方式，我们保持核心在控制中，因此满足了控制反转。这很令人满意，因为数据实现了Core定义的存储库。</p><h2 id="25ac" class="lb lc iq bd my nt nu dn nc nv nw dp ng lr nx ny ni lv nz oa nk lz ob oc nm od bi translated">通用文件结构</h2><p id="6a8b" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">在我们的主项目中，我们有一个名为<code class="fe ow ox oy kx b">packages</code>的文件夹，它为我们应用程序的每一层都有一个文件夹。我们将从在Core中创建一些东西开始。</p><h2 id="a5a6" class="lb lc iq bd my nt nu dn nc nv nw dp ng lr nx ny ni lv nz oa nk lz ob oc nm od bi translated">定义示例应用程序</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/c40b44a0d7b366f30be12b448c6bb862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FyXcE74d4OI3SJ7A"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@loic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Djim Loic </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="19d8" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">假设我们刚刚收到了对某个应用程序的以下要求:</p><ul class=""><li id="9579" class="oe of iq lk b ll lm lo lp lr os lv ot lz ou md oj ok ol om bi translated">创建一个向用户显示计数器的应用程序</li><li id="d9d3" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">用户应该能够创建/删除计数器</li><li id="d35b" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">用户应该能够通过按下按钮来增加/减少计数器</li><li id="7549" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">用户应该能够改变计数器的增量/减量</li><li id="3e54" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">用户应该能够将标签分配给计数器</li><li id="b631" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">用户应该能够通过标签过滤计数器</li><li id="1ee7" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">如果用户关闭应用程序并再次打开它，应该保存用户的计数器。</li></ul><p id="4e44" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">根据这些要求，我们可以说:</p><ul class=""><li id="a201" class="oe of iq lk b ll lm lo lp lr os lv ot lz ou md oj ok ol om bi translated">我们的主要实体是<code class="fe ow ox oy kx b">Counter</code></li><li id="a64b" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">我们的用例获取所有计数器，获取按标签过滤的计数器，递增，递减，分配标签，创建计数器，以及删除计数器</li><li id="94fe" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated">我们需要一种在本地存储数据的方式，即本地数据源</li></ul><h1 id="a7db" class="mx lc iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">编写你的第一个实体和用例</h1><p id="4051" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">现在我们开始有趣的部分。我们首先定义应用程序的单一实体:计数器。</p><p id="4ed5" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们将在名为counter的<code class="fe ow ox oy kx b">core/src/ </code>下创建一个新目录，并在其中创建另一个名为<code class="fe ow ox oy kx b">entities</code>的目录，在其中我们将创建一个名为<code class="fe ow ox oy kx b">counter.entity.ts</code>的文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/e36513e821a1b07463d98f17dda10bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*P1ra3QwaY-QdLjr3lKNZhA.png"/></div></figure><p id="120f" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">接下来，我们实现我们的用例。我们首先定义一种标准的方式来与我们的用例以及每个用例的依赖项进行交互。</p><p id="1f31" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们在<code class="fe ow ox oy kx b">core/src/base</code>下创建一个用例接口，并将其命名为<code class="fe ow ox oy kx b">usecase.interface.ts</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/471506ff95c39af0618a0d1ee444d379.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*UeQhKpuMCeTTmFUage5DvA.png"/></div></figure><p id="13ff" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在，每当我们创建一个新的用例时，我们让它实现<code class="fe ow ox oy kx b">Usecase</code>,其中它也必须定义它的返回类型。这迫使我们考虑用例的输出。</p><p id="06f4" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">让我们首先创建<code class="fe ow ox oy kx b">CreateCounterUsecase</code>。</p><p id="0b2e" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在core内部，在<code class="fe ow ox oy kx b">src/counter</code>下创建一个名为<code class="fe ow ox oy kx b">usecases</code>的文件夹，并在其中创建<code class="fe ow ox oy kx b">create-counter.ts</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="c01d" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">您将会看到用例的一个接口，在它的正下方，是该接口的一个实现。这样做有助于我们定义流入/流出用例的数据流，也使依赖注入变得轻而易举。</p><p id="4fb2" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">这个用例将需要一种方法来创建一个持续存在的计数器，这样我们的用户将能够做像刷新页面这样的事情，而不会丢失他们的计数器。为此，我们在<code class="fe ow ox oy kx b">src/counter/counter-repository.interface.ts</code>下创建一个存储库接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="40e2" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在，我们将这个存储库添加到我们的create-counter用例的依赖项中，并调用我们添加的这个新方法。我喜欢在构造函数中定义依赖关系，因为在进行依赖注入时提供依赖关系很简单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="5284" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">恭喜你！我们刚刚编写了我们的第一个实体、用例以及存储库接口！</p><p id="646b" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们还需要做最后一件事，那就是从核心包中导出我们的实体、用例以及存储库。我更喜欢使用<code class="fe ow ox oy kx b">index.ts</code>文件。我们是这样做的。</p><p id="68fd" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在<code class="fe ow ox oy kx b">core/src/counter</code>下，创建一个名为<code class="fe ow ox oy kx b">index.ts</code>的文件。这个文件将使用<code class="fe ow ox oy kx b">export</code>语句，通过一个非常简单的导入语句使计数器目录中的所有内容都可用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="544e" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">每当我们向<code class="fe ow ox oy kx b">counter</code>添加一个新文件，并且我们想要导出它，我们只需向这个文件添加一个导出语句。</p><p id="db14" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">接下来，更新<code class="fe ow ox oy kx b">core/src/index.ts</code>,以包含以下出口声明:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="b3cf" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们不需要再次更新这个文件，除非我们在<code class="fe ow ox oy kx b">counter</code>旁边添加另一个模块。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/450bd0d806cec4c2be8da3e39975336a.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*4C0TOInzrpuxPr2vBbUcDg.png"/></div></div></figure><p id="686a" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">运行以下命令来构建您的<code class="fe ow ox oy kx b">core</code>包，并将其分发给所有依赖于它的包:<code class="fe ow ox oy kx b">npx lerna run build &amp;&amp; npx lerna bootstrap</code>。如果是第一次使用模板，只需要运行bootstrap命令。</p><p id="151e" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在我们准备好下一步了。</p><h1 id="280d" class="mx lc iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">创建数据源</h1><p id="4686" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">我们需要实现core定义的存储库接口。我选择在一个名为data的包中做这件事。这样，我将我的业务规则隔离在<code class="fe ow ox oy kx b">core</code>包中，并将支持它们的数据源隔离在另一个包中。</p><p id="6cd7" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在<code class="fe ow ox oy kx b">packages/data/src</code>下，创建一个名为<code class="fe ow ox oy kx b">counter</code>的文件夹，并在其中创建一个名为<code class="fe ow ox oy kx b">counter-repository.impl.ts</code>的文件。文件扩展名是完全可选的。我只是喜欢使用这些扩展名使文件的内部更加清晰。这也使得寻找它们变得更加容易。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="74d4" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">您会注意到我已经将core中的所有内容作为关键字<code class="fe ow ox oy kx b">core</code>导入。这也是个人喜好。你可以使用析构导入从<code class="fe ow ox oy kx b">core</code>中获取东西，但是我认为最好让它更明确。</p><p id="f7fb" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">不管怎样？我们应该如何实现我们的存储库？我们需要某种方式让用户能够以某种方式保持他们的会话。<em class="mt">“哦，我知道了！”</em>我听到你热情地说，<em class="mt">“我们可以只使用浏览器的内置本地存储！”这是一个很好的解决方案，但是有一个小问题。</em></p><p id="f7cf" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated"><code class="fe ow ox oy kx b">data</code>包不能访问浏览器的存储API，因为它首先不知道浏览器。其实我们希望<code class="fe ow ox oy kx b">data</code>是这样的。否则，我们会使它依赖于一个细节，即它运行的平台。</p><p id="3ed4" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">相反，我们为我们的回购实现提供了一个叫做<code class="fe ow ox oy kx b">local storage</code>的东西。这是对我们在<code class="fe ow ox oy kx b">data</code>中定义的接口的依赖，也是我们可以在任何地方定义的实现。这种<code class="fe ow ox oy kx b">local storage</code>依赖性将被注入到我们的回购实现中。我们将很快到达这一部分。</p><p id="f219" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我选择以<code class="fe ow ox oy kx b">local-storage-service.interface.ts</code>的身份在<code class="fe ow ox oy kx b">data/src/common</code>下创建这个接口，因为我们也想在其他库中使用它。下面是我们的<code class="fe ow ox oy kx b">local storage</code>依赖关系的接口:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="b06e" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在，我们将它作为依赖项添加到我们的repo实现中，并实现了<code class="fe ow ox oy kx b">createCounter</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="9197" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我现在尽可能简单地实现这个方法。最酷的是，你可以选择让它成为你未来想要的任何东西，而不需要改变任何东西。</p><p id="34d9" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">恭喜你。我们刚刚在<code class="fe ow ox oy kx b">data</code>中实现了我们需要的所有功能。现在我们也需要导出它。同样，让我们利用索引文件。</p><p id="0fe4" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在<code class="fe ow ox oy kx b">data/src/counter</code>下创建一个<code class="fe ow ox oy kx b">index.ts</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="b63f" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">还有一个在<code class="fe ow ox oy kx b">data/src/common</code>下面</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="c86a" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">最后，在<code class="fe ow ox oy kx b">data/src</code>下的索引文件中导出这两个文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/eb02ba5f05c2cd2b7284f1e229584cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*vf9U6a2T44ctyYk8DTIk1w.png"/></div></figure><p id="a1c3" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们导出本地存储服务接口，因为我们将在可以访问浏览器的存储API: Presentation的地方实现它！</p><p id="a4db" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">但是让<code class="fe ow ox oy kx b">data</code>依赖于<code class="fe ow ox oy kx b">Presentation</code>不会破坏我们的依赖图吗？事实上，它不会，因为我们正在实现控制反转。这意味着表示将间接依赖于数据，而不是相反。在下一节中，您将看到这是如何工作的。</p><p id="7836" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在，让我们重新构建我们的数据包。再次运行<code class="fe ow ox oy kx b">npx lerna run build</code>。</p><h1 id="a8bb" class="mx lc iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">依赖注入(Angular提供了一点帮助)</h1><p id="1ebb" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">下面我们把<code class="fe ow ox oy kx b"><strong class="lk ir">core</strong></code>和<code class="fe ow ox oy kx b"><strong class="lk ir">data</strong></code>放在一起。我们希望将用例的实现和存储库与它们的接口联系起来。</p><p id="639f" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我使用一个类来实现这一点，这个类生成这些对象，并赋予它们依赖关系，例如一个<code class="fe ow ox oy kx b">Factory</code>。</p><p id="a0c5" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在<code class="fe ow ox oy kx b">di/src</code>下，创建一个名为<code class="fe ow ox oy kx b">counter</code>的文件夹，并在其中创建一个名为<code class="fe ow ox oy kx b">counter.factory.ts</code>的文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="e6c4" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">用实例化我们的存储库和用例所需的所有依赖关系实例化了<code class="fe ow ox oy kx b">CounterFactory</code>类。我们不公开存储库，只公开它需要的接口。</p><p id="f68b" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们通过在<code class="fe ow ox oy kx b">di/src/counter</code>下创建一个<code class="fe ow ox oy kx b">index.ts</code>文件来导出这个工厂以及它需要的本地存储服务接口，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="c90d" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">并且我们将这个文件导出到<code class="fe ow ox oy kx b">di/src</code>下的<code class="fe ow ox oy kx b">index.ts</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="e34c" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">下面是<code class="fe ow ox oy kx b">di</code>的项目目录:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/aa80f2aec45c11d697b05cb71f2bb0d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*4ooQD_KwQ7eovNkzA9Rmbg.png"/></div></figure><p id="07c3" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">运行<code class="fe ow ox oy kx b">npx lerna run build</code>来构建你的包。请注意，Lerna并没有重新构建核心和数据，而是使用以前构建的缓存版本，因为它们没有发生变化。有点酷，对吧？</p><p id="4919" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在我们准备好进入<code class="fe ow ox oy kx b">Presentation</code>。</p><p id="6b95" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们需要使我们刚刚创建的东西在演示中易于访问。为此，我使用Angular出色的依赖注入。我是这样做的。</p><p id="877b" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">有了Angular，我们可以直接在我们的<code class="fe ow ox oy kx b">app.module</code>文件中做这件事，但是我会把它放在<code class="fe ow ox oy kx b">presentation/src/di</code>下的一个文件夹中，这样会更整洁，我会在其中创建一个名为<code class="fe ow ox oy kx b">counter.ioc.ts</code>的文件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="cc34" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">这个文件实例化了<code class="fe ow ox oy kx b">CounterFactory</code>，并为它提供了所需的依赖项。然后，我们使用Angular的提供者类型创建一个<code class="fe ow ox oy kx b">Provider[]</code>,并注入我们的依赖项，就像我们通常在Angular应用程序中做的那样。</p><p id="8728" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在你惊慌之前，这里是我们在<code class="fe ow ox oy kx b">presentation/src/services</code>下创建的<code class="fe ow ox oy kx b">LocalStorageServiceImpl</code>文件(或者你认为合适的任何地方):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="2a31" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">最后一件事(我发誓！).我们需要在我们的<code class="fe ow ox oy kx b">app.module</code>中包含这个<code class="fe ow ox oy kx b">CORE_IOC</code> provider数组，使它在我们所有的应用程序中都可用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/e5db15078679f362339d46d435de486a.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*RCwX1m3rGmCsCUO5Guzd8w.png"/></div></figure><p id="f360" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们正式结束了。我知道你能到达那里！</p><p id="5d23" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">请记住，我们在前面的步骤中所做的很多事情我们只会做一次。一旦我们开始添加更多的用例，您就会看到。</p><p id="4727" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们现在可以开始编写UI代码了。</p><h1 id="96fd" class="mx lc iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">创建与用例交互的UI组件</h1><p id="b87e" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">这是你的标准角度编码程序。我们将在<code class="fe ow ox oy kx b">presentation/src/app</code>下创建一个名为counter的新组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/55d6dd3e2aa090d5dce080856dcfe1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*2WEwBfc7nQ8XJDsljkbQ4w.png"/></div></figure><p id="2734" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我将跳过UI代码，只展示控制器和用例是如何使用的。如果你感兴趣，你可以在这里看到代码。</p><p id="6db3" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我将从<code class="fe ow ox oy kx b">app.component</code>中移除Angular生成的所有代码，并添加我自己的代码。我们现在需要一个按钮来创建计数器，并需要一种结构来显示它们。我会用一个基本的滚动列表。这是我们的用户界面的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/4c0680bf071d1ac128b338272db19249.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*30-N9GeWYSMJzoGaI1M2zQ.png"/></div></figure><p id="004f" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我将把蓝色按钮挂在<code class="fe ow ox oy kx b">app.component.ts</code>中组件控制器的一个方法上:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="23ea" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们有一个存储所有计数器的列表和一个创建计数器的方法，该方法在调用用例后将新的计数器推送到列表中。我们使用Angular出色的依赖注入将用例注入到构造函数中。很漂亮，对吧？</p><p id="c1bd" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在我们可以按下add-counter按钮，我们会看到一些东西在列表中弹出。(同样，我跳过了实际的HTML和CSS，因为它们不相关)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/2e032fda08dee579cc8ec01f5ce4bb14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*2uCMiw1_-qSfAYJ1Wmwjag.png"/></div></figure><p id="0484" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在按下刷新键，然后…都没了。这是因为我们需要在控制器中添加一个方法，以便在页面加载时检索所有计数器。</p><p id="5415" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">为此，我们还需要一个这样的用例。让我们开始工作。</p><p id="5b99" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们在<code class="fe ow ox oy kx b">core/counter/usecases</code>下创建一个名为<code class="fe ow ox oy kx b">get-all-counters.ts</code>的新用例</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="4fb5" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们向repo接口添加了一个获取所有计数器的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="5d97" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">用<code class="fe ow ox oy kx b">npx lerna run build</code>构建<code class="fe ow ox oy kx b">core</code>，然后在<code class="fe ow ox oy kx b">data</code>的回购实现中实现该方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="1b08" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">存储库实现现在变得有点复杂了。这里可能有一个更好的实现(伏笔；)).</p><p id="6032" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">不管怎样，构建<code class="fe ow ox oy kx b">data</code>并转移到<code class="fe ow ox oy kx b">di</code>，所以我们更新计数器工厂来说明我们的新用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="4b47" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在我们已经有了样板代码，这就简单多了，对吗？</p><p id="360d" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">最后，我们使用Angular的<code class="fe ow ox oy kx b">di</code>注入我们的用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="f3b9" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">现在我们准备在<code class="fe ow ox oy kx b">app.component</code>中使用这个用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="e35b" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们在构造函数中提供用例，然后设置它在<code class="fe ow ox oy kx b">ngOnInit</code>中被调用。现在，通过按按钮添加一个计数器并刷新页面；计数器将持续存在！至少在我们重置浏览器存储之前。</p><p id="339d" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">所以，概括一下:</p><ol class=""><li id="6cf9" class="oe of iq lk b ll lm lo lp lr os lv ot lz ou md pl ok ol om bi translated">我们在<code class="fe ow ox oy kx b">core</code>中创建了用例</li><li id="cb00" class="oe of iq lk b ll on lo oo lr op lv oq lz or md pl ok ol om bi translated">我们实现了<code class="fe ow ox oy kx b">data</code>中用例所要求的回购方法</li><li id="2532" class="oe of iq lk b ll on lo oo lr op lv oq lz or md pl ok ol om bi translated">我们在<code class="fe ow ox oy kx b">di</code>中设置了一个方法来创建工厂及其依赖项</li><li id="a46a" class="oe of iq lk b ll on lo oo lr op lv oq lz or md pl ok ol om bi translated">在<code class="fe ow ox oy kx b">presentation</code>中，我们使用Angular的di来提供整个项目的用例</li><li id="6af6" class="oe of iq lk b ll on lo oo lr op lv oq lz or md pl ok ol om bi translated">我们称之为用例！</li></ol><p id="24b3" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">步骤1、2和5是对我们有意义的步骤。其余的是胶水和使生活更容易的解决方案。</p><p id="f838" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">添加其余的用例只是冲洗和重复。你可以看到我是如何在这个回购中实现其余的<a class="ae kv" href="https://github.com/aziznal/typescript-clean-architecture" rel="noopener ugc nofollow" target="_blank">的。</a></p><h1 id="7297" class="mx lc iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">测试</h1><p id="305e" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">在这一节中，我将提供一个为<code class="fe ow ox oy kx b">data</code>中的计数器存储库实现编写单元测试的例子。</p><p id="84c1" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们通过在<code class="fe ow ox oy kx b">data/src/tests/counter</code>下创建一个名为<code class="fe ow ox oy kx b">counter-repository.test.ts</code>的新文件来做到这一点</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="483a" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">第6行到第15行是本地存储服务的基本模拟实现，这是计数器存储库实现所需要的。我们在第17到40行定义了测试代码的主体。在每个测试块运行之前，计数器存储库及其依赖项都被初始化，因此我们确保我们的单元测试每次都在干净的环境中运行。</p><p id="648c" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我编写了一个测试，它创建一个新的计数器，然后通过调用方法检索所有计数器来查看它是否已被存储。剩下的就看你自己了！</p><h1 id="9984" class="mx lc iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">结束语</h1><p id="77d3" class="pw-post-body-paragraph li lj iq lk b ll no jr ln lo np ju lq lr nq lt lu lv nr lx ly lz ns mb mc md ij bi translated">我们已经涉及了相当多的内容，乍一看可能会让人不知所措。如果你第一次有困难，再试一次，慢慢来。理解每一层实际上负责什么将有助于让所有的部分都到位！</p><p id="33e2" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">这肯定是一个比您可能习惯的要慢的开始，但是一旦您掌握了基本的步骤，您将会感谢知道谁负责什么以及哪个代码位于哪里的轻松。更不用说当一切都是松散耦合时，测试会变得多么容易。</p></div><div class="ab cl pm pn hu po" role="separator"><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr"/></div><div class="ij ik il im in"><p id="3369" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">最后，如果有人能对我在这里的工作给予反馈，我会非常高兴。这对你有用吗？复杂性和实用性之间的平衡足够好吗？是不是有个大问题盯着我的眼睛，让我看不见了？我完全接受建设性的批评，所以让我接受吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/f7aa73fed58b78263205430cf2e6da86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AZJxij-BzbFugq-K"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jingdachen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陈静达</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="686e" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">谢谢你通读了整本书。我希望你会发现它非常有用，它给你编程带来的快乐和它给我带来的一样多。</p><h1 id="6910" class="mx lc iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">参考和链接</h1><ul class=""><li id="3508" class="oe of iq lk b ll no lo np lr og lv oh lz oi md oj ok ol om bi translated"><a class="ae kv" href="https://medium.com/@aziznal/creating-the-ultimate-clean-architecture-template-for-typescript-projects-e53936269bb9" rel="noopener">我解释如何制作这个模板的文章</a></li><li id="0bd2" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="https://github.com/aziznal/typescript-clean-architecture" rel="noopener ugc nofollow" target="_blank">已经完成实现的github repo</a></li><li id="99be" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">鲍勃大叔的干净建筑</a></li><li id="7dce" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="https://lerna.js.org/docs/introduction" rel="noopener ugc nofollow" target="_blank"> Lerna文档</a></li><li id="b6d8" class="oe of iq lk b ll on lo oo lr op lv oq lz or md oj ok ol om bi translated"><a class="ae kv" href="https://nx.dev/getting-started/intro" rel="noopener ugc nofollow" target="_blank"> NX文档</a></li></ul></div></div>    
</body>
</html>