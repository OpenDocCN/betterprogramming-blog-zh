<html>
<head>
<title>10 React Interview Questions for 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年的10个React面试问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-react-interview-questions-for-2020-544f0ce5386b?source=collection_archive---------3-----------------------#2020-06-10">https://betterprogramming.pub/10-react-interview-questions-for-2020-544f0ce5386b?source=collection_archive---------3-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c4fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">搞定你的下一次面试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c9e6afe0c13d195577efcf0dda8c743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LahjBzy8z7LUimmm.png"/></div></div></figure><p id="5cd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React是目前使用最多的UI库。它为脸书和无数其他公司提供动力。在这篇文章中，我将列出10个常见的React面试问题，以帮助你确定下一次面试。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="d1d8" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">基于类的组件和功能组件有什么区别？</h1><p id="6683" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">最明显的区别是语法和定义。函数组件是返回另一个组件的函数。基于类的组件是其渲染函数返回另一个组件的类。但是你应该在什么时候使用哪一个呢？</p><p id="056a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在React 16.8之前，在钩子被引入之前，只有基于类的组件可以保存内部状态和生命周期方法，功能组件只能依赖props(因此，它们是无状态的)。所以，这很简单:对有状态组件使用类，对无状态组件使用函数。</p><p id="f049" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是现在，像<code class="fe mu mv mw mx b">useState</code>和<code class="fe mu mv mw mx b">useEffect</code>这样的React钩子允许在功能组件中拥有状态和生命周期方法。此外，React团队鼓励每个人远离基于类的组件，因为性能问题和JavaScript中糟糕的类实现<a class="ae my" href="https://medium.com/javascript-in-plain-english/please-stop-using-classes-in-javascript-and-become-a-better-developer-a185c9fbede1" rel="noopener">。然而，功能组件中仍然缺少一些特性。其中之一是错误边界，所以你不得不使用基于类的组件。</a></p><p id="1a95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是两种方法的示例。这是同一个组件，在基于类的组件和函数中实现了一个计数器按钮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="6ee7" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">什么是JSX？是如何转化成JS的？</h1><p id="b24b" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">JSX代表JavaScript XML。这是React团队想出来的让React代码编写更简单的东西。本质上，JSX是一种定义我们都喜欢的组件的语言。例如，这是JSX电码:</p><pre class="kj kk kl km gt nb mx nc nd aw ne bi"><span id="cd8b" class="nf ly it mx b gy ng nh l ni nj">&lt;SomeComponent someProp={someValue} /&gt;</span></pre><p id="5039" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，这些代码不能被浏览器或节点(或Deno)理解。为了使它可以运行，使用了像巴贝尔这样的运输工具。在引擎盖下，代码被转换成这样:</p><pre class="kj kk kl km gt nb mx nc nd aw ne bi"><span id="14fa" class="nf ly it mx b gy ng nh l ni nj">React.createElement(SomeComponent, {someProp: someValue});</span></pre><p id="48f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么你必须把<code class="fe mu mv mw mx b">React</code>导入到JSX使用的每个文件中。代码将被编译成直接调用这个库的东西，即使你看不到它。你可以在这里玩Babel<a class="ae my" href="https://babeljs.io/repl/#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=GYVwdgxgLglg9mABACQKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8amciA7nGevQEJaAekasA3EQC-RIqEiwEiAIIAHVXkJEAkBSo1EtdlkRZ0AXgIByOFitTEwlpJlA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=react&amp;prettier=false&amp;targets=&amp;version=7.10.2&amp;externalPlugins=" rel="noopener ugc nofollow" target="_blank"/>——试着粘贴你的一些代码，并了解它在运行时的实际样子。</p><h1 id="d9f3" class="lx ly it bd lz ma nk mc md me nl mg mh jz nm ka mj kc nn kd ml kf no kg mn mo bi translated">什么是道具，如何获取？</h1><p id="9c82" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Props是将数据从一个组件传递给其子组件的一种方式。您还可以向下传递回调以反转方向并从子节点获取数据。此外，如果您更改子组件的属性，子组件将重新呈现。你像这样把道具传递给组件:</p><pre class="kj kk kl km gt nb mx nc nd aw ne bi"><span id="e4ad" class="nf ly it mx b gy ng nh l ni nj">&lt;MyComponent myProp={myValue} /&gt;</span></pre><p id="4d2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，您可以在功能组件中访问此属性:</p><pre class="kj kk kl km gt nb mx nc nd aw ne bi"><span id="b96d" class="nf ly it mx b gy ng nh l ni nj">function MyComponent(props) { <br/>  return &lt;h1&gt;{props.myProp}&lt;/h1&gt;;<br/>}</span></pre><p id="e742" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在类组件中:</p><pre class="kj kk kl km gt nb mx nc nd aw ne bi"><span id="4b08" class="nf ly it mx b gy ng nh l ni nj">class MyComponent extends Component { <br/>  render() { <br/>    &lt;h1&gt;{this.props.myProp}&lt;/h1&gt;; <br/>  } <br/>}</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="5135" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">什么是状态，你如何使用它？</h1><p id="03d3" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">状态是您需要在重新呈现器之间保持的一段数据。它可以是任何东西，从文本框中的值到计时器的时间戳。每次状态改变时，组件都会重新呈现，这就对如何更新组件产生了一定的限制。下面是如何使用<code class="fe mu mv mw mx b">useState</code>钩子访问功能组件中的状态:</p><pre class="kj kk kl km gt nb mx nc nd aw ne bi"><span id="9198" class="nf ly it mx b gy ng nh l ni nj">const Field = () =&gt; { <br/>  const [text, setText] = useState(''); <br/>  return &lt;TextField value={text} onChange={setText} /&gt;; <br/>};</span></pre><p id="ac8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">useState</code>接受一个参数——初始状态。它返回两个值—状态值和一个改变它的函数。现在，让我们看看状态是如何在基于类的组件中实现的:</p><pre class="kj kk kl km gt nb mx nc nd aw ne bi"><span id="8cb3" class="nf ly it mx b gy ng nh l ni nj">class Field extends Component { <br/>  constructor(props) { <br/>    super(props); <br/>    this.state = {text: ''}; <br/>  } </span><span id="212a" class="nf ly it mx b gy np nh l ni nj">  render() { <br/>    return ( <br/>      &lt;TextField <br/>        value={this.state.text} <br/>        onChange={(newText) =&gt; this.setState({text: newText})} /&gt;); <br/>  } <br/>}</span></pre><p id="2271" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">班级里的情况略有不同。首先，在构造函数中定义状态，稍后可以使用<code class="fe mu mv mw mx b">this.state</code>访问它。注意，与函数不同，类只能有一个状态对象(可以有多个属性)。<code class="fe mu mv mw mx b">setState</code>函数接受一个全新的状态对象，替换它并重新呈现组件。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="6054" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">什么是全球状态，我们为什么需要它？</h1><p id="d197" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">虽然组件有状态，但这些状态对它们来说是局部的。您不能从另一个组件直接访问一个组件的状态。有时您有一些数据需要显示在许多不同的地方，比如用户名、主题(暗/亮模式)、地区等等。</p><p id="7835" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种方法是在树中的某个位置定义这种状态，并将其作为道具传递下去。然而，当您拥有超过20个以上的组件时，这是不可能的——您的代码将变得一团乱麻。这时你需要存储全局状态。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="0c99" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">有哪些管理全局状态的方法？</h1><p id="f00f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">React应用程序中管理全局状态的两种主要方法是使用Redux和React上下文。</p><p id="d364" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Redux是第三方库，不是React的一部分。它允许您定义一个全局状态对象，并使用选择器在组件中查询它。另一方面，组件发送动作来修改状态。Redux对其进行修改，并重新呈现所有关注这一特定变化的组件。</p><p id="4f1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与Redux不同，React上下文是React的一部分。上下文还为您提供了一种处理全局状态的方式。与Redux不同，您可以拥有多个上下文，并独立地访问它们。然而，当处理大量动作时，上下文可能会有性能问题。从好的方面来看，上下文的开销要小得多。您需要根据您的项目需求和范围来决定使用哪一个。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="503a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">哑组件和智能组件有什么区别？</h1><p id="dc7c" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">哑组件和智能组件是React中的一种设计模式。本质上，它可以归结为:智能组件处理业务逻辑，而非智能组件直接呈现UI。因此，智能组件是有状态的，而非智能组件是无状态的，仅仅依赖于props。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="ef70" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">受控组件和非受控组件有什么区别？</h1><p id="4eca" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">当我们谈到受控和非受控组件时，我们通常指的是以某种方式处理用户输入的组件。但是“不受控制”不是一个很好的词。每一个部件都是由谁控制的，问题是<em class="nq">由谁控制？</em>例如，这是我们使用受控组件的方式:</p><pre class="kj kk kl km gt nb mx nc nd aw ne bi"><span id="b05f" class="nf ly it mx b gy ng nh l ni nj">const App = () =&gt; { <br/>  const [text, setText] = useState(''); <br/>  return ( &lt;Input value={text} onChange={setText} /&gt; ); <br/>}</span></pre><p id="104c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们作为开发人员，控制着<code class="fe mu mv mw mx b">Input</code>组件。当用户输入内容时，会触发<code class="fe mu mv mw mx b">onChange</code>回调(甚至在用户看到文本之前)。状态被更新，组件用新值重新呈现。这是一个不受控制的组件的例子:</p><pre class="kj kk kl km gt nb mx nc nd aw ne bi"><span id="3d5f" class="nf ly it mx b gy ng nh l ni nj">const App = () =&gt; { <br/>  return ( &lt;input type='text' /&gt; ); <br/>}</span></pre><p id="a58c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个HTML输入组件。用户可以输入文本，它会显示出来。然而，我们不能控制它的价值。谁知道。浏览器引擎。注意，我们很少在React中使用不受控制的组件，因为现在很难获得输入的值。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a574" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">Flux架构的基础是什么？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6f9ed08d3e484057f00fb0124d60f68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*bDKUmjbHK-Aa167J"/></div></figure><p id="db2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Flux是一种用于开发大型React应用程序的设计模式。这是反应式编程模式的延续，在使用UI时特别有用。</p><p id="8c4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Flux由一个存储组成，它保存应用程序的全局状态。视图是一个获取状态并生成UI的函数。理想情况下，视图必须是纯粹的和一致的，即相同的状态会产生相同的UI，而UI不会直接改变状态。相反，它将动作(事件)发送给调度程序。调度程序将接收操作，对状态进行必要的更改，并通知视图它们现在必须重新呈现。最流行的实现Flux的库是Redux和RxJS。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="bfa8" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">React中渲染数组时，键的意义是什么？</h1><p id="9889" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这与React协调算法密切相关。本质上，如果列表中两个重新呈现器之间的组件具有相同的键，React会将它们视为相同的组件，而不会更新。此外，如果没有键，React将无法优化，并且您将遭受许多不必要的重新呈现。因此，永远不要使用索引作为键，因为索引可能会改变，如果项目被重新安排，打破一切。此外，不要使用运行时生成的随机字符串作为键，因为你会有许多不必要的重新呈现。我知道有时候你的数据没有唯一的标识符，但是你应该去添加它。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="9610" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结束语</h1><p id="2e24" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">感谢阅读，希望你面试成功！</p><p id="84a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请继续订阅更多关于JS、React以及其他相关内容的文章。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="0815" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">资源</h1><ul class=""><li id="8255" class="ns nt it kw b kx mp la mq ld nu lh nv ll nw lp nx ny nz oa bi translated">【2020年10个JavaScript面试问题</li><li id="af3c" class="ns nt it kw b kx ob la oc ld od lh oe ll of lp nx ny nz oa bi translated">【React协调算法如何工作</li></ul></div></div>    
</body>
</html>