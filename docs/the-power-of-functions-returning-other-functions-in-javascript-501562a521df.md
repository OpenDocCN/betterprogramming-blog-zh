# JavaScript 中返回其他函数的函数的威力

> 原文：<https://betterprogramming.pub/the-power-of-functions-returning-other-functions-in-javascript-501562a521df>

## 功能和可组合性

![](img/c44a3435ce6a04db0001960bcb591f47.png)

*由 Shahadat Rahman 在 Unsplash 上拍摄的照片*

众所周知，JavaScript 本质上非常灵活。本文将展示一些通过使用函数来利用这一点的例子。

由于函数可以在任何地方传递，我们可以将它们传递到函数的参数中。

我的第一次实践经验是开始用 JavaScript 编写代码，实践中有一个概念让我很困惑，那就是将函数传递给其他函数。我试着做一些所有专业人士都在做的高级事情，但我总是以这样的事情结束:

这绝对是荒谬的，甚至让我们更难理解为什么我们要将函数传递给现实世界中的其他函数，而我们本可以这样做并获得相同的行为:

```
const date = new Date()
console.log(`Todays date: ${date}`)
```

但是为什么这对于更复杂的情况还不够好呢？创建一个自定义`getDate(callback)`函数，还要做额外的工作，除了感觉很酷还有什么意义？

然后，我继续问了更多关于这些用例的问题，并要求给出一个在社区板上很好使用的例子，但是没有人愿意解释和给出一个例子。

回想起来，我意识到问题是我的大脑还不知道如何以编程方式思考。让你的思维从原来的生活转移到用计算机语言编程需要一段时间。

因为我理解试图理解高阶函数在 JavaScript 中何时有用的挫折，所以我决定写这篇文章来一步一步地解释一个好的用例，从一个任何人都可以编写的非常基本的函数开始。我们将在此基础上逐步实现一个提供额外好处的复杂实现。

# 有意图的功能

首先，我们将从一个旨在为我们实现目标的功能开始。

有没有一个函数，它接受一个对象，然后返回一个新对象，这个新对象按照我们想要的方式更新了样式？

让我们使用这个对象(我们称之为`component`):

我们想让我们的函数保持`height`不小于`300`，并对按钮组件(带有`type: 'button'`的组件)应用一个`border`，并将其返回给我们。

这可能看起来像这样:

结果:

假设我们想出了一个主意，通过将组件放在它的`children`属性中，每个组件可以包含更多的组件。这意味着我们还必须处理内部组件。

给定这样一个组件…

…我们的职能显然无法完成工作，*然而……*

由于我们最近在组件中添加了子组件的概念，我们现在知道至少有两种不同的方式来解决最终结果。

这是开始考虑*抽象的好时机。将代码片段抽象成可重用的函数使你的代码更具可读性和可维护性，因为它避免了麻烦的情况，比如在某件事情的实现细节中调试一些问题。*

当我们从一些东西中抽象出小的部分时，开始考虑以后如何将这些部分组合在一起也是一个好主意，我们可以称之为*组合。*

# 抽象和构成

要知道要抽象出什么，思考一下我们的最终目标是什么:

> “有没有这样一个函数，它接受一个对象，然后返回一个新对象，这个新对象按照我们想要的方式更新了样式？”

本质上，这个函数的要点是将一个值转换成我们期望的表示形式。

请记住，我们最初的功能是转换组件的样式，但是我们*也*添加了组件可以包含具有`children`属性的组件。

所以我们可以从抽象这两个部分开始，因为很有可能会有更多的情况，我们需要制作更多的函数，这些函数需要对值做类似的事情。出于本教程的考虑，我们可以将这些抽象函数称为*解析器*:

结果:

# 重大变化

接下来，让我们讨论一下这些代码是如何导致灾难性错误的——这些错误会让你的应用崩溃。

如果我们仔细看看解析器，看看它们是如何用于计算最终结果的，我们可以看出它们很容易崩溃，导致我们的应用程序崩溃，原因有两个:

## **它变异了**

如果一个未知的 bug 发生了，并且错误地将未定义的值赋给了值，从而错误地改变了值，该怎么办？该值也在函数之外波动，因为它被变异了(理解[引用](https://stackoverflow.com/questions/6605640/javascript-by-reference-vs-by-value)是如何工作的)。

如果我们从`resolveStyles`中取出`return component`，我们会立即面对一个`TypeError`，因为这将成为下一个解析器函数的输入值:

## **解析器覆盖先前的结果**

这不是一个好的实践，违背了抽象的目的。我们的`resolveStyles`可以计算它的值，但是如果`resolveChildren`函数返回一个全新的值也没关系。

# 保持事物不变

通过使这些函数不可变并确保它们在给定相同值的情况下总是返回相同的结果，我们可以安全地朝着我们的目标前进。

# 合并新的更改

在我们的`resolveStyles`函数中，我们可以返回一个新值(object ),其中包含我们将与原始值合并的更改值。这样，我们可以确保解析器不会相互覆盖，并且返回的`undefined`不会影响后面的其他代码:

# 当项目变大时

如果我们有 10 个风格解析器，而只有一个解析器处理子元素，那么维护起来会变得很困难。我们可以在它们合并的地方把它们分开:

调用这些解析器的代码已经被抽象成它自己的函数，所以我们可以重用它，也可以减少重复。

如果我们有一个解析器，它需要更多的上下文来计算结果呢？

例如，如果我们有一个`resolveTimestampInjection`解析器函数，当在包装器中的某个地方使用了某个选项参数时，它会注入一个`time`属性，那会怎么样呢？

# 需要附加上下文的函数

让解析器能够获得额外的上下文，而不只是接收作为参数的`component`值，这将是一件好事。我们可以通过使用解析器函数的第二个参数来提供这种能力，但是我认为这些参数应该在组件级的基础上为较低级别的抽象而保存。

如果解析器能够返回一个函数，并从返回函数的参数中接收所需的上下文，那会怎么样？

像这样的东西:

如果我们能够在不改变原始代码行为的情况下启用该功能，那就太好了:

这就是合成高阶函数的威力开始显现的地方，好消息是它们很容易实现！

# 抽离抽象

为了实现这一功能，让我们通过将解析器封装到一个更高阶的函数中，将上下文注入到更低层次的解析器函数中，从而在抽象上更上一层楼。

我们现在可以从我们注册为解析器的任何函数中返回一个函数，并且仍然保持我们的应用程序的行为，就像这样:

在我展示最后一个例子之前，让我们先来看看`makeInjectContext`高阶函数，看看它在做什么:

它首先接受一个要传递给所有解析器函数的对象，然后返回一个接受回调函数作为参数的函数。这个回调参数稍后将成为原始解析器函数之一。

我们这样做的原因是因为我们正在做所谓的*包装*。我们用一个外部函数包装了回调，这样我们可以注入额外的功能，同时通过确保我们在这里调用回调来保持我们原始函数的行为。

如果回调结果的返回类型是一个函数，我们将假设回调需要上下文，所以我们再次调用回调的结果——这就是我们传递上下文的地方。

当我们调用那个回调函数(调用者提供的函数)并在包装函数内部进行一些计算时，我们有来自包装器和调用者的值。对于我们的最终目标来说，这是一个很好的用例，因为我们希望将结果合并在一起，而不是让每个解析器函数覆盖前一个解析器函数的值或结果！

有其他高级用例来解决不同的问题是没有价值的，这是一个很好的例子来展示我们需要正确的策略来用于正确的情况。

因为如果你像我一样，你可能会在每次发现一个开放的机会时尝试实现许多高级用例。这是一种不好的做法，因为根据具体情况，一些高级模式比其他模式更好。

现在我们的`start`函数需要针对`makeInjectContext`高阶函数进行调整:

我们仍然得到了一个预期结果的对象！

# 结论

本文到此结束。我希望你发现这是有价值的，并期待在未来更多！