<html>
<head>
<title>5 Steps to Turn a Random React Application Into a Micro Front-End</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将随机React应用程序转变为微前端的5个步骤</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-steps-to-turn-a-random-react-application-into-a-micro-frontend-946718c147e7?source=collection_archive---------0-----------------------#2020-02-25">https://betterprogramming.pub/5-steps-to-turn-a-random-react-application-into-a-micro-frontend-946718c147e7?source=collection_archive---------0-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d92" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始使用微前端，这是一种运行多个应用程序的新方法，感觉就像一个应用程序一样</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/817eaf6b6d5ffeae1c9f34bf90ad9c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kB2U3W8rmbBcuaQGWCmjQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@duminda?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杜明达·佩雷拉</a>在<a class="ae ky" href="https://unsplash.com/s/photos/5?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么是微前端方法？术语<em class="lv">微前端</em>在2016年11月的<a class="ae ky" href="https://www.thoughtworks.com/radar/techniques/micro-frontends" rel="noopener ugc nofollow" target="_blank"> ThoughtWorks技术雷达</a>中首次出现。它将微服务的概念扩展到前端开发。</p><p id="6958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法是通过分解应用程序特性，将基于浏览器的代码拆分成微前端。通过制作更小的、以功能为中心的代码库，我们实现了软件开发的解耦目标。</p><p id="7536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管代码库是分离的，但用户体验是一致的。此外，每个代码库都可以独立实现、升级、更新和部署。</p><p id="d6db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是微前端的天堂。JavaScript应用，不管框架和版本，都是由一个容器启动的。这些应用程序，无论是旧的还是新的，都可以无缝地协同工作，就像一个应用程序一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/aed1ac78628bd726501cff0614c3595f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-8XM08c1FwEHoatLhTLtww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们将处理React微前端的更简单的情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/f4ca5442ce0bd3ed82dee1e4ffd33e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBuCdzMk2bf4oMKZT_ZbMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="cc51" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">构建启动React应用程序的微型前端容器的前期工作</h1><p id="ddb6" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">这个容器需要能够启动一个随机的React应用程序，而不需要知道很多细节。此外，由于微前端的想法，这一层需要很薄，几乎没有业务逻辑。</p><p id="3618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，<a class="ae ky" href="https://camjackson.net/" rel="noopener ugc nofollow" target="_blank"> Cam Jackson </a>发表了他的<a class="ae ky" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">微前端作品</a>供我们采用。他的作品是在这个<a class="ae ky" href="https://github.com/micro-frontends-demo" rel="noopener ugc nofollow" target="_blank">地点</a>拍摄的:</p><ul class=""><li id="0bb0" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">一个<code class="fe nl nm nn no b"><a class="ae ky" href="https://github.com/micro-frontends-demo/container" rel="noopener ugc nofollow" target="_blank">Container</a></code>:微前端演示的入口点和容器应用。</li><li id="d018" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">一个浏览餐厅的微前端:<code class="fe nl nm nn no b"><a class="ae ky" href="https://github.com/micro-frontends-demo/browse/" rel="noopener ugc nofollow" target="_blank">Browse</a></code>。</li><li id="1063" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">一个餐厅点餐的微前端:<code class="fe nl nm nn no b"><a class="ae ky" href="https://github.com/micro-frontends-demo/restaurant-order" rel="noopener ugc nofollow" target="_blank">Restaurant-order</a></code>。</li><li id="e685" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">一个<code class="fe nl nm nn no b"><a class="ae ky" href="https://github.com/micro-frontends-demo/content" rel="noopener ugc nofollow" target="_blank">Content</a></code>服务器:为微前端演示存储静态内容的地方。</li></ul><p id="3ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是微前端的工作流程:</p><ul class=""><li id="5304" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">启动<code class="fe nl nm nn no b">Content</code>服务器。</li><li id="0f3d" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">在特定端口上启动<code class="fe nl nm nn no b">Browse</code>和<code class="fe nl nm nn no b">Restaurant-order</code>应用。</li><li id="b7f6" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">基于URL，<code class="fe nl nm nn no b">Container</code>将路由到一个微前端。</li><li id="b034" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">选择的微前端到特定的端口获取应用的<code class="fe nl nm nn no b">asset-manifest.json</code>。从这个JSON文件中，包含的<code class="fe nl nm nn no b">main.js</code>被放在一个脚本标签上并被加载。</li></ul><p id="f1c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<a class="ae ky" href="https://github.com/facebook/create-react-app/issues/6436" rel="noopener ugc nofollow" target="_blank">清单文件</a>包含了所有资产文件名到它们相应的输出文件的映射，这样工具就可以在不解析<code class="fe nl nm nn no b">index.html</code>的情况下获取它。这个<code class="fe nl nm nn no b">Container</code>的核心是下面的<code class="fe nl nm nn no b"><a class="ae ky" href="https://github.com/micro-frontends-demo/container/blob/master/src/MicroFrontend.js" rel="noopener ugc nofollow" target="_blank">MicroFrontend.js</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="baff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第13到22行包含启动微前端的代码。通常，微前端之间没有通信，并且容器和微前端之间的通信有限。</p><p id="2fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，这是从容器到微前端的一种方式。这里，第34行传递了<code class="fe nl nm nn no b">containerId</code>及其微前端的历史，如下所示:</p><pre class="kj kk kl km gt nw no nx ny aw nz bi"><span id="68d7" class="oa mg it no b gy ob oc l od oe">ReactDOM.render(&lt;App history={history} /&gt;, document.getElementById(containerId));</span></pre><p id="1d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第18行将脚本的<code class="fe nl nm nn no b">crossOrigin</code>值设置为空，相当于<code class="fe nl nm nn no b">anonymous</code>。这意味着对元素的请求将把它的模式设置为<code class="fe nl nm nn no b">cors</code>并且把它的凭证模式设置为<code class="fe nl nm nn no b">same-origin</code>。</p><p id="0cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在实际代码中稍微修改了一下Cam的例子。无论如何，这是我们使用的基础。基于此，我们可以向您展示如何将应用程序转变为微前端。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="d6c6" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">将随机React应用程序转变为微前端的5个步骤</h1><p id="19e9" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我们选择的随机React应用程序是<a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>。把它变成一个微前端需要五个步骤。</p><p id="a4dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener"> <em class="lv"> 10个关于Create React App </em> </a>的有趣事实中，描述了脸书皇冠宝石应用的很多原理。在本文中，我们强调应用这些原则。</p><h2 id="9b9a" class="oa mg it bd mh of og dn ml oh oi dp mp li oj ok mr lm ol om mt lq on oo mv op bi translated">步骤1:修改package.json来设置端口并使用“react-app-rewired”</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="01ef" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">在第12行，<code class="fe nl nm nn no b">react-app-rewired</code>被添加为一个依赖项——这允许在不弹出的情况下定制应用程序。</li><li id="5262" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">在第15行，应用程序的启动端口已经从默认端口3000更改为选定的4000——这避免了端口冲突，因为<code class="fe nl nm nn no b">Container</code>本身运行在端口3000上。</li><li id="b3e7" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">从第15行到第17行，<code class="fe nl nm nn no b">react-scripts</code>替换为<code class="fe nl nm nn no b"><a class="ae ky" href="https://github.com/timarney/react-app-rewired" rel="noopener ugc nofollow" target="_blank">react-app-rewired</a></code>。</li></ul><p id="d981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了新的端口，Create React App显示的UI如下。(我们作弊了一点。使用<code class="fe nl nm nn no b">react-app-rewired</code>需要在应用程序运行前更改步骤2。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/8b5e06fe71d7e49d70bda0ff7a2e4c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPb0WN6SLguVZU3sgAopCQ.png"/></div></div></figure><h2 id="9c05" class="oa mg it bd mh of og dn ml oh oi dp mp li oj ok mr lm ol om mt lq on oo mv op bi translated">步骤2:使用config-overrides.js禁用代码拆分</h2><p id="4200" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">默认情况下，启用代码拆分。一个应用程序被分成几个块，可以独立地加载到页面上。</p><p id="6638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">http://localhost:4000/asset-manifest.json</code>清楚显示该应用已被分块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/edbaf88656380c8ff505d2797bd3508c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wry1ryJ3alJ1P4qAsgHQaw.png"/></div></div></figure><p id="7f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种加载优化会导致装载和卸载微前端的问题。我们需要通过创建或编辑<code class="fe nl nm nn no b">config-overrides.js</code>来禁用分块，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="eae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，<code class="fe nl nm nn no b">http://localhost:4000/asset-manifest.json</code>显示没有分块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/1f3a3ef95581962469c413d1b3b48e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2zs9wGX3mdc4QgwgwYWEQ.png"/></div></div></figure><p id="4d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您没有从Create React app生成React App，则可以通过修改<a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>配置来完成步骤1和步骤2。</p><blockquote class="ot ou ov"><p id="da34" class="kz la lv lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated"><em class="it">如果使用我们改进的</em><a class="ae ky" href="https://gist.github.com/JenniferFuBook/0cd7d34548c76df1837988692880b54c" rel="noopener ugc nofollow" target="_blank"><em class="it">micro frontend . js</em></a><em class="it">，在步骤1中就不必使用</em> <code class="fe nl nm nn no b"><em class="it">react-app-rewired</em></code> <em class="it">，步骤2完全可以跳过。5步减为3.5步。详细内容在“</em> <a class="ae ky" href="https://medium.com/better-programming/you-dont-have-to-lose-optimization-for-micro-frontends-60a63d5f94fe" rel="noopener"> <em class="it">微前端</em> </a> <em class="it">”中有描述。</em></p><p id="b286" class="kz la lv lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated"><em class="it">本次保存在本</em> <a class="ae ky" href="https://github.com/JenniferFuBook/micro-frontend/tree/chunkOptimization" rel="noopener ugc nofollow" target="_blank"> <em class="it">回购</em> </a> <em class="it">的</em> chunkOptimization <em class="it">分支中捕获。</em></p></blockquote><h2 id="f63a" class="oa mg it bd mh of og dn ml oh oi dp mp li oj ok mr lm ol om mt lq on oo mv op bi translated">步骤3:在src/index.js中进行修改，以定义呈现和卸载函数</h2><p id="de05" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我们来看看<code class="fe nl nm nn no b">Browse</code>微前端的<code class="fe nl nm nn no b">src/index.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义了<code class="fe nl nm nn no b">window.renderBrowse</code>和<code class="fe nl nm nn no b">window.unmountBrowse</code>。这些方法由<code class="fe nl nm nn no b">Container</code>的<code class="fe nl nm nn no b">MicroFrontend.js</code>调用。需要为Create React App的<code class="fe nl nm nn no b">src/index.js</code>定义类似的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ca39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从第7行到第19行，增加<code class="fe nl nm nn no b">window.renderCreatereactapp</code>和<code class="fe nl nm nn no b">window.unmountCreatereactapp</code>。</p><p id="bc59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第23行变成有条件的。如果是独立应用，会渲染到<code class="fe nl nm nn no b">root</code>元素。如果是微前端，会由<code class="fe nl nm nn no b">window.renderCreatereactapp</code>渲染到<code class="fe nl nm nn no b">containerId</code>。</p><h2 id="2a06" class="oa mg it bd mh of og dn ml oh oi dp mp li oj ok mr lm ol om mt lq on oo mv op bi translated">步骤4:使用src/setupProxy.js来设置CORS规则</h2><p id="1ebe" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">当在web浏览器中启动微前端时，我们得到一个CORS错误:</p><pre class="kj kk kl km gt nw no nx ny aw nz bi"><span id="0598" class="oa mg it no b gy ob oc l od oe">Access to fetch at ‘http://localhost:4000/asset-manifest.json' from origin ‘http://localhost:3000' has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.</span></pre><p id="f03e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">必须通过创建或编辑<code class="fe nl nm nn no b">src/setupProxy.js</code>来设置以下代理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进行第5步之前，我们为<code class="fe nl nm nn no b">Container</code>做一些额外的工作。</p><p id="d16f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nl nm nn no b">.env</code>文件中，需要添加新的主机<code class="fe nl nm nn no b">REACT_APP_CREATEREACTAPP_HOST</code>。端口4000需要与运行Create React App的真实端口相匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cda3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也需要对<code class="fe nl nm nn no b">.env.production</code>进行类似的更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nl nm nn no b">AppHeader.js</code>中添加一个导航链接，使其可被用户界面访问。这是可选的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe nl nm nn no b">Createreactapp</code>及其路线添加到<code class="fe nl nm nn no b">Container</code>的<code class="fe nl nm nn no b">App.js</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们试着展示一下我们的微前端。</p><ul class=""><li id="f0bd" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated"><code class="fe nl nm nn no b">Content</code>服务器:<code class="fe nl nm nn no b">npm start</code>。</li><li id="0db8" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><code class="fe nl nm nn no b">Browse</code>微前端:<code class="fe nl nm nn no b">npm start</code>。</li><li id="c126" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><code class="fe nl nm nn no b">Restaurant-order</code>微前端:<code class="fe nl nm nn no b">npm start</code>。</li><li id="e276" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><code class="fe nl nm nn no b">Create React App</code>微前端:<code class="fe nl nm nn no b">npm start</code>。</li><li id="2f71" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><code class="fe nl nm nn no b">Container</code> : <code class="fe nl nm nn no b">npm start</code>。</li></ul><p id="deeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe nl nm nn no b">localhost:3000/createreactapp</code>启动页面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/a9f4de0952087b49306a880c9e254142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9v9hBTaM6MHCI5Ecvpp9xw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哎呀，React旋转日志在哪里？</p><p id="e785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重温一下<code class="fe nl nm nn no b">http://localhost:4000/asset-manifest.json</code>。微前端的logo是一个单独的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="61ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们忘记拿了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/6adf3b51ccf00710a03a60944b003999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fjhQ-r-y248lRlC4Se3XA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这个logo SVG文件的源码，设置为<code class="fe nl nm nn no b">/static/media/logo.5d5d9eef.svg</code>。这个文件在Create React App(https://localhost:4000)中有，在<code class="fe nl nm nn no b">Container</code> (http://localhost: 3000)中没有。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/c31c87705a01eaa0efdff3c9d05c894a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djZ3oJFdn2zNXk3YLIfdPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的最后一步。</p><h2 id="5af3" class="oa mg it bd mh of og dn ml oh oi dp mp li oj ok mr lm ol om mt lq on oo mv op bi translated">步骤5:在<code class="fe nl nm nn no b">.env</code>文件中配置内容主机，并使用它作为静态内容的前缀</h2><p id="c871" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">创建或编辑<code class="fe nl nm nn no b">.env</code>以设置内容主机:</p><pre class="kj kk kl km gt nw no nx ny aw nz bi"><span id="5c71" class="oa mg it no b gy ob oc l od oe">REACT_APP_CONTENT_HOST=http://localhost:4000</span></pre><p id="e2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当微前端使用静态内容时，它需要在HTML中给它们加上前缀<code class="fe nl nm nn no b">%REACT_APP_CONTENT_HOST%</code>，在JavaScript中加上前缀<code class="fe nl nm nn no b">process.env.REACT_APP_CONTENT_HOST</code>。</p><p id="bce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们修改了<code class="fe nl nm nn no b">src/App.js</code>中的第9行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种改变，logo SVG文件以<code class="fe nl nm nn no b">http://localhost:4000</code>为前缀。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/de6b59cf6db4d77610455fd3dc71aee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpHh9Y99gutOf8yUDZF76g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序现在工作正常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/98550aa756d5869ec7057a8075edcde3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uyyORy_yhDxmwlg405COA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="f773" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="6056" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">微前端方法是一条鲜有人走的路。可以去<a class="ae ky" href="https://micro-frontends.org/" rel="noopener ugc nofollow" target="_blank">微前端网站</a>了解更多。</p><p id="c30e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这项工作的一部分是由乔纳森马贡献。</p><p id="7cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。</p><p id="d59a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个关于微前端的系列。以下是其他文章的列表:</p><ul class=""><li id="3fab" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">"<a class="ae ky" href="https://medium.com/better-programming/3-steps-to-turn-a-random-react-application-into-a-micro-frontend-container-a80e33b6a066" rel="noopener">将随机React应用程序转变为微前端容器的3个步骤</a>"</li><li id="3968" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">"<a class="ae ky" href="https://medium.com/better-programming/build-your-own-micro-frontend-ecosystem-a05128c74f99" rel="noopener">打造自己的微前端生态系统</a>"</li><li id="35e3" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">"<a class="ae ky" href="https://medium.com/better-programming/you-dont-have-to-lose-optimization-for-micro-frontends-60a63d5f94fe" rel="noopener">你不必失去对微前端的优化</a>"</li><li id="6002" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">"<a class="ae ky" href="https://medium.com/better-programming/10-decision-points-for-micro-frontends-approach-4ebb4b59f40" rel="noopener">微前端方法的10个决策点</a>"</li><li id="8ce9" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">"<a class="ae ky" href="https://medium.com/better-programming/6-steps-to-create-a-multi-version-react-application-1c3e5b5df7e9" rel="noopener">创建多版本React应用程序的6个步骤</a>"</li><li id="de5f" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated">"<a class="ae ky" href="https://medium.com/better-programming/micro-frontends-using-webpack-5-module-federation-3b97ffb22a0d" rel="noopener">使用Webpack 5模块联盟的微前端</a>"</li></ul></div></div>    
</body>
</html>