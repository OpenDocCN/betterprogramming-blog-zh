<html>
<head>
<title>How to Write Python Decorators That Take Parameters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写带参数的Python装饰器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-python-decorators-that-take-parameters-b5a07d7fe393?source=collection_archive---------2-----------------------#2020-05-13">https://betterprogramming.pub/how-to-write-python-decorators-that-take-parameters-b5a07d7fe393?source=collection_archive---------2-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2b46" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">超越基本的Python装饰器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/21b6bec42280c8a90e352a676390cf24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9kA-XAE3WLmHdizj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弗兰克·麦凯纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一种通用的面向对象编程语言，Python通过将数据和功能(包括函数)视为对象来实现其所有操作。像其他数据对象(例如，整数和字符串)一样，函数可以作为参数传递给其他函数，并由其他函数作为输出值返回。</p><p id="ba47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些使用其他函数作为输入和输出的函数通常被称为<em class="lv">高阶函数</em>。一种这样的高阶函数是decorators，它是扩展其他函数(被修饰的函数)的行为而不显式修改它们的函数。请看下面的例子来感受一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="eab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码所示，我们定义了一个decorator函数，它基本上返回两次调用传递的函数参数的<code class="fe ly lz ma mb b">wrapper</code>函数。为了使用这个装饰函数，我们在要被装饰的函数的正上方使用@符号作为装饰函数名的前缀(例如，<code class="fe ly lz ma mb b">echo_wrapper</code>)。当我们调用修饰函数时，我们可以看到<code class="fe ly lz ma mb b">say_hello</code>函数确实被调用了两次。这很酷，不是吗？</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="44a5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">突出的问题</h1><p id="1cda" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">使用上面代码片段中的同一个例子，让我们考虑一个稍微复杂一点的特性。我们如何指定装饰函数需要多少回声呢？到目前为止，它只回显一次(原来的那个加上回显产生了两个印记)。</p><p id="5bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，decorator函数必须有一个机制，允许它将该计数作为一个参数。为了解决这个问题，让我们后退一步，回顾一下装修工的工作。让我们考虑下面的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码所示，要利用<code class="fe ly lz ma mb b">echo_wrapper</code>装饰器函数，我们只需将声明的函数(即<code class="fe ly lz ma mb b">say_hi</code>)传递给装饰器并调用装饰器函数。正如你所看到的，我们能够通过说两次Hi来回应！换句话说，通过将函数发送给装饰器，函数被显式地装饰，并采用装饰器施加的改变的行为。因此,@符号只是一个语法糖，它隐式地改变了被修饰函数的行为。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="2400" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">试探性解决方案</h1><p id="55f8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通过理解场景背后的东西，考虑更新装饰函数的一个天真的方法是添加另一个参数，即回显次数的计数。这样的实现如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="dd56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们能够通过显式使用装饰器来指定回显计数。让我们更进一步，看看我们是否可以简单地使用@符号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，这种方法似乎行不通。如上面的代码片段所示，错误告诉我们新的装饰器是<code class="fe ly lz ma mb b">missing 1 required positional argument: ‘func’</code>，因此它无法装饰<code class="fe ly lz ma mb b">greet</code>函数。由于这一失败，尝试调用该函数肯定是行不通的。</p><p id="5756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们怎样才能用一种允许我们使用@ symbol语法进行函数修饰的方式来解决这个问题呢？毕竟，我确实相信使用@符号比显式调用装饰器更好。</p><blockquote class="ng"><p id="7e7c" class="nh ni it bd nj nk nl nm nn no np lu dk translated">“漂亮总比难看好。”-蟒蛇的禅</p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ab45" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">更好的解决方案</h1><p id="8100" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了找到更好的解决方案，我们要解决的第一个问题是为什么会产生错误<code class="fe ly lz ma mb b">missing 1 required positional argument: ‘func’</code>。错误信息非常清楚。当我们使用@符号进行修饰时，我们的Python解释器只能找到关键字参数<code class="fe ly lz ma mb b">count</code>，而不能找到位置参数<code class="fe ly lz ma mb b">func</code>。</p><p id="4101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止解释器寻找<code class="fe ly lz ma mb b">func</code>参数，下面是我们解决问题的方法。因为它不太简单，所以我包含了一些打印日志，这样我们就可以知道代码的哪些部分被准确地调用了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="f790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们声明了一个名为<code class="fe ly lz ma mb b">better_echo_wrapper_count</code>的装饰器，它只接受一个<code class="fe ly lz ma mb b">count</code>参数。在其中，我们声明了一个嵌套函数，它可以将待修饰的函数作为参数，并返回包装的函数。</p><p id="4f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么会这样？让我们来看一下装饰步骤，如下面的第2部分所示，它具有与这个装饰函数完全相同的打印输出。</p><p id="c27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是了解装修过程的关键。你可以认为<code class="fe ly lz ma mb b">@better_echo_wrapper_count(count=3)</code>是调用<code class="fe ly lz ma mb b">better_echo_wrapper_count</code>函数。重要的是，返回的装饰函数<code class="fe ly lz ma mb b">decorator</code>装饰了<code class="fe ly lz ma mb b">good_morning</code>函数。流程是这样的:<code class="fe ly lz ma mb b">@better_echo_wrapper_count(count=3) -&gt; @decorator -&gt; decoration</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，您必须使用圆括号调用更好的装饰函数，如<code class="fe ly lz ma mb b">better_echo_wrapper_count()</code>，以获得返回的嵌套装饰函数。如果您想省略括号，Python解释器所做的就是假设您正在将待修饰的函数作为<code class="fe ly lz ma mb b">count</code>参数传递，这根本行不通。考虑下面的例子，注意为<code class="fe ly lz ma mb b">count</code>参数打印的粗体字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以接受的是，我们可以要求这个<code class="fe ly lz ma mb b">better_echo_wrapper_count</code>的所有用户记得使用括号，使装饰按预期工作。但是如果有人忘记使用括号怎么办？从预防bug的角度来看，我们可能想现在就处理它。</p><p id="10f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何做到这一点？</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="1037" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">最佳解决方案—版本1</h1><p id="2b8b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了得到最好的解决方案，我们只需要实现一种机制，能够处理装饰者被用作<code class="fe ly lz ma mb b">@decorator</code>和<code class="fe ly lz ma mb b">@decorator()</code>的情况。对于前一种情况，装饰函数将待装饰函数作为位置参数，而对于后一种情况，装饰函数执行并返回其嵌套的装饰函数，该函数随后装饰待装饰函数。</p><p id="a91c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们同意这种理解，我们可以继续下面的代码片段，看看如何创建正确的分支。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码所示，我已经列出了处理我们上面讨论的两个场景的两个可能的分支，我们可以用下面的例子来尝试这两个分支。太好了，一切正常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="afef" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">最佳解决方案—版本2</h1><p id="b656" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们很高兴我们得到了最好的解决方案，它允许用户根据需要省略括号或者指定<code class="fe ly lz ma mb b">count</code>参数。然而，如果您更仔细地关注声明的decorator <code class="fe ly lz ma mb b">best_echo_wrapper_count</code>函数，您会发现许多代码都是重复的。让我们考虑下面缩短的伪代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="cc6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe ly lz ma mb b">outer_decorator0</code>和<code class="fe ly lz ma mb b">outer_decorator1</code>函数具有完全相同的结构。因此，我们应该考虑称为<em class="lv"> currying </em>的技术，它指的是通过应用部分参数从现有函数创建新函数。如果您有兴趣了解更多，我在以前的文章“Python函数:Lambdas、Closures、decorator和Currying ”中介绍了这个主题和常规decorator</p><p id="b7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以通过应用部分函数技术来更新我们的最佳解决方案。请看下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="f2ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码所示，当<code class="fe ly lz ma mb b">func</code>参数为<code class="fe ly lz ma mb b">None</code>时，我们使用根据需要返回装饰函数的<code class="fe ly lz ma mb b">partial</code>函数。我们用两个例子来测试更新的版本，两个例子都像预期的那样工作。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="e9ae" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="159b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在本文中，我们回顾了如何编写接受参数的装饰器。更重要的是，我们学会了编写更健壮的装饰器，可以处理不使用括号的默认装饰器语法(即<code class="fe ly lz ma mb b">@decorator</code>)以及设置参数和显式调用装饰器函数的情况(即<code class="fe ly lz ma mb b">decorator(count=x)</code>)。</p><p id="0b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>