# 掌握这 5 个主题，为你的下一次 JavaScript 面试做好准备

> 原文：<https://betterprogramming.pub/master-these-5-topics-to-nail-your-next-javascript-interview-2b0da3380e5c>

## 在面试新的 JavaScript 开发人员时，我总是使用这个清单

![](img/56e4fcb5dbea64e7d7c6f7edbc2ec10a.png)

照片由[迈克尔·德莫亚](https://unsplash.com/@demoya?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/interview?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

面试一份新工作会让人精疲力尽。每个公司都有自己独特的测试你的方式。在决定你是否有价值时，每个面试官都有一套偏好的话题。

当谈到 JavaScript 时，有太多的主题需要涉及。实际上，你可以谈论任何事情——如果你面试的是一个特定的基于框架的角色(例如，React 开发人员、Vue guru 等),就更是如此。).

然而，根据我的经验，我发现任何能够真正理解以下五个主题如何工作的开发人员都可以处理我可能扔给他们的任何东西。

所以事不宜迟，这里是我认为任何面试 JS 职位的人都必须知道的五大 JavaScript 话题。

# 事件循环

JavaScript 中的事件循环是面试中一个确定无疑的问题。这个问题可能有不同的形式，但是你真正需要理解的是引擎如何解析和执行你的代码来处理不同的任务。

## 这与 JavaScript 无关

这是其中一把钥匙。事件循环属于引擎(通常是[谷歌的 V8](https://v8.dev/) )，不属于语言本身。

## 没有线程——嗯，几乎没有

接下来要理解的是，事件循环负责处理和启用 JavaScript 中的异步行为。关于这一点最常见的误解之一是，引擎使用 [libuv](https://libuv.org/) 通过 C++中的线程实现这些调用。

虽然在某些特定情况下确实如此，但常见的异步用例已经被您正在与之交互的 API(例如，操作系统、外部数据库等)所涵盖。)，不再需要定制线程。

## 这都是关于阶段的

循环的另一个关键方面是它有不同的阶段，每个阶段处理不同类型的异步函数。

这些阶段是:

*   **定时器**:在此阶段，`setTimeout`和`setInterval`被评估。
*   **回调**:这些是特定于系统的回调，在需要时被调用。
*   **检查**:我们的好朋友`setImmediate`在这个阶段得到评估。
*   **关闭** **事件**:在此阶段调用所有的`close`事件回调。
*   **Poll** :这里是执行所有 I/O 相关回调的地方。如果所有的回调函数都被调用了，那么循环将在这里等待，直到新的函数被注册。

通常在正常执行时，首先引起引擎注意的是当前线程。一旦完成，它需要调用`nextTick`，所以如果你用这个函数设置了任何回调，它们将在下一个被执行。

现在可以开始了，但通常我们可以预期以下顺序:计时器、检查，最后是轮询。

您可以编写一个简短的代码片段来检查这种行为:

您希望这个脚本的输出是什么？根据我们所了解的，你应该能猜到:

```
5: Current thread - Fibonacci(20): 6765 - Callback
Next Tick Call #1
Next Tick Call #2
4: Timers...
3: Checks (setImmediate) ...
2: Polling (reading file)...
1: Polling (http request)...
```

首先是当前线程(如果完成斐波那契数列)。然后调用下一个 tick 回调，因为这就是循环正在做的事情(调用`nextTick`)。然后轮到计时器了。之后才是`setImmediate`——如果你仔细想想，这是很讽刺的。三次回调比这次更直接。

最后，进入轮询阶段，这里的执行顺序取决于操作。读取文件比执行 HTTP 请求要快得多，所以这里首先调用第二个回调。

## 关于计时器的一个有趣推论

在跳到下一个主题之前，我想先介绍一个关于定时器的小细节。所有三个基于时间的回调，`setImmediate`、`setInterval`和`setTimeout`，都不能保证在您配置它们的时候被执行。

正如您注意到的`setImmediate`的延迟执行，其他因素也会影响执行时间。因此，不是确保您的回调将在您配置的超时时间(或您配置的时间间隔)准确地被调用*，而是一旦该时间过去，回调将至少被调用*。不会更早，但也不一定正好在那个时候。**

# 提升

这是一个快速而简单的概念，但也因此容易被忽视。提升在 JavaScript 中定义了一个特殊的行为，如果你不考虑它，它会影响你的答案的结果。

如果用`var`而不是`let`来使用提升更有意义——因为如果用`var`定义变量，可以在声明发生之前使用它(在正确的范围内)。引擎会将所有变量声明移动到顶部，允许您使用它们而不会出现引用错误。

然而，用`let`声明的变量没有同样的好处。如果你使用的是`let`，那么虽然你的代码块知道它，但是你不能在它声明之前使用它——相反，你会得到一个引用错误。

当你试图给`y`赋值时，上面的代码会在第 7 行抛出一个异常，因为它是在第 15 行用`let`定义的。您还可以看到如何在第 2 行使用在第 14 行定义并赋值为 10 的`x2`——但是没有实际赋值。这是因为提升只是将声明移动到顶部，其他什么都没有。

# 这是什么？

虽然我们倾向于将关键字`this`与 OOP 上下文联系起来，但是 JavaScript 让这个关键字随处可及。

您现在就可以在您最喜欢的 JS 运行时上编写`console.log(this)`——无论是您的浏览器控制台还是带有节点 REPL 的终端窗口——您都会得到一个有效的结果。

`this`关键字引用代码执行的上下文，虽然在代码中间使用它没有什么意义，但在函数或方法调用中使用它很有意义。

## 在函数调用内部

除非另有说明，函数可以通过`this`关键字访问全局对象。在浏览器上下文中，该关键字将引用`window`对象。然而，在 Node 中，您可以访问`globalThis`对象，该对象引用了`setInterval`、`setImmediate`等方法。

您可以通过两种方式影响此行为:

1.  如果您设置了严格模式，那么除非另有说明，`this`关键字将是未定义的。
2.  一旦调用函数，可以使用`bind`或`call`和`apply`等函数方法覆盖`this`的值。

## 在方法调用内部

方法调用是对关键字`this`更直观的使用。换句话说，使用`this`关键字将引用对象本身，允许您访问其他方法或属性。

然而，您可以利用这样一个事实，即方法只是 JavaScript 中的函数，并且您还可以在调用它们时覆盖它们的`this`引用。

根据定义，上面的代码不应该工作——类`C2`没有名为`method1`的方法。但是，我们可以通过执行以下操作来实现这一点:

注意我们是如何用对另一个对象(具有所需方法的对象)的引用来覆盖`this`关键字的。这样做肯定是危险的，只有当你明白自己在做什么以及为什么要做的时候，你才应该这样做。

## 箭头函数如何改变这一点？

最后，由于 JavaScript 组合中添加了箭头函数，我们还需要考虑另一种行为。

函数和 arrow 函数的主要区别之一是，后者没有自己定义的`this`或执行上下文。相反，它们从它们的父类继承一个(当被定义时)，所以对于 arrow 函数来说，这是关于何时以及如何定义它们的问题。

这就是为什么将箭头函数用作文字对象的方法并不理想，但将它们用作独立的函数并在调用它们时正确绑定它们的上下文才是理想的。

# 关闭

在我的采访中，我通常会问一个关于这个话题的简单问题:什么是结束？

我希望得到的答案是这样的:当一个函数被定义时，JavaScript 获取其上下文的快照，并将其与新定义相关联。这允许您的函数被分配和传递，并且仍然可以访问它的上下文。

我通常使用下面的函数作为例子:

你认为这个函数会输出什么？当然，它会在你的终端上打印`10`，这是因为当匿名函数被声明时，它的执行上下文也被附加到它上面。因此当我们返回它时，它仍然可以访问变量`a`。

# 生活

也称为*立即调用的函数表达式，*这些函数是在定义后立即调用的。

他们没什么奇怪的。这只是一个正确书写定义的问题，这样你就可以用一组括号把它括起来，然后执行那个表达式。

换句话说:

就是这样。如果你将代码复制并粘贴到 REPL 中，它会自动调用这个函数。

那么他们有什么好宣传的呢？IIFEs 对于创建一个作用域块非常有用，在这个作用域块中，您可以定义依赖关系而不会有命名冲突。

换句话说，在使用不同库的环境中，当其中一些库可能有相同的名称或者有冲突名称的导出方法时，IIFEs 允许您定义包含哪些依赖项，而不会引起任何冲突。

想象一下在一个已经使用了[下划线. js](https://underscorejs.org/) 的项目中不得不使用 [lodash](https://lodash.com/) 。我知道，这是一个非常困难的用例，但是很方便，所以我要用它。如果添加 lodash，就会与导出的全局`_`发生名称冲突。然而，您可以定义一个 IIFE 来封装您的逻辑并接收 lodash 作为参数。

这样，函数中的`_`将只引用您想要的，因为它覆盖了全局名称。

# 结论

掌握 JavaScript 面试并不容易——有许多不同的主题要涉及，而针对特定框架的问题就更难了。然而，一些基本主题影响 JavaScript 相关开发的所有领域，这五个主题涉及所有领域。

你呢？在之前的采访中，你是否不得不面对我在这里没有提到的其他难以破解的话题？