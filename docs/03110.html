<html>
<head>
<title>To Be or Not to Be</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生存还是毁灭</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/to-be-or-not-to-be-2c372198a01c?source=collection_archive---------8-----------------------#2020-01-21">https://betterprogramming.pub/to-be-or-not-to-be-2c372198a01c?source=collection_archive---------8-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="216b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在React中选择受控和非受控组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/70960cd3f47a2c0aa3397259ccb8fe2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-MtoeTZG4yzKDEQpvidBw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥利弗·施文德纳在<a class="ae ky" href="https://unsplash.com/s/photos/control?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ba5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">受控</a>和<a class="ae ky" href="https://reactjs.org/docs/uncontrolled-components.html" rel="noopener ugc nofollow" target="_blank">非受控</a>组件是React中的两个重要概念。了解它们之间的区别以及哪种情况最适合它们是至关重要的。</p><p id="8a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React中的受控和非受控组件是什么？</p><ul class=""><li id="1f3c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">受控组件管理其子组件的数据。</li><li id="b1d5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不受控制的组件让其子组件管理自己的数据。</li></ul><p id="665c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面定义中提到的孩子是典型的HTML表单元素，比如<code class="fe mj mk ml mm b">&lt;input&gt;</code>、<code class="fe mj mk ml mm b">&lt;textarea&gt;</code>、<code class="fe mj mk ml mm b">&lt;select&gt;</code>等。在本文中，我们将以<code class="fe mj mk ml mm b">&lt;input type=”text”&gt;</code>为例。</p><p id="b8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子也可以是反应组分。</p><p id="99d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不受控制的组件使用自然的HTML方式，让DOM保存和更新它们的值。下面的<code class="fe mj mk ml mm b">App</code>是一个不受控制的组件，其中的输入值由HTML元素<code class="fe mj mk ml mm b">&lt;input&gt;</code>维护。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">受控组件被称为React方式，由React团队推荐。</p><p id="9e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">受控输入通过一个属性接受它的值，并提供一个回调来更新这个值。该值通常由组件的状态保存。用法很简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一些例子来看看受控组件和非受控组件的区别。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="2fd5" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">示例1:将每个输入按键转换为大写</h1><p id="b9ab" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们如何管理不受控制的组件？React提供事件处理程序来检测更改，然后使用回调来响应更改。</p><p id="ded7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，<code class="fe mj mk ml mm b">onChange</code>处理器将不受控制的输入值转换成大写。这发生在每次击键时。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="47ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过使用如下受控部件来实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="5397" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">示例2:用初始值将每个输入键转换为大写</h1><p id="23f5" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们稍微修改一下例子一，让它有一个初始值。下面是不受控制的组件如何处理初始值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是受控组件处理初始值的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="b31d" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">示例3:单击按钮后将输入转换为大写</h1><p id="9383" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在这个例子中，我们想要演示外部事件是如何管理input元素的。大写转换被延迟，直到点击一个按钮。</p><p id="02c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们面临一个问题。从按钮的事件处理程序中，我们无法访问这个不受控制的输入字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React提供了解决这类问题的参考。ref是访问DOM元素或React元素的一种方式。</p><p id="de10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，<code class="fe mj mk ml mm b">React.useRef()</code>生成一个ref，<code class="fe mj mk ml mm b">textInput</code>。这个引用被传入输入元素，并在安装时使<code class="fe mj mk ml mm b">textInput.current</code>指向这个输入元素。</p><p id="5b6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们能够使用<code class="fe mj mk ml mm b">textInput.current</code>来管理这个不受控制的输入值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是匹配的受控组件示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="7bc8" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated"><strong class="ak">示例4:将有效输入转换为大写</strong></h1><p id="3705" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们在这个例子中添加了验证。在这里，只有字母是有效的输入。当键入无效的键时，它会被忽略，并显示一条红色错误消息。</p><p id="9163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于不受控制的组件，通用的<code class="fe mj mk ml mm b">onChange</code>事件处理程序被替换为<code class="fe mj mk ml mm b">onKeyPress</code>，因为我们可能需要在<code class="fe mj mk ml mm b">onChange</code>发生之前停止默认行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于受控组件，它不需要更改事件处理程序，也不需要阻止输入元素的默认行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="5738" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">示例5:表单提交用例</h1><p id="d40d" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">下面是一个表单提交用例:</p><ul class=""><li id="9844" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">有两个输入字段:姓名和电子邮件。姓名是必填字段，电子邮件需要通过正则表达式测试。</li><li id="6dd2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果存在验证错误，第一个错误将以红色显示。</li><li id="4861" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">只有当所有输入值都有效时，提交按钮才会启用。</li><li id="65e9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">提交表单后，会立即显示发送的信息。该消息会一直显示，直到用户开始输入新值。</li></ul><p id="d970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码使用了一个不受控制的组件。未受控制的特定行被突出显示，其中<code class="fe mj mk ml mm b">handleChange</code>执行验证并启用/禁用按钮。</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="21ee" class="nx mx it mm b gy ny nz l oa ob">const App = () =&gt; {<br/>  const [error, setError] = React.useState('');<br/>  const [submission, setSubmission] = React.useState('');<br/>  <strong class="mm iu">const form = React.useRef();</strong><br/>  const handleChange = () =&gt; {<br/>    <strong class="mm iu">const { name, email, submit } = form.current;</strong><br/>    <strong class="mm iu">if (!name.value) {<br/>      setError('Name is required');<br/>      submit.disabled = true;<br/>    } else if (!/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(email.value)) {<br/>      setError('Invalid email');<br/>      submit.disabled = true;<br/>    } else {<br/>      setError('');<br/>      submit.disabled = false;<br/>    }<br/>    </strong>setSubmission('');<strong class="mm iu"><br/>  };</strong><br/>  const handleSubmit = e =&gt; {<br/>    e.preventDefault();<br/><strong class="mm iu">    const { name, email, submit } = form.current;<br/>    if (!error) {<br/>      setSubmission(`Sent info - name: ${name.value}, email: ${email.value}`)<br/>      submit.disabled = true;<br/>      e.target.reset();<br/>    }</strong><br/>  };<br/>  return (<br/>    &lt;form <strong class="mm iu">ref={form}</strong> onSubmit={handleSubmit}&gt;<br/>      &lt;input name="name" onChange={handleChange}/&gt;<br/>      &lt;input name="email" onChange={handleChange}/&gt;<br/>      &lt;div&gt;{submission}&lt;/div&gt;<br/>      &lt;button name="submit" <strong class="mm iu">disabled</strong> type="submit"&gt;Submit&lt;/button&gt;<br/>    &lt;/form&gt;<br/>  );<br/>}</span></pre><p id="0938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是等效的受控组件代码。受控制的特定行被突出显示，其中<code class="fe mj mk ml mm b">handleChange</code>更新子数据，而<code class="fe mj mk ml mm b">React.useEffect</code>执行验证并启用/禁用按钮。</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="e8f8" class="nx mx it mm b gy ny nz l oa ob">const App = () =&gt; {<br/>  <strong class="mm iu">const [name, setName] = React.useState('');<br/>  const [email, setEmail] = React.useState('');</strong><br/>  <strong class="mm iu">const [isDisabled, setIsDisabled] = React.useState(true);</strong><br/>  const [error, setError] = React.useState('');<br/>  const [submission, setSubmission] = React.useState('');<br/>  <strong class="mm iu">const handleChange = e =&gt; {<br/>    if (e.target.name === 'name') {<br/>      setName(e.target.value);<br/>    } else if (e.target.name === 'email') {<br/>      setEmail(e.target.value);<br/>    }<br/>    </strong>setSubmission('');<strong class="mm iu"><br/>  };</strong><br/>  const handleSubmit = e =&gt; {<br/>    e.preventDefault();<br/><strong class="mm iu">    if (!error) {<br/>      setName('');<br/>      setEmail('');<br/>      setSubmission(`Sent info - name: ${name.value}, email: ${email.value}`)<br/>      setIsDisabled(true);<br/>    }</strong><br/>  };<br/><strong class="mm iu">  React.useEffect(() =&gt; {<br/>    if (!submission) {<br/>      if (!name) {<br/>        setError('Name is required');<br/>        setIsDisabled(true);<br/>      } else if (!/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(email)) {<br/>        setError('Invalid email');<br/>        setIsDisabled(true);<br/>      } else {<br/>        setError('');<br/>        setIsDisabled(false);<br/>      }<br/>    }<br/>  }, [submission, name, email]);  </strong><br/>return (<br/>    &lt;form onSubmit={handleSubmit}&gt;<br/>      &lt;input name="name" <strong class="mm iu">value={name}</strong> onChange={handleChange}/&gt;<br/>      &lt;input name="email" <strong class="mm iu">value={email}</strong> onChange={handleChange}/&gt;<br/>      &lt;div style={{color: "red"}}&gt;{error}&lt;/div&gt;<br/>      &lt;div&gt;{submission}&lt;/div&gt;<br/>      &lt;button name="submit" <strong class="mm iu">disabled={isDisabled}</strong> type="submit"&gt;Submit&lt;/button&gt;<br/>    &lt;/form&gt;<br/>  )<br/>}</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="2484" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">示例6:具有反应子组件</h1><p id="1be1" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们在开始时已经提到，识别受控和非受控组件的方法可以应用于React组件的子组件。</p><p id="a36a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的示例中，<code class="fe mj mk ml mm b">App</code>是一个非受控组件，尽管它的子组件<code class="fe mj mk ml mm b">ShowUpperCase</code>是一个受控组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="85d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的行为可以用受控的方式编码。接下来的<code class="fe mj mk ml mm b">App</code>是一个受控组件，管理<code class="fe mj mk ml mm b">ShowUpperCase</code>的数据。<code class="fe mj mk ml mm b">ShowUpperCase </code>也是受控成分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="9dd0" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="4948" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">您已经看到了一些受控和非受控组件的例子。两种方式都可行。你可以选择一种方式来编码你的用例。</p><p id="f51c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于特定的组件，坚持一种方式。不要将同一组件的受控和非受控方式混合使用。此外，不要在组件的生存期内切换类型。</p><p id="7456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您可能会在调试器控制台中遇到此警告:</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="09bf" class="nx mx it mm b gy ny nz l oa ob">A component is changing an uncontrolled input of type checkbox to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa).</span></pre><p id="eb68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是由于您意外地将状态设置为<code class="fe mj mk ml mm b">null</code>或<code class="fe mj mk ml mm b">undefined</code>，这在React中被视为不受控制。当您取消设置一个值时，记得将其设置为<code class="fe mj mk ml mm b">‘’</code>或<code class="fe mj mk ml mm b">false</code>。</p><p id="a098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候考验你的知识了！</p><p id="6b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，<code class="fe mj mk ml mm b">App</code>是受控组件还是非受控组件？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="07e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是不受控制。</p><p id="818b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">App</code>写为受控元件，但<code class="fe mj mk ml mm b">undefined</code>值将输入元件切换为不受控！</p><p id="5fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有任何问题，请随时回复。</p></div></div>    
</body>
</html>