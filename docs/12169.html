<html>
<head>
<title>Design Considerations for Scaling WebSocket Server Horizontally With a Publish-Subscribe Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用发布-订阅模式水平扩展WebSocket服务器的设计考虑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-considerations-for-scaling-websocket-server-horizontally-with-a-publish-subscribe-pattern-fe6de9988400?source=collection_archive---------0-----------------------#2022-05-17">https://betterprogramming.pub/design-considerations-for-scaling-websocket-server-horizontally-with-a-publish-subscribe-pattern-fe6de9988400?source=collection_archive---------0-----------------------#2022-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="324f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解扩展WebSocket服务器的挑战</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e48110b449243735c18f0bd2e7147ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gljZpEJYexzs1XasRFLRA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯利·西克玛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" href="https://medium.com/@kbryan1008/building-a-websocket-server-in-a-microservice-architecture-50c6c6432e2b" rel="noopener">上一篇文章</a>中，我写了在微服务架构中设计和构建一个WebSocket服务器。尽管该实现对于WebSocket服务器的单个实例来说工作得很好，但是当我们试图扩大WebSocket服务器实例的数量(也称为水平扩展)时，我们将开始面临问题。本文研究了使用发布-订阅消息传递模式扩展WebSocket服务器的设计考虑。</p><h1 id="4f0b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">我的Websocket </strong>服务器<strong class="ak">系列</strong></h1><ul class=""><li id="4cd4" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">01: <a class="ae ky" href="https://medium.com/@kbryan1008/building-a-websocket-server-in-a-microservice-architecture-50c6c6432e2b" rel="noopener">在微服务架构中构建WebSocket服务器</a></li><li id="13df" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">02:使用发布-订阅模式水平扩展WebSocket服务器的设计考虑</li><li id="8839" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">03: <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/implement-a-scalable-websocket-server-with-spring-boot-redis-pub-sub-and-redis-streams-b6b8cc08767f">使用Spring Boot、Redis发布/订阅和Redis流实现可伸缩的WebSocket服务器</a></li><li id="9b25" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">04:待定</li></ul><h1 id="5aff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是水平缩放？</h1><p id="91ff" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">首先，让我们试着理解为什么我们需要水平缩放。随着我们用户群的增长，服务器上的负载也在增长。当负载增加时，单个服务器将无法为所有用户提供高性能。因此，作为我们设计考虑的一部分，有必要提供随时增加/减少服务器数量的能力，以满足用户需求并节省资源。</p><p id="1dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">水平扩展是指在基础设施中添加更多的机器，以应对服务器的高需求。在我们的微服务环境中，水平扩展等同于部署更多的微服务实例。然后需要一个负载平衡器在多个微服务实例之间分配流量，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a0ea7be9874eff47c70d769a8acf5235.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*__94_a1adMCwyR5-rfm9Uw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用负载平衡器进行水平扩展的示例</p></figure><p id="b219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我希望您能更好地理解为什么我们的基础设施需要水平扩展。因此，让我们继续学习在微服务架构中扩展WebSocket服务器的设计考虑。</p><h1 id="f32c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">快速回顾</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2aa0674fd5c786d927ed15859450cc02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*xYb_K9eI3e92RaeSC_CAkA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">微服务架构中WebSocket服务器的高级图</p></figure><p id="179a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前，我们使用Spring Boot、Stomp和Redis Pub/Sub实现了WebSocket服务器。web应用程序(前端)和WebSocket服务器之间的通信是通过WebSocket进行的，而微服务(后端)和WebSocket服务器之间的通信是通过API和发布-订阅消息模式进行的。有关更多信息，请参考<a class="ae ky" href="https://medium.com/@kbryan1008/building-a-websocket-server-in-a-microservice-architecture-50c6c6432e2b" rel="noopener">上一篇文章</a>。</p><h1 id="27b7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有哪些问题和解决方案？</h1><p id="110d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">之前的设计在每个微服务只有一个实例的设置中运行得非常好。但是，在生产环境中拥有单个实例是不实际的。通常，我们将部署带有多个副本(或实例)的微服务，以在生产环境中实现高可用性。因此，当我们试图横向扩展WebSocket服务器(微服务)或后端微服务的数量时，我们会注意到以下问题。</p><h2 id="96ce" class="ni lw it bd lx nj nk dn mb nl nm dp mf li nn no mh lm np nq mj lq nr ns ml nt bi translated"><strong class="ak">问题#1:负载均衡器导致的消息丢失</strong></h2><p id="e7c5" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在我们的上一篇文章中，我们为后端微服务添加了API，以便向WebSocket服务器发送消息，进行单向实时通信。如下所示，当扩展WebSocket服务器的数量时，负载平衡器有助于处理流量重定向。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/702680054253c706d750ca3500455e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHGQpCNZLBV9kb3SxiPKfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过API从微服务(后端)向web应用程序(前端)发送消息时出现问题</p></figure><p id="69a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的设置中，web应用程序的一个实例(前端)建立到WebSocket服务器的WebSocket连接(实例B)。当后端服务器试图向web应用程序发送消息时，负载平衡器将API请求重定向到WebSocket服务器(实例A)。因为WebSocket服务器(实例A)没有到web应用程序的特定实例的WebSocket连接，所以消息将会丢失。</p><h2 id="9e41" class="ni lw it bd lx nj nk dn mb nl nm dp mf li nn no mh lm np nq mj lq nr ns ml nt bi translated"><strong class="ak">问题#1的解决方案:使用发布/订阅广播消息</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/5d0e4d68f3b64b22f8835cb9626b65a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lpvtgq3wXjM3u4Ds0HEIZw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">负载均衡器导致消息丢失的解决方案</p></figure><p id="5fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nv">注:</em> </strong> <em class="nv">这个解决方案很大程度上受到了</em><a class="nw nx ep" href="https://medium.com/u/a0e9fafab843?source=post_page-----fe6de9988400--------------------------------" rel="noopener" target="_blank"><em class="nv">Amr Saleh</em></a>、<em class="nv">的启发，他们写过关于</em> <a class="ae ky" href="https://medium.com/javarevisited/building-scalable-facebook-like-notification-using-server-sent-event-and-redis-9d0944dee618" rel="noopener"> <em class="nv">使用服务器发送的事件和Redis </em> </a> <em class="nv">构建可伸缩的脸书式通知。一定要去看看！</em></p><p id="a15f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解决第一个问题，我们可以使用发布-订阅消息模式引入一个广播通道，从后端微服务接收的所有消息都将广播到所有WebSocket服务器实例，如上图所示。这确保了所有web应用程序实例(前端)将通过WebSocket从WebSocket服务器接收该消息。</p><h2 id="3e11" class="ni lw it bd lx nj nk dn mb nl nm dp mf li nn no mh lm np nq mj lq nr ns ml nt bi translated"><strong class="ak">问题#2:由于多个后端订阅者对一个主题进行重复的消息处理</strong></h2><p id="4fed" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在我们之前的文章中，我们使用Redis Pub/Sub来处理WebSocket服务器(微服务)和后端微服务之间的双向实时通信。当我们增加WebSocket服务器和后端微服务的数量时，您会注意到Redis Pub/Sub的所有订户都会收到如下所示的消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/1459dc626cf317609b46085276b28839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vcoO_fHIeVVmKaIra9jVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">web应用(前端)和微服务(后端)之间的双向实时通信</p></figure><p id="6c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看双向实时通信中每个方向的消息流。</p><ul class=""><li id="6c1b" class="mn mo it lb b lc ld lf lg li ny lm nz lq oa lu mu mv mw mx bi translated">消息流:微服务到web应用程序(无重复处理)→WebSocket服务器的所有实例都必须接收消息，因为每个web浏览器只与一个WebSocket服务器实例建立web socket连接。因此，当消息从后端微服务流向web应用程序时(后端→ WebSocket服务器→前端)，只有web应用程序的一个实例会收到消息，这是正确的行为。</li><li id="4a23" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">消息流:web应用程序到微服务(重复处理)→当消息从Web应用程序流向后端微服务(前端→ WebSocket服务器→后端)时，我们预计只有一个后端微服务实例来处理消息。但是，所有后端微服务(作为订阅者)都会收到消息，导致消息被多次处理，这是不正确的行为。</li></ul><h2 id="2d48" class="ni lw it bd lx nj nk dn mb nl nm dp mf li nn no mh lm np nq mj lq nr ns ml nt bi translated"><strong class="ak">问题#2的解决方案:针对消费者群体的发布/订阅</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/fb9b393295afe6befb90b8e53c783ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQ2pv6sul59U1ub3ylMYNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个主题有多个后端订阅者导致的重复消息处理的解决方案</p></figure><p id="1e26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决第二个问题，我们将利用消费者群体的概念(由Kafka引入)，其中只有一个订户接收消息进行处理。这确保了不会有重复的消息处理，因为只有一个后端微服务实例将接收消息。</p><p id="e24d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我在上一篇文章《实现》中的Redis Pub/Sub不支持消费者组概念，我们可以使用Redis Streams、Google Pub/Sub、RabbitMQ或Apache Kafka来实现消费者组的发布-订阅消息传递模式。我不会详细讨论哪种方法更适合您的实现，因为这不是本文的目的。</p><h1 id="0ef1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/54f63601260a1a6c4b3336bc1019c7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ecRAWPvb7GeOhaG3UGZKIQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用发布-订阅模式在微服务架构中扩展WebSocket服务器的完整设计</p></figure><p id="b109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们讨论了如何在微服务架构中水平扩展WebSocket服务器的设计考虑。本质上，我们使用发布-订阅消息传递模式来确保在web应用程序(前端)和微服务(后端)之间的实时通信过程中没有消息丢失或重复的消息处理。</p><p id="c302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我希望你能从这篇文章中学到一些新的东西。本文只讨论了扩展WebSocket服务器的设计考虑。请继续关注下一篇文章，我将详细阐述如何使用Redis发布/订阅、Redis流和Spring Boot来实现这种设计。</p><p id="650e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，请关注我获取更多内容:)。</p><p id="3d55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你一直读到最后。快乐学习！</p></div></div>    
</body>
</html>