# 为什么我喜欢不完美的软件开发实践

> 原文：<https://betterprogramming.pub/why-i-prefer-imperfect-software-development-practices-b13cfdcf85bf>

## 程序员世界

## 完美可能会成为软件开发的障碍

![](img/071ddd31ee6eed26d914d73ee0374e70.png)

丁满·克劳斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

工程学是一门要求完美的学科。为了获得最佳结果，需要有一个完整、全面、彻底、一致和详尽的流程。软件开发被认为是工程领域的产物。

软件开发，在其初期，试图尽可能地遵循工程原则。然而，我们学到了很多，并意识到软件开发是一个与它的兄弟工程领域非常不同的领域。

以下是这些天它是如何改变和偏好的。

# 优先收集最少的需求，而不是完整的需求

> "如果两者都冻结了，在水面上行走和根据规范开发软件是容易的."
> —爱德华·v·贝拉德

## 过去的实践

需求收集过程是瀑布软件开发模型中非常繁琐的第一个过程。这需要一个团队花上几个月的时间来完成。一旦完成，它被签名并被认为是冻结的，然后可以开始软件实现。

面临的挑战是，当软件准备生产时，需求已经改变，竞争对手已经将他们的产品投放市场。

## 首选实践

> “人们不知道他们想要什么，直到你给他们看。”—史蒂夫·乔布斯

在软件领域，谁能在市场上获得最完整的功能不再是赢家。相反，是那些人提供了第一个创新功能。他们获得了市场份额的最佳初始优势。

将最少可用的软件产品交付给用户更好，因为我们可以更好地了解什么在那里起作用，以及我们应该如何为我们的下一个产品优先级操纵方向。对软件进行增量改进是可能的，因为——与硬件不同，软件中的变化可以更快地完成，也可以更快地发布。

因此，只要我们有了最低的(不完整的)需求，就可以开始开发并快速推向市场。这个概念叫做[最小可行产品](https://en.wikipedia.org/wiki/Minimum_viable_product) (MVP)。

# 比起全面的架构设置，更喜欢基本的

> 硬件设计经久耐用；
> 软件是为改变而设计的。变化是唯一永恒的东西；
> 软件胜。

## 过去的实践

就像工程一样，在编程中，我们希望建立一个全面的架构。不仅仅是为了当前的工作，也是为了未来的改变。希望是，在未来，我们可以只做最小的改变，它将实现我们接下来需要的。

对于下一次迭代，我们希望通过可重用性编写最少的代码并获得最大的输出。过程化编程通过功能共享使之成为可能。面向对象编程后来被引入，目的是使代码共享更加容易。这是通过拥有一个公共基类来实现的，这个基类被认为是最稳定的，并且可以被大量重用。

因此，很多时间都花在了考虑、辩论和构建一个全面的体系结构上，以迎合预测的未来变化。

## 首选实践

> “仅仅因为架构应该是稳定的，并不意味着它永远不会改变。”乔治·赫姆克斯

不幸的是，我们对变化的预测往往是有限的，甚至是错误的。当我们发现新的需求时，我们创建并希望迎合未来的坚实、完美的深度嵌套层次结构不再相关。

为了迎合新的需求，必须对底层基类进行重大修改。这可能会使事情变得复杂，因为它可能会影响从它继承的许多其他类。

因此，与其重复使用我们已经做的，我们必须重建新的基础来满足它的需求。我们许多为未来变化而设想的代码抽象无法投入使用。花费的时间被浪费了。

当我们了解到这一点时，我们知道最好建立一个更轻量级的架构框架，主要满足我们现在的需求，而不是未来的需求。

当新的需求出现时，我们可以看到我们是否需要调整架构或者为它重新实现一个不同的基础。虽然这种修改看起来会有更多的工作，但是如果时间花在需要的东西上，这是更可预测的。所有完成的作品都被使用。我们避免过度设计一些很可能永远不会出现的东西。

# 比起彻底的代码审查过程，我更喜欢足够好

> “编写代码时，始终要假设最终维护你代码的人是一个知道你住哪儿的暴力精神病患者。”—约翰·伍德

## 过去的实践

我们有一套完整记录的编码规则和指南。它们被相应地编入索引和条目，这样当我们在审查的代码中发现不符合时，我们可以很容易地引用它们。

编码审查过程是彻底的、严格的，并且必须涉及来自不同级别人员的多次批准。必须完全解决检测到的所有问题，然后才能批准它们进行签入。

如果做事的方式不止一种，那就需要充分讨论和试验。在继续之前，一个被证明的方法必须比另一个更好。这个过程需要很多迭代和时间。

有时，甚至给一个变量命名都涉及到许多争论。这是一个非常吓人的过程。

## 首选实践

> *“*代码从来都不是‘完美的’代码永远只是“足够好”*——*马修·琼斯**

*拥有好的代码是很重要的，所以我们仍然需要执行代码审查来指出潜在的问题。但是我们必须权衡问题的严重性和延迟的影响以及额外的收益递减。关于如何解决这个问题，需要进行大量的讨论。有时，事后看来，同意或否决的方式可能是一个错误的决定。*

*通常要问的问题是:代码在逻辑上是否满足预期的业务需求？这里面是不是没有可能的重大漏洞或者黑客？这里或那里可能会有一些小问题——仍然应该让编码人员知道——但它不应该是一个阻止程序。*

*经验法则是:如果代码在 net 中的变化比代码变化前更好，那么它就是可以运行的代码。*

*因此，随着好代码的净变化，随着时间的推移，代码库应该会改进。一些不完美的代码会在我们不知道的情况下消失，因为它已经被新的功能所取代。变化发生得非常快。*

# *比起框架和工具的一致性，更喜欢互操作性*

> ***“一致性是企业的敌人**，
> ，正如对称是艺术的敌人**，
> —萧伯纳***

## *过去的实践*

*一致性是关键。无论是我们使用的工具集还是我们为系统采用的框架。其实一切都要尽可能标准化。*

*当事情一致时，开发人员可以很快熟悉它，每个人都可以说同一种语言，这将摩擦减到最小。培训和管理都将变得更加容易。*

*当一项新技术出现时，我们会有一个小团队对它进行实验，并且必须对它进行仔细评估，以确保它满足每个人的需求。*

*只有当发现它完全适合所有人时，团队才提供如何完全部署它的主要计划。一切都被搁置，以确保顺利部署重大变更。接下来是一个重大的全民训练计划。*

## *喜欢练习*

> *"**我们未来的成功与我们理解、采用新技术并将其融入到工作中的能力成正比。"—苏坎特·拉特纳卡***

*毫无疑问，一致性给软件开发带来了很多价值。一致性编码风格、命名约定、使用的工具集、框架、环境等。我们仍然应该尽可能地坚持一致性。*

*然而，变化，尤其是在软件开发社区中的变化，比我们的产品生命周期要快得多。如果我们不能足够快地适应变化，我们就会落后。在我们的整个项目中采用这种改变会花费太多的时间。新的技术变革不断涌现。一直改变我们的整个项目成本太高了。*

*因此，与其在改变一切和不改变之间做出选择，我们必须找到一个平衡的中间地带。让我们部分地适应这种变化——只在正在处理的区域。*

*让旧系统使用一个框架，让新系统使用另一个框架，只要它仍然可以互操作，这是可以的。一个简单的例子是在基于 Java 的项目中采用 Kotlin 代码。我们不需要一下子把整个代码库都改成 Kotlin。我们可以通过使用 Kotlin 而不是 Java 来编码一个新的模块，来逐步淘汰 Java。旧的特性总有一天会和旧的 Java 代码一起被移除。*

*这也是为什么我们需要一个轻量级架构的框架的原因之一，它允许人们更好地适应变化，同时使它们具有互操作性。如果我们架构得太深，底层基础可能会过于依赖旧框架，这使得适应新框架更加困难，互操作性更加棘手——如果不是不可能的话。*

*虽然新的变化并不总是与现有的变化具有互操作性，但是我们总是可以寻找一个连接它们的工具集。Docker 是一个让系统更加微型的好例子，它很容易组合在一起，让不同的系统可以互操作。*

# *更喜欢及时而不是详尽的质量保证*

> *"质量是免费的，但只对那些愿意花大价钱购买的人开放."— **德马科和李斯特***

## *过去的实践*

*由于在开发周期中发现 bug 时，bug 的成本会呈指数级增长，所以我们必须尽我们所能来消除所有的 bug，即使这意味着延迟将项目交付给客户。*

*对我们来说，最好是自己找到这些缺陷，而不是让它们落入客户手中。测试必须严格和详尽。它需要数周的时间，并通过不同的测试。:自动化、探索性、黑盒、白盒等。*

*需要核对一长串清单，最后，最高管理层必须签字同意发布。*

*它必须如此严格，因为下一个发布周期可能会在几个月后。我们希望避免在发布之间制作补丁的需要，因为这会使稳定的软件发布过程变得复杂。*

## *首选实践*

> *“有两种方法可以写出没有错误的程序；只有第三个管用。”—艾伦·珀利斯*

*质量仍然是非常重要的，我们不应该错过任何会影响大多数用户的关键问题。如果我们懈怠，这将是一个自杀的任务。但是我们知道我们永远也不会摆脱每一个 bug。*

*有了敏捷开发，我们现在已经缩短了开发周期。自然地，我们认为较短的开发周期和较短的测试时间会导致灾难性的错误产品。*

*然而，相反，它有助于更高的质量。原因如下:*

1.  *每个版本都由较小的增量变化组成。打破东西的风险也大大降低了。*
2.  *我们的测试也可以更加关注已经改变的范围，减少测试的时间，但是增加更多的时间来测试每个发布的风险区域，这有助于更好的质量。*
3.  *通过向用户发布更快的版本，以及适当的远程监控 bug 系统，我们可以获得更快的用户输入。我们可以更快地识别高问题区域。这导致更好的质量集中在优先用户特征上。*
4.  *由于发布速度更快，任何发现的问题都可以很快得到解决，因此减少了外部发现的错误的影响。当用户遇到问题时，他们会更加宽容，因为他们知道问题通常会很快得到解决。*

*QA 中的详尽性仍然很重要，但及时性很有帮助，有助于优先处理最重要的事情。*

*尽管软件也是一个工程领域，但与其他工程领域相比，它是一个完全不同的领域——这是由于它的“软”方面。*

*硬件工程受到其快速复制和分发能力的限制。它限制了快速变化的可能性，因此对开发后期发现的任何错误的影响要高得多。因此，管理它的过程必须规避风险，有严格的纪律。*

*另一方面，软件没有自我复制和快速发布的约束。任何错误都可以快速解决，因此它具有更高的风险承受能力。当出错的风险较低时，创新的加速度增加。*

> *软件的游戏不在于它能多经得起未来的考验，而在于它能多快地进化以满足人类不断增长的需求。*

> *警告:上述观点不适用于人命关天的软件产品——一个简单的错误就可能导致生命损失。*