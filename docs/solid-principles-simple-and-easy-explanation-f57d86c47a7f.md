# 坚实的原则-简单易懂的解释

> 原文：<https://betterprogramming.pub/solid-principles-simple-and-easy-explanation-f57d86c47a7f>

![](img/738dca35296d0c368002b57a3da1def0.png)

SOLID Principles 是一种编码标准，所有开发人员都应该对正确开发软件有一个清晰的概念，以避免糟糕的设计。它是由 Robert C Martin 提出的，并在面向对象设计领域广泛使用。如果应用得当，它会使你的代码更具可扩展性、逻辑性和可读性。

当开发人员按照糟糕的设计构建软件时，代码可能会变得不灵活和更脆弱。软件中的小改动会导致错误。基于这些原因，我们应该遵循坚实的原则。

这需要一些时间来理解，但是如果你遵循这些原则来编写代码，它将提高代码质量，并帮助你理解设计最好的软件。

为了理解坚实的原理，你必须清楚地知道接口的使用。如果你对界面的概念不清楚，那么你可以阅读这个[文档](https://medium.com/@NahidulHasan/understanding-use-of-interface-and-abstract-class-9a82f5f15837)。

我将试图用最简单的方式解释坚实的原理，以便初学者容易理解。让我们一个接一个地检查每个原则:

# 单一责任原则:

> 一个类应该有且只有一个改变的理由。

一个类应该只服务于一个目的。这并不意味着每个类应该只有一个方法，但是它们都应该与类的职责直接相关。所有的方法和属性都应该朝着同一个目标努力。当一个类服务于多种目的或职责时，它应该成为一个新的类。

请看下面的代码:

上述类违反了单一责任原则。这个类为什么要从数据库中检索数据？它与持久层有关。持久层处理持久化(存储和检索)来自数据存储(例如数据库)的数据。所以不是这门课的责任。

方法格式也不是这个类的责任，因为我们可能需要不同的数据格式，比如 XML、JSON、HTML 等等。

最后，重构后的代码将描述如下:

# 开闭原则:

> 实体应该对扩展开放，但对修改关闭。

软件实体(类、模块、函数等。)应该是可扩展的，而不需要实际改变正在扩展的类的内容。如果我们能够足够严格地遵循这个原则，那么就有可能在不接触原始代码的情况下修改我们代码的行为。

请看下面的代码:

如果我们想计算一个正方形的面积，我们必须修改 CostManager 类中的 calculate 方法。它打破了开闭原则。根据这个原理，我们不能修改，但可以扩展。

那么我们该如何解决这个问题呢？请参见以下代码:

现在我们可以在不修改 CostManager 类的情况下找到一个正方形的面积。

# 利斯科夫替代原理:

1987 年，Barbara Liskov 在她的会议主题“数据抽象”中介绍了 Liskov 替代原则。芭芭拉·利斯科夫和[珍妮特·温](https://en.wikipedia.org/wiki/Jeannette_Wing)在 1994 年的一篇论文中简洁地阐述了这一原理，如下所示:

> 设φ(x)是关于 t 类型的对象 x 的一个可证明的性质，那么φ(y)对于 S 类型的对象 y 应该是真的，其中 S 是 t 的子类型。

[的人类可读版本](https://en.wikipedia.org/wiki/Liskov_substitution_principle#Principle)几乎重复了 Bertrand Meyer 已经说过的所有内容，但是它完全依赖于一个类型系统:

> 1.不能在子类型中加强前提条件。
> 2。子类型中的后置条件不能被削弱。
> 3。超类型的不变量必须保留在子类型中。

罗伯特·马丁在 1996 年使这个定义更流畅、更简洁:

> 使用基类引用的指针的函数必须能够在不知道的情况下使用派生类的对象。

或者简单地说:子类/派生类应该可以替换它们的基类/父类。

它指出，抽象(接口)的任何实现在接受抽象的任何地方都应该是可替换的。基本上，在我们的代码中使用接口编码时，我们不仅有接口接收的输入契约，还有实现该接口的不同类返回的输出；他们应该是同一类型的。

这段代码显示了什么违反了 LSP，以及我们如何修复它:

# 界面分离原则:

> 不应该强迫客户端实现它不使用的接口。

这条规则意味着我们应该把我们的界面分成许多更小的界面，这样它们才能更好地满足客户的确切需求。

与单一责任原则相似，接口分离原则的目标是通过将软件划分为多个独立的部分来最小化副作用和重复。

让我们看一个例子:

在上面的代码中，RobotWorker 不需要 sleep，但是类必须实现 sleep 方法，因为我们知道所有的方法在接口中都是抽象的。它打破了界面分离定律。请查看以下代码，了解我们如何修复它:

# 依赖性倒置原则:

> 高层模块不应该依赖低层模块。两者都应该依赖于抽象。
> 
> 抽象不应该依赖于细节。细节应该依赖于抽象。

或者简单地说:依赖抽象，而不是具体。

通过应用依赖倒置原则，模块可以很容易地被其他模块改变，只要改变依赖模块。对低级模块的任何更改都不会影响高级模块。

请看下面的代码:

有一个常见的误解，即依赖倒置只是依赖注入的另一种说法。然而，这两者并不相同。

在上面的代码中，尽管在`PasswordReminder`类中注入了`MySQLConnection`类，但它依赖于`MySQLConnection`。高级模块`PasswordReminder`不应该依赖低级模块`MySQLConnection`。

如果我们想将连接从`MySQLConnection`更改为`MongoDBConnection`，我们必须更改`PasswordReminder`类中硬编码的构造函数注入。

类应该依赖于抽象，而不是具体化。但是怎么才能做到呢？请看下面的例子:

在上面的代码中，我们希望将连接从`MySQLConnection`更改为`MongoDBConnection`。我们不需要改变`PasswordReminder`类中的构造函数注入。因为这里的`PasswordReminder`类依赖于抽象，而不是具体化。

*如果你想练习并得到关于坚实的例子的代码，请查看我的*[*GitHub*](https://github.com/nahidulhasan/solid-principles)*(星星总是受赞赏的)资源库。*

感谢阅读。

特别感谢[艾哈迈德·沙米姆·哈桑](https://medium.com/u/42d2a133e29f?source=post_page-----f57d86c47a7f--------------------------------)和[拉夫桑·哈辛·汗](https://medium.com/u/2194060a4e1f?source=post_page-----f57d86c47a7f--------------------------------)