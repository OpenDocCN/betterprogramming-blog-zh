<html>
<head>
<title>Fancy SwiftUI: Making an Interactive Overlay Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">花式SwiftUI:制作一个交互式覆盖控件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fancy-swiftui-making-an-interactive-overlay-control-202e691c04bf?source=collection_archive---------2-----------------------#2019-09-06">https://betterprogramming.pub/fancy-swiftui-making-an-interactive-overlay-control-202e691c04bf?source=collection_archive---------2-----------------------#2019-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4fba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当你的应用程序感觉不错的时候</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f579d015e8741f65629ac26d06f3ea88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kFJkibe1dkMER9fh8T-vQ.jpeg"/></div></div></figure><p id="7ef1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们可能并不总是合适的。它们可能不符合某些设计标准。见鬼，有时候他们可能看起来超过了<strong class="kw iu"> </strong>顶端(最近第一次当爸爸)。</p><p id="c646" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，这并不能改变我是UI上的菜单和控件的超级粉丝的事实，比如桌面上传统的右键/控制键点击下拉菜单。也许这也是因为我太习惯于在视频游戏中动态显示菜单和覆盖图了。它们是确认用户在UI中的焦点和释放该区域可用信息和特性的简单方式。而且几乎最好的是，它只在用户想要/需要的时候出现。</p><p id="31b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天，我们将看看SwiftUI中的叠加。具体来说，我并没有把覆盖图看作是改变视图设计的一种方式，而是提出了一种与其父控件进行通信的交互控件。</p><p id="b9cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过SwiftUI中新的声明式UI方法，交互式覆盖控件获得了一些新的好处。首先，将一个覆盖视图连接到一个父视图需要很少的代码。说到代码，覆盖层也在UI构建的桌子上获得了一席之地——不再有单独的故事板/xib，也不再像某种见不得人的后门交易那样在幕后将它们连接起来。最后，由于Combine，我们可以在覆盖图和父图之间建立更强的关系。Combine:从2019年开始将UI家族聚集在一起。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a603" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">构建我们的用户界面</h1><p id="65ff" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">打开Xcode 11，启动一个启用SwiftUI的新项目。打开预先制作的ContentView.swift文件，离开Hello World文本视图。那是我们的父母。</p><p id="acb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了构建我们的基本UI，我们要做的就是在文本视图周围构建一个框架，设置一种颜色，我们的目标是制作一个可以改变颜色的覆盖控件。在这个过程中，我们还会给它添加一些特色。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="516d" class="mz ly it mv b gy na nb l nc nd">Text(“Hello World”)</span><span id="a92d" class="mz ly it mv b gy ne nb l nc nd">    .frame(width: 100, height: 100)</span><span id="9e26" class="mz ly it mv b gy ne nb l nc nd">    .background(Color.blue)</span></pre><h2 id="b59b" class="mz ly it bd lz nf ng dn md nh ni dp mh ld nj nk mj lh nl nm ml ll nn no mn np bi translated">去Z还是不去Z？</h2><p id="a5d5" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在，在我们设置覆盖之前，我想指出ZStack。是的，ZStack允许你将视图堆叠在彼此之上，我们可以假装它是一个覆盖图。这很酷，但是在代码中，它没有明确地让一个视图的父视图位于另一个视图之上。覆盖图确实明确地将分层视图声明为另一个视图的子视图，这在某些属性中有所体现(例如，覆盖图的偏移属性将基于父视图的属性)。ZStack可以人为地建立这种关系，但可以说它仍然被视为兄弟姐妹。</p><p id="5493" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们希望我们的控件特别关注它想要与之交互的父控件，所以我们将使用一个覆盖。</p><h2 id="ff3a" class="mz ly it bd lz nf ng dn md nh ni dp mh ld nj nk mj lh nl nm ml ll nn no mn np bi translated">那就叠加吧！</h2><p id="c241" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">让我们在文本视图上声明我们的覆盖。我们现在画一个圆圈，这样我们可以在预览中看到它。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="43e3" class="mz ly it mv b gy na nb l nc nd">.overlay(Circle())</span></pre><p id="68eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止…看起来很丑，但我们正在大步前进！让我们再多设置一点UI，改变我们的圆形，设置它为一个线条宽度足够大的笔画，以及设置足够大的框架，让我们的圆形包围我们的文本框架。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2db7" class="mz ly it mv b gy na nb l nc nd">Circle()</span><span id="0c87" class="mz ly it mv b gy ne nb l nc nd">    .stroke(Color.red, lineWidth: 30)</span><span id="c07c" class="mz ly it mv b gy ne nb l nc nd">    .frame(width: 300, height: 300)</span></pre><p id="be8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了这个设置，让我们让我们的戒指互动。我们的目标是将文本视图更改为戒指的颜色。</p><p id="06e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了做到这一点，我们将设置一个颜色状态，文本的背景将被设置，这将由我们的圆圈上的点击手势设置。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7f76" class="mz ly it mv b gy na nb l nc nd">//Add this to our ContentView<br/><a class="ae nq" href="http://twitter.com/State" rel="noopener ugc nofollow" target="_blank">@State</a> var textColor = Color.blue</span><span id="e61e" class="mz ly it mv b gy ne nb l nc nd">//Change this for our Text View<br/>.background(textColor)</span><span id="959c" class="mz ly it mv b gy ne nb l nc nd">//Add this to our Circle<br/>.onTapGesture { self.textColor = Color.red }</span></pre><p id="d4e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们使覆盖只有在我们召唤它时才可见。在这种情况下，我们将在文本视图上使用另一个点击手势。这将触发另一个状态，作为显示或隐藏覆盖的条件。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2d5a" class="mz ly it mv b gy na nb l nc nd">//Add this to our ContentView<br/><a class="ae nq" href="http://twitter.com/State" rel="noopener ugc nofollow" target="_blank">@State</a> var showOverlay = false</span><span id="1df4" class="mz ly it mv b gy ne nb l nc nd">//Add this to our Text View<br/>.onTapGesture { self.showOverlay.toggle() }</span><span id="4d8b" class="mz ly it mv b gy ne nb l nc nd">//Cmd+Click Circle, select “Make Conditional”,<br/>//and set self.showOverlay as our condition<br/>VStack {<br/>    if self.showOverlay {<br/>        Circle()<br/>            .stroke(Color.red, lineWidth: 30)<br/>            .frame(width: 300, height: 300)<br/>            .onTapGesture { self.textColor = Color.red }<br/>    } else {<br/>        EmptyView()<br/>    }<br/>}</span></pre><p id="6935" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们通过Cmd+Click使circle有条件时，Xcode会自动将其包装在VStack中，并设置一个if/else，其中else是一个EmptyView()。这似乎是苹果显示或隐藏视图的首选方式。它看起来很笨拙，我非常想把它变成一个三元语句，但是现在我们把新的状态设置为条件，让它保持原样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2405895d12ab598048f4e343735ac59c.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*IzMO4u19uPILDjsMdeJlow.gif"/></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">基本的，但是很管用！</p></figure><p id="2124" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧啊。我们已经达到了我们的目标。以下是我们的成果:</p><ul class=""><li id="a919" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated">我们创建了一个覆盖。</li><li id="809e" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">我们的覆盖图只在用户召唤时出现。</li><li id="7cdf" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">与我们的覆盖图交互会触发父视图的变化。</li></ul><p id="8a1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我们创建的代码要点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">我们的覆盖控制代码</p></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="361c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">让它变得新奇</h1><p id="e0b1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我明白了:这不是有史以来最令人兴奋的UI/UX。幸运的是，这不是乐趣需要结束的地方。通过使用我们在这里创建的东西，我们可以修改我们的UI来创建一些更有趣、更吸引人的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f36fd1649747da9e527833da94668847.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*vSwTkbePwE89xQ4rPhr7Yw.gif"/></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">我们叠加控件的增强版本</p></figure><p id="21f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建增强版最终只增加了19行代码(参见下面的要点)。所需要做的是将我们的圆放到一个新的自定义视图中，使用trim创建一个弧形效果，并使用ZStack通过ForEach循环将多个弧形显示为一个完整的圆。然后，到处添加一些UI和动画。立即我们的覆盖看起来更有吸引力，有趣，酷！</p><p id="25ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">*免责声明:我不是一个真正的UI/UX类型的人，所以对我来说这是幻想<em class="om">。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">增强覆盖控制的代码</p></figure><h2 id="68e1" class="mz ly it bd lz nf ng dn md nh ni dp mh ld nj nk mj lh nl nm ml ll nn no mn np bi translated">美国的观点</h2><p id="7747" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">为了不跑题，我想谈谈我是如何处理我们的状态的。基本版和增强版之间的一个很大的区别是叠加图被提取为一个单独的视图。我还将我们的状态作为绑定参数传入新视图。</p><p id="c09f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过我在SwiftUI上阅读的一些示例项目和文章，我看到了视图层次结构之间的状态和数据流以许多不同的方式处理，尽管许多人声称它们是“确定的方式”。我没有这样的说法。</p><p id="c8b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我选择这条路的原因有两个:</p><ul class=""><li id="78c2" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated">使用覆盖图的父视图不应该被它的子视图属性弄得乱七八糟(看我在那里做了什么？)除非是针对家长需求的独特。如果我的层次结构能够整齐地自成一体，那么它就没有必要变得杂乱无章。(看看两者之间的覆盖声明有多么不同，我想你会同意在增强版中它更加清晰)</li><li id="0d35" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">对我来说，可重用性和保持上下文是创建函数和(现在)视图的关键。如果它与我的子视图有关，并且可以生活在我的子视图中，为什么我要把它的内脏分散到别处？同样，它弄乱了父视图，使得在其他地方使用子视图需要引用我在原始父视图中所做的，并在预期的父视图中复制它。</li></ul><h2 id="2b89" class="mz ly it bd lz nf ng dn md nh ni dp mh ld nj nk mj lh nl nm ml ll nn no mn np bi translated">错误的笔记</h2><p id="3bdd" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">写这篇文章的时候肯定有一些bug还生活在SwiftUI里(我用的是Xcode 11 Beta 7)。例如，在circle的trim属性的三元组中，我的代码不会编译，除非我将item强制转换为double，并且不允许我在该强制转换中执行任何操作。所以当你看到那条线上可怕的过度杀戮时，请保留你的判断。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="0bec" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">你在控制中</h1><p id="97f3" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">有许多其他方法可以编辑这个覆盖图或创建另一种覆盖图。我们可以使用不同的手势作为触发器，比如长按。或者在堆栈上使用弹簧动画代替线性动画。</p><p id="fdc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总而言之，这取决于你的应用程序UI/UX会找到什么最适合。</p><p id="030b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可能要记住的最重要的事情之一是以某种方式让用户知道你的覆盖控件的存在(可能是在你的视图上使用Z层的一次性教程遮罩，或者在你的应用程序的开始漫游中，如果它有一个的话)。只要用户不要错过检查新奇的覆盖控件，这可以让他们了解更多你的应用程序的精彩功能和体验！</p></div></div>    
</body>
</html>