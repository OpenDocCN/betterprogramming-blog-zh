<html>
<head>
<title>How to Change React Animations Behavior When Props Change</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当道具改变时如何改变反应动画的行为</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-animations-that-change-behavior-when-props-change-da026cec7548?source=collection_archive---------2-----------------------#2022-02-12">https://betterprogramming.pub/react-animations-that-change-behavior-when-props-change-da026cec7548?source=collection_archive---------2-----------------------#2022-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a48" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">中途更改动画</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/570f4784f077e32f9c079e55a7f6c33e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uM7JzsbBBptu4izOcd3zyw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画！反应过来！激动人心！</p></figure><p id="13c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想在React中制作动画，有很多方法可以实现。CSS动画特别优雅，但它似乎更适合于在动画开始后不需要控制动画行为的情况。</p><p id="59ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将描述如何中途改变动画的行为以响应组件属性值的改变。此外，我们将在避免直接引用DOM元素的同时做到这一点，因为这可能会干扰React的渲染。</p><p id="8d2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里给出的方法可以很容易地重复用于您想要实现的任何类型的基于数据的动画。</p><h1 id="5dd5" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">呈现进度条</h1><p id="421c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">对于我们的例子，假设我们需要一个React组件来呈现一个简单的进度条。它将需要props操作开始的时间(<code class="fe mr ms mt mu b">startTime</code>)和操作预计需要多长时间(<code class="fe mr ms mt mu b">expectedDuration</code>)。</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="9291" class="mz lv it mu b gy na nb l nc nd">const outerStyle = { <br/>  width:'100%', <br/>  height:'10rem', <br/>  backgroundColor:'blue' <br/>};</span><span id="9e00" class="mz lv it mu b gy ne nb l nc nd">const innerStyle = { <br/>  height: '100%', <br/>  backgroundColor:'black' <br/>};</span><span id="93d1" class="mz lv it mu b gy ne nb l nc nd">function ProgressBarComponent({startTime, expectedDuration}) {<br/>  const elapsed = Date.now() - startTime;<br/>  const completedRatio = elapsed &gt; expectedDuration<br/>    ? '100%' : `${elapsed / expectedDuration * 100}%`;</span><span id="ad6e" class="mz lv it mu b gy ne nb l nc nd">  return (<br/>    &lt;div style={outerStyle}&gt;<br/>      &lt;div style={{...innerStyle, width:completedRatio}} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="0149" class="mz lv it mu b gy ne nb l nc nd">export default ProgressBarComponent;</span></pre><p id="d81e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">渲染时，进度条如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/949c830e303aa754743101ed6ba94cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*um8asMqf3pquYGtUY6U5ig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我不是想用美学设计来打动你。</p></figure><h1 id="fbb9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">制作进度条动画</h1><p id="2712" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">制作进度条动画的任务仍然存在。我们可以使用JavaScript的<code class="fe mr ms mt mu b">setTimeout()</code>来更新用于渲染的状态。让我预先警告你，我将拒绝下面的解决方案。</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="54bd" class="mz lv it mu b gy na nb l nc nd"><strong class="mu iu">import { useState } from 'react';</strong></span><span id="b079" class="mz lv it mu b gy ne nb l nc nd">...</span><span id="dd55" class="mz lv it mu b gy ne nb l nc nd"><strong class="mu iu">const FRAME_INTERVAL = 1000 / 30; // 30 FPS</strong></span><span id="6aae" class="mz lv it mu b gy ne nb l nc nd">function ProgressBarComponent({startTime, expectedDuration}) {<br/>  <strong class="mu iu">const [completedRatio, setCompletedRatio] = useState(null);</strong></span><span id="0063" class="mz lv it mu b gy ne nb l nc nd"><strong class="mu iu">  const updateCompletion = () =&gt; {<br/>    const elapsed = Date.now() - startTime;<br/>    if (elapsed &gt;= expectedDuration) {<br/>      setCompletedRatio('100%');<br/>      return;<br/>    }<br/>    setCompletedRatio(`${elapsed / expectedDuration * 100}%`);<br/>    setTimeout(updateCompletion, FRAME_INTERVAL);<br/>  }</strong></span><span id="5548" class="mz lv it mu b gy ne nb l nc nd"><strong class="mu iu">  if (completedRatio === null) updateCompletion();</strong><br/>  return (<br/>    &lt;div style={outerStyle}&gt;<br/>      &lt;div style={{...innerStyle, width:completedRatio}} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="00d6" class="mz lv it mu b gy ne nb l nc nd">...</span></pre><p id="0239" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码将使进度条从左向右移动。但是它有一个问题。在这个例子中，我们希望进度条根据对操作所需时间的估计来改变进度。</p><p id="f407" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果父组件改变了传递给<code class="fe mr ms mt mu b">ProgressBarComponent</code>的<code class="fe mr ms mt mu b">expectedDuration</code>属性，那么在<code class="fe mr ms mt mu b">updateCompletion()</code>内部执行的用于<code class="fe mr ms mt mu b">setTimeout()</code>回调的代码将仍然获得<code class="fe mr ms mt mu b">expectedDuration</code>的先前值，忽略这一改变。</p><p id="3931" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果在动画完成之前<code class="fe mr ms mt mu b">expectedDuration</code>改变了，你会看到一些混乱的，破碎的渲染。两个独立的<code class="fe mr ms mt mu b">setTimeout()</code>回调链将使用它们不同的<code class="fe mr ms mt mu b">expectedDuration</code>值来呈现进度条的位置。</p><h1 id="1b6f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">最小化SetTimeout回调中的状态更改</h1><p id="38cf" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了解决这个问题，我们可以将状态更新逻辑从<code class="fe mr ms mt mu b">setTimeout() </code>回调移到组件的呈现函数中。我们将使用<code class="fe mr ms mt mu b">setTimeout()</code>来触发重新渲染。这种方法如下所示。</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="2bda" class="mz lv it mu b gy na nb l nc nd">...</span><span id="83d9" class="mz lv it mu b gy ne nb l nc nd">function ProgressBarComponent({startTime, expectedDuration}) {<br/>  const [frameNo, setFrameNo] = useState(0);</span><span id="e1ba" class="mz lv it mu b gy ne nb l nc nd">  <strong class="mu iu">setTimeout(() =&gt; setFrameNo(frameNo + 1), FRAME_INTERVAL);</strong></span><span id="9302" class="mz lv it mu b gy ne nb l nc nd">  <strong class="mu iu">const elapsed = Date.now() - startTime;<br/>  const completedRatio = elapsed &gt; expectedDuration <br/>    ? '100%' : `${elapsed / expectedDuration * 100}%`;</strong></span><span id="0e67" class="mz lv it mu b gy ne nb l nc nd">  return (<br/>    &lt;div style={outerStyle}&gt;<br/>      &lt;div style={{...innerStyle, width:completedRatio}} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="c4a9" class="mz lv it mu b gy ne nb l nc nd">...</span></pre><p id="5482" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码变得更简单了。一件好事是，我们不必担心在回调中更新除了<code class="fe mr ms mt mu b">frameNo</code>之外的任何状态。<code class="fe mr ms mt mu b">frameNo</code>除了触发新的渲染之外，不用于其他任何事情。</p><h1 id="7e23" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">使用UseEffect避免额外渲染</h1><p id="8e6c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">使用上面的代码，每当父组件更改传递给组件的prop值时，都会触发一个新的setTimeout()回调链。这可能导致对render函数的过度调用，从而降低web应用程序的性能。</p><p id="2adb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以添加一个效果挂钩来确保我们只有一个<code class="fe mr ms mt mu b">setTimeout()</code>回调链。</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="1866" class="mz lv it mu b gy na nb l nc nd">import { useState, useEffect } from 'react';</span><span id="263c" class="mz lv it mu b gy ne nb l nc nd">...</span><span id="c627" class="mz lv it mu b gy ne nb l nc nd">function ProgressBarComponent({startTime, expectedDuration}) {<br/>  const [frameNo, setFrameNo] = useState(0);</span><span id="eb66" class="mz lv it mu b gy ne nb l nc nd">  <strong class="mu iu">useEffect(() =&gt; {<br/>    const timer = setTimeout(<br/>      () =&gt; setFrameNo(frameNo + 1), FRAME_INTERVAL);<br/>    return () =&gt; clearTimeout(timer);<br/>  }, [frameNo]);</strong></span><span id="8867" class="mz lv it mu b gy ne nb l nc nd">  const elapsed = Date.now() - startTime;<br/>  const completedRatio = elapsed &gt; expectedDuration <br/>    ? '100%' : `${elapsed / expectedDuration * 100}%`;</span><span id="0084" class="mz lv it mu b gy ne nb l nc nd">  return (<br/>    &lt;div style={outerStyle}&gt;<br/>      &lt;div style={{...innerStyle, width:completedRatio}} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="05f9" class="mz lv it mu b gy ne nb l nc nd">...</span></pre><p id="5949" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我来解释一下上面的<code class="fe mr ms mt mu b">useEffect</code>是做什么的。它将执行这一行…</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="4344" class="mz lv it mu b gy na nb l nc nd">setTimeout(() =&gt; setFrameNo(frameNo + 1), FRAME_INTERVAL);</span></pre><p id="d670" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">…第一次安装组件时。这将导致对<code class="fe mr ms mt mu b">setFrameNo()</code>的调用在未来一段时间内发生，这将更新<code class="fe mr ms mt mu b">frameNo</code>属性。这又会导致“setTimeout”行再次执行。</p><p id="d461" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，当组件卸载时，它返回一个调用clearTimeout()的函数。这可以防止超时回调在frameNo和setFrameNo不再存在后引用它们。</p><p id="fb68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个改进，因为我们已经将<code class="fe mr ms mt mu b">setTimeout</code>行的触发器数量限制为我们需要的两个——组件挂载和<code class="fe mr ms mt mu b">frameNo</code> prop的更新。</p><h1 id="a461" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">动画完成后停止重新渲染</h1><p id="83f4" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">所以现在代码不那么占用CPU了。但是没有动画表演的时候呢？如果进度条达到100%，我们可以停止更新动画。</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="b756" class="mz lv it mu b gy na nb l nc nd">...</span><span id="3bbf" class="mz lv it mu b gy ne nb l nc nd">function ProgressBarComponent({startTime, expectedDuration}) {<br/>  const [frameNo, setFrameNo] = useState(0);<br/><strong class="mu iu">  const [isAnimating, setIsAnimating] = useState(true);</strong></span><span id="41aa" class="mz lv it mu b gy ne nb l nc nd">  useEffect(() =&gt; {<br/>    <strong class="mu iu">if (isAnimating) {<br/>      const timer = setTimeout(<br/>        () =&gt; setFrameNo(frameNo + 1), FRAME_INTERVAL);<br/>      return () =&gt; clearTimeout(timer);<br/>    }<br/>  }, [frameNo, isAnimating]);</strong></span><span id="eaf6" class="mz lv it mu b gy ne nb l nc nd">  const elapsed = Date.now() - startTime;<br/>  const completedRatio = elapsed &gt; expectedDuration <br/>    ? '100%' : `${elapsed / expectedDuration * 100}%`;<br/>  <strong class="mu iu">if (completedRatio === '100%' &amp;&amp; isAnimating) <br/>    setIsAnimating(false);</strong></span><span id="8fac" class="mz lv it mu b gy ne nb l nc nd">  return (<br/>    &lt;div style={outerStyle}&gt;<br/>      &lt;div style={{...innerStyle, width:completedRatio}} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="b504" class="mz lv it mu b gy ne nb l nc nd">...</span></pre><h1 id="5ad8" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">这不是你要找的进度条</h1><p id="0a20" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这个进度条并不漂亮。当你前面的等待增加时，它会做出不友好的事情，比如倒退。(老实，但是有点苛刻！)在文章中使用它的目的只是为了给出一个简单而具体的受改变道具影响的动画示例。</p><p id="8c94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你没有道具控制动画的特殊需求，我推荐你使用其他更有效的方法，比如CSS或者画布动画。</p><p id="ef12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是该组件的完整源代码。我在此将它公之于众。</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="3121" class="mz lv it mu b gy na nb l nc nd">import { useState, useEffect } from 'react';</span><span id="83f6" class="mz lv it mu b gy ne nb l nc nd">const outerStyle = { <br/>  width:'100%', <br/>  height:'10rem', <br/>  backgroundColor:'blue' <br/>};</span><span id="7373" class="mz lv it mu b gy ne nb l nc nd">const innerStyle = { <br/>  height: '100%', <br/>  backgroundColor:'black' <br/>};</span><span id="3a74" class="mz lv it mu b gy ne nb l nc nd">const FRAME_INTERVAL = 1000 / 30; // 30 FPS</span><span id="8edc" class="mz lv it mu b gy ne nb l nc nd">function ProgressBarComponent({startTime, expectedDuration}) {<br/>  const [frameNo, setFrameNo] = useState(0);<br/>  const [isAnimating, setIsAnimating] = useState(true);</span><span id="16a8" class="mz lv it mu b gy ne nb l nc nd">  useEffect(() =&gt; {<br/>    if (isAnimating) {<br/>      const timer = setTimeout(<br/>        () =&gt; setFrameNo(frameNo + 1), FRAME_INTERVAL);<br/>      return () =&gt; clearTimeout(timer);<br/>    }<br/>  }, [frameNo, isAnimating]);</span><span id="d08e" class="mz lv it mu b gy ne nb l nc nd">  const elapsed = Date.now() - startTime;<br/>  const completedRatio = elapsed &gt; expectedDuration <br/>    ? '100%' : `${elapsed / expectedDuration * 100}%`;</span><span id="9af2" class="mz lv it mu b gy ne nb l nc nd">  if (completedRatio === '100%' &amp;&amp; isAnimating) <br/>    setIsAnimating(false);</span><span id="65a0" class="mz lv it mu b gy ne nb l nc nd">  return (<br/>    &lt;div style={outerStyle}&gt;<br/>    &lt;div style={{...innerStyle, width:completedRatio}} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="3fda" class="mz lv it mu b gy ne nb l nc nd">export default ProgressBarComponent;</span></pre><p id="7b88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章或者觉得它有用，那么…哦，我真的不在乎你做什么。祝你生活愉快，我的朋友！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/28b1a708eb16b660cc60a42aeefcdb3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84PV1EnS626HIR3snbWK4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">* * * <a class="ae nh" href="https://medium.com/@ErikH2000/where-my-media-comes-from-59761dc4be7" rel="noopener">媒体学分</a> * * * <a class="ae nh" href="https://medium.com/@ErikH2000/yes-i-can-help-you-get-an-it-job-b0b51fee4c95" rel="noopener">想要一份工作？</a> * * * <a class="ae nh" href="https://www.linkedin.com/in/erikhermansen" rel="noopener ugc nofollow" target="_blank"> LinkedIn个人资料</a> * * *</p></figure></div></div>    
</body>
</html>