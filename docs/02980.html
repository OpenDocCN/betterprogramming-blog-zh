<html>
<head>
<title>A Case For Conventional Commits in Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git中常规提交的一个例子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-case-for-conventional-commits-in-git-d70c65245009?source=collection_archive---------9-----------------------#2020-01-13">https://betterprogramming.pub/a-case-for-conventional-commits-in-git-d70c65245009?source=collection_archive---------9-----------------------#2020-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6cea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">添加结构并提高提交的可读性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5a3449197b3d3d4608b7126d53fed4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6XeL5ZKVBpwwZlqHp-Isw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@yancymin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae kv" href="https://unsplash.com/s/photos/git?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="225d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大约一年前，我开始在我的个人项目和工作中使用常规提交，到目前为止我并不后悔。这让我更清楚地传达了什么是变化。因此，我的提交历史更加易于管理。</p><p id="403e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">传统提交</em>是一种用于格式化提交消息的规范，它是轻量级的，人和机器都可读。即使不使用可以解析它们的工具，它对开发人员来说仍然很有用。</p><p id="5f77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个提交消息都有一个类型，将变更分为特性、修复、测试等。它还有一个可选的范围，即项目的哪个部分受到变更的影响，以及对已经完成的工作的简短说明。接下来是正文，包括更多的细节和事件发生的背景。最后，页脚将包含来自问题跟踪器的票据编号等信息以及类似的元数据。</p><p id="42d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">了解它的样子最简单的方法就是看一些例子。下面是满足规则的最小提交消息。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="b20c" class="ly lz iq lu b gy ma mb l mc md">feat: add an endpoint to get contents recommendation</span><span id="8237" class="ly lz iq lu b gy me mb l mc md">GET /contents/:topics/recommendation returns a JSON with some<br/>recommendations for the user.</span></pre><p id="aa70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一条更长的提交消息，包含更多详细信息。它有一个作用域(<code class="fe mf mg mh lu b">api</code>)和一个带有元数据的页脚。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="88ed" class="ly lz iq lu b gy ma mb l mc md">test(api): assess test suite quality with mutation analysis</span><span id="ac4e" class="ly lz iq lu b gy me mb l mc md">Add a new executable `mutation-analysis` that analyses the API's<br/>test suite and returns a score that we can use to keep track of<br/>how good our tests are at catching defects. This is a better<br/>approach than code coverage.</span><span id="27a2" class="ly lz iq lu b gy me mb l mc md">It works by running the tests against mutants of the API<br/>(slightly different versions of the code, e.g. a &lt; could be<br/>replaced with a &lt;=) and counting the proportion of mutants that<br/>the tests catch. This is relying on the assumption that most<br/>mutants are invalid and should make the tests fail.</span><span id="ac04" class="ly lz iq lu b gy me mb l mc md">Issue: ABC-456<br/>Approved-By: Tom Feron</span></pre><p id="f5b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以通过阅读<a class="ae kv" href="https://www.conventionalcommits.org/en/v1.0.0/" rel="noopener ugc nofollow" target="_blank">规范</a>来了解更多关于如何格式化它们的信息。我接下来的目标是与他们分享我的经历，以及他们如何为我提供价值。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="17ba" class="mp lz iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">轻量级选手</h1><p id="691d" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">如你所见，它们非常简单，几乎不需要任何承诺。不需要设置任何东西，也不依赖任何工具。如果你改变主意，你可以简单地停止使用它们。</p><p id="d336" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，从常规提交开始的成本几乎为零。</p><p id="5a41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你写提交信息可能要多花一点时间，但是你的队友——或者你未来的自己——会为此感谢你的。</p><p id="9183" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一的要求是决定一些提交类型(或者<a class="ae kv" href="https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional" rel="noopener ugc nofollow" target="_blank">偷一些</a>)和作用域，如果你决定使用它们的话。不过，开始时，一些即兴表演是非常好的。用自己觉得合理的就行，以后再调整。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="5ab5" class="mp lz iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">更容易通过</h1><p id="53ef" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">软件开发的一个重要部分是与其他人交流，而不是与计算机交流。这包括评论你的代码，<a class="ae kv" href="https://medium.com/swlh/your-job-as-a-developer-handling-complexity-66e0c7063a35" rel="noopener">保持事情简单</a>(甚至有时以牺牲性能为代价)，以及制作好的提交消息。</p><p id="be01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">清晰的交流意味着快速准确地传达意思。考虑到这个目标，标准格式可以帮助其他人快速解析提交消息，以了解更改的内容，并突出显示关键信息。</p><p id="1c04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用常规提交一段时间后，我注意到它如何促使我给出更多的解释和上下文。我以前会写提交消息，比如“修复测试”——拜托，谁没有呢？—我现在将编写如下提交消息:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="619a" class="ly lz iq lu b gy ma mb l mc md">test(api): fix comment's JSON in endpoint test</span><span id="d6aa" class="ly lz iq lu b gy me mb l mc md">The key `actorId` was deprecated a few months ago and removed<br/>recently but the test suite hadn't been updated.</span></pre><p id="09a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我在这里使用<code class="fe mf mg mh lu b">test</code>进行测试修复，除非它暗示了应用程序代码中的一个错误。<code class="fe mf mg mh lu b">fix</code>应该保留给bug修复。事实上，它使得调试回归和发布跟踪更加容易。说到这个...</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="4a54" class="mp lz iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">1次提交= 1次更改</h1><p id="4252" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我在使用传统提交时注意到的另一件事是它如何迫使我一次提交一个变更。当你不得不用<code class="fe mf mg mh lu b">feat(task-runner): something</code>开始提交时，在同时提交一些不相关的重构之前，你要三思。</p><p id="d1d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，将一些不相关的函数重命名(或某段代码的重新格式化)与您正在开发的新功能放在同一个提交中，并在提交消息的正文中提及，这是可以接受的。</p><p id="eab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这有时是真的，但是在太多的提交和随之而来的噪音之间要找到一个恰当的平衡。您不一定希望将更改隐藏到其他提交中，从而混淆提交历史。</p><p id="5ff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不需要传统的提交来清楚地将变更分割成单独的提交，但是，从我的经验来看，这样做有助于获得必要的规则。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="7a1f" class="mp lz iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">发布跟踪</h1><p id="2781" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在敏捷开发的时代，很难跟踪发生了什么变化以及什么时候发生的。在生产中调试问题时，这尤其成问题。常规提交以一种对人和机器都可以解析的方式告诉您每次提交的更改类型及其范围。</p><p id="5338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">跟踪发布有用的另一种情况是用于流量分析。知道你的网站转化率的峰值发生在<code class="fe mf mg mh lu b">3d0e862dacf9655236bd73c31676170037e87483</code>，甚至<code class="fe mf mg mh lu b">fix spacing</code>部署之后，并没有什么帮助。</p><p id="9b56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用常规提交，您可以根据类型和范围过滤掉不相关的提交，并且只显示容易成为您所观察到的根本原因的变更。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="a9fd" class="mp lz iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">变更日志</h1><p id="1ce1" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在准备sprint回顾的时候，你有没有被问到(或者你自己问你的同事)“我们这周发了什么？”您的任务管理器或看板可能对显示实际合并的内容没有太大帮助。一些变化没有被这样的工具捕捉到，其他的只是吉拉问题的一部分，但是仍然传递价值，值得一提。</p><p id="f96b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，常规提交有助于自动生成准确反映实际情况的changelog。</p><p id="53af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一些工具可以使这个过程自动化。例如，<a class="ae kv" href="https://github.com/conventional-changelog/conventional-changelog" rel="noopener ugc nofollow" target="_blank">conditional-changelog</a>就是为这个目的而设计的一套工具。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="e7bc" class="mp lz iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="f0b4" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">考虑到开始使用常规提交是多么容易，而且几乎不存在成本，您会鼓励任何人至少尝试一下，亲自看看它是如何进行的。</p><p id="05f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一开始不需要自动化任何东西。传统提交只有在人们使用时才是有用的。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="2a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这样的故事，可以考虑成为<a class="ae kv" href="https://tomferon.medium.com/membership" rel="noopener">媒体</a>和/或<a class="ae kv" href="https://tomferon.medium.com/subscribe" rel="noopener">订阅</a>的会员。</p></div></div>    
</body>
</html>