<html>
<head>
<title>Big O Notation for Dummies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">假人的大O符号</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/big-o-notation-for-dummies-like-me-98ac2d141f9f?source=collection_archive---------1-----------------------#2019-07-11">https://betterprogramming.pub/big-o-notation-for-dummies-like-me-98ac2d141f9f?source=collection_archive---------1-----------------------#2019-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="801d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">别担心，不是每个人都知道(但我们不会说)</h2></div><p id="cf0e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我第一次听到<em class="le"> Big O Notation </em>这个术语的时候，我完全不知道它是什么意思，甚至猜不出它和代码有什么关系。甚至阅读维基百科文章的前几个句子也没有让我明白这个概念<strong class="kk iu"/>。没有计算机科学学位，这些行话似乎太专业、太复杂，难以理解。我也害怕这么多年后，我不得不再次思考数学。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/dc4dd63a7366653c7ecd37bd0ef698cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D2MCEs8jj4b4Y2Ag"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">约翰·莫塞斯·鲍恩在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="5e99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，这里涉及的数学大多是理论性的，这是我最喜欢的一种，因为我实际上不必“求解x”或其他什么。在编程世界中，理解算法显然非常重要，而且它们在面试中很常见，所以我想我会再试一次，从最基本的步骤开始:理解什么是<em class="le">大O </em>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="c1c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最基本的层面上，大O符号定义了算法运行需要多长时间，也称为<em class="le">时间复杂度</em>。它表示当数据变大时，给定算法的运行时间有多长。你可能想知道为什么除了炫耀之外，还有人关心计算算法的速度，但是随着程序规模的增长，这些微小的毫秒会越积越多！突然，一个过去根本不需要时间的算法开始让一切陷入困境，因此程序员需要知道“最坏的情况”是什么，或者更确切地说，在数据列表不断增长的情况下，一个算法运行的最慢速度是多少。</p><p id="2ceb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">中的<em class="le">基本代表<em class="le">阶</em>，与<em class="le">数量级</em>相同。<a class="ae lv" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">维基</a>补充道，<em class="le"/>函数的增长率也被称为函数的<strong class="kk iu">阶。</strong><strong class="kk iu"/>所以，对于我这样的初学者来说，把这里的字母<em class="le"> O </em>想成类似于<em class="le">增长率</em>可能会有帮助。人们将大O符号称为“大o of”或“order of”，然后是括号内的内容，通常是<em class="le"> n </em>。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="2fc7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大O记法的最佳时间复杂度是O(1)。这包括无论列表是长是短，运行时间都差不多的算法。下面的例子非常简单，但是你可以明白为什么它们不会花很长时间:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/90d37227d6e42fe4cecb1de3ce3f2b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*I65VBQNSI2m7QcHvJr90BA.png"/></div></figure><p id="dd71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也包括算法中不依赖于常数的数学运算，例如:“5 * 250 / 2”。这些方法不是真正的排序或搜索来比较数据，直到一个匹配条件；它们只是访问数组中的固定点或返回值，不管列表中有10个还是100个数字，运行时间都差不多。这被称为<em class="le">常数时间</em>，它是理想的，尽管很难让一个复杂的算法运行得那么快。</p><p id="1f63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">O(n)变得有点复杂，变量“n”是您正在处理的数据的大小。这通常表示一种算法，该算法必须对列表中的每一项进行排序，以找到它要寻找的项，或者该算法使用每一项，并以某种方式改变或组合它们。有人称这些<em class="le">蛮力</em>算法，因为它们无论如何都要遍历每一项。O(n)也叫<em class="le">线性时间。</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi me"><img src="../Images/539635b28fb3ab6b6985fe123f6d5588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKuU2EvomAk603anuFRiJg.png"/></div></div></figure><p id="d240" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为一组数据可能会增长到无法管理的大小，所以还有一个比O(n)更好的时间复杂度，称为O(log n)。这里的<em class="le"> log </em>代表对数，你可以认为它是指数的反义词。例如，我们知道2⁴是16，数字4是指数。所以2的4次方等于16。对数处理试图找到指数是什么，如果你已经有了值。对数回答了这样一个问题，“为了得到16，我们要把2乘以多少次？”O(log n)也叫<em class="le">对数时间</em>。</p><p id="d588" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">O(log n)的工作方式是在一个排序数组中使用二分搜索法。二分搜索法将列表分成两半，只搜索一半。如果你要找的数据在那一半里，它会再把它分成两半，然后重复搜索，直到没有剩余的部分。当您处理大型数据集时，这种搜索方式会变得更加高效，因为它每次搜索都会丢弃一半。</p><p id="aefc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将在这里介绍的最后一个时间复杂度是O(n)，也称为<em class="le">二次时间</em>。这个很糟糕，因为它开始还不错，然后很快就变得很慢。这种时间复杂度通常处理嵌套数据，其运行时间不好的原因是，不仅要对列表中的每一项进行排序，还要对列表中的每一项进行排序。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mf"><img src="../Images/aa03ef3c35fa7fbffb5a72dce1d2b386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0i1sA79G0m7oMrSvCoSig.png"/></div></div></figure><p id="1197" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，假设你有一个数组，里面有五个学生，每个学生实际上是另一个数组，包含关于这个学生的五个细节。这个算法总共要迭代25次，也就是5次。更深的嵌套将导致O(n)，O(n⁴)等。</p><p id="316b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(在大O表示法中，常数被忽略并替换为n，因为大小可以是任何值，但数量级更容易量化。)</p><p id="d205" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个方便的图表，为您提供了不同类型的运行时复杂性的可视化参考。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mg"><img src="../Images/84426deb800b75b511ce7a3afc7b06bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8oaYCvQ7ZR_HGHQn7uYtg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><a class="ae lv" href="http://bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">http://bigocheatsheet.com/</a></p></figure><p id="93f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大O可以变得非常复杂，很难概念化。到目前为止，我能学到的很少的东西实际上只是冰山一角。然而，一旦你理解了为什么和如何工作，理解一些更复杂的想法就更容易了。希望如果你像我一样从零开始，这有助于以一种简单明了的方式解释它。我真的能学会计算大O吗？敬请期待一探究竟！</p></div></div>    
</body>
</html>