<html>
<head>
<title>The Case for Duplicated Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重复代码的情况</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-case-for-duplicated-code-5334557bea69?source=collection_archive---------20-----------------------#2020-04-06">https://betterprogramming.pub/the-case-for-duplicated-code-5334557bea69?source=collection_archive---------20-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="37ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有一个时间和地点的逻辑看起来是一样的。这都是关于代码代表什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6bf763e955d3bf9f852d3da4df8e53b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A2YSHc_e0H0sfacE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">潘卡杰·帕特尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="eb82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您曾经编写过代码，那么您一定听说过“不要重复”原则:</p><blockquote class="lv"><p id="ead2" class="lw lx it bd ly lz ma mb mc md me lu dk translated">"每一项知识都必须在系统中有一个单一的、明确的、权威的表示."——<a class="ae ky" href="https://en.wikipedia.org/wiki/Andy_Hunt_(author)" rel="noopener ugc nofollow" target="_blank">安迪·亨特</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Dave_Thomas_(author)" rel="noopener ugc nofollow" target="_blank">迪夫·托马斯</a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/The_Pragmatic_Programmer" rel="noopener ugc nofollow" target="_blank">T12】务实的程序员T14】</a></p></blockquote><p id="9201" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">这个定义很花哨，大多数人把它理解为“每当你复制和粘贴一些东西时，停下来！”使它成为一个可重用的函数、扩展、字段或任何它需要的东西，以便逻辑是共享的——而不是重复的。你可以在考试中写这个，或者在编码面试中说这个。</p><p id="60ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个伟大的经验法则。代码复制会很快使代码库变得不可维护、臃肿、容易出错，并且很难处理。</p><p id="5bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候。</p><p id="53a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你真的考虑一下DRY原则，并且真的盯着那个术语定义，它实际上并没有严格地谈论代码复制。它谈到了一个更大的问题:真理的单一来源。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="1678" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">干燥，持续一整天</h1><p id="ac16" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们将看一些代码来澄清，但首先一些背景。假设我们有一个客户端应用程序从网络获取数据，将其转换为有用的形状显示给用户，并将数据缓存到设备中。网络响应和缓存数据只能使用基本类型和数组。因此，我们需要在我们的“有用形状”和网络响应之间进行转换，并缓存数据。大概是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/a70064e127ccad62a8a174c5428d1167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ey7oWz3QEEGQjByL0CQjBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers" rel="noopener ugc nofollow" target="_blank"> Heroku发展中心</a>。</p></figure><p id="d1e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的准则是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5ab02b8e6f70cf5449d79086c21ee731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*OQQVgRM2CFhSZ2g65m2opA.png"/></div></figure><p id="e581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的界面。<code class="fe nr ns nt nu b">MyUser</code>是我们希望在应用程序中使用的形状，<code class="fe nr ns nt nu b">MyUserNetwork</code>是我们从网络中获得的形状，<code class="fe nr ns nt nu b">MyUserCache</code>是我们需要能够将数据放入缓存的形状。</p><p id="7053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经注意到一些类似的代码？让我们来看看一些转换函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/825c4bcfd4eca47823009afaa3cba052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSjPomMKG__O3Rf5FZStzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这些并不是你需要的所有转换函数。他们也不是什么好东西！</p></figure><p id="6fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些函数看起来非常相似。人们可能会试图将这些封装到一个函数中，甚至将这些类型完全折叠在一起。我是说，他们看起来一模一样！</p><p id="e5ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我认为无论是接口数据类型还是转换函数都不应该折叠在一起。这是因为它们代表的不是同一个东西。他们没有相同的<em class="nw">意图</em>。如果缓存的工作方式或缓存数据类型需要更改，这应该不会影响网络数据类型。他们长得一样纯粹是巧合。</p><p id="8237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DRY的意思是任何问题都有一个真实的来源，而不是“不要重复逻辑”当我问这个问题时，“我如何从<code class="fe nr ns nt nu b">MyUser</code>转换到<code class="fe nr ns nt nu b">MyUserCache</code>？”应该只有一个地方可以找到这个答案:这个单一函数。如果这些类中的任何一个发生变化，您只有一个地方来重写如何在它们之间进行转换。</p><p id="aa96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是干原理的精髓。我们再举一个例子。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="16b6" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">相同的观点，不同的视角</h1><p id="efd1" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们可以从UI层面来考虑这个问题。假设您的应用程序中有用户个人资料，并且您允许用户拥有个人资料图片。假设您有一个如下所示的用户界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4e0f5b201789e1de63eb7d2ea11a304b.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*0iQrXEMr4MrJtb35dS2blw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户配置文件屏幕。</p></figure><p id="276c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你的任务是做一个这样的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/eedca8e5f24e882ecf213c91423a1b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*RTUSOq6lon_QGjnXnzAjEw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户列表的搜索结果。</p></figure><p id="fcd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看到什么是可以复制的吗？此用户标识形状:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/5872491edc1c2a802039fcfbe0209e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*qqHqdtrz_UxJ-8EInBm8TA.png"/></div></figure><p id="f0f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们可能想让结果列表中的单元格与用户配置文件顶部的形状共享相同的代码。我是说，他们看起来一模一样！我自己复制粘贴的！</p><p id="96b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，同样，我认为这些应该是具有独立代码的独立视图。如果一个人想改变搜索结果的外观，他不会期望用户简档屏幕改变。事实上，作为一个QA人员，甚至不看用户资料也是合理的。他们没有精神上的联系。*</p><p id="3f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，继续复制样式并查看这些屏幕的代码。把它放在一个新的文件中，并有一些重复的代码。</p><p id="fa10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw">*这也可以通过测试来发现。+1表示测试您的代码。</em></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5f2a" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="3953" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这些是一些非常具体的例子，说明重复代码是可以的。这些并不经常发生，但是当代码被共享而人们没有意识到这一点时，就会产生意想不到的后果。</p><p id="6f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验法则是，当代码是一个想法的真实来源时，它应该被共享。这个视图是什么样子的？我如何在这些类型之间转换？答案应该只有一个。</p><p id="5639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>