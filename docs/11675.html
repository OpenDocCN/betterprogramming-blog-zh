<html>
<head>
<title>How to Process Notifications With Kafka, MinIO, And Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Kafka、MinIO和Python处理通知</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-process-notifications-with-kafka-minio-and-python-8a288b12854?source=collection_archive---------5-----------------------#2022-04-07">https://betterprogramming.pub/how-to-process-notifications-with-kafka-minio-and-python-8a288b12854?source=collection_archive---------5-----------------------#2022-04-07</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="faf7" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">通过Kafka发送存储桶通知，并使用Python处理记录</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/142162ee7d3b5fd01efb278d71644add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1xvLsSvKIGHbACRw"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Christopher Gower 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6208" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Event-driven_architecture" rel="noopener ugc nofollow" target="_blank">事件驱动架构</a>已经成为一种流行的方法，它使解耦的应用程序能够相互通信。</p><p id="5b68" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了说明这个架构是如何工作的，我们将设置<a class="ae kz" href="https://min.io/" rel="noopener ugc nofollow" target="_blank"> Minio </a>通过Kafka发送主题通知。然后，我们将用Python创建一个简单的Kafka监听器来使用事件记录。</p><p id="dfdc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们开始吧！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0c28" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">准备迷你卡夫卡环境</h1><p id="b488" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">首先，让我们准备本地开发基础设施。最简单的开始方式是运行一个<code class="fe na nb nc nd b">docker-compose.yml</code>文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div></figure><p id="026c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们为<code class="fe na nb nc nd b">minio</code>、<code class="fe na nb nc nd b">kafka</code>和<code class="fe na nb nc nd b">zookeeper</code>创建容器。</p><ul class=""><li id="5281" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated">MinIO服务充当生产者，向Kafka发送通知数据。</li><li id="ef68" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">Kafka是一个流系统，它将使用MinIO事件数据并相应地处理记录。</li><li id="025a" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">Zookeeper用于跟踪Kafka集群中节点的状态，并维护Kafka主题、分区等的列表。</li></ul><p id="468e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">重要注意事项:</p><ul class=""><li id="2a26" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated">米尼奥的<code class="fe na nb nc nd b">environment</code>配置定义了卡夫卡的属性。例如，代理端口、通知主题名称。</li><li id="3b83" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">卡夫卡经纪人出现在<code class="fe na nb nc nd b">9092</code>端口。所以，我们可以参考它进行局部测试。</li><li id="d821" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">所有服务应该运行在同一个网络中，在本例中是<code class="fe na nb nc nd b">kafka-net</code>。</li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="3185" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">配置MinIO通知</h1><p id="2029" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">运行<code class="fe na nb nc nd b">docker-compose.yml</code>文件:</p><pre class="kk kl km kn gu nu nd nv nw aw nx bi"><span id="a9bd" class="ny me iu nd b gz nz oa l ob oc">$ docker-compose up -D</span></pre><p id="11c4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后使用凭证登录运行在<a class="ae kz" href="http://localhost:9001/" rel="noopener ugc nofollow" target="_blank"> http://localhost:9001/ </a>上的MinIO的控制台:<em class="od">minioadmin</em>/<em class="od">minioadmin</em>。</p><p id="a4f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">确保MinIO和Kafka配置正确。导航至<strong class="lc iv">设置- &gt;通知</strong>。<strong class="lc iv">通知端点</strong>应该在线；</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/5e8cfe01ffae9d908f0a8afafc37848b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XLYNkbgz-pIGWGdRJrIuqA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Kafka的通知端点</p></figure><p id="a196" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创建新的存储桶:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj of"><img src="../Images/8f4ec01cb84aa709c126f16220242048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yagd_RAx2ENstATA2ZyUqQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">创建新的存储桶</p></figure><p id="a70a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">点击新的存储桶并选择<strong class="lc iv">管理</strong>。</p><p id="b79e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">点击<strong class="lc iv">订阅事件</strong>按钮订阅通知事件:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/31f0563377358c379a4eba260b796351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKQ1la527nlCshg8RpM6MQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">订阅存储桶事件</p></figure><p id="b59a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> ARN </strong>下拉菜单应该会自动提示卡夫卡。订阅一些事件，例如<strong class="lc iv">放</strong>，<strong class="lc iv">获取，删除</strong>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="bf39" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">测试通知</h1><p id="7828" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们已经配置了MinIO和Kafka，并订阅了通知事件。所以，现在当我们上传一个文件，我们应该得到通知。如何检查是否收到通知？让我们使用<code class="fe na nb nc nd b"><a class="ae kz" href="https://github.com/edenhill/kcat" rel="noopener ugc nofollow" target="_blank">kcat</a></code>，一个轻量级的、简单易用的消息阅读器工具。</p><p id="e9cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要在Ubuntu上安装<code class="fe na nb nc nd b">kcat</code>,在终端中运行:</p><pre class="kk kl km kn gu nu nd nv nw aw nx bi"><span id="e51f" class="ny me iu nd b gz nz oa l ob oc">$ apt-get install kafkacat</span></pre><p id="00f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，让我们启动该工具，将代理的端口和主题的名称作为参数传递:</p><pre class="kk kl km kn gu nu nd nv nw aw nx bi"><span id="fc34" class="ny me iu nd b gz nz oa l ob oc">$ kafkacat -b localhost:9092 -t my-notifications</span></pre><p id="1297" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">就是这样！</p><p id="d08d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们将一个文件上传到MinIO中的bucket。</p><p id="61e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的<code class="fe na nb nc nd b">kcat</code>控制台应该会立即向您显示通知:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/ff7b846fddffd542f9c9e678377ae897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KoQpTmPaAHV3AE8VFj_iKA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Kcat输出</p></figure><p id="db4b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">厉害！现在，我们成功地通过Kafka接收来自MinIO的通知。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4101" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">配置Python Kafka监听器</h1><p id="a8ab" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Python可以使用几个Kafka客户端。在本教程中，我使用的是<code class="fe na nb nc nd b"><a class="ae kz" href="https://kafka-python.readthedocs.io/en/master/index.html" rel="noopener ugc nofollow" target="_blank">kafka-python</a></code>库:</p><pre class="kk kl km kn gu nu nd nv nw aw nx bi"><span id="0294" class="ny me iu nd b gz nz oa l ob oc">$ pip3 install kafka-python</span></pre><p id="5c54" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们用以下内容创建一个新的Python文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">kafka-listener.py代码</p></figure><p id="7c78" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们用以下参数初始化一个<code class="fe na nb nc nd b">KafkaConsumer</code>:</p><ul class=""><li id="69da" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated"><code class="fe na nb nc nd b">topic</code> —要听的题目名称。</li><li id="ca95" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated"><code class="fe na nb nc nd b">value_deserializer</code> —将数据反序列化为通用的JSON格式。这种格式有利于灵活的数据操作。</li></ul><p id="d515" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="od">注意还有一个可选参数，</em> <code class="fe na nb nc nd b"><em class="od">bootstrap_listener</em></code> <em class="od">，其默认值为</em> <code class="fe na nb nc nd b"><em class="od">localhost:9092</em></code> <em class="od">。因为这是我们使用的，所以我没有把它包括在参数列表中。</em></p><p id="11c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在后台线程中启动Kafka监听器。程序从循环中的主题开始轮询。当消息到达时，我们简单地打印出数据。通常，我们会执行一些代码来处理接收到的记录。</p><p id="d8cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">运行程序:</p><pre class="kk kl km kn gu nu nd nv nw aw nx bi"><span id="7ce8" class="ny me iu nd b gz nz oa l ob oc">$ python3 kafka-listener.py</span></pre><p id="ba29" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们通过在MinIO Bucket中上传一个新文件来测试它。</p><p id="b536" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您应该会在终端的控制台上看到一个<code class="fe na nb nc nd b">ConsumerRecord</code>:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oi"><img src="../Images/f89c6352ac4144238afd064139dd5e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2i4sp3m__f9ALZftpKBPg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Python Kafka监听器使用的结果</p></figure><p id="9cac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如您所见，该程序按预期运行。设置它非常简单！</p><p id="404e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，它也应该适用于删除和下载事件。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="633e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">总结</h1><p id="87c0" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在这个简短的教程中，我向您展示了如何使用Kafka从MinIO接收桶通知。我们还使用<code class="fe na nb nc nd b">kafka-python</code>库创建了一个小的Python程序来使用记录。</p><p id="9b61" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本例中的消费者配置是用于演示目的的基本配置。更高级的用法，查看<a class="ae kz" href="https://kafka-python.readthedocs.io/en/master/apidoc/modules.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="6d1e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你喜欢这个话题，你可能会喜欢一个类似的。它基于MinIO、RabbitMQ和Java技术堆栈:</p><div class="oj ok gq gs ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/java-process-messages-from-rabbitmq-and-upload-data-to-minio-cloud-b70ecd2e82be"><div class="on ab fp"><div class="oo ab op cl cj oq"><h2 class="bd iv gz z fq or fs ft os fv fx it bi translated">Java:处理来自RabbitMQ的消息并将数据上传到MinIO Cloud</h2><div class="ot l"><h3 class="bd b gz z fq or fs ft os fv fx dk translated">消费来自RabbitMQ的消息并将epub文件上传到MinIO云存储</h3></div><div class="ou l"><p class="bd b dl z fq or fs ft os fv fx dk translated">better编程. pub</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kt om"/></div></div></a></div><p id="21f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读，祝您编码愉快！</p></div></div>    
</body>
</html>