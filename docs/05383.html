<html>
<head>
<title>Add Authentication to Your App With BCrypt and JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BCrypt和JWT为您的应用程序添加身份验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adding-authentication-to-your-application-with-bcrypt-and-json-web-tokens-8bf449de3b2b?source=collection_archive---------1-----------------------#2020-07-05">https://betterprogramming.pub/adding-authentication-to-your-application-with-bcrypt-and-json-web-tokens-8bf449de3b2b?source=collection_archive---------1-----------------------#2020-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="73f3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">好的应用程序是安全的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1558098404dbe7e8d844536273f73fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1RnA5nJL0vj7vVkl-YGcw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片来自<a class="ae kv" href="https://gomedici.com/future-of-authentication-what-will-replace-login-password-pairs" rel="noopener ugc nofollow" target="_blank">美第奇</a>。</p></figure><p id="4ad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最近的一次软件工程面试中，出现了关于认证的问题。这是一个严酷的警钟，让我意识到我在这方面已经生疏了。我最近习惯于在我的项目中完全跳过身份验证，因为它们的规模相对较小，并且包含没有敏感信息的虚拟种子数据。在过去和紧迫的最后期限下，我被告知不要太担心身份验证，因为许多公司将这一过程完全外包给网络安全专业服务。</p><p id="8ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，这些绝不是忽略身份验证的好借口。每个软件工程师都需要知道用户认证的基本概念和实现。</p><p id="afb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的采访中断之后，本着成长的精神，我决定回到这个主题，使用<code class="fe ls lt lu lv b">BCrypt</code>和JSON Web令牌创建一个带有身份验证的应用程序的小演示。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="2f1e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">构建Rails服务器</h1><p id="c473" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">首先，我们将使用以下命令创建一个Rails项目:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="ef1c" class="ne me iq lv b gy nf ng l nh ni">rails new &lt;project_name&gt; --api --database=postgresql</span></pre><p id="2fa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们使用<a class="ae kv" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>作为数据库，并向Rails表明这将是一个带有<code class="fe ls lt lu lv b">--api</code>标志的API。如果没有这个标志，我们会生成许多额外的不必要的文件，包括完整的MVC框架。</p><p id="d3a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将安装<code class="fe ls lt lu lv b">jwt</code>和<code class="fe ls lt lu lv b">active_model_serializers</code>宝石:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="d0f9" class="ne me iq lv b gy nf ng l nh ni">bundle add jwt &amp;&amp; bundle add active_model_serializers</span></pre><p id="d436" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，导航到<code class="fe ls lt lu lv b">Gemfile</code>并取消注释<code class="fe ls lt lu lv b">gem 'rack-cors'</code>，允许我们在API中建立跨源资源共享(CORS)。我们还将取消对<code class="fe ls lt lu lv b">gem 'bcrypt'</code>的注释。最后，在终端中运行<code class="fe ls lt lu lv b">bundle install</code>来安装这些库。</p><p id="e684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要启用CORS，转到<code class="fe ls lt lu lv b">config/initializers/cors.rb</code>并取消以下注释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b5a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，将<code class="fe ls lt lu lv b">'example.com'</code>改为<code class="fe ls lt lu lv b">'*'</code>。这将允许所有域向我们的API发出请求。这涉及到安全问题，所以对于除了演示之外的任何东西，我建议将访问权限限制在您的前端领域。</p><p id="c9c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将使用以下命令创建用户模型、控制器和序列化程序:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="9704" class="ne me iq lv b gy nf ng l nh ni">rails g model User username password password_digest bio avatar<br/>rails g controller api/v1/users<br/>rails g serializer user</span></pre><p id="2f07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在生成模型时，可以随意在模式中包含任何您喜欢的列。<code class="fe ls lt lu lv b">username</code>、<code class="fe ls lt lu lv b">password</code>和<code class="fe ls lt lu lv b">password_digest</code>大约是最低要求。</p><p id="3028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建数据库，请运行:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="7a0c" class="ne me iq lv b gy nf ng l nh ni">rails db:create<br/>rails db:migrate</span></pre><p id="dd1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！我们现在有了一个基本的API后端，可以开始实现身份验证逻辑了。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="69c0" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">BCrypt</h1><p id="2743" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在我们的应用程序中，我们使用<code class="fe ls lt lu lv b">BCrypt</code>来存储用户的明文密码。salt是添加到用户密码中的一点随机数据。加盐密码然后通过散列函数运行。哈希函数实际上是一个单向过程，因为不可能解析哈希来确定原始密码。多亏了<code class="fe ls lt lu lv b">BCrypt</code>，我们现在有了可以安全存储在数据库中的“摘要”密码。不要在数据库中存储明文密码。</p><p id="e934" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在用户模型中创建一个<code class="fe ls lt lu lv b">authenticate</code>方法来比较用户的明文密码和密码摘要。它看起来会像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5bba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过我们会用内置的<code class="fe ls lt lu lv b">ActiveModel#has_secure_password</code>。我们将把它添加到用户模型中，并进行一些验证来检查用户名的唯一性:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="1fb2" class="ne me iq lv b gy nf ng l nh ni">class User &lt; ApplicationRecord<br/>  has_secure_password<br/>  validates :username, uniqueness: { case_sensitive: false }<br/>end</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="f7bd" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">创建用户</h1><p id="97a5" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们将首先关注创建新的有效用户。在<code class="fe ls lt lu lv b">UsersController</code>中，我们将定义一个<code class="fe ls lt lu lv b">create</code>方法以及一些强参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c4ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们使用了Rails内置的状态代码符号，<code class="fe ls lt lu lv b">status: :created</code>和<code class="fe ls lt lu lv b">status: :not_acceptable</code>。这些将分别抛出201和406代码。我们将在<code class="fe ls lt lu lv b">UserSerializer</code>中添加我们希望在客户端显示的属性:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="e9e5" class="ne me iq lv b gy nf ng l nh ni">class UserSerializer &lt; ActiveModel::Serializer<br/>  attributes :username, :avatar, :bio<br/>end</span></pre><p id="755b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航到<code class="fe ls lt lu lv b">config/routes.rb</code>添加我们的服务器所需的路线。我们需要路由来处理两个动作。当现有用户登录并发送请求以查看其个人资料时。这两个操作都需要一个JSON Web令牌，稍后会详细介绍。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们的后端已经准备好处理对<code class="fe ls lt lu lv b">api/v1/users</code>端点的POST请求。我建议快速编写一个普通的JavaScript或者React前端来测试你是否可以成功地创建新用户。使用<code class="fe ls lt lu lv b">fetch</code>，请求看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="21fa" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">JSON Web令牌(JWT)</h1><p id="7165" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">jwt提供了一种将信息作为JSON对象安全传递的方式。它们允许我们使用无状态身份验证，这意味着当前用户的任何信息都不会存储在服务器上。用户数据用JWT编码，该令牌存储在客户端(浏览器)。然后，它会随每个经过身份验证的数据请求一起发送。下图很好地总结了这一过程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/4221951051283a617142688644279f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*v1xb9ZGyQPu2w0xujuo20w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication" rel="noopener ugc nofollow" target="_blank"> scotch.io </a>。</p></figure><p id="a389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">jwt有一个由句点分隔的三个字符串组成的通用结构，每个字符串携带编码数据。它们看起来像这样:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="ab75" class="ne me iq lv b gy nf ng l nh ni">xxxxxxxxxxx.yyyyyyyyyyyyyy.zzzzzzzzzzzzz</span></pre><p id="eb6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个字符串携带头数据。这包括令牌类型<code class="fe ls lt lu lv b">jwt</code>，以及用于对有效负载进行数字签名和验证的签名算法:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="1f33" class="ne me iq lv b gy nf ng l nh ni">{<br/>  "alg": "HS256",<br/>  "typ": "JWT"<br/>}</span></pre><p id="7c40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">中间的字符串包括有效负载。在我们的例子中，这是与用户相关的信息(用户名、ID等。).</p><p id="67ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三个字符串代表签名。它是通过组合报头、编码的有效载荷、秘密和报头中指定的算法来创建的。该签名验证数据在请求过程中未被更改或篡改，还可以确认JWT的发送者就是他们所说的那个人:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="8816" class="ne me iq lv b gy nf ng l nh ni">HMACSHA256(<br/>  base64UrlEncode(header) + "." +<br/>  base64UrlEncode(payload),<br/>  secret)</span></pre><p id="2605" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">jwt有两个关键方法:<code class="fe ls lt lu lv b">encode</code>和<code class="fe ls lt lu lv b">decode</code>。<code class="fe ls lt lu lv b">encode</code>接受要编码的有效负载的三个参数，您选择的应用程序秘密，以及可选的要使用的散列算法。此方法返回JWT字符串。<code class="fe ls lt lu lv b">decode</code>接受类似的JWT字符串的三个参数，一个应用程序秘密，以及可选的散列算法。</p><h2 id="d3c5" class="ne me iq bd mf nm nn dn mj no np dp mn lf nq nr mp lj ns nt mr ln nu nv mt nw bi translated">JWTs和应用程序控制器</h2><p id="aa03" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">由于其他控制器需要认证和授权用户的能力，我们将把这一功能放在<code class="fe ls lt lu lv b">ApplicationController</code>的顶层。首先，我们将创建一个用令牌对请求负载进行编码的方法，以及一个对随后续请求发送的令牌进行解码的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d6fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户请求访问受授权保护的路由或资源时，用户需要发送JWT。令牌包含在使用承载模式<code class="fe ls lt lu lv b">Authorization: Bearer &lt;token&gt;</code>的<code class="fe ls lt lu lv b">fetch</code>请求的报头中。实际上，这看起来像是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5fc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许我们修改我们的<code class="fe ls lt lu lv b">decoded_token</code>方法，期望授权头包含JWT:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="46c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面，我们使用了<code class="fe ls lt lu lv b">begin/rescue</code>语法，它允许我们在服务器被传递了无效令牌的情况下拯救出一个异常。服务器不会崩溃，而是会返回<code class="fe ls lt lu lv b">nil</code>。</p><p id="0745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将编写一个<code class="fe ls lt lu lv b">current_user</code>方法，每当出现一个令牌进行授权时，该方法将获取相关的用户。我们还可以定义一个<code class="fe ls lt lu lv b">logged_in?</code>方法，它将根据<code class="fe ls lt lu lv b">current_user</code>方法的返回返回一个布尔值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="341e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将定义一个提示用户授权的方法，并使用<code class="fe ls lt lu lv b">before_action</code>在任何路由或资源请求之前要求授权:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="d81e" class="ne me iq bd mf nm nn dn mj no np dp mn lf nq nr mp lj ns nt mr ln nu nv mt nw bi translated">在用户控制器中分配令牌</h2><p id="9446" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">既然我们已经有了在<code class="fe ls lt lu lv b">ApplicationController</code>中创建和读取jwt的功能，让我们调用<code class="fe ls lt lu lv b">UsersController</code>中的<code class="fe ls lt lu lv b">encode_token</code>在用户注册时自动分配一个令牌。我们还必须确保在创建用户之前跳过授权。注册或创建用户是唯一不需要用户登录即可访问的操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="d81a" class="ne me iq bd mf nm nn dn mj no np dp mn lf nq nr mp lj ns nt mr ln nu nv mt nw bi translated">登录时创建令牌</h2><p id="644a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">不仅需要在用户注册时创建令牌，而且现有用户每次登录时都必须创建新令牌。为了处理这个问题，我们将创建一个<code class="fe ls lt lu lv b">AuthController</code>:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="0c2b" class="ne me iq lv b gy nf ng l nh ni">rails g controller api/v1/auth</span></pre><p id="7815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的控制器中，我们将编写一些方法来为登录用户以及一些强参数创建身份验证:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7f5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用从<code class="fe ls lt lu lv b">ApplicationController</code>继承的<code class="fe ls lt lu lv b">encode_token</code>方法，我们通过在有效载荷中包含现有用户的ID来创建令牌。然后我们返回这个新的JWT和用户数据。然后，用户的数据可以存储在前端的state中(如果使用React或Redux)，令牌可以存储在客户端。</p><p id="c832" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的前端，一个执行登录动作的<code class="fe ls lt lu lv b">fetch</code>请求将包含一个到<code class="fe ls lt lu lv b">/api/v1/login</code>端点的POST方法。正如我们在路线中指定的，这将调用<code class="fe ls lt lu lv b">AuthController</code>中的<code class="fe ls lt lu lv b">create</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="6f52" class="ne me iq bd mf nm nn dn mj no np dp mn lf nq nr mp lj ns nt mr ln nu nv mt nw bi translated">访问用户的简档</h2><p id="4779" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">之前，我们讨论了JWT必须如何包含在授权头中才能访问受保护的路由和资源，例如用户的配置文件。让我们为登录的用户构建查看其个人资料的功能。我们将在<code class="fe ls lt lu lv b">UsersController</code>中编写一个<code class="fe ls lt lu lv b">profile</code>方法，它将发送一个包含用户数据的JSON对象，前提是用户已经被授权:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就结束了我们的Rails服务器的认证和授权！正如我所说的，我发现在基本的前端测试所有东西是有帮助的。虽然本文没有讨论，但是您可以在我的GitHub上找到我的<a class="ae kv" href="https://github.com/MACorman/medium_blog_auth_frontend/pull/4" rel="noopener ugc nofollow" target="_blank">前端存储库</a>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="c227" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">参考</h1><div class="nx ny gp gr nz oa"><a href="https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">基于令牌的身份验证的来龙去脉</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">引言如今，基于令牌的认证在网络上随处可见。几乎每个网络公司都使用…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">scotch.io</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kp oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">HTTP响应状态代码</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">HTTP响应状态代码指示特定的HTTP请求是否已成功完成。回答是…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">developer.mozilla.org</p></div></div><div class="oj l"><div class="op l ol om on oj oo kp oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://github.com/codahale/bcrypt-ruby" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">codahale/bcrypt-ruby</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">保护用户密码安全的简单方法。如果您明文存储用户密码，那么窃取…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="oq l ol om on oj oo kp oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://jwt.io/introduction/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">JWT。IO — JSON Web令牌简介</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">新:免费获得JWT手册，深入学习jwt！JSON Web Token (JWT)是一个开放标准(RFC 7519 ),它…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">jwt.io</p></div></div><div class="oj l"><div class="or l ol om on oj oo kp oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://blog.angular-university.io/angular-jwt/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">JWT:JSON Web令牌完全指南</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">这篇文章是一个分两部分的分步指南的第一部分，该指南从一个角度介绍了如何实现基于JWT的认证</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">blog.angular-university.io</p></div></div><div class="oj l"><div class="os l ol om on oj oo kp oa"/></div></div></a></div></div></div>    
</body>
</html>