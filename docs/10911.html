<html>
<head>
<title>Struggling With Webpack? Understand It Through Illustrations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纠结于Webpack？通过插图来理解</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/struggling-with-webpack-understand-it-through-illustrations-c8009e6ad4d5?source=collection_archive---------2-----------------------#2022-02-03">https://betterprogramming.pub/struggling-with-webpack-understand-it-through-illustrations-c8009e6ad4d5?source=collection_archive---------2-----------------------#2022-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e0c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我制作了3个动画来解释Webpack的内部工作原理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2010baa61b9b0f169e923bc4eeff6a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PtOVOt8Ry95-HAyIA93BKQ.png"/></div></div></figure><p id="a9b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相信每个前端开发者都听说过webpack。作为前端开发最重要的构建工具，大大提高了我们的开发效率。</p><p id="92df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然网上有很多关于Webpack的教程，但是由于Webpack本身的复杂性，很多初学者即使看了那些教程，仍然无法理解Webpack。</p><p id="17e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我试着写一个更容易理解的教程，创作几个动画。希望能帮你更容易理解。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="eef5" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">webpack是做什么的？</h1><p id="8297" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Webpack的核心功能是将不同的JavaScript模块捆绑在一起。</p><p id="32bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有两个JavaScript文件:</p><p id="aba0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">add.js</code>:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="6c80" class="nc ly it mx b gy nd ne l nf ng">exports.default = function (a, b) {<br/>  return a + b<br/>}</span></pre><p id="d4e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">index.js</code>:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="f320" class="nc ly it mx b gy nd ne l nf ng">var add = require('./add.js').default</span><span id="290c" class="nc ly it mx b gy nh ne l nf ng">console.log(add(1, 2))</span></pre><p id="98c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们使用CommonJS标准模块语法。如果我们直接使用nodejs来执行这段代码，它会工作得很好:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5470" class="nc ly it mx b gy nd ne l nf ng">$ node index.js</span><span id="5f57" class="nc ly it mx b gy nh ne l nf ng">3</span></pre><p id="997d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果它们被直接引用到HTML文件中，浏览器将无法正确执行这些代码:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="8620" class="nc ly it mx b gy nd ne l nf ng">&lt;script src="./add.js"&gt;&lt;/script&gt;<br/>&lt;script src="./index.js"&gt;&lt;/script&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/bece0fe094ef8970de6447c3e1d8463f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOnQZD_n5J0jm8YehzMw0Q.png"/></div></div></figure><p id="0240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这主要是因为CommonJS标准不是Web API的一部分。浏览器无法理解<code class="fe mu mv mw mx b">exports</code>对象和<code class="fe mu mv mw mx b">require</code>函数，因此上述代码无法正确执行。</p><p id="8ab7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，我们可以使用Webpack对代码进行打包。Webpack要做的就是把上面的代码转换成浏览器能理解的新版本，不能改变原来的执行逻辑。</p><p id="2de1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解一个特性的最好方法是自己实现它。让我们来看看相关的功能是如何实现的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2f2d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">实施导出</h1><p id="ef87" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如果我们想要加载一个模块，我们只需要两步:</p><ul class=""><li id="d6e7" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">阅读文件的内容</li><li id="e459" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">然后将字符串转换成可执行代码</li></ul><p id="fa57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当读取文件内容时，我们可以使用像<code class="fe mu mv mw mx b">fs.readfileSync()</code>这样的API。然后我们可以使用<code class="fe mu mv mw mx b">eval</code>函数将文件中的字符串作为代码执行。</p><p id="e287" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nx">提示:</em> <code class="fe mu mv mw mx b"><strong class="kw iu"><em class="nx">eval()</em></strong></code> <em class="nx">函数计算表示为字符串的JavaScript代码。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/92e4925ec4859cd17d0c39dce77fcb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HK1sn-SJsUwxqY8HkKgipg.png"/></div></div></figure><p id="3c66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们可以把<code class="fe mu mv mw mx b">add.js</code>转换成这样:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5269" class="nc ly it mx b gy nd ne l nf ng">var exports = {}</span><span id="ca95" class="nc ly it mx b gy nh ne l nf ng">eval('exports.default = function(a,b) {return a + b}')</span></pre><p id="be28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样的代码可以被浏览器理解:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/304bd510daa39d3c13e563e62f463236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nn56w8dFyW71Cd_sKwQhA.png"/></div></div></figure><p id="5885" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用动画来表现这个过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/fd90c11387523ec922792f7694bb4f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ej-pjaZ-me7aiSYo7u-_Q.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">以前</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/e45e3a02c6e4a99140951f0208400412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Az9WChkuMq397U0fDlVRwg.gif"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">过程</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/e3a1b1f25e0d9f59a81cbe27cf76a85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNT6Btathqq9p_7XMDSSqA.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">在...之后</p></figure><p id="994f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是上面的实现有一个小缺点，就是如果在模块中声明了一个变量，那么在<code class="fe mu mv mw mx b">eval</code>之后就会变成一个全局变量，从而污染全局命名空间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/692906018d880b9a4e1b9d3ce7ef6c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w43AEu-4ap9U4c2p5fIfeg.png"/></div></div></figure><p id="1395" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，我们用<a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">立即调用的函数表达式</a>封装了作用域:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="63c5" class="nc ly it mx b gy nd ne l nf ng">var exports = {}<br/>(function (exports, code) {<br/> eval(code)<br/>})(exports, 'exports.default = function(a,b){return a + b}')</span></pre><p id="4037" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，这就是Webpack处理<code class="fe mu mv mw mx b">exports</code>的方式。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="cc51" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">实施要求</h1><p id="e452" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">那么如何编写<code class="fe mu mv mw mx b">require</code>函数呢？<code class="fe mu mv mw mx b">require</code>函数需要做的事情很简单，就是取出exports中的内容。</p><p id="8726" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们可以简化问题，假设我们现在只需要加载<code class="fe mu mv mw mx b">add.js</code>中的内容。那么<code class="fe mu mv mw mx b">require</code>函数可以这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9757" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们的代码从这种形式开始:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="a278" class="nc ly it mx b gy nd ne l nf ng">exports = {}<br/>eval('exports.default = function(a,b) {return a + b}')</span><span id="3b6e" class="nc ly it mx b gy nh ne l nf ng">var add = require('add.js').default<br/>console.log(add(1 , 2))</span></pre><p id="bc23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种形式:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ab01" class="nc ly it mx b gy nd ne l nf ng">function require(file) {<br/>  var exports = {};<br/>  (function (exports, code) {<br/>    eval(code)<br/>  })(exports, 'exports.default = function(a,b){return a + b}')<br/>  return exports<br/>}</span><span id="49c8" class="nc ly it mx b gy nh ne l nf ng">var add = require('add.js').default<br/>console.log(add(1 , 2))</span></pre><p id="5079" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述代码已经可以在浏览器环境中使用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/60e6875e6cfd1806c411602dd6db822c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7d4KFL5NHfRHiavs1l09g.png"/></div></div></figure><p id="7a8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们将代码转换的过程制作成动画，它应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/ab6932289263d792a532d8b9753043f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*i02IisEp9gkzy8EfdNRo1g.gif"/></div></div></figure><p id="4b8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果有多个模块需要加载，那么我们应该将所有模块的文件名和代码串组织成一个键值表，然后我们可以根据参数加载不同的模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="454a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，为了避免引入变量<code class="fe mu mv mw mx b">moduleList</code>，我们可以把上面的代码写成<a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">立即调用函数表达式</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e706" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们简单地实现了<code class="fe mu mv mw mx b">require</code>函数。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="19bf" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">一般过程</h1><p id="c50d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">除了解决<code class="fe mu mv mw mx b">exports</code>和<code class="fe mu mv mw mx b">require</code>的问题，Webpack还会做很多事情。</p><p id="83d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在打包过程中，Webpack还处理模块之间的依赖关系。它会生成如下所示的依赖关系图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="a87e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，Webpack需要将ES6语法转换成ES5语法。</p><p id="e741" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总结一下，Webpack打包的流程大致如下:</p><ul class=""><li id="287e" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">分析模块之间的依赖关系</li><li id="194b" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">将ES6转换为ES5</li><li id="5399" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">取代出口并要求</li></ul><p id="820a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用动画来表现这个过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/379324797b84b464213390912dc8cac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2IQJMTBSA5YLqdCGxnx8Yg.gif"/></div></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="4525" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p><h1 id="7c83" class="lx ly it bd lz ma oo mc md me op mg mh jz oq ka mj kc or kd ml kf os kg mn mo bi translated">相关文章</h1><ul class=""><li id="ad73" class="nj nk it kw b kx mp la mq ld ot lh ou ll ov lp no np nq nr bi translated"><a class="ae oi" href="https://medium.com/frontend-canteen/13-webpack-optimization-tips-you-should-know-668666f8c020" rel="noopener">你应该知道的13个Webpack优化技巧</a></li></ul></div></div>    
</body>
</html>