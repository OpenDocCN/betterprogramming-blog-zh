<html>
<head>
<title>A Dive Into Python Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Decorators探究</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-python-decorators-e95291a77cfb?source=collection_archive---------14-----------------------#2022-01-17">https://betterprogramming.pub/a-deep-dive-into-python-decorators-e95291a77cfb?source=collection_archive---------14-----------------------#2022-01-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ff01" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">理解日志、时间、嵌套和其他内置的Python装饰器</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/03f030bc09aaa4b73b14383b739c4d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K5vDcLAl-rGRAmhJ"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@spacejoy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Spacejoy </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="185a" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">介绍</h1><p id="868c" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">Python装饰器是一个修改另一个函数并返回一个函数的函数。Python装饰器的概念有点难以理解。让我们详细了解一下Python decorators。</p><h1 id="6f30" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">内容</h1><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="5f82" class="mt lb iu mp b gz mu mv l mw mx">1. <a class="ae kz" href="#14b5" rel="noopener ugc nofollow">What is a Python Decorator?</a><br/>2. <a class="ae kz" href="#f0cf" rel="noopener ugc nofollow">Create a Simple Python Decorator</a><br/>3. <a class="ae kz" href="#81cf" rel="noopener ugc nofollow">Debugging-Fix the Function Name and Docstring</a><br/>4. <a class="ae kz" href="#5843" rel="noopener ugc nofollow">Nested Decorators</a><br/>5. <a class="ae kz" href="#62de" rel="noopener ugc nofollow">Passing Arguments to the Decorator</a><br/>6. <a class="ae kz" href="#9e8c" rel="noopener ugc nofollow">Passing Arguments to the Function</a><br/>7. <a class="ae kz" href="#3fc1" rel="noopener ugc nofollow">Logged Decorator</a><br/>8. <a class="ae kz" href="#93e8" rel="noopener ugc nofollow">Time Decorator</a><br/>9. <a class="ae kz" href="#fab8" rel="noopener ugc nofollow">Functools.lru_cache(Memoize)</a><br/>10. <a class="ae kz" href="#b885" rel="noopener ugc nofollow">Uses of Decorators</a><br/>11. <a class="ae kz" href="#218c" rel="noopener ugc nofollow">Built-in Python Decorators</a><br/>12. <a class="ae kz" href="#6307" rel="noopener ugc nofollow">Conclusion</a></span></pre><h1 id="14b5" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">Python装饰器</h1><ul class=""><li id="6f9b" class="my mz iu lu b lv lw ly lz mb na mf nb mj nc mn nd ne nf ng bi translated">装饰器是Python 2.4中引入的。</li><li id="1b97" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">Python decorator函数是一个修改另一个函数并返回一个函数的函数。</li><li id="d4e7" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">它接受一个函数作为它的参数。</li><li id="834c" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">它返回一个闭包。Python中的闭包只是一个由另一个函数返回的函数。</li><li id="56a6" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">装饰函数中有一个包装函数。</li><li id="c505" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">它向现有函数添加了一些额外的功能，而不改变现有函数的代码。这是装修工可以做到的。</li><li id="ebe7" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">装饰器允许你在函数前后执行代码；他们装饰而不修改功能本身。</li><li id="2b36" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">在Python中，decorator以<code class="fe nm nn no mp b">@</code> <strong class="lu iv"> </strong>符号开始，后跟decorator函数的名称。</li><li id="b1a7" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">装饰者减慢函数调用。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj np"><img src="../Images/e5b6b3f5777226742555411b62c8fc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3VLFEAzTe5t78767N6tsAg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><h1 id="f0cf" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">创建一个简单的Python装饰器</h1><p id="6144" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">让我们编码，看看它是如何工作的。</p><ol class=""><li id="05ce" class="my mz iu lu b lv nq ly nr mb ns mf nt mj nu mn nv ne nf ng bi translated">下面我有一个简单的函数，它给出三个数的乘积。就叫原函数吧。</li></ol><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="c9e5" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">2.现在我想修改原函数的功能，而不修改原函数中的代码。这可以通过使用Python装饰器来完成。</p><p id="b574" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">现在我有以下功能:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><ul class=""><li id="7f61" class="my mz iu lu b lv nq ly nr mb ns mf nt mj nu mn nd ne nf ng bi translated">我有一个名为<code class="fe nm nn no mp b">decor_func</code>的装饰函数。在装饰函数中，我有另一个名为<code class="fe nm nn no mp b">wrapper_func</code>的函数，它接受任意数量的参数——<code class="fe nm nn no mp b">*args </code>和<code class="fe nm nn no mp b">**kwargs</code>。</li><li id="08c8" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated"><code class="fe nm nn no mp b">decor_func</code>将返回<code class="fe nm nn no mp b">wrapper_func</code>。</li><li id="f5a4" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated"><code class="fe nm nn no mp b">orig_func</code>由<code class="fe nm nn no mp b">decor_func</code>装饰。</li></ul><p id="8c2a" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">让我们看看它是如何工作的。</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="b449" class="mt lb iu mp b gz mu mv l mw mx">orig_func (7,9,11)</span></pre><p id="9873" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">输出如下所示:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="417d" class="mt lb iu mp b gz mu mv l mw mx">This is the product: 693</span></pre><p id="cf9b" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">现在，我想在不改变上述功能的情况下添加一些功能。所以我使用了一个装饰函数，它包含一个包装函数，这个包装函数有一些代码，并且是用原始函数执行的。</p><ul class=""><li id="af00" class="my mz iu lu b lv nq ly nr mb ns mf nt mj nu mn nd ne nf ng bi translated">函数是对象。</li><li id="7982" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">函数可以在函数中定义。</li><li id="0d07" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">函数可以分配给一个变量。</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="1bb5" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">您可以通过以下方式调用装饰函数</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="f24c" class="mt lb iu mp b gz mu mv l mw mx">orig_func=decor_func(orig_func)</span></pre><p id="cbcc" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">或者</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="9f47" class="mt lb iu mp b gz mu mv l mw mx">@decor_func</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/a634e6ddbfac08b27106b39d0bd98127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZ358IMJW5kS5lEEhVDMvQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="1200" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated"><code class="fe nm nn no mp b">orig_func=decor_func(orig_func)</code>或<code class="fe nm nn no mp b">@decor_func</code>运行<code class="fe nm nn no mp b">decor_func</code>中的<code class="fe nm nn no mp b">wrapper_func</code>。</p><p id="c9d5" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">当我执行上述代码时，输出如下:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="d8c7" class="mt lb iu mp b gz mu mv l mw mx">Execute this code before the main function is executed.<br/>This is the product: 693</span></pre><p id="33cd" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">现在你可以理解Python装饰器是如何工作的了。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oc"><img src="../Images/ce3ccb8027cfe37829ef1a72cf3496aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjCM9Jiq4gIFB-1bB-leeQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="15a6" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">现在你知道一个基本的室内设计师是如何工作的了。我们可以探索装饰者的一些额外的概念。</p><h1 id="81cf" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">调试-修复函数名和文档字符串</h1><p id="f062" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">如果你在原函数上做<code class="fe nm nn no mp b">help</code>，看起来是这样的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="e5a3" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">它给出了以下内容:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="1870" class="mt lb iu mp b gz mu mv l mw mx">Help on function wrapper_func in module __main__: <br/>    wrapper_func(*args, **kwargs) <br/>    This is the wrapper function</span></pre><p id="57d2" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">这显示了包装函数的docstring。它应该显示原始函数名和文档字符串。</p><p id="5277" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">我们可以通过以下解决方法实现这一点:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="76a7" class="mt lb iu mp b gz mu mv l mw mx">dir(orig_func)</span></pre><p id="761a" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">Python函数中包含以下属性:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="f233" class="mt lb iu mp b gz mu mv l mw mx">[‘__annotations__’, ‘__call__’, ‘__class__’, ‘__closure__’, ‘__code__’, ‘__defaults__’, ‘__delattr__’, ‘__dict__’, ‘__dir__’, ‘__doc__’, ‘__eq__’, ‘__format__’, ‘__ge__’, ‘__get__’, ‘__getattribute__’, ‘__globals__’, ‘__gt__’, ‘__hash__’, ‘__init__’, ‘__init_subclass__’, ‘__kwdefaults__’, ‘__le__’, ‘__lt__’, ‘__module__’, ‘__name__’, ‘__ne__’, ‘__new__’, ‘__qualname__’, ‘__reduce__’, ‘__reduce_ex__’, ‘__repr__’, ‘__setattr__’, ‘__sizeof__’, ‘__str__’, ‘__subclasshook__’]</span></pre><p id="8c5f" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">您可以将函数赋给变量，并显示名称和文档字符串。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="502f" class="mt lb iu mp b gz mu mv l mw mx">orig_func <br/>returns the product of a,b,c</span></pre><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="55bf" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">或者</p><p id="3774" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">我们可以使用<code class="fe nm nn no mp b">functools</code>模块中的包装。它是一个函数装饰器，将<code class="fe nm nn no mp b">update_wrapper()</code>应用于被装饰的函数。将<code class="fe nm nn no mp b">functools.wraps</code>应用到装饰器返回的包装器中，会携带输入函数<code class="fe nm nn no mp b">orig_func</code>的docstring和其他元数据。Python 2.5中引入了<code class="fe nm nn no mp b">functools</code>模块。它包括函数，该函数将修饰函数的名称、模块和文档字符串复制到其包装器中。我们可以按如下方式更改代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><h1 id="5843" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">嵌套装饰器</h1><p id="cd06" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">我们还可以有多个装饰器，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="525c" class="mt lb iu mp b gz mu mv l mw mx">This is the first decorator<br/>This is the second decorator<br/>Nested Decorators</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj od"><img src="../Images/07403951540d05ba8e428a5762a47294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kv8RpoB2av6Yx54iwh4oGA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><h1 id="62de" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">将参数传递给装饰者</h1><p id="1490" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">您还可以将参数传递给装饰器，以便在代码中使用。</p><p id="b627" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">举个例子，</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="8e2a" class="mt lb iu mp b gz mu mv l mw mx">orig_func(7,9,11)</span></pre><p id="8947" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">上面的输出如下所示:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="a405" class="mt lb iu mp b gz mu mv l mw mx">Flag is False <br/>This is the product: 693</span></pre><p id="4358" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">让我们来看看这是如何工作的:</p><ul class=""><li id="c7cc" class="my mz iu lu b lv nq ly nr mb ns mf nt mj nu mn nd ne nf ng bi translated"><code class="fe nm nn no mp b">decor_factory</code>函数不是装饰函数。相反，它在被调用时返回一个装饰器。</li><li id="3d78" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">传递给<code class="fe nm nn no mp b">decor_factory</code>的任何参数都可以在函数decor中引用(作为自由变量)。</li><li id="93b4" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated"><code class="fe nm nn no mp b">decor_factory</code>函数是一个装饰工厂函数。它是一个函数，每次被调用时都会创建一个新的装饰器。</li><li id="7901" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">在这种情况下，<code class="fe nm nn no mp b">decor_factory</code>返回装饰功能。<code class="fe nm nn no mp b">deco</code>函数是真正的装饰器，它将<code class="fe nm nn no mp b">function(fn)</code>作为它的参数。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/0975cf1df5577a781888a3f142220580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jj6qGgYiPC1l4p-kYlGyOA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><h1 id="9e8c" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">向函数传递参数</h1><p id="65c2" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">我们可以将参数传递给装饰包装函数，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="4722" class="mt lb iu mp b gz mu mv l mw mx">Arguments are passed: San Jose , California<br/>My city is San Jose <br/>My State is California</span></pre><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="d004" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">如果你正在制作一个通用的装饰器——一个你可以应用于任何函数或方法的装饰器——那么就使用<code class="fe nm nn no mp b">*args, **kwargs</code></p><h1 id="3fc1" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">@记录的装饰者</h1><p id="5a6f" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">尝试创建一个日志，就像函数被调用时使用的函数名等。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="508b" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">输出如下所示:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="049f" class="mt lb iu mp b gz mu mv l mw mx">The product of a*b*c: 90 <br/>product: called 2022–01–16 04:41:50.483630+00:00</span></pre><h1 id="93e8" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">@时间装饰者</h1><p id="b33b" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">创建一个装饰器来计算函数执行的时间。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="5b30" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">输出如下所示:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="d29b" class="mt lb iu mp b gz mu mv l mw mx">The product of a*b*c: 90 <br/>product ran for 0.001004s</span></pre><p id="c5e8" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">也可以把日志和时间一起调用。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="9410" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">输出如下所示:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="273a" class="mt lb iu mp b gz mu mv l mw mx">The product of a*b*c: 90 <br/>product ran for 0.000092s <br/>product: called 2022–01–16 04:59:14.443023+00:00</span></pre><h1 id="fab8" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">@functools.lru_cache(Memoize)</h1><ul class=""><li id="233f" class="my mz iu lu b lv lw ly lz mb na mf nb mj nc mn nd ne nf ng bi translated"><code class="fe nm nn no mp b">@lru_cache</code> decorator，它让你能够使用<strong class="lu iv">最近最少使用(LRU)策略</strong>缓存函数的结果。它使用捕捉技术。<code class="fe nm nn no mp b">lru</code>代表“最近最少使用的”更多信息，请查看以下<a class="ae kz" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank">链接</a>。</li><li id="f222" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">使用<code class="fe nm nn no mp b">@lru_cache decorator.</code>可以提高性能</li><li id="db46" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">捕捉可以通过使用字典来实现。</li><li id="dd1f" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">记忆是缓存的一种形式。我们缓存以前计算的阶乘数，这样我们就不必再计算它们了。</li></ul><p id="faee" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">以下是一些例子:</p><h1 id="5257" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated"><strong class="ak">无缓存</strong></h1><p id="77c5" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">这里我们创建了一个阶乘函数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="d114" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">输出如下所示:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="5892" class="mt lb iu mp b gz mu mv l mw mx">Factor5!<br/>Factor4!<br/>Factor3!<br/>Factor2!<br/>Factor1!<br/>120</span></pre><p id="3890" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">如果我尝试<code class="fe nm nn no mp b">factor 7</code>，那么输出是</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="d912" class="mt lb iu mp b gz mu mv l mw mx">factor(7)</span></pre><p id="f7c8" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">详细的输出如下:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="b994" class="mt lb iu mp b gz mu mv l mw mx">Factor7!<br/>Factor6!<br/>Factor5!<br/>Factor4!<br/>Factor3!<br/>Factor2!<br/>Factor1!<br/>5040</span></pre><h1 id="d250" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated"><strong class="ak">带缓存</strong></h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="dd9a" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">现在我们使用的<code class="fe nm nn no mp b">@lru_cache.Functools.cache</code>是从Python 3.9中获得的。3.9之前，使用<code class="fe nm nn no mp b"> @lru_cache</code>。</p><p id="2444" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated"><code class="fe nm nn no mp b">@lru_cache</code>有一个<code class="fe nm nn no mp b">maxsize</code>参数，它的默认值是128——这意味着缓存在任何时候最多可以容纳128个条目。首字母缩写词LRU代表“最近最少使用”，这意味着一段时间没有被阅读的旧条目将被丢弃，以便为新条目腾出空间。</p><p id="3cad" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated"><code class="fe nm nn no mp b">factor(5)</code>的输出如下:</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="6aa2" class="mt lb iu mp b gz mu mv l mw mx">Factor5!<br/>Factor4!<br/>Factor3!<br/>Factor2!<br/>Factor1!<br/>120</span></pre><p id="bd85" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">如果运行<code class="fe nm nn no mp b">factor 6</code> — <code class="fe nm nn no mp b">factor(6)</code>的函数，那么输出将是</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="4161" class="mt lb iu mp b gz mu mv l mw mx">Factor6!<br/>720</span></pre><p id="559e" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">如您所见，对于缓存，它使用缓存中的因子1到因子5，并且只计算缓存6。</p><p id="d760" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">如果您尝试使用因子4，则输出为</p><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="70c8" class="mt lb iu mp b gz mu mv l mw mx">24</span></pre><p id="4df1" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">在这种情况下，所有都是从缓存中选择的。</p><p id="e274" class="pw-post-body-paragraph ls lt iu lu b lv nq jv lx ly nr jy ma mb ny md me mf nz mh mi mj oa ml mm mn in bi translated">所以<code class="fe nm nn no mp b">@lru_cache</code>提高了性能。您还可以使用<code class="fe nm nn no mp b">@time</code>装饰器来捕获<code class="fe nm nn no mp b">time-end-start</code>。</p><h1 id="b885" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">装修工的使用</h1><ul class=""><li id="644b" class="my mz iu lu b lv lw ly lz mb na mf nb mj nc mn nd ne nf ng bi translated">访问控制和验证。</li><li id="ea70" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">伐木。</li><li id="a363" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">时机。</li><li id="a960" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">缓存。</li><li id="2f65" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">不想改变源函数。</li><li id="15fd" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated">尝试重用可能失败的功能。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/1867ab8edbb2f570707cfeb70628007f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fhktv6PAR5a0R6lmNLutDw.jpeg"/></div></div></figure><h1 id="218c" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">内置Python装饰器</h1><p id="3c1a" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">下面是一些重要的Python内置装饰器:</p><ul class=""><li id="5147" class="my mz iu lu b lv nq ly nr mb ns mf nt mj nu mn nd ne nf ng bi translated"><code class="fe nm nn no mp b"><a class="ae kz" href="https://docs.python.org/3.5/library/functools.html#functools.wraps" rel="noopener ugc nofollow" target="_blank">@functools.wraps</a> </code>这是一个在定义包装函数时调用<code class="fe nm nn no mp b">update_wrapper()</code>作为函数装饰器的方便函数。</li><li id="0e4c" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated"><code class="fe nm nn no mp b"><a class="ae kz" href="https://docs.python.org/3.5/library/functools.html#functools.lru_cache" rel="noopener ugc nofollow" target="_blank">@functools.lru_cache</a></code> Decorator用一个记忆的可调用函数来包装一个函数，这个函数可以保存最近的调用。它可以节省时间，当一个昂贵的或I/O绑定的函数，它是定期调用相同的参数。</li><li id="d9a6" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated"><code class="fe nm nn no mp b"><a class="ae kz" href="https://docs.python.org/2.7/library/atexit.html#atexit.register" rel="noopener ugc nofollow" target="_blank">@atexit.register</a></code>将func注册为终止时执行的函数。</li><li id="2f2b" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated"><code class="fe nm nn no mp b"><a class="ae kz" href="https://docs.python.org/3.5/library/functions.html#classmethod" rel="noopener ugc nofollow" target="_blank">@classmethod</a></code>返回函数的类方法。</li><li id="c448" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nd ne nf ng bi translated"><code class="fe nm nn no mp b"><a class="ae kz" href="https://docs.python.org/3.5/library/functions.html#property" rel="noopener ugc nofollow" target="_blank">@property</a></code>返回一个属性。</li></ul><h1 id="6307" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">结论</h1><p id="b057" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">正如您所看到的，Python decorators更加强大，可以在很多场景中使用。也许你可以创建自己的装饰器，并使用上述概念。</p><h1 id="19ad" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">参考</h1><ol class=""><li id="7873" class="my mz iu lu b lv lw ly lz mb na mf nb mj nc mn nv ne nf ng bi translated"><a class="ae kz" href="https://gist.github.com/Zearin/2f40b7b9cfc51132851a" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Zearin/2f40b7b9cfc51132851a</a></li><li id="a637" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nv ne nf ng bi translated"><a class="ae kz" href="https://github.com/chiphuyen/python-is-cool" rel="noopener ugc nofollow" target="_blank">https://github.com/chiphuyen/python-is-cool</a></li><li id="c86d" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nv ne nf ng bi translated"><a class="ae kz" href="https://github.com/lord63/awesome-python-decorator" rel="noopener ugc nofollow" target="_blank">https://github.com/lord63/awesome-python-decorator</a></li><li id="d278" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nv ne nf ng bi translated"><a class="ae kz" href="https://www.python.org/dev/peps/pep-0318/" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/pep-0318/</a></li><li id="35d8" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nv ne nf ng bi translated"><a class="ae kz" href="https://www.python.org/dev/peps/pep-3129/" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/pep-3129/</a></li><li id="ccb6" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nv ne nf ng bi translated"><a class="ae kz" href="https://wiki.python.org/moin/PythonDecorators" rel="noopener ugc nofollow" target="_blank">https://wiki.python.org/moin/PythonDecorators</a></li><li id="fa9e" class="my mz iu lu b lv nh ly ni mb nj mf nk mj nl mn nv ne nf ng bi translated"><a class="ae kz" href="https://wiki.python.org/moin/PythonDecoratorLibrary" rel="noopener ugc nofollow" target="_blank">https://wiki.python.org/moin/PythonDecoratorLibrary</a></li></ol></div><div class="ab cl of og hy oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="in io ip iq ir"><pre class="kk kl km kn gu mo mp mq mr aw ms bi"><span id="db1a" class="mt lb iu mp b gz mu mv l mw mx"><strong class="mp iv">Want to Connect?</strong></span><span id="34f2" class="mt lb iu mp b gz om mv l mw mx">Please feel free to connect with me on <a class="ae kz" href="http://linkedin.com/in/esenthil" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></span></pre></div></div>    
</body>
</html>