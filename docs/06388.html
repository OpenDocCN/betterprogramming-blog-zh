<html>
<head>
<title>The Modulo Operation (%) With Negative Numbers in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中负数的模运算(%)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modulo-operation-with-negative-numbers-in-python-38cb7256bb32?source=collection_archive---------1-----------------------#2020-09-28">https://betterprogramming.pub/modulo-operation-with-negative-numbers-in-python-38cb7256bb32?source=collection_archive---------1-----------------------#2020-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ce9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你有没有想过它是如何工作的？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/495c3347a2b134f4580500407daaadca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6no9GqwBUive5yycH-J9oA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="4a92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我最近学到的东西，我认为值得分享，因为它让我很惊讶，这是一个非常有用的学习事实。Python如何处理负数的取模运算？所以，让我们长话短说，直奔主题。</p><blockquote class="lu"><p id="e0fb" class="lv lw it bd lx ly lz ma mb mc md lt dk translated">“Python中的<code class="fe me mf mg mh b">%</code>符号被称为模运算符。它返回左操作数除以右操作数的余数。它用来得到除法问题的余数。”——<em class="mi"/><a class="ae mj" href="http://www.freecodecamp.org" rel="noopener ugc nofollow" target="_blank">freeCodeCamp</a></p></blockquote><p id="a67b" class="pw-post-body-paragraph ky kz it la b lb mk ju ld le ml jx lg lh mm lj lk ll mn ln lo lp mo lr ls lt im bi translated">基本语法是:</p><ul class=""><li id="b675" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my"> a % b = r </em></li></ul><p id="6571" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上例中，<em class="my"> a </em>除以<em class="my"> b </em>，返回<em class="my"> r </em>(即余数)。现在让我们看一个数字的例子:</p><ul class=""><li id="2798" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my"> 7 % 2 = 1 </em></li></ul><p id="d204" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上例的结果是<em class="my"> 1 </em>。<em class="my"> 2 </em>三次进入<em class="my"> 7 </em>还剩<em class="my"> 1 </em>。同样，如果我们选择两个数字，其中<em class="my"> b &gt; a </em>，我们将得到以下结果:</p><ul class=""><li id="7147" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated">3 % 4 = 3</li></ul><p id="956c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这会导致<em class="my"> 3 </em>因为<em class="my"> 4 </em>在任何时候都不会进入<em class="my"> 3 </em>，所以原来的<em class="my"> 3 </em>仍然存在。</p><p id="5479" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模运算符的兄弟称为整数除法运算(<code class="fe me mf mg mh b">//</code>)，其中小数部分(即余数)被丢弃。举以下例子:</p><ul class=""><li id="998b" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my"> 5 // 2 = 2 </em></li></ul><p id="9a2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于正数，没有什么好惊讶的。然而，如果其中一个操作数为负，结果也将被floored(即从<em class="my"> 0 </em>向负无穷大舍入)，返回小于或等于<em class="my"> x </em>的最大整数。例如:</p><ul class=""><li id="db93" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my"> -5 // 2 = -3 </em></li></ul><p id="4706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，有几种方法来执行这个操作。与C或C++不同，Python的模运算符总是返回一个与分母(除数)符号相同的数字，因此后面的等式如下:</p><ul class=""><li id="9060" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my">mod = a—math . floor(a/b)* base</em></li></ul><p id="ba41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，使用我们之前的一个示例，我们会得到:</p><ul class=""><li id="ec73" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my">mod = 7—math . floor(7/2)* 2</em></li><li id="483f" class="mp mq it la b lb mz le na lh nb ll nc lp nd lt mu mv mw mx bi translated"><em class="my">mod = 7–3 * 2 = 1</em></li></ul><p id="84c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并且整体逻辑根据以下前提工作:</p><ul class=""><li id="57bc" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my"> a/b = q </em>带余数<em class="my"> r </em></li><li id="17e4" class="mp mq it la b lb mz le na lh nb ll nc lp nd lt mu mv mw mx bi translated">使得:<em class="my"> b*q + r = a </em>和<em class="my"> 0 &lt; = r &lt; b </em></li></ul><p id="821f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们想让这种关系扩展到负数，有几种方法可以处理这种情况。根据<a class="ae mj" href="http://en.wikipedia.org/wiki/Modulo_operation" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，在数学数论中，数学家们更喜欢遵循负无穷大的下限，如下例所示:</p><ul class=""><li id="6efb" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my"> -500/27 = -18.51 </em></li><li id="8c1e" class="mp mq it la b lb mz le na lh nb ll nc lp nd lt mu mv mw mx bi translated"><em class="my"> math.floor(-500/27) = -19 </em></li></ul><p id="80c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python遵循同样的逻辑。为什么？根据Python的创始人吉多·范·罗苏姆的说法，这个标准有一些有趣的应用。例如，考虑获取一个POSIX时间戳(从1970年开始的秒数)并将其转换为一天中的时间。由于一天有<em class="my">24 * 3600 = 86400</em>秒，所以这个计算简单来说就是<em class="my">t % 86400</em>。但是，如果我们用负数来表示1970年以前的时间，那么使用其他标准会给出一个没有意义的结果，而使用下限规则就可以了。</p><p id="fe76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，在处理负数时，请考虑以下几点:</p><ul class=""><li id="e419" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated">如果<em class="my"> a &lt; 0 </em>那么<em class="my"> 0 &lt; = r &lt; b </em>保持不变。</li><li id="32b2" class="mp mq it la b lb mz le na lh nb ll nc lp nd lt mu mv mw mx bi translated">但是如果<em class="my"> b &lt; 0 </em>那么<em class="my"> 0 &gt; = r &gt; b </em>。</li></ul><p id="189d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们来看一个<em class="my"> a = -500 </em>和<em class="my"> b = 12 </em>的快速例子:</p><ul class=""><li id="73e9" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my"> -500/12 = -41.67 </em></li><li id="4c2d" class="mp mq it la b lb mz le na lh nb ll nc lp nd lt mu mv mw mx bi translated"><em class="my"> -500 % 12 = 4 </em></li><li id="ab63" class="mp mq it la b lb mz le na lh nb ll nc lp nd lt mu mv mw mx bi translated"><em class="my"> -500 // 12 = -42 </em></li></ul><p id="efa2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们可以检查<em class="my"> b*q + r = a </em>:</p><ul class=""><li id="d436" class="mp mq it la b lb lc le lf lh mr ll ms lp mt lt mu mv mw mx bi translated"><em class="my"> 12 * -42 + 4 = -500 </em></li></ul><p id="054c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章的最后，让我们来看看负数模运算符的一个有趣的应用:将24小时制中的一个小时转换成12小时制。这个挑战看起来很简单，对吗？例如，<em class="my"> 23%2 </em>会给我们<em class="my"> 11 </em>而<em class="my"> 15%12 </em>会给我们<em class="my"> 3 </em> …正是我们想要的！现在，当我们点击数字<em class="my"> 12 </em>时，情节变得复杂了，因为<em class="my"> 12%12 </em>将给出<em class="my"> 0 </em>，这是午夜而不是中午。</p><p id="708c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的解决方案是对负数使用模运算符。比如<em class="my"> -22%12 </em>会给我们<em class="my"> 2 </em>和<em class="my"> -19/12 </em>会给我们<em class="my"> 5 </em>。根据经验，这种运算总会告诉我们，在下一个分母的倍数到来之前，我们还剩多少个单位。在我们的第一个例子中，我们在<em class="my"> 12x2 </em>之前缺少两个小时，以类似的方式，<em class="my"> -34%12 </em>也会给我们<em class="my"> 2 </em>，因为在<em class="my"> 12x3 </em>之前我们还有两个小时。</p><p id="027a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，回到我们最初的挑战，即将24小时制的一个小时转换成12小时制，我们可以写如下:</p><pre class="kj kk kl km gt ne mh nf ng aw nh bi"><span id="3f1f" class="ni nj it mh b gy nk nl l nm nn">def convert24to12(hour):</span><span id="6601" class="ni nj it mh b gy no nl l nm nn">return 12 — ((- hour) % 12)</span></pre><p id="2105" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天到此为止。别忘了看看我关于更好编程的其他一些故事:</p><div class="np nq gp gr nr ns"><a href="https://medium.com/better-programming/facing-a-classification-project-in-machine-learning-462b319873de" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">面对机器学习中的分类项目</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">温和的逐步指导</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://medium.com/better-programming/how-to-divide-data-into-train-and-test-assuring-representativeness-c4c12c215d79" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">使用随机森林将数据分成训练和测试以保证代表性</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">使用Python和Sklearn</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og ks ns"/></div></div></a></div><p id="f5f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而我<strong class="la iu">如果你想直接在你的邮箱里收到我的最新文章，只需</strong> <a class="ae mj" href="https://gmail.us3.list-manage.com/subscribe?u=8190cded0d5e26657d9bc54d7&amp;id=3e942158a2" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">订阅我的简讯</strong> </a> <strong class="la iu">:)。</strong>再见，感谢阅读！感谢阅读！</p></div></div>    
</body>
</html>