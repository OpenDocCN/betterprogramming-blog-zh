<html>
<head>
<title>Map vs. FlatMap vs. CompactMap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地图与平面地图与压缩地图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/map-vs-flatmap-vs-compactmap-c75f66b904a6?source=collection_archive---------2-----------------------#2019-11-01">https://betterprogramming.pub/map-vs-flatmap-vs-compactmap-c75f66b904a6?source=collection_archive---------2-----------------------#2019-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="55aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较这些功能以及何时使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/006b867e691dd70cfd8ee38f47f62f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*umzrRZbhyFMlE8xMh6sHNw.png"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="659c" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">地图</h1><p id="24ea" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">所以，让我们假设你需要将一个整数数组转换成一个字符串数组。您可以创建自己的简单解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">自定义地图示例</p></figure><p id="a347" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">它达到了预定的目标，但是如果你能改进它呢？</p><p id="52eb" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">此时，您做了一个简单的从一种类型到另一种类型的映射。Swift有一套高阶函数帮助您转换数据。</p><p id="b295" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">让我们修改代码，使用一个<code class="fe ml mm mn mo b">map</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">地图示例</p></figure><p id="17c7" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">你看到这种力量了吗？超级简洁易懂。它接受您的转换闭包，并将其应用于数组的每个成员。</p><p id="a14f" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">现在我们可以对<code class="fe ml mm mn mo b">map</code>函数有一个定义了:</p><p id="4670" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">Map返回一个数组，其中包含将给定闭包映射到序列元素的结果。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="5a8b" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">紧凑地图</h1><p id="29e1" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">那<code class="fe ml mm mn mo b">compactMap</code>呢？要理解它，你需要玩弄它。</p><p id="fb04" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">假设我们的<code class="fe ml mm mn mo b">arrayOfIntegers</code> <strong class="lr iu"> </strong>常量有一些<code class="fe ml mm mn mo b">nil</code>值，你不希望它们被映射到相应的字符串，而是忽略它们。</p><p id="77e3" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">首先想到，它也是一个映射，所以我使用的是<code class="fe ml mm mn mo b">map</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">错误的地图示例</p></figure><p id="4128" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">编译器不喜欢它，并警告您:</p><pre class="kj kk kl km gt na mo nb nc aw nd bi"><span id="2cfe" class="ne ky it mo b gy nf ng l nh ni">String interpolation produces a debug description for an optional value; did you mean to make this explicit?</span></pre><p id="fc1f" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">您可以使用<code class="fe ml mm mn mo b">String</code>初始化器<code class="fe ml mm mn mo b">“\(String(describing: $0))”</code>来包装它，但是这只会消除警告，您的最终结果将是<code class="fe ml mm mn mo b">[“Optional(1)”, “Optional(2)”, “nil”, “Optional(4)”]</code></p><p id="7abd" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">嗯，这不是你想要的…你可能会想:“哦，我可以使用我的自定义映射函数，检查它是否是<code class="fe ml mm mn mo b">nil</code>。”</p><p id="845c" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">是的，你可以做到这一点，它将完美地工作，但Swift知道如何帮助你，这里有<code class="fe ml mm mn mo b">compactMap</code> <strong class="lr iu"> </strong>结合我们以前学习的<code class="fe ml mm mn mo b">map</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">带链接的压缩映射示例</p></figure><p id="995d" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">这里有两个步骤:</p><ul class=""><li id="4728" class="nj nk it lr b ls mv lv mw ly nl mc nm mg nn mk no np nq nr bi translated"><code class="fe ml mm mn mo b">compactMap</code>清理序列，因此，你得到一个非可选的整数序列。</li><li id="65d3" class="nj nk it lr b ls ns lv nt ly nu mc nv mg nw mk no np nq nr bi translated"><code class="fe ml mm mn mo b">map</code>将其转换成字符串。</li></ul><p id="7a2f" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">没有<code class="fe ml mm mn mo b">map</code>也能做到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">带有过滤示例的压缩映射</p></figure><p id="aebd" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated"><code class="fe ml mm mn mo b">compactMap</code>帮助您同时消除零值和映射。它接受你的序列并产生一个更好的序列。虽然简单。</p><p id="000d" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">这里是<code class="fe ml mm mn mo b">compactMap</code>的定义。</p><p id="0afc" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated"><code class="fe ml mm mn mo b">compactMap</code>返回一个数组，该数组包含用此序列的每个元素调用给定转换的非零结果。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="a6e1" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">平面地图</h1><p id="ad24" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们旅程的最后一部分是<code class="fe ml mm mn mo b">flatMap</code>。这只怪兽可能比<code class="fe ml mm mn mo b">map</code>或<code class="fe ml mm mn mo b">compactMap</code>更难理解，但它不是火箭科学。</p><p id="fa28" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">想象我们的<code class="fe ml mm mn mo b">arrayOfIntegers</code>正在增长，你需要以某种方式构建它。你以一种由奇数和偶数数组组成的方式构造了它。</p><p id="b50f" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">你的任务是将它映射到一个没有零值的数组中。</p><pre class="kj kk kl km gt na mo nb nc aw nd bi"><span id="13da" class="ne ky it mo b gy nf ng l nh ni">let arrayOfIntegers = [[1,3,5,nil],[2,nil,6]]</span></pre><p id="b9bd" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">哦，你可能觉得这越来越难了，但是别担心，我们也会解决的。</p><p id="7c6a" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">您已经知道如何删除零值。用<code class="fe ml mm mn mo b">compactMap</code>就可以了，但是这个数组数组……<code class="fe ml mm mn mo b">flatMap</code>来救援呢！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">平面图示例</p></figure><p id="3cc2" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">同样，要理解这一点有两个步骤:</p><ul class=""><li id="0e6c" class="nj nk it lr b ls mv lv mw ly nl mc nm mg nn mk no np nq nr bi translated">平坦化你的阵列。申请<code class="fe ml mm mn mo b">.flatMap { $0 }</code>后，收到<code class="fe ml mm mn mo b">“[Optional(1), Optional(3), Optional(5), nil, Optional(2), nil, Optional(6)]”</code>。</li><li id="11a6" class="nj nk it lr b ls ns lv nt ly nu mc nv mg nw mk no np nq nr bi translated"><code class="fe ml mm mn mo b">compactMap</code>删除零值，从而得到最终结果<code class="fe ml mm mn mo b">[1, 3, 5, 2, 6]</code>。</li></ul><p id="72e0" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">这里是<code class="fe ml mm mn mo b">flatMap</code>的定义。</p><p id="e7fe" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated"><code class="fe ml mm mn mo b">flatMap</code>返回一个数组，该数组包含用此序列的每个元素调用给定转换的连接结果。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="0322" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">结论</h1><p id="d105" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">高阶函数还有很多其他的用例。这是我们今天发现的要点:</p><ul class=""><li id="58fa" class="nj nk it lr b ls mv lv mw ly nl mc nm mg nn mk no np nq nr bi translated">如果您需要简单地将一个值转换成另一个值，那么使用<code class="fe ml mm mn mo b">map</code>。</li><li id="99d7" class="nj nk it lr b ls ns lv nt ly nu mc nv mg nw mk no np nq nr bi translated">如果需要删除零值，则使用<code class="fe ml mm mn mo b">compactMap</code>。</li><li id="dea1" class="nj nk it lr b ls ns lv nt ly nu mc nv mg nw mk no np nq nr bi translated">如果您需要将结果向下拉平一级，则使用<code class="fe ml mm mn mo b">flatMap</code>。</li><li id="00e5" class="nj nk it lr b ls ns lv nt ly nu mc nv mg nw mk no np nq nr bi translated">也可以将这些功能串联起来，以达到预期的效果。</li></ul><p id="be78" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">这里有一个<a class="ae nx" href="https://github.com/Cr1xus/higher-order-functions" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>和<code class="fe ml mm mn mo b">.playground</code>文件。</p><p id="e4cc" class="pw-post-body-paragraph lp lq it lr b ls mv ju lu lv mw jx lx ly mx ma mb mc my me mf mg mz mi mj mk im bi translated">感谢您的关注和时间！</p></div></div>    
</body>
</html>