<html>
<head>
<title>The Power of the Observer Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中观察者模式的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-observer-pattern-in-javascript-4f4e0b908d5e?source=collection_archive---------2-----------------------#2019-10-06">https://betterprogramming.pub/the-observer-pattern-in-javascript-4f4e0b908d5e?source=collection_archive---------2-----------------------#2019-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建立一个车管所售票系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b55b7e9c4a9c754cd2a2ae45bfdd3b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUItmMX1gdBLya0AwsIW_Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">照片由阿迪·戈尔茨坦在Unsplash上拍摄</em></p></figure><p id="0603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将回顾观察者模式<em class="lv"> </em>，并用JavaScript实现它，这样，希望你能更好地理解它，尤其是如果你在理解这个概念上有困难的话。</p><p id="a1df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察者模式仍然是设计解耦系统的最佳实践之一，应该是任何JavaScript开发人员的重要工具。</p><p id="97ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察者模式是一种设计模式，在这种模式中，主体(仅仅是带有方法的<em class="lv">对象</em>)维护一个观察者列表，这些观察者已经<em class="lv">注册</em>以获得即将到来的消息的通知。</p><p id="4b06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当他们收到关于他们所关注主题的通知事件时，他们可以利用这些机会做一些有用的事情，这取决于从他们那里收到了什么。</p><p id="501e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要多个对象在最近状态变化的同时得到通知时，该模式非常有用。因此，当您需要多个对象来维护整个应用程序的一致性时，这种模式的威力就显现出来了，而不是使用紧密耦合的类。</p><p id="5474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，甚至有可能让几个彼此不直接相关的对象同时保持一致。</p><p id="e64d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察器可以在被附加后移除自己，因此甚至可以灵活地选择一个观察器和下一个观察器的进出，反之亦然。</p><p id="9d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将所有这些功能组合在一起时，您就可以在主体和观察者之间建立动态关系，从而构成健壮的功能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fe1a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">这个概念</h1><p id="7943" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当观察者关注对象的状态并希望选择加入观察<em class="lv"> </em>即将到来的状态更新时，他们可以注册或连接到它们以接收即将到来的信息。</p><p id="34e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当发生变化时，这些观察者将能够得到通知，包括之后的更新。这是在主体使用广播方法向其附属的观察者发送通知消息时完成的。</p><p id="e027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些通知消息中的每一个都可以包含对接收它们的一个或多个观察者有用的数据。通知消息被发送的方式通常调用一个<code class="fe na nb nc nd b">notify</code>方法来遍历它的观察器列表，在每个循环中，它将调用一个观察器的<code class="fe na nb nc nd b">update</code>方法。</p><p id="83b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当观察者不再希望与主体相关联时，他们可以被分离。</p><p id="aa86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个简短而精确的表格，其中列出了构成这种模式的所有常见参与者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="447d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看看这在代码中会是什么样子。</p><p id="f549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的第一件事是开始创建subject，它将拥有一个管理其观察者的接口。为此，我们实际上要在一个名为<code class="fe na nb nc nd b">ObserversList</code>的独立函数上定义构造函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将这个接口直接附加到一个主题的属性上:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="8efe" class="nk me it nd b gy nl nm l nn no">function Subject() {<br/>  this.observers = new ObserversList()<br/>}</span></pre><p id="6c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以直接在subject上定义原型方法，但我们没有这样做的原因是因为subject通常是真实用例中的任意实例，只需要继承observer接口，然后可能扩展其功能或围绕它们创建包装器。</p><p id="c8e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将继续定义<code class="fe na nb nc nd b">Observer</code>:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="125a" class="nk me it nd b gy nl nm l nn no">function Observer() {<br/>  this.update = function() {}<br/>}</span></pre><p id="f139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当不同的对象继承了<code class="fe na nb nc nd b">Observer</code>时，通常会发生的是它们覆盖了对它们所寻找的数据感兴趣的<code class="fe na nb nc nd b">update</code>(或更新器)函数。</p><p id="3be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为，当主体调用它的<code class="fe na nb nc nd b">notifyAll</code>方法时，观察者的更新函数会在每个循环中使用。</p><p id="9f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在实践中看到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1d53" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">真实世界的例子</h1><p id="00a5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在让我们来看一个真实世界的例子。</p><p id="4041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在<code class="fe na nb nc nd b">Alhambra</code>位置操作<a class="ae np" href="https://www.dmv.ca.gov/" rel="noopener ugc nofollow" target="_blank"> DMV </a>。我们将使用观察者模式实现票务呼叫系统。</p><p id="19e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在车管所典型的售票系统中，当人们被放入等候名单时，通常会得到一个票号，他们会一直等到自己的号码被叫到。</p><p id="0f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就在他们拿到票号之前，车管所会检查是否已经有空位，然后再交给他们。如果没有空位，他们就会被安排到等候名单上，并有指定的票号。</p><p id="4423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个人完成了他们在展台的会议，让我们假装他们完成了一天的工作。这是指他们的机票号码不再使用，以后可以再次使用。</p><p id="5588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例中，我们将把票号标记为立即可用，以分配给将被放入等待列表的其他人。</p><p id="8437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的第一件事是定义<code class="fe na nb nc nd b">DMV</code>构造函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="482d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，<code class="fe na nb nc nd b">DMV</code>是<code class="fe na nb nc nd b">subject</code>，因为它将管理一个人员和票号列表。</p><p id="ab36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们设置了一个<code class="fe na nb nc nd b">maxTicketsToProcess</code>参数，因为没有它，等待列表将总是空的，因为我们没有办法知道何时将一个人放入等待列表是合适的。</p><p id="32c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当到达<code class="fe na nb nc nd b">maxTicketsToProcess</code>时，如果在<code class="fe na nb nc nd b">this.ticketsFree</code>还有票，我们将开始把人们放入有票号的等候名单中。</p><p id="df76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们看一下<code class="fe na nb nc nd b">DMV</code>构造函数时，它给<code class="fe na nb nc nd b">this.waitingList</code>分配了一个<code class="fe na nb nc nd b">WaitingList</code>实例。这个<code class="fe na nb nc nd b">WaitingList</code>基本上就是<code class="fe na nb nc nd b">ObserversList</code>，因为它提供了一个几乎相同的界面来管理它的人员列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">broadcastNext</code>相当于<code class="fe na nb nc nd b">ObserversList</code>示例中的<code class="fe na nb nc nd b">notifyAll</code>方法。然而，我们没有调用<code class="fe na nb nc nd b">.update</code>，而是调用了在<code class="fe na nb nc nd b">person</code>实例上定义的<code class="fe na nb nc nd b">.notifyTicket</code>(稍后我们会看到)。</p><p id="f15a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们提供了一个<code class="fe na nb nc nd b">accept</code>回调函数作为第二个参数，因为这将模拟现实生活中的场景，当一个人看着他们的票号，意识到分配给他们的号码正在被调用，并走向他们的摊位。</p><p id="1ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个<code class="fe na nb nc nd b">Person</code>构造函数来为每个人实例化:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="9df2" class="nk me it nd b gy nl nm l nn no">function Person(name) {<br/>  this.name = name<br/>}</span></pre><p id="229b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经意识到我们在这里使用的方法<code class="fe na nb nc nd b">notifyTicket</code>丢失了:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="cc39" class="nk me it nd b gy nl nm l nn no">person.notifyTicket(ticketNum, function accept() {</span></pre><p id="2d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，因为我们不想把等待列表的界面和通用的<code class="fe na nb nc nd b">People</code>界面混在一起。</p><p id="c4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将创建一个<code class="fe na nb nc nd b">WaitingListPerson</code>构造函数，它将包含自己的接口，专门用于等候名单上的人，因为我们知道，当这个人被带走后，这些功能将没有任何用处。所以，我们让事情变得有条理和简单。</p><p id="da86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将通过一个名为<code class="fe na nb nc nd b">extend</code>的实用程序来扩展<code class="fe na nb nc nd b">Person</code>的实例:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="21a5" class="nk me it nd b gy nl nm l nn no">function extend(target, extensions) {<br/>  for (let ext in extensions) {<br/>    target[ext] = extensions[ext]<br/>  }<br/>}</span></pre><p id="d5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe na nb nc nd b">WaitingListPerson</code>的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="94d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们要做的最后一件事是最终实现<code class="fe na nb nc nd b">DMV</code>的方法，这样它就可以添加/删除人员，管理票号等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="843c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有一个足够的DMV售票系统，由观察者模式支持！</p><p id="f1b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它的使用情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/3a83a0a30db4e95be49701aa1765bc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kcXa2OH0siiCnCI_.JPG"/></div></div></figure><p id="6e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经看到了观察者模式能让你的应用走多远。我们已经利用它建立了一个功能性的车管所票务呼叫系统。给你们自己一点鼓励！</p><p id="96a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个帖子到此结束！我希望你发现这是有价值的，并期待在未来更多。</p><p id="8366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想保持联系吗？订阅我的<a class="ae np" href="https://app.getresponse.com/site2/javascript-newsletter?u=zpBtw&amp;webforms_id=SM2hz" rel="noopener ugc nofollow" target="_blank">简讯</a>。</p></div></div>    
</body>
</html>