<html>
<head>
<title>4 New JavaScript Features To Watch Out for in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年值得关注的4个JavaScript新特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-new-javascript-features-to-watch-out-for-in-2021-36b7d7d08745?source=collection_archive---------5-----------------------#2021-05-18">https://betterprogramming.pub/4-new-javascript-features-to-watch-out-for-in-2021-36b7d7d08745?source=collection_archive---------5-----------------------#2021-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dad8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数字分隔符、逻辑赋值运算符等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f85cfbf31390a14d2e42ef7125a1cc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DAWRXtqePjub6hhulxYzWw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@korpa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jr Korpa </a>在<a class="ae ky" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6a20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自2015年以来，JavaScript每年都有语言更新。2021年也不例外:今年，几个新功能达到了<a class="ae ky" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank"> TC39进程</a>的第4阶段，并且已经可以在Node.js和大多数主要的现代浏览器中使用。</p><p id="923a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究四个最重要的新特性。我们将介绍一个新的string方法、一个新的Promise方法、对数字可读性的改进以及一个新的赋值简写。</p><h1 id="2793" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">replaceAll()</h1><p id="023e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们有一个新的字符串原型方法<code class="fe ms mt mu mv b">replaceAll</code>，它替换子字符串的每个实例。虽然我们可以用现有的replace方法做到这一点，但我们不得不求助于正则表达式，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="7b3a" class="na lw it mv b gy nb nc l nd ne">"1990-01-01".replace(/-/g, "/");</span></pre><p id="014c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">replaceAll</code>按理说更具可读性:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="16b4" class="na lw it mv b gy nb nc l nd ne">"1990-01-01".replaceAll("-", "/");</span></pre><p id="fea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ms mt mu mv b">replaceAll</code>，不需要正则表达式。但是，只要提供了<code class="fe ms mt mu mv b">g</code>标志，它仍然可以使用。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="359f" class="na lw it mv b gy nb nc l nd ne">"1990-01-01".replaceAll(/-/g, "/");</span></pre><h2 id="0631" class="na lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">支持</h2><p id="abca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">chrome:85+<br/>Firefox:77+<br/>Safari:13.1+<br/>Node:15 . 0 . 0+</p><h1 id="c370" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">承诺。任何</h1><p id="9f59" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">今年，使用<code class="fe ms mt mu mv b">Promise.any</code>对异步代码的处理有了进一步的改进，它接受一组承诺并返回第一个解决的承诺。如果每个承诺都被拒绝，就会抛出一个错误。</p><p id="ac59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们做四个承诺，看看会发生什么:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0ede" class="na lw it mv b gy nb nc l nd ne">const p1 = new Promise((<em class="nq">resolve</em>, <em class="nq">reject</em>) =&gt; setTimeout(reject,  1000, "p1"));</span><span id="1614" class="na lw it mv b gy nr nc l nd ne">const p2 = new Promise((<em class="nq">resolve</em>, <em class="nq">reject</em>) =&gt; setTimeout(resolve, 2000, "p2"));</span><span id="b7cb" class="na lw it mv b gy nr nc l nd ne">const p3 = new Promise((<em class="nq">resolve</em>, <em class="nq">reject</em>) =&gt; setTimeout(reject,  3000, "p3"));</span><span id="7060" class="na lw it mv b gy nr nc l nd ne">const p4 = new Promise((<em class="nq">resolve</em>, <em class="nq">reject</em>) =&gt; setTimeout(resolve, 4000, "p4"));</span></pre><p id="f67b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">Promise.any</code>将返回先解决的问题。这种情况下，<code class="fe ms mt mu mv b">p2</code>。我们可以使用下面的代码对此进行测试:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="7ec6" class="na lw it mv b gy nb nc l nd ne">async function getFirstResolvedPromise() {<br/>  const result = await Promise.any([p1, p2, p3, p4]);<br/>  console.log(result);<br/>};</span><span id="cd37" class="na lw it mv b gy nr nc l nd ne">getFirstResolvedPromise(); // "p2"</span></pre><p id="1cd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在有四种方法可以用来处理一系列承诺:</p><ul class=""><li id="abe2" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">Promise.all</code> —一旦所有承诺都已解决，返回一个已解决承诺的数组</li><li id="2dbf" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">Promise.allSettled</code>(2020年新增)—一旦所有承诺都被解决或拒绝，则返回一组承诺，无论它们是被解决还是被拒绝</li><li id="fec3" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">Promise.race</code> —返回第一个解决或拒绝的承诺</li><li id="5c95" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">Promise.any</code> —返回第一个已解决的承诺</li></ul><h2 id="c748" class="na lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">支持</h2><p id="c4ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">chrome:85+<br/>Firefox:79+<br/>Safari:14+<br/>Node:15 . 0 . 0+</p><h1 id="e787" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">逻辑赋值运算符</h1><p id="bf54" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">自从2020年引入nullish合并运算符<code class="fe ms mt mu mv b">??</code>以来，我们现在有三个逻辑运算符:</p><ul class=""><li id="1455" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">&amp;&amp;</code> —逻辑与</li><li id="99c1" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">||</code> —逻辑或</li><li id="6339" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">??</code> —无效合并运算符</li></ul><p id="1c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些简写允许我们根据一个值是真还是假来简洁地解析表达式——或者，在<code class="fe ms mt mu mv b">??</code>的情况下——一个值是否为空(<code class="fe ms mt mu mv b">null</code>或<code class="fe ms mt mu mv b">undefined</code>)。</p><p id="7c44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们有了使用这些运算符赋值的更简洁的简写方式:</p><ul class=""><li id="31f8" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">&amp;&amp;=</code> —如果变量为真，则分配变量</li><li id="ae5f" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">||=</code> —如果变量为falsy，则分配变量</li><li id="7727" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ms mt mu mv b">??=</code> —如果变量为空，则分配一个变量</li></ul><p id="dc0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，每组三条语句是等效的:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9334" class="na lw it mv b gy nb nc l nd ne">// Logical AND assignment<br/>a &amp;&amp;= b;<br/>a = a &amp;&amp; b;<br/>a = a ? b : a;</span><span id="61b3" class="na lw it mv b gy nr nc l nd ne">// Logical OR assignment<br/>a ||= b;<br/>a = a || b;<br/>a = a ? a : b;</span><span id="2e86" class="na lw it mv b gy nr nc l nd ne">// Logical nullish assignment<br/>a ??= b;<br/>a = a ?? b;<br/>a = a === null || a === undefined ? b : a;</span></pre><p id="548e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，当每个表达式运行时，变量<code class="fe ms mt mu mv b">a</code>将被重新分配一个新值。代码如下:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="404e" class="na lw it mv b gy nb nc l nd ne">let a = true;<br/>const b = false, c = null, d = 10;</span><span id="a5c6" class="na lw it mv b gy nr nc l nd ne">a &amp;&amp;= b;<br/>console.log(a); // false</span><span id="2f51" class="na lw it mv b gy nr nc l nd ne">a ||= c;<br/>console.log(a); // null</span><span id="f02d" class="na lw it mv b gy nr nc l nd ne">a ??= d;<br/>console.log(a); // 10</span></pre><p id="3bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些新的赋值运算符加入了数学赋值运算符<code class="fe ms mt mu mv b">+=</code>、<code class="fe ms mt mu mv b">-=</code>、<code class="fe ms mt mu mv b">*=</code>、<code class="fe ms mt mu mv b">/=</code>、<code class="fe ms mt mu mv b">**=</code>和<code class="fe ms mt mu mv b">%=</code>，以及按位运算符赋值。</p><h2 id="31da" class="na lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">支持</h2><p id="8fe5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">chrome:85+<br/>Firefox:79+<br/>Safari:14+<br/>Node:15 . 0 . 0+</p><h1 id="721e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数字分隔符</h1><p id="033e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，今年有一个特性被广泛采用，它为那些处理大量数字或大量小数位的人带来了显著的可读性增强！</p><p id="196b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以用下划线来分隔数字。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8399" class="na lw it mv b gy nb nc l nd ne">const a = 100000000;</span><span id="d8a5" class="na lw it mv b gy nr nc l nd ne">const b = 100_000_000;</span><span id="a28c" class="na lw it mv b gy nr nc l nd ne">console.log(a === b); // true</span></pre><p id="8aa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe ms mt mu mv b">a</code>和<code class="fe ms mt mu mv b">b</code>一模一样，但是<code class="fe ms mt mu mv b">b</code>更容易识别为1亿。实际上，数字分隔符主要用作千位分隔符，尽管这种用法不是强制的。数字分隔符可用于浮点数和BigInt值(2020年引入)。下面的代码展示了这些是如何工作的:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3659" class="na lw it mv b gy nb nc l nd ne">const float = 3.141_592_653_59;</span><span id="ed95" class="na lw it mv b gy nr nc l nd ne">const bigInt = 9_007_199_254_740_992n;</span></pre><p id="8bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们也支持十六进制、八进制和二进制数，比如十六进制的<code class="fe ms mt mu mv b">0xFF_FF_FF</code>或<code class="fe ms mt mu mv b">0x_00_00_00</code>。</p><p id="b968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe ms mt mu mv b">_</code>不能用在数字的开头或结尾(或者在首字母<code class="fe ms mt mu mv b">0</code>之后)。此外，它不能与小数点相邻，并且不能在一行中使用多个下划线。</p><h2 id="187a" class="na lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">支持</h2><p id="ede6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">chrome:75+<br/>Firefox:70+<br/>Safari:13+<br/>Node:12 . 5 . 0+</p></div></div>    
</body>
</html>