<html>
<head>
<title>White Labeling in Xcode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Xcode中的白色标签</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/white-labelling-in-xcode-a5ad66f30a8a?source=collection_archive---------2-----------------------#2019-10-12">https://betterprogramming.pub/white-labelling-in-xcode-a5ad66f30a8a?source=collection_archive---------2-----------------------#2019-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给应用贴上白色标签，无需为每种风格复制一个目标</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/576eca8d08e0001c64675118e59327d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyexPhOUb1ybpIKMNn4NKg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同的口味</p></figure><p id="477b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们一直在准备建立一个白色标签的应用程序，不想为每种口味重复一个目标。</p><p id="8b9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有完全不同的产品，这是有意义的，但对于像白色标签这样的东西，随着你添加更多的目标，这就变成了一场噩梦。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5a27" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为什么不应该复制目标？</h1><p id="5287" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这实际上和复制粘贴<em class="my"> </em>是一样的，你不会用代码来这样做(对吗？).</p><p id="0e87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您最终会复制构建设置、构建阶段和构建规则。这很快变得难以管理，并导致重复工作— <em class="my"> </em>每次你编辑其中一个，你都必须编辑它们。</p><p id="f920" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用<a class="ae mz" href="https://cocoapods.org/" rel="noopener ugc nofollow" target="_blank"> CocoaPods </a>，您还会使您的Podfile变得复杂，因为您还需要在那里添加每个目标。</p><p id="73ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次将文件添加到项目中时，您都需要确保将引用添加到每个目标的编译源或复制包资源阶段。</p><p id="aec9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于这些都是手动过程，它们也容易出现人为错误，并可能导致运行时错误，特别是当弱链接框架或捆绑资源没有正确配置时。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b499" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">你有什么选择？</h1><p id="6fad" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">您可以使用构建配置、构建设置、<code class="fe na nb nc nd b">info.plist</code>、方案和构建阶段的组合。我将在下面更详细地介绍每一个以及如何组合它们。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d411" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">构建配置</h1><p id="6160" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在您的项目中，在<em class="my"> Info </em>下，您可以为每个风格复制/添加构建配置。</p><p id="03aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在您已经添加了一个构建配置，您可以转到项目的构建设置，用箭头展开一个项，并查看您的构建配置可以为该设置定义自己的值。</p><p id="c538" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以在目标的构建设置中覆盖这些默认值(<code class="fe na nb nc nd b">$(inherited)</code>)。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a71a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">构建设置</h1><p id="cb5f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">现在我们有了不同的构建配置，我们可以添加一个用户定义的构建设置来返回风格。</p><p id="3e24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们称这个设置为<code class="fe na nb nc nd b">BUILD_FLAVOUR</code>，我们可以在我们的构建设置、构建阶段、<code class="fe na nb nc nd b">info.plist</code>或者计划中的任何地方引用它(稍后会详细介绍)。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="49ba" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">信息列表</h1><p id="6789" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">打开您的<code class="fe na nb nc nd b">Info.plist</code>文件，您会注意到一堆现有的构建设置，如<code class="fe na nb nc nd b">$(PRODUCT_BUNDLE_IDENTIFIER)</code>。</p><p id="9dc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您转到项目的构建设置，您可以为每个构建配置编辑此设置—现在您已经有了一种以不同方式签署多个应用程序的方法。</p><p id="63eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您可以添加自己的用户定义的构建设置来管理各种设置，如每个构建配置的API键或服务器URL。您需要引用<code class="fe na nb nc nd b">Info.plist</code>中的构建设置，以与现有键相同的方式添加您自己的键。</p><p id="7a15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，您可以像下面这样从包中访问它们:<code class="fe na nb nc nd b">Bundle.main.infoDictionary[EXAMPLE_API_KEY]</code>。</p><p id="e547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我通常忽略的另一个设置是包名，因为使用了<code class="fe na nb nc nd b">$(PRODUCT_NAME)</code>链接映射文件和模块名，所以最好保留这些作为项目名，并创建第二个用户定义的构建设置，称为<code class="fe na nb nc nd b">BUILD_DISPLAY_NAME</code>，并根据构建配置进行配置。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b7a8" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">计划</h1><p id="3439" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">为了构建正确的风格，我们需要为每个风格设置一个方案，指向<code class="fe na nb nc nd b">DEBUG</code>和<code class="fe na nb nc nd b">PRODUCTION</code>的正确构建配置。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="0644" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">包括和排除文件</h1><p id="9c35" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">假设我们已经为A和b两种口味配置了方案。</p><p id="5cc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与<code class="fe na nb nc nd b">BUILD_FLAVOUR</code>设置(如上所述)结合使用时，两个设置非常强大:</p><h2 id="b490" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated"><code class="fe na nb nc nd b">1. EXCLUDED_SOURCE_FILE_NAMES</code></h2><p id="ed61" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">您可以使用模式或确切的文件名来排除所有风格中不应该捆绑的所有内容(如xcassets、files)。</p><p id="6d39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我发现模式是管理这些的最简单的方法，我们可以添加一个像<code class="fe na nb nc nd b">*Flavour*_*.*</code>这样的模式来排除所有前缀为<code class="fe na nb nc nd b">Flavour*_</code>的文件。</p><p id="9f52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我可以将<code class="fe na nb nc nd b">FlavourA_Assets.xcassets</code>和<code class="fe na nb nc nd b">FlavourB_Assets.xcassets</code>添加到项目中，并确信这两个都将从编译后的应用程序二进制文件中缺失(因为它们匹配这个模式)。</p><h2 id="cf61" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">2.<code class="fe na nb nc nd b">INCLUDED_SOURCE_FILE_NAMES</code></h2><p id="dd5f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">本身并不十分强大。它需要与此设置结合使用，以包含基于生成设置的文件。</p><p id="28b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以加上这个图案:<code class="fe na nb nc nd b">*Flavour$(BUILD_FLAVOUR)_*.*</code>。</p><p id="0c52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们现在编译风味A方案，我们应该看到<code class="fe na nb nc nd b">Flavour<strong class="la iu">A</strong>_Assets.xcassets</code>已经被复制到编译后的<code class="fe na nb nc nd b">.app</code>文件中，应该缺少<code class="fe na nb nc nd b">Flavour<strong class="la iu">B</strong>_Assets.xcassets</code>。反之亦然，对于flavor B方案也是如此。</p><p id="f410" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也可以用于复制不同的代码，因此您可以通过拥有签名的同一实现的两个变体来定义稍微不同的行为。</p><p id="fbc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以为风味A添加一个名为<code class="fe na nb nc nd b">FlavourA_Calculation.swift</code>的文件，它有一个以英镑( )为单位返回结果的函数；为风味B添加另一个名为<code class="fe na nb nc nd b">FlavourB_Calculation.swift</code>的文件，它有相同的函数，但以欧元(€)为单位返回结果。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ca76" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">构建阶段</h1><p id="320d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">构建阶段可以涵盖需要将文件复制到一个精确位置的场景，比如Google Analytics的<code class="fe na nb nc nd b">Google-Info.plist</code>。对于不同的风格，这个文件可能有不同的变体，但是Fabric要求这个文件叫做<code class="fe na nb nc nd b">Google-Info.plist</code>。</p><p id="ac4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，您可以编写脚本，在将这些文件复制到包中之后(即复制包资源之后)对其进行重命名。</p><p id="e502" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我发现一个有用的运行脚本是这样的:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="f545" class="ne mc it nd b gy nu nv l nw nx">function move {<br/> CFGROOT=”$CONFIGURATION_BUILD_DIR/$CONTENTS_FOLDER_PATH”<br/> CFGDEST=”$CFGROOT/GoogleService-Info.plist”<br/> CFGSRC=”$CFGROOT/Flavour$1_GoogleService-Info.plist”<br/> if [ -f “$CFGSRC” ]; then<br/>   mv “$CFGSRC” “$CFGDEST”<br/> fi<br/>}</span><span id="4d19" class="ne mc it nd b gy ny nv l nw nx">move A<br/>move B</span></pre><p id="8073" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe na nb nc nd b">BUILD_FLAVOUR</code>在构建阶段不可用，我们需要通过多次调用该方法来尝试复制每个文件。</p><p id="e3a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个我似乎找不到解决方案的是启动屏幕，它必须是你的<code class="fe na nb nc nd b">Target</code>中的常规设置中提到的那个。这可以使用类似的脚本来解决。</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="dc61" class="ne mc it nd b gy nu nv l nw nx">function move {<br/>    SBROOT="$CONFIGURATION_BUILD_DIR/$CONTENTS_FOLDER_PATH"<br/>    # Storyboards are compiled directories after compilation (storyboardc)<br/>    SBDEST="$SBROOT/Base.lproj/LaunchScreen.storyboardc"<br/>    SBSRC="$SBROOT/Flavour$1_LaunchScreen.storyboardc"<br/>    if [ -d "$SBSRC" ]; then<br/>        rm -R "$SBDEST"<br/>        mv "$SBSRC" "$SBDEST"<br/>    fi<br/>}<br/><br/>move A<br/>move B</span></pre><p id="3081" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你已经拥有了给应用贴上白色标签所需的所有要素。</p><p id="8c3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是一个<a class="ae mz" href="https://github.com/cjnevin/WhiteLabelled" rel="noopener ugc nofollow" target="_blank">的示例项目</a>。</p></div></div>    
</body>
</html>