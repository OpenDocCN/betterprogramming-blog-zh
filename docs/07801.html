<html>
<head>
<title>Expression Language Injections in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的表达式语言注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/expression-language-injections-in-java-e08bd17addf4?source=collection_archive---------1-----------------------#2021-02-21">https://betterprogramming.pub/expression-language-injections-in-java-e08bd17addf4?source=collection_archive---------1-----------------------#2021-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ecb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用CodeQL检测JEXL进样</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e3fd43000d46c20ef8bb7c76592fc556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9-msGOCPh4s28xjh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kozjat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科兹贾特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="e928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论一个用于检测JEXL表达式语言注入漏洞的CodeQL查询。</p><p id="7644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我将简要概述表达式语言，特别是JEXL。我还会解释什么是表达式语言注入，如何防范。然后，我将描述CodeQL查询是如何工作的。此外，我将展示通过查询发现的一些漏洞。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7fc1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是表情语言？</h1><p id="6371" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">表达式语言(EL)是一种通用编程语言，主要用于在运行时嵌入和计算表达式。大多数情况下，ELs是解释性语言。换句话说，有一个解释器准备执行上下文并在其中运行表达式。根据特定的应用程序，开发人员、管理员甚至普通用户都可以出于各种目的创建表达式。嵌入式表达式通常有助于定制和配置应用程序。</p><p id="0b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">EL有多种实现方式。以下是几个例子:</p><ul class=""><li id="d28b" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">Java服务器页面(JSP)允许在许多标签中使用表达式。</li><li id="581d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">Spring框架提供了<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html" rel="noopener ugc nofollow" target="_blank"> Spring表达式语言</a> (SpEL)，这在Spring标签、配置和其他上下文中是允许的。</li><li id="5fe5" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">Apache Struts允许在多种上下文中使用表达式。它使用<a class="ae ky" href="https://commons.apache.org/proper/commons-ognl/" rel="noopener ugc nofollow" target="_blank">对象图形导航库</a> (OGNL)。</li></ul><p id="57b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，表达式语言提供许多简单的操作，如加法、乘法、字符串连接等等。除此之外，一些EL解释器允许您调用评估上下文中可用的对象上的方法。此外，一些解释器允许您访问JVM中的任何类并调用它们的方法。但这可能相当危险。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="679f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">JEXL是什么？</h1><p id="2090" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://commons.apache.org/proper/commons-jexl/" rel="noopener ugc nofollow" target="_blank"> JEXL </a>代表Java表达式语言。这是一个提供用于评估JEXL表达式的API的库。该项目属于Apache软件基金会。</p><p id="78ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们来说，最有趣的事实是JEXL足够强大，可以让我们调用JVM中可用的类和方法。下面的代码调用<code class="fe nn no np nq b">ProcessBuilder</code>来启动一个外部进程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b05" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是表情语言注入？</h1><p id="fffa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果应用程序允许表达式访问JVM中可用的类和方法，并且如果恶意用户可以向应用程序提供(或注入)任意表达式，则通常会导致任意代码执行。那叫表达式语言注入漏洞。</p><p id="4c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种问题的影响通常很大，因为攻击者可以在JVM内部甚至外部运行几乎任何代码。成功攻击的可能性取决于攻击者如何注入恶意表达式。在最坏的情况下，应用程序从未经身份验证的远程用户接收的请求中读取并运行表达式(例如，使用HTTP)。这通常会导致远程代码执行(RCE)。除此之外，应用程序可以从文件、数据库和其他地方获得表达式。</p><p id="27e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个易受攻击的代码示例。它只是从HTTP请求中获取一个表达式并立即运行它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="22bc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">预防JEXL注射</h1><p id="6812" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我建议在应用程序中引入表达式之前要三思。它们可能真的没有必要，可能有更好(或更简单)的设计。如果引入表达式是不可避免的，那么表达式应该在一个限制性的沙箱中运行。</p><p id="3ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，JEXL提供了两种实现沙箱的方法。第一种方法是使用<code class="fe nn no np nq b">JexlSandbox</code>类。类别可让您指定允许或禁止从JEXL运算式呼叫哪些类别。确保将<code class="fe nn no np nq b">false</code>传递给构造函数。这意味着所有方法调用都被禁止，除非它们被明确允许。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法是通过实现<code class="fe nn no np nq b">JexlUberspect</code>接口来创建一个自定义沙箱。这个类的主要目的是自省，但是它也可以用于创建沙箱。这种方法更加灵活，因为我们不受<code class="fe nn no np nq b">JexlSandbox</code>提供的API的限制。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="09c3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用于检测JEXL注入的CodeQL查询</h1><p id="efa8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://securitylab.github.com/tools/codeql" rel="noopener ugc nofollow" target="_blank"> CodeQL </a>是一个代码分析引擎。它允许您为代码编写查询来检测各种问题，包括安全问题。让我们看看它如何帮助我们检测JEXL注射。</p><p id="24c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CodeQL可以查找从源到我们指定的接收器的数据流。在JEXL注入的情况下，接收器是触发评估JEXL表达式的方法调用，比如<code class="fe nn no np nq b">JexlExpression.evaluate()</code>、<code class="fe nn no np nq b">JexlScript.execute()</code>和其他几个表达式。最有趣的数据源是远程用户可用的数据源(例如网络套接字和HTTP请求)。从远程数据源到其中一个JEXL接收器的数据流可能是一个潜在的JEXL注入。</p><p id="6e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经在一个CodeQL查询中实现了这个想法。让我们来看看它的主要组成部分。</p><p id="f296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了搜索数据流，我编写了一个配置来跟踪从远程数据源到JEXL接收器的污染数据。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d0d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有三个主要部分:</p><ul class=""><li id="fcec" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe nn no np nq b">isSource()</code>谓词定义了数据源。这里，它使用了描述网络套接字、HTTP请求和CodeQL核心库知道的其他远程数据源的<code class="fe nn no np nq b">RemoteFlowSource</code>类。</li><li id="c3c4" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe nn no np nq b">isSink()</code>谓词定义了数据接收器。这里，它使用了<code class="fe nn no np nq b">JexlEvaluationSink</code>类，该类列出了触发评估JEXL表达式的方法调用。</li><li id="a869" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe nn no np nq b">isAdditionalTaintStep()</code>谓词告诉CodeQL引擎被感染的输入可以通过其他方式传播。</li></ul><p id="bf89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看<code class="fe nn no np nq b">JexlEvaluationSink</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="588b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它定义了两组可以触发评估JEXL表达式的方法调用:</p><ul class=""><li id="acd5" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">立即计算表达式的方法。比如<code class="fe nn no np nq b">JexlExpression.evaluate()</code>和<code class="fe nn no np nq b">JexlEngine.getProperty()</code>。</li><li id="e784" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">表达式延迟求值的方法:<code class="fe nn no np nq b">JexlExpression.callable()</code>和<code class="fe nn no np nq b">JexlScript.callable()</code>。那些方法不会马上计算表达式。该查询假设稍后将调用触发评估的<code class="fe nn no np nq b">Callable.call()</code>方法。</li></ul><p id="9ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">isAdditionalTaintStep()</code>谓词定义了另外两种传播受感染数据的方式:</p><ul class=""><li id="748f" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe nn no np nq b">TaintPropagatingJexlMethodCall</code>类定义了编译JEXL表达式、脚本和模板的方法。</li><li id="26cf" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe nn no np nq b">returnsDataFromBean()</code>谓词定义了对可能保存被污染数据的beans上的getters的调用。</li></ul><p id="dbd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，该查询检查是否使用了沙盒JEXL引擎。它在<code class="fe nn no np nq b">isUnsafeEngine()</code>谓词和一个单独的数据流配置(<code class="fe nn no np nq b">SandboxedJexlFlowConfig</code>)中实现，该配置检查是否已经为JEXL引擎设置了<code class="fe nn no np nq b">JexlSandbox</code>或<code class="fe nn no np nq b">JexlUberspect</code>。</p><p id="b3ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当前查询有几个已知问题:</p><ul class=""><li id="44cd" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">当数据存储在复杂的结构中时,<code class="fe nn no np nq b">returnsDataFromBean()</code>谓词有助于识别问题。然而，它没有考虑数据在bean中是如何流动的。因此，它可能会导致误报。</li><li id="a0a8" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">如果查询检查沙箱是否是实现的属性就好了。不幸的是，我找不到一个可靠的解决方案。目前，这个查询不能确定一个<code class="fe nn no np nq b">JexlUberspect</code>是否真的实现了一个沙箱，或者一个<code class="fe nn no np nq b">JexlSandbox</code>是否过于宽松。相反，它只是假设沙箱得到了正确的实现。因此，它可能会导致假阴性。</li></ul><p id="ff6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该查询发现了几个有趣的问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="969c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">CVE-2021–3396:OpenNMS中的RCE</h1><p id="18f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第一个发现是在<a class="ae ky" href="https://github.com/OpenNMS/newts" rel="noopener ugc nofollow" target="_blank"> OpenNMS/newts </a>项目中的一个RCE(<a class="ae ky" href="https://nvd.nist.gov/vuln/detail/CVE-2021-3396" rel="noopener ugc nofollow" target="_blank">CVE-2021–3396</a>)。服务器提供<code class="fe nn no np nq b">/measurements/{resource}</code> <a class="ae ky" href="https://github.com/OpenNMS/newts/blob/d706eb9e12783b31f4745c232a3cfa212474e68a/rest/src/main/java/org/opennms/newts/rest/MeasurementsResource.java#L62" rel="noopener ugc nofollow" target="_blank">端点</a>:</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="6b22" class="nx md it nq b gy ny nz l oa ob"><a class="ae ky" href="http://twitter.com/POST" rel="noopener ugc nofollow" target="_blank">@POST</a><br/><a class="ae ky" href="http://twitter.com/Path" rel="noopener ugc nofollow" target="_blank">@Path</a>("/{resource}")<br/><a class="ae ky" href="http://twitter.com/Timed" rel="noopener ugc nofollow" target="_blank">@Timed</a><br/>public Collection&lt;Collection&lt;MeasurementDTO&gt;&gt; getMeasurements(<br/>        ResultDescriptorDTO descriptorDTO,<br/>        <a class="ae ky" href="http://twitter.com/PathParam" rel="noopener ugc nofollow" target="_blank">@PathParam</a>("resource") Resource resource,<br/>        <a class="ae ky" href="http://twitter.com/QueryParam" rel="noopener ugc nofollow" target="_blank">@QueryParam</a>("start") Optional&lt;TimestampParam&gt; start,<br/>        <a class="ae ky" href="http://twitter.com/QueryParam" rel="noopener ugc nofollow" target="_blank">@QueryParam</a>("end") Optional&lt;TimestampParam&gt; end,<br/>        <a class="ae ky" href="http://twitter.com/QueryParam" rel="noopener ugc nofollow" target="_blank">@QueryParam</a>("resolution") Optional&lt;DurationParam&gt; resolution,<br/>        <a class="ae ky" href="http://twitter.com/QueryParam" rel="noopener ugc nofollow" target="_blank">@QueryParam</a>("context") Optional&lt;String&gt; contextId) {</span></pre><p id="cbe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">端点接受带有许多参数的POST请求。大部分来自URL路径和查询字符串。除此之外，<code class="fe nn no np nq b">getMeasurements()</code>方法接受了一个<code class="fe nn no np nq b">ResultDescriptorDTO</code>的实例。这个参数没有任何注释，但是它来自于<br/>POST请求的主体。<code class="fe nn no np nq b">ResultDescriptorDTO</code>类保存一个JEXL <br/>表达式数组。当端点被调用时，这些JEXL表达式会转到<code class="fe nn no np nq b">JexlEngine</code>并立即执行。</p><p id="d45e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引擎未配置沙箱。因此，远程用户可以在服务器上运行任意代码。该问题已在newts 1.5.3 中通过<a class="ae ky" href="https://github.com/OpenNMS/newts/pull/49" rel="noopener ugc nofollow" target="_blank">沙盒</a> JEXL表达式<a class="ae ky" href="https://www.opennms.com/en/blog/2021-02-16-cve-2021-3396-full-security-disclosure/" rel="noopener ugc nofollow" target="_blank">修复。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="91d8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">特拉卡的RCE</h1><p id="dbce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第二个发现是Traccar项目中的一个<a class="ae ky" href="https://github.com/traccar/traccar/issues/4624" rel="noopener ugc nofollow" target="_blank"> RCE。服务器有一个未记录的</a><a class="ae ky" href="https://github.com/OpenNMS/newts/blob/d706eb9e12783b31f4745c232a3cfa212474e68a/rest/src/main/java/org/opennms/newts/rest/MeasurementsResource.java#L62" rel="noopener ugc nofollow" target="_blank">端点</a> ( <code class="fe nn no np nq b">/attributes/computed/test</code>)，它接受一个设备ID和一个带有属性的结构:</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="e735" class="nx md it nq b gy ny nz l oa ob"><a class="ae ky" href="http://twitter.com/POST" rel="noopener ugc nofollow" target="_blank">@POST</a><br/><a class="ae ky" href="http://twitter.com/Path" rel="noopener ugc nofollow" target="_blank">@Path</a>("test")<br/>public Response test(<br/>        <a class="ae ky" href="http://twitter.com/QueryParam" rel="noopener ugc nofollow" target="_blank">@QueryParam</a>("deviceId") long deviceId, Attribute entity) {</span></pre><p id="7f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该属性有一个包含JEXL表达式的<code class="fe nn no np nq b">expression</code>字段。表达式直接进入一个不使用沙箱的<code class="fe nn no np nq b">JexlEngine</code>。此问题可能难以利用，因为攻击者必须是管理员才能访问端点。因此，项目维护人员没有把这个问题当回事。</p><p id="8bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该查询可以扩展到考虑更多的数据源，如文件。那肯定会发现更多的问题。然而，这样的问题并不有趣，因为攻击者很难利用它们。例如，Apache JMeter不支持来自测试计划的JEXL表达式。实现沙箱被认为是一种安全<a class="ae ky" href="https://bz.apache.org/bugzilla/show_bug.cgi?id=65151" rel="noopener ugc nofollow" target="_blank">增强</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0660" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="6031" class="mz na it lb b lc mu lf mv li oc lm od lq oe lu ne nf ng nh bi translated"><a class="ae ky" href="https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection" rel="noopener ugc nofollow" target="_blank">表情语言注射(OWASP) </a></li><li id="6310" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://commons.apache.org/proper/commons-jexl/" rel="noopener ugc nofollow" target="_blank">阿帕奇JEXL </a></li><li id="5f5d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://codeql.github.com/docs/" rel="noopener ugc nofollow" target="_blank"> CodeQL文档</a></li></ul></div></div>    
</body>
</html>