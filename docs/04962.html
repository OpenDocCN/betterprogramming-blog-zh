<html>
<head>
<title>An Introduction to Michelson: the Scripting Language of Tezos (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Michelson简介:Tezos的脚本语言(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-michelson-the-language-of-tezos-part-1-374c03394cc3?source=collection_archive---------8-----------------------#2020-05-26">https://betterprogramming.pub/introduction-to-michelson-the-language-of-tezos-part-1-374c03394cc3?source=collection_archive---------8-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a51" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用Michelson编程语言并在Tezos上编写智能合同</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b9bec226580ca62cf9694cded067c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XTEXry5Unn2UYtZ7nSpMA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://pixabay.com/illustrations/matrix-code-data-networking-1735640/" rel="noopener ugc nofollow" target="_blank">来源:Pixabay </a></p></figure><p id="57d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迈克尔逊一定是目前智能合约最令人兴奋的编程语言之一。这是一种基于堆栈的、严格类型化的语言，用它来编写智能合约以确保Tezos区块链的安全。迈克尔逊类似于以太坊智能合约的字节码，但它更可读、更安全、更健壮。你可以用来为Tezos编写智能合同的所有高级语言——如SmartPy、Ligo或Lorentz——最终都会编译成Michelson。</p><p id="da9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一篇文章中，我们将尝试迈克尔逊语言，理解“基于堆栈”的含义，并编写一些非常简单的智能契约。这篇文章主要是为编程和/或Tezos开发的初学者写的，但是想要了解更多关于Michelson的中级程序员也可以在这里找到有用的信息。我们要用烤坏开发的<a class="ae ky" href="https://github.com/baking-bad/michelson-kernel" rel="noopener ugc nofollow" target="_blank"> Jupyter内核在Jupyter笔记本上写迈克尔逊代码。如果您想查看工作中的代码，可以在每个部分找到一个链接。</a></p><p id="f465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们写点代码吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e42" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">堆栈</h1><p id="5c1d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了理解迈克尔逊是如何工作的，需要正确理解的一个主要概念是<em class="mz">栈</em>。每一份迈克尔逊合同都是一系列相互关联的指令。这些指令有精确的顺序，并按照它们被写入的顺序执行。</p><p id="759d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每条指令都会以某种方式操纵堆栈。把它想象成一堆数据。您编写的指令将对堆中的数据产生影响。例如，您可以将两个数据放在一起，移除上面的一个数据，将另一个数据放在上面，转移一些令牌，等等。栈的工作基于<em class="mz">后进先出</em>的原则:如果你想访问一个不在栈顶的数据，你必须首先处理它上面的数据。</p><p id="24c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用迈克尔逊编码时，你必须记住三个主要概念:</p><ul class=""><li id="abe3" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">新数据放在栈顶。</li><li id="3045" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">只有当堆栈中的数据位于堆栈顶部时(或者对于某些操作而言位于第二个位置，如下所述)，它们才变得可访问。</li><li id="1979" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">数据处理的顺序是从堆栈的顶部到底部。</li></ul><p id="d099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="23a8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">推送操作</h1><p id="c173" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果要在栈顶添加一段数据，就要调用PUSH操作。它是这样工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/afe6aa56a3aadb4646d54ca57c3e02f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Krmyh1dSg-FBu3o1ZmHZWw.png"/></div></div></figure><p id="94fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，堆栈中可能已经有数据，在这种情况下，新值将放在它们的顶部。这是你在迈克尔逊推新数据的方式:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b1b5" class="nu md it nq b gy nv nw l nx ny">PUSH value-type value</span></pre><p id="3504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如要推一个整数就写<code class="fe nz oa ob nq b">PUSH int 2</code>，对于一个字符串就写<code class="fe nz oa ob nq b">PUSH string "Tezos"</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d214" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">迈克尔逊智能合同结构</h1><p id="27de" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">迈克尔逊的智能合约展示了一个由三个部分组成的简单结构:</p><ul class=""><li id="c991" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">预期参数的类型。</li><li id="c6bb" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">存储的类型。</li><li id="3ec2" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">迈克尔逊密码。</li></ul><p id="892e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这转化为以下代码:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="c9a1" class="nu md it nq b gy nv nw l nx ny"><strong class="nq iu">parameter</strong> <em class="mz">parameter-type</em> ;<br/><strong class="nq iu">storage</strong> <em class="mz">storage-type</em> ;<br/><strong class="nq iu">code</strong> {<br/>  ...<br/>}</span></pre><p id="e6e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这种结构之外，在Michelson中编写智能合同时，您还必须记住两条规则:</p><ul class=""><li id="da52" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">当代码被执行时，包含参数和存储<code class="fe nz oa ob nq b">(pair parameter storage)</code>的一对总是被自动推入堆栈。记住——如果没有参数，就用<code class="fe nz oa ob nq b">Unit</code>来代替。</li><li id="5c3a" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">代码必须总是返回一个包含操作列表和(更新的)存储<code class="fe nz oa ob nq b">(pair list(operation) storage)</code>的对。当这种类型的对是堆栈中最后剩下的东西时，执行将停止。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc5a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一份简单的迈克尔逊智能合同</h1><p id="39b1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经知道了Michelson中的推送和智能合约的结构，让我们编写一个吧！</p><p id="4c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于此契约，我们将编写一个“Hello world”契约，并将一个字符串保存到存储中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/b9caafdde9bf91e1116d472ed4e14dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKe_5_e8DLNW-6AfI_dk3A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://mybinder.org/v2/gh/claudebarde/michelson-kernel/binder" rel="noopener ugc nofollow" target="_blank">Michelson tutorial-demo 1 . ipynb</a></p></figure><p id="4492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是执行这段代码时发生的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/1dc707e24c8f269e36e1ed5aaef7502c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bby6PNwbiDXZ4ylTSIgQxA.png"/></div></div></figure><ul class=""><li id="7755" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">parameter unit</code>表示传递的参数类型为<code class="fe nz oa ob nq b">unit</code>(基本上没有参数)。</li><li id="2973" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">storage string</code>表示合同有类型为<code class="fe nz oa ob nq b">string</code>的存储。</li><li id="270d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">DROP</code>是移除栈顶所有东西的操作码。请记住，我们之前说过，带参数和存储的对在开始时会自动包含在堆栈的顶部，我们不会使用它，我们可以直接删除它。</li><li id="170c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">PUSH</code>将一个值放在栈顶，这里是字符串“Hello world”。</li><li id="2398" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">NIL</code>是一个操作码，在栈顶添加一个指定类型的空列表(这里是<code class="fe nz oa ob nq b">operation</code>)。</li><li id="7357" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">PAIR</code>获取堆栈顶部的两个元素，创建一个包含这两个元素的新对，并将该对推回堆栈。</li></ul><p id="e77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:每条指令都以分号结束(尽管最后一条指令是可选的)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e5bc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加整数并保存结果</h1><p id="c0f9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面介绍一个新的操作:<code class="fe nz oa ob nq b">ADD</code>。你可能已经猜到了它的作用——将两个数值相加。</p><p id="0c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的合同来演示它是如何工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/fe661912de82067d4d82da73261cce33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQiFjng1rKrd-SJzKJ98Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://mybinder.org/v2/gh/claudebarde/michelson-kernel/binder" rel="noopener ugc nofollow" target="_blank">Michelson tutorial-demo 2 . ipynb</a></p></figure><p id="0030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细检查每个操作，以了解堆栈内部发生了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/adee25dbf6ba25bee41e4384e1c71f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Inw07Kx3DEhMLieXUY2FOw.png"/></div></div></figure><ul class=""><li id="9016" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">parameter unit </code> —同样，我们没有使用任何参数，所以我们传递一个<code class="fe nz oa ob nq b">unit</code>。</li><li id="0c6f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">storage int</code> —这一次，我们将整型值保存到存储器中。</li><li id="8660" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">DROP</code> —我们不需要初始对，所以我们可以去掉它，为我们实际需要的值腾出空间。</li><li id="cab1" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">PUSH int 2 ; PUSH int 3 ;</code>——注意顺序至关重要。按下<code class="fe nz oa ob nq b">int 3</code>后，<code class="fe nz oa ob nq b">int 2</code>将位于堆栈底部。在加法的情况下，顺序并不太重要，但如果你减去两个数字，例如，这是至关重要的推动他们在正确的顺序。</li><li id="50f0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">ADD</code>的工作原理与<code class="fe nz oa ob nq b">PAIR</code>相同。您将前两个元素放在堆栈的顶部，并从中获取一个值，然后将其推回堆栈。<code class="fe nz oa ob nq b">ADD</code>将两个数相加。请注意，这两个数字必须是相同的数字类型(例如，不能将整数和nat相加)。</li><li id="4103" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">NIL</code> —和之前的合约一样，我们推一个空的操作列表。</li><li id="72f1" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nz oa ob nq b">PAIR</code> —创建包含操作列表和新存储的对，我们需要它来停止契约的执行。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2da9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="07d3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">迈克尔逊语言的复杂性经常被高估。这可能是因为没有适合初学者的教程，而且网上难得一见的文档非常专业，新手很难读懂。这就是为什么我决定亲自经历学习迈克尔逊的过程，使用困难的文档创建一系列教程，我希望这些教程更容易理解。</p><p id="d77e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解迈克尔逊是理解和欣赏Tezos区块链的独特性以及使其更安全、更有用的关键。</p><p id="25aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一部分，我们将继续深入迈克尔逊。我们将编写一些简单的智能合同，并探索由Baking Bad团队创建的令人惊叹的<a class="ae ky" href="https://mybinder.org/v2/gh/baking-bad/michelson-kernel/binder?filepath=michelson_quickstart.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本，这些笔记本将允许我们编写迈克尔逊代码，并准确理解正在发生的事情。</a></p><p id="6726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">敬请期待！</p></div></div>    
</body>
</html>