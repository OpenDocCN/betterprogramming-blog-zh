<html>
<head>
<title>Storing Key-Value Pairs With JavaScript Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript映射存储键值对</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/storing-key-value-pairs-with-javascript-maps-52fb713bb096?source=collection_archive---------1-----------------------#2019-11-09">https://betterprogramming.pub/storing-key-value-pairs-with-javascript-maps-52fb713bb096?source=collection_archive---------1-----------------------#2019-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6580" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">地图和物体有什么区别？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8ed5ebdb5503df580160b8267860eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MfrQMdAVnBfS4rG3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Andrew Stutesman 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8ba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES2015中，我们有了一种新的数据结构来存储键-值对，称为映射，这是一种字典，我们可以使用它来存储任何对象作为键和任何对象作为值。</p><p id="4129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们有地图之前，我们必须使用对象作为字典，字典只使用字符串作为键，但是值可以是任何东西。</p><p id="ed4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用地图很简单，我们可以用下面的代码定义地图:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="59f5" class="ma mb it lw b gy mc md l me mf">let messageMap = new Map();<br/>messageMap.set('hi', 'Hello');<br/>messageMap.set('greeting', 'How are you doing?');<br/>messageMap.set('bye', 'Bye');</span></pre><p id="5baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了使用<code class="fe mg mh mi lw b">set</code>方法添加键和值，我们还可以传递一个嵌套数组，其中数组的每个条目都将键作为第一个元素，将值作为第二个元素。</p><p id="6535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1da2" class="ma mb it lw b gy mc md l me mf">const arrayOfKeysAndValues = [<br/>  ['a', 1],<br/>  ['b', 2],<br/>  ['c', 3],<br/>  ['d', 3],<br/>  ['e', 4],<br/>  ['f', 5],<br/>  ['g', 6],<br/>  ['h', 7],<br/>  ['i', 8],<br/>  ['j', 9],<br/>  ['k', 10],<br/>  ['l', 11],<br/>  ['m', 12],<br/>  ['n', 13],<br/>  ['o', 14],<br/>]<br/>let numMap = new Map(arrayOfKeysAndValues);<br/>console.log(numMap)</span></pre><p id="e0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将创建一个映射，其中每个数组的第一个元素作为键，每个数组的第二个元素作为相应的值。因此，在运行了<code class="fe mg mh mi lw b">console.log</code>行之后，我们得到了与数组顺序相同的所有Map条目。</p><p id="a740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用<code class="fe mg mh mi lw b">size</code>属性来获得映射中定义的键值对的数量:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1cab" class="ma mb it lw b gy mc md l me mf">messageMap.size // 3</span></pre><p id="5b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了通过键获得值，我们使用了<code class="fe mg mh mi lw b">get</code>函数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2216" class="ma mb it lw b gy mc md l me mf">messageMap.get('hi'); // 'Hello'<br/>messageMap.get('hello'); // undefined</span></pre><p id="a4b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果该键存在，它将返回值；如果带有该键的条目不存在，它将返回<code class="fe mg mh mi lw b">undefined</code>。</p><p id="973c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要删除给定了键的条目，我们可以使用<code class="fe mg mh mi lw b">delete</code>函数传递键:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="931d" class="ma mb it lw b gy mc md l me mf">messageMap.delete('hi');</span></pre><p id="8b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们多次使用同一个键调用<code class="fe mg mh mi lw b">set</code>，那么后面的<code class="fe mg mh mi lw b">set</code>调用中的值会覆盖前面的值。例如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f463" class="ma mb it lw b gy mc md l me mf">let messageMap = new Map();<br/>messageMap.set('hi', 'Hello');<br/>messageMap.set('greeting', 'How are you doing?');<br/>messageMap.set('bye', 'Bye');<br/>messageMap.set('hi', 'Hi');</span><span id="ecd8" class="ma mb it lw b gy mj md l me mf">console.log(messageMap.get('hi'))</span></pre><p id="6d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行<code class="fe mg mh mi lw b">console.log(messageMap.get(‘hi’))</code>，我们得到的是<code class="fe mg mh mi lw b">'Hi'</code>而不是<code class="fe mg mh mi lw b">'Hello'</code>。</p><p id="d857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要清除地图对象的所有条目，我们可以调用<code class="fe mg mh mi lw b">clear</code>函数，如下面的代码所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5b44" class="ma mb it lw b gy mc md l me mf">let messageMap = new Map();<br/>messageMap.set('hi', 'Hello');<br/>messageMap.set('greeting', 'How are you doing?');<br/>messageMap.set('bye', 'Bye');<br/>messageMap.set('hi', 'Hi');<br/>messageMap<!-- -->.clear();<br/>console.log(messageMap)<br/>console.log(messageMap.size)</span></pre><p id="8c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到当我们记录它时<code class="fe mg mh mi lw b">messageMap</code>应该是空的，并且它的<code class="fe mg mh mi lw b">size</code>应该是0。</p><p id="9542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以用一个<code class="fe mg mh mi lw b">for...of</code>循环迭代映射的条目。通过每个条目的析构赋值，我们可以使用类似于下面代码中的<code class="fe mg mh mi lw b">for...of</code>循环获得每个条目的键和值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="666b" class="ma mb it lw b gy mc md l me mf">let messageMap = new Map();<br/>messageMap.set('hi', 'Hello');<br/>messageMap.set('greeting', 'How are you doing?');<br/>messageMap.set('bye', 'Bye');</span><span id="51ff" class="ma mb it lw b gy mj md l me mf">for (let [key, value] of <!-- -->messageMap<!-- -->) {<br/>  console.log(`${key} - ${value}`);<br/>}</span></pre><p id="dcf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象和贴图在很多方面都是不同的。对象的键只能是字符串类型。在地图中，关键字可以是任何值。</p><p id="e5e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过objects中没有的属性<code class="fe mg mh mi lw b">size</code>轻松获得地图的大小。贴图的迭代顺序是元素的迭代顺序，而对象的键的迭代是不确定的。</p><p id="a4e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象有原型，所以对象中有默认键，而映射中没有。</p><p id="3168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望存储非字符串键，当运行时才知道这些键时，以及当所有键都是同一类型并且值也是同一类型(可能与键是同一类型，也可能不是同一类型)时，最好使用映射。</p><p id="fa34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mg mh mi lw b">entries</code>函数来获取地图的条目。例如，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="51bf" class="ma mb it lw b gy mc md l me mf">let messageMap = new Map();<br/>messageMap.set('hi', 'Hello');<br/>messageMap.set('greeting', 'How are you doing?');<br/>messageMap.set('bye', 'Bye');</span><span id="8c28" class="ma mb it lw b gy mj md l me mf">for (let [key, value] of <!-- -->messageMap.entries()<!-- -->) {<br/>  console.log(`${key} - ${value}`);<br/>}</span></pre><p id="c839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环遍历地图的条目。</p><p id="9869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe mg mh mi lw b">NaN</code>被认为与自身相等以及+0和-0也被认为相等之外，键的相等性检查主要遵循三重等于运算符的规则。该算法被称为同值零算法。</p><p id="8bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果我们有:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f431" class="ma mb it lw b gy mc md l me mf">const map = new Map();<br/>map.set(NaN, 'abc');</span></pre><p id="2e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们运行<code class="fe mg mh mi lw b">map.get(NaN)</code>，我们得到返回的<code class="fe mg mh mi lw b">'abc'</code>。另外，需要注意的是，我们可以像上面一样使用非字符串值作为键。例如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="251e" class="ma mb it lw b gy mc md l me mf">let messageMap = new Map();<br/>messageMap.set(1, 'Hello');<br/>messageMap.set(2, 'How are you doing?');<br/>messageMap.set(3, 'Bye');</span></pre><p id="3eb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们调用<code class="fe mg mh mi lw b">messageMap.get(1)</code>，我们得到<code class="fe mg mh mi lw b">'Hello'</code>。</p><p id="a2c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，由于键是通过检查三重等于操作符来检索的，而<code class="fe mg mh mi lw b">NaN</code>被认为等于自身，所以我们不能直接从对象键中获得您期望的值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e515" class="ma mb it lw b gy mc md l me mf">let messageMap = new Map();<br/>messageMap.set({ messageType: 'hi' }, 'Hello');<br/>messageMap.set({ messageType: 'greeting' }, 'How are you doing?');<br/>messageMap.set({ messageType: 'bye' }, 'Bye');<br/>const hi = messageMap.get({<br/>  messageType: 'hi'<br/>})</span><span id="3126" class="ma mb it lw b gy mj md l me mf">console.log(hi);</span></pre><p id="620d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">hi</code>将为<code class="fe mg mh mi lw b">undefined</code>，因为它不检查对象的内容是否相等。</p><p id="ad19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们先将Map转换为数组，然后再将其转换回Map，那么我们可以在Map上使用数组方法。例如，如果我们要将地图中的所有值乘以2，那么我们可以编写以下内容:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bb8d" class="ma mb it lw b gy mc md l me mf">let numMap = new Map();<br/>numMap.set('a', 1);<br/>numMap.set('b', 2);<br/>numMap.set('c', 3);</span><span id="55c0" class="ma mb it lw b gy mj md l me mf">let multipliedBy2Array = [...numMap].map(([key, value]) =&gt; ([key, value * 2]));</span><span id="1979" class="ma mb it lw b gy mj md l me mf">let newMap = new Map(multipliedBy2Array);</span><span id="6ae1" class="ma mb it lw b gy mj md l me mf">console.log(newMap)</span></pre><p id="24a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码中我们可以看到，我们可以使用spread操作符，通过将值从映射复制到数组，直接将映射转换为数组。</p><p id="3c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个条目由一个数组组成，其中键作为第一个元素，值作为第二个元素。然后我们可以对它调用<code class="fe mg mh mi lw b">map</code>,因为它是一个数组。然后，我们可以将每个值的条目乘以2，同时保持每个条目的数组结构相同，首先是键，其次是值。</p><p id="1684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以将它直接传递给<code class="fe mg mh mi lw b">Map</code>对象的构造函数，我们可以看到新的Map对象<code class="fe mg mh mi lw b">newMap</code>的所有值都乘以2，同时保持与<code class="fe mg mh mi lw b">numMap</code>相同的键。</p><p id="ff78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以组合多个Map，首先用spread操作符将它们放在同一个数组中，然后将它们组合成一个，然后将它传递给Map构造函数以生成一个新的Map对象。</p><p id="2e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c5b1" class="ma mb it lw b gy mc md l me mf">let numMap1 = new Map();<br/>numMap1.set('a', 1);<br/>numMap1.set('b', 2);<br/>numMap1.set('c', 3);<br/>numMap1.set('d', 3);<br/>numMap1.set('e', 4);<br/>numMap1.set('f', 5);<br/>numMap1.set('g', 6);<br/>numMap1.set('h', 7);<br/>numMap1.set('i', 8);<br/>numMap1.set('j', 9);<br/>numMap1.set('k', 10);<br/>numMap1.set('l', 11);</span><span id="dd53" class="ma mb it lw b gy mj md l me mf">let numMap2 = new Map();<br/>numMap2.set('m', 1);<br/>numMap2.set('n', 2);<br/>numMap2.set('o', 3);<br/>numMap2.set('p', 3);<br/>numMap2.set('q', 4);<br/>numMap2.set('r', 5);<br/>numMap2.set('s', 6);<br/>numMap2.set('t', 7);<br/>numMap2.set('u', 8);<br/>numMap2.set('v', 9);<br/>numMap2.set('w', 10);<br/>numMap2.set('x', 11);</span><span id="8fb5" class="ma mb it lw b gy mj md l me mf">let numMap3 = new Map();<br/>numMap3.set('y', 1);<br/>numMap3.set('z', 2);<br/>numMap3.set('foo', 3);<br/>numMap3.set('bar', 3);<br/>numMap3.set('baz', 4);</span><span id="106a" class="ma mb it lw b gy mj md l me mf">const combinedArray = [...numMap1, ...numMap2, ...numMap3];<br/>const combinedNumMap = new Map(combinedArray);</span></pre><p id="3ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们记录<code class="fe mg mh mi lw b">combinedNumMap</code>时，我们看到所有原始的键和值都完好无损，但是它们被组合到一个映射中。</p><p id="5c44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有重叠的键，那么后面插入的键会覆盖前面插入的值。例如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e547" class="ma mb it lw b gy mc md l me mf">let numMap1 = new Map();<br/>numMap1.set('a', 1);<br/>numMap1.set('b', 2);<br/>numMap1.set('c', 3);<br/>numMap1.set('d', 3);<br/>numMap1.set('e', 4);<br/>numMap1.set('f', 5);<br/>numMap1.set('g', 6);<br/>numMap1.set('h', 7);<br/>numMap1.set('i', 8);<br/>numMap1.set('j', 9);<br/>numMap1.set('k', 10);<br/>numMap1.set('l', 11);</span><span id="dd50" class="ma mb it lw b gy mj md l me mf">let numMap2 = new Map();<br/>numMap2.set('m', 1);<br/>numMap2.set('n', 2);<br/>numMap2.set('o', 3);<br/>numMap2.set('p', 3);<br/>numMap2.set('q', 4);<br/>numMap2.set('r', 5);<br/>numMap2.set('s', 6);<br/>numMap2.set('t', 7);<br/>numMap2.set('u', 8);<br/>numMap2.set('v', 9);<br/>numMap2.set('w', 10);<br/>numMap2.set('x', 11);</span><span id="5fab" class="ma mb it lw b gy mj md l me mf">let numMap3 = new Map();<br/>numMap3.set('y', 1);<br/>numMap3.set('z', 2);<br/>numMap3.set('a', 21);<br/>numMap3.set('b', 22);<br/>numMap3.set('c', 23);</span><span id="0c60" class="ma mb it lw b gy mj md l me mf">const combinedArray = [...numMap1, ...numMap2, ...numMap3];<br/>const combinedNumMap = new Map(combinedArray);</span></pre><p id="8af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们记录<code class="fe mg mh mi lw b">combinedNumMap</code>时，我们看到大部分原始的键和值都完好无损，但是它们被组合成了一个映射。但是，<code class="fe mg mh mi lw b">a</code>现在映射到21，<code class="fe mg mh mi lw b">b</code>现在映射到22，<code class="fe mg mh mi lw b">c</code>现在映射到23。</p><p id="bffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了映射，我们可以拥有键-值对，其中的键不是字符串。映射是可以按照插入键值对的顺序进行迭代的集合。</p><p id="f0a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们可以转换为数组，每个条目都是一个数组，第一个元素是键，第二个元素是值，这意味着我们可以将它们转换为数组，然后像数组方法一样使用arras操作。</p><p id="0648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用spread操作符像处理任何数组一样处理它们，然后再将它们转换回地图。我们可以使用<code class="fe mg mh mi lw b">set</code>函数添加更多的条目，使用<code class="fe mg mh mi lw b">get</code>函数获取给定键的值。</p><p id="e933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些值由关键字通过相同值为零算法检索，这意味着关键字由三重等于运算符匹配，除了-0和+0被视为相等，而<code class="fe mg mh mi lw b">NaN</code>被视为等于自身。</p></div></div>    
</body>
</html>