<html>
<head>
<title>Everything You Need to Know About Regular Expressions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于JavaScript中的正则表达式，你需要知道的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-you-need-to-know-about-regular-expressions-in-javascript-59807f758cbd?source=collection_archive---------7-----------------------#2020-03-19">https://betterprogramming.pub/everything-you-need-to-know-about-regular-expressions-in-javascript-59807f758cbd?source=collection_archive---------7-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="946a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个详细的指南应该可以回答你所有的正则表达式问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/473b711ae37e9cca1d5eec7cd7ed91cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*icNOH1eTNiKAuo7B"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jobsavelsberg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">工作拯救者</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ca05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式是软件开发的必需品。作为一名前端开发人员，你可以愉快地忽略它们的存在很长一段时间，但迟早你将不得不处理它们。</p><p id="6c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本指南中，您将找到关于JavaScript中正则表达式的所有信息。这篇文章的结构如下:</p><ul class=""><li id="9882" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">你能用正则表达式做什么？</li><li id="507c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">正则表达式是什么样子的？</li><li id="1f68" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何在javascript中定义正则表达式？</li><li id="13a6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">正则表达式是如何工作的？</li><li id="a771" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Javascript中的regex语法是什么？</li><li id="9a85" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何使用捕获和反向引用？</li><li id="a66e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">正则表达式是如何匹配的？</li><li id="60a9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何优化正则表达式？</li><li id="768f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">什么时候不使用正则表达式？</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3435" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">你能用正则表达式做什么？</h1><p id="8d00" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">可以把正则表达式看作是高速的、高性能的工具，它允许您在文本中查找和替换模式。使用正则表达式:</p><ul class=""><li id="3c7c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">您可以检查文本是否包含特定的子字符串或模式。</li><li id="e3d8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您可以找到并返回那些模式匹配。</li><li id="00ea" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您可以从文本中捕获这些子字符串。</li><li id="6562" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您可以修改捕获的子字符串。</li></ul><p id="198f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的文章列出了正则表达式在前端开发中的一些用例。</p><div class="nn no gp gr np nq"><a href="https://blog.bitsrc.io/6-handy-regular-expressions-every-front-end-developer-should-know-ac9e0c514b71" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">每个前端开发人员都应该知道的6个方便的正则表达式</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">利用正则表达式的强大功能来执行各种文本处理任务。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">blog.bitsrc.io</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="e575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数高级语言都使用正则表达式。JavaScript的正则表达式引擎基于Perl5正则表达式语法。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a9f8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">正则表达式是什么样子的？</h1><p id="69a5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下面是一个正则表达式的例子:<code class="fe of og oh oi b">/Medi[a-zA-Z]*/</code></p><p id="359e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着理解它是做什么的。</p><p id="f818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个正则表达式描述了一种以子字符串<code class="fe of og oh oi b">Medi</code>开头的单词模式。在本例中，<code class="fe of og oh oi b">Medium</code>、<code class="fe of og oh oi b">Media</code>、<code class="fe of og oh oi b">Medical</code>和<code class="fe of og oh oi b">Medi</code>将匹配。</p><p id="2cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自己试试<a class="ae ky" href="https://regex101.com/r/kjpTjX/1" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="db9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oj">注意:如果你还没有注意到，正则表达式是区分大小写的，例如</em> <code class="fe of og oh oi b"><em class="oj">medium</em></code> <em class="oj">就不会匹配。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c761" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何在JavaScript中定义正则表达式？</h1><p id="953c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">正则表达式是描述字符模式的对象。在JavaScript中，可以用两种不同的方式定义正则表达式:</p><ul class=""><li id="132a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用正则表达式文字，在一对斜杠<code class="fe of og oh oi b">/.../</code>内:</li></ul><p id="3233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">const myPattern = /Medi[a-zA-Z]*/;</code></p><ul class=""><li id="1a52" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">或者，通过构造一个<code class="fe of og oh oi b">RegExp</code>对象的实例:</li></ul><p id="aa75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">const myPattern = new RegExp (“Medi[a-zA-Z]*”);</code></p><p id="dd0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两种格式都会导致在变量<code class="fe of og oh oi b">myPattern</code>中创建相同的正则表达式。</p><h2 id="3cff" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">选项</strong></h2><p id="19c9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">除了表达式本身，正则表达式中还可以包含五个选项:</p><ul class=""><li id="d9c7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe of og oh oi b">i</code>:使正则表达式不区分大小写。例如，<code class="fe of og oh oi b">/Medi[a-zA-Z]*/i</code>将匹配所有情况。</li><li id="6970" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe of og oh oi b">g</code>:匹配模式的所有出现。当没有指定<code class="fe of og oh oi b">g</code>时，正则表达式将只匹配第一个匹配项。</li><li id="189b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe of og oh oi b">m</code>:允许多行文本匹配。</li><li id="2514" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe of og oh oi b">y</code>:启用粘性匹配；正则表达式通过尝试从最后一个匹配位置开始匹配来尝试字符串中的粘性匹配。</li><li id="90d5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe of og oh oi b">u</code>:允许使用Unicode点转义<code class="fe of og oh oi b">\u…</code>。</li></ul><p id="a8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<code class="fe of og oh oi b">RexExp</code>对象时，这些选项可以作为参数传递。例如:</p><p id="4810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">const myPattern = new RegExp (“Medi[a-zA-Z]*”, "ig");</code></p><p id="ba57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这相当于:</p><p id="dd58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">const myPattern = /Medi[a-zA-Z]*/ig;</code></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f0cd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">正则表达式是如何工作的？</h1><p id="c6b0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下面是简短的回答。可以把正则表达式想象成一个迷你程序，它描述一个模式并告诉机器要寻找什么。考虑到这一点，您应该不会感到惊讶:</p><ul class=""><li id="c3d7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">正则表达式定义了一组指令。在我们的例子中:“首先找到大写字母<code class="fe of og oh oi b">M</code>，然后找到小写字母<code class="fe of og oh oi b">i</code>，…等等”</li><li id="5102" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">正则表达式有一个输入(您试图搜索或替换的文本)，并可以输出您试图匹配的子集；</li><li id="8bdd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">正则表达式有一个语法，它们可以被编译、执行，甚至被优化以运行得更快！</li></ul><p id="dd3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向下滚动查看更长、更详细的答案！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2f51" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">JavaScript中的Regex语法是什么？</h1><h2 id="3491" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">精确匹配</strong></h2><p id="6d06" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">任何非特殊元字符或运算符的字母数字字符都将在<code class="fe of og oh oi b">regex</code>中匹配自身。</p><p id="3826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们前面的例子中，<code class="fe of og oh oi b">/Medi[a-zA-Z]*/</code> : <code class="fe of og oh oi b">M</code>是匹配自身的字符，与<code class="fe of og oh oi b">e</code>、<code class="fe of og oh oi b">d</code>、<code class="fe of og oh oi b">i</code>相同。</p><p id="01e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将一个字符放在另一个字符之后，表明我们要寻找的是<code class="fe of og oh oi b">M</code>，接着是<code class="fe of og oh oi b">e</code>，接着是<code class="fe of og oh oi b">d</code>，然后是<code class="fe of og oh oi b">i</code>。在这样一个例子中，<code class="fe of og oh oi b">Medo</code>将不匹配。</p><h2 id="ffe7" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">交替</strong></h2><p id="a7f4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果我们想要表达我们想要匹配<code class="fe of og oh oi b">a</code>或<code class="fe of og oh oi b">b</code>，我们可以使用管道操作符<code class="fe of og oh oi b">|</code>，正则表达式将看起来像这样<code class="fe of og oh oi b">/a|b/</code>。</p><h2 id="5ae3" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">匹配一类字符</strong></h2><p id="9f98" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在许多情况下，您不会想要匹配一个精确的字符，而是一个有限字符集中的一个字符。<code class="fe of og oh oi b">set</code>操作符允许我们这样做。</p><p id="ce88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe of og oh oi b">[abc]</code>字符集将匹配该集中的任何字符<code class="fe of og oh oi b">a</code>或<code class="fe of og oh oi b">b</code>或<code class="fe of og oh oi b">c</code>。如果我们在括号后面添加一个<code class="fe of og oh oi b">^</code>，集合<code class="fe of og oh oi b">[^abc]</code>将匹配除<code class="fe of og oh oi b">a</code>、<code class="fe of og oh oi b">b</code>和<code class="fe of og oh oi b">c</code>之外的任何字符。</p><p id="e6ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们前面的例子中，<code class="fe of og oh oi b">/Medi[a-zA-Z]*/</code> : <code class="fe of og oh oi b">[a-zA-Z]</code>是一个字符类，它匹配从<code class="fe of og oh oi b">a</code>到<code class="fe of og oh oi b">z</code>小写或大写的任何字符。</p><p id="e231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以写<code class="fe of og oh oi b">[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]</code>，但是使用破折号操作符<code class="fe of og oh oi b">-</code>，来自<code class="fe of og oh oi b">a through z</code>或<code class="fe of og oh oi b">A through Z</code>的任何字符，包括包含性和字典顺序，都将被匹配。</p><h2 id="8c87" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">逃逸</strong></h2><p id="4b5c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">并非正则表达式中的所有字符都代表它们自己。在我们前面的例子中，<code class="fe of og oh oi b">/Medi[a-zA-Z]*/</code> : <code class="fe of og oh oi b">*</code>是一个量词，它匹配集合<code class="fe of og oh oi b">[a-zA-Z]</code>中的一个字符，匹配次数在零到无限之间——尽可能多。</p><p id="14cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何指定我们想要匹配文字<code class="fe of og oh oi b">*</code>？</p><p id="7fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在regex中，当您想要指定一个文字字符时，可以使用反斜杠字符<code class="fe of og oh oi b">\</code>对其进行转义。如果要匹配<code class="fe of og oh oi b">*</code>，需要将<code class="fe of og oh oi b">\*</code>指定给正则表达式。如果要匹配文字反斜杠，需要指定<code class="fe of og oh oi b">\\</code>。</p><h2 id="a45c" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">开始和结束</strong></h2><p id="73ae" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在某些情况下，您可能希望确保模式匹配字符串的开头。如果我们回到前面的例子，<code class="fe of og oh oi b">/Medi[a-zA-Z]*/</code>，<code class="fe of og oh oi b">zdMedium</code>也是匹配的。如果我们想确保匹配以<code class="fe of og oh oi b">Medi</code>开始，我们所要做的就是在正则表达式的开头添加一个<code class="fe of og oh oi b">^</code>，就像这样:<code class="fe of og oh oi b">/^Medi[a-zA-Z]*/</code></p><p id="6dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，美元符号<code class="fe of og oh oi b">$</code>表示模式必须出现在字符串的末尾。</p><h2 id="3366" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">量词</strong></h2><p id="feff" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果我们想匹配两个<code class="fe of og oh oi b">m</code>字符的序列，我们可以写<code class="fe of og oh oi b">/mm/</code>。正则表达式允许我们指定匹配特定模式的次数。</p><p id="6659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe of og oh oi b">/m{2}/</code>表示两个连续字符的匹配。</p><p id="6d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，在我们的例子中<code class="fe of og oh oi b">/Medi[a-zA-Z]*/</code> : <code class="fe of og oh oi b">*</code>表示我们将尽可能多地匹配集合<code class="fe of og oh oi b">[a-zA-Z]</code>中的任何字符。</p><h2 id="b53a" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">预定义的字符类</strong></h2><p id="6f42" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一些字符类已经被预定义。例如，我们可能需要匹配数字。因此，预定义的<code class="fe of og oh oi b">\d</code>类将匹配任何十进制数字——这相当于<code class="fe of og oh oi b">[0-9].</code></p><p id="54af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他例子包括用于水平制表符的<code class="fe of og oh oi b">\t</code>和用于匹配换行符的<code class="fe of og oh oi b">\n</code>。</p><p id="763a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在Mozilla 的本指南中找到预定义字符类的备忘单。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e1d0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何使用捕获和反向引用</h1><p id="cef7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当括号将正则表达式的一部分括起来时，它会创建一个捕获。</p><p id="be26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要匹配一个HTML标签，我们可以使用如下所示的正则表达式:<code class="fe of og oh oi b">/&lt;([a-z]\w*)\b[^&gt;]*&gt;/</code></p><p id="8062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来分解一下。</p><ul class=""><li id="1b46" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">HTML标签以字符<code class="fe of og oh oi b">&lt;</code>开始，以<code class="fe of og oh oi b">&gt;</code>结束。</li><li id="2273" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe of og oh oi b">[a-z]</code>将匹配任何小写字母字符。</li><li id="25a6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe of og oh oi b">\w*</code>将匹配任何字母数字字符，包括下划线。</li><li id="fd04" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe of og oh oi b">\b</code>在单词边界断言位置。</li><li id="40b8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe of og oh oi b">[^&gt;]*</code>匹配除<code class="fe of og oh oi b">&gt;</code>以外的任何字符。</li></ul><p id="6eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个正则表达式将匹配:<code class="fe of og oh oi b">&lt;div&gt;, &lt;span&gt;, &lt;something&gt;, etc</code></p><p id="9549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们捕获标记的名称<code class="fe of og oh oi b">([a-z]\w*)</code>，正则表达式的这个部分将匹配它。比如<code class="fe of og oh oi b">div</code>、<code class="fe of og oh oi b">span</code>、<code class="fe of og oh oi b">something</code>。</p><p id="76dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自己试试<a class="ae ky" href="https://regex101.com/r/Bkfkjk/2" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="1e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们希望正则表达式匹配一个正确的HTML元素，它以一个标签开始，以同一个标签结束:<code class="fe of og oh oi b">&lt;div&gt;something&lt;/div&gt;</code>。</p><p id="3740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们希望能够引用我们之前捕获的标签。反向引用的符号是反斜杠，后跟要引用的捕获的编号:<code class="fe of og oh oi b">\1</code>。</p><p id="c11c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们只有一个捕获。为了匹配一个完整的HTML元素，正则表达式应该是这样的:<code class="fe of og oh oi b">/&lt;([a-z]\w*)\b[^&gt;]*&gt;.*?&lt;\/\1&gt;/</code>。</p><p id="9ed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这似乎令人困惑，但让我们来分解一下:</p><ul class=""><li id="139b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe of og oh oi b">.*?</code>将匹配任何字符，除了行终止符。</li><li id="cf94" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe of og oh oi b">&lt;\/\1&gt;</code>将匹配一个结束HTML标签:<code class="fe of og oh oi b">&lt;</code>匹配其文字本身，<code class="fe of og oh oi b">\/</code>匹配一个<code class="fe of og oh oi b">/</code>字符。<code class="fe of og oh oi b">\1</code>指回我们的捕获，<code class="fe of og oh oi b">&gt;</code>再次匹配它的字面自我。</li></ul><p id="264f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个正则表达式将匹配以下字符串:<code class="fe of og oh oi b">&lt;div&gt; &lt;i&gt;something&lt;/i&gt; &lt;/div&gt;</code>、<code class="fe of og oh oi b">&lt;span&gt;my span&lt;/span&gt;</code>等。</p><p id="7fd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe of og oh oi b">&lt;div&gt; something&lt;/other&gt;</code>这样的字符串不会匹配。</p><p id="2c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有反向引用，我们将无法匹配一个简单的HTML元素。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c597" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">正则表达式是如何匹配的？</h1><p id="9fda" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">JavaScript正则表达式引擎使用名为<em class="oj">非确定有限自动机</em>的模式匹配引擎。有限自动机(FA)是一种用于接受或拒绝符号串的计算模型。</p><p id="b0e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，FA由一组有限的状态组成，状态之间可能存在转换。在评估输入字符串时，引擎将通过评估和转换每个阶段来尝试匹配引擎的每个字符，直到到达结尾。</p><p id="4184" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到第一个例子:<code class="fe of og oh oi b">/Medi[a-zA-Z]*/</code>。如果我们将其表示为FA图，它看起来会像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/7688e69394b23723b04ddf01f940c416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4bOYh64nhXnCM9hHSRwZQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe of og oh oi b">/Medi[a-zA-Z]*/</code>的FA</p></figure><p id="47b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个例子。假设我们有下面的正则表达式:<code class="fe of og oh oi b">/Medi(um|cal|cine)/</code>。FA将会是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/cc012922ce62be96b8f811d01e0e3743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Q3nakbpj9T6nHqhpE2YzA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe of og oh oi b">/Medi(um|cal|cine)/</code>的FA</p></figure><p id="217d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用<code class="fe of og oh oi b">Medium</code>或<code class="fe of og oh oi b">Medical</code>或<code class="fe of og oh oi b">Medicine</code>测试这个正则表达式，它将遵循其中一个路径。然而，例如，如果正则表达式正在检查输入<code class="fe of og oh oi b">Medicinal</code>，它将首先将<code class="fe of og oh oi b">M</code>、<code class="fe of og oh oi b">e</code>、<code class="fe of og oh oi b">d</code>、<code class="fe of og oh oi b">i</code>与状态<code class="fe of og oh oi b">e</code>进行匹配，然后它将匹配<code class="fe of og oh oi b">c</code>并转换到状态<code class="fe of og oh oi b">k</code>，然后是<code class="fe of og oh oi b">l</code>。</p><p id="8218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在在<code class="fe of og oh oi b">Medicin</code>，下一个字母是<code class="fe of og oh oi b">a</code>并且自动机不匹配，所以我们不能转换到状态<code class="fe of og oh oi b">m</code>。自动机将返回到状态<code class="fe of og oh oi b">h</code>并尝试匹配另一条路径。那里不可能有匹配的。它将返回到状态<code class="fe of og oh oi b">e</code>，在那里不可能匹配。那么它就会失败。</p><p id="af27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FA被称为<em class="oj"> </em>非确定性，因为当试图匹配给定输入(例如<code class="fe of og oh oi b">Medicinal</code>)上的正则表达式时，输入字符串中的每个字符可能会被自动机的不同阶段检查几次。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="feec" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何优化正则表达式？</h1><p id="7997" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">即使在上面的简单示例中，您也看到了引擎在声明输入不匹配之前必须回溯几次。</p><p id="6ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优化正则表达式的一个重要部分是最小化引擎的回溯量。正如我们所见，引擎确定输入不匹配比确定成功匹配花费的时间更长。我们越早抛弃不匹配的输入越好。</p><p id="b47e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个著名的坏正则表达式的例子:<code class="fe of og oh oi b">/^(\w+\s?)*$/</code>。在这个例子中，我们试图用可选的空格字符<code class="fe of og oh oi b">\s?</code>来匹配单词<code class="fe of og oh oi b">\w+</code>。如果您尝试将它与这个字符串:<code class="fe of og oh oi b">this will not cause catastrophic back tracking</code>进行匹配，引擎将需要26个步骤来声明它是匹配的。然而，如果您试图评估下面的输入:<code class="fe of og oh oi b">this will cause catastrophic back tracking</code>，它将导致太多的回溯，可能需要使用100%的CPU。如果在浏览器中完成，用户界面将冻结，浏览器可能会重新加载页面。都是因为搞清楚<code class="fe of og oh oi b">.</code>不见了太多步骤。</p><p id="4e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了优化正则表达式，请记住以下几点。</p><h2 id="38c2" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated">明智地使用交替</h2><p id="94cc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">像<code class="fe of og oh oi b">/(A|B|C)/</code>这样的正则表达式以慢著称，当然，考虑到<code class="fe of og oh oi b">A</code>、<code class="fe of og oh oi b">B</code>和<code class="fe of og oh oi b">C</code>是正则表达式中需要回溯的复杂部分。</p><p id="fe8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，交替可以简化。不用写<code class="fe of og oh oi b">/(abc|abba)/</code>，在这种情况下<code class="fe of og oh oi b">abc</code>和<code class="fe of og oh oi b">abba</code>并不互斥，正则表达式可以简化成这样:<code class="fe of og oh oi b">/ab(c|ba)/</code>。这个正则表达式更快，因为引擎会尝试匹配<code class="fe of og oh oi b">ab</code>，如果不匹配就不会回溯。</p><h2 id="73d0" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">如果您打算使用</strong>中的文本，请仅捕获组</h2><p id="b0ac" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">捕获是regex的一个强大特性，但是如果您不打算使用提取的文本，就没有必要使用它们。</p><p id="b065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，我们不需要捕获<code class="fe of og oh oi b">c</code>或<code class="fe of og oh oi b">ba</code>。我们可以把它变成一个非捕获组，如下:<code class="fe of og oh oi b">/ab(?:c|ba)/</code></p><h2 id="db73" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">优化贪婪量词</strong></h2><p id="c9fc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">像<code class="fe of og oh oi b">*</code>或<code class="fe of og oh oi b">+</code>这样的贪婪量词会首先尝试匹配输入字符串中尽可能多的字符，即使这意味着输入字符串中没有足够的字符来匹配正则表达式的其余部分。如果发生这种情况，贪婪量词将回溯，返回字符，直到找到一个整体匹配或直到没有更多的字符。</p><p id="aff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，惰性量词会首先尝试匹配输入字符串中尽可能少的字符。</p><p id="7588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很多情况下，贪婪量词很容易被懒惰量词取代。假设你想优化像<code class="fe of og oh oi b">Med.*m</code>这样的正则表达式的一部分。</p><p id="1394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果字符<code class="fe of og oh oi b">m</code>位于输入字符串末尾附近，最好使用贪婪量词<code class="fe of og oh oi b">*</code>。如果字符位于输入字符串的开头附近，最好使用惰性量词<code class="fe of og oh oi b">*?</code>并将子表达式改为<code class="fe of og oh oi b">Med.*?m</code>。</p><h2 id="944a" class="ok mr it bd ms ol om dn mw on oo dp na li op oq nc lm or os ne lq ot ou ng ov bi translated"><strong class="ak">具体一点</strong></h2><p id="4fd7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">写正则表达式的时候，越具体越好。尽量少用像<code class="fe of og oh oi b">.*</code>这样的子表达式，因为它们会导致引擎大量回溯——特别是当表达式的其余部分与输入字符串不匹配时。</p><p id="6d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为替代，您应该使用更具体的字符类。这让您可以更好地控制<code class="fe of og oh oi b">*</code>将导致正则表达式引擎消耗多少字符，让您能够停止过多的回溯。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9d31" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">何时不使用正则表达式</h1><p id="3464" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">正则表达式通常用于验证用户的输入，但它们经常会导致糟糕的用户体验——尤其是当程序员对用户输入做出假设时。</p><p id="6691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为用户，我经常面临的一个问题是严格的电子邮件验证。一些表单希望电子邮件不包含<code class="fe of og oh oi b">+</code>符号。一些表单希望用户的姓名或电话号码限于某些字符。这种验证是没有用的，最终会让你的用户感到沮丧。</p><p id="1788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，正则表达式可能会很昂贵并且难以维护。当我使用<code class="fe of og oh oi b"><a class="ae ky" href="https://www.fluentd.org/" rel="noopener ugc nofollow" target="_blank">fluentld</a></code>解析一些数据库日志时，我已经亲身体验过了。当日志不如预期并且正则表达式无法匹配时，那个<code class="fe of og oh oi b">fluentld</code>容器定期达到100% CPU。每当容器停止工作时，我都需要尝试理解我几个月前编写的复杂正则表达式。</p><p id="2afc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你发现自己花了很多时间解析大文本，<a class="ae ky" href="https://wiki.haskell.org/Parsing_expressions_and_statements" rel="noopener ugc nofollow" target="_blank">你可能想考虑写一个解析器</a></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d86c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">进一步阅读</h1><ul class=""><li id="13a3" class="lv lw it lb b lc ni lf nj li oy lm oz lq pa lu ma mb mc md bi translated"><a class="ae ky" href="https://javascript.info/regular-expressions" rel="noopener ugc nofollow" target="_blank">https://javascript.info/regular-expressions</a></li><li id="3a62" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.regular-expressions.info/catastrophic.html" rel="noopener ugc nofollow" target="_blank">https://www.regular-expressions.info/catastrophic.html</a></li><li id="03e1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://swtch.com/~rsc/regexp/regexp1.html" rel="noopener ugc nofollow" target="_blank">https://swtch.com/~rsc/regexp/regexp1.html</a></li><li id="a0e8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.rexegg.com/regex-explosive-quantifiers.html" rel="noopener ugc nofollow" target="_blank">https://www.rexegg.com/regex-explosive-quantifiers.html</a></li><li id="dfa3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Regular _ Expressions/cheat sheet</a></li></ul></div></div>    
</body>
</html>