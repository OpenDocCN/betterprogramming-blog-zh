<html>
<head>
<title>The Whole Shebang: Compose Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整个事情:编写文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-whole-shebang-compose-files-5b6f50dd196c?source=collection_archive---------11-----------------------#2022-02-02">https://betterprogramming.pub/the-whole-shebang-compose-files-5b6f50dd196c?source=collection_archive---------11-----------------------#2022-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="317c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过理解和实践Docker Compose的每个可用选项，掌握多容器应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/459ccdf8161241e45dba2e4a7941e469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mH0yw7Pu6NdGGTlX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ventiviews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡梅隆通风</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e5e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近一直在写关于Docker和容器的文章。我非常感谢那些使用我的内容并提供反馈的人。我明白你的意思，很自然，下一个要解决的话题是Docker Compose——因为现在你已经知道如何构建自己的容器映像并运行它们，下一个逻辑里程碑是创建复杂的多容器应用程序，并将所有这些作为单个软件进行管理。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6107" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Docker Compose:它是什么，为什么我需要它？</h1><blockquote class="mu mv mw"><p id="e699" class="kz la mx lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated"><strong class="lb iu"> Compose </strong>是一个定义和运行多容器<strong class="lb iu"> Docker </strong>应用的工具。</p></blockquote><p id="7db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从<a class="ae ky" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中了解更多信息，但是为了简化，请考虑以下内容:您使用<strong class="lb iu"> Docker </strong>来管理容器、图像、卷等。当你做<code class="fe nb nc nd ne b">docker run</code>时，你基本上是在执行一个<strong class="lb iu">单个</strong>容器。如果您想启动第二个容器，以某种方式与第一个容器进行交互，您需要再次运行<code class="fe nb nc nd ne b">docker run</code>,并分别处理它们的卷和网络，这样它们就可以相互查看和通信。</p><p id="8e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker Compose通过在Docker之上提供一个<strong class="lb iu">包装器</strong>抽象了所有这些(是的！Docker Compose只是Docker的一个高级CLI)。事实上，您会看到大多数选项的命名方式与<code class="fe nb nc nd ne b">docker run</code>子命令中的选项非常相似。</p><p id="1ae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Docker Compose，您可以通过名为<strong class="lb iu"> Compose Files </strong>的YAML文件，以声明方式<strong class="lb iu">定义您的所有容器(在Docker Compose世界中称为<code class="fe nb nc nd ne b">services</code>…,因为您也可以在Swarm模式下使用Compose文件……但在另一篇文章中会有更多相关内容)、卷和网络及其配置。这样，每当你需要管理你的多容器应用程序时，你只需要接触这个compose文件，然后让Docker Compose处理其他的事情。</strong></p><h1 id="82c3" class="mc md it bd me mf nf mh mi mj ng ml mm jz nh ka mo kc ni kd mq kf nj kg ms mt bi translated">撰写文件</h1><p id="5394" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们将把Docker Compose CLI留给另一篇文章，因为首先，您需要学习如何编写Compose文件，以便能够正确地将多容器应用程序投入使用。</p><p id="208b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">compose files上的<a class="ae ky" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank">Docker docs</a>非常完整，但是我坚信实用主义和从经验中学习，所以我将整理所有的Compose File选项，并提供简单的解释和真实的例子——开始吧！</p><p id="8f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注1: </strong>我将只讨论compose files规范v3的选项和模式(这是撰写本文时的最新版本，所以应该没问题)</p><p id="7292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注2: </strong>对于每个选项，我将只解释和举例说明它们的常见用法(即我将使用我多年的Docker经验作为参考，因此如果有某个选项参数我从未使用过，我会将其视为“不常用”)。关于什么是可能的以及如何使用某个选项的不常用参数的更多细节，请查看<a class="ae ky" href="https://docs.docker.com/compose/compose-file/compose-file-v3/" rel="noopener ugc nofollow" target="_blank">正式文档</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d51b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在深入示例之前，请注意所有的合成文件都以关键字<code class="fe nb nc nd ne b">version</code>开头，表示我们正在编写的合成文件的模式。如上所述，我们的将是最新的(<code class="fe nb nc nd ne b">version: “3”</code>)。</p><h2 id="2de6" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">建设</h2><p id="630b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">基本上，当您开始使用Docker Compose时，您可以提供Docker图像或Docker文件。如果您希望Docker在启动相应的容器之前构建您的容器映像，而不必手动构建映像，那么您可以使用这个选项。</p><p id="2f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="e4cc" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;Dockerfile &lt;&lt;EOF<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="50d7" class="np md it ne b gy oj og l oh oi">CMD ["echo", "Hello Medium readers"]</span><span id="1ab3" class="np md it ne b gy oj og l oh oi"># End of the Dockerfile<br/>EOF<br/><strong class="ne iu">$<br/>$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="7198" class="np md it ne b gy oj og l oh oi">services:<br/>  my-test-container:<br/>    build: .<br/>EOF<br/><strong class="ne iu">$<br/>$ </strong>docker-compose up <br/>Creating network "mediumcom_default" with the default driver<br/>Building my-test-container<br/>Sending build context to Docker daemon  1.337MB<br/>Step 1/2 : FROM ubuntu<br/> ---&gt; ba6acccedd29<br/>Step 2/2 : CMD ["echo", "Hello Medium readers"]<br/> ---&gt; Using cache<br/> ---&gt; 6c8b22fa650c<br/>Successfully built 6c8b22fa650c<br/>Successfully tagged mediumcom_my-test-container:latest<br/>Creating mediumcom_my-test-container_1 ... done<br/>Attaching to mediumcom_my-test-container_1<br/>my-test-container_1  | Hello Medium readers<br/>mediumcom_my-test-container_1 exited with code 0<br/><strong class="ne iu">$</strong></span></pre><p id="b758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，Docker Compose指示Docker从我们的Dockerfile(位于与Compose文件相同的路径中)构建一个图像，然后自动启动我们的容器。</p><p id="a1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<strong class="lb iu"> </strong>正如您所料，您通常在<code class="fe nb nc nd ne b">docker build</code>中使用的一些选项也可以在这里使用，比如传递构建参数、指定docker文件的路径和名称等。查看<a class="ae ky" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#build" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多详情。</p><h2 id="39c7" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">图像</h2><p id="5f0e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">很明显，你不需要在每次启动应用程序时都构建Docker映像…那会很麻烦。所以你要么选择<code class="fe nb nc nd ne b">build</code>，要么简单地指定容器<code class="fe nb nc nd ne b">image</code>。</p><p id="e519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设前一个示例中的docker文件，并采用以下合成文件:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="508f" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong># just to clean the previous example<br/><strong class="ne iu">$ </strong># from here on, make sure this command is executed on every <strong class="ne iu"><br/>$ </strong>#<strong class="ne iu"> </strong>example, just for the sake of simplicity<br/><strong class="ne iu">$ </strong>docker-compose down -v --remove-orphans   <br/><strong class="ne iu">$<br/>$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="5db1" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    build: .</span><span id="c26d" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: hello-world<br/>EOF</span><span id="7f1e" class="np md it ne b gy oj og l oh oi"><strong class="ne iu">$ </strong># Dockerfile hasn't changed, so the 1st image won't be rebuilt<strong class="ne iu"><br/>$ docker-compose up </strong>   <br/>Creating network "mediumcom_default" with the default driver<br/>Creating <strong class="ne iu">mediumcom_first_1</strong>  ... done<br/>Creating <strong class="ne iu">mediumcom_second_1</strong> ... done<br/>Attaching to mediumcom_second_1, mediumcom_first_1<br/><strong class="ne iu">first_1   | Hello Medium readers</strong><br/>second_1  | <br/><strong class="ne iu">second_1  | Hello from Docker!</strong><br/>second_1  | This message shows that your installation appears to be working correctly.<br/>second_1  | <br/>second_1  | To generate this message, Docker took the following steps:<br/>second_1  |  1. The Docker client contacted the Docker daemon.<br/>second_1  |  2. The Docker daemon pulled the "hello-world" image from the Docker Hub.<br/>second_1  |     (amd64)<br/>second_1  |  3. The Docker daemon created a new container from that image which runs the<br/>second_1  |     executable that produces the output you are currently reading.<br/>second_1  |  4. The Docker daemon streamed that output to the Docker client, which sent it<br/>second_1  |     to your terminal.<br/>second_1  | <br/>second_1  | To try something more ambitious, you can run an Ubuntu container with:<br/>second_1  |  $ docker run -it ubuntu bash<br/>second_1  | <br/>second_1  | Share images, automate workflows, and more with a free Docker ID:<br/>second_1  |  <a class="ae ky" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/</a><br/>second_1  | <br/>second_1  | For more examples and ideas, visit:<br/>second_1  |  <a class="ae ky" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/get-started/</a><br/>second_1  | <br/>mediumcom_second_1 exited with code 0<br/>mediumcom_first_1 exited with code 0</span></pre><p id="dab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，现在我们已经在同一个多容器应用程序中，从单个合成文件和单个<code class="fe nb nc nd ne b">docker-compose</code>命令并行启动了2个容器。其中一个容器使用我们定制的Docker映像来表示“Hello Medium readers”，而另一个容器从Docker Hub中提取Docker映像“hello-world ”,并打印出自己的Hello World消息。</p><h2 id="2ea6" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">命令</h2><p id="4b90" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这允许您定义容器的命令。因此，如果您的Docker映像定义了一个入口点，这个命令将是它的参数。示例:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="9811" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="8501" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ubuntu<br/>    command: echo "I am at your command!"</span><span id="a40f" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Creating network "mediumcom_default" with the default driver<br/>Creating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/><strong class="ne iu">first_1  | I am at your command!<br/></strong>mediumcom_first_1 exited with code 0</span></pre><p id="3e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超级直白吧？</p><h2 id="6270" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">入口点</h2><p id="cf6d" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">顾名思义，它允许您(重新)定义容器的入口点。假设您希望您的容器作为一个<code class="fe nb nc nd ne b">echo</code>可执行文件运行:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="83ca" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="8c3d" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ubuntu<br/>    entrypoint: ["echo"]<br/>    command: "I am just an arg"</span><span id="d669" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Creating network "mediumcom_default" with the default driver<br/>Creating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/><strong class="ne iu">first_1  | I am just an arg</strong><br/>mediumcom_first_1 exited with code 0</span></pre><p id="cfe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单吧？如果你想知道<code class="fe nb nc nd ne b">command</code>对<code class="fe nb nc nd ne b">entrypoint</code>等等。，你不是唯一一个。这是一个非常典型的困惑点。我已经在我的另一篇文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-whole-shebang-dockerfiles-5d59ace94d28">“The Whole she bang:docker files”</a>中谈过了。简而言之，这是我在需要协调这两个选项时的备忘单:<a class="ae ky" href="https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/reference/builder/# understand-how-cmd-and-entry point-interact</a></p><h2 id="04c9" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">cap_add</h2><p id="8638" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如果您的容器需要额外的功能，您可以这样添加它们:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="b0ea" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="5602" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ubuntu:14.04<br/>    command: <!-- -->ip link add dummy0 type dummy<br/>    cap_add:<br/>     - NET_ADMIN</span><span id="cc91" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>mediumcom_first_1 <strong class="ne iu">exited with code 0</strong></span></pre><p id="1c21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您要运行与上面相同的容器，但是没有该功能，您会得到一个错误:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="a9d3" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="4c25" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ubuntu:14.04<br/>    command: <!-- -->ip link add dummy0 type dummy</span><span id="d1ed" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/><strong class="ne iu">first_1  | RTNETLINK answers: Operation not permitted</strong><br/>mediumcom_first_1 <strong class="ne iu">exited with code 2</strong></span></pre><h2 id="5618" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">cap_drop</h2><p id="fed9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">与<code class="fe nb nc nd ne b">cap_add</code>完全相反。使用它从容器中删除功能。假设我们有一个超级特权容器:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="4e11" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="64ea" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ubuntu:14.04<br/>    command: <!-- -->ip link add dummy0 type dummy<br/>    cap_add:<br/>     - <strong class="ne iu">ALL</strong></span><span id="8e3c" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>mediumcom_first_1 exited with code <strong class="ne iu">0</strong></span></pre><p id="546f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们不希望它管理主机的网络堆栈:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="1021" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="f49b" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ubuntu:14.04<br/>    command: <!-- -->ip link add dummy0 type dummy<br/>    cap_add:<br/>     - ALL<br/>    cap_drop:<br/>     - NET_ADMIN</span><span id="355c" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | <strong class="ne iu">RTNETLINK answers: Operation not permitted</strong><br/>mediumcom_first_1 exited with code 2</span></pre><h2 id="7684" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">cgroup_parent</h2><p id="b258" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如果你是第一次接触<code class="fe nb nc nd ne b">cgroups</code>，这里有一篇关于它们的很好的短文<a class="ae ky" href="https://medium.com/@asishrs/docker-limit-resource-utilization-using-cgroup-parent-72a646651f9d" rel="noopener"/>。简而言之，Linux内核为用户提供了通过控制组(又名<code class="fe nb nc nd ne b">cgroups</code>)按进程严格控制系统资源使用的能力。在Docker中，这意味着您可以控制容器可以使用多少特定资源。默认情况下，容器会尽可能多地获取资源:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="ad5c" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="e3a0" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ubuntu<br/>    command: <!-- -->sleep 30</span><span id="0dff" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d <br/>Creating network "root_default" with the default driver<br/>Creating <strong class="ne iu">root_first_1</strong> ... done<br/><strong class="ne iu">$ </strong>docker inspect root_first_1 --format '{{.HostConfig.CgroupParent}}'</span><span id="32ee" class="np md it ne b gy oj og l oh oi"><strong class="ne iu">$</strong></span></pre><p id="dd98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，默认情况下，没有为容器分配控制组。但是我们可以指定一个。我们甚至可以分配我们自己的:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="7a1c" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cgcreate -g cpu:test-cgroup-medium<br/><strong class="ne iu">$ </strong>ls /sys/fs/cgroup/cpu<br/>cgroup-limit           cgroup.sane_behavior  cpu.shares    cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  release_agent  <strong class="ne iu">test-cgroup-medium</strong><br/>cgroup.clone_children  cpu.cfs_period_us     cpu.stat      cpuacct.usage_all     cpuacct.usage_percpu_user  docker              system.slice   user.slice<br/>cgroup.procs           cpu.cfs_quota_us      cpuacct.stat  cpuacct.usage_percpu  cpuacct.usage_sys          notify_on_release   tasks</span></pre><p id="c1ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用这个选项，我们将能够通过<code class="fe nb nc nd ne b">cgroup</code> "cpu:test-cgroup-medium ":</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="1a9a" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="1141" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ubuntu<br/>    command: <!-- -->sleep 30<br/>    cgroup_parent: "<!-- -->cpu:test-cgroup-medium"</span><span id="29a8" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d <br/><strong class="ne iu">Recreating root_first_1</strong> ... done<br/><strong class="ne iu">$ </strong>docker inspect root_first_1 --format '{{.HostConfig.CgroupParent}}'<br/><strong class="ne iu">cpu:test-cgroup-medium<br/>$</strong></span></pre><h2 id="ea19" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">容器名称</h2><p id="61e9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这个选项没有火箭科学可言。它基本上允许您修改Docker合成部署产生的容器的名称。</p><p id="f028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，默认情况下，Docker Compose会为您的容器添加一个后缀，与Docker Compose项目的名称相匹配(如果您没有明确指定这个项目的名称，Docker Compose会将您的当前路径作为默认路径)。</p><p id="91f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您想覆盖这个Docker组合行为，并为生成的容器修改您自己的自定义名称，您可以使用container_name。示例:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="2ded" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="4242" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ubuntu<br/>    container_name: my-own-container-name</span><span id="8ba9" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Creating network "mediumcom_default" with the default driver<br/>Creating <strong class="ne iu">my-own-container-name</strong> ... done<br/>Attaching to <strong class="ne iu">my-own-container-name</strong><br/><strong class="ne iu">my-own-container-name</strong> exited with code 0</span></pre><p id="0035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> P.S.: </strong>是的，正如您可能想知道的那样，这个Docker Compose部署中的其他容器可以通过容器名相互联系。示例:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="3b25" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="ca0e" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 5<br/>    container_name: my-own-container-name</span><span id="d86d" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: ping -c 1 my-own-container-name</span><span id="6831" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Recreating my-own-container-name ... done<br/>Creating mediumcom_second_1      ... done<br/>Attaching to mediumcom_second_1, my-own-container-name<br/>second_1  | PING my-own-container-name (172.18.0.3): 56 data bytes<br/>second_1  | 64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.743 ms<br/>second_1  | <br/>second_1  | --- my-own-container-name ping statistics ---<br/>second_1  | 1 packets transmitted, 1 packets received, 0% packet loss<br/>second_1  | round-trip min/avg/max = 0.743/0.743/0.743 ms<br/>mediumcom_second_1 exited with code 0<br/>my-own-container-name exited with code 0</span></pre><h2 id="d75f" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">依赖于</h2><p id="4591" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">让我先说<strong class="lb iu">不</strong>，这个选项<strong class="lb iu">不能让你控制你的容器<strong class="lb iu">应用</strong>的启动顺序！这是一个常见的错误。但是请想一想…您的容器内部正在运行一个或多个进程，因此假设Docker(管理所述容器的人)完全了解在容器内部运行的任何应用程序/进程的商业智能是幼稚的。</strong></p><p id="4c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个细微的差别，但是这个选项的作用是指示Docker Compose以什么顺序开始/停止容器。</p><p id="811d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="ee2d" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="ca0d" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    depends_on:<br/>     - second</span><span id="0ae0" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    depends_on:<br/>     - first</span><span id="6112" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Creating network "mediumcom_default" with the default driver<br/>Creating <strong class="ne iu">mediumcom_second_1</strong> ... done<br/>Creating <strong class="ne iu">mediumcom_first_1</strong>  ... done<br/>Attaching to mediumcom_second_1, mediumcom_first_1<br/>mediumcom_second_1 exited with code 0<br/>mediumcom_first_1 exited with code 0</span></pre><p id="b80a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到了吗？因为<code class="fe nb nc nd ne b">first</code>依赖于<code class="fe nb nc nd ne b">second</code>，所以<code class="fe nb nc nd ne b">second</code>容器会先启动，然后<code class="fe nb nc nd ne b">first</code>才会启动。同样的，当你阻止他们的时候——<code class="fe nb nc nd ne b">second</code>会最后倒下，因为<code class="fe nb nc nd ne b">first</code>就靠它了！</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="c6fd" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$</strong> docker-compose down<br/>Removing <strong class="ne iu">mediumcom_first_1</strong>  ... done<br/>Removing <strong class="ne iu">mediumcom_second_1</strong> ... done<br/>Removing network mediumcom_default</span></pre><p id="fc89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">附:</strong>如果你陷入混乱，而你使<code class="fe nb nc nd ne b">second</code>也依赖<code class="fe nb nc nd ne b">first</code>怎么办？😝别担心，Docker很聪明，会告诉你这样的话:</p><blockquote class="mu mv mw"><p id="1cbf" class="kz la mx lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">错误:第一个和第二个之间存在循环依赖</p></blockquote><h2 id="5051" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">卷</h2><p id="bfab" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我不会深入解释Docker卷。这是<a class="ae ky" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">相当大的话题</a>。假设您有4种方法来管理容器应用程序中的数据:</p><ol class=""><li id="16de" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">将所有数据保留在容器的可写层中(无卷)</li><li id="76a8" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">在主机和容器之间创建一个装载点(绑定装载)</li><li id="fe75" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">创建专用的Docker资源来托管和管理数据，独立于容器的生命周期(卷)</li><li id="bb03" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">通过不保存任何数据，而是将数据保存在内存中(tmpfs)来优化容器的性能。</li></ol><p id="b800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，尽管如此，您显然可以从合成文件中管理所有这些类型的卷。到目前为止，上面所有的例子都利用了容器的可写层。但是我们可以使用剩余的3个数据管理选项，如下所示:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="da4b" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="70f4" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: ls /<br/>    volumes:<br/>     - /:/my-hostfs<br/>     - my-volume:/my-volume<br/>     - type: tmpfs<br/>       target: /my-tmpfs</span><span id="1ac2" class="np md it ne b gy oj og l oh oi">volumes:<br/>  my-volume:</span><span id="ace1" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Creating network "test_default" with the default driver<br/>Creating volume "test_my-volume" with default driver<br/>Creating test_first_1 ... done<br/>Attaching to test_first_1<br/>first_1  | bin<br/>first_1  | dev<br/>first_1  | etc<br/>first_1  | home<br/>first_1  | lib<br/>first_1  | media<br/>first_1  | mnt<br/>first_1  | <strong class="ne iu">my-hostfs</strong><br/>first_1  | <strong class="ne iu">my-tmpfs</strong><br/>first_1  | <strong class="ne iu">my-volume</strong><br/>first_1  | opt<br/>first_1  | proc<br/>first_1  | root<br/>first_1  | run<br/>first_1  | sbin<br/>first_1  | srv<br/>first_1  | sys<br/>first_1  | tmp<br/>first_1  | usr<br/>first_1  | var<br/>test_first_1 exited with code 0</span></pre><p id="5bbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就对了，三种不同类型的坐骑一气呵成。顺便说一下，你可能已经注意到我使用了3种不同的语法…你可以选择你喜欢的，或者最适合你的坐骑的(在这里阅读更多关于它们的信息<a class="ae ky" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#short-syntax-3" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="10c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<code class="fe nb nc nd ne b">tmpfs</code>也可以通过专用选项设置…阅读下一节的示例。</p><h2 id="8361" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">tmpfs</h2><p id="0993" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这在上一节中已经描述过了，但是正如您所知道的，这只是为您的容器设置非持久挂载点的另一种更简单的方法:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="65bc" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="d6b4" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: ls /<br/>    tmpfs: /my-tmpfs</span><span id="3892" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$</strong> docker-compose up<br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | bin<br/>first_1  | dev<br/>first_1  | etc<br/>first_1  | home<br/>first_1  | lib<br/>first_1  | media<br/>first_1  | mnt<br/><strong class="ne iu">first_1  | my-tmpfs<br/></strong>first_1  | opt<br/>first_1  | proc<br/>first_1  | root<br/>first_1  | run<br/>first_1  | sbin<br/>first_1  | srv<br/>first_1  | sys<br/>first_1  | tmp<br/>first_1  | usr<br/>first_1  | var<br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="8dea" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">设备</h2><p id="1988" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">顾名思义，它允许您访问用于管理系统设备的容器。你有理由怀疑这与直装订有什么不同。你可以简单地把一个设备绑定到你的容器上，对吗？嗯，是也不是…这取决于你的容器是如何处理那个设备的。设备文件与常规文件和目录略有不同(即使它们看起来像您的<code class="fe nb nc nd ne b">/dev</code>文件夹下的普通文件)。设备文件提供了到设备驱动程序和物理设备的接口，因此具有更细粒度的访问控制，这通过<code class="fe nb nc nd ne b">cgroups</code>来管理(你可以在这里阅读更多关于它的<a class="ae ky" href="https://www.kernel.org/doc/Documentation/cgroup-v1/devices.txt" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="29b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，简而言之，如果您的容器没有运行在特权模式下，您仍然可以通过这个选项授予您的容器对特定设备文件的访问权限。</p><p id="6abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的电脑上安装了一个网络摄像头，</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="ebc5" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>lsusb -s 001:003<br/>Bus 001 Device 003: ID 046d:0826 <strong class="ne iu">Logitech, Inc. HD Webcam C525</strong></span></pre><p id="7544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想在集装箱里用它来拍照。然后考虑以下场景:</p><ul class=""><li id="2ef7" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu oy oq or os bi translated">首先，让我们尝试从容器内部访问网络摄像头，不应用任何选项</li></ul><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="f973" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="7d95" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ccordeiro/fswebcam:armv7l<br/>    command: fswebcam -r 640x480 --jpeg 85 -D 1 picture.jpg</span><span id="e2b0" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Creating network "tmp_default" with the default driver<br/>Creating tmp_first_1 ... done<br/>Attaching to tmp_first_1<br/>first_1  | --- Opening /dev/video0...<br/><strong class="ne iu">first_1  | stat: No such file or directory<br/>first_1  | tmp_first_1 exited with code 0</strong></span></pre><p id="bc59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…但显然，容器对任何设备都不可见…</p><ul class=""><li id="1af5" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu oy oq or os bi translated">其次，让我们尝试直接绑定挂载设备文件</li></ul><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="9627" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="3170" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ccordeiro/fswebcam:armv7l<br/>    command: fswebcam -r 640x480 --jpeg 85 -D 1 picture.jpg<br/>    volumes:<br/>     - /dev/video0:/dev/video0</span><span id="245b" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Recreating tmp_first_1 ... done<br/>Attaching to tmp_first_1<br/>first_1  | --- Opening /dev/video0...<br/>first_1  | Trying source module v4l2...<br/><strong class="ne iu">first_1  | Error opening device: /dev/video0<br/>first_1  | open: Operation not permitted<br/></strong>first_1  | Trying source module v4l1...<br/><strong class="ne iu">first_1  | Error opening device: /dev/video0<br/>first_1  | open: Operation not permitted<br/></strong>first_1  | Unable to find a source module that can read /dev/video0.<br/>first_1  | tmp_first_1 exited with code 0</span></pre><p id="f6e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…嗯，容器可以看到它，但是它有访问它的权利。</p><ul class=""><li id="3e7b" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu oy oq or os bi translated">最后，让我们使用<code class="fe nb nc nd ne b">device</code></li></ul><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="4203" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="8792" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: ccordeiro/fswebcam:armv7l<br/>    command: fswebcam -r 640x480 --jpeg 85 -D 1 picture.jpg<br/>    devices:<br/>     - /dev/video0:/dev/video0</span><span id="bc68" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Recreating tmp_first_1 ... done<br/>Attaching to tmp_first_1<br/>first_1  | --- Opening /dev/video0...<br/>first_1  | Trying source module v4l2...<br/>first_1  | /dev/video0 opened.<br/>first_1  | No input was specified, using the first.<br/>first_1  | Delaying 1 seconds.<br/>first_1  | --- Capturing frame...<br/>first_1  | Captured frame in 0.00 seconds.<br/><strong class="ne iu">first_1  | --- Processing captured image...<br/>first_1  | Setting output format to JPEG, quality 85<br/>first_1  | Writing JPEG image to 'picture.jpg'.<br/></strong>first_1  | tmp_first_1 exited with code 0</span></pre><p id="8172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们成功了！</p><h2 id="cce6" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">网络模式</h2><p id="89bf" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">你可能知道，Docker的联网系统是基于<a class="ae ky" href="https://docs.docker.com/network/" rel="noopener ugc nofollow" target="_blank">联网驱动</a>的。使用此选项，您可以指定容器应该以哪种网络模式运行。</p><p id="ca2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们要部署4个容器:1个在默认桥接网络中，1个在主机网络中，1个在与第一个相同的网络中，1个没有任何网络。你应该这样做:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="0463" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="a7e9" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sh -c 'ifconfig eth0 &amp;&amp; sleep 5'<br/>    network_mode: bridge</span><span id="3fde" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: ifconfig eth0<br/>    network_mode: host</span><span id="7c92" class="np md it ne b gy oj og l oh oi">  third:<br/>    image: alpine<br/>    command: ifconfig eth0<br/>    depends_on:<br/>     - first<br/>    network_mode: service:first</span><span id="72d9" class="np md it ne b gy oj og l oh oi">  fourth:<br/>    image: alpine<br/>    command: ifconfig eth0<br/>    network_mode: none</span><span id="bf09" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Creating mediumcom_first_1  ... done<br/>Creating mediumcom_fourth_1 ... done<br/>Creating mediumcom_second_1 ... done<br/>Creating mediumcom_third_1  ... done<br/>Attaching to mediumcom_second_1, mediumcom_fourth_1, mediumcom_first_1, mediumcom_third_1<br/><strong class="ne iu">first_1   | eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  <br/>first_1   |           inet addr:172.17.0.2</strong>  <strong class="ne iu">Bcast:172.17.255.255  Mask:255.255.0.0</strong><br/><strong class="ne iu">...</strong><br/><strong class="ne iu">fourth_1  | ifconfig: eth0: error fetching interface information: Device not found<br/>...<br/>second_1  | eth0      Link encap:Ethernet  HWaddr 02:50:00:00:00:01  <br/>second_1  |           inet addr:192.168.65.3  Bcast:192.168.65.255  Mask:255.255.255.0</strong><br/>...<br/><strong class="ne iu">third_1   | eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  <br/>third_1   |           inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</strong><br/>...<br/>mediumcom_fourth_1 exited with code 1<br/>mediumcom_second_1 exited with code 0<br/>mediumcom_third_1 exited with code 0<br/>mediumcom_first_1 exited with code 0</span></pre><p id="204d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了什么事？让我们来分解一下:</p><ul class=""><li id="80a0" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu oy oq or os bi translated"><code class="fe nb nc nd ne b">first</code>容器进入网桥模式，因此被分配了自己的<code class="fe nb nc nd ne b">eth0</code>专用网络接口(IP 172.17.0.2，是Docker网桥子网的一部分)</li><li id="8921" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu oy oq or os bi translated"><code class="fe nb nc nd ne b">second</code>容器进入主机模式，这意味着它运行在与主机相同的网络级别，因此可以看到主机的所有网络接口，包括主机的eth0 IP</li><li id="be0d" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu oy oq or os bi translated"><code class="fe nb nc nd ne b">third</code>集装箱和<code class="fe nb nc nd ne b">first</code>集装箱被赋予相同的网络</li><li id="e077" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu oy oq or os bi translated"><code class="fe nb nc nd ne b">fourth</code>容器没有网络，因此它无法找到<code class="fe nb nc nd ne b">eth0</code>接口。</li></ul><h2 id="0e0b" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated"><strong class="ak">网络</strong></h2><p id="99cc" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">现在，回到上面的选项，如果您想将您的容器连接到一个用户定义的网络(现有的或新的)，该怎么办呢？嗯，用<code class="fe nb nc nd ne b">networks</code>:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="831c" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>docker network create cjdc-test<br/>0f5e35bf6b8d396c45c19545540957fbc5fa15ba1ca0e5fbca4add3802c7db6d<br/><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="8668" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 30<br/>    networks:<br/>     - new-net</span><span id="a535" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: sleep 30<br/>    networks:<br/>     - cjdc-test</span><span id="58e1" class="np md it ne b gy oj og l oh oi">networks:<br/>  new-net:<br/>  cjdc-test:<br/>    external: true<br/>    name: cjdc-test</span><span id="1129" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/><strong class="ne iu">Creating network "mediumcom_new-net</strong>" with the default driver<br/>Creating mediumcom_second_1 ... done<br/>Creating mediumcom_first_1  ... done<br/><strong class="ne iu">$ </strong>docker inspect --format '{{.NetworkSettings.Networks}}' mediumcom_first_1<br/>map[<strong class="ne iu">mediumcom_new-net</strong>:0xc0004d8f00]<br/><strong class="ne iu">$ </strong>docker inspect --format '{{.NetworkSettings.Networks}}' mediumcom_second_1<br/>map[<strong class="ne iu">cjdc-test</strong>:0xc0003e8f00]</span></pre><h2 id="121c" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">十进位计数制</h2><p id="2686" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">它基本上让你为你的容器定义一个定制的DNS服务器。示例:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="ae46" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="9a23" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: cat /etc/resolv.conf<br/>    dns: 1.2.3.4<br/>    network_mode: bridge</span><span id="665b" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | nameserver <strong class="ne iu">1.2.3.4</strong><br/>mediumcom_first_1 exited with code 0</span></pre><p id="9aad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>注意需要有一个桥接网络，因为对于用户定义的网络来说,<code class="fe nb nc nd ne b">dns</code>选项不会有这样的行为。</p><h2 id="4f3c" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">dns_search</h2><p id="c58e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这样，您可以设置自己的自定义DNS搜索域。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="4538" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="d303" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: cat /etc/resolv.conf<br/>    dns_search: my.custom.dns<br/>    network_mode: bridge</span><span id="1c0e" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | search <strong class="ne iu">my.custom.dns</strong><br/>first_1  | nameserver 192.168.65.5<br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="834f" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">环境文件</h2><p id="7999" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">您可能习惯于一次设置一个变量的容器环境，但是您可以使用一个文件来一次性完成这项工作:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="259b" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;my-env &lt;&lt;EOF<br/>VAR1=value<br/>MY_VAR_FROM_FILE=1<br/>FOO=BAR<br/>EOF</span><span id="664b" class="np md it ne b gy oj og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="2eea" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: env<br/>    env_file:<br/>     - my-env</span><span id="688c" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br/>first_1  | HOSTNAME=157e34e4fc64<br/>first_1  | <strong class="ne iu">VAR1=value</strong><br/>first_1  | <strong class="ne iu">MY_VAR_FROM_FILE=1</strong><br/>first_1  | <strong class="ne iu">FOO=BAR</strong><br/>first_1  | HOME=/root<br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="3335" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">环境</h2><p id="bade" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这样，您可以直接在合成文件中一个接一个地为容器设置环境变量。</p><p id="2537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以用它来覆盖通过<code class="fe nb nc nd ne b">env_file</code>选项加载的变量。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="434b" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="67dd" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: env<br/></span><span id="4cf5" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br/>first_1  | HOSTNAME=68e909013198<br/>first_1  | <strong class="ne iu">NEW_VAR=yes</strong><br/>first_1  | HOME=/root<br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="7486" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">揭露</h2><p id="717a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">与Dockerfiles非常相似，这个选项只是简单地标记一个容器的端口，并使它们对其他链接的容器可用。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="d894" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="c6bb" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 20<br/>    expose:<br/>     - 9876</span><span id="45d4" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Recreating mediumcom_first_1 ... done<br/><strong class="ne iu">$ </strong>docker ps<br/>CONTAINER ID   IMAGE     COMMAND      CREATED          STATUS          PORTS      NAMES<br/>3be377f4bf6c   alpine    "sleep 20"   18 seconds ago   Up 16 seconds   <strong class="ne iu">9876/tcp</strong>   mediumcom_first_1</span></pre><h2 id="3bf1" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">外部链接</h2><p id="f82f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><em class="mx">让我们跳过这一个原因1)它是一个遗留选项，2)您可以使用网络来实现相同的结果(即，通过</em> <code class="fe nb nc nd ne b"><em class="mx">external</em></code> <em class="mx"> </em> <strong class="lb iu"> <em class="mx">网络</em> </strong> <em class="mx">，将您的容器连接到您的合成文件之外的其他容器)。</em></p><h2 id="49e3" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">额外主机</h2><p id="51a3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这基本上允许您向容器的<code class="fe nb nc nd ne b">/etc/hosts</code>文件添加一个新条目。例如，如果你想让你的容器在内部给自己起一个别的名字，而不仅仅是“localhost ”,你可以这样做:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="3257" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="d472" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sh -c 'cat /etc/hosts; ping me -c 1'<br/>    extra_hosts:<br/>     - "myself:127.0.0.1"<br/>     - "me:127.0.0.1"</span><span id="e057" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | 127.0.0.1 localhost<br/>first_1  | ::1 localhost ip6-localhost ip6-loopback<br/>first_1  | fe00::0 ip6-localnet<br/>first_1  | ff00::0 ip6-mcastprefix<br/>first_1  | ff02::1 ip6-allnodes<br/>first_1  | ff02::2 ip6-allrouters<br/><strong class="ne iu">first_1  | 127.0.0.1 myself<br/>first_1  | 127.0.0.1 me</strong><br/>first_1  | 172.22.0.2 01d566c4380a<br/>first_1  | PING <strong class="ne iu">me</strong> (127.0.0.1): 56 data bytes<br/>first_1  | 64 bytes from 127.0.0.1: seq=0 ttl=64 time=1.192 ms<br/>first_1  | <br/>first_1  | --- me ping statistics ---<br/>first_1  | <strong class="ne iu">1 packets transmitted, 1 packets received, 0% packet loss</strong><br/>first_1  | round-trip min/avg/max = 1.192/1.192/1.192 ms<br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="881c" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">健康检查</h2><p id="f7d7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">正如所料，这与同名的Dockerfile选项非常相似。它允许您创建一个自定义检查，Docker可以用它来评估您的容器是否“健康”。</p><p id="0752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，假设只有当在<code class="fe nb nc nd ne b">/tmp</code>有一个名为<code class="fe nb nc nd ne b">medium.txt</code>的文件时，我们的容器才是健康的。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="128b" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="6847" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sh -c 'touch /tmp/NOT_MY_FILE; sleep 10'<br/>    healthcheck:<br/>      test: "[ -f /tmp/medium.txt ]"<br/>      # run asap<br/>      interval: 1s<br/>      timeout: 5s<br/>      retries: 1<br/>      start_period: 0s</span><span id="5ebc" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: sh -c 'touch /tmp/medium.txt; sleep 10'<br/>    healthcheck:<br/>      test: "[ -f /tmp/medium.txt ]"<br/>      # run asap<br/>      interval: 1s<br/>      timeout: 5s<br/>      retries: 1<br/>      start_period: 0s</span><span id="ac45" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Recreating mediumcom_first_1 ... done<br/>Creating mediumcom_second_1  ... done<br/><strong class="ne iu">$ </strong>docker ps<br/>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS                     PORTS     NAMES<br/>b8804cbb440d   alpine    "sh -c 'touch /tmp/N…"   4 seconds ago   Up 2 seconds (<strong class="ne iu">unhealthy</strong>)             <strong class="ne iu">mediumcom_first_1</strong><br/>604a6880f3c6   alpine    "sh -c 'touch /tmp/m…"   4 seconds ago   Up 2 seconds (<strong class="ne iu">healthy</strong>)               <strong class="ne iu">mediumcom_second_1</strong></span></pre><p id="1bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，<code class="fe nb nc nd ne b">first</code>不正常，但<code class="fe nb nc nd ne b">second</code>正常，因为所需的文件存在于正确的位置。</p><h2 id="1e19" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">初始化</h2><p id="e510" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">有了这个，你可以告诉Docker是否为你的容器使用一个<code class="fe nb nc nd ne b">init</code>。如果是<code class="fe nb nc nd ne b">true</code>，Docker将使用基于<a class="ae ky" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank"><em class="mx"/></a>的init调用<code class="fe nb nc nd ne b">docker-init</code>。让我们来看看不同之处:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="43a2" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="0ea6" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: ps -a<br/>    init: false</span><span id="c2c1" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | PID   USER     TIME  COMMAND<br/>first_1  |     1 root      0:00 <strong class="ne iu">ps -a</strong><br/>mediumcom_first_1 exited with code 0</span></pre><p id="8e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果您启用了一个<code class="fe nb nc nd ne b">init</code>，那么您将得到这种流程包装器，并添加了PID 1(在本例中是<code class="fe nb nc nd ne b">docker-init</code>)功能:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="9c27" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="bb42" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: ps -a<br/>    init: true</span><span id="85eb" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up<br/>Starting mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | PID   USER     TIME  COMMAND<br/>first_1  |     1 root      0:00 <strong class="ne iu">/sbin/docker-init</strong> -- ps -a<br/>first_1  |     8 root      0:00 ps -a<br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="0f1c" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">隔离</h2><p id="9b28" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">对于Linux，这总是<code class="fe nb nc nd ne b">default</code>。对于Windows，你有更多的选择，但我恐怕我没有一台Windows机器来为你们运行一个例子😛对不起Windows用户！</p><h2 id="4331" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">标签</h2><p id="22b3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">顾名思义，使用该选项可以为容器设置标签:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="53d3" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="1402" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 10<br/>    labels:<br/>     - "foo=bar"</span><span id="0728" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Recreating mediumcom_first_1 ... done<br/><strong class="ne iu">$ docker ps --filter 'label=foo=bar'<br/></strong>CONTAINER ID   IMAGE     COMMAND      CREATED          STATUS         PORTS     NAMES<br/>94e844176d76   alpine    "sleep 10"   30 seconds ago   Up 7 seconds             <strong class="ne iu">mediumcom_first_1</strong></span></pre><h2 id="81a5" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">链接</h2><p id="db92" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><em class="mx">至于</em> <code class="fe nb nc nd ne b"><em class="mx">external_links</em></code> <em class="mx">我们就跳过这个</em> <strong class="lb iu"> <em class="mx">遗留</em> </strong> <em class="mx">选项吧。容器之间的通信可以通过用户定义的网络轻松实现。</em></p><h2 id="9da6" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">记录</h2><p id="cfe7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">实际上，我发现这个选项非常关键，因为大多数用户通常没有足够重视他们的容器应用程序日志不断增长的大小。除非您希望您的主机随着时间的推移而填满，否则对于任何其他应用程序，您还必须控制应用程序记录其内容的方式。Docker允许您通过使用这个<code class="fe nb nc nd ne b">logging</code>选项来控制容器应用程序的标准输出日志。不仅是日志记录的类型，还有日志记录大小限制和循环参数:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="db96" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="bb4f" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sh -c 'while true; do echo `date`; done'<br/>    logging:<br/>      options:<br/>        max-size: "50k"<br/>        max-file: "10"</span><span id="d53f" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Recreating tmp_first_1 ... done<br/><strong class="ne iu">$ </strong>docker ps -f 'name=tmp_first_1'<br/>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES<br/><strong class="ne iu">2ea63dd32607</strong>   alpine    "sh -c 'while true; …"   2 minutes ago   Up 2 minutes             tmp_first_1<br/><strong class="ne iu">$ <br/>$ </strong>du -h /var/lib/docker/containers/2ea63dd32607*/*log*<br/><strong class="ne iu">20K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log<br/><strong class="ne iu">52K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log.1<br/><strong class="ne iu">52K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log.2<br/><strong class="ne iu">52K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log.3<br/><strong class="ne iu">52K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log.4<br/><strong class="ne iu">52K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log.5<br/><strong class="ne iu">52K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log.6<br/><strong class="ne iu">52K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log.7<br/><strong class="ne iu">52K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log.8<br/><strong class="ne iu">52K</strong> /var/lib/docker/containers/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60/2ea63dd32607ea5c5b3238ed4da2233a049c41422cfff96b6a2e45c818f96f60-json.log.9</span></pre><p id="0b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，在本例中，我们可以确认Docker最多只保存10个日志文件，它们的大小从未超过我们期望的50k字节(= 52K)。</p><h2 id="9080" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">pid</h2><p id="afe9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">根据请求，您可以让容器与主机共享PID地址空间。这是实现这一目标的选择:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="4dfa" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="fa42" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: ps -a<br/>    pid: "host"</span><span id="7bfa" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: ps -a<br/>EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Creating network "mediumcom_default" with the default driver<br/>Creating mediumcom_second_1 ... done<br/>Creating mediumcom_first_1  ... done<br/>Attaching to mediumcom_second_1, mediumcom_first_1<br/>second_1  | PID   USER     TIME  COMMAND<br/><strong class="ne iu">second_1</strong>  |     1 root      0:00 ps -a<br/>first_1   | PID   USER     TIME  COMMAND<br/><strong class="ne iu">first_1</strong>   |     1 root      0:07 /sbin/init<br/>first_1   |     2 root      0:00 [kthreadd]<br/>first_1   |     3 root      0:00 [rcu_gp]<br/>first_1   |     4 root      0:00 [rcu_par_gp]<br/>first_1   |     6 root      0:00 [kworker/0:0H-ev]<br/>first_1   |     8 root      0:00 [mm_percpu_wq]<br/>first_1   |     9 root      0:00 [rcu_tasks_rude_]<br/>first_1   |    10 root      0:00 [rcu_tasks_trace]<br/>first_1   |    11 root      0:22 [ksoftirqd/0]<br/>first_1   |    12 root      0:10 [rcu_sched]<br/>first_1   |    13 root      0:07 [migration/0]<br/>first_1   |    15 root      0:00 [cpuhp/0]<br/>first_1   |    16 root      0:00 [cpuhp/1]<br/>...</span></pre><p id="6af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这意味着您可以从容器内部管理(包括终止)主机进程，所以使用该选项时要小心。</p><h2 id="cba4" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">港口</h2><p id="b637" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在最流行的选项中，这允许您从容器内部向您的主机发布端口(除非您的容器已经在“主机”模式下运行)。</p><p id="598f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我要发布:<br/> -端口3000到随机端口<br/> -端口范围3005到3010 <br/> -端口80到仅本地主机上的端口80<br/>-端口443到所有主机接口上的端口443<br/>-端口3011到主机上的端口9876，但仅用于UDP</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="e1b9" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="060b" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 10<br/>    ports:<br/>     - 3000<br/>     - 3005-3010<br/>     - 127.0.0.1:80:80<br/>     - 443:443<br/>     - 9876:3011/udp</span><span id="319d" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Removing orphan container "mediumcom_second_1"<br/>Starting mediumcom_first_1 ... done<br/><strong class="ne iu">$ </strong>docker ps --format '{{.Ports}}'<br/>127.0.0.1:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:61290-&gt;3000/tcp, 0.0.0.0:61292-&gt;3005/tcp, 0.0.0.0:61293-&gt;3006/tcp, 0.0.0.0:61294-&gt;3007/tcp, 0.0.0.0:61295-&gt;3008/tcp, 0.0.0.0:61296-&gt;3009/tcp, 0.0.0.0:61291-&gt;3010/tcp, 0.0.0.0:9876-&gt;3011/udp</span></pre><h2 id="76b2" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">轮廓</h2><p id="3b4d" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">“配置文件”是一个很酷的控制机制，通过它您可以在您的撰写文件中分离职责。假设我们希望我们的组合文件中的一些容器只在非常特定的设置下运行，或者按需运行(也称为“概要”)。你可以这样做:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="4bf1" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="bdda" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: nginx</span><span id="305c" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: wget <a class="ae ky" href="http://first'" rel="noopener ugc nofollow" target="_blank">http://first</a><br/>    profiles: ["debug"]</span><span id="2a7c" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Creating network "mediumcom_default" with the default driver<br/>Creating <strong class="ne iu">mediumcom_first_1</strong> ... done</span><span id="63f4" class="np md it ne b gy oj og l oh oi"><strong class="ne iu">$ </strong># see? only the nginx container was started. Let's enable "debug"<br/><strong class="ne iu">$ </strong>docker-compose <strong class="ne iu">--profile debug</strong> up <br/>mediumcom_first_1 is up-to-date<br/>Creating <strong class="ne iu">mediumcom_second_1</strong> ... done<br/>Attaching to mediumcom_first_1, mediumcom_second_1<br/><strong class="ne iu">second_1  | Connecting to first (172.26.0.2:80)<br/>second_1  | saving to 'index.html'<br/>second_1  | index.html           100% |********************************|   615  0:00:00 ETA<br/>second_1  | 'index.html' saved</strong><br/>first_1   | /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration<br/>first_1   | /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/<br/>first_1   | /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh<br/>first_1   | 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf<br/>first_1   | 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf<br/>first_1   | /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh<br/>first_1   | /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh<br/>first_1   | /docker-entrypoint.sh: Configuration complete; ready for start up<br/>first_1   | 2022/02/01 15:07:21 [notice] 1#1: using the "epoll" event method<br/>first_1   | 2022/02/01 15:07:21 [notice] 1#1: nginx/1.21.5<br/>first_1   | 2022/02/01 15:07:21 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6) <br/>first_1   | 2022/02/01 15:07:21 [notice] 1#1: OS: Linux 5.10.76-linuxkit<br/>first_1   | 2022/02/01 15:07:21 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576<br/>first_1   | 2022/02/01 15:07:21 [notice] 1#1: start worker processes<br/>first_1   | 2022/02/01 15:07:21 [notice] 1#1: start worker process 31<br/>first_1   | 2022/02/01 15:07:21 [notice] 1#1: start worker process 32<br/><strong class="ne iu">first_1   | 172.26.0.3 - - [01/Feb/2022:15:07:34 +0000] "GET / HTTP/1.1" 200 615 "-" "Wget" "-"</strong><br/><strong class="ne iu">mediumcom_second_1 exited with code 0</strong></span></pre><h2 id="987a" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">重新开始</h2><p id="ffec" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这就是你如何为你的容器定义重启策略(从<code class="fe nb nc nd ne b">no</code>、<code class="fe nb nc nd ne b">always</code>、<code class="fe nb nc nd ne b">unless-stopped</code>和<code class="fe nb nc nd ne b">on-failure</code>中)。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="158e" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="49ce" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    restart: on-failure<br/>    command: sleep 4</span><span id="4797" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: echo Hi `date`<br/>    restart: always</span><span id="98f9" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Creating network "mediumcom_default" with the default driver<br/>Creating mediumcom_first_1  ... done<br/>Creating mediumcom_second_1 ... done<br/>Attaching to mediumcom_first_1, mediumcom_second_1<br/>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/><strong class="ne iu">mediumcom_second_1 exited with code 0<br/></strong>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/><strong class="ne iu">mediumcom_second_1 exited with code 0<br/></strong>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/><strong class="ne iu">mediumcom_second_1 exited with code 0<br/></strong>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/>second_1  | Hi Tue Feb 1 17:21:11 CET 2022<br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="9767" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">安全性_opt</h2><p id="bd29" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">该选项允许您控制容器的SELinux标签。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="3bda" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="2e53" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 30<br/>    <!-- -->security_opt:<br/>     - label:user:USER</span><span id="3e4e" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: sleep 30</span><span id="294f" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker inspect mediumcom_first_1 --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}'<br/>2808e4b2ac6a6870b372ecf06da5ce0217efdd6d14df16cef4b332e1d4fb9b6a: SecurityOpt=<strong class="ne iu">[label:user:USER]</strong><br/><strong class="ne iu">$ </strong><br/><strong class="ne iu">$ </strong>docker inspect mediumcom_second_1 --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}'<br/>ed4c417b27257cc9f793d5d3dad94672074859dba90effddd0cde49f12dd4115: SecurityOpt=<strong class="ne iu">&lt;no value&gt;</strong></span></pre><h2 id="4093" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">停止宽限期</h2><p id="2d70" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">你可能会发现，默认情况下，如果在收到一个SIGTERM后10秒内没有自然停止，Docker force就会杀死一个容器(例如，在你试图用<code class="fe nb nc nd ne b">docker stop</code>停止一个容器后)。这个时间段称为停止宽限期，您可以对其进行配置。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="6bf0" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="b0ac" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sh -c 'while true; do sleep 5 &amp; done'</span><span id="e206" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: sh -c 'while true; do sleep 5 &amp; done'<br/>    stop_grace_period: 1s</span><span id="bd13" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Recreating mediumcom_first_1  ... done<br/>Recreating mediumcom_second_1 ... done<br/><strong class="ne iu">$ </strong>time docker stop mediumcom_first_1<br/>mediumcom_first_1</span><span id="8c5e" class="np md it ne b gy oj og l oh oi"><strong class="ne iu">real 0m10.847s</strong><br/>user 0m0.205s<br/>sys 0m0.092s<br/><strong class="ne iu">$ </strong>time docker stop mediumcom_second_1<br/>mediumcom_second_1</span><span id="0cb2" class="np md it ne b gy oj og l oh oi"><strong class="ne iu">real 0m1.883s<br/></strong>user 0m0.192s<br/>sys 0m0.105s</span></pre><h2 id="2a05" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">停止信号</h2><p id="3b99" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">从上面的选项中，您已经知道SIGTERM是停止Docker容器的默认信号。但是您可以改变这一点，这样<code class="fe nb nc nd ne b">docker stop</code>就可以向您的容器应用程序发送您自己喜欢的信号:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="479e" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="5170" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 60<br/>    stop_signal: SIGUSR1</span><span id="d3a1" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Creating network "mediumcom_default" with the default driver<br/>Creating mediumcom_first_1 ... done<br/><strong class="ne iu">$ </strong>docker inspect mediumcom_first_1 --format '{{.Config.StopSignal}}'</span><span id="c967" class="np md it ne b gy oj og l oh oi"><strong class="ne iu">SIGUSR1</strong></span></pre><h2 id="f356" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">sysctls</h2><p id="2f49" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">该选项允许您在运行时为容器配置命名空间内核参数。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="6373" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="f6a3" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 60<br/>    sysctls:<br/>      net.core.somaxconn: 1024<br/>      net.ipv4.tcp_syncookies: 0</span><span id="de26" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Creating network "mediumcom_default" with the default driver<br/>Creating mediumcom_first_1 ... done<br/><strong class="ne iu">$ </strong>docker inspect mediumcom_first_1 --format '{{json .HostConfig.Sysctls}}'<br/><strong class="ne iu">{"net.core.somaxconn":"1024","net.ipv4.tcp_syncookies":"0"}</strong></span></pre><h2 id="0ee5" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">ulimits</h2><p id="59f3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">允许您覆盖容器的默认ulimits。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="f0ab" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="82fa" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 60<br/>    ulimits:<br/>      <!-- -->nproc: 65535<br/>      <!-- -->nofile:<br/>        soft: 20000<br/>        hard: 40000</span><span id="0fea" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Recreating mediumcom_first_1 ... done<br/><strong class="ne iu">$ </strong>docker inspect mediumcom_first_1 --format '{{json .HostConfig.Ulimits}}'<br/><strong class="ne iu">[{"Name":"nproc","Hard":65535,"Soft":65535},{"Name":"nofile","Hard":40000,"Soft":20000}]</strong></span></pre><h2 id="4276" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">用户模式</h2><p id="5cac" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">不涉及太多细节，以防万一您已经在Docker守护进程中启用了<code class="fe nb nc nd ne b">user</code>名称空间，这个选项让您只需执行<code class="fe nb nc nd ne b">userns_mode: "host"</code>就可以禁用单个容器的用户名称空间。</p><h2 id="6fe4" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">用户</h2><p id="3c51" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">您希望您的容器应用程序在您的容器中作为特定用户运行吗？</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="9038" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="168d" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: whoami<br/>    user: nobody</span><span id="de70" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | <strong class="ne iu">nobody</strong><br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="e722" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">工作目录</h2><p id="7279" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">你从档案里知道这个。有了它，你可以为你的容器重新定义登陆路径(PWD ),并可能影响你的入口点和命令的行为，以防它们没有使用绝对路径。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="2c3b" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="ee4b" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: pwd<br/>    working_dir: /my/custom/medium/dir</span><span id="15fc" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  |<strong class="ne iu"> /my/custom/medium/dir</strong><br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="1821" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">域名</h2><p id="b208" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如您所知，您的容器有一个主机名和一个域名。当<strong class="lb iu">不是</strong>在主机模式下运行时，主机名将等于容器的ID，域名，正如所料，将是none。如果您想设置它，请执行以下操作:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="290f" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="f0e3" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: hostname -f<br/>    domainname: cristovaocordeiro.medium.com</span><span id="c8d5" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | 6e900c697939.<strong class="ne iu">cristovaocordeiro.medium.com</strong><br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="3c53" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">主机名</h2><p id="3b24" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">显然，如果您可以设置一个域名，那么您也可以为您的容器设置一个主机名，这样它就可以采用默认的“难看的”ID形式😜</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="3d26" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="9b7a" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: hostname -f<br/>    hostname: test-container</span><span id="8d41" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | <strong class="ne iu">test-container</strong><br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="5c7b" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">工业程序控制（ industrial process control的缩写）</h2><p id="eefa" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">您可以管理容器的进程间通信(用于性能调优)。通过让您为容器配置IPC名称空间，该选项让您可以做到这一点。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="857b" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="155e" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sleep 30<br/>    ipc: shareable</span><span id="2ace" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker inspect mediumcom_first_1 --format '{{json .HostConfig.IpcMode}}'<br/>"<strong class="ne iu">shareable</strong>"</span></pre><h2 id="e84c" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">mac地址</h2><p id="6b49" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">你甚至可以为你的容器定义你自己的mac地址。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="e3dd" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="62b7" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: ifconfig eth0<br/>    mac_address: <!-- -->00:ab:cd:12:34:56</span><span id="9138" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | eth0      Link encap:Ethernet  HWaddr <strong class="ne iu">00:AB:CD:12:34:56</strong>  <br/>first_1  |           inet addr:172.29.0.2  Bcast:172.29.255.255  Mask:255.255.0.0<br/>first_1  |           UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br/>first_1  |           RX packets:2 errors:0 dropped:0 overruns:0 frame:0<br/>first_1  |           TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br/>first_1  |           collisions:0 txqueuelen:0 <br/>first_1  |           RX bytes:200 (200.0 B)  TX bytes:0 (0.0 B)<br/>first_1  | <br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="8572" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">特许的</h2><p id="def5" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们已经在上面几次解决了“特权”容器的状态。总之如果你确定(！！)并且您想简单地向您的容器授予每一种可能的能力(以及对主机设备和更多设备的潜在访问权)，那么您可以使用这个选项。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="723c" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="41ee" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: sh -c 'ls /dev/ | wc -l'</span><span id="10ef" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: sh -c 'ls /dev/ | wc -l'<br/>    privileged: true</span><span id="2e1e" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1  ... done<br/>Recreating mediumcom_second_1 ... done<br/>Attaching to mediumcom_first_1, mediumcom_second_1<br/>first_1   | 15<br/><strong class="ne iu">second_1  | 150</strong><br/>mediumcom_first_1 exited with code 0<br/>mediumcom_second_1 exited with code 0</span></pre><h2 id="5f38" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">只读</h2><p id="8e1e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如您所知，运行容器时，会在容器的只读图像层之上创建一个可写层。但是，您也可以将这个可写层变为只读。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="1e2f" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="fa6f" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: touch /tmp/test</span><span id="56cc" class="np md it ne b gy oj og l oh oi">  second:<br/>    image: alpine<br/>    command: touch /tmp/test<br/>    read_only: true</span><span id="04fb" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1  ... done<br/>Recreating mediumcom_second_1 ... done<br/>Attaching to mediumcom_first_1, mediumcom_second_1<br/><strong class="ne iu">second_1  | touch: /tmp/test: Read-only file system</strong><br/>mediumcom_first_1 exited with code 0<br/>mediumcom_second_1 exited with <strong class="ne iu">code 1</strong></span></pre><h2 id="017a" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">shm_size</h2><p id="b8dc" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">您可以指定容器可以使用的共享内存量。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="3236" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="4879" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    command: df -h /dev/shm<br/>    shm_size: 123M</span><span id="5da4" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up <br/>Recreating mediumcom_first_1 ... done<br/>Attaching to mediumcom_first_1<br/>first_1  | Filesystem                Size      Used Available Use% Mounted on<br/>first_1  | <strong class="ne iu">shm</strong>                     <strong class="ne iu">123.0M</strong>         0    123.0M   0% <strong class="ne iu">/dev/shm</strong><br/>mediumcom_first_1 exited with code 0</span></pre><h2 id="c29a" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">标准输入_打开</h2><p id="73ab" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这相当于<code class="fe nb nc nd ne b">docker run</code>中的<code class="fe nb nc nd ne b">-i</code>。使用它，您可以为您的容器打开STDIN，在您的主机和容器之间创建一个交互式会话。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="d4ed" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="991a" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    stdin_open: true</span><span id="2978" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Recreating mediumcom_first_1 ... done<br/><strong class="ne iu">$ </strong>docker attach mediumcom_first_1 <br/>echo Hello, I am sending commands to the container<br/>Hello, I am sending commands to the container<br/>exit</span></pre><p id="d78c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们正在与容器进行交互，但主机和容器之间并没有真正的终端会话…如果您想简化它，它基本上只是一个管道。</p><h2 id="3fdc" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">电传打字机</h2><p id="0455" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这相当于<code class="fe nb nc nd ne b">docker run</code>中的<code class="fe nb nc nd ne b">-t</code>。它让你为你的容器分配一个伪tty，当与<code class="fe nb nc nd ne b">stdin_open</code>结合时，它会很有用。</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="80a1" class="np md it ne b gy of og l oh oi"><strong class="ne iu">$ </strong>cat &gt;<strong class="ne iu">docker-compose.yml</strong> &lt;&lt;EOF<br/>version: "3"</span><span id="46da" class="np md it ne b gy oj og l oh oi">services:<br/>  first:<br/>    image: alpine<br/>    stdin_open: true<br/>    tty: true</span><span id="d892" class="np md it ne b gy oj og l oh oi">EOF<br/><strong class="ne iu">$ </strong>docker-compose up -d<br/>Recreating mediumcom_first_1 ... done<br/><strong class="ne iu">$ </strong>docker attach mediumcom_first_1 <br/>/ # echo now this is a real terminal<br/>now this is a real terminal<br/>/ # sleep 5<br/>^C<br/>/ # echo $?<br/>130<br/>/ # exit</span></pre><p id="a44c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个真正的终端和一个交互式会话，可以在容器内部做我们想做的任何事情。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c3b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是一篇大文章。很抱歉。从好的方面来说，你不需要在标签页之间跳来跳去，在多篇文章中搜索，只是为了找出不同的合成文件选项的作用</p><p id="f98a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我已经忽略了一些选项(那些特定于Swarm模式中的服务的选项)和特殊的结构技巧，如变量替换和扩展字段。这些是可选的，我们可以在另一篇文章中介绍它们。</p><p id="732d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这能提高你的Docker写作技巧</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="9705" class="np md it ne b gy of og l oh oi"><strong class="ne iu">Want to Connect?</strong></span><span id="8f9e" class="np md it ne b gy oj og l oh oi">I hope this article was useful, and serves as a good complement to my <a class="ae ky" href="https://www.udemy.com/course/docker-crash-course-learn-from-experience-for-beginners/?couponCode=B6FB29C107CC97ACFEFF" rel="noopener ugc nofollow" target="_blank">Docker course for beginners</a> (get 75% discount from this link).</span></pre></div></div>    
</body>
</html>