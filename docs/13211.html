<html>
<head>
<title>Profiling in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的剖析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/profiling-in-go-78cf71f81a07?source=collection_archive---------4-----------------------#2022-08-08">https://betterprogramming.pub/profiling-in-go-78cf71f81a07?source=collection_archive---------4-----------------------#2022-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释应用程序与CPU或内存的连接的简要指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ddce33ad0b5f362e592e289cb8ffe4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TQk6lJXa2vQTxsYC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@dilucidus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kai Dahms </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="b27f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是剖析，为什么有用？</h1><p id="1ec4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您是否曾经想深入了解一下为什么您的应用程序会增加内存或CPU峰值？虽然监控工具告诉你它正在发生，但你不知道为什么。</p><p id="2242" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是侧写非常棒的时候。通过性能分析，可以更好地了解应用程序如何与CPU或内存交互。它允许更容易地对您的代码行为进行优化。</p><p id="82dc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Go附带了一个名为pprof的原生分析工具。它提供了大量可以分析的组件，比如内存分配(当前和过去)、CPU、goroutines的堆栈跟踪和各种其他选项。</p><h1 id="80b7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">基本设置</h1><p id="7220" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">pprof的入门相当简单。在最基本的例子中，它要求您将<code class="fe ms mt mu mv b">net/http/pprof</code>作为空白标识符导入。这触发了一个<code class="fe ms mt mu mv b">init</code>功能，该功能将配置pprof端点。</p><p id="e282" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">注意</strong>:我们正在使用来自<code class="fe ms mt mu mv b">net/http</code>的HTTP处理程序，这取决于你正在使用的HTTP处理程序。配置pprof的方式可能会有所不同。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2716" class="na la it mv b gy nb nc l nd ne">package main</span><span id="fc14" class="na la it mv b gy nf nc l nd ne">import ( <br/> “log” <br/> “net/http” <br/> _ “net/http/pprof” <br/>)</span><span id="f6b4" class="na la it mv b gy nf nc l nd ne">func main() { <br/> log.Println(“booting on localhost:8080”) <br/> log.Fatal(http.ListenAndServe(“:8080”, nil)) <br/>}</span></pre><p id="52c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有了这个基本设置，pprof将在运行时公开端点，您可以与这些端点进行交互，开始收集应用程序的概要文件。</p><h1 id="f83a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Pprof端点</h1><p id="56e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">那么pprof向我们公开和提供了什么来进行概要分析，我如何访问它呢？</p><p id="0990" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">pprof终点可在<code class="fe ms mt mu mv b"><a class="ae ky" href="http://localhost:8080/debug/pprof`" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/debug/pprof</a></code>到达。至于哪些端点是可用的，下面列出了每个端点的简短描述:</p><p id="d69b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">/debug/pprof/allocs</code>:所有过去内存分配的抽样</p><p id="6ff1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">/debug/pprof/block</code>:导致同步原语阻塞的堆栈跟踪</p><p id="8131" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">/debug/pprof/cmdline</code>:当前程序的命令行调用</p><p id="8bd8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">/debug/pprof/goroutine</code>:堆叠当前所有goroutines的踪迹</p><p id="def6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">/debug/pprof/heap</code>:活动对象的内存分配抽样。在获取堆样本之前，可以指定<code class="fe ms mt mu mv b">gc GET</code>参数来运行GC。</p><p id="718f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">/debug/pprof/mutex</code>:竞争互斥体持有者的堆栈跟踪</p><p id="b7a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">/debug/pprof/profile</code> : CPU配置文件。您可以在seconds GET参数中指定持续时间。获得配置文件后，使用go tool pprof命令研究配置文件。</p><p id="b0c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">/debug/pprof/threadcreate</code>:导致创建新操作系统线程的堆栈跟踪</p><p id="6dba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">/debug/pprof/trace</code>:当前程序执行的痕迹。您可以在seconds GET参数中指定持续时间。获取跟踪文件后，使用go工具trace命令来调查跟踪。</p><h1 id="3ac1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">与pprof交互</h1><p id="0416" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了与pprof交互，我们可以使用下面的命令<code class="fe ms mt mu mv b">go tool pprof</code>。使用该命令有两种方式。第一种方法是在CLI中使用它，第二种方法是通过web界面将其可视化。您知道pprof将呈现在一段时间内捕获的数据吗？以下命令的默认值是30秒。您可以通过将<code class="fe ms mt mu mv b">?seconds=</code>添加到您的查询中来调整这一点，这将告诉pprof在显示结果之前需要多长时间进行分析。</p><p id="0178" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下是该命令的详细内容:</p><p id="19ae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">go tool pprof <a class="ae ky" href="http://localhost:{APP" rel="noopener ugc nofollow" target="_blank">http://localhost:{APP</a> PORT}/{pprof endpoint}</code></p><p id="33bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">app端口将是pprof运行的端口。在我们的例子中，应该是<code class="fe ms mt mu mv b">8080</code>。至于pprof端点，这是上面列出的您希望分析的任何端点。</p><p id="2de2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">命令行交互的完整示例如下:</p><p id="4e9a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">go tool pprof -<a class="ae ky" href="http://localhost:8080/debug/pprof/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/debug/pprof/</a>heap</code></p><p id="7266" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">而web交互的完整示例如下，只是稍微添加了一个<code class="fe ms mt mu mv b">http</code>标志:</p><p id="9dfc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">go tool pprof --http=:8081 <a class="ae ky" href="http://localhost:8080/debug/pprof/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/debug/pprof/</a>heap</code></p><p id="126b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">注意:</strong>这里提供的端口可以是你喜欢的任何东西，只要端口没有被使用。</p><p id="f00b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们要运行下面的命令<code class="fe ms mt mu mv b">go tool pprof — http=:8081 <a class="ae ky" href="http://localhost:8080/debug/heap/`" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/debug/heap/</a> </code>，pprof将对我们的应用程序内存进行30秒的分析。然后它会打开一个看起来像这样的网页:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/b42b2ac6e7d1390e0e44fb41fab211bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOkBQysmCvBqUfAH8WQrbA.png"/></div></div></figure><p id="cfeb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里我们有一个应用程序内存使用的分类。盒子越大，总是与其用途相对应，无论这是CPU、内存等。，所以在这个例子中，我们看到<code class="fe ms mt mu mv b">StartCPUProfile</code>是用<code class="fe ms mt mu mv b">1185.27kB</code>消耗内存最多的。</p><h1 id="e2b3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">最终想法</h1><p id="b15f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">而使用Prometheus和Grafana等工具来监控和掌握您的应用程序是很好的(也是必要的)。Pprof在处理go应用程序中可能在您的监控中弹出的任何奇怪的尖峰信号方面进行了扩展。</p><p id="b136" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">希望这篇文章能够揭示pprof这样的工具在微调或调试Go应用程序中的棘手问题时有多么强大。</p></div></div>    
</body>
</html>