<html>
<head>
<title>iOS PDFKit Ink Annotations Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS PDFKit墨迹注释教程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-pdfkit-ink-annotations-tutorial-4ba19b474dce?source=collection_archive---------0-----------------------#2019-02-19">https://betterprogramming.pub/ios-pdfkit-ink-annotations-tutorial-4ba19b474dce?source=collection_archive---------0-----------------------#2019-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f099" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">苹果pdf包完全指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ec071ba06e3a960bc145a7778dccfed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7piZX6kn2_-aKBmb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@suganth?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Suganth </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="29c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我第一篇关于苹果PDFKit的文章。我们将从PDFKit基础开始，并在本教程的最后创建第一个墨迹注释。</p><ul class=""><li id="fabb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">第二个是关于铅笔工具、文本注释和自动保存。</li><li id="d9c2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">第三篇<a class="ae kv" href="https://medium.com/@artempoluektov/ios-pdfkit-create-document-insert-delete-pages-2c53829de6c8" rel="noopener">文章是关于在设备上创建PDF文档，以及插入和删除页面</a></li></ul><p id="e65a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的团队最近开始了一个新项目:开发一个内置PDF浏览器的新iOS应用程序。</p><p id="6276" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个浏览器的主要特点是能够用手指或苹果铅笔给PDF文件添加注释。当然，我们知道这不是一项容易的任务，但我们从未想象过它会有多么具有挑战性。</p><p id="245b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，<code class="fe mg mh mi mj b">PDFKit</code>看起来像iOS SDK中包含的任何其他苹果的框架。它包括PDF文档和缩略图视图，内置手势支持和大量动画。它实际上似乎是一个“神奇”的框架，只用几行代码就解决了我们的任务。</p><p id="395d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我花了很多时间让绘图、润色和注释像预期的那样工作。我们还发现了一些导致崩溃的错误(在<code class="fe mg mh mi mj b">Framework</code>内部)，以及缺乏文档和教程或例子。</p><p id="8c3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我才给你做了这个教程！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="71e4" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">针对iOS 13更新</h1><p id="4bab" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">本教程更新至iOS 13，你还会在<a class="ae kv" href="https://medium.com/@artempoluektov/ios-pdfkit-tutorial-text-annotations-more-d0175436b28b" rel="noopener">第二部</a>中找到一些关于<code class="fe mg mh mi mj b">PencilKit</code>、<code class="fe mg mh mi mj b">PKCanvasView</code>和<code class="fe mg mh mi mj b">PKToolPicker</code>的有用信息，以及如何添加文本注释。</p><h2 id="77df" class="no ms iq bd mt np nq dn mx nr ns dp nb lf nt nu nd lj nv nw nf ln nx ny nh nz bi translated">任务</h2><p id="f8cc" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">任务非常简单:</p><ul class=""><li id="3da1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">将PDF文件下载到设备。</li><li id="0c6e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">查看PDF文档并允许用户在页面间导航。</li><li id="e339" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用用户的手指或Apple pencil向PDF添加墨迹注释</li><li id="3523" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">保存PDF文档并将其上传到服务器。</li></ul><p id="cb7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来很容易，不是吗？我们不需要教你如何使用Alamofire下载和上传文件——我们将直接使用PDFKit。</p><p id="8f99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oa">注意:在本教程中，我将构建一个iPad应用程序，但PDFKit也适用于iPhone。</em></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="890c" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">PDFView</h1><p id="c209" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">PDFView是PDFKit中的关键对象。它是UIView的一个子类，主要用途是显示PDF文档。要将一个添加到您的<code class="fe mg mh mi mj b">ViewController</code>视图中，您可以使用<code class="fe mg mh mi mj b">Storyboard</code>或代码内初始化。就我个人而言，我更喜欢<code class="fe mg mh mi mj b">Storyboard</code>的，所以这就是我在这里使用的。</p><h2 id="3440" class="no ms iq bd mt np nq dn mx nr ns dp nb lf nt nu nd lj nv nw nf ln nx ny nh nz bi translated"><strong class="ak">将PDFView添加到ViewController的视图中</strong></h2><ul class=""><li id="7131" class="ls lt iq ky b kz nj lc nk lf ob lj oc ln od lr lx ly lz ma bi translated">只需添加新的UIView</li><li id="d9a5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">设置限制(我将在左侧留出一些空间用于缩略图视图)</li><li id="e1ef" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">转到检查器面板(在右侧)，选择Identity选项卡并输入类名<code class="fe mg mh mi mj b">PDFView</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/f0944bb91323ccc531585d37238594b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYTa9r1oDXOYV3RXmxYXKw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将PDFView添加到ViewController的视图中</p></figure><p id="fd81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以建立<code class="fe mg mh mi mj b">PDFView</code>:</p><ul class=""><li id="72d6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">使用界面构建器为您的<code class="fe mg mh mi mj b">ViewController’s</code>类创建<code class="fe mg mh mi mj b">@IBOutlet</code></li><li id="8638" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">别忘了<code class="fe mg mh mi mj b">import PDFKit</code></li><li id="e7e2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">以下是我的PDFView设置代码:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一行非常简单——您的<code class="fe mg mh mi mj b">PDFView</code>可以有垂直或水平滚动方向。</p><p id="0197" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二行非常有用。默认情况下，<code class="fe mg mh mi mj b">PDFView</code>使用内置的<code class="fe mg mh mi mj b">UIScrollView</code>来实现整个文档的连续滚动。但是，您可以激活<code class="fe mg mh mi mj b">PageViewController</code>模式，这样<code class="fe mg mh mi mj b">PDFView</code>在屏幕上只显示一页。当然，缩放是默认支持和启用的。</p><p id="cfd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现<code class="fe mg mh mi mj b">.autoScales</code>设置包含一个bug。当屏幕旋转时，它在iPad上不起作用。要解决这个问题，您必须添加这个调用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="18a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个具有意外行为的方法是<code class="fe mg mh mi mj b">.backgroundColor</code>。它只在代码中起作用，当你试图在界面构建器中设置它时不起作用。我花了很长时间试图理解我做错了什么！</p><p id="466a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我找到了原因:调用<code class="fe mg mh mi mj b">pdfView.document = ...</code>会将<code class="fe mg mh mi mj b">PDFView</code>的背景颜色重置为默认值。所以，在<code class="fe mg mh mi mj b">pdfView.document = ...</code>之后调用<code class="fe mg mh mi mj b">pdfView.backgroundColor = ...</code>。</p><p id="3bdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成<code class="fe mg mh mi mj b">PDFView</code>设置后，让我们将一个示例PDF文档添加到您的项目中(将其拖放到左侧面板):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/1f3a6e20d6a4504ab76ec917b2625548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*rej9XKfj5nUclzYrbgdv2g.png"/></div></figure><p id="88d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe mg mh mi mj b">PDFDocument</code>并将其添加到您的<code class="fe mg mh mi mj b">PDFView</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a76d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那很简单！</p><p id="6e70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们的应用已经启动并运行，具备了以下开箱即用的特性:</p><ul class=""><li id="98ed" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">用双指手势缩放。</li><li id="282e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">滚动。</li><li id="93f3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">长按手势调用复制菜单。</li><li id="cacf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">ThumbnailView</code>支持。</li></ul><p id="60b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我的<code class="fe mg mh mi mj b">viewDidLoad</code>方法在这一步之后的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6dae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oa">注意:把这么多行代码放在你的</em> <code class="fe mg mh mi mj b"><em class="oa">viewDidLoad</em></code> <em class="oa">里并不是最好的办法，但这是教程，就这样吧！</em></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="6e8c" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">PDFThumbnailView</h1><p id="2ad4" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">创建缩略图很容易。就像我们在上一步中做的那样:</p><ul class=""><li id="ef93" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">将新的<code class="fe mg mh mi mj b">UIView</code>添加到你的<code class="fe mg mh mi mj b">ViewController’s</code>视图中(不是<code class="fe mg mh mi mj b">PDFView’s</code>子视图)。</li><li id="9787" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">设置约束。</li><li id="af72" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在右侧面板的Identity Inspector选项卡中将<code class="fe mg mh mi mj b">PDFThumbnailView</code>设置为类名。</li><li id="6430" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">为你的<code class="fe mg mh mi mj b">ViewController</code>代码创建<code class="fe mg mh mi mj b">@IBOutlet</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/29e1c9a364f1d396a151af6557e8b114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9emWXjr3gaJPKDgBHhlPkA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建缩略图视图</p></figure><p id="3f31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的<code class="fe mg mh mi mj b">viewDidLoad</code>方法中使用这段代码来设置您的新<code class="fe mg mh mi mj b">Thumbnail View</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0c02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码很清楚。不得不提的是<code class="fe mg mh mi mj b">PDFThumbnailView</code>和<code class="fe mg mh mi mj b">PDFView</code>一样，不尊重<code class="fe mg mh mi mj b">.backgroundColor</code>界面建筑设置。但是，它会存储您设置的颜色，因此您不必在每次调用<code class="fe mg mh mi mj b">pdfView.document = ...</code>时重置它。</p><p id="302c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，当用户试图添加注释时，我们在iOS 12上遇到了<code class="fe mg mh mi mj b">PDFThumbnailView</code>崩溃。在一种情况下，用户可以画一个小时而不崩溃，但在其他情况下，应用程序在第一次注释后崩溃。在iOS 13中好像已经修复了。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="dbeb" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">接收触摸事件</h1><p id="fd36" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">最初，为了实现用户输入，我试图添加透明的<code class="fe mg mh mi mj b">UIView</code>作为<code class="fe mg mh mi mj b">pdfView's</code>子视图。我发现透明视图不接收触摸事件。</p><p id="b8be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我将alpha设置为0.01，这是<code class="fe mg mh mi mj b">view</code>接收触摸的最小alpha。然而，我仍然有缩放和滚动手势的问题。我希望我的透明视图接收一个手指手势，并将其他(两个手指)手势转发给它的父视图(<code class="fe mg mh mi mj b">pdfView</code>)。我最终发现这种方法行不通。</p><p id="a44e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，最后，我实现了自己的自定义手势识别器。它只适用于一个手指的手势，如果手势有多个手指，它就会失败。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="5c6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我实现了<code class="fe mg mh mi mj b">touchesBegan</code>方法，它分析它接收到的触摸。</p><p id="c318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是Apple Pencil和单指手势，我将手势识别器状态设置为<code class="fe mg mh mi mj b">.began</code>并继续接收触摸事件。您可以注释<code class="fe mg mh mi mj b">Pencil</code>行，让这段代码在iOS Simulator上运行。不幸的是，你不能在Mac上模拟<code class="fe mg mh mi mj b">Pencil</code>。如果是多点触摸手势，我将手势识别器状态设置为<code class="fe mg mh mi mj b">.failed</code>，以便其他<code class="fe mg mh mi mj b">pdfView's</code>手势识别器工作。</p><p id="a276" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mg mh mi mj b">touchesBegan</code>中，我还通知我的代理，我们收到了一个新的触摸事件，因此它可以创建新的<code class="fe mg mh mi mj b">PDFAnnotation</code>。在<code class="fe mg mh mi mj b">touchesMoved</code>方法中，我只通知代理新的触摸位置。</p><p id="3b96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在<code class="fe mg mh mi mj b">touchesEnded</code>方法中，我发送最终触摸位置并通知我的代理触摸已经结束。</p><p id="774a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是协议参考，非常简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a95e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将此代码添加到您的<code class="fe mg mh mi mj b">ViewController</code>的<code class="fe mg mh mi mj b">viewDidLoad</code>方法中，将此手势识别器添加到您的<code class="fe mg mh mi mj b">PDFView</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="f9e5" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated"><strong class="ak">聚结和预测触摸</strong></h1><p id="4af1" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">来自我们的手势识别器的每个触摸事件(<code class="fe mg mh mi mj b">UIEvent</code>)也具有合并的和预测的触摸阵列。由于不同的设备硬件以及为了提高性能，手势识别器仅实时接收一些触摸事件。</p><p id="46a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的应用程序需要更高的精度，您可以通过检查<code class="fe mg mh mi mj b">UIEvent</code>的<code class="fe mg mh mi mj b">coalescedTouches</code>属性来访问所有触摸。iOS还会尝试预测用户手指或铅笔的移动，并为每个<code class="fe mg mh mi mj b">UIEvent</code>创建一个<code class="fe mg mh mi mj b">predictedTouches</code>数组。</p><p id="51c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据苹果的文档，你可以存储<code class="fe mg mh mi mj b">coalescedTouches</code>并使用它们来绘图。但是，当您接收到下一个触摸事件时，您必须从<code class="fe mg mh mi mj b">predictedTouches</code>中删除任何绘图使用的数据。</p><p id="8fd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们试图不仅将当前触摸的位置，而且将合并的和预测的触摸的数组转发给手势识别器的代表。然而，这导致了性能问题，所以在最终的实现中，我们决定坚持只使用常规的触摸事件，并跳过合并和预测触摸。以我们的情况来说，最终并没有影响用户体验。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="610f" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">绘图实现</h1><p id="6c25" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">创建手势识别器后，我们需要实现绘图。我将尝试遵循单一责任原则，创建另一个类来处理绘图。姑且称之为<code class="fe mg mh mi mj b">PDFDrawer</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9c21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe mg mh mi mj b">PDFDrawer</code>应该保存一个对<code class="fe mg mh mi mj b">PDFView</code>的引用，我们向其中添加注释。<code class="fe mg mh mi mj b">Path</code>用于存储单个手势中的所有触摸事件。<code class="fe mg mh mi mj b">CurrentAnnotation</code>还需要引用，因为每当用户移动Apple Pencil时，我们都会向路径添加新的点，因此我们需要更新它。对于用户在一个页面开始一个手势，然后意外地移动到下一个页面的情况，也需要<code class="fe mg mh mi mj b">CurrentPage</code>。</p><p id="366b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我应该解释一下<code class="fe mg mh mi mj b">PDFDocument</code>是如何工作的。文档包含由<code class="fe mg mh mi mj b">PDFPage</code>类表示的页面。每个页面都包含自己的类<code class="fe mg mh mi mj b">PDFAnnotation</code>注释。因此，如果用户在一个页面上开始一个手势，然后将触摸移动到另一个页面，我们必须在初始页面上继续绘制。</p><p id="37d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">PDFDrawer</code>是手势识别器的代表，所以我们需要实现<code class="fe mg mh mi mj b">DrawingGestureRecognizerDelegate</code>协议的三个方法。首先，在用户第一次触摸时调用一个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们存储当前页面引用并为新绘图创建新的<code class="fe mg mh mi mj b">UIBezierPath</code>。</p><p id="abbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户移动手指或铅笔时，调用以下方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ecee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将检查当前页面引用是否存在，向我们的路径添加一个新点，并添加绘图注释。稍后我将提供<code class="fe mg mh mi mj b">drawAnnotation</code>方法实现。</p><p id="b215" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户完成触摸时，会调用完全相同的代码。或者至少，在教程的这个阶段是一样的，但是我们将在后面添加一些特定的代码来实现橡皮擦。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3cf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单，对吧？最初，我试图在开始、移动和结束事件中重用一个注释。我每次都通过调用<code class="fe mg mh mi mj b">PDFAnnotation</code>的<code class="fe mg mh mi mj b">.add(UIBezierPath)</code>方法给当前注释添加一个新的<code class="fe mg mh mi mj b">UIBezierPath</code>。然而，我们发现这个应用程序在<code class="fe mg mh mi mj b">PDFKit</code>框架内的某个地方崩溃了。</p><p id="6169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我没有在一个注释上调用<code class="fe mg mh mi mj b">.add</code>，而是在每次触摸移动时创建一个新的注释，并删除旧的注释。这(添加和删除)在iOS模拟器上是可见的，但在真正的iPad上可以流畅地工作。这是我发现的唯一防止崩溃的解决方案。</p><p id="f487" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我创建注释的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0a15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迫使我们使用这个解决方案的另一个问题是来自我们客户的特性请求。他们不仅希望用全彩绘制，还希望能够用透明色(带alpha组件)绘制。</p><p id="3225" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几乎没有路径的默认<code class="fe mg mh mi mj b">PDFAnnotation</code>看起来真的很糟糕。因为它由几条透明的路径组成，所以一条路径的终点和另一条路径的起点比直线更亮，因为有交叉点。因为所有的绘图都是在<code class="fe mg mh mi mj b">PDFKit</code>内进行的，我们无法改变这一点。这就是我们使用我们的解决方案的原因。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/1eb6323d9c4ea866ce148c93bc0a0c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*MY2xHtkAo2zBvG_FX-kHbg.jpeg"/></div></div></figure><p id="363c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，为了让事情顺利进行，我们需要在我们的<code class="fe mg mh mi mj b">ViewController</code>中创建一个<code class="fe mg mh mi mj b">PDFDrawer</code>属性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="66e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在<code class="fe mg mh mi mj b">viewDidLoad</code>中添加这个设置调用的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d492" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">长按手势识别器</h1><p id="2e13" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">正如我上面提到的，<code class="fe mg mh mi mj b">PDFView</code>包含了很多内置的手势识别器。在一些罕见的情况下，我们的自定义手势识别器与用于复制动作的内置长按手势识别器冲突。我们还没有找到<code class="fe mg mh mi mj b">PDFView</code>的任何设置来禁用它，所以我们必须实现<code class="fe mg mh mi mj b">PDFView</code>的这个子类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="49bf" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">自定义pdf目录</h1><p id="0121" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们还试验了定制的PDFAnnotations。正如我上面提到的，在收到新的触摸事件后，我们需要删除和添加新的PDFAnnotation。</p><p id="3be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们试图从手势的开始到结束使用单个注释，以提高绘图性能。因此，我们创建了一个带有path属性的定制注释类，并覆盖了<code class="fe mg mh mi mj b">draw()</code>方法。</p><p id="bea8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们不能强迫PDFKit在每次修改路径时重画注释，因为<code class="fe mg mh mi mj b">PDFAnnotation</code>不是<code class="fe mg mh mi mj b">UIView</code>并且没有任何方法来重画注释。</p><p id="4520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们决定在每次收到新的触摸事件时在页面中添加和删除相同的注释(不创建新的事件)。通过自定义<code class="fe mg mh mi mj b">draw</code>方法，我们实现了可视化绘图性能的显著提升，从而改善了用户体验。下面是<code class="fe mg mh mi mj b">draw()</code>的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ef3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了消除绘图伪像，我们向<code class="fe mg mh mi mj b">draw()</code>方法添加了一些额外的设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f6a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使这个方法线程安全，我们在<code class="fe mg mh mi mj b">draw()</code>方法中替换了path副本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="0cab" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">自定义注释和性能</h1><p id="8026" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在第一次发布之后，我们发现了另一个性能问题。使用我们的自定义注释，用户在滚动和缩放PDF文档时经历了冻结。有些甚至由于内存警告而崩溃——即使是系统内和第三方应用。</p><p id="f877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题并保持良好的绘图体验，我们决定在用户绘图时使用自定义注释，并在用户完成触摸后立即用系统<code class="fe mg mh mi mj b">PDFAnnotation</code>替换它。我们还添加了新的边界计算机制，以最小化最终注释的边界大小，减少内存使用并提高绘图性能。我要提醒您的是，在绘制过程中，我们使用了整个页面大小作为自定义注释的界限——用户可以快速、流畅地绘制整个页面。</p><p id="4b67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新<code class="fe mg mh mi mj b">PDFDrawer</code> <code class="fe mg mh mi mj b">gestureRecognizerEnded</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个方法中，我们仍然更新路径，然后删除旧的(自定义)注释并创建最终的(系统)注释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。在绘图和预览过程中表现出色。如果您要使用我的代码，不要忘记将<code class="fe mg mh mi mj b">UIBezierPath+.swift</code>文件添加到您的项目中。您可以在本教程底部的示例代码中找到它。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="218b" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">橡皮擦</h1><p id="564f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们还需要实现一个橡皮擦工具。然而，我们无法使用由<code class="fe mg mh mi mj b">PDFPage</code>提供的<code class="fe mg mh mi mj b">annotation(at:CGPoint)</code>方法，因为它基于注释的边界，即使当用户点击边界内的空白区域<code class="fe mg mh mi mj b">rect</code>时，也会返回注释。</p><p id="fd8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中(用户可能用Apple Pencil写文本),它没有像用户期望的那样工作。我们需要找出路径是否被窃听，而不是路径的边界。首先，我们用可计算的<code class="fe mg mh mi mj b">hitPath</code>属性实现了<code class="fe mg mh mi mj b">PDFAnnotation</code>子类(稍后会有更多细节)，这是注释的最终路径。出于性能原因，仅在路径完成时才进行计算。</p><p id="5eaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们发现在关闭<code class="fe mg mh mi mj b">PDFDocument</code>并再次打开它之后，这种方法不起作用，因为所有之前创建的类<code class="fe mg mh mi mj b">PDFAnnotationWithPath</code>的注释都变成了常规的<code class="fe mg mh mi mj b">PDFAnnotation</code>。因此，我们不得不牺牲一点性能，创建一个扩展来代替<code class="fe mg mh mi mj b">subclass</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="fcc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，我们在这里使用了<code class="fe mg mh mi mj b">PDFAnnotation</code>的<code class="fe mg mh mi mj b">paths</code>属性——确保将您的最终路径放在那里。我们还使用10磅作为所有线条的默认描边宽度，使用户更容易用橡皮擦点击路径。</p><p id="0b07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还实现了<code class="fe mg mh mi mj b">PDFPage</code>扩展来调用<code class="fe mg mh mi mj b">contains</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要更新<code class="fe mg mh mi mj b">PDFDrawer</code>方法来支持橡皮擦工具:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9230" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是一个枚举，包含了我们所有的绘图工具。用户可以在UI中选择具有不同线宽和颜色的不同工具。我们将它存储为<code class="fe mg mh mi mj b">PDFDrawer</code>的属性。</p><p id="be08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对<code class="fe mg mh mi mj b">gestureRecognizerEnded</code>方法进行同样的修改:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="1211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe mg mh mi mj b">removeAnnotationAtPoint</code>的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="7c23" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated"><strong class="ak">保存文档</strong></h1><p id="bd93" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">添加完所有需要的注释后，保存您的<code class="fe mg mh mi mj b">PDFDocument</code>也非常容易:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们应用程序的最终视图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/771b90f90cbd2aa9ffc48120d0f3689e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gveidnG252SFkWiVm4o1qw.png"/></div></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="b9dd" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">示例代码</h1><p id="8381" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">对于演示项目，请<a class="ae kv" href="https://github.com/poluektov/pdfkit-ink-annotations/" rel="noopener ugc nofollow" target="_blank">检查存储库</a>。</p><p id="a85b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有故意创建一个库或框架。主要是因为所有使用PDF的应用程序/项目都非常不同，需要大量的定制。所以，伙计们，请随意使用我的示例代码作为您自己项目的基础。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="b7cd" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">继续阅读</h1><p id="aa9a" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">要了解更多关于<code class="fe mg mh mi mj b">PDFKit</code>的信息，包括使用<code class="fe mg mh mi mj b">PencilKit</code>，添加文本注释，以及替代解决方案，请继续阅读<a class="ae kv" href="https://medium.com/@artempoluektov/ios-pdfkit-tutorial-text-annotations-more-d0175436b28b" rel="noopener">第二部分</a>。</p></div></div>    
</body>
</html>