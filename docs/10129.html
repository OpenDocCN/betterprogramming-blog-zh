<html>
<head>
<title>Which is The Best Method To Find an Item in an Array of Arrays in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中，在数组的数组中查找项目的最佳方法是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/which-is-the-best-method-to-find-an-item-in-an-array-of-arrays-in-javascript-5f51589d2086?source=collection_archive---------4-----------------------#2021-12-02">https://betterprogramming.pub/which-is-the-best-method-to-find-an-item-in-an-array-of-arrays-in-javascript-5f51589d2086?source=collection_archive---------4-----------------------#2021-12-02</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="150d" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">比较三种方法</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/a7566369188f66c70018431626c61513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6WsIAv0gT25yAqXDQqkf7Q.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="72e3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">每当圣诞节临近，我的妻子就开始她的<em class="lv">珠子降临日历</em>。我一直很羡慕她，她的坚定和毅力。在她的建议下，我也决定尝试类似的东西。显然与手工珠宝世界无关(这将是一场灾难)，但与编码有关。幸运的是，YouTube向我推荐了马克·巴克斯的视频。我喜欢他对2021年 开发降临节日历的想法:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lx ly l"/></div></figure><p id="40a2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当然，我仍然不知道我是否能每天做作业。我甚至不知道我是否能够用我的解决方案写一篇文章。事先不知道谜题，也不知道会不会有什么有趣的事情说。对于第一个问题，是的，有一些有趣的想法。</p><h1 id="6c35" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">第一个谜题:找到鲁道夫</h1><pre class="kk kl km kn gu mr ms mt mu aw mv bi"><span id="fc8b" class="mw ma iu ms b gz mx my l mz na">Weeks before Christmas, Santa's reindeers start practicing their flying in order to be fit for the big night. Unfortunately, one of them (Rudolf) crashed and landed in the forest 🌲<br/><br/>Now, Santa 🎅 needs YOUR help to find him.</span></pre><p id="bfbf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是一个数组中的数组搜索问题。换句话说，我必须找到一个二维矩阵中元素的坐标。例如，如果我有一个这样的矩阵，我希望在坐标<code class="fe nb nc nd ms b">(3, 2)</code>找到驯鹿鲁道夫:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><p id="924e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">相反在这样的“森林”中我会得到负坐标，<code class="fe nb nc nd ms b">(-1, -1)</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><h1 id="55b3" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">使用forEach()查找数组中的元素</h1><p id="93a9" class="pw-post-body-paragraph kz la iu lb b lc nf jv le lf ng jy lh li nh lk ll lm ni lo lp lq nj ls lt lu in bi translated">这个问题本身很简单。我们可以用几种方法解决它。最直观的方法是滚动穿过森林的每一条线来寻找鲁道夫:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><p id="ef8f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">array . prototype . foreach()</a>方法为数组的每个元素执行相同的代码。该代码只是对索引Rudolf(🦌)正在使用的<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" rel="noopener ugc nofollow" target="_blank">索引。如果索引是负的，Rudolf就不在那一行。相反，如果我们得到一个正的索引，那么我们就找到了检索它的行和列。</a></p><h1 id="d554" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">使用some()查找数组中的元素</h1><p id="4b11" class="pw-post-body-paragraph kz la iu lb b lc nf jv le lf ng jy lh li nh lk ll lm ni lo lp lq nj ls lt lu in bi translated">我想知道是否有更快的方法来找到数组中的元素。在循环结束之前，无法停止<strong class="lb iv"> forEach() </strong>循环。例如，如果鲁道夫在<code class="fe nb nc nd ms b">(0, 0)</code>坐标，就没有必要在整个森林中寻找他。但是这段代码确实做到了这一点，即使已经找到了答案，它也会继续寻找。</p><p id="6295" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了解决这个问题，我决定使用另一种方法，<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener ugc nofollow" target="_blank"> Array.prototype.some() </a>。<code class="fe nb nc nd ms b">some()</code>做的事情和<code class="fe nb nc nd ms b">forEach</code>完全一样，但是有一个很小但很重要的区别:当它找到元素时就停止循环。或者，更好的是，当所定义的条件被证明为真时。</p><p id="7251" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以我重写了代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><p id="b7f9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我将坐标值保存在两个变量中，<code class="fe nb nc nd ms b">col</code>和<code class="fe nb nc nd ms b">row</code>。但是我还保存了一个额外的变量，<code class="fe nb nc nd ms b">found</code>，作为一个参考来确定我是否能够找到鲁道夫。然后，我对森林中的每个元素进行循环，并在<code class="fe nb nc nd ms b">r.indexOf("🦌") &gt; -1</code>时中断它，此时我已经找到了值”🦌“在阵中。</p><h1 id="e88b" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">使用flat()查找数组中的元素</h1><p id="1216" class="pw-post-body-paragraph kz la iu lb b lc nf jv le lf ng jy lh li nh lk ll lm ni lo lp lq nj ls lt lu in bi translated">一切都很好，但我还不满意。我希望能够同时避开<code class="fe nb nc nd ms b">forEach()</code>和<code class="fe nb nc nd ms b">some()</code>。所以我决定尝试另一种方式。基本的假设是森林是由大小相同的行组成的。如果是这样，那么我可以把二维数组转换成一维数组。然后我用<code class="fe nb nc nd ms b">indexOf("🦌")</code>找到鲁道夫的位置。最后，我将索引转换成一对二维坐标。所有这些推理的基础是<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" rel="noopener ugc nofollow" target="_blank"> Array.prototype.flat() </a>方法。<code class="fe nb nc nd ms b">flat()</code>方法创建一个新的数组，所有的子数组元素递归地连接在一起，直到指定的深度。</p><p id="4763" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">翻译成代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><h1 id="0c25" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">最好的方法是什么？</h1><p id="0f44" class="pw-post-body-paragraph kz la iu lb b lc nf jv le lf ng jy lh li nh lk ll lm ni lo lp lq nj ls lt lu in bi translated">此时，我问自己:好吧，我有三种方法来寻找二维数组中的一个元素，但最有效的方法是什么？</p><p id="726b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了回答这个问题，我去寻找一些聪明的方法来衡量一个函数的性能。最好的方法是最常见的:记录各种函数多次执行同一操作所用的时间，并进行比较。在我的研究中，我发现了一些非常有益的读物。我推荐阅读Zell Liew的这篇文章，<a class="ae lw" href="https://zellwk.com/blog/performance-now/" rel="noopener ugc nofollow" target="_blank">测试JavaScript性能</a>。</p><p id="cb70" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我创建了一个函数来计算单个函数的执行时间:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><p id="61d4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后我创建了一组随机的森林来寻找驯鹿。我认为1，000，000个森林样本对我的测试来说已经足够了</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><p id="03ce" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我创建函数在每个森林中顺序搜索Rudolf:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><p id="3b59" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最后，我做了一些测试:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><p id="5133" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我得到这样的消息:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nk"><img src="../Images/89c489b1d5012705d163c064ed15c472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TANFrqHjxquUei_c.gif"/></div></div></figure><p id="341a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">似乎没有一种方法明显优于另一种方法。我决定将测试值保存在一个文件中，并尝试看看原始数据是否有帮助。我安装了一个额外的包，<code class="fe nb nc nd ms b"><a class="ae lw" href="https://www.npmjs.com/package/jsonexport" rel="noopener ugc nofollow" target="_blank">jsonexport</a></code>来帮助我转换<code class="fe nb nc nd ms b">resultGeneral</code>变量并创建一个CSV文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne ly l"/></div></figure><p id="dd6b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">将结果导入Excel后，我得到了这个图表:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nl"><img src="../Images/efc7b828abff9a7f031705f57a5894a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIdtVsswyiEDgLqEfd89WQ.jpeg"/></div></div></figure><p id="c60c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">好吧，关于什么？这么多的努力都白费了:在我的测试中，三种方法的性能几乎相当。但现在是时候放下键盘，拿起灯笼，帮助森林里的精灵找到鲁道夫了。</p><p id="b531" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">感谢阅读！敬请关注更多内容。</p></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="9ef0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">不要错过我的下一篇文章—报名我的</em> </strong> <a class="ae lw" href="https://medium.com/subscribe/@el3um4s" rel="noopener"> <strong class="lb iv"> <em class="lv">中邮箱列表</em> </strong> </a></p><div class="nt nu gq gs nv nw"><a href="https://el3um4s.medium.com/membership" rel="noopener follow" target="_blank"><div class="nx ab fp"><div class="ny ab nz cl cj oa"><h2 class="bd iv gz z fq ob fs ft oc fv fx it bi translated">通过我的推荐链接加入Medium—Samuele</h2><div class="od l"><h3 class="bd b gz z fq ob fs ft oc fv fx dk translated">阅读萨缪尔的每一个故事(以及媒体上成千上万的其他作家)。不是中等会员？在这里加入一块…</h3></div><div class="oe l"><p class="bd b dl z fq ob fs ft oc fv fx dk translated">el3um4s.medium.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok kt nw"/></div></div></a></div></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="5643" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="lv">原载于2021年12月2日https://blog.stranianelli.com</em><a class="ae lw" href="https://blog.stranianelli.com/3-ways-to-find-an-item-in-an-array-of-arrays/" rel="noopener ugc nofollow" target="_blank"><em class="lv"/></a><em class="lv">。</em></p></div></div>    
</body>
</html>