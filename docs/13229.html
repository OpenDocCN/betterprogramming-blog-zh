<html>
<head>
<title>Does Variable Name Length Affect Python Code Speed?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">变量名长度影响Python代码速度吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/does-variable-name-length-affect-python-code-speed-6b0b115007a6?source=collection_archive---------2-----------------------#2022-08-09">https://betterprogramming.pub/does-variable-name-length-affect-python-code-speed-6b0b115007a6?source=collection_archive---------2-----------------------#2022-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="447f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探究Python内部，了解大小的重要性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/70d3caa0ef88a497217f01b5ab1bba2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qQ9-wHOMGnId79OT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@charlesdeluvio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> charlesdeluvio </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="89ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经从事代码优化工作有一段时间了，您可能会遇到以下问题:变量名的长度是否会以任何方式影响代码运行时性能？</p><p id="0647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，您可能认为使用三个字符的变量名在执行速度方面与更具描述性的名称不会有太大区别。此外，没有人会为了损失几毫秒而让他们的代码无法阅读。</p><p id="9b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是接下来你会想得更多，并开始问自己:“但是说真的，变量名长度会影响代码性能吗？”。这是一个合理且非常有趣的问题。</p><p id="cfbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当编程语言源代码被编译成机器代码时，变量的概念就失去了意义。剩下的所有对象、类、函数和所有这些高级概念只是内存地址、跳转指令和简单的操作。特别是，变量被转换成内存地址和偏移量。</p><p id="1883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Python源代码通常不直接编译成机器代码，而是由默认的Python解释器<a class="ae ky" href="https://en.wikipedia.org/wiki/CPython" rel="noopener ugc nofollow" target="_blank"> CPython </a>解释。更准确地说，CPython在执行之前将源代码编译成字节码。然而，在编译过程中，它仍然保留对变量名的引用。否则，Python就不能打印出像这样的漂亮而有价值的错误信息:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9197" class="ma mb it lw b gy mc md l me mf">Traceback (most recent call last):<br/>  File "/home/nic/Desktop/er.py", line 7, in &lt;module&gt;<br/>    foo()<br/>  File "/home/nic/Desktop/er.py", line 4, in foo<br/>    a<br/>NameError: name 'a' is not defined</span></pre><h1 id="81b9" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">性能基准</h1><p id="cd98" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">弄清楚变量名是否影响代码性能的第一步是编写代码并收集一些数据。对于这个测试示例，我决定创建两个简单的函数:一个使用单字符变量，而另一个函数使用4014196个字符(4MB)的超长名称。</p><p id="0902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用内置的<code class="fe nc nd ne lw b">timeit</code>模块执行基准测试。在下面的代码片段中，我用一个更短的描述性名称替换了4MB长的名称，所以您不必下载整个8MB的要点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="57d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，基准测试结果非常不一致。有时候一个功能更快；有时另一个，如下图所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b7e0" class="ma mb it lw b gy mc md l me mf">Short time: 0.08893431029973727<br/>Long time:  0.07757537399993453<br/><br/>Short time: 0.08859034220022295<br/>Long time:  0.07780963819968748<br/><br/>Short time: 0.08343082869996579<br/>Long time:  0.10756722440019076<br/><br/>Short time: 0.08072503170042182<br/>Long time:  0.07815180819961824<br/><br/>Short time: 0.07780468439996184<br/>Long time:  0.07831483780028066<br/><br/>Short time: 0.10425543720011773<br/>Long time:  0.09920399159964291</span></pre><p id="4bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果有任何运行时性能差异，像这样的极端测试用例应该会指出来。然而，还不要停止阅读:有趣的部分现在就来了。长变量名还在，所以它一定有所不同。</p><h2 id="c8c9" class="ma mb it bd mh nh ni dn ml nj nk dp mp li nl nm mr lm nn no mt lq np nq mv nr bi translated">分析字节码</h2><p id="6d11" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">为了更深入地探讨这个主题，让我们将这两个函数分成不同的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f19e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将它们编译成字节码，方法是用</p><p id="3a3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne lw b">python3 -m &lt;file_name&gt;</code></p><p id="b68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在当前目录中生成一个包含编译后的Python代码的<code class="fe nc nd ne lw b">__pycache__</code>文件夹。如果我们用十六进制编辑器检查生成的文件，我们可以看到变量名在编译后仍然存在，并且出现在字节代码中。</p><p id="5cbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，变量名在字节码中只出现一次，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/fa0486336ef98bc86394560c389ddf5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOqOfoxrRR4ikEJM2nQgrA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为“<code class="fe nc nd ne lw b">short_name.py"</code>文件生成的字节码</p></figure><p id="33ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着CPython仍然保留变量名，但像编译语言一样使用另一种方法来引用它。这意味着我们必须深入了解引擎盖下发生了什么。</p><h2 id="013f" class="ma mb it bd mh nh ni dn ml nj nk dp mp li nl nm mr lm nn no mt lq np nq mv nr bi translated">分解字节码</h2><p id="820e" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">现在，我们可以对字节码进行逆向工程以发现变量是如何被引用的，或者我们可以使用<a class="ae ky" href="https://godbolt.org/" rel="noopener ugc nofollow" target="_blank">编译器资源管理器</a>通过简单地复制粘贴Python源代码来轻松地反汇编它。</p><p id="62a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不懂汇编语言也不用担心。我会对每一行进行彻底的评论，这样任何人都可以理解发生了什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="893c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这是你第一次阅读汇编语言，你可能需要花更多的时间来阅读注释，以彻底理解每条指令的作用。</p><p id="c3f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从图中可以看到，Python在程序中多次加载了<code class="fe nc nd ne lw b">short_name</code>变量。那么，如何才能在字节码中只看到一次呢？如果你仔细注意引用<code class="fe nc nd ne lw b">short_name</code>时右边的数字，你会发现它们总是<code class="fe nc nd ne lw b">0</code>。这个数字是局部范围内的对象地址，并引用它而不是它的变量名。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9bc5" class="ma mb it lw b gy mc md l me mf">2 STORE_FAST                0 (short_name)<br/>16 LOAD_FAST                0 (short_name)<br/>22 STORE_FAST               0 (short_name)</span></pre><p id="f4f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，括号中的变量名仅由编译器资源管理器添加，以提高可读性，它不是字节代码的一部分。</p><p id="691d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在局部作用域中添加其他变量来进一步证明最右边的数字是对象地址，看看这个数字是如何相应变化的。我将在下面的代码片段中只显示相关的装配线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道Python只使用一次变量名，并使用它的作用域地址来引用它。但是，变量名长度是如何影响代码执行速度的呢？</p><h2 id="e549" class="ma mb it bd mh nh ni dn ml nj nk dp mp li nl nm mr lm nn no mt lq np nq mv nr bi translated">加载和解析</h2><p id="eabe" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在之前的<code class="fe nc nd ne lw b">timeit</code>基准测试中，我们已经证明了变量名的长度与运行速度无关。然而，那是因为源代码已经被编译成字节码了。</p><p id="e8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长变量名的速度劣势在于代码执行前的加载和解析步骤。为了检查这一点，我测试了我之前展示的两个单独的Python文件的执行速度，<code class="fe nc nd ne lw b">short_name.py</code>和<code class="fe nc nd ne lw b">long_name.py</code>，使用Unix命令<code class="fe nc nd ne lw b">time</code>来测量一个命令执行的时间。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3a4c" class="ma mb it lw b gy mc md l me mf">$ time python3 short_name.py</span><span id="cbda" class="ma mb it lw b gy nt md l me mf">real 0m0,032s<br/>user 0m0,028s<br/>sys 0m0,004s</span><span id="fbed" class="ma mb it lw b gy nt md l me mf">$ time python3 long_name.py</span><span id="e022" class="ma mb it lw b gy nt md l me mf">real 0m0,173s<br/>user 0m0,148s<br/>sys 0m0,024s</span></pre><p id="76aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我多次重复测试，以确保数据中没有噪声。</p><p id="5209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe nc nd ne lw b">short_name.py</code>比<code class="fe nc nd ne lw b">long_name.py</code>花费的时间少得多。这是因为Python需要首先将文件加载到内存中。其次，它得把源代码编译成字节码，然后才能执行程序。这意味着文件越大，处理它的时间就越长。</p><p id="a701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基准测试结果的差异仅仅是由于文件大小的巨大差异，正如您在这里看到的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b78b" class="ma mb it lw b gy mc md l me mf">$ ls -lh</span><span id="0a2c" class="ma mb it lw b gy nt md l me mf">-rw-r--r--  1 nic nic 7,7M  8 ago 11.05 long_name.py<br/>-rw-r--r--  1 nic nic  127  8 ago 11.11 short_name.py</span></pre><p id="ebb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne lw b">long_name.py</code>占用近8MB内存，而<code class="fe nc nd ne lw b">short_name.py</code>只有127字节，难怪后者运行速度明显更快。然而，这是一个极端的情况，你不需要使用太长的变量名来改变加载和编译的速度。</p><h1 id="661b" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="c7ad" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">总而言之，变量名长度会影响Python程序的速度，因为较大的文件需要较长的处理时间，如Unix <code class="fe nc nd ne lw b">time</code>基准测试所示。然而，一旦编译了源代码，性能差异就小于由其他不相关因素(如同时运行的其他进程)引起的随机噪声，如<code class="fe nc nd ne lw b">timeit</code>基准所示，因此完全可以忽略不计。</p><p id="3d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不应该为了最初几毫秒的速度优势而牺牲代码的可读性。如果您担心由于程序太大而导致的内存(磁盘和RAM)利用率，您可能希望研究一下<a class="ae ky" href="https://en.wikipedia.org/wiki/Minification_(programming)" rel="noopener ugc nofollow" target="_blank">缩小</a>，即在不改变其功能的情况下从源代码中删除所有不必要的字符的过程(就像您在web开发中看到的那些<code class="fe nc nd ne lw b">.min.js</code>文件)。</p><p id="7e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。如果你有什么要补充的，请在评论中分享你的想法。感谢阅读！</p><p id="1e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于编译器资源管理器，我用来反汇编Python源代码的工具，看看下面这个故事:</p><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/compiler-explorer-a-must-have-tool-for-software-developers-98e7f4d6e94c"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">编译器资源管理器:软件开发人员的必备工具</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">从一个舒适的浏览器选项卡中轻松分析、比较和优化源代码</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">better编程. pub</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>