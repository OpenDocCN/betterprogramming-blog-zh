<html>
<head>
<title>Clock-In/Out System Part 6: Basic Front End — Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下班打卡系统第6部分:基本前端—角度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/part-6-clock-in-out-system-basic-frontend-an-7e5f9ed08c3f?source=collection_archive---------0-----------------------#2019-01-18">https://betterprogramming.pub/part-6-clock-in-out-system-basic-frontend-an-7e5f9ed08c3f?source=collection_archive---------0-----------------------#2019-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9bd3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NestJS + Angular教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/27028d592125269574905771e8218205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*KhCkmbtORw2Ux3n5WCrtzA.png"/></div></figure><p id="cb5f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这篇文章是我描述上下班打卡系统的系列文章的一部分。如果你想了解更多，你可以阅读以下内容:</p><ul class=""><li id="ace6" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-1-clock-in-out-system-diagram-a0a51bab02a7?source=post_page---------------------------" rel="noopener">上下班打卡系统第1部分:图</a></li><li id="02aa" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-2-clock-in-out-system-basic-backend-i-authmodule-66d4a5c56122?source=post_page---------------------------" rel="noopener">上下班打卡系统第二部分:基础后端— AuthModule </a></li><li id="f56b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-3-clock-in-out-system-basic-backend-ii-usersmodule-a56f42b20f62?source=post_page---------------------------" rel="noopener">上下班打卡系统第3部分:基本后端——用户模块</a></li><li id="570e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-4-clock-in-out-system-basic-backend-iii-appmodule-850dd17883e?source=post_page---------------------------" rel="noopener">上下班打卡系统第4部分:基础后端— AppModule </a></li><li id="4035" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-5-clock-in-out-system-seed-database-and-migration-data-cf037be21aac?source=post_page---------------------------" rel="noopener">上下班打卡系统第5部分:种子数据库和迁移数据</a></li><li id="09ca" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-6-clock-in-out-system-basic-frontend-an-7e5f9ed08c3f?source=post_page---------------------------" rel="noopener">上下班打卡系统第6部分:基本前端</a></li><li id="cb20" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-7-deploy-backend-nestjs-docker-docker-compose-2429c0b6aa9c?source=post_page---------------------------" rel="noopener">上下班打卡系统第7部分:使用Docker/Docker-Compose部署后端(NestJS)</a></li><li id="8948" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-8-clock-in-out-system-deploy-frontend-angular-6-using-environments-ad267325d3b6?source=post_page---------------------------" rel="noopener">上下班打卡系统第8部分:使用环境部署前端(角度6+)</a></li><li id="e6a0" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-9-testing-backend-testing-2d021f48403b?source=post_page---------------------------" rel="noopener">上下班打卡系统第9部分:后端测试——服务的单元测试</a></li><li id="9ede" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-10-testing-backend-testing-unit-testing-controllers-4177370ef581?source=post_page---------------------------" rel="noopener">上下班打卡系统第10部分:后端测试——控制器单元测试</a></li><li id="ddde" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第11部分:后端测试-e2e测试</li><li id="9c7b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第12部分:前端测试单元测试</li><li id="701a" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第13部分:前端测试集成测试</li></ul><p id="0feb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是我们打卡上班/下班系统前端的第一部分，它已经有了一个基本的、功能性的后端。前端将使用JS框架<a class="ae lv" href="https://www.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>开发，因为Angular是软件架构意义上的最佳框架。我的意图不是引发一场关于哪个是最好或最差的JavaScript框架的战争。这是一篇关于我自己的系统的文章，尽管我确信有更好的解决方案来开发我的软件的这一层:-)。</p><p id="3264" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/603eb548959587307227e91f8e35b4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bYID6EW0MszXitX4.gif"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="565f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">我们走吧！</h1><p id="c53b" class="pw-post-body-paragraph kq kr it ks b kt nf ju kv kw ng jx ky kz nh lb lc ld ni lf lg lh nj lj lk ll im bi translated">第一步是使用<a class="ae lv" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>创建一个新项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nk"><img src="../Images/b75459e5b7f8ef09bf8a290fa3f32faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBL-sUzQ0-tSXo2xSUPYDA.png"/></div></div></figure><p id="d96b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们的上下文中，不需要路由，因为我们的前端不是<a class="ae lv" href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener ugc nofollow" target="_blank"> SPA </a>。(OMG！那你为什么用Angular？因为这是一个简单的教程，展示如何整合<a class="ae lv" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank">nestj</a>+<a class="ae lv" href="https://www.angular.io/" rel="noopener ugc nofollow" target="_blank">Angular</a>。</p><p id="9464" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下一步是安装几个依赖于我们代码的库(<a class="ae lv" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular Material </a>):</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3b01" class="nq mo it nm b gy nr ns l nt nu">npm i @angular/cdk @angular/animations @angular/material</span></pre><p id="23bc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们的项目有三个要点:</p><ol class=""><li id="6a4a" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll nv ls lt lu bi translated"><strong class="ks iu"> AppModule </strong>:这是主模块，负责启动其他模块。</li><li id="b921" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nv ls lt lu bi translated"><strong class="ks iu"> UserComponent </strong>:该组件用于添加新用户及其密钥。(这只是为了管理目的，虽然没有任何安全性。)</li><li id="1a82" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nv ls lt lu bi translated"><strong class="ks iu"> TicketingComponent </strong>:这是最重要的组件，因为它用应该在大楼中工作的用户的信息来刷新屏幕。</li></ol><p id="0aa3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我将展示并解释每个模块。</p><h1 id="00df" class="mn mo it bd mp mq nw ms mt mu nx mw mx jz ny ka mz kc nz kd nb kf oa kg nd ne bi translated">AppModule</h1><p id="b254" class="pw-post-body-paragraph kq kr it ks b kt nf ju kv kw ng jx ky kz nh lb lc ld ni lf lg lh nj lj lk ll im bi translated">这是用于启动其他模块的模块。在下面的代码中，我正在加载模块:</p><p id="f716" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">角状材料</strong></p><p id="a2e5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">MatTableModule :这个表格会显示在大楼里的用户列表。</p><p id="6b30" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> MatInputModule </strong>:这提供了将用于添加用户-键对的表单输入。</p><p id="3fd6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> RouterModule </strong>:该模块用于加载打卡/下班和管理页面。</p><p id="143d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> FormsModule </strong>:在我们的项目中需要这个模块来使用模板驱动的表单。</p><p id="0292" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">浏览器模块</strong>和<strong class="ks iu">浏览器模块</strong>:这些是在浏览器中使用Angular(和动画)所需的模块。</p><p id="6dd1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> HttpClientModule </strong>:该模块将用于使用HTTP协议与前端和后端进行通信。</p><p id="2460" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe ob oc od nm b">Route[]</code>是加载组件的路径。在我们的例子中，这非常简单，因为默认路径将加载<code class="fe ob oc od nm b">TicketingComponent</code>，路径<code class="fe ob oc od nm b">/user</code>将加载我们的管理页面(<code class="fe ob oc od nm b">UserComponent</code>)。</p><p id="c83a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，我们必须在<code class="fe ob oc od nm b">AppModule</code> : <code class="fe ob oc od nm b">AppComponent</code>、<code class="fe ob oc od nm b">UserComponent</code>和<code class="fe ob oc od nm b">TicketingComponent</code>中声明我们的组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oe"><img src="../Images/d604aacf2f2402ae4bbd466b91e70087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlKbBS3AaldYZhX9BcaPSg.png"/></div></div></figure><p id="bf3b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe ob oc od nm b">AppComponent</code>是我们应用的引导程序。这个组件只运行<code class="fe ob oc od nm b">router-outlet</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi of"><img src="../Images/da04c1bb149adb145c4ea14c233ab9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCXDW11BLAG1R6gIbT0vlw.png"/></div></div></figure><h1 id="7389" class="mn mo it bd mp mq nw ms mt mu nx mw mx jz ny ka mz kc nz kd nb kf oa kg nd ne bi translated">常数和环境</h1><p id="fb9b" class="pw-post-body-paragraph kq kr it ks b kt nf ju kv kw ng jx ky kz nh lb lc ld ni lf lg lh nj lj lk ll im bi translated">在我们开发的任何软件中，我们都需要不同的常量和环境变量。例如，http://localhost:420 <strong class="ks iu"> 0 </strong>是开发Angular应用程序的传统URI，尽管在部署应用程序时需要更改域或端口。为此，Angular为我们提供了在不同环境之间变化的配置。</p><p id="b81a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">文件<code class="fe ob oc od nm b">AppSettings</code>可以定义我们所有的常量。最重要的常量是APIENDPOINT，它由文件<code class="fe ob oc od nm b">environment</code>提供。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi og"><img src="../Images/f929e6e3198675fda74b7ec0d4951cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sE-LerIthjLeph633v8mmQ.png"/></div></div></figure><p id="3e3c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在开发Angular应用程序时，默认情况下会加载<code class="fe ob oc od nm b">environment</code>文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi of"><img src="../Images/72a66c02e9466904aa2617393efcde6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ySFg0s64E9RCm6TljD1wQ.png"/></div></div></figure><p id="53a1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe ob oc od nm b">environment.production.ts</code>文件中唯一的不同是<code class="fe ob oc od nm b">APIENDPOINT_BACKEND</code>常量，它包含部署我们的应用程序的机器的名称(在我们的例子中，是一个docker容器)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oh"><img src="../Images/4561205b73001d170bbcf46ffbb77ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGtW7sr7hmhHAZOKX0kDNQ.png"/></div></div></figure><h1 id="e13b" class="mn mo it bd mp mq nw ms mt mu nx mw mx jz ny ka mz kc nz kd nb kf oa kg nd ne bi translated">票务组件</h1><p id="6ef0" class="pw-post-body-paragraph kq kr it ks b kt nf ju kv kw ng jx ky kz nh lb lc ld ni lf lg lh nj lj lk ll im bi translated">票务组件是这个项目中最有趣的代码，因为它是使用<a class="ae lv" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>开发的，使系统接近实时。这个例子没有使用redux，所以从逻辑部分使用双重数据绑定来刷新模板。该组件的模板如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oi"><img src="../Images/79b40d4a2a0a6cfb072283768f32511b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOglaVPJSlisE-cC6km0eg.png"/></div></div></figure><p id="e282" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可能注意到模板有几个<code class="fe ob oc od nm b">Observable$</code>，它们是使用管道<code class="fe ob oc od nm b">async</code>呈现的。例如，在下面的代码中，<code class="fe ob oc od nm b">span</code>标签呈现了可观察对象<code class="fe ob oc od nm b">timestamp$</code>的订阅结果。这个管道是传统的<code class="fe ob oc od nm b">subscribe</code>方法的语法糖。你可以在官方文档中读到更多关于这个管道的信息。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1f88" class="nq mo it nm b gy nr ns l nt nu">&lt;span class="right"&gt; {{ timestamp$ | async }}&lt;/span&gt;</span></pre><p id="b3a9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">模板的另一个有趣的地方是组件<code class="fe ob oc od nm b">Material Datatable</code>的使用，它可以使用输入<code class="fe ob oc od nm b">[source]</code>接收一组要呈现在表格或可观察对象中的数据。然而，在我们的例子中，<code class="fe ob oc od nm b">Datatable</code>将接收一组数据(之后管道<code class="fe ob oc od nm b">async</code>完成它的工作)。此外，数据显示在两个不同的表格中。使用方法<code class="fe ob oc od nm b">middle</code>将数据分成两组。</p><p id="14c4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">CSS非常简单，如以下代码所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oj"><img src="../Images/b66b6e7e19f9c135d61af84135b5f18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTCSM2Ghf2FOSyZ7cMuNag.png"/></div></div></figure><p id="744c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然这篇文章不是关于CSS的，但是你必须知道永远不要使用<code class="fe ob oc od nm b">id</code>来设计你的网站。你可以在<a class="ae lv" href="https://dev.to/claireparker/reasons-not-to-use-ids-in-css-4ni4" rel="noopener ugc nofollow" target="_blank">开发到</a>、<a class="ae lv" href="https://csswizardry.com/2011/09/when-using-ids-can-be-a-pain-in-the-class/" rel="noopener ugc nofollow" target="_blank"> CSSWizard </a>和<a class="ae lv" href="https://www.developingdesigns.com/stop-using-ids-in-your-css/" rel="noopener ugc nofollow" target="_blank">开发设计</a>中了解更多相关信息。</p><p id="ce35" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们的CSS文件很简单，因为它只是设计了我们的表格(必须有一个49.50%的<code class="fe ob oc od nm b">width</code>和不同的字体大小调整)。</p><p id="baab" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我现在将揭示这篇文章中最有趣的一段代码，即<code class="fe ob oc od nm b">TicketingComponent</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ok"><img src="../Images/2d7625e6f85da7d46501e01553dcbb3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rqzp4ihwKATBfUsZ_tz-DA.png"/></div></div></figure><p id="6c29" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它具有以下属性:</p><ul class=""><li id="83a0" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe ob oc od nm b">usersAbsent$</code>:这是包含<em class="ol">不在</em>大楼内的用户列表的可观察对象。</li><li id="a9df" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe ob oc od nm b">usersPresent$</code>:这是包含<em class="ol">在大楼里的</em>用户列表的可观察对象。</li><li id="4a0d" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe ob oc od nm b">timestamp$</code>:这是包含来自服务器的时间戳的可观察对象。</li><li id="0498" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe ob oc od nm b">displayedColumns</code>:包含将在表格中显示的列数组。</li></ul><p id="96c1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">非常重要的是要记住，我们在代码中使用observables来通过使用<a class="ae lv" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>操作符为我们提供流操作的能力。这些观察值是使用模板中的管道<code class="fe ob oc od nm b">async</code>订阅的。</p><p id="dd6b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们的下一步是组件构造函数，真正的魔力出现了！您必须理解<a class="ae lv" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>中的流，才能理解以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oe"><img src="../Images/f87f637b5f81a5030ddadd58595c759e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQjwroGQrG_ciP2YAv7yMg.png"/></div></div></figure><p id="a21c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该代码执行以下操作:</p><p id="32fb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用<code class="fe ob oc od nm b">timer</code>操作符创建可观察对象<code class="fe ob oc od nm b">interval$</code>，这又会每隔3000毫秒触发一次调用。在接下来的代码行中，您可以看到可观察对象<code class="fe ob oc od nm b">data$</code>是如何从可观察对象<code class="fe ob oc od nm b">interval$</code>创建的，后者使用<code class="fe ob oc od nm b">httpClient</code>服务运行http请求。</p><p id="f93d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后，<code class="fe ob oc od nm b">get</code>请求返回一个包含用户列表和时间戳的对象(来自服务器)。这段代码的两个部分特别相关:</p><ol class=""><li id="7ee7" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll nv ls lt lu bi translated">操作符<code class="fe ob oc od nm b">switchMap</code>用于在发出新请求时取消未完成的请求(以避免同时发出几个请求)。</li><li id="176e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nv ls lt lu bi translated">运算符<code class="fe ob oc od nm b">retryWhen</code>用于处理服务器错误。例如，如果客户端或服务器中的连接丢失，您将需要重试请求。当代码有错误时，将在3000毫秒内重试请求。</li></ol><p id="e459" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">好了，现在可观察的<code class="fe ob oc od nm b">data$</code>有了一个包含用户列表和时间戳信息的流。可观察对象<code class="fe ob oc od nm b">users$</code>是从可观察对象<code class="fe ob oc od nm b">data$</code>创建的，它在每个数据流中进行析构。这就是<code class="fe ob oc od nm b">map</code>操作员在那里的原因。如果你已经理解了前面的代码，你就可以想象可观测的<code class="fe ob oc od nm b">timestamp$</code>是如何产生的了。这个时间戳是Unix格式的。我们需要将其转换为DATE_FORMAT (DD/MM/YYYY)。</p><p id="c723" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">或许你现在可以想象<code class="fe ob oc od nm b">usersPresent$</code>和<code class="fe ob oc od nm b">usersAbsent$</code>可观察量是如何从<code class="fe ob oc od nm b">users$</code>可观察量中产生的。对于这些可观测值，你必须使用<a class="ae lv" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank">RxJS</a>T3】操作符来创建一个新的可观测值，使用Array.prototype <code class="fe ob oc od nm b">filter</code>方法。最后一步是创建私有的<code class="fe ob oc od nm b">isPresent</code>和<code class="fe ob oc od nm b">isAbsent</code>方法，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi om"><img src="../Images/22d318435e646bc01457c62bab7acb4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHP7nzhXFbvYPmv2c6fH-g.png"/></div></div></figure><p id="fd89" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些方法基本上都是检查用户是否得到了系统的授权，动作是<code class="fe ob oc od nm b">INPUT</code>还是<code class="fe ob oc od nm b">OUTPUT</code>。</p><p id="c8ca" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">完整的控制器代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oe"><img src="../Images/22ced349f0167f47ed97e52565bc55aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RkuV3mZfGSaqFZ0raQbsxw.png"/></div></div></figure><h1 id="3bd2" class="mn mo it bd mp mq nw ms mt mu nx mw mx jz ny ka mz kc nz kd nb kf oa kg nd ne bi translated">用户组件</h1><p id="7bc3" class="pw-post-body-paragraph kq kr it ks b kt nf ju kv kw ng jx ky kz nh lb lc ld ni lf lg lh nj lj lk ll im bi translated">我们基本前端的最后一个组件是<code class="fe ob oc od nm b">UserComponent</code>，它是一个简单的表单，用于向我们的数据库添加用户和密钥。构建这个组件的想法与在<code class="fe ob oc od nm b">TicketingComponent</code>中使用的组件相同。因此，执行操作<code class="fe ob oc od nm b">subscribe</code> s的模板使用<code class="fe ob oc od nm b">async</code>管道。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi on"><img src="../Images/5b64e12628917d32b2ec38e6359b163d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9C6F5I9TLcYyQogFRVc4gQ.png"/></div></div></figure><p id="7878" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该模板使用<code class="fe ob oc od nm b">ng-container</code>的if-else在无人拥有密钥时显示一条消息。</p><p id="9c61" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe ob oc od nm b">UserComponent</code>代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oo"><img src="../Images/9725d672faac531a39ae1040b2e946fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcbadFxtpTQecdv7ytDSTw.png"/></div></div></figure><p id="43b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本例中，我们定义了四个相关属性:</p><ol class=""><li id="6929" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll nv ls lt lu bi translated">Observable <code class="fe ob oc od nm b">users$</code>，包含用户的uid列表。</li><li id="8e65" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nv ls lt lu bi translated">字符串<code class="fe ob oc od nm b">userID</code>，包含从模板中选择的用户标识。</li><li id="b32e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nv ls lt lu bi translated">字符串<code class="fe ob oc od nm b">key</code>，它是将分配给用户的键。</li><li id="a50f" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nv ls lt lu bi translated">可观察/主题<code class="fe ob oc od nm b">update$</code>，它让我们知道动作已经成功更新。</li></ol><p id="eb4e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该构造函数与<code class="fe ob oc od nm b">TicketingComponent</code>中的构造函数非常相似。它通过使用<code class="fe ob oc od nm b">switchMap</code>和<code class="fe ob oc od nm b">map</code>操作符从后端恢复用户的UID列表。</p><p id="5b95" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，<code class="fe ob oc od nm b">save</code>方法用后端要求保存信息的对象向后端发出请求<code class="fe ob oc od nm b">POST</code>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="e0f5" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="9fbc" class="pw-post-body-paragraph kq kr it ks b kt nf ju kv kw ng jx ky kz nh lb lc ld ni lf lg lh nj lj lk ll im bi translated">‌In这一块，我已经解释了我的基本前端<strong class="ks iu">，</strong>用Angular和RxJS开发，以确保一个接近实时的系统(使用轮询作为与服务器连接的技术)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/741c25c5e4d498357f82c86c0fc88a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9qxZNnXW2nfISGI2.gif"/></div></div></figure><p id="2476" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">GitHub项目是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out" rel="noopener ugc nofollow" target="_blank">https://github.com/Caballerog/clock-in-out</a>。<br/>这一块的GitHub分支是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out/tree/part6-basic-frontend" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/clock-in-out/tree/part 6-basic-frontend</a>。</p></div></div>    
</body>
</html>