<html>
<head>
<title>11 Refactoring Patterns To Elevate Your Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升Python代码的11种重构模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/11-refactoring-patterns-to-elevate-your-python-code-a47dbe5826d?source=collection_archive---------0-----------------------#2021-04-06">https://betterprogramming.pub/11-refactoring-patterns-to-elevate-your-python-code-a47dbe5826d?source=collection_archive---------0-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d56" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们扩展一下<em class="ki">重构</em>的定义，以包括新的功能</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/ad74dd9c51ac2e436bf871f141c702c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__ryJQAuT1PYMzNUD8rc9w.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">适当的重构降低了技术债务(图片由<a class="ae kz" href="https://unsplash.com/@ryland_dean?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ryland Dean </a>在<a class="ae kz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="8c9e" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">不同类型的重构</h1><p id="9b35" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我计划在<a class="ae kz" href="https://www.photon-ai.com/" rel="noopener ugc nofollow" target="_blank"> Photonai </a>代码库中增加稳定性和性能，并降低维护成本。我在原始代码基础上添加了集群功能，并改变了架构。</p><p id="9fe5" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">一个小的代码重构任务通常是修复bug。一些人认为如果错误修复发生在发布测试之前，那就不是重构。</p><p id="fca8" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">一个重要的代码重构项目的例子是使一个程序符合2000年，但不改变功能。Y2K就绪使代码能够在2000年1月1日或以后正确运行。(是的，这是一个东西！)</p><blockquote class="na nb nc"><p id="7edf" class="lz ma nd mb b mc mv ju me mf mw jx mh ne mx mk ml nf my mo mp ng mz ms mt mu im bi translated">“重构是一种重组现有代码体的训练有素的技术，改变其内部结构而不改变其外部行为。”— <a class="ae kz" href="https://martinfowler.com/books/refactoring.html" rel="noopener ugc nofollow" target="_blank">马丁·福勒</a></p></blockquote><p id="ebd1" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">嗯，也许这是正确的，但我在内部扩展了定义:</p><blockquote class="na nb nc"><p id="feed" class="lz ma nd mb b mc mv ju me mf mw jx mh ne mx mk ml nf my mo mp ng mz ms mt mu im bi translated">“重构是一种训练有素的技术，用于重组现有的代码体，改变其内部结构，<strong class="mb iu">这也可能导致其外部行为发生变化</strong>。”—匿名</p></blockquote><div class="nh ni gp gr nj nk"><a href="https://medium.com/continuousdelivery/refactoring-workflows-da982d08d2c7" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">重构工作流</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">重构是一种改进现有代码库设计的受控技术。其实质是运用一种…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kt nk"/></div></div></a></div><p id="c1c6" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我重新定义了重构的定义，因为说“重构并添加代码项目”或者仅仅是“添加代码项目”是非常不酷的(更重要的是，上层管理层开始认为重构=好。)</p><p id="88a2" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我称之为“重构项目”我知道许多人可能认为我这样做是错误的。</p><p id="4c50" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">重构的定义(被我)扩大到对现有代码基础的任何改变都是重构。如果您可以向应用程序、框架、包或代码集添加少量或大量的功能，那么您就是在重构代码集。</p><p id="3d1e" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在本文中，当添加的功能本质上是重构方法的一部分时，将对其进行讨论。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="c1e3" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">1.删除不需要的注释</h1><p id="0ff5" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">当您通读并理解代码时，您会遇到不再相关的注释和注释代码。删除它。您提高了可读性并减少了代码量。</p><p id="0a70" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">你可能认为<code class="fe nz oa ob oc b"># 'fab... </code>评论应该保留。我决定删除它，因为它不是一般性的，而是对最初程序员(研究者)兴趣的一个注解。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="8aa8" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">2.将常数赋给变量</h1><p id="5f36" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">将常量放入变量中可以使它们位于一个位置。如果它们位于一个地方，那么更改它们的成本要低得多，维护代码集的成本也要低得多。还有其他原因，比如可读性更好。</p><p id="2be7" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在我看来，较低的维护成本是使用将常量赋给变量模式的主要驱动力。你可以和我争论，称之为一种模式。请将它放入你想要的任何分类方案中。这仍然是一个很好的重构实践。</p><p id="ad12" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在下面的示例中，代码片段显示了将常量赋值给变量重构。现在想象你将字符串<code class="fe nz oa ob oc b">‘Classifcation'</code>、<code class="fe nz oa ob oc b">'Regression'</code>和<code class="fe nz oa ob oc b">'Clustering'</code>分配给<code class="fe nz oa ob oc b">ELEMENT_TYPES</code>。然后你把<code class="fe nz oa ob oc b">'Regression'</code>分散在整个代码中。</p><p id="3f60" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">将常量赋值给变量的重构本身几乎没有降低维护成本。如果您在整个代码中将所有的<code class="fe nz oa ob oc b">'Regression'</code>引用都改为<code class="fe nz oa ob oc b">ELEMENT_TYPES[REGRID]</code>，那将是最好的。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f20b" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">注意</strong>:找出上例中的错误。请注意纠正这个错误是多么容易，而不是在分散在包中的多个位置进行纠正。</p><p id="f567" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">注意</strong>:错误确实影响行为。它通过了测试，但没有通过代码审查。</p><p id="60b1" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">注意</strong> : CLSFID和其他全局变量遵循PEP-8风格指南。你可以用PEP-8检查你所有的代码。你可以用黑色的<a class="ae kz" href="https://pypi.org/project/black/" rel="noopener ugc nofollow" target="_blank">把你的代码重新格式化成PEP-8风格。不要误解我。还有其他工具用于PEP-8样式检查和重新格式化。我更喜欢黑色<strong class="mb iu">。</strong></a></p><p id="a4c9" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">注意</strong>:我们缩短了许多全局名称，因为我们觉得它们太长了，会影响80或更少字符宽的屏幕的可读性。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="a55b" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">3.修复Bug或添加新代码</h1><p id="cd2e" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我对bug修复的定义可以称为“由他人添加功能”。<em class="nd"/>如果是架构变更，我认为是bug修复。添加集群和所有相关的代码添加和更改会导致实质性的架构重构。</p><p id="7dbe" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">注意:我认为“架构重构”是这个活动更好的术语。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="a4f3" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">4.修改字典中的关键字</h1><p id="1c91" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我没有做一个更技术性的副标题，比如给字典名称-功能映射增加一个新的层次，主要是因为我认为这是一个足够窄的重构模式。</p><p id="8d5a" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在重构之前修改Photonai的字典中用于聚类的键的一个例子是:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0967" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">修改字典中的键并将常量分配给变量重构后:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="2fc6" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">5.将重复代码转换成装饰器</h1><p id="e682" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">挑战在于，通常没有多少重复的代码可以通过消除来重构。</p><p id="0b83" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我应该改变规则来重构重复的代码片段。</p><p id="9812" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">Python对于在顶部或底部或两者都有重复模式的代码有一个很好的解决方案。解决方案是一个可以绕过差异中间代码的包装器，在Python <strong class="mb iu">中称为<em class="nd">装饰器</em>。</strong></p><p id="912b" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">函数或方法是装饰器的内联代码参数。装饰器包装函数/方法(f)。通过包装f，装饰器在f之前调用代码，然后调用f，然后在f之后调用代码，然后返回结果f。</p><p id="e907" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">Decorator(ed) <em class="nd"> </em>代码可读性更强，维护成本更低。</p><p id="fb14" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">广泛使用的装饰者之一是<code class="fe nz oa ob oc b">register_DataFrame_method()</code>。It decorator函数和方法，使它们能够从DataFrame实例中被功能性地调用。你可以在创作者<a class="ae kz" href="https://zsailer.github.io/software/pandas-flavor/" rel="noopener ugc nofollow" target="_blank">扎克·赛勒</a> <strong class="mb iu">写的博文《<a class="ae kz" href="https://zsailer.github.io/software/pandas-flavor/" rel="noopener ugc nofollow" target="_blank">写出你自己的熊猫味道</a>》中读到。</strong></p><p id="1581" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面的代码片段<em class="nd"> </em>详细描述了装饰者<code class="fe nz oa ob oc b">register_DataFrame_method</code>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure><div class="nh ni gp gr nj nk"><a href="https://www.pythonforthelab.com/blog/how-to-use-decorators-part-2/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">如何使用装饰者第2部分</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">Decorators是一种有益的编程模式，它允许以很少的代价改变函数的行为</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">www.pythonforthelab.com</p></div></div><div class="nt l"><div class="of l nv nw nx nt ny kt nk"/></div></div></a></div><p id="c511" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">你可能会问自己“装饰者<em class="nd"> </em> <code class="fe nz oa ob oc b">register_DataFrame_method()</code>与重构重复性代码片段重构活动有什么关系？”</p><p id="4c90" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我来回答一个问题。您会重复添加哪些代码来包装函数，以便它们从DataFrame实例中调用？</p><p id="ba1f" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面的例子展示了我们如何转换函数<code class="fe nz oa ob oc b">statistic() </code>，以便从DataFrame实例中调用它。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="5d6e" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">6.将Python&gt;3.7类转换为Python≤3.7 @dataclass</h1><p id="5bcc" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><code class="fe nz oa ob oc b">@dataclass</code>在Python 3.7中新增。<strong class="mb iu"> </strong>它的引入是为了消除使用Python &gt; 3.7类导致的样板文件。<code class="fe nz oa ob oc b">@dataclass</code>实现了一个用于参数初始化的<code class="fe nz oa ob oc b">__init__()</code>方法、一个用于字符串表示的<code class="fe nz oa ob oc b">__repr__()</code>方法和一个用于对象比较的<code class="fe nz oa ob oc b">__eq__()</code>方法。所有与实例化、打印和比较数据类实例相关的样板文件都在<code class="fe nz oa ob oc b">@dataclass</code>内部。</p><p id="5ab2" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面是一个使用新的<code class="fe nz oa ob oc b">@dataclass</code>装饰器的例子:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="bde3" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">注意</strong>:任何复杂类型都必须包含<code class="fe nz oa ob oc b">field(default_factory=dict)</code> <strong class="mb iu"> </strong>，如<code class="fe nz oa ob oc b">list</code>或<code class="fe nz oa ob oc b">dict</code>。</p><p id="3e04" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">有关<code class="fe nz oa ob oc b">@dataclass</code>的更多详情，请访问:</p><div class="nh ni gp gr nj nk"><a href="https://dr-bruce-cottman.medium.com/twelve-dataclass-examples-for-better-python-code-d1318f362d93" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">更好的Python代码的12个@dataclass示例</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">我们用12个前后代码示例展示了@dataclass如何将Python代码转换成更好的Python代码。</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">dr-bruce-cottman.medium.com</p></div></div><div class="nt l"><div class="og l nv nw nx nt ny kt nk"/></div></div></a></div></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="e0bf" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">7.消除不必要的代码语句</h1><p id="d380" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我把消除不必要的语句放在这里，因为它在<insert language="">程序员中出现得太频繁了。当一个算法被编码和增量更新以通过测试时，它自然地出现在代码中。</insert></p><p id="f542" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">如果你想产生干净、可读的代码，你需要删除不必要的代码和注释。在向他人展示或发布代码之前，仔细检查代码，删除不必要的语句。</p><p id="1b69" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在下面的代码中，删除第1行、第2行、第3–6行和第8行的注释。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="af53" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">由代码审查来捕捉这种不必要的代码反模式。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="3931" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">8.代码提升</h1><p id="910e" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">代码提升是消除不必要的代码语句模式的子模式。这是一种重构模式，因为它在代码集中经常出现。</p><p id="b2a6" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">当一个或多个语句出现在两个或多个条件分支上时，就会发生代码提升。那些多余的语句被从条件式中“吊”了出来。</p><p id="57b9" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在某些情况下，条件消除了一个或多个分支。通常，这将导致异常变得更加明确。</p><p id="9c88" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">移除是微妙的，有潜在的危险。有些人认为不应该删除，因为这通常不会提高性能或可读性。(我们的编码标准规定了这一点，所以我们这样做是为了不在代码审查中失去印象分)。</p><p id="2d60" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">注意</strong>:代码提升导致代码行(LOC)复杂度指标降低。</p><p id="7a7a" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面是后一种代码提升的示例:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7d21" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">注</strong>:我个人觉得这段代码经过重构后更容易理解。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="f377" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">9.记录代码</h1><p id="ad65" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">总是可以有更多的docstrings。最起码的是你需要理解的文档区域和你添加的任何代码。</p><p id="e6e1" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">一个服务不足的领域是隐藏方法，那些标有<em class="nd">邓德斯</em>(双下划线符号)的方法。<code class="fe nz oa ob oc b">__init__</code>或<code class="fe nz oa ob oc b">_xxxx</code>是缺乏关注的方法的典型代表。</p><p id="cbc1" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面是函数<code class="fe nz oa ob oc b">toContinuousCategory</code>的文档示例以及最佳实践用法的研究笔记。(还有，选长例的例子。)</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7c14" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">有许多文档字符串样式。我用的是<a class="ae kz" href="http://google.github.io/styleguide/pyguide.html" rel="noopener ugc nofollow" target="_blank">谷歌</a>风格。原始样式、Sphinx以及docstrings示例将在下一篇文章中详细介绍。</p><div class="nh ni gp gr nj nk"><a href="https://medium.com/better-programming/the-guide-to-python-docstrings-3d40340e824b" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">开始编写Python文档字符串</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">简化你的生活和任何试图阅读你的代码的人的生活</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div><div class="nt l"><div class="oh l nv nw nx nt ny kt nk"/></div></div></a></div></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="5445" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">10.放入类型提示</h1><p id="4c84" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我考虑加入类型提示重构，并且我写了一篇专门讨论它的文章:</p><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/twenty-type-hinting-techniques-and-tools-for-better-python-code-e877e0b0c679"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">更好的Python代码的20种类型提示技术和工具</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">让我们讨论一下为什么类型提示技术和工具可以改进您的Python代码</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">better编程. pub</p></div></div><div class="nt l"><div class="oi l nv nw nx nt ny kt nk"/></div></div></a></div><p id="c6da" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我修改了Photonai代码，使其包含一致的类型提示<em class="nd">。</em></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="4395" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">11.更新测试套件</h1><p id="ae15" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我发现每个组织在发布测试之前都有自己的指导方针。我的指导方针是:</p><ul class=""><li id="e719" class="oj ok it mb b mc mv mf mw mi ol mm om mq on mu oo op oq or bi translated">代码必须遵循PEP-8格式风格指南。</li><li id="588e" class="oj ok it mb b mc os mf ot mi ou mm ov mq ow mu oo op oq or bi translated">测试套件必须覆盖代码集的85%以上。</li><li id="9d2a" class="oj ok it mb b mc os mf ot mi ou mm ov mq ow mu oo op oq or bi translated">对于任何更改的函数或方法，必须有一个或多个测试。</li><li id="1934" class="oj ok it mb b mc os mf ot mi ou mm ov mq ow mu oo op oq or bi translated">任何新的函数、方法类和数据类都必须有一个或多个测试。</li><li id="4f44" class="oj ok it mb b mc os mf ot mi ou mm ov mq ow mu oo op oq or bi translated">测试套件必须是自动化的。</li></ul></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="0c84" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">摘要</h1><p id="d64b" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">重构的定义已经扩大到“对现有代码基础的任何改变都是重构。你可以向一个应用程序、框架、包或一些代码集添加少量或大量的功能，你正在重构那个代码集。</p><p id="f141" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我们讨论了在Photonai包中使用的11种重构方法。重构Photonai包的目标是添加无监督聚类算法。</p><p id="1d79" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我希望这些关于重构的文章能对你有所帮助。</p><p id="d35d" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">编码快乐！</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="a354" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">资源</h1><p id="04e3" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><a class="ae kz" href="https://realpython.com/python-pep8/" rel="noopener ugc nofollow" target="_blank">如何用PEP 8写出漂亮的Python代码</a></p><div class="nh ni gp gr nj nk"><a href="https://github.com/python-rope/rope/blob/master/docs/overview.rst#refactorings" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">蟒蛇绳/绳子</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">这个文件的目的是给出rope的一些特性的概述。它是不完整的。还有一些功能…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="ox l nv nw nx nt ny kt nk"/></div></div></a></div></div></div>    
</body>
</html>