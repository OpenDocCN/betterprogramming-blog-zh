<html>
<head>
<title>How To Handle Worker Threads in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中处理工作线程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-handle-worker-threads-in-node-js-4657cb8c1adf?source=collection_archive---------12-----------------------#2021-04-08">https://betterprogramming.pub/how-to-handle-worker-threads-in-node-js-4657cb8c1adf?source=collection_archive---------12-----------------------#2021-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd58" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">揭开Node.js中线程的神秘面纱</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9d9d66895020ba176c3c65ff1c86f8e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*Lp3iKxdC96JShDAF.jpg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="9405" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们经常谈论Node的单线程特性如何使Node应用程序易于扩展和节省资源。但是这也使得<a class="ae lq" href="https://livecodestream.dev/post/when-you-should-and-should-not-use-nodejs-for-your-project/" rel="noopener ugc nofollow" target="_blank">节点不适合用于实现CPU密集型任务</a>。</p><p id="50dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是为了解决这个问题，Node在其v10.5.0版本中引入了工作线程的概念。工作线程提供了一种生成新线程的机制，以处理节点程序中的CPU密集型任务。</p><p id="025a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在本教程中，我们将向您简单介绍工作线程以及如何使用它们。然而，为了理解为什么工作线程很重要，让我们首先讨论为什么Node在处理CPU密集型任务时性能很差。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d6f9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">为什么Node不能处理CPU密集型任务？</h1><p id="f85a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们称运行在节点程序中的单线程为事件循环。当事件被触发时，节点使用它来处理下面的执行。</p><p id="496c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果事件的执行代价很高，比如CPU受限和I/O受限的任务，Node无法在事件循环中运行它，除非长时间阻塞唯一可用的线程。</p><p id="8eed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，事件循环不会等待代价高昂的操作完成，而是注册附加到事件的回调函数，并继续处理循环中的下一个事件。</p><p id="7b25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">昂贵的操作被卸载到一组叫做<em class="mv">工作线程池的辅助线程上。</em>工作池中的一个线程异步执行任务，一旦操作完成就通知事件循环。</p><p id="69d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，事件循环在其线程上执行为该操作注册的回调函数。</p><p id="f5cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为回调是在事件循环上运行的，如果它们中的任何一个包含CPU密集型操作，比如机器学习或大数据中使用的复杂数学计算，它就会在相当长的时间内阻塞事件循环。在此期间，应用程序不会执行事件循环中的任何其他任务，包括响应来自客户端的请求。</p><p id="b585" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种情况会大大降低节点应用程序的性能。因此，在很长一段时间里，Node被认为不适合处理CPU密集型操作。</p><p id="5650" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是工作线程的引入为这个问题提供了一个解决方法。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="251f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">工作线程是如何工作的？</h1><p id="442f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在v10中，Node引入了工作线程作为实验特性。在v12中变得稳定。工作线程的行为并不完全像传统的多线程系统，因为它们不是JavaScript本身内置的特性。</p><p id="470b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是它们允许将昂贵的任务委托给单独的线程，而不是阻塞应用程序的事件循环。那么工作线程实际上是如何工作的呢？</p><p id="1c42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工作线程的职责是运行由父线程或主线程指定的一段代码。每个工人与其他工人隔离运行。但是，工作线程及其父线程可以通过消息通道来回传递消息。</p><p id="2174" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当JavaScript不支持多线程时，为了运行相互隔离的工作线程，工作线程使用一种特殊的机制。</p><p id="3730" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们都知道Node运行在Chrome的V8引擎之上。V8支持创建独立的V8运行时。这些被隔离的实例被称为<a class="ae lq" href="https://v8docs.nodesource.com/node-0.8/d5/dda/classv8_1_1_isolate.html" rel="noopener ugc nofollow" target="_blank"> V8 Isolate </a>，它们有自己的JavaScript堆和微任务队列。</p><p id="1eba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工作线程在这些隔离的V8引擎上运行，每个工作线程都有自己的V8引擎和事件队列。换句话说，当workers处于活动状态时，一个节点应用程序有多个节点实例在同一个进程中运行。</p><p id="06b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使JavaScript本身不支持并发，worker threads也提供了一种在单个进程中运行多个线程的方法。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8d7b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">创建和运行新员工</h1><p id="516b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在这个例子中，我们将执行一个任务来计算斐波那契数列的第<em class="mv"> n </em>项。这是一个CPU密集型任务，如果在没有工作线程的情况下执行，它将阻塞我们的节点应用程序的单个线程，特别是随着第<em class="mv"> n </em>项的增加。</p><p id="aa42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将实现分成两个文件。第一个是<code class="fe mw mx my mz b">app.js</code>，这是主线程执行的代码，包括一个新工作线程的创建。第二个文件<code class="fe mw mx my mz b">worker.js</code>，包含我们将创建的worker运行的代码。这是CPU密集型斐波那契计算的代码应该在的地方。</p><p id="2f8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何在父线程中处理新工作线程的创建。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="3a43" class="ne lz it mz b gy nf ng l nh ni">const {Worker} = require("worker_threads");</span><span id="e37a" class="ne lz it mz b gy nj ng l nh ni">let num = 40;</span><span id="3342" class="ne lz it mz b gy nj ng l nh ni">//Create new worker<br/>const worker = new Worker("./worker.js", {workerData: {num: num}});</span><span id="359d" class="ne lz it mz b gy nj ng l nh ni">//Listen for a message from worker<br/>worker.once("message", result =&gt; {<br/>  console.log(`${num}th Fibonacci Number: ${result}`);<br/>});</span><span id="75db" class="ne lz it mz b gy nj ng l nh ni">worker.on("error", error =&gt; {<br/>  console.log(error);<br/>});</span><span id="0efc" class="ne lz it mz b gy nj ng l nh ni">worker.on("exit", exitCode =&gt; {<br/>  console.log(exitCode);<br/>})</span><span id="40e4" class="ne lz it mz b gy nj ng l nh ni">console.log("Executed in the parent thread");</span></pre><p id="b153" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用<code class="fe mw mx my mz b">Worker</code>类来创建一个新的工作线程。当创建一个新的<code class="fe mw mx my mz b">Worker</code>实例时，它接受以下参数。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="caab" class="ne lz it mz b gy nf ng l nh ni">new Worker(filename[, options])</span></pre><p id="3dd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，filename参数指的是文件的路径，该文件包含应该由工作线程执行的代码。因此，我们需要传递<code class="fe mw mx my mz b">worker.js</code>文件的文件路径。</p><p id="bd89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mw mx my mz b">Worker</code>构造器也接受一些选项，你可以参考 <code class="fe mw mx my mz b"><a class="ae lq" href="https://nodejs.org/api/worker_threads.html#worker_threads_class_worke" rel="noopener ugc nofollow" target="_blank">Worker</a></code> <a class="ae lq" href="https://nodejs.org/api/worker_threads.html#worker_threads_class_worke" rel="noopener ugc nofollow" target="_blank">类</a>的<a class="ae lq" href="https://nodejs.org/api/worker_threads.html#worker_threads_class_worke" rel="noopener ugc nofollow" target="_blank">官方文档。然而，我们选择只使用<code class="fe mw mx my mz b">workerData</code>选项。当开始运行时，通过<code class="fe mw mx my mz b">workerData</code>选项传递的数据将可供工人使用。我们可以使用这个选项轻松地将<em class="mv"> n </em>的值传递给斐波那契数列计算器。</a></p><p id="d9b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了在执行完成时接收结果，父线程将一些事件侦听器附加到工作线程。</p><p id="648c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个实现中，我们选择监听三个事件。它们是:</p><ul class=""><li id="87c5" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated"><code class="fe mw mx my mz b">message</code>:当工作者向父母发布消息时，触发该事件。</li><li id="29c0" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mw mx my mz b">error</code>:当运行工人时发生错误时触发。</li><li id="2ec2" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mw mx my mz b">exit</code>:当工人退出执行时触发。如果在<code class="fe mw mx my mz b">process.exit()</code>调用后退出，退出代码将被设置为<code class="fe mw mx my mz b">0</code>。如果用<code class="fe mw mx my mz b">worker.terminate()</code>终止执行，代码将是<code class="fe mw mx my mz b">1</code>。</li></ul><p id="132b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在message事件中，worker使用连接worker和parent的消息通道发送消息。我们将在后面的小节中看到消息传递是如何工作的。</p><p id="8b8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦创建了工作线程，父线程就可以继续执行，而无需等待结果。当我们运行上面的代码时，在返回第<em class="mv"> n </em>个斐波那契数列之前，字符串<code class="fe mw mx my mz b">Executed in the parent thread</code>被记录到控制台。</p><p id="c34c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们看到这样的输出:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="3b6c" class="ne lz it mz b gy nf ng l nh ni">Executed in the parent thread<br/>40th Fibonacci Number: 102334155</span></pre><p id="4a1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们在<code class="fe mw mx my mz b">worker.js</code>文件中编写由worker实现的代码。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="a676" class="ne lz it mz b gy nf ng l nh ni">const {parentPort, workerData} = require("worker_threads");</span><span id="6c37" class="ne lz it mz b gy nj ng l nh ni">parentPort.postMessage(getFib(workerData.num))</span><span id="08e2" class="ne lz it mz b gy nj ng l nh ni">function getFib(num) {<br/>    if (num === 0) {<br/>      return 0;<br/>    }<br/>    else if (num === 1) {<br/>      return 1;<br/>    }<br/>    else {<br/>      return getFib(num - 1) + getFib(num - 2);<br/>    }<br/>}</span></pre><p id="9370" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们使用递归<code class="fe mw mx my mz b">getFib</code>函数来计算斐波纳契数列的第<em class="mv"> n </em>项。</p><p id="ba52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是更有趣的是我们通过<code class="fe mw mx my mz b">workerData</code>选项从父节点接收数据的方式。通过这个对象，工人可以访问创建时传递的<code class="fe mw mx my mz b">num</code>的值。</p><p id="016c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们还使用这个<code class="fe mw mx my mz b">parentPort</code>对象向父线程发送一条包含斐波那契计算结果的消息。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8d30" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">父线程和工作线程之间的通信</h1><p id="a661" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">正如您在前面的例子中看到的，<code class="fe mw mx my mz b">parentPort</code>对象允许工作线程与父线程通信。</p><p id="87fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个<code class="fe mw mx my mz b">parentPort</code>是<code class="fe mw mx my mz b">MessagePort</code>类的一个实例。当父母或工作者使用<code class="fe mw mx my mz b">MessagePort</code>实例发送消息时，消息被写入<code class="fe mw mx my mz b">M<a class="ae lq" href="https://nodejs.org/api/worker_threads.html#worker_threads_class_messagechannel" rel="noopener ugc nofollow" target="_blank">essageChannel</a></code>并触发<code class="fe mw mx my mz b">message</code>事件来通知接收者。</p><p id="02ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">父进程可以使用相同的<code class="fe mw mx my mz b">postMessage</code>方法向工作进程发送消息。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="bb63" class="ne lz it mz b gy nf ng l nh ni">worker.postMessage("Message from parent");</span></pre><p id="ac09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以随时使用<code class="fe mw mx my mz b">MessageChannel</code>在父母和工作者之间来回发送多条消息。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5bb7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">对待工人的更好方法</h1><p id="240d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在前面的例子中，我们创建的worker在一次Fibonacci计算结束时退出。有了这个实现，如果我们想计算另一个斐波那契数，我们就必须生成一个新的工作线程。</p><p id="425b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，使用独立的V8引擎和事件循环来生成工作线程是一项非常消耗资源的任务，尤其是考虑到在生产代码中遵循这种方法并不十分有效。</p><p id="09dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们可以重用同一个工作线程来执行每个计算，而不是为每个Fibonacci计算创建新的工作线程。这种行为是如何实现的。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="12c8" class="ne lz it mz b gy nf ng l nh ni">//worker.js<br/>const {parentPort} = require("worker_threads");</span><span id="4518" class="ne lz it mz b gy nj ng l nh ni">parentPort.on("message", data =&gt; {<br/>  parentPort.postMessage({num: data.num, fib: getFib(data.num)});<br/>});</span><span id="bf33" class="ne lz it mz b gy nj ng l nh ni">function getFib(num) {<br/>  if (num === 0) {<br/>    return 0;<br/>  }<br/>  else if (num === 1) {<br/>    return 1;<br/>  }<br/>  else {<br/>    return getFib(num - 1) + getFib(num - 2);<br/>  }<br/>}</span></pre><p id="a839" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mw mx my mz b">worker.js</code>中，我们设置worker监听来自其父节点的消息。</p><p id="fce5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">父节点没有通过<code class="fe mw mx my mz b">workerData</code>选项传递数据，而是选择通过消息传递数据。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="e333" class="ne lz it mz b gy nf ng l nh ni">//app.js</span><span id="6adb" class="ne lz it mz b gy nj ng l nh ni">const {Worker} = require("worker_threads");</span><span id="8e59" class="ne lz it mz b gy nj ng l nh ni">//Create new worker<br/>const worker = new Worker("./worker.js");</span><span id="f475" class="ne lz it mz b gy nj ng l nh ni">//Listen for a message from worker<br/>worker.on("message", result =&gt; {<br/>  console.log(`${result.num}th Fibonacci Number: ${result.fib}`);<br/>});</span><span id="aaee" class="ne lz it mz b gy nj ng l nh ni">worker.on("error", error =&gt; {<br/>  console.log(error);<br/>});</span><span id="cff0" class="ne lz it mz b gy nj ng l nh ni">worker.postMessage({num: 40});<br/>worker.postMessage({num: 12});</span></pre><p id="cfdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以使用同一个工作线程来运行多个CPU密集型操作。</p><p id="8ff4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，通过<code class="fe mw mx my mz b">postMessage</code>方法传递的数据，类似于作为<code class="fe mw mx my mz b">workerData</code>传递的数据，在发送给worker之前，使用<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" rel="noopener ugc nofollow" target="_blank">结构化克隆算法</a>进行克隆。这可以防止两个线程修改同一个对象时出现争用情况。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9d91" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">在父母和员工之间共享内存</h1><p id="6f3f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">节点工作线程允许应用程序在父线程和工作线程之间共享内存，类似于传统的多线程系统。</p><p id="a673" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">共享内存比克隆数据并在父线程和工作线程之间来回传递更有效。</p><p id="0fad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了在线程之间共享内存，我们使用了一个<code class="fe mw mx my mz b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" rel="noopener ugc nofollow" target="_blank">SharedArrayBuffer</a></code>。</p><p id="674e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像这样在两个线程之间共享内存可能会导致程序中出现竞争情况。<a class="ae lq" href="https://en.wikipedia.org/wiki/Race_condition" rel="noopener ugc nofollow" target="_blank">竞争条件</a>发生在两个线程试图同时读写同一内存位置的时候。</p><p id="ef77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics" rel="noopener ugc nofollow" target="_blank">原子</a>来解决这个问题。Atomics确保一个读或写操作在开始下一个操作之前完成。它防止了竞争情况的发生，因为现在在给定的时间只有一个线程可以访问共享内存。</p><p id="1913" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何用<code class="fe mw mx my mz b">Atomics</code>和<code class="fe mw mx my mz b">SharedArrayBuffer</code>实现内存共享。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="7484" class="ne lz it mz b gy nf ng l nh ni">const {Worker} = require("worker_threads");</span><span id="af10" class="ne lz it mz b gy nj ng l nh ni">let nums = [21, 33, 15, 40];</span><span id="965f" class="ne lz it mz b gy nj ng l nh ni">//get size of the array buffer with int32 size buffer for each element in the array<br/>const size = Int32Array.BYTES_PER_ELEMENT*nums.length;</span><span id="4818" class="ne lz it mz b gy nj ng l nh ni">//create the buffer for the shared array<br/>const sharedBuffer = new SharedArrayBuffer(size);<br/>const sharedArray = new Int32Array(sharedBuffer);</span><span id="d43f" class="ne lz it mz b gy nj ng l nh ni">nums.forEach((num, index) =&gt; {<br/>  Atomics.store(sharedArray, index, num);<br/>})</span><span id="f912" class="ne lz it mz b gy nj ng l nh ni">//Create new worker<br/>const worker = new Worker("./worker.js");</span><span id="814f" class="ne lz it mz b gy nj ng l nh ni">//Listen for a message from worker<br/>worker.on("message", result =&gt; {<br/>  console.log(`${result.num}th Fibonacci Number: ${result.fib}`);<br/>});</span><span id="0284" class="ne lz it mz b gy nj ng l nh ni">worker.on("error", error =&gt; {<br/>  console.log(error);<br/>});</span><span id="19fa" class="ne lz it mz b gy nj ng l nh ni">worker.postMessage({nums: sharedArray});</span></pre><p id="9a3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过这种实现，父线程和工作线程都可以从共享数组对象读取数据和向其写入数据。</p><p id="e839" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">worker执行的代码略有变化，因为现在我们传递的是一个数字数组，而不是单个数字。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="b97a" class="ne lz it mz b gy nf ng l nh ni">parentPort.on("message", data =&gt; {<br/>  data.nums.forEach(num =&gt; {<br/>    parentPort.postMessage({num: num, fib: getFib(num)});<br/>  });<br/>})</span></pre><p id="260b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工作线程会立即向父线程发送它计算的每个斐波那契数的消息，而不会等待整个过程完成。</p><p id="f949" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个实现中，尽管我们使用了<code class="fe mw mx my mz b">postMessage</code>方法向worker发送数据，但是在将数据发送给worker之前，它不会克隆数据。相反，它传递对共享数组对象的引用。</p><p id="3165" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在工作线程(如集群和子进程)之前提供的并行处理解决方案节点没有在线程之间共享内存的能力。这使得工作线程比这些解决方案更有优势。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8d2b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">线程工作池</h1><p id="3211" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">正如我们之前所讨论的，创建一个工人是一项成本很高的任务。这就是为什么我们决定重用同一个工作者，而不让它在一个任务执行后退出。我们可以更进一步，创建一个等待执行任务的工人池。</p><p id="c9ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们只有一个工作者时，应用程序必须等待，直到工作者被释放来接受新的任务。它会延迟应用程序对其他排队请求的响应时间。我们可以通过使用线程池来避免这种情况。</p><p id="81ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，该池可以从可用的工作线程中为我们提供一个非活动的工作线程，以便毫不延迟地执行任务。</p><p id="ed95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，工作线程还没有对工作池的本地支持。所以我们必须依靠第三方库来简化我们的任务。我们将使用<code class="fe mw mx my mz b"><a class="ae lq" href="http://node-worker-threads-pool npm package" rel="noopener ugc nofollow" target="_blank">node-worker-threads-pool</a></code> npm包。</p><p id="b0be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们如何使用这个包创建一个静态的工人池(即固定数量的工人)。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="bd35" class="ne lz it mz b gy nf ng l nh ni">const {StaticPool} = require("node-worker-threads-pool");</span><span id="ef7c" class="ne lz it mz b gy nj ng l nh ni">let num = 40;</span><span id="abf8" class="ne lz it mz b gy nj ng l nh ni">//Create a static worker pool with 8 workers<br/>const pool = new StaticPool({<br/>  size: 8,<br/>  task: "./worker.js"<br/>});</span><span id="9936" class="ne lz it mz b gy nj ng l nh ni">//Get a worker from the pool and execute the task<br/>pool.exec({num: num}).then(result =&gt; {<br/>  console.log(`${result.num}th Fibonacci Number: ${result.fib}`);<br/>});</span></pre><p id="3537" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们运行<code class="fe mw mx my mz b">pool.exec()</code>函数时，池提供一个非活动的工作线程来运行我们的任务。</p><p id="4df9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工作者的代码不需要通过任何改变来支持工作者池。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="d868" class="ne lz it mz b gy nf ng l nh ni">const {parentPort} = require("worker_threads");</span><span id="6de7" class="ne lz it mz b gy nj ng l nh ni">parentPort.on("message", data =&gt; {<br/>  parentPort.postMessage({num: data.num, fib: getFib(data.num)});<br/>})</span><span id="960e" class="ne lz it mz b gy nj ng l nh ni">function getFib(num) {<br/>  if (num === 0) {<br/>    return 0;<br/>  }<br/>  else if (num === 1) {<br/>    return 1;<br/>  }<br/>  else {<br/>    return getFib(num - 1) + getFib(num - 2);<br/>  }<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8154" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">摘要</h1><p id="ce5e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在本教程中，我们讨论了如何使用节点工作线程创建新线程来运行CPU密集型任务。将这些任务卸载到单独的线程有助于运行我们的节点应用程序，即使在处理CPU密集型任务时，性能也不会显著下降。</p><p id="bc26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管Node不支持传统方式的多线程，但worker threads为这个问题提供了一个很好的解决方法。因此，如果您认为节点应用程序不能有多个线程，那么是时候抛弃这种想法，尝试一下工作线程了。</p><p id="1b00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div></div>    
</body>
</html>