<html>
<head>
<title>SwiftUI ZStack vs Overlay Modifier: Similarities and Differences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI ZStack与覆盖修改器:相似与不同</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-zstack-x-overlay-modifier-which-is-the-real-difference-5a47dfa7ab1e?source=collection_archive---------1-----------------------#2022-03-05">https://betterprogramming.pub/swiftui-zstack-x-overlay-modifier-which-is-the-real-difference-5a47dfa7ab1e?source=collection_archive---------1-----------------------#2022-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3f04" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">比较叠加可视组件的两种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1a50e1f01372746b045a7f9a04b2ce7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-u3KfrOUXXA9P1t7cODVOA.jpeg"/></div></div></figure><p id="a1ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，这是我关于SwiftUI框架的第一篇文章，真的希望我能给你带来一些关于这个主题的知识。</p><p id="622d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天的文章关注这两种将一个可视组件叠加到另一个组件上的常用方法。当我了解到这两者时，我真的在试图找出何时使用其中一个，经过一些研究和一系列实验后，我会让它的特殊性变得非常清楚。</p><h1 id="6fa1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">ZStack vs. Overlays:它们是什么？</h1><p id="9ff3" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">好吧，让我们首先澄清什么是<code class="fe mk ml mm mn b">ZStacks</code>和<code class="fe mk ml mm mn b">overlay</code>修改器，以及在SwiftUI场景中应用它们的结果是什么。</p><p id="1217" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您可能已经知道的，堆栈是一个标准容器，用于跨一个轴放置其内部组件，包括x(水平)、y(垂直)和z(一个在另一个前面)。</p><p id="884e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe mk ml mm mn b">ZStack</code>的例子中，与UIKit相比，这相当于创建一个自定义UIView(或者另一个小部件)并开始在其中添加每个子视图。</p><p id="5202" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果将是一些视图出现在其他视图的前面，这取决于尺寸和支持的空间(当然在UIKit的情况下，约束关系到它们之间的位置)，但是它们都在同一个父视图中。当你把一个<code class="fe mk ml mm mn b">View1</code>和<code class="fe mk ml mm mn b">View2</code>放入一个<code class="fe mk ml mm mn b">ZStack</code>时，根据顺序和<code class="fe mk ml mm mn b">zindex</code>的不同，一个会覆盖它的“兄弟姐妹”的一部分。看下面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/5c74f08d4e85aa0ce34a9536abf8283a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdGnvd2jOuBr4ySx9bmzaA.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">如您所见，根据已建立的层次结构，蓝色矩形被放置在红色矩形的前面</p></figure><p id="4fe2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，我们在SwiftUI中也有一个修改器，允许您放置一个视图来覆盖另一个视图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/9cb0c716ed37a084ef28f8ea0843d7e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hr0GWJuVXAHGseF18Upbw.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">蓝色矩形放置在红色矩形的上面</p></figure><p id="8723" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，两种情况产生了相同的结果，我们把蓝色的矩形放在与另一个相同的z轴上。</p><p id="efbf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于这两种方法的另一个观察结果是，在这两种情况下，我们都可以指定重叠视图的对齐:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/0ecce8bdb0816f1e22dc984d1c7e4b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FG2GtLC7wtx-M6gd7-jQSQ.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">ZStack在顶部对齐其子视图</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/148066ce2feb704d7a5f42cd82148f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wHmL7X4vusj9zS931_exA.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">蓝色的矩形覆盖了顶端角落的红色</p></figure><p id="36b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们讨论了这两种方法之间的主要相似之处，但现在让我们讨论一下不同之处:</p><h2 id="f721" class="mw lo iq bd lp mx my dn lt mz na dp lx la nb nc lz le nd ne mb li nf ng md nh bi translated">栈指令</h2><p id="f419" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当我们处理<code class="fe mk ml mm mn b">ZStack</code>时，有一个关于视图在堆栈中放置顺序的非常重要的概念。有一个修改器应用到视图中，称为<code class="fe mk ml mm mn b">zIndex</code>。</p><p id="0242" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你已经和<code class="fe mk ml mm mn b">SpriteKit</code>一起工作过，你肯定知道这个概念。</p><p id="3788" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您将一些<code class="fe mk ml mm mn b">zIndex</code>应用于内部视图，则显示顺序完全由该参数定义:最大的<code class="fe mk ml mm mn b">zIndex</code>，它将更靠前。</p><p id="3545" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，<code class="fe mk ml mm mn b">zIndex</code>值等于0，如果两个视图有相同的<code class="fe mk ml mm mn b">zIndex</code>，那么产生的顺序将被堆栈中的顺序解开。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/f2f64d4e0e3fed533e6f5e8e9e6b3d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijs-AvO8hAhMU2UZ_edUAg.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">虽然蓝色矩形是在红色矩形之后定义的，但是它的zIndex较低，所以它留在后面</p></figure><p id="66ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe mk ml mm mn b">overlay</code>修改器时，没有预先定义的顺序。无论<code class="fe mk ml mm mn b">zIndex</code>值如何，每个放置在修改器内的视图层次都应该保持在前面，就是这样。</p><h2 id="392c" class="mw lo iq bd lp mx my dn lt mz na dp lx la nb nc lz le nd ne mb li nf ng md nh bi translated">剪辑时显示框架</h2><p id="7390" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当我提到框架时，你可能已经知道我在说什么。考虑到视图的大小(宽度和高度)，视图的框架只不过是其父视图的内部尺寸。它跟<code class="fe mk ml mm mn b">ZStack</code>和<code class="fe mk ml mm mn b">overlay</code>有什么关系？一切！主要是在剪辑视图内容时</p><p id="1809" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">ZStack</code>是一个动态容器，因此它的框架完全基于其内部内容。实际上，为了使一切可见，它的框架是由最大的子框架定义的。所以，如果我们剪辑了<code class="fe mk ml mm mn b">ZStack</code>，不管顺序如何，可见内容将完全是最大的内部视图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/b656de33957d05aa4a9543db6f749975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xCjsC8U4bEDZ6N3Q0L__g.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">ZStack框架由红色矩形定义</p></figure><p id="7070" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe mk ml mm mn b">overlay</code>案例中，情况有所不同。被覆盖的视图是主要焦点，即使覆盖视图有更大的框架，也只考虑由第一个视图定义的尺寸:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/18c398129f5fd19929417311f2bf7445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9SNqPNQwSp9N8yyNSU5k8w.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">现在修复红色矩形的可见内容是由蓝色矩形定义的，这是修改后的视图</p></figure><p id="da5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我可以用几句话来描述它们之间的差异:在<code class="fe mk ml mm mn b">ZStack</code>中，所有的子视图都是平等的，焦点停留在较大的视图上，而在<code class="fe mk ml mm mn b">overlay</code>中，修改后的视图是焦点，它的框架才是真正重要的。</p><h1 id="b0c5" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="c0da" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">所以，这两种方法产生的结果非常相似，意义也几乎相同。唯一的区别在于应用<code class="fe mk ml mm mn b">zIndex</code>和定义帧和剪辑时的两种特殊情况。我希望你从现在开始知道什么时候使用这两种方法。感谢阅读。</p></div></div>    
</body>
</html>