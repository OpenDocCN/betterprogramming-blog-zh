<html>
<head>
<title>How To Use Media Queries Programmatically in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中以编程方式使用媒体查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-media-queries-programmatically-in-react-4d6562c3bc97?source=collection_archive---------0-----------------------#2019-10-16">https://betterprogramming.pub/how-to-use-media-queries-programmatically-in-react-4d6562c3bc97?source=collection_archive---------0-----------------------#2019-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f819" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用断点挂钩#扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/37a5710f9e73a6b97b843b4b64eaafa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nif7gaXhWzDp6ANK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">艾伦·毕晓普在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React.js中获取媒体查询断点有时可以非常方便地在React.js中操作我们的UI，而不是编写CSS然后为其编写媒体查询。</p><p id="b56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" href="https://medium.com/better-programming/usebreakpoint-hook-get-media-query-breakpoints-in-react-3f1779b73568" rel="noopener">上一篇</a>文章中，我讨论了当设备宽度改变时，获得这些断点作为<code class="fe lv lw lx ly b">xs</code>、<code class="fe lv lw lx ly b">sm</code>、<code class="fe lv lw lx ly b">md</code>和<code class="fe lv lw lx ly b">lg</code>。在那里，我使用<code class="fe lv lw lx ly b">resize</code>事件讨论了<code class="fe lv lw lx ly b">useBreakpoint</code>钩子的实现。</p><p id="f13a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看其他比使用<code class="fe lv lw lx ly b">resize</code>事件更合法的实现方式。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4fe7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">匹配媒体</h1><p id="ceb3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了获得媒体查询断点，我们需要开始检验我们的媒体，或者换句话说，开始检验我们的设备；无论是小屏设备还是大屏设备。</p><p id="647e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何做到这一点？</p><p id="eee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，JavaScript在<code class="fe lv lw lx ly b">window</code>对象上为我们提供了一个<code class="fe lv lw lx ly b">matchMedia</code>方法。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="cea0" class="nh mh it ly b gy ni nj l nk nl">window.matchMedia('(max-width: 100px)')</span></pre><p id="cefa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像这样，我们将会看到我们的文档最大宽度是100像素。</p><p id="6dd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">matchMedia</code>方法返回一个<code class="fe lv lw lx ly b">MediaQueryList</code>对象，代表指定媒体查询的解析结果。</p><p id="eb47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，这个<code class="fe lv lw lx ly b">MediaQueryList</code>对象是我们实际用来确定<code class="fe lv lw lx ly b">document</code>何时匹配媒体查询，或者监视<code class="fe lv lw lx ly b">document</code>以检测它何时匹配或停止匹配媒体查询。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d159" class="nh mh it ly b gy ni nj l nk nl">const mql = window.matchMedia(<em class="nm">mediaQueryString</em>);</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b006" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用MediaQueryList</h1><p id="32e9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">MediaQueryList</code>时会出现两种情况:</p><ol class=""><li id="9d0e" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">当我们希望即时检查我们的文档是否匹配媒体查询，或者我们希望只检查一次，可能是在我们的主要React组件安装之后。</li><li id="5d6f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当我们不断检查我们的文档是否与媒体查询相匹配时。这种情况可能发生在当我们的设备的视窗宽度或高度可以改变时，比如说当我们将手机方向从纵向改为横向时。</li></ol><p id="bfc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第一种情况，当我们需要即时检查时，我们将简单地使用<code class="fe lv lw lx ly b">MediaQueryList</code> <code class="fe lv lw lx ly b">matches</code>属性。这是一个布尔属性，如果<code class="fe lv lw lx ly b">document</code>当前匹配媒体查询列表，则返回<code class="fe lv lw lx ly b">true</code>，否则返回<code class="fe lv lw lx ly b">false</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="59ff" class="nh mh it ly b gy ni nj l nk nl">mql.matches //returns true or false</span></pre><p id="5b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第二种情况，我们需要观察<code class="fe lv lw lx ly b">MediaQueryList</code>对象上的<code class="fe lv lw lx ly b">change</code>事件。为了开始监听<code class="fe lv lw lx ly b">change</code>事件，<code class="fe lv lw lx ly b">MediaQueryList</code>提供了一个名为<code class="fe lv lw lx ly b">addListener()</code>的方法。</p><p id="71f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，为了停止监听，我们有<code class="fe lv lw lx ly b">removeListener()</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c29b" class="nh mh it ly b gy ni nj l nk nl">const listenerFunc = () =&gt; {<br/>// Listening logic goes here</span><span id="4eaf" class="nh mh it ly b gy ob nj l nk nl">};</span><span id="3056" class="nh mh it ly b gy ob nj l nk nl">mql.addListener(listenerFunc);</span></pre><p id="43da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个侦听器函数不会在我们调整文档宽度、改变方向或其他事情时每次都运行，但它只会在两种情况下被触发。当我们的文档开始匹配<code class="fe lv lw lx ly b">mediaQueryString</code>或停止匹配<code class="fe lv lw lx ly b">mediaQueryString</code> <em class="nm">时。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="99f7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们要做的是</h1><p id="206c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们将从自定义钩子的用户那里得到一个对象，其中每个属性值都是一个媒体查询字符串。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7e77" class="nh mh it ly b gy ni nj l nk nl">const queries = {</span><span id="d0d5" class="nh mh it ly b gy ob nj l nk nl">xs: '(max-width: 320px)', //query for xs devices</span><span id="cdd9" class="nh mh it ly b gy ob nj l nk nl">sm: '(max-width: 720px)',</span><span id="7916" class="nh mh it ly b gy ob nj l nk nl">md: '(max-width: 1024px)'</span><span id="600c" class="nh mh it ly b gy ob nj l nk nl">}</span></pre><p id="6b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且，作为我们的输出，我们还期待一个对象，它具有在<code class="fe lv lw lx ly b">queries</code>对象中给定的所有键，其中属性/键的每个值都是布尔值。<code class="fe lv lw lx ly b">true</code>如果文档匹配查询，则<code class="fe lv lw lx ly b">false</code>否则。</p><p id="aeea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有一个640像素的视窗宽度，那么上面的<code class="fe lv lw lx ly b">queries</code>的输出将是:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="fa34" class="nh mh it ly b gy ni nj l nk nl">{</span><span id="38a7" class="nh mh it ly b gy ob nj l nk nl">xs: false,</span><span id="5054" class="nh mh it ly b gy ob nj l nk nl">sm: true,</span><span id="2780" class="nh mh it ly b gy ob nj l nk nl">md: true</span><span id="c4c4" class="nh mh it ly b gy ob nj l nk nl">}<br/>// here our matches are sm and md</span></pre><p id="6e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得上述输出，我们将遵循以下步骤:</p><ul class=""><li id="dc97" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu oc nt nu nv bi translated">我们将遍历<code class="fe lv lw lx ly b">queries</code>对象的每个属性，并为每个查询调用<code class="fe lv lw lx ly b">matchMedia()</code>(下面是代码1)。</li><li id="2b57" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oc nt nu nv bi translated">每次调用<code class="fe lv lw lx ly b">matchMedia</code>进行查询都会返回一个<code class="fe lv lw lx ly b">MediaQueryList</code>对象，我们将把<code class="fe lv lw lx ly b">MediaQueryList</code>对象存储到一个新的对象中，对应于同一个键(代码一)。</li><li id="2a0e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oc nt nu nv bi translated">同样为了获得当前的<code class="fe lv lw lx ly b">document</code>匹配查询，以便我们知道启动时我们的设备类型是什么，我们将在每个<code class="fe lv lw lx ly b">MediaQueryList</code>对象(代码一)上使用<code class="fe lv lw lx ly b">matches</code>属性。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码1</p></figure><ul class=""><li id="a087" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu oc nt nu nv bi translated">现在，我们还需要处理我们在<code class="fe lv lw lx ly b">queries</code>对象中的查询发生变化的情况，即当我们的文档开始或停止匹配查询时。为此，我们将使用<code class="fe lv lw lx ly b">addListener()</code>(代码二)监听每个<code class="fe lv lw lx ly b">MediaQueryList</code>项目上的<code class="fe lv lw lx ly b">change</code>事件。</li><li id="d303" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oc nt nu nv bi translated">我们将定义一个处理函数，在这个函数中，我们将遍历<code class="fe lv lw lx ly b">queries</code>对象的每个键，并保存每个<code class="fe lv lw lx ly b">MediaQueryList</code>对象的<code class="fe lv lw lx ly b">matches</code>属性的结果(代码二)。</li></ul><p id="67be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:每当我们的文档开始或停止匹配<code class="fe lv lw lx ly b">queries</code>对象中的任何查询时，都会调用这个处理函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码2</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="eba9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">React中的实现</h1><p id="172f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">检查媒体查询是我们代码中的一个副作用，所以我们将把这个逻辑放入一个<code class="fe lv lw lx ly b">useEffect</code>钩子中，并且我们还必须检查我们的浏览器是否支持<code class="fe lv lw lx ly b">matchMedia</code>。</p><p id="cff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们还必须维护一个状态，该状态将显示所有媒体查询的结果，无论这些结果是否与我们的<code class="fe lv lw lx ly b">document</code>匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码3</p></figure><p id="1951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以像使用其他钩子一样使用这个钩子了。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6aa2" class="nh mh it ly b gy ni nj l nk nl">import useBreakpoint from './useBreakpointext'</span><span id="35ca" class="nh mh it ly b gy ob nj l nk nl">const queries = {<br/>  xs: '(max-width: 320px)',<br/>  md: '(max-width: 720px)',<br/>  lg: '(max-width: '1024px)',<br/>}</span><span id="3b13" class="nh mh it ly b gy ob nj l nk nl">const App = () =&gt; {<br/>  const matchPoints = useBreakpoint(queries);<br/>  //Rest Code goes here<br/>} </span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d75d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">是一种高效的方式吗？</h1><p id="44cb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">不，你们中的一些人可能已经明白了，因为如果我们必须在成千上万个组件中使用<code class="fe lv lw lx ly b">useBreakpoint</code>钩子，那么我们必须一次又一次地调用<code class="fe lv lw lx ly b">useBreakpoint</code>。</p><p id="9891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致注册一个<code class="fe lv lw lx ly b">change</code>事件监听器，如果我们有几个挂载的组件，并且它们都使用<code class="fe lv lw lx ly b">useBreakpoint</code>钩子，那么这个监听器的效率会非常低。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f3e8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">那么什么是有效的方法呢？</h1><p id="3714" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这里，React上下文提供了帮助。</p><p id="acf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将使用上下文，然后使用我们的自定义钩子，而不是直接使用<code class="fe lv lw lx ly b">useBreakpoint</code>。</p><p id="bb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<code class="fe lv lw lx ly b">React.createContext(<em class="nm">defaltValue)</em></code> <em class="nm">创建一个上下文。</em></p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c2c7" class="nh mh it ly b gy ni nj l nk nl">const defaultValue = {};<br/>const BreakpointContext = createContext(defaultValue);</span></pre><p id="9b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须将我们想要访问上下文值的代码包装到一个<code class="fe lv lw lx ly b">Provider</code>中，在我们的例子中是<code class="fe lv lw lx ly b">BreakpointContext.Provider</code>，然后，为了访问那个值，我们将使用React钩子<code class="fe lv lw lx ly b">useContext</code>。</p><p id="2d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们不会直接使用<code class="fe lv lw lx ly b">BreakpointContext.Provider</code>，而是创建一个包装器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码4</p></figure><p id="bd08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">useBreakpoint</code>是一个函数，我们从中返回上下文值，这基本上是我们匹配的查询结果。</p><p id="a1ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把我们的应用程序包装在<code class="fe lv lw lx ly b">BreakpointProvider</code>中，并传递一个查询prop给它，而<code class="fe lv lw lx ly b">useBreakpoint</code>只能在被包装在<code class="fe lv lw lx ly b">BreakpointProvider</code>中的组件中使用。</p><p id="619c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们把所有的部分放在一起。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码5</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="245e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用</h1><p id="7cce" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">BreakpointProvider</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码6</p></figure><p id="f27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">useBreakpoint</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码7</p></figure><p id="f58a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们不仅可以使用此方法检查<code class="fe lv lw lx ly b">max-width</code>或<code class="fe lv lw lx ly b">min-width</code>，还可以检查方向和许多其他媒体查询。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8522" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参考</h1><div class="of og gp gr oh oi"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Testing_media_queries" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">以编程方式测试媒体查询</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">DOM提供了可以通过MediaQueryList接口以编程方式测试媒体查询结果的特性…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">developer.mozilla.org</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div></div></div>    
</body>
</html>