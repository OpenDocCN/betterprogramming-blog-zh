<html>
<head>
<title>How To Use Control Structures in Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在药剂中使用控制结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-control-structures-in-elixir-a8b2b134c1f5?source=collection_archive---------9-----------------------#2022-08-10">https://betterprogramming.pub/how-to-use-control-structures-in-elixir-a8b2b134c1f5?source=collection_archive---------9-----------------------#2022-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ca4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在灵丹妙药中使用格、条件、如果和除非</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/0c6ace4c7e86f0976a9d4560df04b82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bobWISMquSll2o0g9a3Imw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">摘自<a class="ae ku" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/</a></p></figure><p id="2c51" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在过去的条目中，我们看到了Elixir中的<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/learn-elixir-in-2023-a691d37f521">数据类型</a>和<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-pattern-matching-in-elixir-426709bb179a">模式匹配</a>。现在，我们将看到允许我们控制应用程序流程的函数。当然，你已经熟悉了一些if-else和case。</p><h1 id="97e7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">情况</h1><p id="a47a" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">它用于将一个结果与几个可能的值进行匹配。这个想法类似于模式匹配。我们想要匹配一个对象，根据它是否匹配，我们做一些事情，我们可以从同一个案例中获得值。让我们看看下面的语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="862b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请记住，pin运算符<code class="fe mq mr ms mt b">^</code>用于将现有值与模式进行匹配。让我们看一个关于这个操作符的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7473" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每个case子句都允许我们使用守卫来指定特殊条件，例如，确保某个值存在于某个区间中。让我们看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a162" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">值得一提的是，保护中的错误不会传播；他们只是让条款失效。例如，在下一个例子中，hd(1)失败，因为<code class="fe mq mr ms mt b">hd</code>函数需要一个非空列表作为参数。如果它没有失败，它只是传递到下一个子句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3957" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们有一个结构有一个不匹配的子句，我们将有一个异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="2ee4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Cond</h1><p id="048c" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">该控制结构用于匹配具有不同条件的结果，直到其评估为既不是<code class="fe mq mr ms mt b">:nil</code>也不是<code class="fe mq mr ms mt b">:false</code>的结果，必须始终存在评估为真的默认条件。</p><p id="9af7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">语法与case非常相似，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cfcc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果没有条件返回true，就会出现异常。下面的代码说明了这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ab61" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">重要的是要考虑到除了零或假以外的任何值都被认为是真的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="e0a4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">如果/除非</h1><p id="c62e" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">它们只对检查一个条件有用，就像<code class="fe mq mr ms mt b">unless</code>它和其他编程语言的其他<code class="fe mq mr ms mt b">if</code>非常相似。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a972" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mq mr ms mt b">Unless</code>相当于<code class="fe mq mr ms mt b">if</code>，但需要一个假值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2c68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这种情况下，代码块将返回一个<code class="fe mq mr ms mt b">nil</code>。<code class="fe mq mr ms mt b">if</code>和<code class="fe mq mr ms mt b">unless</code>都支持<code class="fe mq mr ms mt b">else</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cf0e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然而，对于<code class="fe mq mr ms mt b">unless</code>，不鼓励使用它，因为它不太易读。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="503a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果在诸如<code class="fe mq mr ms mt b">if/unless</code>、<code class="fe mq mr ms mt b">cond</code>或<code class="fe mq mr ms mt b">case</code>的块中声明或更改了任何变量，则声明和更改将仅在该结构中可见。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5b48" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们希望变量改变，我们必须将值重新分配给块的结果，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="8d06" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="1b5b" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">虽然一开始看起来很复杂，但我认为Elixir提供了非常有效的工具来控制应用程序的流程。这只是学习函数式编程语言如何工作的问题，然后你会爱上它的！</p></div></div>    
</body>
</html>