<html>
<head>
<title>Your Guide to Caching: From Top to Bottom</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存指南:从上到下</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/your-guide-to-caching-from-top-to-bottom-638d5fde9f01?source=collection_archive---------9-----------------------#2020-02-26">https://betterprogramming.pub/your-guide-to-caching-from-top-to-bottom-638d5fde9f01?source=collection_archive---------9-----------------------#2020-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ec6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">“计算机科学只有两个硬东西:缓存失效和事物命名”</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/cac62a67a0f767c5a952f6d358aecaa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ooP7nqxQOtoa0y2hNU5xtQ.png"/></div></div></figure><p id="2c64" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每个程序员都会遇到缓存。</p><p id="98d6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是一个核心和广泛的概念，每个程序员都应该深刻理解，它对于系统设计和性能关键型程序来说极其重要。</p><blockquote class="lr"><p id="cd91" class="ls lt it bd lu lv lw lx ly lz ma lq dk translated"><em class="ki">“计算机科学只有两个硬东西:缓存失效和事物命名。”—菲尔·卡尔顿</em></p></blockquote><p id="9ec9" class="pw-post-body-paragraph kv kw it kx b ky mb ju la lb mc jx ld le md lg lh li me lk ll lm mf lo lp lq im bi translated">技术来了又去，但原则往往保持不变。</p><p id="ab48" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在计算世界中，无处不在的技术源于缓存的概念。缓存是在多个抽象层中设计和实现的，从CDN、web浏览器、操作系统、CPU和算法设计。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mg"><img src="../Images/2470ce77444d34fb2e4e785bcf6349f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0km648lPxW66hRbl.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图1:缓存:自上而下</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="f69e" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">什么是缓存</h1><p id="b42b" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">Cachingexplained.com<a class="ae np" href="https://cachingexplained.com/#caching-explained" rel="noopener ugc nofollow" target="_blank">会给你缓存最好的解释。</a></p><blockquote class="nq nr ns"><p id="cef3" class="kv kw nt kx b ky kz ju la lb lc jx ld nu lf lg lh nv lj lk ll nw ln lo lp lq im bi translated">"缓存是存储数据的硬件或软件组件，以便将来对该数据的请求可以得到更快的服务；存储在缓存中的数据可能是早期计算的结果，也可能是存储在其他地方的数据的副本。—维基百科</p></blockquote><p id="57a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">缓存的基本思想是利用空间进行时间优化，这是大小和速度之间的权衡。</p><p id="d662" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">缓存用于以下情况:</p><ul class=""><li id="3d11" class="nx ny it kx b ky kz lb lc le nz li oa lm ob lq oc od oe of bi translated">读取操作多于写入操作。</li><li id="7aaf" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated">操作遵循<a class="ae np" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank">的局部性原则</a>。</li></ul><p id="f5fd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">缓存的好处包括增加读取吞吐量和减少后端负载。</p><p id="a9d3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下是与缓存相关的一些关键方面:</p><h2 id="b9e6" class="ol mt it bd mu om on dn my oo op dp nc le oq or ne li os ot ng lm ou ov ni ow bi translated"><strong class="ak"> 1。命中率</strong></h2><pre class="kk kl km kn gt ox oy oz pa aw pb bi"><span id="053b" class="ol mt it oy b gy pc pd l pe pf"> 𝑁(ℎ𝑖𝑡) / (𝑁(ℎ𝑖𝑡)+𝑁(𝑚𝑖𝑠ℎ𝑖𝑡))</span></pre><p id="e99b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">未命中意味着提取的内容不在缓存中，将发出额外的请求来提取它。显然，命中率越高，缓存的工作效率越高。</p><h2 id="5fad" class="ol mt it bd mu om on dn my oo op dp nc le oq or ne li os ot ng lm ou ov ni ow bi translated"><strong class="ak"> 2。缓存数据访问和更新策略</strong></h2><p id="1b7c" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">有多种<a class="ae np" href="https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/" rel="noopener ugc nofollow" target="_blank">缓存策略</a>，我们应该根据数据访问模式，也就是如何读写数据来选择合适的策略。</p><p id="df36" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">此外，通常的高速缓存是以有限的大小实现的。当缓存已满时，我们需要选择哪些缓存内容将被逐出(或替换为新数据)，这里有几种常见的策略:</p><ul class=""><li id="5e7e" class="nx ny it kx b ky kz lb lc le nz li oa lm ob lq oc od oe of bi translated">最近最少使用(LRU)。</li><li id="ee1d" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated">最不常用(LFU)。</li><li id="26e2" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated">最近使用的(MRU)。</li><li id="f361" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated">先进先出(FIFO)。</li></ul><p id="356a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同时，缓存可能会引入一些其他问题，如数据不一致。</p><h2 id="7faf" class="ol mt it bd mu om on dn my oo op dp nc le oq or ne li os ot ng lm ou ov ni ow bi translated"><strong class="ak"> 3。单一或分布式缓存</strong></h2><p id="a6f7" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">分布式缓存适用于高流量的站点，在分布式环境中会复杂得多。</p><p id="34bd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们讨论缓存的一些经典用法。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="41d0" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">加拿大</h1><p id="3414" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated"><a class="ae np" href="https://www.globaldots.com/content-delivery-network-explained" rel="noopener ugc nofollow" target="_blank"> CDN </a>(内容交付网络)是一个至关重要的互联网基础设施，实现了缓存的概念。</p><p id="36d2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">CDN改善了网页的加载时间，加快了点播视频下载和流媒体播放的速度。</p><p id="0e68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们在流式传输网飞的视频时，客户端从地理上离我们最近的CDN节点下载视频，而不是直接从中央服务器获取视频，从而缩短了加载时间。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/0872913984d84918b4b1b1d406fafd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/0*JpKA8rrGPJto2gha.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图2:来源:维基</p></figure><p id="906a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">典型的CDN工作流程是:</p><p id="7aac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当客户端从CDN节点请求数据时，CDN节点检查缓存的数据是否过期。</p><ul class=""><li id="426f" class="nx ny it kx b ky kz lb lc le nz li oa lm ob lq oc od oe of bi translated">如果缓存的数据没有过期，缓存的数据将直接返回给客户端。</li><li id="978b" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated">否则，CDN节点向源服务器发送请求。从源服务器获取最新数据，更新本地缓存，然后将最新数据返回给客户端。</li></ul><p id="3b41" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里的权衡是CDN节点会缓存内容多长时间，这对命中率有直接影响。</p><p id="2bd4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果CDN缓存时间短，CDN边缘节点上的数据最容易过时，导致对源服务器的频繁请求，增加了源服务器的系统负载，延迟了用户的访问。如果CDN缓存时间过长，可能会向客户端提供过期数据。</p><p id="b6c3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">后续问题:CDN服务器如何检查客户端是否有最新的缓存内容？</p><p id="677b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">答案是指HTTP缓存方法。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="0a55" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">HTTP缓存</h1><p id="7195" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">在网络环境中，用户阅读比写作更频繁。</p><p id="aca7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过网络获取数据既慢又贵，因此缓存和重用以前获取的资源的能力对于优化性能至关重要。</p><p id="6f1e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">HTTP上下文中使用了许多缓存模式。最重要的缓存头是<code class="fe ph pi pj oy b">cache-control</code>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/84579b46ea70e4d28fed050ee0f31eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/0*DvxqNw52tz8J48qJ.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图3:与缓存相关的HTTP头</p></figure><ul class=""><li id="da0a" class="nx ny it kx b ky kz lb lc le nz li oa lm ob lq oc od oe of bi translated">缓存控制:<code class="fe ph pi pj oy b">no-store</code></li></ul><p id="f881" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">缓存不应该存储任何关于客户端请求或服务器响应的信息。请求被发送到服务器，并且每次都下载完整的响应。</p><ul class=""><li id="bf14" class="nx ny it kx b ky kz lb lc le nz li oa lm ob lq oc od oe of bi translated">缓存控制:<code class="fe ph pi pj oy b">no-cache</code></li></ul><p id="5072" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在释放缓存的副本之前，缓存会将请求发送到源服务器进行验证。</p><ul class=""><li id="60c9" class="nx ny it kx b ky kz lb lc le nz li oa lm ob lq oc od oe of bi translated">缓存控制:<code class="fe ph pi pj oy b">private</code></li></ul><p id="f9b3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe ph pi pj oy b">private</code>表示响应仅供单个用户使用，不得由共享缓存存储。在这种情况下，专用浏览器缓存可以存储响应。</p><ul class=""><li id="0d21" class="nx ny it kx b ky kz lb lc le nz li oa lm ob lq oc od oe of bi translated">缓存控制:<code class="fe ph pi pj oy b">public</code></li></ul><p id="d5e6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe ph pi pj oy b">public</code>指令表示响应可以被任何缓存缓存。如果内容需要缓存在CDN中，则需要<code class="fe ph pi pj oy b">public</code>。</p><p id="7168" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是我们如何解决陈旧数据的问题呢？</p><p id="ac71" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">答案是<code class="fe ph pi pj oy b">ETags/last-modified</code>，服务器会检查这些头来确定客户端的本地缓存是否经过验证。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pl"><img src="../Images/e2c473af64da366e6e139aa99aba8f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0KeT8YfozUnf6wC9.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图4: HTTP缓存:客户机和服务器流程</p></figure><p id="b50c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果通过验证，将发送一个包含304的HTTP响应，否则，将发送一个包含最新内容的200响应。</p><p id="b251" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">过期数据的另一个解决方案是为资源生成一个新的唯一URL，在正常情况下，样式表文件、HTML页面中的图像、JavaScript文件都会在文件名中嵌入指纹。这样，如果服务器更新了内容，客户端将从新的URL获取内容。</p><p id="6b68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">结合使用cache-control、ETags和惟一URL，我们可以获得最佳结果:长有效期、对响应缓存位置的控制以及按需更新。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9dc6" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">NGINX缓存</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pm"><img src="../Images/f823064ed52681c202720ae2ae0f1f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C3iXZfXdgeEDl-pz.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图5:图片来源:隐私加拿大(<a class="ae np" href="https://privacycanada.net/" rel="noopener ugc nofollow" target="_blank">https://privacycanada.net</a>)</p></figure><p id="1561" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在实践中，NGINX通常用作应用程序前面的反向代理或负载平衡器，它也可以充当缓存服务器。NGINX缓存的一个简单配置是:</p><pre class="kk kl km kn gt ox oy oz pa aw pb bi"><span id="af94" class="ol mt it oy b gy pc pd l pe pf">server {<br/>    # Note that it's listening on port 9000<br/>    listen 9000 default_server;<br/>    root /var/www/;<br/>    index index.html index.htm;</span><span id="ad64" class="ol mt it oy b gy pn pd l pe pf">    server_name example.com www.example.com;</span><span id="1616" class="ol mt it oy b gy pn pd l pe pf">    charset utf-8;<br/>    include h5bp/basic.conf;</span><span id="0cb5" class="ol mt it oy b gy pn pd l pe pf">    location / {<br/>        try_files $uri $uri/ =404;<br/>    }<br/>}</span></pre><p id="2619" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它是几乎任何后端应用程序的透明缓存层，这意味着简洁的架构。</p><p id="d145" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里还有一点需要注意。我们将内存空间(用于缓存键)的大小设置为10m，缓存的值存储在路径为<code class="fe ph pi pj oy b">/tmp/nginx</code>的磁盘上。</p><p id="488d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe ph pi pj oy b">inactive=60m</code>选项用于指定一个项目在不被访问的情况下可以在缓存中保留多长时间。</p><p id="0e62" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">除了更好的性能，NGINX缓存还可以提高网站的可用性，我们可以使用<code class="fe ph pi pj oy b">proxy_cache_use_stale</code>选项在源关闭时提供缓存的内容。</p><p id="d92d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">NGINX还有其他丰富的特性，如流量限制、内容压缩等。如果你对高性能调优感兴趣，强烈推荐你阅读:<a class="ae np" href="https://www.nginx.com/blog/nginx-high-performance-caching/#HowItWorks" rel="noopener ugc nofollow" target="_blank"> <em class="nt"> NGINX高性能缓存</em> </a>。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="93de" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Linux系统缓存</h1><p id="8928" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">请记住，系统调用开销很大，磁盘上的数据操作(读/写)比内存上的操作慢得多。Linux将最大限度地利用计算机的内存以获得最佳性能。</p><p id="4983" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们检查一下<code class="fe ph pi pj oy b">free</code>的命令:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi po"><img src="../Images/37c091276102ed4ba3fb8331c3549261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/0*_Su_znJffLy-4pQs.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图6: Linux自由命令</p></figure><p id="44ae" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如我们所看到的，没有太多的<code class="fe ph pi pj oy b">free</code>内存，尽管我们目前没有运行很多应用程序。</p><p id="f6f1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">别担心，Linux不是在吃你的内存。系统只是借用<em class="nt">未使用的内存</em>用于磁盘缓存。这使它看起来像你的内存不足。</p><p id="61c1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当数据被写入时，Linux首先将其写入页面缓存(在内存中)并将页面标记为<em class="nt">脏。</em>这些脏页的内容会定期(以及通过系统调用<code class="fe ph pi pj oy b">sync</code>或<code class="fe ph pi pj oy b">fsync</code>)传输到底层存储设备。</p><p id="971d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们运行一些命令来验证它:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/3b7fb310feee9e661609829c37bbda0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/0*qrUy9NXlLl46dMMu.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图7: Linux sync命令</p></figure><p id="472e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">从输出中，我们可以发现在写入200MB数据后，系统中的脏页会增加。</p><p id="da64" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，如果我们运行命令<code class="fe ph pi pj oy b">sync</code>，它会缩小，因为脏页中的数据已经同步到磁盘。</p><p id="ab29" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">文件块被写入页面缓存，不仅在写入期间，在读取文件时也是如此。</p><p id="537f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，当您一个接一个地读取100MB文件两次时，第二次访问会更快，因为文件块直接来自内存中的页面缓存，而不必再次从硬盘中读取。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="bfb0" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">CPU缓存</h1><p id="1a54" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">发明CPU缓存是为了弥补CPU和内存之间的速度差距。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/c147a2e2b3716f6cab028ee757f08729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/0*EzbntyPcRGDs1eiW.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图8:extremetech.com信用图像</p></figure><p id="18f1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">CPU缓存是小内存池，存储CPU接下来最有可能需要的信息。所有现代CPU都有多级CPU缓存。</p><p id="f0b9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每个缓存级别之间的访问时间差异很大，速度较快的级别的每字节成本高于速度较慢的级别，容量也较小。L1缓存比L2缓存快，L2缓存比RAM快。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/d9c5456bb39cfa0ecdf7c37781d2ada7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*xuSk-4beAW3FcbIk.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图9:形象信用<a class="ae np" href="https://hazelcast.com/glossary/memory-caching/" rel="noopener ugc nofollow" target="_blank">https://hazelcast.com/glossary/memory-caching/</a></p></figure><p id="9c6f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">根据<a class="ae np" href="https://en.wikipedia.org/wiki/Locality_of_reference#cite_note-1" rel="noopener ugc nofollow" target="_blank">局部性原则</a>，一个程序花费的大部分时间都集中在核心操作上，CPU很可能在很短的时间内重复访问同一组内存位置。</p><p id="a3c8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">遵循这一原则至关重要，因为高速缓存中的高未命中率可能会给程序带来性能损失。</p><p id="f049" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们用这两个C函数来检查一下，它们之间有什么区别？为什么第一个函数比后一个函数快了差不多两倍？</p><pre class="kk kl km kn gt ox oy oz pa aw pb bi"><span id="fe1d" class="ol mt it oy b gy pc pd l pe pf">int array_sum_row(int a[M][N]) {<br/>  int i,j,sum=0;<br/>  for(i = 0; i&lt;M; i++)<br/>    for(j = 0; j&lt;N; j++)<br/>      sum += a[i][j];<br/>  return sum;<br/>}</span><span id="8d19" class="ol mt it oy b gy pn pd l pe pf">int array_sum_col(int a[M][N]) {<br/>  int i,j,sum=0;<br/>  for(i = 0; i&lt;N; i++)<br/>    for(j = 0; j&lt;M; j++)<br/>      sum += a[j][i];<br/>  return sum;<br/>}</span></pre><p id="e8ac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因为C/C++编译器使用内存中的行优先布局。当<code class="fe ph pi pj oy b">a[i][0]</code>中的数据被访问时，附近的数据<code class="fe ph pi pj oy b">a[i][1]</code> ~ <code class="fe ph pi pj oy b">a[i][K]</code>将可能被加载到缓存中。</p><p id="15b6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">按照迭代顺序，因为附近的元素已经缓存了，所以我们在缓存上会得到很高的命中率。</p><p id="becf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是，如果我们将迭代顺序反转为col-major，由于加载的数据之后不会被访问，并且大多数数据不会从缓存中提取，因此会引发高未命中率问题和运行时的糟糕性能。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c91e" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">算法中的缓存</h1><p id="5bcf" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">在算法设计中，为了时间性能，我们通常将计算结果存储在缓存中。让我们深入研究一下经典的递归版本的斐波那契算法:</p><pre class="kk kl km kn gt ox oy oz pa aw pb bi"><span id="645c" class="ol mt it oy b gy pc pd l pe pf">function fib(n) {<br/> if (n &lt; 2) {<br/>   return n<br/> }<br/> return fib(n - 1) + fib(n - 2)<br/>}</span></pre><p id="d516" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们在可视化中分析计算过程，我们会发现在计算过程中有一些重复的部分。它在big-O符号中的复杂度是𝑂(2^𝑛).</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ps"><img src="../Images/e7eccf207c81a3e81625edd41f478eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DRbOgDY5cDjvXI3a.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图10:图片来源:<a class="ae np" href="https://medium.com/@porzingod" rel="noopener">https://medium.com/@porzingod</a></p></figure><p id="f5e0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">内存化(自顶向下的缓存填充)可用于优化性能，我们使用一个数组来存储计算结果:</p><pre class="kk kl km kn gt ox oy oz pa aw pb bi"><span id="b718" class="ol mt it oy b gy pc pd l pe pf">memFib(n) {<br/>   if (mem[n] is undefined)<br/>       if (n &lt; 2) result = n<br/>       else result = memFib(n-2) + memFib(n-1)<br/>       mem[n] = result<br/>   return mem[n]<br/>}</span></pre><p id="8c82" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">或者我们可以使用自下而上的缓存填充，这将产生一个迭代版本程序:</p><pre class="kk kl km kn gt ox oy oz pa aw pb bi"><span id="90d2" class="ol mt it oy b gy pc pd l pe pf">tabFib(n) {<br/>   mem[0] = 0<br/>   mem[1] = 1<br/>   for i = 2...n<br/>       mem[i] = mem[i-2] + mem[i-1]<br/>   return mem[n]<br/>}</span></pre><p id="af50" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">减少重复计算的思想也应用在<a class="ae np" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">动态规划</a> (DP)中，对DP问题的关键观察是找到重叠子问题，并使用缓存存储重叠结果。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="34f3" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">摘要</h1><p id="6f1d" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">我们对不同层次的缓存技术进行了研究。缓存不仅是架构和设计的一种方法，也是解决问题的一种通用思想。</p><p id="8a74" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">基本原则是:</p><ul class=""><li id="90e7" class="nx ny it kx b ky kz lb lc le nz li oa lm ob lq oc od oe of bi translated">如果需要，将重复数据存储在更快的组件上(例如CDN、内存缓存)。</li><li id="16b9" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated">使用缓存来减少计算中的重复(Fibonacci/DP中的情况)。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/4c4e1b6e4fae425fa7d9dada63179f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/0*Y6wFy5LspC-ItW6e.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图11:资料来源:quotefancy.com</p></figure><p id="d13f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在大多数情况下，缓存是我们在解决性能问题时需要的抽象层，缓存技术值得有抱负的程序员认真学习。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="3763" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">参考</h1><ul class=""><li id="16a7" class="nx ny it kx b ky nk lb nl le pu li pv lm pw lq oc od oe of bi translated"><a class="ae np" href="https://www.globaldots.com/content-delivery-network-explained" rel="noopener ugc nofollow" target="_blank"> CDN </a></li><li id="bfa3" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated"><a class="ae np" href="https://support.stackpath.com/hc/en-us/articles/360001212783-CDN-Caching-Explained" rel="noopener ugc nofollow" target="_blank"> CDN缓存</a></li><li id="e8c3" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated"><a class="ae np" href="https://tools.ietf.org/html/rfc7234" rel="noopener ugc nofollow" target="_blank"> HTTP缓存1 </a></li><li id="b045" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated"><a class="ae np" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener ugc nofollow" target="_blank"> HTTP缓存2 </a></li><li id="6fe5" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated"><a class="ae np" href="https://docs.nginx.com/nginx/admin-guide/content-cache/content-caching/#enable" rel="noopener ugc nofollow" target="_blank"> NGINX缓存</a></li><li id="4f21" class="nx ny it kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated"><a class="ae np" href="https://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips" rel="noopener ugc nofollow" target="_blank"> CPU缓存</a></li></ul></div></div>    
</body>
</html>