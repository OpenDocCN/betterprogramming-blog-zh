<html>
<head>
<title>Understanding Promises in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的承诺</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-promises-in-javascript-13d99df067c1?source=collection_archive---------0-----------------------#2018-07-15">https://betterprogramming.pub/understanding-promises-in-javascript-13d99df067c1?source=collection_archive---------0-----------------------#2018-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="61d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解如何创造和处理承诺</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/791c1c391e2b52400839f8a74ba31d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IXaKMoKxyvrZs1prvukJvw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我给你一个小小的承诺，在这篇文章结束时，你会更好地了解JavaScript的承诺。</p></figure><p id="b7a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我对JavaScript有点又爱又恨。尽管如此，它一直吸引着我。在过去的十年里，我一直在研究Java和PHP，JavaScript看起来与众不同，但却很有趣。我没有在这上面花足够的时间，最近一直在努力弥补。</p><p id="994f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">承诺是我遇到的第一个有趣的话题。我一次又一次地听到人们说，承诺“将你从回调地狱中拯救出来”。嗯，这可能是一个令人愉快的副作用，但承诺远不止于此。这是我到目前为止所能理解的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d624" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">背景</strong></h1><p id="4d2f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">一开始使用JavaScript可能会有点令人沮丧。你会听到人们说JavaScript是一种同步编程语言，然后其他人会声称它是异步的。你会听到阻塞代码、非阻塞代码、事件驱动的设计模式、事件生命周期、函数堆栈、事件队列、冒泡、polyfill、babel、angular、reactJS、vue JS和许多其他工具和库。别担心——你不是第一个。有一个术语可以形容它:<em class="my"> JavaScript疲劳。</em>这条推文很好地抓住了这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Javascript疲劳</p></figure><p id="9d9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript是一种<em class="my">同步</em>编程语言。但是多亏了回调函数，我们可以让它像异步编程语言一样工作。</p><h2 id="64bf" class="nb mc it bd md nc nd dn mh ne nf dp ml lh ng nh mn ll ni nj mp lp nk nl mr nm bi translated"><strong class="ak">承诺，通俗地说</strong></h2><p id="fd43" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">JavaScript中的承诺类似于你在现实生活中做出的承诺，所以让我们看看现实生活中的承诺。</p><p id="0e12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是诺言的字典定义:</p><p id="21e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">承诺:名词:保证某人会做某事或某件特定的事情会发生。</p><p id="aca2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">那么当有人向你许下承诺时会发生什么？</strong></p><ol class=""><li id="1a95" class="nn no it la b lb lc le lf lh np ll nq lp nr lt ns nt nu nv bi translated">承诺给你保证某事会被做。他们(做出承诺的人)是自己做还是让别人做并不重要。他们给你一个保证，在此基础上你可以计划一些事情。</li><li id="2733" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">诺言可以遵守，也可以违背。</li><li id="d0ce" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">当一个承诺被遵守的时候，你期望从那个承诺中得到一些东西。你可以将承诺的结果用于你进一步的行动或计划。</li><li id="c64c" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">当一个承诺被打破时，你想知道为什么做出承诺的人不能遵守他的承诺。一旦你知道了原因，并确认承诺已经被打破，你就可以计划下一步该做什么。</li><li id="51ef" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">当一个承诺被许给我们时，我们所拥有的只是一个保证。我们不能立即采取行动。当<em class="my">承诺被遵守</em>(因此我们有一个预期的结果)或<em class="my">被破坏</em>(我们知道原因，因此我们可以计划一个应急方案)时，我们可以决定并制定需要做的事情。</li><li id="33fd" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">做出承诺的人有可能不会反悔。在这种情况下，设定一个期限是明智的。例如，如果那个人在十天内没有回到我身边，我会认为他们没有遵守诺言。即使他们15天后回到你身边，也没关系——你已经做了备用计划。</li></ol></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="57df" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">JavaScript中的承诺</h1><p id="39c9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">根据经验，我总是阅读来自<em class="my"> MDN Web Docs </em>的JavaScript文档。在所有可用的资源中，我认为它们提供了最简洁的细节。我阅读了MDSN网站文档中的承诺页面，并摆弄了一下代码，以便找到窍门。</p><p id="6e04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理解承诺有两个部分。<em class="my">创建承诺</em>和<em class="my">处理承诺</em>。尽管我们的大部分代码将迎合其他库创建的处理承诺，但获得完整的理解是重要的。随着你从初级阶段进步，理解承诺的创造将变得越来越重要。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="2447" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">创造承诺</h1><p id="620a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">让我们来看看创建新承诺的签名:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="3239" class="nb mc it oc b gy og oh l oi oj">new Promise( /* executor */ function(resolve, reject) { ... } );</span></pre><p id="50fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构造函数接受一个名为<code class="fe ok ol om oc b">executor</code>的函数。这个<code class="fe ok ol om oc b">executor</code>函数接受两个参数:<code class="fe ok ol om oc b">resolve</code>和<code class="fe ok ol om oc b">reject</code>，它们依次是函数。</p><p id="91d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">承诺通常用于更容易地处理异步操作或阻塞代码，例如，文件操作、API调用、DB调用、IO调用等。这些异步操作在<code class="fe ok ol om oc b">executor</code>函数内部启动。如果异步操作成功，调用<code class="fe ok ol om oc b">resolve</code>函数返回预期结果。类似地，如果有一些意外的错误，原因会通过调用<code class="fe ok ol om oc b">reject</code>函数来传递。</p><p id="0e75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们知道如何创造一个承诺。让我们创造一个简单的承诺来帮助我们理解。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="d31c" class="nb mc it oc b gy og oh l oi oj">var keepsHisWord;<br/>keepsHisWord = true;<br/>promise1 = new Promise(function(resolve, reject) {<br/>  if (keepsHisWord) {<br/>    resolve("The man likes to keep his word");<br/>  } else {<br/>    reject("The man doesnt want to keep his word");<br/>  }<br/>});<br/>console.log(promise1);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/a215c66dda75ffc56b491cfbfa187000.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*ByDQ6-tTp2TvHIh4R_P6xw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个承诺都有一个状态和价值</p></figure><p id="ea16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为这个承诺马上得到解决，我们将无法检查承诺的初始状态。因此，让我们创造一个新的承诺，这需要一些时间来解决。最简单的方法是使用<code class="fe ok ol om oc b">setTimeOut</code>函数。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="af40" class="nb mc it oc b gy og oh l oi oj">promise2 = new Promise(function(resolve, reject) {<br/>  setTimeout(function() {<br/>    resolve({<br/>      message: "The man likes to keep his word",<br/>      code: "aManKeepsHisWord"<br/>    });<br/>  }, 10 * 1000);<br/>});<br/>console.log(promise2);</span></pre><p id="1752" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码创建了一个承诺，它将在十秒钟后无条件地解决。我们可以检查承诺的状态，直到它被解决。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/41cc8e3066d4ef4abcca3434f33c8093.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*6GX_rHpGa3HXcYiHm9Vy6g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">承诺状态，直到它被解决或拒绝</p></figure><p id="6315" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦十秒钟过后，承诺就完成了。<code class="fe ok ol om oc b">PromiseStatus</code>和<code class="fe ok ol om oc b">PromiseValue</code>都相应更新。如您所见，我们更新了resolve函数，这样我们可以传递一个JSON对象，而不是一个简单的字符串。这是为了说明我们也可以在<code class="fe ok ol om oc b">resolve</code>函数中传递其他值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/8e5597bdfb72f297250b2dec7ae41a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*n6s4IswZBVUIHc2K3apONA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">十秒钟后以JSON对象作为返回值的承诺</p></figure><p id="53c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们来看一个会被拒绝的承诺。我们只是稍微修改了承诺一。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="850a" class="nb mc it oc b gy og oh l oi oj">keepsHisWord = false;<br/>promise3 = new Promise(function(resolve, reject) {<br/>  if (keepsHisWord) {<br/>    resolve("The man likes to keep his word");<br/>  } else {<br/>    reject("The man doesn't want to keep his word");<br/>  }<br/>});<br/>console.log(promise3);</span></pre><p id="0fd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于这将创建一个未处理的拒绝，Chrome浏览器将显示一个错误。你可以暂时忽略它——我们以后再讨论它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2005826256274a6937959bf8ceb1475b.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*rP1Qk-5xOz4c1MJmoNT0Bw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拒绝承诺</p></figure><p id="9564" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，<code class="fe ok ol om oc b">PromiseStatus</code>可以有三个不同的值:<code class="fe ok ol om oc b">pending</code>、<code class="fe ok ol om oc b">resolved</code>或<code class="fe ok ol om oc b">rejected</code>。当一个承诺被创建时，<code class="fe ok ol om oc b">PromiseStatus</code>处于<code class="fe ok ol om oc b">pending</code>状态—它将拥有<code class="fe ok ol om oc b">PromiseValue</code> <code class="fe ok ol om oc b">undefined</code>直到该承诺处于<code class="fe ok ol om oc b">resolved</code>或<code class="fe ok ol om oc b">rejected.</code>状态。当一个承诺处于<code class="fe ok ol om oc b">resolved</code>或<code class="fe ok ol om oc b">rejected</code>状态时，该承诺被称为<code class="fe ok ol om oc b">settled</code>。所以一个承诺通常会从待定状态转换到确定状态。</p><p id="6f2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们知道了承诺是如何产生的，我们可以看看我们如何使用或处理承诺。这将有助于理解<code class="fe ok ol om oc b">Promise</code>对象。</p><h1 id="4bc8" class="mb mc it bd md me or mg mh mi os mk ml jz ot ka mn kc ou kd mp kf ov kg mr ms bi translated">理解承诺对象</h1><p id="3f64" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">根据MDN文档:</p><blockquote class="ow ox oy"><p id="0f8a" class="ky kz my la b lb lc ju ld le lf jx lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><code class="fe ok ol om oc b"><em class="it">Promise</em></code>对象表示异步操作的最终完成(或失败)及其结果值。</p></blockquote><p id="c83d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ok ol om oc b">Promise</code>对象有静态方法和<code class="fe ok ol om oc b">prototype methods</code>。</p><p id="5cdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ok ol om oc b">Promise</code>对象中的静态方法可以独立应用，而<code class="fe ok ol om oc b">prototype methods</code>需要应用于<code class="fe ok ol om oc b">Promise</code>对象的实例。</p><p id="31e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住普通方法和原型都返回一个<code class="fe ok ol om oc b">Promise</code>会使理解事情变得容易得多。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="99c1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">原型方法</h1><p id="6c02" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们将从<code class="fe ok ol om oc b">prototype methods</code>开始。他们有三个人。</p><p id="d148" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只是重申一下:所有这些方法都可以应用在<code class="fe ok ol om oc b">Promise</code>对象的实例上，并且所有这些方法都依次返回一个承诺。所有这些方法都为承诺的不同状态转换分配处理程序。</p><p id="81a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们前面看到的，当<code class="fe ok ol om oc b">Promise</code>被创建时，它处于<code class="fe ok ol om oc b">pending</code>状态。承诺结算时，根据是<code class="fe ok ol om oc b">fulfilled</code>还是<code class="fe ok ol om oc b">rejected</code>运行以下三种方法中的一种或几种:</p><p id="9cf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ok ol om oc b">Promise.prototype.catch(onRejected)</code></p><p id="95ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ok ol om oc b">Promise.prototype.then(onFulfilled, onRejected)</code></p><p id="d914" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ok ol om oc b">Promise.prototype.finally(onFinally)</code></p><p id="3795" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下图显示了<code class="fe ok ol om oc b">.then</code>和<code class="fe ok ol om oc b">.catch</code>方法的流程。因为它们返回一个<code class="fe ok ol om oc b">Promise</code>，所以它们可以再次被链接，这也显示在图中。如果<code class="fe ok ol om oc b">.finally</code>被声明为承诺，则无论承诺是被履行还是被拒绝，只要承诺是<code class="fe ok ol om oc b">settled</code>就会被执行。正如Konstantin Rouda所指出的，对<code class="fe ok ol om oc b">.finally</code>的支持是有限的，所以在使用这个之前请检查一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/de1af4b48302af2983453fcffcadaab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mBlni5vsYZE2wFzfVv8EA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自:<a class="ae pd" href="https://mdn.mozillademos.org/files/15911/promises.png" rel="noopener ugc nofollow" target="_blank">https://mdn.mozillademos.org/files/15911/promises.png</a></p></figure><p id="dc64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个小故事。你是一个小学生，你向你妈妈要一部电话。她说“我保证在月底买一部手机。”</p><p id="954f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这个承诺在月底得到执行，让我们看看这个承诺在JavaScript中是什么样子的:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="ce2b" class="nb mc it oc b gy og oh l oi oj">var momsPromise = new Promise(function(resolve, reject) {<br/>  momsSavings = 20000;<br/>  priceOfPhone = 60000;<br/>  if (momsSavings &gt; priceOfPhone) {<br/>    resolve({<br/>      brand: "iphone",<br/>      model: "6s"<br/>    });<br/>  } else {<br/>    reject("We donot have enough savings. Let us save some more money.");<br/>  }<br/>});</span><span id="e5f9" class="nb mc it oc b gy pe oh l oi oj">momsPromise.then(function(value) {<br/>  console.log("Hurray I got this phone as a gift ", JSON.stringify(value));<br/>});</span><span id="ce30" class="nb mc it oc b gy pe oh l oi oj">momsPromise.catch(function(reason) {<br/>  console.log("Mom coudn't buy me the phone because ", reason);<br/>});</span><span id="5888" class="nb mc it oc b gy pe oh l oi oj">momsPromise.finally(function() {<br/>  console.log(<br/>    "Irrespecitve of whether my mom can buy me a phone or not, I still love her"<br/>  );<br/>});</span></pre><p id="cd15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样的输出是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/46250e04eefb030b0b65132ff350a664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*Ol16n8YEu5vKgVqh0pBbhg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">妈妈们没有兑现承诺。</p></figure><p id="e788" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们将<code class="fe ok ol om oc b">momsSavings</code>的值改为200000，那么妈妈就可以给儿子礼物了。在这种情况下，输出是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/95eae558e06d3b1718ef789b60532a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*9PPksLxayz3373AxoYg4kA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">妈妈信守承诺。</p></figure><p id="6e73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们戴上消耗这个库的人的帽子。我们模仿输出和自然，这样我们可以看看如何有效地使用<code class="fe ok ol om oc b">.then</code>和<code class="fe ok ol om oc b">.catch</code>。</p><p id="b2f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe ok ol om oc b">.then</code>可以分配两个<code class="fe ok ol om oc b">onFulfilled, onRejected handlers</code>，而不是分别写<code class="fe ok ol om oc b">.then</code>和<code class="fe ok ol om oc b">.catch</code>，我们可以用<code class="fe ok ol om oc b">.then</code>做同样的事情。它应该是这样的:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="5129" class="nb mc it oc b gy og oh l oi oj">momsPromise.then(<br/>  function(value) {<br/>    console.log("Hurray I got this phone as a gift ", JSON.stringify(value));<br/>  },<br/>  function(reason) {<br/>    console.log("Mom coudn't buy me the phone because ", reason);<br/>  }<br/>);</span></pre><p id="96f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了代码的可读性，我觉得还是把它们分开比较好。</p><p id="26a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了确保我们可以在一般的浏览器或特定的Chrome中运行所有这些样本，我确保我们的代码样本中没有外部依赖。</p><p id="a3c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了更好地理解后面的主题，让我们创建一个返回承诺的函数，然后随机地解决或拒绝该承诺，以便我们可以测试各种场景。</p><p id="8802" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解异步函数的概念，让我们在函数中引入一个随机延迟。</p><p id="bd4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们需要随机数，所以让我们首先创建一个随机函数，返回x和y之间的随机数:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="3253" class="nb mc it oc b gy og oh l oi oj">function getRandomNumber(start = 1, end = 10) {<br/>  //works when both start,end are &gt;=1 and end &gt; start<br/>  return parseInt(Math.random() * end) % (end-start+1) + start;<br/>}</span></pre><p id="2a09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们创建一个为我们返回承诺的函数。让我们调用我们的函数<code class="fe ok ol om oc b">promiseTRRARNOSG</code>，它是<code class="fe ok ol om oc b">promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code>的别名。该函数将创建一个承诺，该承诺在2到10秒之间的任意秒数后解决或拒绝。</p><p id="156e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了随机化拒绝和解决，我们将创建一个介于1和10之间的随机数。如果生成的随机数大于5，我们解决承诺，否则我们拒绝它。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="8cce" class="nb mc it oc b gy og oh l oi oj">function getRandomNumber(start = 1, end = 10) {<br/>  //works when both start and end are &gt;=1<br/>  return (parseInt(Math.random() * end) % (end - start + 1)) + start;<br/>}</span><span id="3e66" class="nb mc it oc b gy pe oh l oi oj">var promiseTRRARNOSG = (<!-- -->promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator<!-- --> = function() {<br/>  return new Promise(function(resolve, reject) {<br/>    let randomNumberOfSeconds = getRandomNumber(2, 10);<br/>    setTimeout(function() {<br/>      let randomiseResolving = getRandomNumber(1, 10);<br/>      if (randomiseResolving &gt; 5) {<br/>        resolve({<br/>          randomNumberOfSeconds: randomNumberOfSeconds,<br/>          randomiseResolving: randomiseResolving<br/>        });<br/>      } else {<br/>        reject({<br/>          randomNumberOfSeconds: randomNumberOfSeconds,<br/>          randomiseResolving: randomiseResolving<br/>        });<br/>      }<br/>    }, randomNumberOfSeconds * 1000);<br/>  });<br/>});</span><span id="e3b6" class="nb mc it oc b gy pe oh l oi oj">var testProimse = promiseTRRARNOSG();<br/>testProimse.then(function(value) {<br/>  console.log("Value when promise is resolved : ", value);<br/>});<br/>testProimse.catch(function(reason) {<br/>  console.log("Reason when promise is rejected : ", reason);<br/>});</span><span id="11e0" class="nb mc it oc b gy pe oh l oi oj">// Let us loop through and create ten different promises using the function to see some variation. Some will be resolved and some will be rejected. </span><span id="5d8b" class="nb mc it oc b gy pe oh l oi oj">for (i=1; i&lt;=10; i++) {<br/>  let promise = promiseTRRARNOSG();<br/>  promise.then(function(value) {<br/>    console.log("Value when promise is resolved : ", value);<br/>  });<br/>  promise.catch(function(reason) {<br/>    console.log("Reason when promise is rejected : ", reason);<br/>  });<br/>}</span></pre><p id="aba1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">刷新浏览器页面并在控制台中运行代码，查看<code class="fe ok ol om oc b">resolve</code>和<code class="fe ok ol om oc b">reject</code>场景的不同输出。稍后我们将看看如何创建多个承诺并检查它们的输出，而不必这样做。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7560" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">静态方法</h1><p id="c9d3" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在<code class="fe ok ol om oc b">Promise</code>对象中有四个静态方法。</p><p id="e547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前两个是助手方法或快捷方式。他们帮助你做出决定或拒绝的承诺。</p><p id="45c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ok ol om oc b">Promise.reject(reason)</code>帮助你创造一个被拒绝的承诺。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="1585" class="nb mc it oc b gy og oh l oi oj">var promise3 = Promise.reject("Not interested");<br/>promise3.then(function(value){<br/>  console.log("This will not run as it is a resolved promise. The resolved value is ", value);<br/>});<br/>promise3.catch(function(reason){<br/>  console.log("This run as it is a rejected promise. The reason is ", reason);<br/>});</span></pre><p id="45ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ok ol om oc b">Promise.resolve(value)</code>帮助你创造一个明确的承诺:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="3af4" class="nb mc it oc b gy og oh l oi oj">var promise4 = Promise.resolve(1);<br/>promise4.then(function(value){<br/>  console.log("This will run as it is a resovled promise. The resolved value is ", value);<br/>});<br/>promise4.catch(function(reason){<br/>  console.log("This will not run as it is a resolved promise", reason);<br/>});</span></pre><p id="ccf7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">旁注:一个承诺可以有多个处理程序，所以您可以将上面的代码更新为:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="980f" class="nb mc it oc b gy og oh l oi oj">var promise4 = Promise.resolve(1);<br/>promise4.then(function(value){<br/>  console.log("This will run as it is a resovled promise. The resolved value is ", value);<br/>});<br/>promise4.then(function(value){<br/>  console.log("This will also run as multiple handlers can be added. Printing twice the resolved value which is ", value * 2);<br/>});<br/>promise4.catch(function(reason){<br/>  console.log("This will not run as it is a resolved promise", reason);<br/>});</span></pre><p id="4732" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/dc72eccb3bca67b1d225579cbd6907c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXk3jy1wB9iTXujph1EbcA.png"/></div></div></figure><p id="f9f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来的两种方法帮助你处理一系列承诺。</p><p id="3eeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你处理多重承诺时，最好先创建一系列承诺，然后对所有承诺采取必要的行动。</p><p id="4223" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解这些方法，我们将无法使用我们方便的<code class="fe ok ol om oc b">promiseTRRARNOSG</code>——它太随机了。最好有一些确定性的承诺，这样我们才能理解行为。让我们创建两个函数。一个将在n秒后解析，一个将在n秒后拒绝。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="d327" class="nb mc it oc b gy og oh l oi oj">var promiseTRSANSG = (promiseThatResolvesAfterNSecondsGenerator = function(<br/>  n = 0<br/>) {<br/>  return new Promise(function(resolve, reject) {<br/>    setTimeout(function() {<br/>      resolve({<br/>        resolvedAfterNSeconds: n<br/>      });<br/>    }, n * 1000);<br/>  });<br/>});<br/>var promiseTRJANSG = (promiseThatRejectsAfterNSecondsGenerator = function(<br/>  n = 0<br/>) {<br/>  return new Promise(function(resolve, reject) {<br/>    setTimeout(function() {<br/>      reject({<br/>        rejectedAfterNSeconds: n<br/>      });<br/>    }, n * 1000);<br/>  });<br/>});</span></pre><p id="6358" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们用这些辅助函数来理解<code class="fe ok ol om oc b">Promise.All</code></p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a4a7" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">保证。全部</h1><p id="de4b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">根据MDN文档:</p><blockquote class="ow ox oy"><p id="d1b1" class="ky kz my la b lb lc ju ld le lf jx lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><code class="fe ok ol om oc b"><strong class="la iu"><em class="it">Promise.all(iterable)</em></strong></code>方法返回单个<code class="fe ok ol om oc b"><a class="ae pd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"><em class="it">Promise</em></a></code>，当<code class="fe ok ol om oc b"><em class="it">iterable</em></code>参数中的所有承诺都已解析或者当iterable参数不包含承诺时，该方法将解析。它用拒绝的第一个承诺的理由拒绝。</p></blockquote><h2 id="6e88" class="nb mc it bd md nc nd dn mh ne nf dp ml lh ng nh mn ll ni nj mp lp nk nl mr nm bi translated">案例一</h2><p id="4888" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当所有的承诺都解决了。这是最常用的场景:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="cf02" class="nb mc it oc b gy og oh l oi oj">console.time("Promise.All");<br/>var promisesArray = [];<br/>promisesArray.push(promiseTRSANSG(1));<br/>promisesArray.push(promiseTRSANSG(4));<br/>promisesArray.push(promiseTRSANSG(2));<br/>var handleAllPromises = Promise.all(promisesArray);<br/>handleAllPromises.then(function(values) {<br/>  console.timeEnd("Promise.All");<br/>  console.log("All the promises are resolved", values);<br/>});<br/>handleAllPromises.catch(function(reason) {<br/>  console.log("One of the promises failed with the following reason", reason);<br/>});</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/ab7888675e83b92c8804d58d3b626550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*_gAQxkb19weN6ajUgzi0WA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有承诺都解决了。</p></figure><p id="0ebf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于这个输出，我们需要做两个重要的观察。</p><p id="2b48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1: <strong class="la iu"> </strong>耗时2秒的第三个承诺在耗时4秒的第二个承诺之前完成。但是正如您在输出中看到的，承诺的顺序在值中保持不变。</p><p id="f31d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2: <strong class="la iu"> </strong>我加了一个控制台定时器，看看<code class="fe ok ol om oc b">Promise.All</code>需要多长时间。如果这些承诺按顺序执行，总共需要1+4+2=7秒。但是从我们的计时器中我们看到它只需要4秒钟。这证明了所有的承诺都是并行执行的。</p><h2 id="b8ff" class="nb mc it bd md nc nd dn mh ne nf dp ml lh ng nh mn ll ni nj mp lp nk nl mr nm bi translated">案例2</h2><p id="fd8f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当没有承诺的时候。我觉得这是最不常用的。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="d653" class="nb mc it oc b gy og oh l oi oj">console.time("Promise.All");<br/>var promisesArray = [];<br/>promisesArray.push(1);<br/>promisesArray.push(4);<br/>promisesArray.push(2);<br/>var handleAllPromises = Promise.all(promisesArray);<br/>handleAllPromises.then(function(values) {<br/>  console.timeEnd("Promise.All");<br/>  console.log("All the promises are resolved", values);<br/>});<br/>handleAllPromises.catch(function(reason) {<br/>  console.log("One of the promises failed with the following reason", reason);<br/>});</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/f55e538dc05f94db9296257bf653f691.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*TETvAXYEHE4x58OdimRXww.png"/></div></figure><p id="5469" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为数组中没有承诺，所以返回的承诺被解析。</p><h2 id="5989" class="nb mc it bd md nc nd dn mh ne nf dp ml lh ng nh mn ll ni nj mp lp nk nl mr nm bi translated">案例3</h2><p id="ffbf" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">它以拒绝的第一个承诺的理由拒绝:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="db6f" class="nb mc it oc b gy og oh l oi oj">console.time("Promise.All");<br/>var promisesArray = [];<br/>promisesArray.push(promiseTRSANSG(1));<br/>promisesArray.push(promiseTRSANSG(5));<br/>promisesArray.push(promiseTRSANSG(3));<br/><strong class="oc iu">promisesArray.push(promiseTRJANSG(2));</strong><br/>promisesArray.push(promiseTRSANSG(4));<br/>var handleAllPromises = Promise.all(promisesArray);<br/>handleAllPromises.then(function(values) {<br/>  console.timeEnd("Promise.All");<br/>  console.log("All the promises are resolved", values);<br/>});<br/>handleAllPromises.catch(function(reason) {<br/>  console.timeEnd("Promise.All");<br/>  console.log("One of the promises failed with the following reason ", reason);<br/>});</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/98dbfa1a5b4dcd4969da93005f2f2c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*y_NCGDEfc3PKctq5-ZO8iA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行在第一次拒绝后停止</p></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="9356" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">承诺.比赛</h1><p id="2a61" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">根据MDN文档</p><blockquote class="ow ox oy"><p id="8e33" class="ky kz my la b lb lc ju ld le lf jx lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><code class="fe ok ol om oc b"><strong class="la iu">Promise.race(iterable)</strong></code>方法返回一个承诺，该承诺在iterable中的一个承诺解析或拒绝后立即解析或拒绝，并返回该承诺的值或原因。</p></blockquote><h2 id="c993" class="nb mc it bd md nc nd dn mh ne nf dp ml lh ng nh mn ll ni nj mp lp nk nl mr nm bi translated">案例1</h2><p id="9ece" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">其中一个承诺首先解决:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="b6b1" class="nb mc it oc b gy og oh l oi oj">console.time("Promise.race");<br/>var promisesArray = [];<br/>promisesArray.push(promiseTRSANSG(4));<br/>promisesArray.push(promiseTRSANSG(3));<br/><strong class="oc iu">promisesArray.push(promiseTRSANSG(2));</strong><br/>promisesArray.push(promiseTRJANSG(3));<br/>promisesArray.push(promiseTRSANSG(4));<br/>var promisesRace = Promise.race(promisesArray);<br/>promisesRace.then(function(values) {<br/>  console.timeEnd("Promise.race");<br/>  console.log("The fasted promise resolved", values);<br/>});<br/>promisesRace.catch(function(reason) {<br/>  console.timeEnd("Promise.race");<br/>  console.log("The fastest promise rejected with the following reason ", reason);<br/>});</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/cedef5d6d60aaa693467fae9bd1e73eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*6za2DUGOKIxARTyfP5HihQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最快的分辨率</p></figure><p id="0ea0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有的承诺都是并行的。第三个承诺在两秒内解决。一旦这样做了，由<code class="fe ok ol om oc b">Promise.race</code>返回的承诺就解决了。</p><h2 id="c336" class="nb mc it bd md nc nd dn mh ne nf dp ml lh ng nh mn ll ni nj mp lp nk nl mr nm bi translated">案例2</h2><p id="acea" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">其中一个承诺首先拒绝。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="e4f2" class="nb mc it oc b gy og oh l oi oj">console.time("Promise.race");<br/>var promisesArray = [];<br/>promisesArray.push(promiseTRSANSG(4));<br/>promisesArray.push(promiseTRSANSG(6));<br/>promisesArray.push(promiseTRSANSG(5));<br/><strong class="oc iu">promisesArray.push(promiseTRJANSG(3));</strong><br/>promisesArray.push(promiseTRSANSG(4));<br/>var promisesRace = Promise.race(promisesArray);<br/>promisesRace.then(function(values) {<br/>  console.timeEnd("Promise.race");<br/>  console.log("The fasted promise resolved", values);<br/>});<br/>promisesRace.catch(function(reason) {<br/>  console.timeEnd("Promise.race");<br/>  console.log("The fastest promise rejected with the following reason ", reason);<br/>});</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/1c250724a947086985fa59bc2080f555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*CvfsxAM8XbGZYTXo5KjiCA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最快的拒绝</p></figure><p id="cce3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有的承诺都是并行的。第四个承诺在三秒钟内被拒绝。一旦完成，由<code class="fe ok ol om oc b">Promise.race</code>返回的承诺被拒绝。</p><p id="d300" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经编写了所有的示例方法，所以我可以测试各种场景，测试可以在浏览器中运行。这就是为什么在示例中看不到任何API调用、文件操作或数据库调用。虽然所有这些都是真实的例子，但是您需要额外的工作来设置和测试它们。</p><p id="e0ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，使用延迟功能可以提供类似的场景，而无需额外的设置。您可以轻松地使用这些值来查看和检查不同的场景。您可以使用<code class="fe ok ol om oc b">promiseTRJANSG</code>、<code class="fe ok ol om oc b">promiseTRSANSG</code>和<code class="fe ok ol om oc b">promiseTRRARNOSG</code>方法的组合来模拟足够多的场景，以便彻底理解承诺。</p><p id="b019" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，在相关块之前和之后使用<code class="fe ok ol om oc b">console.time</code>方法将帮助我们容易地识别承诺是并行运行还是顺序运行。如果你有其他有趣的场景或者我错过了什么，请告诉我。如果你想把所有的代码样本放在一个地方，看看这个要点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pn na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">承诺样品</p></figure><p id="9e5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在结束之前，我想列出我遵守的所有经验法则，以保持我对承诺的理智。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f133" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">使用承诺的经验法则</h1><ol class=""><li id="7c5d" class="nn no it la b lb mt le mu lh po ll pp lp pq lt ns nt nu nv bi translated">每当你使用异步或阻塞代码时，使用承诺。</li><li id="b7d1" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><code class="fe ok ol om oc b">resolve</code>映射到<code class="fe ok ol om oc b">then</code>,<code class="fe ok ol om oc b">reject</code>映射到<code class="fe ok ol om oc b">catch</code>用于所有实际用途。</li><li id="1e16" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">确保写下所有承诺的<code class="fe ok ol om oc b">.catch</code>和<code class="fe ok ol om oc b">.then</code>方法。</li><li id="5498" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">如果在这两种情况下都需要做些什么，使用<code class="fe ok ol om oc b">.finally</code>。</li><li id="fbf7" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">我们只有一次机会改变每个承诺。</li><li id="2eb6" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">我们可以为一个承诺添加多个处理程序。</li><li id="68d8" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><code class="fe ok ol om oc b">Promise</code>对象中所有方法的返回类型，不管它们是静态方法还是原型方法，都是一个<code class="fe ok ol om oc b">Promise</code></li><li id="0e78" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated">在<code class="fe ok ol om oc b">Promise.all</code>中，承诺的顺序保持在值变量中，不管哪个承诺首先被解决。</li></ol><p id="22bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇关于承诺的深度分析，并且想了解更多关于Javascript的知识，请加入我们的讨论<a class="ae pd" href="https://discord.gg/ENbQbbZy25" rel="noopener ugc nofollow" target="_blank">https://discord.gg/ENbQbbZy25</a>或者在twitter上关注我<a class="ae pd" href="https://twitter.com/gokulnk" rel="noopener ugc nofollow" target="_blank">https://twitter.com/gokulnk</a></p><p id="d9fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以订阅我的简讯<a class="ae pd" href="https://understandingx.substack.com/" rel="noopener ugc nofollow" target="_blank">https://understandingx.substack.com/</a></p><h1 id="3b5b" class="mb mc it bd md me or mg mh mi os mk ml jz ot ka mn kc ou kd mp kf ov kg mr ms bi translated">何时使用异步等待，何时使用承诺</h1><p id="3e54" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">通过这篇文章，我希望你对承诺有足够的了解，并在现实生活中使用它们。你可以阅读关于<a class="ae pd" href="https://medium.com/better-programming/understanding-async-await-in-javascript-1d81bb079b2c" rel="noopener"> async-await </a>的内容，然后阅读<a class="ae pd" href="https://medium.com/better-programming/should-i-use-promises-or-async-await-126ab5c98789" rel="noopener">我应该使用promises还是async-await </a>。有了这三个地方，我认为你应该在一个伟大的地方开始进一步探索。如果我在这些文章中遗漏了什么，一定要让我知道。我总是愿意学习。</p></div></div>    
</body>
</html>