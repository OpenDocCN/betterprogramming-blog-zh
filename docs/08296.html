<html>
<head>
<title>Two ES2020 Features You Should Know About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该了解的两个ES2020特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/two-es2020-features-you-should-know-about-8ccd8fc9484e?source=collection_archive---------10-----------------------#2021-04-14">https://betterprogramming.pub/two-es2020-features-you-should-know-about-8ccd8fc9484e?source=collection_archive---------10-----------------------#2021-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="56e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入研究可选链接和无效合并操作符</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3c6c1b0e328a3d4c8c543fe2a14863b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*enVaeyWweVxLUmrn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kar111?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭佳欣·阿维蒂斯扬</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在作为ES2020(又名ES11)规范的一部分发布的所有<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/javascript-es2020-features-with-simple-examples-d301dbef2c37">新特性</a>中，我发现可选链接和nullish合并操作符是最有用的。在本文中，我将向您展示它们如何使您的项目受益。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ae34" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">零融合算子</h1><p id="4fd9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在JavaScript中，<code class="fe mz na nb nc b">undefined</code>和<code class="fe mz na nb nc b">null</code>被视为“falsy”值。这意味着在真正的假布尔值周围执行空值检查可能很棘手——例如，<code class="fe mz na nb nc b">0</code>或<code class="fe mz na nb nc b">false</code>——这有时可能是函数的合法响应。</p><p id="d8fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个(非常做作的)例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="32e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果来自<code class="fe mz na nb nc b">decisionMaker</code>的响应是<code class="fe mz na nb nc b">undefined</code>，我们可以使用nullish合并操作符(<code class="fe mz na nb nc b">??</code>)将值设置为<code class="fe mz na nb nc b">"Undecided"</code>——否则，我们打印<code class="fe mz na nb nc b">true</code>或<code class="fe mz na nb nc b">false</code>。</p><p id="462c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以与逻辑“或”运算符(<code class="fe mz na nb nc b">||</code>)形成对比，如果值为<code class="fe mz na nb nc b">false</code>或“falsy”，则逻辑“或”运算符失败在这个例子中，如果我们使用<code class="fe mz na nb nc b">||</code>操作符，当<code class="fe mz na nb nc b">decisionMaker</code>函数同时返回<code class="fe mz na nb nc b">false</code>和<code class="fe mz na nb nc b">undefined</code>时，我们会看到<code class="fe mz na nb nc b">false</code>，这不是我们想要的行为。</p><p id="b297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用nullish合并操作符之前，我们应该完成如下工作:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="c906" class="nj md it nc b gy nk nl l nm nn">const decision = decisionMaker();</span><span id="b9d9" class="nj md it nc b gy no nl l nm nn">if (typeof decision === "undefined") {<br/>  console.log("Should I go to the ball?", "Undecided");<br/>} else {<br/>  console.log("Should I go to the ball?", decision);<br/>}</span></pre><p id="b307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用nullish合并操作符给我们带来了更干净、可读性更强的代码，并减少了出错的空间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cd8e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可选链接</h1><p id="833b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可选链接允许您从嵌套属性中选择一个值，而无需显式检查链中的每个属性是否都已定义。如果链中的任何属性都没有定义，您只会得到<code class="fe mz na nb nc b">undefined</code>而不是运行时错误。</p><p id="f0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以像这样重构代码:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="a172" class="nj md it nc b gy nk nl l nm nn">let result;</span><span id="61d6" class="nj md it nc b gy no nl l nm nn">if (foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz) {<br/>  result = foo.bar.baz;<br/>}</span></pre><p id="af53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3fd8" class="nj md it nc b gy nk nl l nm nn">const result = foo?.bar?.baz;</span></pre><p id="1078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于可读性来说是一个巨大的胜利，让你的代码更加简洁。这也意味着您很少会错过空检查和在代码中引入不必要的bug。</p><p id="e8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可选链接的主要用例——然而，在其他一些情况下，它会非常有用。例如，如果函数已定义，它允许您选择性地执行该函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们只执行从actions对象中选择的值(如果它已定义)——这允许我们在函数未定义的情况下使用nullish合并操作符返回回退消息。以前，您可能需要这样做:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="6167" class="nj md it nc b gy nk nl l nm nn">if (typeof actions[action] === "function") {<br/>  return actions[action](num1, num2);<br/>}</span><span id="e2da" class="nj md it nc b gy no nl l nm nn">return "Calculation is not recognised";</span></pre><p id="7717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比使用可选链接的版本代码要多得多，在我看来也不够清晰——当然这是个人偏好！</p><p id="2b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果定义了数组，还可以使用可选的链接从数组中选择一项。例如:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="c89a" class="nj md it nc b gy nk nl l nm nn">const first = people.filter((person) =&gt; person.name === name)?.[0];</span></pre><p id="92e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们按姓名过滤一组人员，如果过滤器返回了一些值，则只选择第一个选项。同样，简洁明了，在我看来，比大量的空值检查更具可读性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="8981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">掌握最新JavaScript规范的最新内容意味着您可以利用新特性来编写更简洁、更易维护的代码。可选链接和nullish合并操作符是我特别喜欢的，希望这些例子能给你一些如何在自己的项目中使用它们的想法。</p></div></div>    
</body>
</html>