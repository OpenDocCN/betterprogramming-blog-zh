<html>
<head>
<title>About Kubernetes’ CNI Plugins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Kubernetes的CNI插件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/about-kubernetes-cni-plugins-f0bcd60b5629?source=collection_archive---------2-----------------------#2021-01-12">https://betterprogramming.pub/about-kubernetes-cni-plugins-f0bcd60b5629?source=collection_archive---------2-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f6d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">揭秘CNI插件的使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e0982000bfcbaafe65b6c0779d60fbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIgjBfIvDNBp80DgTV6SAA.png"/></div></div></figure><p id="1ab3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设置Kubernetes集群时，必须安装网络插件，集群才能运行。为了简单起见，网络插件的作用是建立网络连接，以便集群中不同节点上运行的Pods可以相互通信。根据插件的不同，可以提供不同的网络解决方案:覆盖(vxlan，IP-in-IP)或非覆盖。</p><p id="1604" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简化网络插件的使用，Kubernetes公开了容器网络接口(又名CNI ),因此任何实现该接口的网络插件都可以使用。</p><p id="6c3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubernetes还允许使用非CNI网络插件kubenet T1。这个是基本的，功能有限。</p><p id="a5c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们使用托管集群(有很多:<a class="ae lq" href="https://docs.aws.amazon.com/eks/latest/userguide/clusters.html" rel="noopener ugc nofollow" target="_blank">亚马逊EKS </a>、<a class="ae lq" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">谷歌GKE </a>、<a class="ae lq" href="https://www.digitalocean.com/products/kubernetes/" rel="noopener ugc nofollow" target="_blank">数字海洋DOKS </a>、<a class="ae lq" href="https://www.ovhcloud.com/en/public-cloud/kubernetes/" rel="noopener ugc nofollow" target="_blank"> OVH托管Kubernetes </a>、<a class="ae lq" href="https://www.scaleway.com/en/kubernetes-kapsule/" rel="noopener ugc nofollow" target="_blank"> Scaleway Kapsule </a>)，CNI网络插件已经从许多现有的解决方案中选出并为我们安装。但是如果我们安装自己的集群，我们需要手动选择和安装插件。不过，一些外部工具，如<a class="ae lq" href="https://rancher.com/products/rancher/" rel="noopener ugc nofollow" target="_blank"> Rancher </a>，让这个过程变得非常简单。</p><p id="81f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将介绍CNI，看看一个网络插件是如何安装，配置和使用的。我们将遵循以下步骤:</p><ul class=""><li id="4fbe" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">集装箱网络接口快速介绍(CNI)</li><li id="97dd" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">使用Calico插件设置k0s集群</li><li id="8654" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">用编织网插件建立一个k0s集群</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="86ec" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">CNI——快速介绍</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/737ad4fc97b269009a7d3172f9fa4ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*r3Z-0G3oNe4Ehf7TtLM0CA.png"/></div></figure><h2 id="98a2" class="nf mn it bd mo ng nh dn ms ni nj dp mw ld nk nl my lh nm nn na ll no np nc nq bi translated">什么是CNI？</h2><p id="c4b7" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">根据<a class="ae lq" href="https://github.com/containernetworking/cni" rel="noopener ugc nofollow" target="_blank">官方定义</a>，</p><blockquote class="nw nx ny"><p id="9a31" class="ku kv nz kw b kx ky ju kz la lb jx lc oa le lf lg ob li lj lk oc lm ln lo lp im bi translated">“CNI (Container Network Interface)，一个<a class="ae lq" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基金会</a>项目，包括一个规范和用于编写插件的库，以配置Linux容器中的网络接口，以及许多支持的插件。CNI只关心容器的网络连通性，并在删除容器时移除分配的资源</p></blockquote><p id="f46c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CNI是一个规范，也是该规范的一些参考实现。</p><p id="2aeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CNI规范目前版本为0 . 4 . 0(2021年1月)，可从官方<a class="ae lq" href="https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>获得。</p><p id="b6f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CNI插件(遵循CNI规范的网络插件)主要负责:</p><ul class=""><li id="7831" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">将网络接口插入容器</li><li id="b7ff" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">给这个接口分配一个IP</li><li id="8c62" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">删除容器时删除此接口</li></ul><p id="0f28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在幕后，插件是一个可执行文件，它必须实现几个方法(在未来的版本中可能会添加更多):</p><ul class=""><li id="9b55" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">添加:向网络添加容器</li><li id="dd75" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">DEL:从网络中删除容器</li><li id="47f8" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">检查:确保容器的网络正常工作</li><li id="2591" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">版本:提供当前版本</li></ul><h2 id="a8f7" class="nf mn it bd mo ng nh dn ms ni nj dp mw ld nk nl my lh nm nn na ll no np nc nq bi translated">一些参考实现</h2><p id="bbe8" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">容器网络团队还维护了一组被分成几个类别的<a class="ae lq" href="https://www.cni.dev/plugins" rel="noopener ugc nofollow" target="_blank">参考实现</a>:</p><ul class=""><li id="565e" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">创建几种类型的网络接口的主要插件</li><li id="4ad7" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">专用于IP地址分配的IPAM插件</li><li id="a971" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">更具体的插件</li></ul><p id="d126" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中一些被其他CNI网络插件使用。</p><h2 id="fe41" class="nf mn it bd mo ng nh dn ms ni nj dp mw ld nk nl my lh nm nn na ll no np nc nq bi translated">实施CNI规范的第三方网络插件</h2><p id="5196" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">在参考实现之上，还有几个第三方CNI插件。其中最著名的有:</p><ul class=""><li id="6340" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><a class="ae lq" href="https://www.projectcalico.org/" rel="noopener ugc nofollow" target="_blank">印花棉布</a></li><li id="d260" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://cilium.io" rel="noopener ugc nofollow" target="_blank">纤毛</a></li><li id="6cb1" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://www.weave.works/docs/net/latest/overview/" rel="noopener ugc nofollow" target="_blank">编织网</a></li><li id="bfff" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://github.com/coreos/flannel" rel="noopener ugc nofollow" target="_blank">法兰绒</a></li></ul><p id="2ca5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更完整的列表可在<a class="ae lq" href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档</a>中找到。</p><p id="4690" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个集群都需要安装一个第三方插件</p><p id="bb3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个插件都有自己的一套功能。根据工作负载要求(Kubernetes网络策略的使用、数据平面的加密、低延迟等),这有时会使选择变得非常困难。).然而，这篇由<a class="od oe ep" href="https://medium.com/u/56f781522ec8?source=post_page-----f0bcd60b5629--------------------------------" rel="noopener" target="_blank">亚历克西斯·杜卡斯泰尔</a>撰写的<a class="ae lq" href="https://itnext.io/benchmark-results-of-kubernetes-network-plugins-cni-over-10gbit-s-network-updated-august-2020-6e1b757b9e49" rel="noopener ugc nofollow" target="_blank"> CNI基准文章</a>绝对能在选择过程中帮到你。</p><h2 id="f7ec" class="nf mn it bd mo ng nh dn ms ni nj dp mw ld nk nl my lh nm nn na ll no np nc nq bi translated">插件是如何安装和使用的？</h2><p id="bb0b" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">通常，CNI网络插件作为DaemonSet运行，这意味着一个Pod确保网络配置将在集群的每个节点上运行。安装插件时，默认情况下会在<code class="fe of og oh oi b">/etc/cni/net.d</code>中创建一个特定的网络配置文件。这个配置文件必须匹配<a class="ae lq" href="https://github.com/containernetworking/cni/blob/master/SPEC.md#network-configuration" rel="noopener ugc nofollow" target="_blank"> CNI规范</a>，并且该文件中引用的任何CNI插件必须存在于/opt/cni/bin中。Kubelet负责读取CNI配置文件，并按照指定的方式调用插件二进制文件，因此它可以为每个Pod设置网络。</p><p id="5306" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一部分中，我们将创建一个单节点Kubernetes集群，并在其上安装Calico CNI插件。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b415" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用Calico运行k0s</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/7d4428497d05a4b733640f55847b006a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrQ9G4FL17aWsuDcZ8ddoA.png"/></div></div></figure><p id="8601" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<a class="ae lq" href="https://medium.com/better-programming/k0s-kubernetes-in-a-single-binary-224bb43f4520" rel="noopener">之前的一篇文章</a>中，我们已经展示了<a class="ae lq" href="https://k0sproject.io/" rel="noopener ugc nofollow" target="_blank"> k0s </a>，一个由<a class="od oe ep" href="https://medium.com/u/fedcaa2e9074?source=post_page-----f0bcd60b5629--------------------------------" rel="noopener" target="_blank"> Mirantis </a>开发的新的Kubernetes发行版。我们将在本文中使用k0s来说明CNI插件的用法。如果你还不知道k0s，我推荐你快速浏览一下这篇文章，这样你就可以开始使用这个伟大的Kubernetes发行版了。</p><p id="f7d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一部分中，我们将运行一个基于k0s的单节点Kubernetes集群。我们将使用默认配置，这样它会自动安装Calico网络插件。</p><p id="a13e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们创建一个Ubuntu虚拟机。在本例中，我们使用默认配置的<a class="ae lq" href="https://multipass.run" rel="noopener ugc nofollow" target="_blank">多通道</a>(1个CPU、1G RAM、5G HDD)。如果您遵循本教程，您可以使用任何其他解决方案创建一个VM(在本地使用vagger，在云提供商的基础设施上，等等)。)</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="258c" class="nf mn it oi b gy oo op l oq or">$ multipass launch -n node1</span></pre><p id="ea9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来我们得到k0s二进制的最新版本。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="7dff" class="nf mn it oi b gy oo op l oq or">$ curl -sSLf get.k0s.sh | sudo sh</span></pre><p id="7dbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们运行单节点集群，确保该节点同时充当主节点和工作节点:</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="9fee" class="nf mn it oi b gy oo op l oq or">$ sudo k0s server --enable-worker</span></pre><p id="d1fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们在运行服务器时没有指定任何配置文件，所以使用默认配置。如果我们需要知道所使用的默认参数，我们可以使用以下命令来列出它们:</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="2cad" class="nf mn it oi b gy oo op l oq or">$ k0s default-config</span></pre><p id="a63d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们配置本地kubectl。正如我们在以前的文章中多次做的那样，我们需要获得k0s生成的<code class="fe of og oh oi b">kubeconfig</code>文件，修改IP地址，使其使用VM外部IP，并公开kubectl考虑的一个环境变量:</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="2695" class="nf mn it oi b gy oo op l oq or"># Get kubeconfig file<br/>multipass exec node1 sudo cat /var/lib/k0s/pki/admin.conf &gt; k0s.cfg</span><span id="1a90" class="nf mn it oi b gy os op l oq or"># Replace IP address<br/>NODE_IP=$(multipass info node1 | grep IP | awk '{print $2}')<br/>sed -i '' "s/localhost/$NODE_IP/" k0s.cfg</span><span id="d0da" class="nf mn it oi b gy os op l oq or"># Configure local kubectl<br/>export KUBECONFIG=$PWD/k0s.cfg</span></pre><p id="62b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们可以检查群集单个节点的状态。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="e77e" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu">$ kubectl get no<br/></strong>NAME    STATUS   ROLES    AGE    VERSION<br/>node1   Ready    &lt;none&gt;   101m   v1.20.1-k0s1</span></pre><p id="0622" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">节点的状态为Ready，这意味着一切运行良好:Calico网络插件已经正确配置和安装。</p><p id="ffec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在将仔细看看网络插件。在集群的每个节点上(在我们的示例中只有一个节点)，文件夹<code class="fe of og oh oi b"> /etc/cni/net.d</code>包含一个描述网络配置的文件。正如我们在下面看到的，还有一个<code class="fe of og oh oi b">kubeconfig</code>文件，它允许calico进程与API服务器通信。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="6e31" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu"># ls /etc/cni/net.d/<br/></strong>10-calico.conflist  calico-kubeconfig</span></pre><p id="9428" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们看一下<code class="fe of og oh oi b">.conflist</code>文件，我们可以看到它引用了几个插件:</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="ae19" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu"># cat /etc/cni/net.d/10-calico.conflist<br/></strong>{<br/>  "name": "k8s-pod-network",<br/>  "cniVersion": "0.3.1",<br/>  "plugins": [<br/>    {<br/>      "type": "<strong class="oi iu">calico</strong>",<br/>      "log_level": "info",<br/>      "log_file_path": "/var/log/calico/cni/cni.log",<br/>      "datastore_type": "kubernetes",<br/>      "nodename": "node1",<br/>      "mtu": 1450,<br/>      "ipam": {<br/>          "type": "<strong class="oi iu">calico-ipam</strong>"<br/>      },<br/>      "policy": {<br/>          "type": "k8s"<br/>      },<br/>      "kubernetes": {<br/>          "kubeconfig": "/etc/cni/net.d/calico-kubeconfig"<br/>      }<br/>    },<br/>    {<br/>      "type": "<strong class="oi iu">portmap</strong>",<br/>      "snat": true,<br/>      "capabilities": {"portMappings": true}<br/>    },<br/>    {<br/>      "type": "<strong class="oi iu">bandwidth</strong>",<br/>      "capabilities": {"bandwidth": true}<br/>    }<br/>  ]<br/>}</span></pre><p id="ebcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这些插件中，有两个被引用的实现可以在官方的GitHub CNI库中找到:<a class="ae lq" href="https://github.com/containernetworking/plugins" rel="noopener ugc nofollow" target="_blank">https://github.com/containernetworking/plugins</a></p><ul class=""><li id="9da4" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><strong class="kw iu"> portmap </strong>将流量从主机上的一个或多个端口转发到容器(详细信息见文档<a class="ae lq" href="https://www.cni.dev/plugins/meta/portmap/" rel="noopener ugc nofollow" target="_blank">https://www.cni.dev/plugins/meta/portmap/</a>)</li><li id="54d0" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><strong class="kw iu">带宽</strong>提供了一种使用和配置Linux流量控制(TC)子系统的方法(详细信息见文档<a class="ae lq" href="https://www.cni.dev/plugins/meta/bandwidth/" rel="noopener ugc nofollow" target="_blank">https://www.cni.dev/plugins/meta/bandwidth/</a></li></ul><p id="e607" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外两个插件来自Calico项目:<a class="ae lq" href="https://github.com/projectcalico/cni-plugin" rel="noopener ugc nofollow" target="_blank">https://github.com/projectcalico/cni-plugin</a></p><ul class=""><li id="5d8a" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><strong class="kw iu"> calico </strong> <em class="nz"> </em>是顶级的Calico CNI插件</li><li id="4af4" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><strong class="kw iu"> calico-ipam </strong>控制IP地址如何分配给集群中的pod</li></ul><p id="dd19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个文件基本上定义了网络配置，并告诉kubelet(读取这个配置的进程)需要调用哪些插件，以及必须如何调用。在<code class="fe of og oh oi b">plugins</code>列表中的插件被顺序调用。</p><p id="a123" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，kubelet从<code class="fe of og oh oi b">/opt/cni/bin</code>文件夹中访问这些插件。列出我们单个节点上可用的插件，有一些在上面的配置文件中没有提到(法兰绒、主机本地、调优等等)。这些插件也由Calico提供(端口映射和带宽插件也是如此),因为如果不同的配置文件需要它们，它们可能会被使用。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="3b7d" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu"># ls /opt/cni/bin/<br/></strong>bandwidth<br/>calico<br/>calico-ipam<br/>flannel<br/>host-local<br/>install<br/>loopback<br/>portmap<br/>tuning</span></pre><p id="7531" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于所有的Kubernetes网络插件，Calico作为DaemonSet部署在集群上。上面列出的CNI网络插件是由这个守护进程中的一个<code class="fe of og oh oi b">initContainer</code>安装的。感谢Jussi Nummelin指出这一点。</p><p id="e650" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:在安装Calico之前，节点上既没有<code class="fe of og oh oi b">/etc/cni/net.d</code>也没有<code class="fe of og oh oi b">/opt/cni/bin</code>目录。</p><p id="02bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过网络配置，kubelet知道需要使用的CNI插件以及在哪里可以找到它们。每次运行一个新的Pod时，kubelet调用专用插件将一个网络接口连接到Pod，并为该接口分配一个IP地址。当一个Pod被删除时，kubelet调用插件来释放IP地址并删除该Pod的网络接口。</p><p id="9344" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一部分中，我们将再次使用k0s来创建一个单节点Kubernetes集群，但是这次我们将安装Weave Net CNI网络插件。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="8228" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用编织网运行k0s</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/28300264c0550c251033044b21c1b863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qlv3q4iRSv1CK60sHKax1Q.png"/></div></div></figure><p id="b8d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一部分中，我们遵循与上面相同的步骤:我们首先创建一个名为node2的新VM，并在该VM上获得最新的k0s版本。</p><p id="de56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在运行单节点k0s集群之前，我们创建一个配置文件来告诉k0s不要安装Calico，因为我们将在后面的步骤中安装Weave Net插件。我们在<code class="fe of og oh oi b">.spec.network.provider</code>属性中设置值<code class="fe of og oh oi b">custom</code>，并将该配置文件保存为<code class="fe of og oh oi b">k0s.yaml</code>。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="985c" class="nf mn it oi b gy oo op l oq or">apiVersion: k0s.k0sproject.io/v1beta1<br/>kind: Cluster<br/>metadata:<br/>  name: k0s<br/>spec:<br/>  api:<br/>    address: 192.168.64.12<br/>    sans:<br/>    - 192.168.64.12<br/>  network:<br/>    provider: custom</span></pre><p id="596f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:192.168.64.12是使用多通道创建的虚拟机的IP地址。</p><p id="d3ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果k0s找到一个名为<code class="fe of og oh oi b">k0s.yaml</code>的配置文件，它会自动使用这个文件，所以我们在命令行上运行集群时不需要指定它。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="2f3d" class="nf mn it oi b gy oo op l oq or">$ sudo k0s server --enable-worker</span></pre><p id="1c19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们检查群集单个节点的状态:</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="3dc9" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu">$ kubectl get no</strong><br/>NAME    STATUS     ROLES    AGE   VERSION<br/>node1   <strong class="oi iu">NotReady</strong>   &lt;none&gt;   18s   v1.20.1-k0s1</span></pre><p id="b468" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">节点显示为<code class="fe of og oh oi b">NotReady</code>，因为尚未安装CNI网络插件。我们可以在节点描述中获得更详细的错误消息:</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="702c" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu">$ kubectl describe node node2<br/></strong>...<br/>Conditions:<br/><strong class="oi iu">  </strong>  <strong class="oi iu">Ready            False   Fri, 08 Jan 2021 14:05:17 +0100   Fri, 08 Jan 2021 14:04:47 +0100   KubeletNotReady              runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:Network plugin returns error: cni plugin not initialized<br/>...</strong></span></pre><p id="8b38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，我们将安装一个网络插件。在本例中，我们选择了编织网。根据文档，安装是通过运行以下命令完成的，该命令:</p><ul class=""><li id="f67b" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">创建一个<code class="fe of og oh oi b">ServiceAccount</code></li><li id="9fb3" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">通过使用<code class="fe of og oh oi b">Role</code> / <code class="fe of og oh oi b">RoleBinding</code>和<code class="fe of og oh oi b">ClusterRole</code> / <code class="fe of og oh oi b">ClusterRoleBinding</code>赋予其一些权限</li><li id="a9be" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">以恶魔集的身份运行编织网</li></ul><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="5112" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu">$ kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"</strong><br/>serviceaccount/weave-net created<br/>clusterrole.rbac.authorization.k8s.io/weave-net created<br/>clusterrolebinding.rbac.authorization.k8s.io/weave-net created<br/>role.rbac.authorization.k8s.io/weave-net created<br/>rolebinding.rbac.authorization.k8s.io/weave-net created<br/>daemonset.apps/weave-net created</span></pre><p id="7526" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Weave Net的安装会在<code class="fe of og oh oi b"> /etc/cni/net.d</code>的主机文件系统上自动创建一个配置文件。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="7109" class="nf mn it oi b gy oo op l oq or"># find /etc/cni/<br/>/etc/cni/<br/>/etc/cni/net.d<br/>/etc/cni/net.d/10-weave.conflist</span></pre><p id="bdea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe of og oh oi b">/etc/cni/net.d/10-weave.conflist</code>文件定义了编织网网络插件的配置。如果我们仔细看看，我们可以看到它引用了几个插件:</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="e3ea" class="nf mn it oi b gy oo op l oq or"># cat /etc/cni/net.d/10-weave.conflist<br/>{<br/>    "cniVersion": "0.3.0",<br/>    "name": "weave",<br/>    "plugins": [<br/>        {<br/>            "name": "weave",<br/>            "type": "<strong class="oi iu">weave-net</strong>",<br/>            "hairpinMode": true<br/>        },<br/>        {<br/>            "type": "<strong class="oi iu">portmap</strong>",<br/>            "capabilities": {"portMappings": true},<br/>            "snat": true<br/>        }<br/>    ]<br/>}</span></pre><ul class=""><li id="dbe4" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><strong class="kw iu">编织网</strong>是顶级编织网CNI插件</li><li id="d7dc" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><strong class="kw iu">端口映射</strong>将主机上一个或多个端口的流量转发到容器(详细信息见文档<a class="ae lq" href="https://www.cni.dev/plugins/meta/portmap/" rel="noopener ugc nofollow" target="_blank">https://www.cni.dev/plugins/meta/portmap/</a></li></ul><p id="ef54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Weave Net DaemonSet的安装还会在主机文件系统的<code class="fe of og oh oi b">/opt/cni/bin</code>中创建一些CNI二进制文件:</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="b2e3" class="nf mn it oi b gy oo op l oq or"># find /opt/cni/<br/>/opt/cni/<br/>/opt/cni/bin<br/>/opt/cni/bin/weave-plugin-2.7.0<br/>/opt/cni/bin/weave-net<br/>/opt/cni/bin/weave-ipam</span></pre><p id="c823" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:<code class="fe of og oh oi b">weave-net</code>和<code class="fe of og oh oi b">weave-ipam</code>是两个指向weave-plugin-2.7.0的符号链接。</p><p id="5f50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些二进制文件似乎丢失了——例如，<code class="fe of og oh oi b">conflist</code>文件中引用的portmap——但也有一些其他被间接使用的文件(例如loopback)。后果就是所有非DaemonSet的豆荚还是<code class="fe of og oh oi b">Pending</code>。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="ecc4" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu">$ kubectl get po -A<br/></strong>NAMESPACE     NAME                     READY STATUS  RESTARTS   AGE<br/>kube-system   coredns-5c98d7d4d8-5pxs8 1/1   <strong class="oi iu">Pending</strong> 0          2m<br/>kube-system   konnectivity-agent-gghlv 1/1   <strong class="oi iu">Pending</strong> 0          1m<br/>kube-system   kube-proxy-557gw         1/1   Running 0          2m<br/>kube-system   metrics-server-...       1/1   <strong class="oi iu">Pending</strong> 0          2m</span></pre><p id="db45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们仔细看看dns pod，我们会发现这个问题的原因:环回插件丢失了。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="dae6" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu">$ kubectl describe po -l k8s-app=kube-dns -n kube-system<br/></strong>...<br/>Warning  FailedCreatePodSandBox  8s (x11 over 2m17s)   kubelet            (combined from similar events): Failed to create pod sandbox: rpc error: code = Unknown desc = failed to setup network for sandbox "fcbf107aea021ba123c25ee746dbb59f37a3bc9687ac49287295ec805edc80f4": failed to find plugin "<strong class="oi iu">loopback</strong>" in path [/opt/cni/bin]</span></pre><p id="3ffc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我仍然不确定谁应该负责运送Weave Net正常工作所需的插件。这应该是运行Weave Net DaemonSet时初始化步骤的一部分(如安装Calico时所做的)还是k0s应该确保的先决条件(如<code class="fe of og oh oi b">kubeadm</code>所做的)？我认为第一种选择似乎更符合逻辑。</p><p id="5fac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与此同时，我们可以通过从官方GitHub库获取插件并将其提取到<code class="fe of og oh oi b">/opt/cni/bin</code>中来轻松解决这个问题。</p><div class="ou ov gp gr ow ox"><a href="https://github.com/containernetworking/plugins/releases" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">包含网络/插件的版本</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">欢迎来到CNI社区插件的v0.9.0。感谢@fedepaol，我们有了VRF链接插件，它将创建…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">github.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div><p id="f6af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:在这个例子中，我们复制了所有的插件，即使其中一些不一定被Weave Net使用。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="0e1c" class="nf mn it oi b gy oo op l oq or"># Get cni plugins<br/>root@node2:~# curl -sSL -o cni.tgz https://github.com/containernetworking/plugins/releases/download/v0.9.0/cni-plugins-linux-amd64-v0.9.0.tgz</span><span id="ee2f" class="nf mn it oi b gy os op l oq or"># Extract the plugins into the /opt/cni/bin folder<br/>root@node2:~# tar xvf cni.tgz -C /opt/cni/bin/</span></pre><p id="bb43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几秒钟后，我们可以验证pod是否正常运行。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="7f5f" class="nf mn it oi b gy oo op l oq or"><strong class="oi iu">$ kubectl get po -A<br/></strong>NAMESPACE     NAME                     READY STATUS  RESTARTS   AGE<br/>kube-system   coredns-5c98d7d4d8-5pxs8 1/1   Running 0          6m<br/>kube-system   konnectivity-agent-gghlv 1/1   Running 0          5m<br/>kube-system   kube-proxy-557gw         1/1   Running 0          6m<br/>kube-system   metrics-server-...       1/1   Running 0          6m<br/>kube-system   weave-net-pw9mz          2/2   Running 0          1m</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="839c" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="a5bc" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">我希望这篇文章中的例子有助于揭开CNI插件的神秘面纱。不去探究插件是如何实现的细节(有这么多实现)，我认为重要的是看看这些插件是如何发布的，配置是如何提供给kubelet的，以及它们是如何被调用的。</p></div></div>    
</body>
</html>