<html>
<head>
<title>An Intro to Javascript for Experienced Programmers Who Could Use a Strong Dose of Fundamentals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向有经验的程序员的Javascript介绍，他们可能需要大量的基础知识</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-intro-to-javascript-for-experienced-programmers-who-could-use-a-strong-dose-of-fundamentals-31535030616b?source=collection_archive---------0-----------------------#2019-05-02">https://betterprogramming.pub/an-intro-to-javascript-for-experienced-programmers-who-could-use-a-strong-dose-of-fundamentals-31535030616b?source=collection_archive---------0-----------------------#2019-05-02</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/d603e3cab9fa84ee1983ced4e8934d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIN7CtPsBgl7tA1fHbTO1w.jpeg"/></div></div></figure><p id="51da" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当我们准备推出<a class="ae la" href="http://medium.com/better-programming" rel="noopener"> Better Programming </a>时，我联系了一个我认为是编程大师的人，<a class="ae la" href="http://raganwald.com/" rel="noopener ugc nofollow" target="_blank">雷金纳德·布莱斯维特</a>(在许多地方被称为<a class="ae la" href="https://twitter.com/raganwald" rel="noopener ugc nofollow" target="_blank">拉甘瓦尔德</a>)。我想知道的是，他是否会从他的书《JavaScript Allongé》中贡献一个样本章节，这本书是“Six”版(<a class="ae la" href="https://www.amazon.com/dp/B00FLKRCVO?tag=coachdotme20-20" rel="noopener ugc nofollow" target="_blank"> amazon </a> | <a class="ae la" href="https://leanpub.com/javascriptallongesix" rel="noopener ugc nofollow" target="_blank"> leanpub </a>)。</p><p id="1bfa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">相反，他的反应只是简单地把他的书的版权条款改成了“知识共享:归属/共享——类似”,并让我尽情发挥。(也许狂野是言过其实了。)</p><p id="6b88" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">下面是这本书的一部分，很长的一部分，我发现它在一个非常特别的方面很有价值。对于从未编程的人来说，有很多JavaScript教程。但我一直在编程，至少从1994年开始(甚至是80年代，如果你把移动屏幕上有Logo的乌龟也算在内的话)。</p><p id="cbd2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然而，当编程世界跳到JavaScript时，我有点迷失了。我花了一段时间才意识到为什么，尽管事后看来这是显而易见的。我从未真正理解JavaScript语言的基础。我以前总是有语言足够相似的经验，以至于我大部分时间只是查找偶尔的语法细节。例如，我的第一个PHP和Rails项目带有一个基于Perl web开发的心智模型。不过JavaScript有点太不一样了，所以我发现自己需要回去学习基础知识。</p><p id="e3fa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这就是雷金纳德的书出现的地方。我发现他的文章很迂腐，这让我想起了我的计算机科学教授。这正是我想要的——这不是给初次程序员的教程。另外，我想Reginald会说，对编程语言有学究式的详细了解是务实的——你会工作得更快，犯的错误更少。</p><p id="72df" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">下面的教程从最基本的开始:值和变量。我发现这种复习很有价值。但是当他进入函数时，真正的肉来了。</p><p id="09ed" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我用我的JavaScript控制台在Chrome上阅读了下面的内容。这样我就可以一边走一边测试我自己的代码版本。</p><figure class="lc ld le lf gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj lb"><img src="../Images/366a9efc11b09bd9b210bffeb7d52bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgwCpVJgIazqXPhXhUkfdQ.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">通过右键单击&gt;检查&gt;控制台打开Javascript控制台</p></figure></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="5d03" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">前奏:喝咖啡时的价值观和表达</h1><p id="035e" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated"><em class="mu">以下材料极其基础；然而，像大多数故事一样，最好的开始方式是从头开始。</em></p><p id="33f8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">想象我们正在参观我们最喜欢的咖啡店。他们会为你制作任何你想要的饮料，从短而浓的意式浓缩咖啡到干的卡布奇诺，再到以各种浓缩糖浆和牛奶为特色的咖啡口味的沙漠混合物。(你容忍含糖饮料的存在，因为它们为公司提供了足够的利润空间，让你可以整天使用他们的无线网络，每隔几个小时就点一杯3美元的饮料。)</p><p id="d38f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">你在他们柜台的一端表达你的订单，柜台后面的人表演他们的魔术，在另一端递送你所珍视的咖啡。这正是本书中JavaScript环境的工作方式。我们将省去网络服务器、浏览器和其他复杂的东西，处理这个简单的模型:你给计算机一个表达式，它返回一个值，就像你向咖啡师表达你的愿望，得到一杯咖啡作为回报。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="a68a" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">值是表达式</h2><p id="855e" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">所有的值都是表达式。假设你递给咖啡师一杯古巴咖啡。是的，你递过来一杯用部分焦糖浸泡的咖啡。你说，“我想要一个。”咖啡师不是傻瓜，她会直接把它还给你，你就会得到你想要的。因此，一杯古巴咖啡是一种表达(你可以用它来下订单)和一种价值(你可以从咖啡师那里拿回来)。</p><p id="1af5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们用计算机容易理解的东西来试试:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="5969" class="mv ls iu ni b gz nm nn l no np">42</span></pre><p id="25a8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是一种表达吗？一个值？都不是？还是两者都有？</p><p id="2034" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">答案是，这既是一个表达式<em class="mu">又是一个值</em>。辨别两者的方法非常简单:当你输入JavaScript时，你会得到同样的结果，就像我们的古巴咖啡馆一样:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="4d86" class="mv ls iu ni b gz nm nn l no np">42<!-- -->   <br/>//=&gt; 42</span></pre><p id="b6fa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">所有的值都是表达式。那很简单！还有其他种类的表达吗？当然可以！我们回咖啡店吧。我们可以不交出成品咖啡，而是交出配料。让我们交出一些磨碎的咖啡加上一些开水。</p><p id="729e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">敏锐的读者会意识到我们遗漏了一些东西。恭喜你！喝一口浓咖啡。我们一会儿就会谈到这一点。</p><p id="4016" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在咖啡师还给我们一杯浓缩咖啡。如果我们交出浓缩咖啡，我们就能拿回浓缩咖啡。所以，开水加咖啡粉是一种表达，但不是一种价值。开水是一种价值。研磨咖啡是一种价值。浓缩咖啡是一种价值。开水加研磨咖啡是一种表达方式。</p><p id="33dc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们用其他计算机容易理解的东西来试试这个:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b371" class="mv ls iu ni b gz nm nn l no np">"JavaScript"<!-- --> <!-- -->+<!-- --> <!-- -->" "<!-- --> <!-- -->+<!-- --> <!-- -->"Allonge"<!-- -->   <br/>//=&gt; "JavaScript Allonge"</span></pre><p id="077c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在我们看到“字符串”是值，你可以用字符串和一个操作符<code class="fe nq nr ns ni b">+</code>做一个表达式。因为字符串是值，所以它们本身也是表达式。但是带运算符的字符串不是值，是表达式。现在我们知道“咖啡渣加热水”的例子中缺少了什么。咖啡渣是一个值，沸腾的热水是一个值，它们之间的“加”运算符使整个事物成为一个表达式，而不是一个值。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="f938" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">价值观和身份</h2><p id="609e" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">在JavaScript中，我们测试两个值是否与<code class="fe nq nr ns ni b">===</code>操作符相同，以及它们是否与<code class="fe nq nr ns ni b">!==</code>操作符不同:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="07fd" class="mv ls iu ni b gz nm nn l no np">2<!-- --> <!-- -->===<!-- --> <!-- -->2<!-- -->     <br/>//=&gt; true<!-- -->        </span><span id="72d4" class="mv ls iu ni b gz nt nn l no np">'hello'<!-- --> <!-- -->!==<!-- --> <!-- -->'goodbye'<!-- -->     <br/>//=&gt; true</span></pre><p id="b117" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">===</code>到底是如何运作的？想象给你看一杯咖啡。然后你会看到另一杯咖啡。这两个杯子“一模一样吗？”在JavaScript中，有四种可能性:</p><p id="4352" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">首先，有时，杯子是不同种类的。一个是小杯咖啡，另一个是大杯。这相当于在JavaScript中比较两个不同类型的东西。例如，字符串<code class="fe nq nr ns ni b">"2"</code>和数字<code class="fe nq nr ns ni b">2</code>不是一回事。字符串和数字是不同的类型，因此字符串和数字永远不会相同:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="f8ef" class="mv ls iu ni b gz nm nn l no np">2<!-- --> <!-- -->===<!-- --> <!-- -->'2'<!-- -->   <br/>//=&gt; false<!-- -->    </span><span id="43d6" class="mv ls iu ni b gz nt nn l no np">true<!-- --> <!-- -->!==<!-- --> <!-- -->'true'<!-- -->   <br/>//=&gt; true</span></pre><p id="5476" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">第二，有时，杯子是同一类型的——也许是两个咖啡杯——但它们有不同的内容物。一个拿着单人的，一个拿着双人的。这相当于比较两个类型相同但“内容”不同的JavaScript值。比如数字<code class="fe nq nr ns ni b">5</code>和数字<code class="fe nq nr ns ni b">2</code>不是一回事。</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="dd9d" class="mv ls iu ni b gz nm nn l no np">true<!-- --> <!-- -->===<!-- --> <!-- -->false<!-- -->   <br/>//=&gt; false<!-- -->    </span><span id="5024" class="mv ls iu ni b gz nt nn l no np">2<!-- --> <!-- -->!==<!-- --> <!-- -->5<!-- -->   <br/>//=&gt; true<!-- -->    </span><span id="d647" class="mv ls iu ni b gz nt nn l no np">'two'<!-- --> <!-- -->===<!-- --> <!-- -->'five'<!-- -->   <br/>//=&gt; false</span></pre><p id="b11a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果杯子是同类型的<em class="mu">和</em>内容是一样的怎么办？JavaScript的第三和第四种可能性涵盖了这一点。</p><h2 id="979e" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">值类型</h2><p id="cffc" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">第三，有些类型的杯子上没有明显的标志。如果它们是同一种杯子，装的是同样的东西，我们就没有办法区分它们。到目前为止，我们看到的字符串、数字和布尔值就是这种情况。</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="0b0f" class="mv ls iu ni b gz nm nn l no np">2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- --> <!-- -->===<!-- --> <!-- -->4<!-- -->   <br/>//=&gt; true<!-- -->    </span><span id="e209" class="mv ls iu ni b gz nt nn l no np">(2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- --> <!-- -->===<!-- --> <!-- -->4)<!-- --> <!-- -->===<!-- --> <!-- -->(2<!-- --> <!-- -->!==<!-- --> <!-- -->5)<!-- -->   <br/>//=&gt; true</span></pre><p id="5789" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">请注意这些例子所发生的事情:即使我们获得一个字符串、数字或布尔值作为表达式的求值结果，它也与另一个具有相同“内容”的相同类型的值相同。字符串、数字和布尔值是JavaScript所谓的“值”或“原始”类型的例子。我们将交替使用这两个术语。</p><p id="2769" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们还没有遇到第四种可能。稍微延伸一下这个比喻，一些类型的杯子在底部有一个序列号。所以即使你有两个同类型的杯子，它们的内容物是一样的，你仍然可以区分它们。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="23cc" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">参考类型</h2><p id="cf7b" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">那么，哪些类型的值可能是相同的类型，具有相同的内容，但不被认为与JavaScript相同呢？我们来认识一个当代编程语言中非常常见的数据结构，<em class="mu">数组</em>(其他语言有时称之为列表或向量)。</p><p id="ea04" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一个数组是这样的:<code class="fe nq nr ns ni b">[1, 2, 3]</code>。这是一个表达式，你可以把<code class="fe nq nr ns ni b">[]</code>和其他表达式组合起来。疯狂做一些事情，比如:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9d0c" class="mv ls iu ni b gz nm nn l no np">[2-1,<!-- --> <!-- -->2,<!-- --> <!-- -->2+1]<!-- --> <br/>[1,<!-- --> <!-- -->1+1,<!-- --> <!-- -->1+1+1]</span></pre><p id="7070" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">请注意，您总是生成具有相同内容的数组。但是它们是相同的吗，就像<code class="fe nq nr ns ni b">42</code>的每一个值都与<code class="fe nq nr ns ni b">42</code>的每一个值相同吗？自己试试这些:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9e1d" class="mv ls iu ni b gz nm nn l no np">[2-1,<!-- --> <!-- -->2,<!-- --> <!-- -->2+1]<!-- --> <!-- -->===<!-- --> <!-- -->[1,2,3]<!-- --> <br/>[1,2,3]<!-- --> <!-- -->===<!-- --> <!-- -->[1,<!-- --> <!-- -->2,<!-- --> <!-- -->3]<!-- --> <br/>[1,<!-- --> <!-- -->2,<!-- --> <!-- -->3]<!-- --> <!-- -->===<!-- --> <!-- -->[1,<!-- --> <!-- -->2,<!-- --> <!-- -->3]</span></pre><p id="73ce" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">怎么样！当您键入<code class="fe nq nr ns ni b">[1, 2, 3]</code>或它的任何变体时，您键入的是一个生成自己的<em class="mu">唯一</em>数组的表达式，该数组与任何其他数组都不相同，即使其他数组看起来也像<code class="fe nq nr ns ni b">[1, 2, 3]</code>。这就好像JavaScript正在生成底部带有序列号的新咖啡。</p><p id="98fd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">它们看起来一样，但是如果你用<code class="fe nq nr ns ni b">===</code>来审视它们，你会发现它们是不同的。每次你评估一个表达式(包括输入一些内容)来创建一个数组，你都在创建一个新的、不同的值，即使它<em class="mu">看起来</em>与其他数组值相同。正如我们将看到的，这适用于许多其他类型的值，包括本书的主题<em class="mu">函数</em>。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="e4d2" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">浓郁的香气:基本数字</h2><blockquote class="nu nv nw"><p id="e523" class="kc kd mu ke b kf kg kh ki kj kk kl km nx ko kp kq ny ks kt ku nz kw kx ky kz in bi translated">在计算机科学中，文字是表示源代码中固定值的符号。几乎所有的编程语言都有整数、浮点数和字符串等原子值的符号，通常还有布尔和字符的符号；有些还有枚举类型和复合值元素的符号，如数组、记录和对象。匿名函数是函数类型的文字。— <a class="ae la" href="https://en.wikipedia.org/wiki/Literal_(computer_programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="b968" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">像大多数语言一样，JavaScript有一个文字集合。我们看到，像<code class="fe nq nr ns ni b">42</code>这样仅由数字组成的表达式是一个字面量。它代表数字42，也就是以42为基数的10。不是所有的数字都是十进制的。如果我们以零开始一个文字，它是一个八进制文字。所以字面上的<code class="fe nq nr ns ni b">042</code>是42基8，实际上是34基10。</p><p id="c14a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在内部，<code class="fe nq nr ns ni b">042</code>和<code class="fe nq nr ns ni b">34</code>具有相同的表示，如<a class="ae la" href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noopener ugc nofollow" target="_blank">双精度浮点数</a>。理解计算机内部的数字表示很重要。机器对数字的表示几乎永远不会与我们对数字行为的理解完全一致，因此，如果我们对它在“引擎盖下”做什么知之甚少，就会有一些地方让我们感到惊讶。</p><p id="3ce0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">例如，JavaScript可以安全处理的最大整数是<code class="fe nq nr ns ni b">9007199254740991</code>，或<code class="fe nq nr ns ni b">2^53 - 1</code>。像大多数编程语言一样，JavaScript不允许我们使用逗号来分隔数字组。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="93f4" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">浮动的</h2><p id="f4c7" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">大多数程序员从未遇到过整数的大小限制。但是我们提到，数字在内部表示为浮点，这意味着它们不一定只是整数。例如，我们可以编写<code class="fe nq nr ns ni b">1.5</code>或<code class="fe nq nr ns ni b">33.33</code>，JavaScript将这些文字表示为浮点数。</p><p id="d751" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">人们很容易认为我们现在已经拥有了处理大量金钱等事情所需的一切，但正如已故的约翰·贝鲁西所说的那样，“不，不，不，不，不，不。计算机内部浮点数的表示是二进制的，而我们的文字数是十进制的。这对整数来说没有意义，但对分数来说有意义，因为一些以10为基数的分数没有以2为基数的精确表示。</p><p id="47cf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">最常重复的一个例子是:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="4738" class="mv ls iu ni b gz nm nn l no np">1.0<!-- -->   <br/>//=&gt; 1<!-- --> </span><span id="3a3a" class="mv ls iu ni b gz nt nn l no np">1.0<!-- --> <!-- -->+<!-- --> <!-- -->1.0<!-- -->   <br/>//=&gt; 2<!-- --> </span><span id="2589" class="mv ls iu ni b gz nt nn l no np">1.0<!-- --> <!-- -->+<!-- --> <!-- -->1.0<!-- --> <!-- -->+<!-- --> <!-- -->1.0<!-- -->   <br/>//=&gt; 3</span></pre><p id="adaf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然而:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="340e" class="mv ls iu ni b gz nm nn l no np">0.1<!-- -->   <br/>//=&gt; 0.1<!-- --> </span><span id="bb68" class="mv ls iu ni b gz nt nn l no np">0.1<!-- --> <!-- -->+<!-- --> <!-- -->0.1<!-- -->   <br/>//=&gt; 0.2<!-- --> </span><span id="f4cc" class="mv ls iu ni b gz nt nn l no np">0.1<!-- --> <!-- -->+<!-- --> <!-- -->0.1<!-- --> <!-- -->+<!-- --> <!-- -->0.1<!-- -->   <br/>//=&gt; 0.30000000000000004</span></pre><p id="fd9c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当执行具有可接受偏差的计算时，这种“不精确”可以忽略。例如，当将页面上的一些文本居中时，只要您可能计算的手写内容和JavaScript计算的内容之间的差异小于一个像素，就没有可观察到的错误。</p><p id="d9cb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是作为一个规则，如果你需要处理实数，你应该对IEEE浮点运算标准有更多的了解。专业程序员几乎从不使用浮点数来表示货币金额。例如，“$43.21”几乎总是用两个数字表示:<code class="fe nq nr ns ni b">43</code>表示美元，<code class="fe nq nr ns ni b">21</code>表示美分，而不是<code class="fe nq nr ns ni b">43.21</code>。在本书中，我们不需要考虑这些细节，但在本书之外，我们必须考虑。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="f606" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">数字运算</h2><p id="b9d4" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">正如我们所见，JavaScript有许多常见的算术运算符。我们可以创建看起来非常像数学表达式的表达式，例如，我们可以写出<code class="fe nq nr ns ni b">1 + 1</code>或<code class="fe nq nr ns ni b">2 * 3</code>或<code class="fe nq nr ns ni b">42 - 34</code>甚至<code class="fe nq nr ns ni b">6 / 2</code>。这些可以组合成更复杂的表达式，比如<code class="fe nq nr ns ni b">2 * 5 + 1</code>。</p><p id="c283" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在JavaScript中，操作符有一个优先顺序，它被设计成模仿人类解析书面算法的方式。所以:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9a1b" class="mv ls iu ni b gz nm nn l no np">2<!-- --> <!-- -->*<!-- --> <!-- -->5<!-- --> <!-- -->+<!-- --> <!-- -->1<!-- -->   <br/>//=&gt; 11<!-- --> </span><span id="d10d" class="mv ls iu ni b gz nt nn l no np">1<!-- --> <!-- -->+<!-- --> <!-- -->5<!-- --> <!-- -->*<!-- --> <!-- -->2<!-- -->   <br/>//=&gt; 11</span></pre><p id="9945" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">JavaScript将表达式视为我们编写的<code class="fe nq nr ns ni b">(2 * 5) + 1</code>和<code class="fe nq nr ns ni b">1 + (5 * 2)</code>，因为<code class="fe nq nr ns ni b">*</code>操作符的<em class="mu">优先级比<code class="fe nq nr ns ni b">+</code>操作符的</em>高。JavaScript有更多的操作符。在某种意义上，它们的行为就像小函数。如果我们写<code class="fe nq nr ns ni b">1 + 2</code>，这在概念上类似于写<code class="fe nq nr ns ni b">plus(1, 2)</code>(当然，假设我们有一个函数将绑定到名字<code class="fe nq nr ns ni b">plus</code>的两个数字相加)。</p><p id="9937" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">除了常见的<code class="fe nq nr ns ni b">+</code>、<code class="fe nq nr ns ni b">-</code>、<code class="fe nq nr ns ni b">*</code>、<code class="fe nq nr ns ni b">/</code>，JavaScript还支持模数、<code class="fe nq nr ns ni b">%</code>和一元否定、<code class="fe nq nr ns ni b">-</code>:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="d97a" class="mv ls iu ni b gz nm nn l no np">-(457<!-- --> <!-- -->%<!-- --> <!-- -->3)<!-- -->   <br/>//=&gt; -1</span></pre><p id="5cbf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">还有许许多多可以用于数字的运算符，包括像<code class="fe nq nr ns ni b">|</code>和<code class="fe nq nr ns ni b">&amp;</code>这样的位运算符，它们允许您直接对数字的二进制表示进行运算，还有许多其他运算符执行赋值或逻辑比较，我们将在后面讨论。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="800d" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">关于函数，尽可能的少，但是不能少</h1><p id="2c00" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">在JavaScript中，函数是值，但它们也不仅仅是简单的数字、字符串，甚至是像树或地图这样复杂的数据结构。函数代表要执行的计算。像数字、字符串和数组一样，它们也有表示形式。让我们从第二个最简单的函数开始。在JavaScript中，它看起来像这样:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="4392" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->0</span></pre><p id="263f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是一个应用于无值并返回<code class="fe nq nr ns ni b">0</code>的函数。让我们验证我们的函数是一个像所有其他函数一样的值:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b3e8" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->0)<!-- -->   <br/>//=&gt; [Function]</span></pre><p id="a916" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">什么！？它为什么不给我们打回<code class="fe nq nr ns ni b">() =&gt; 0</code>？这个<em class="mu">似乎</em>打破了我们的规则，即如果一个表达式也是一个值，JavaScript将把相同的值返回给我们。这是怎么回事？最简单和最容易的答案是，尽管JavaScript解释器确实返回了那个值，但是在屏幕上显示它是另一回事。<code class="fe nq nr ns ni b">[Function]</code>是编写Node.js的人做出的选择，node . js是托管JavaScript REPL的JavaScript环境。如果你在浏览器中尝试同样的东西，你可能会看到别的东西。</p><p id="bdff" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我更喜欢其他的东西，但是我必须承认，在屏幕上输入给我们的东西是任意的，真正重要的是它对人类阅读有些用处。但我们必须明白，无论我们看到的是<code class="fe nq nr ns ni b">[Function]</code>还是<code class="fe nq nr ns ni b">() =&gt; 0</code>，JavaScript内部都有一个完整而恰当的功能。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="4709" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">功能和身份</h2><p id="7574" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">你还记得，我们有两种关于身份的值:值类型和引用类型。如果值类型具有相同的内容，则它们共享相同的标识。引用类型没有。</p><p id="f180" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">哪一种是函数？让我们试试看。出于安抚JavaScript解析器的原因，我们将函数括在括号中:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="c092" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->0)<!-- --> <!-- -->===<!-- --> <!-- -->(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->0)<!-- -->   <br/>//=&gt; false</span></pre><p id="cce4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">像数组一样，每次你计算一个表达式来产生一个函数，你会得到一个新的函数，这个函数与其他任何函数都不相同，即使你使用相同的表达式来产生它。“函数”是一种引用类型。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="9c03" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">应用函数</h2><p id="d515" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">让我们让函数发挥作用。我们使用函数的方式是<em class="mu">将</em>它们应用于零个或多个值，称为<em class="mu">参数</em>。正如<code class="fe nq nr ns ni b">2 + 2</code>产生一个值(在本例中是<code class="fe nq nr ns ni b">4</code>)一样，将一个函数应用于零个或多个参数也会产生一个值。</p><p id="da48" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">下面是我们如何在JavaScript中将一个函数应用于一些值:假设<em class="mu"> fn_expr </em>是一个表达式，当它被求值时，产生一个函数。让我们把这些参数叫做<em class="mu"> args </em>。以下是如何将函数应用于一些参数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="6be8" class="mv ls iu ni b gz nm nn l no np"><em class="mu">fn_expr</em>(<em class="mu">args</em>)</span></pre><p id="d46a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在，我们只知道一个这样的表达:<code class="fe nq nr ns ni b">() =&gt; 0</code>，所以让我们使用它。我们将把它放在括号中，让解析器满意，就像我们上面做的一样:<code class="fe nq nr ns ni b">(() =&gt; 0)</code>。因为我们没有给它任何参数，我们将简单地在表达式后面写<code class="fe nq nr ns ni b">()</code>。所以我们写道:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="dd59" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->0)()<!-- -->   <br/>//=&gt; 0</span></pre></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="dcfc" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">返回值和计算表达式的函数</h2><p id="b7da" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">我们看过<code class="fe nq nr ns ni b">() =&gt; 0</code>。我们知道<code class="fe nq nr ns ni b">(() =&gt; 0)()</code>返回<code class="fe nq nr ns ni b">0</code>，这并不奇怪。同样，以下这些都应该是显而易见的:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="108a" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->1)()<!-- -->   <br/>//=&gt; 1<!-- --> </span><span id="066e" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->"Hello, JavaScript")()<!-- -->   <br/>//=&gt; "Hello, JavaScript"<!-- --> </span><span id="6a2c" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->Infinity)()<!-- -->   <br/>//=&gt; Infinity</span></pre><p id="abee" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">好吧，最后一个很棒，但是总的想法是这样的:我们可以通过把值放在箭头的右边来创建一个返回值的函数。</p><p id="c33d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在前奏中，我们看了表情。像<code class="fe nq nr ns ni b">0</code>这样的值是表达式，像<code class="fe nq nr ns ni b">40 + 2</code>这样的东西也是表达式。我们能在箭头的右边放一个表达式吗？</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="c77a" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->1)()<!-- -->   <br/>//=&gt; 2<!-- --> </span><span id="d9c8" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->"Hello, "<!-- --> <!-- -->+<!-- --> <!-- -->"JavaScript")()<!-- -->   <br/>//=&gt; "Hello, JavaScript"<!-- --> </span><span id="1407" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->Infinity<!-- --> <!-- -->*<!-- --> <!-- -->Infinity)()<!-- -->   <br/>//=&gt; Infinity</span></pre><p id="281c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">是的，我们可以。我们可以把任何表达式放在箭头的右边。比如<code class="fe nq nr ns ni b">(() =&gt; 0)()</code>就是一个表达式。我们能不能把它放在一个箭头的右边，像这样:<code class="fe nq nr ns ni b">() =&gt; (() =&gt; 0)()</code>？</p><p id="06e7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们来试试:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="5b69" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->0)())()<!-- -->   <br/>//=&gt; 0</span></pre><p id="a539" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">是的，我们可以！函数可以返回评估另一个函数的值。</p><p id="c067" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当处理有许多相同字符的表达式(如括号)时，您可能会发现格式化代码会有所帮助，使事情突出。所以我们也可以写:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="cec5" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<br/>    <!-- -->(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->0<br/>      <!-- -->)()<br/>)()<br/>//=&gt; 0</span></pre><p id="7ff6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">它评估为相同的东西，<code class="fe nq nr ns ni b">0</code>。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="4764" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">逗号</h2><p id="09dd" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">JavaScript中的逗号操作符很有趣。它接受两个参数，对这两个参数求值，然后自己计算右边参数的值。换句话说:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2fc3" class="mv ls iu ni b gz nm nn l no np">(1,<!-- --> <!-- -->2)<!-- -->   <br/>//=&gt; 2<!-- -->  </span><span id="0039" class="mv ls iu ni b gz nt nn l no np">(1<!-- --> <!-- -->+<!-- --> <!-- -->1,<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2)<!-- -->   <br/>//=&gt; 4</span></pre><p id="041e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以在函数中使用逗号来创建计算多个表达式的函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="f78e" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(1<!-- --> <!-- -->+<!-- --> <!-- -->1,<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2))()<!-- -->   <br/>//=&gt; 4</span></pre><p id="94f4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这在尝试做可能涉及<em class="mu">副作用</em>的事情时很有用，但我们稍后会讲到。在大多数情况下，JavaScript并不关心事物是否由空格、制表符或换行符分隔。所以我们也可以写:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="ff17" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- -->   <br/>    <!-- -->(1<!-- --> <!-- -->+<!-- --> <!-- -->1,<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2)</span></pre><p id="a014" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">或者甚至:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2726" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(<!-- -->     <br/>        <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->1,<!-- -->     <br/>        <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- -->   <br/>)</span></pre></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="5ecb" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">最简单的块</h2><p id="5873" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">还有一个东西我们可以放在箭头的右边，一个<em class="mu">块</em>。一个块有零个或多个用分号分隔的<em class="mu">语句</em>。</p><p id="3dfa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">所以，这是一个有效的函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="3678" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{}</span></pre><p id="d889" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">它返回评估没有语句的块的结果。那会是什么？让我们来试试:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="a7b4" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{})()<!-- -->   <br/>//=&gt; undefined</span></pre><p id="9bea" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是什么<code class="fe nq nr ns ni b">undefined</code>？</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="7448" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated"><code class="fe nq nr ns ni b">undefined</code></h2><p id="dba4" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">在JavaScript中，缺少值被写成<code class="fe nq nr ns ni b">undefined</code>，它的意思是没有值。它会再次出现。<code class="fe nq nr ns ni b">undefined</code>是它自己的值类型，它的行为类似于值类型:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9a52" class="mv ls iu ni b gz nm nn l no np">undefined<!-- -->   <br/>//=&gt; undefined</span></pre><p id="0bb3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">像数字、布尔值和字符串一样，JavaScript可以打印出值<code class="fe nq nr ns ni b">undefined</code>。</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="00c3" class="mv ls iu ni b gz nm nn l no np">undefined<!-- --> <!-- -->===<!-- --> <!-- -->undefined<!-- -->   <br/>//=&gt; true<!-- --> </span><span id="15a5" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{})()<!-- --> <!-- -->===<!-- --> <!-- -->(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{})()<!-- -->   <br/>//=&gt; true<!-- --> </span><span id="e761" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{})()<!-- --> <!-- -->===<!-- --> <!-- -->undefined<!-- -->   <br/>//=&gt; true</span></pre><p id="318b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">无论你如何评价<code class="fe nq nr ns ni b">undefined</code>，你都会得到一个相同的值。<code class="fe nq nr ns ni b">undefined</code>是一个值，表示“我没有值”但它仍然是一个值:-)</p><p id="9c56" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">你可能认为JavaScript中的<code class="fe nq nr ns ni b">undefined</code>相当于SQL中的<code class="fe nq nr ns ni b">NULL</code>。不会。在SQL中，两个为<code class="fe nq nr ns ni b">NULL</code>的事物不等于也不共享同一个恒等式，因为两个未知数不可能相等。在JavaScript中，每个<code class="fe nq nr ns ni b">undefined</code>都与其他<code class="fe nq nr ns ni b">undefined</code>相同。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="c29f" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">空的</h2><p id="8fa9" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">我们已经看到JavaScript通过键入<code class="fe nq nr ns ni b">undefined</code>来表示一个未定义的值，我们已经以两种方式生成了未定义的值:</p><ol class=""><li id="ac75" class="oa ob iu ke b kf kg kj kk kn oc kr od kv oe kz of og oh oi bi translated">通过评估不返回值<code class="fe nq nr ns ni b">(() =&gt; {})()</code>的函数，以及；</li><li id="94d7" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">靠自己写作<code class="fe nq nr ns ni b">undefined</code>。</li></ol><p id="72f3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">还有第三种方法，使用JavaScript的<code class="fe nq nr ns ni b">void</code>操作符。请看:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="30c7" class="mv ls iu ni b gz nm nn l no np">void<!-- --> <!-- -->0<!-- -->   <br/>//=&gt; undefined<!-- --> </span><span id="d1e3" class="mv ls iu ni b gz nt nn l no np">void<!-- --> <!-- -->1<!-- -->   <br/>//=&gt; undefined<!-- --> </span><span id="c4e0" class="mv ls iu ni b gz nt nn l no np">void<!-- --> <!-- -->(2<!-- --> <!-- -->+<!-- --> <!-- -->2)<!-- -->   <br/>//=&gt; undefined</span></pre><p id="541b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">void</code>是一个取任意值并计算为<code class="fe nq nr ns ni b">undefined</code>的运算符，始终。那么，当我们故意想要一个未定义的值时，我们应该使用第一、第二还是第三种形式呢？答案是，用<code class="fe nq nr ns ni b">void</code>。按照惯例，使用<code class="fe nq nr ns ni b">void 0</code>。</p><p id="b07a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">第一种形式可行，但很麻烦。第二种形式在大多数情况下是有效的，但是通过将<code class="fe nq nr ns ni b">undefined</code>重新赋值给一个不同的值也可以打破它。第三种形式保证总是有效，所以我们将使用这种形式。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="a1a8" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">回到街区</h2><p id="1aea" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">回到我们的函数。我们对此进行了评估:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9d93" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{})()<!-- -->   <br/>//=&gt; undefined</span></pre><p id="c732" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们说过函数返回评估一个<em class="mu">块</em>的结果，我们说过块是由分号分隔的JavaScript <em class="mu">语句</em>的列表(可能是空的)。</p><p id="0211" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">类似于:<code class="fe nq nr ns ni b">{</code>声明1 <code class="fe nq nr ns ni b">;</code>声明2 <code class="fe nq nr ns ni b">;</code>声明3 <code class="fe nq nr ns ni b">; ... ;</code>声明n <code class="fe nq nr ns ni b">}</code></p><p id="80c6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们还没有讨论这些<em class="mu">语句</em>。什么是声明？</p><p id="3906" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">JavaScript语句有很多种，但第一种是我们已经见过的。表达式是一个JavaScript语句。尽管它们不太实用，但它们是有效的JavaScript函数，应用时会返回<code class="fe nq nr ns ni b">undefined</code>:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="155d" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- --> <!-- -->}<!-- --> </span><span id="a802" class="mv ls iu ni b gz nt nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->1;<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- --> <!-- -->}</span></pre><p id="ddd6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">正如我们在上面用逗号看到的，当我们觉得这样更易读时，我们可以将这些函数重新安排到多行中:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b5d0" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->     <br/>        <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->1;<!-- -->     <br/>        <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- -->   <br/>}</span></pre><p id="2f83" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是无论我们如何排列它们，一个包含一个或多个表达式的块仍然计算为<code class="fe nq nr ns ni b">undefined</code>:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="aa29" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- --> <!-- -->})()<!-- -->   <br/>//=&gt; undefined<!-- -->    </span><span id="fe61" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->1;<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- --> <!-- -->})()<!-- -->   <br/>//=&gt; undefined<!-- -->    </span><span id="13f8" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->     <br/>         <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->1;<!-- -->     <br/>         <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- -->   <br/>})()<!-- -->   <br/>//=&gt; undefined</span></pre><p id="0cbc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如您所见，包含一个表达式的块的行为不像表达式，包含多个表达式的块的行为不像用逗号运算符构造的表达式:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="94e3" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2)()<!-- -->   <br/>//=&gt; 4<!-- --> </span><span id="9b1b" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- --> <!-- -->})()<!-- -->   <br/>//=&gt; undefined<!-- -->    </span><span id="091e" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(1<!-- --> <!-- -->+<!-- --> <!-- -->1,<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2))()<!-- -->   <br/>//=&gt; 4<!-- --> </span><span id="7314" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->1;<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- --> <!-- -->})()<!-- -->   <br/>//=&gt; undefined</span></pre><p id="0651" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">那么，我们如何获得一个函数来评估一个应用时返回值的块呢？用<code class="fe nq nr ns ni b">return</code>关键字和任意表达式:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="0725" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->return<!-- --> <!-- -->0<!-- --> <!-- -->})()<!-- -->   <br/>//=&gt; 0<!-- -->    </span><span id="4574" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->return<!-- --> <!-- -->1<!-- --> <!-- -->})()<!-- -->   <br/>//=&gt; 1<!-- -->    </span><span id="ace7" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->return<!-- --> <!-- -->'Hello '<!-- --> <!-- -->+<!-- --> <!-- -->'World'<!-- --> <!-- -->})()<!-- -->   <br/>// 'Hello World'</span></pre><p id="ab0d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">return</code>关键字创建一个<em class="mu">返回语句</em>，该语句立即终止函数应用程序并返回其表达式求值的结果。例如:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="1fd8" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->     <br/>         <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->1;<!-- -->     <br/>         <!-- -->return<!-- --> <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- -->   <br/>})()<!-- -->   <br/>//=&gt; 4</span></pre><p id="3f83" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">此外:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="1a61" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->     <br/>         <!-- -->return<!-- --> <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->1;<!-- -->     <br/>         <!-- -->2<!-- --> <!-- -->+<!-- --> <!-- -->2<!-- -->   <br/>})()<!-- -->   <br/>//=&gt; 2</span></pre><p id="239a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">return语句是我们看到的第一个语句，它的行为与表达式不同。例如，您不能在简单函数中将one用作表达式，因为它不是表达式:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="5c92" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->return<!-- --> <!-- -->0)()<!-- -->   <br/>//=&gt; ERROR</span></pre><p id="a624" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">语句属于块内部，并且只属于块内部。一些语言通过将一切都变成表达式来简化这一点，但是JavaScript保持了这种区别，所以在学习JavaScript时，我们还学习了像函数声明、for循环、if语句等语句。稍后我们会看到更多这样的例子。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="f412" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">评估为函数的函数</h2><p id="321b" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">如果计算结果为函数的表达式是一个表达式，如果return语句的右边可以有任何表达式… <em class="mu">我们可以把计算结果为函数的表达式放在函数表达式的右边吗？</em></p><p id="9f79" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">是:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="f8e9" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->0</span></pre><p id="ab58" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">那是功能！它是一个函数，当被应用时，计算为一个函数，当被应用时，计算为<code class="fe nq nr ns ni b">0</code>。所以我们有一个函数，它返回一个函数，返回零。同样:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="737b" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->true</span></pre><p id="3e02" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">那是一个函数，返回一个函数，返回<code class="fe nq nr ns ni b">true</code>:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b372" class="mv ls iu ni b gz nm nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->true)()()<!-- -->   <br/>//=&gt; true</span></pre><p id="f455" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当然，如果我们愿意，我们可以用积木做同样的事情:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="8869" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- --> <!-- -->return<!-- --> <!-- -->true;<!-- --> <!-- -->}</span></pre><p id="c3ee" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但我们一般不会。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><p id="96dd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">好吧。我们很聪明，但是到目前为止，这一切似乎都很抽象。</p><p id="0660" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">晶体的衍射本身是美丽而有趣的，但你不能责怪我们想要展示它的实际用途，就像能够确定数百万光年以外的恒星的成分一样。所以…在下一节，我们将看到如何使功能变得实用。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="481b" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">啊。我想争论一下。</h1><p id="c494" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">到目前为止，我们已经看了没有参数的函数。我们甚至还没有说什么是参数<em class="mu">什么是</em>，只说我们的函数没有任何参数。</p><p id="0881" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">大多数程序员都非常熟悉实参(通常称为“参数”)。中学数学讨论这个。所以你知道它们是什么，我也知道你知道它们是什么，但是请耐心等待解释！</p><p id="020f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们来做一个带自变量的函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="27cb" class="mv ls iu ni b gz nm nn l no np">(room)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{}</span></pre><p id="a0c7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个函数有一个参数，<code class="fe nq nr ns ni b">room</code>，和一个空体。下面是一个有两个参数和一个空体的函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="c80b" class="mv ls iu ni b gz nm nn l no np">(room,<!-- --> <!-- -->board)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{}</span></pre><p id="eab8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我相信你对这个函数有两个参数<code class="fe nq nr ns ni b">room</code>和<code class="fe nq nr ns ni b">board</code>的想法非常满意。一个人对这些论点做了什么？当然是用在身体上。你认为这是什么？</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="6740" class="mv ls iu ni b gz nm nn l no np">(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->3.14159265</span></pre><p id="03eb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是一个在给定直径的情况下计算圆周的函数。我大声读出来是“当应用于代表直径的值时，这个函数<em class="mu">返回</em>直径乘以3.14159265。”</p><p id="d817" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">记住，为了应用一个没有参数的函数，我们编写了<code class="fe nq nr ns ni b">(() =&gt; {})()</code>。要应用带有一个参数(或多个参数)的函数，我们将参数(或多个参数)放在括号内，如下所示:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="58fb" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->3.14159265)(2)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="70e9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">看到如何编写一个函数并将其应用于两个参数，您不会感到惊讶:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="8d7e" class="mv ls iu ni b gz nm nn l no np">((room,<!-- --> <!-- -->board)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->room<!-- --> <!-- -->+<!-- --> <!-- -->board)(800,<!-- --> <!-- -->150)<!-- -->   <br/>//=&gt; 950</span></pre></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="15f3" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">函数和主体的快速总结</h2><p id="f41f" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">从例子中，参数在主体表达式中是如何使用的对你来说可能是非常明显的，特别是如果你使用过任何编程语言(除了BASIC的方言——我记得在我的中学时代——当你调用一个过程时，它不允许参数)。</p><p id="ef12" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">表达式由值的表示(如<code class="fe nq nr ns ni b">3.14159265</code>、<code class="fe nq nr ns ni b">true</code>和<code class="fe nq nr ns ni b">undefined</code>)、组合表达式的操作符(如<code class="fe nq nr ns ni b">3 + 2</code>)、一些特殊形式(如用于从表达式创建数组的<code class="fe nq nr ns ni b">[1, 2, 3]</code>)或用于创建函数的<code class="fe nq nr ns ni b">function (</code> <em class="mu">参数</em> <code class="fe nq nr ns ni b">) {</code> <em class="mu">主体语句</em> <code class="fe nq nr ns ni b">}</code>组成。</p><p id="c571" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一个重要的可能语句是return语句。return语句接受任何有效的JavaScript表达式。</p><p id="be23" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这种松散的定义是递归的，所以我们可以凭直觉(或者利用我们对其他语言的经验)认为，既然一个函数可以包含一个带有表达式的return语句，我们就可以编写一个返回函数的函数，或者一个包含另一个数组表达式的数组。或者返回数组的函数、函数数组、返回函数数组的函数等等:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b4bf" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{};<!-- -->  </span><span id="ebde" class="mv ls iu ni b gz nt nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->[<!-- --> <!-- -->1,<!-- --> <!-- -->2,<!-- --> <!-- -->3];<!-- -->  </span><span id="32a3" class="mv ls iu ni b gz nt nn l no np">[1,<!-- --> <!-- -->[2,<!-- --> <!-- -->3],<!-- --> <!-- -->4];<!-- -->  </span><span id="5279" class="mv ls iu ni b gz nt nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->[<!-- -->     <br/>        <!-- -->()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->1,<!-- -->     <br/>        <!-- -->()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->2,<!-- -->     <br/>        <!-- -->()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->3<!-- -->   <br/>];</span></pre></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="36dd" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">按值调用</h2><p id="36d6" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">像大多数当代编程语言一样，JavaScript使用“按值调用”的评估策略。这意味着，当您编写一些代码来将函数应用于一个或多个表达式时，JavaScript会计算所有这些表达式，并将函数应用于结果值。</p><p id="5a6f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">所以当你写下:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="d38b" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->3.14159265)(1<!-- --> <!-- -->+<!-- --> <!-- -->1)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="93fc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">内部发生的是表达式<code class="fe nq nr ns ni b">1 + 1</code>先求值，结果产生了<code class="fe nq nr ns ni b">2</code>。然后我们的圆周函数应用到了<code class="fe nq nr ns ni b">2</code>。</p><p id="2b2f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们将在下面看到，虽然JavaScript总是通过值来调用，但是“值”的概念有额外的微妙之处。但在此之前，我们先来看看变量。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="382d" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">变量和绑定</h2><p id="ada5" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">现在一切看起来简单明了，我们可以继续更详细地讨论论点。我们将从<code class="fe nq nr ns ni b">(diameter) =&gt; diameter * 3.14159265</code>逐步提升到如下功能:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9426" class="mv ls iu ni b gz nm nn l no np">(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x</span></pre><p id="c556" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">(x) =&gt; (y) =&gt; x</code>看起来很疯狂，就好像我们正在把英语作为第二语言来学习，老师承诺我们很快就会使用像<em class="mu">反既定主义</em>这样的词。除了希望使用长词来让人印象深刻之外，除非我们发现自己想要讨论英格兰教会在19世纪英国政治中的作用，否则这不会看起来有吸引力。</p><p id="9beb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是学习单词<em class="mu">反体制主义</em>还有另一个原因:我们可以学习前缀和后缀在英语语法中是如何工作的。跟<code class="fe nq nr ns ni b">(x) =&gt; (y) =&gt; x</code>是一回事。它本身就有一定的重要意义，而且它也是学习函数、环境、变量等等的绝佳借口。</p><p id="564b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了讨论这是如何工作的，我们应该就几个术语达成一致(您可能已经知道它们，但是让我们一起检查并“同步我们的字典”)。第一个<code class="fe nq nr ns ni b">x</code>，也就是<code class="fe nq nr ns ni b">(x) =&gt; ...</code>里的那个，是一个<em class="mu">论证</em>。<code class="fe nq nr ns ni b">function (y) ...</code>中的<code class="fe nq nr ns ni b">y</code>是另一种说法。第二个<code class="fe nq nr ns ni b">x</code>，即<code class="fe nq nr ns ni b">=&gt; x</code>中的那个，不是参数，<em class="mu">是引用变量</em>的表达式。无论我们谈论的是<code class="fe nq nr ns ni b">(x) =&gt; (y) =&gt; x</code>还是简单的<code class="fe nq nr ns ni b">(x) =&gt; x</code>，参数和变量的工作方式都是一样的。</p><p id="faa0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">每次调用一个函数(“被调用”意味着“应用于零个或多个参数”)，都会创建一个新的<em class="mu">环境</em>。环境是一个(可能是空的)字典，它通过名称将变量映射到值。我们称之为“变量”的表达式中的<code class="fe nq nr ns ni b">x</code>本身就是一个通过在环境中查找值来计算的表达式。</p><p id="69b6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">价值是如何进入环境的？对于论点来说，这很简单。当您将函数应用于参数时，字典中会为每个参数放置一个条目。所以当我们写下:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="f247" class="mv ls iu ni b gz nm nn l no np">((x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x)(2)<!-- -->   <br/>//=&gt; 2</span></pre><p id="632e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">事情是这样的:</p><ol class=""><li id="3e01" class="oa ob iu ke b kf kg kj kk kn oc kr od kv oe kz of og oh oi bi translated">JavaScript将这一切解析为由几个子表达式组成的表达式。</li><li id="398c" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">然后，它开始计算表达式，包括计算子表达式</li><li id="0970" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">一个子表达式，<code class="fe nq nr ns ni b">(x) =&gt; x</code>计算出一个函数。</li><li id="0260" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">另一个是<code class="fe nq nr ns ni b">2</code>，计算结果是数字2。</li><li id="9bd7" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">JavaScript现在评估对参数<code class="fe nq nr ns ni b">2</code>应用函数。有趣的地方就在这里…</li><li id="e158" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">创造了一个环境。</li><li id="d952" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">值“2”绑定到环境中的名称“x”。</li><li id="d209" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">表达式“x”(函数的右侧)在我们刚刚创建的环境中进行计算。</li><li id="b7e8" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">在一个环境中评估时，变量值是绑定到该环境中变量名的值，即“2”</li><li id="a107" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">这就是我们的结果。</li></ol><p id="e62c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当我们谈论环境时，我们将使用一个<a class="ae la" href="http://json.org/" rel="noopener ugc nofollow" target="_blank">不令人惊讶的语法</a>来显示它们的绑定:<code class="fe nq nr ns ni b">{x: 2, ...}</code>。也就是说，环境是一个字典，值<code class="fe nq nr ns ni b">2</code>与名字<code class="fe nq nr ns ni b">x</code>绑定在一起，字典中可能还有我们现在没有讨论的其他内容。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="651c" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">通过共享呼叫</h2><p id="a754" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">前面，我们区分了JavaScript的<em class="mu">值类型</em>和它的<em class="mu">引用类型</em>。当时，我们研究了JavaScript如何区分相同和不同的对象。现在是时候再看一看值类型和引用类型之间的区别了。</p><p id="8478" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">JavaScript严格维护一个属性:当一个值——任何值——作为参数传递给函数时，函数环境中绑定的值必须与原始值相同。</p><p id="c89d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们说了JavaScript将名称绑定到值，但是没有说将名称绑定到值是什么意思。现在我们可以详细说明:当JavaScript将值类型绑定到名称时，它会制作该值的副本，并将副本放在环境中。正如您所回忆的那样，如果字符串和数字等值类型具有相同的内容，则它们是相同的。因此JavaScript可以随心所欲地复制任意多的字符串、数字或布尔值。</p><p id="c069" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">引用类型呢？JavaScript不会在任何环境中放置引用值的副本。JavaScript将<em class="mu">引用</em>放在环境中引用类型，当需要使用该值时，JavaScript使用该引用获取原始值。</p><p id="5302" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因为许多引用可以共享同一个值，又因为JavaScript将引用作为参数传递，所以可以说JavaScript实现了“通过共享调用”语义。通过共享调用通常被理解为通过值调用的专门化，它解释了为什么一些值被称为值类型，而另一些值被称为引用类型。</p><p id="19d4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">至此，我们已经准备好来看看<em class="mu">闭包</em>。当我们结合我们关于值类型、引用类型、参数和闭包的知识时，我们将理解为什么这个函数总是计算为<code class="fe nq nr ns ni b">true</code>,不管你将它应用于什么参数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="808d" class="mv ls iu ni b gz nm nn l no np">(value)<!-- --> <!-- -->=&gt;<!-- -->   <!-- -->((ref1,<!-- --> <!-- -->ref2)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->ref1<!-- --> <!-- -->===<!-- --> <!-- -->ref2)(value,<!-- --> <!-- -->value)</span></pre></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="b8b6" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">闭包和范围</h1><p id="9b7c" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">是时候看看函数中的函数是如何工作的了:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="75b6" class="mv ls iu ni b gz nm nn l no np">((x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x)(1)(2)<!-- -->   <br/>//=&gt; 1</span></pre><p id="6e70" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">首先，让我们用我们在上面学到的东西。给定<code class="fe nq nr ns ni b">(</code> <em class="mu">某函数</em> <code class="fe nq nr ns ni b">)(</code> <em class="mu">某自变量</em> <code class="fe nq nr ns ni b">)</code>，我们知道我们将函数应用于自变量，创建一个环境，将自变量的值绑定到名称，并对函数的表达式求值。所以我们先用这段代码:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b136" class="mv ls iu ni b gz nm nn l no np">((x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x)(1)<!-- -->   <br/>//=&gt; [Function]</span></pre><p id="f5cb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">属于签名为<code class="fe nq nr ns ni b">(x) =&gt; ...</code>的函数的环境变成了<code class="fe nq nr ns ni b">{x: 1, ...}</code>，应用该函数的结果是另一个函数值。结果值是一个函数是有意义的，因为<code class="fe nq nr ns ni b">(x) =&gt; ...</code>身体的表达式是:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b0c9" class="mv ls iu ni b gz nm nn l no np">(y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x</span></pre><p id="d9a5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在我们有了一个代表这个函数的值。然后我们将获取该函数的值，并将其应用于参数<code class="fe nq nr ns ni b">2</code>，就像这样:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="cef5" class="mv ls iu ni b gz nm nn l no np">((y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x)(2)</span></pre><p id="a8e8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">所以我们似乎得到了一个新的环境<code class="fe nq nr ns ni b">{y: 2, ...}</code>。在这个函数的环境中，表达式<code class="fe nq nr ns ni b">x</code>将如何被求值？它的环境里没有<code class="fe nq nr ns ni b">x</code>，它一定是来自别的地方。</p><p id="85ad" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">顺便说一下，这是JavaScript和同一家族中的语言的一个重要的定义特征:它们是否允许像函数这样的东西嵌套在彼此内部，如果是，它们如何处理在函数内部引用的来自函数“外部”的变量。例如，下面是Ruby中的等价代码:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="5e51" class="mv ls iu ni b gz nm nn l no np">lambda<!-- --> <!-- -->{<!-- --> <!-- -->|x|<!-- -->   <!-- -->lambda<!-- --> <!-- -->{<!-- --> <!-- -->|y|<!-- --> <!-- -->x<!-- --> <!-- -->}<!-- --> <!-- -->}[1][2]<!-- -->   <br/>#=&gt; 1</span></pre></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="2b75" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">如果没有自由变量的函数是纯的，闭包是不纯的吗？</h2><p id="f74e" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">函数<code class="fe nq nr ns ni b">(y) =&gt; x</code>很有意思。它包含一个<em class="mu">自由变量</em>，<code class="fe nq nr ns ni b">x</code>。自由变量是指不在函数内的变量。到目前为止，我们只看到了一种“绑定”变量的方法，即传入一个同名的参数。由于函数<code class="fe nq nr ns ni b">(y) =&gt; x</code>没有名为<code class="fe nq nr ns ni b">x</code>的参数，变量<code class="fe nq nr ns ni b">x</code>没有被绑定在这个函数中，这使得它是“自由的”</p><p id="781c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在我们知道了函数中使用的变量要么是有界的，要么是自由的，我们可以将函数分为有自由变量的函数和没有自由变量的函数:</p><ul class=""><li id="4c4f" class="oa ob iu ke b kf kg kj kk kn oc kr od kv oe kz oo og oh oi bi translated">不含自由变量的函数称为<em class="mu">纯函数</em>。</li><li id="b4a9" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz oo og oh oi bi translated">包含一个或多个自由变量的函数被称为<em class="mu">闭包</em>。</li></ul><p id="00b2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">纯函数最容易理解。无论你在哪里使用它们，它们的意思总是一样的。下面是一些我们已经见过的纯函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="edcd" class="mv ls iu ni b gz nm nn l no np">()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{}<!-- -->  <br/>(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x<!-- -->    <br/>(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x</span></pre><p id="05b8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">第一个函数没有任何变量，因此没有任何自由变量。第二个没有任何自由变量，因为它唯一的变量是绑定的。第三个实际上是两个函数，一个在另一个里面。<code class="fe nq nr ns ni b">(y) =&gt; ...</code>有自由变量，但是整个表达式引用的是<code class="fe nq nr ns ni b">(x) =&gt; ...</code>，它没有自由变量:它体内任何地方唯一的变量是<code class="fe nq nr ns ni b">x</code>，当然是绑定在<code class="fe nq nr ns ni b">(x) =&gt; ...</code>内的。</p><p id="a073" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">由此，我们学到了一些东西:一个纯函数可以包含一个闭包。</p><p id="ccc9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果纯函数可以包含闭包，那么闭包可以包含纯函数吗？仅使用我们目前所学的知识，尝试构建一个包含纯函数的闭包。如果不能，给出为什么不可能的理由。</p><p id="dae9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">纯函数总是意味着同样的事情，因为它们的所有“输入”都完全由它们的参数定义。结束时就不是这样了。如果我向你展示这个纯函数<code class="fe nq nr ns ni b">(x, y) =&gt; x + y</code>，我们就知道它和<code class="fe nq nr ns ni b">(2, 2)</code>有什么关系。但是这个关闭:<code class="fe nq nr ns ni b">(y) =&gt; x + y</code>呢？在不理解计算自由变量<code class="fe nq nr ns ni b">x</code>的魔力的情况下，我们不能说它将如何处理自变量<code class="fe nq nr ns ni b">(2)</code>。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="4761" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">总是环境的问题</h2><p id="18f3" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">为了理解闭包是如何被评估的，我们需要重新考察环境。正如我们之前说过的，所有的功能都与环境相关联。当描述我们的环境时，我们也挥舞着一些东西。还记得我们说过<code class="fe nq nr ns ni b">((x) =&gt; (y) =&gt; x)(1)</code>的环境是<code class="fe nq nr ns ni b">{x: 1, ...}</code>而<code class="fe nq nr ns ni b">((y) =&gt; x)(2)</code>的环境是<code class="fe nq nr ns ni b">{y: 2, ...}</code>吗？让我们来填空吧！</p><p id="55ab" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">((y) =&gt; x)(2)</code>的环境实际上是<em class="mu"/><code class="fe nq nr ns ni b">{y: 2, '..': {x: 1, ...}}</code>。<code class="fe nq nr ns ni b">'..'</code>表示类似“父母”、“圈地”或“超环境”的东西是<code class="fe nq nr ns ni b">(x) =&gt; ...</code>的环境，因为功能<code class="fe nq nr ns ni b">(y) =&gt; x</code>在<code class="fe nq nr ns ni b">(x) =&gt; ...</code>的体内。因此，每当函数应用于参数时，它的环境总是有一个对其父环境的引用。</p><p id="61bd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在你可以猜到我们在环境<code class="fe nq nr ns ni b">{y: 2, '..': {x: 1, ...}}</code>中如何评价<code class="fe nq nr ns ni b">((y) =&gt; x)(2)</code>。变量<code class="fe nq nr ns ni b">x</code>不在<code class="fe nq nr ns ni b">(y) =&gt; ...</code>的直接环境中，但在它的父环境中，所以它的计算结果为<code class="fe nq nr ns ni b">1</code>，这就是<code class="fe nq nr ns ni b">((y) =&gt; x)(2)</code>返回的结果，即使它最终忽略了自己的参数。</p><p id="8887" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">(x) =&gt; x</code>被称为I组合子，或<em class="mu">恒等函数</em>。<code class="fe nq nr ns ni b">(x) =&gt; (y) =&gt; x</code>被称为K组合子，或<em class="mu">红隼</em>。一些人对此非常兴奋，以至于他们写了关于他们的整本书，一些人是伟大的T21，一些人——我该怎么说呢——是有趣的，如果你使用Ruby的话。</p><p id="c83d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">函数也可以有祖父母:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2a9c" class="mv ls iu ni b gz nm nn l no np">(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(z)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x<!-- --> <!-- -->+<!-- --> <!-- -->y<!-- --> <!-- -->+<!-- --> <!-- -->z</span></pre><p id="3b01" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">该函数的功能与以下功能非常相似:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9756" class="mv ls iu ni b gz nm nn l no np">(x,<!-- --> <!-- -->y,<!-- --> <!-- -->z)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x<!-- --> <!-- -->+<!-- --> <!-- -->y<!-- --> <!-- -->+<!-- --> <!-- -->z</span></pre><p id="ec1b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">只是你用<code class="fe nq nr ns ni b">(1)(2)(3)</code>而不是<code class="fe nq nr ns ni b">(1, 2, 3)</code>来称呼它。另一个很大的不同是，你可以用<code class="fe nq nr ns ni b">(1)</code>调用它，然后得到一个函数，你可以稍后用<code class="fe nq nr ns ni b">(2)(3)</code>调用它。</p><p id="1518" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">第一个函数是<a class="ae la" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">与</a>第二个函数相匹配的结果。调用一个只有部分参数的curried函数有时被称为<a class="ae la" href="https://en.wikipedia.org/wiki/Partial_application" rel="noopener ugc nofollow" target="_blank">部分应用</a>。有些编程语言自动库里和部分求值函数，不需要手动嵌套。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="4731" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">来自模糊星球的模糊变量</h2><p id="dd91" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">当一个变量与祖先环境的变量同名时，有趣的事情发生了。考虑:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="12ba" class="mv ls iu ni b gz nm nn l no np">(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(x,<!-- --> <!-- -->y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x<!-- --> <!-- -->+<!-- --> <!-- -->y</span></pre><p id="bc32" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">函数<code class="fe nq nr ns ni b">(x, y) =&gt; x + y</code>是一个纯函数，因为它的<code class="fe nq nr ns ni b">x</code>是在自己的环境中定义的。尽管它的父节点也定义了一个<code class="fe nq nr ns ni b">x</code>，但在评估<code class="fe nq nr ns ni b">x + y</code>时，它会被忽略。JavaScript总是从函数自己的环境开始搜索绑定，然后依次搜索每个父类，直到找到一个为止。同样的道理也适用于:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="abbf" class="mv ls iu ni b gz nm nn l no np">(x)<!-- --> <!-- -->=&gt;<!-- -->   <br/>  <!-- -->(x,<!-- --> <!-- -->y)<!-- --> <!-- -->=&gt;<!-- -->     <br/>    <!-- -->(w,<!-- --> <!-- -->z)<!-- --> <!-- -->=&gt;<!-- -->       <br/>      <!-- -->(w)<!-- --> <!-- -->=&gt;<!-- -->         <br/>        <!-- -->x<!-- --> <!-- -->+<!-- --> <!-- -->y<!-- --> <!-- -->+<!-- --> <!-- -->z</span></pre><p id="45f5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在评估<code class="fe nq nr ns ni b">x + y + z</code>时，JavaScript会在曾祖父母范围内找到<code class="fe nq nr ns ni b">x</code>和<code class="fe nq nr ns ni b">y</code>，在父范围内找到<code class="fe nq nr ns ni b">z</code>。在曾曾祖父母范围内的<code class="fe nq nr ns ni b">x</code>被忽略，正如两个<code class="fe nq nr ns ni b">w</code>一样。当一个变量与一个祖先环境的绑定同名时，它被称为<em class="mu">隐藏</em>祖先。</p><p id="9caf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这往往是一件好事。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="0076" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">先有鸡还是先有蛋？</h2><p id="1f24" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">纯函数和闭包的这种行为有很多很多后果，可以用来编写软件。我们将详细探讨它们，并看看JavaScript提供的其他一些处理变量和可变状态的机制。</p><p id="f875" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但在我们这样做之前，还有最后一个问题:祖先从哪里开始？如果一个文件中没有其他代码，那么<code class="fe nq nr ns ni b">(x) =&gt; x</code>的父环境是什么？</p><p id="75d3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">JavaScript总是认为至少有一个环境是我们无法控制的:一个全局环境，其中绑定了许多有用的东西，比如充满标准函数的库。因此，当您在REPL中调用<code class="fe nq nr ns ni b">((x) =&gt; x)(1)</code>时，它的完整环境将如下所示:<code class="fe nq nr ns ni b">{x: 1, '..': </code> <em class="mu">全局环境</em> <code class="fe nq nr ns ni b">}</code>。</p><p id="e47f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有时，程序员希望避免这种情况。如果你不想让你的代码直接在全局环境中运行，你能做什么？当然是为他们创造一个环境。许多程序员选择像这样编写每个JavaScript文件:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="e290" class="mv ls iu ni b gz nm nn l no np">// top of the file<!-- --> </span><span id="e437" class="mv ls iu ni b gz nt nn l no np">(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->      <br/>  <!-- -->// ... lots of JavaScript ...<!-- -->    <br/>})();<!-- --> </span><span id="784d" class="mv ls iu ni b gz nt nn l no np">// bottom of the file</span></pre><p id="cb81" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">效果是在全局环境和你自己的函数之间插入一个新的空环境:<code class="fe nq nr ns ni b">{x: 1, '..': {'..': </code> <em class="mu">全局环境</em> <code class="fe nq nr ns ni b">}}</code>。这有助于防止程序员意外更改程序中所有代码共享的全局状态。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="f262" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">对咖啡的持续渴望</h1><p id="a751" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">到目前为止，我们真正看到的都是<em class="mu">匿名函数</em>，没有名字的函数。这与大多数其他语言的编程感觉非常不同，在其他语言中，重点是命名函数、方法和过程。命名事物是编程的一个关键部分，但是到目前为止我们所看到的都是如何命名参数。</p><p id="7f37" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在JavaScript中还有其他命名事物的方法，但是在我们学习其中一些之前，让我们看看如何使用我们已经有的东西来命名事物。让我们重温一个非常简单的例子:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="a045" class="mv ls iu ni b gz nm nn l no np">(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->3.14159265</span></pre><p id="f081" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个“3.14159265”是什么数字？<a class="ae la" href="https://en.wikipedia.org/wiki/Pi" rel="noopener ugc nofollow" target="_blank"> PI </a>，很明显。我们想给它起个名字，这样我们可以写成这样:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="1d45" class="mv ls iu ni b gz nm nn l no np">(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI</span></pre><p id="30cc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了将<code class="fe nq nr ns ni b">3.14159265</code>绑定到名称<code class="fe nq nr ns ni b">PI</code>，我们需要一个函数，将参数<code class="fe nq nr ns ni b">PI</code>应用于参数<code class="fe nq nr ns ni b">3.14159265</code>。如果我们把我们的函数表达式放在括号里，我们可以把它应用到<code class="fe nq nr ns ni b">3.14159265</code>的论点上:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="cd33" class="mv ls iu ni b gz nm nn l no np">((PI)<!-- --> <!-- -->=&gt;<!-- -->    <br/>// ????<!-- --> <br/>)(3.14159265)</span></pre><p id="f2ca" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当求值时，我们在将<code class="fe nq nr ns ni b">3.14159265</code>绑定到名字<code class="fe nq nr ns ni b">PI</code>的新函数中放什么？当然，我们的周长函数是:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="38b1" class="mv ls iu ni b gz nm nn l no np">((PI)<!-- --> <!-- -->=&gt;<!-- -->   <br/>    <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<!-- --> <br/>)(3.14159265)</span></pre><p id="e361" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">该表达式计算后返回一个计算周长的函数。这听起来很糟糕，但是仔细想想，<code class="fe nq nr ns ni b">(diameter) =&gt; diameter * 3.14159265</code>也是一个表达式，当它被求值时，返回一个计算周长的函数。我们所有的“功能”都是表达。这个有几个活动部件，仅此而已。但是我们可以像<code class="fe nq nr ns ni b">(diameter) =&gt; diameter * 3.14159265</code>一样使用。</p><p id="90f9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们来测试一下:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="527c" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->3.14159265)(2)<!-- -->   <br/>//=&gt; 6.2831853<!-- -->    </span><span id="2538" class="mv ls iu ni b gz nt nn l no np">((PI)<!-- --> <!-- -->=&gt;<!-- -->   <br/>  <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<!-- --> <br/>)(3.14159265)(2)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="ddcb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">那有效！我们可以在表达式中绑定我们想要的任何东西，方法是将它包装在一个函数中，该函数会立即用我们想要绑定的值调用。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="0e82" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">内面向外</h2><p id="b199" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">还有另一种方法，我们可以创建一个函数，将<code class="fe nq nr ns ni b">3.14159265</code>绑定到名字<code class="fe nq nr ns ni b">PI</code>，然后在表达式中使用它。我们可以通过将绑定放入我们的直径计算函数来颠倒事物，就像这样:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="ebce" class="mv ls iu ni b gz nm nn l no np">(diameter)<!-- --> <!-- -->=&gt;<!-- -->   <br/>  <!-- -->((PI)<!-- --> <!-- -->=&gt;<!-- -->     <br/>    <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI)(3.14159265)</span></pre><p id="ce1f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">它产生的结果与我们之前的直径计算函数表达式相同:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="35da" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->3.14159265)(2)<!-- -->   <br/>//=&gt; 6.2831853<!-- -->    </span><span id="bfde" class="mv ls iu ni b gz nt nn l no np">((PI)<!-- --> <!-- -->=&gt;<!-- -->   <br/>  <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<!-- --> <br/>)(3.14159265)(2)<!-- -->   <br/>//=&gt; 6.2831853<!-- -->  </span><span id="1425" class="mv ls iu ni b gz nt nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- -->   <br/>  <!-- -->((PI)<!-- --> <!-- -->=&gt;<!-- -->     <br/>   <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI)(3.14159265))(2)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="1c08" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">哪个更好？第一个似乎最简单，但是半个世纪的经验告诉我们名字很重要。像<code class="fe nq nr ns ni b">3.14159265</code>这样的“神奇文字”对于可持续软件开发来说是一种诅咒。</p><p id="e128" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">第三个对大多数人来说是最容易阅读的。它很好地分离了关注点:“外部”函数描述了它的参数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2e21" class="mv ls iu ni b gz nm nn l no np">(diameter)<!-- --> <!-- -->=&gt;<!-- -->   <!-- -->// ...</span></pre><p id="447c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">其他一切都封装在它的身体里。就应该这样，命名<code class="fe nq nr ns ni b">PI</code>是它的事，不是我们的事。另一种表述是:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="7747" class="mv ls iu ni b gz nm nn l no np">((PI)<!-- --> <!-- -->=&gt;<!-- -->   <!-- -->// ...<!-- --> <!-- -->)(3.14159265)</span></pre><p id="74c5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">先“暴露”命名<code class="fe nq nr ns ni b">PI</code>，我们要看看里面，找出我们为什么在乎。那么，我们应该一直这样写吗？</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="cb23" class="mv ls iu ni b gz nm nn l no np">(diameter)<!-- --> <!-- -->=&gt;<!-- -->   <br/>  <!-- -->((PI)<!-- --> <!-- -->=&gt;<!-- -->     <br/>    <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI)(3.14159265)</span></pre><p id="89c9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个问题的关键在于，通常情况下，调用函数比计算表达式要昂贵得多。每次我们调用外部函数，我们都会调用内部函数。我们可以通过写作来解决这个问题</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="f258" class="mv ls iu ni b gz nm nn l no np">((PI)<!-- --> <!-- -->=&gt;<!-- -->   <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<!-- --> <!-- -->)(3.14159265)</span></pre><p id="f9aa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是我们混淆了我们的代码，除非万不得已，否则我们不想这样做。</p><p id="fddf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果这种语言给了我们一种在块内绑定名字的方法，而不会导致函数调用的开销，那就太好了。而JavaScript做到了。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="8f73" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">常数</h2><p id="3319" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">编写“周长”函数的另一种方式是将<code class="fe nq nr ns ni b">PI</code>与直径参数一起传递，类似于:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="0888" class="mv ls iu ni b gz nm nn l no np">(diameter,<!-- --> <!-- -->PI)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI</span></pre><p id="30ec" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以这样使用它:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="0929" class="mv ls iu ni b gz nm nn l no np">((diameter,<!-- --> <!-- -->PI)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI)(2,<!-- --> <!-- -->3.14159265)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="2334" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这与我们上面的例子不同，因为只有一个环境，而不是两个。我们在环境中有一个绑定代表我们的常规参数，另一个是我们的“常量”这样效率更高，而且几乎是我们一直想要的:一种将<code class="fe nq nr ns ni b">3.14159265</code>绑定到可读名称的方法。</p><p id="afc6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">JavaScript为我们提供了一种方法，即<code class="fe nq nr ns ni b">const</code>关键字。在未来的章节中，我们将会学到更多关于<code class="fe nq nr ns ni b">const</code>的知识，但是这里是我们可以对<code class="fe nq nr ns ni b">const</code>做的最重要的事情:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="6a4b" class="mv ls iu ni b gz nm nn l no np">(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->   <br/>  <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3.14159265;<!-- -->    </span><span id="49bf" class="mv ls iu ni b gz nt nn l no np">  return<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<!-- --> <br/>}</span></pre><p id="113a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">const</code>关键字在封装它的块中引入了一个或多个绑定。它不会产生函数调用的成本。太好了。更好的是，它将符号(如<code class="fe nq nr ns ni b">PI</code>)放在值(<code class="fe nq nr ns ni b">3.14159265</code>)附近。这比我们写的好多了。</p><p id="b47f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们在<em class="mu">常量语句</em>中使用<code class="fe nq nr ns ni b">const</code>关键字。语句出现在块中，当我们写一个以表达式为主体的粗箭头时，我们不能使用它们。</p><p id="c08b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">它正如我们所希望的那样工作。而不是:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="7406" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- -->   <br/>  <!-- -->((PI)<!-- --> <!-- -->=&gt;<!-- -->     <br/>    <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI)(3.14159265))(2)</span></pre><p id="f49a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">或者:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9a83" class="mv ls iu ni b gz nm nn l no np">((diameter,<!-- --> <!-- -->PI)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI)(2,<!-- --> <!-- -->3.14159265)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="4813" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们写道:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b608" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->   <br/>  <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3.14159265;<!-- -->    <br/>  <br/>  <!-- -->return<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<!-- --> <br/>})(2)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="7903" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以绑定任何表达式。函数是表达式，所以我们可以绑定辅助函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="4d8f" class="mv ls iu ni b gz nm nn l no np">(d)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->   <br/>  <!-- -->const<!-- --> <!-- -->calc<!-- --> <!-- -->=<!-- --> <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->     <br/>    <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3.14159265;<!-- -->      </span><span id="182b" class="mv ls iu ni b gz nt nn l no np">    return<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<!-- -->   <br/>  <!-- -->};<br/>    <br/>  <!-- -->return<!-- --> <!-- -->"The circumference is "<!-- --> <!-- -->+<!-- --> <!-- -->calc(d)<!-- --> <br/>}</span></pre><p id="3ec6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">通知<code class="fe nq nr ns ni b">calc(d)</code>？这强调了我们所说的:如果我们有一个计算函数的表达式，我们用<code class="fe nq nr ns ni b">()</code>来应用它。绑定到函数的名称是计算函数的有效表达式。</p><p id="1102" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">令人惊讶的是如此重要的一个想法——命名函数——竟然可以用几句话顺便解释一下。这强调了JavaScript非常非常正确的一点:作为“第一类实体”的功能函数是可以像任何其他值一样绑定到名称、作为参数传递、从其他函数返回等等的值。</p><p id="6613" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以通过用逗号分隔来绑定多个名称-值对。为了提高可读性，大多数人每行使用一个绑定:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="bff2" class="mv ls iu ni b gz nm nn l no np">(d)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->   <br/>  <!-- -->const<!-- --> <!-- -->PI<!-- -->   <!-- -->=<!-- --> <!-- -->3.14159265,<!-- -->       <br/>        <!-- -->calc<!-- --> <!-- -->=<!-- --> <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI;<!-- -->    </span><span id="e0cb" class="mv ls iu ni b gz nt nn l no np">  return<!-- --> <!-- -->"The circumference is "<!-- --> <!-- -->+<!-- --> <!-- -->calc(d)<!-- --> <br/>}</span></pre></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="b6ee" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">嵌套块</h2><p id="71fd" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">到目前为止，我们只见过用作函数体的块。但是还有其他种类的块。您可以在<code class="fe nq nr ns ni b">if</code>语句中找到块。在JavaScript中，一个<code class="fe nq nr ns ni b">if</code>语句看起来像这样:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9d64" class="mv ls iu ni b gz nm nn l no np">(n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->   <br/>  <!-- -->const<!-- --> <!-- -->even<!-- --> <!-- -->=<!-- --> <!-- -->(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->     <br/>    <!-- -->if<!-- --> <!-- -->(x<!-- --> <!-- -->===<!-- --> <!-- -->0)<!-- -->       <br/>      <!-- -->return<!-- --> <!-- -->true;<!-- -->     <br/>    <!-- -->else<!-- -->       <br/>      <!-- -->return<!-- --> <!-- -->!even(x<!-- --> <!-- -->-<!-- --> <!-- -->1);<!-- -->   <br/>  <!-- -->}<!-- -->   <br/>  <!-- -->return<!-- --> <!-- -->even(n)<!-- --> <br/>}</span></pre><p id="ecc6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">它适用于相当小的数量:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="09a7" class="mv ls iu ni b gz nm nn l no np">((n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->   <br/>  <!-- -->const<!-- --> <!-- -->even<!-- --> <!-- -->=<!-- --> <!-- -->(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->     <br/>    <!-- -->if<!-- --> <!-- -->(x<!-- --> <!-- -->===<!-- --> <!-- -->0)<br/>       <!-- -->return<!-- --> <!-- -->true;<br/>    <!-- -->else<br/>       <!-- -->return<!-- --> <!-- -->!even(x<!-- --> <!-- -->-<!-- --> <!-- -->1);<br/>   <!-- -->}<br/>   <!-- -->return<!-- --> <!-- -->even(n)<!-- --> <br/>})(13)<!-- -->   <!-- -->//=&gt; false</span></pre><p id="adbc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">if</code>语句是一个语句，不是表达式(一个不幸的设计选择)，它的子句是语句或者块。所以我们也可以这样写:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="bd3b" class="mv ls iu ni b gz nm nn l no np">(n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->   <br/>  <!-- -->const<!-- --> <!-- -->even<!-- --> <!-- -->=<!-- --> <!-- -->(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<!-- -->     <br/>    <!-- -->if<!-- --> <!-- -->(x<!-- --> <!-- -->===<!-- --> <!-- -->0)<!-- -->       <br/>      <!-- -->return<!-- --> <!-- -->true;<!-- -->     <br/>    <!-- -->else<!-- --> <!-- -->{<!-- -->       <br/>      <!-- -->const<!-- --> <!-- -->odd<!-- --> <!-- -->=<!-- --> <!-- -->(y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->!even(y);<br/>      <!-- -->return<!-- --> <!-- -->odd(x<!-- --> <!-- -->-<!-- --> <!-- -->1);<!-- -->     <br/>    <!-- -->}<!-- -->   <br/>  <!-- -->}<br/>  <!-- -->return<!-- --> <!-- -->even(n)<!-- --> <br/>}</span></pre><p id="6310" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这也是可行的:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="914b" class="mv ls iu ni b gz nm nn l no np">((n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->const<!-- --> <!-- -->even<!-- --> <!-- -->=<!-- --> <!-- -->(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>     <!-- -->if<!-- --> <!-- -->(x<!-- --> <!-- -->===<!-- --> <!-- -->0)<br/>       <!-- -->return<!-- --> <!-- -->true;<br/>     <!-- -->else<!-- --> <!-- -->{<br/>       <!-- -->const<!-- --> <!-- -->odd<!-- --> <!-- -->=<!-- --> <!-- -->(y)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->!even(y);<br/>       <!-- -->return<!-- --> <!-- -->odd(x<!-- --> <!-- -->-<!-- --> <!-- -->1);<br/>     <!-- -->}<br/>   <!-- -->}<br/>   <!-- -->return<!-- --> <!-- -->even(n)<br/> <!-- -->})(42)<!-- -->   <!-- -->//=&gt; true</span></pre><p id="db64" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们使用了一个块作为<code class="fe nq nr ns ni b">else</code>子句，因为它是一个块，所以我们在其中放置了一个<code class="fe nq nr ns ni b">const</code>语句。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="555d" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">常量和词法范围</h2><p id="dd50" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">这看起来非常简单，但是如果我们想把<code class="fe nq nr ns ni b">const</code>放在任何我们喜欢的地方，我们需要理解绑定名称的一些语义。首先要问自己的是，如果我们使用<code class="fe nq nr ns ni b">const</code>将两个不同的值绑定到“相同”的名称上会发生什么？</p><p id="f6e3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们回顾并重新考虑闭包是如何工作的。如果我们使用参数将两个不同的值绑定到同一个名称会发生什么？</p><p id="d7a5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是我们直径函数的第二个公式，与一个使用生命的名字联系在一起:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b5cc" class="mv ls iu ni b gz nm nn l no np">((diameter_fn)<!-- --> <!-- -->=&gt;<br/>   <!-- -->// ...<br/>)(<br/>   <!-- -->((PI)<!-- --> <!-- -->=&gt;<br/>     <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<br/>   <!-- -->)(3.14159265)<!-- --> <!-- -->)</span></pre><p id="73c5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这有点复杂，但是它将<code class="fe nq nr ns ni b">((PI) =&gt; (diameter) =&gt; diameter * PI)(3.14159265)</code>绑定到<code class="fe nq nr ns ni b">diameter_fn</code>，并对我们省略的表达式求值。我们可以在那里使用任何表达式，并且那个表达式可以调用<code class="fe nq nr ns ni b">diameter_fn</code>。例如:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="e13c" class="mv ls iu ni b gz nm nn l no np">((diameter_fn)<!-- --> <!-- -->=&gt;<br/>   <!-- -->diameter_fn(2)<!-- --> <!-- -->)(<br/>   <!-- -->((PI)<!-- --> <!-- -->=&gt;<br/>     <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<br/>   <!-- -->)(3.14159265)<br/>)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="3729" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们从闭包一节中了解到这一点，但是即使当我们通过评估<code class="fe nq nr ns ni b">diameter_fn(2)</code>来调用<code class="fe nq nr ns ni b">diameter_fn</code>时<code class="fe nq nr ns ni b">PI</code>没有被绑定，当我们评估<code class="fe nq nr ns ni b">(diameter) =&gt; diameter * PI</code>时<code class="fe nq nr ns ni b">PI</code> <em class="mu">被</em>绑定，因此当我们评估<code class="fe nq nr ns ni b">diameter_fn</code>时，表达式<code class="fe nq nr ns ni b">diameter * PI</code>能够访问<code class="fe nq nr ns ni b">PI</code>和<code class="fe nq nr ns ni b">diameter</code>的值。</p><p id="e3f6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这被称为<a class="ae la" href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope" rel="noopener ugc nofollow" target="_blank">词法范围</a>，因为我们可以通过查看程序的源代码来发现名字被绑定在哪里。我们可以看到<code class="fe nq nr ns ni b">PI</code>被绑定在<code class="fe nq nr ns ni b">(diameter) =&gt; diameter * PI</code>周围的环境中，我们不需要知道<code class="fe nq nr ns ni b">diameter_fn</code>在哪里被调用。</p><p id="6536" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以通过故意制造“冲突”来测试这一点</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="6fb3" class="mv ls iu ni b gz nm nn l no np">((diameter_fn)<!-- --> <!-- -->=&gt;<br/>   <!-- -->((PI)<!-- --> <!-- -->=&gt;<br/>     <!-- -->diameter_fn(2)<br/>   <!-- -->)(3)<br/> <!-- -->)(<br/>   <!-- -->((PI)<!-- --> <!-- -->=&gt;<br/>     <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<br/>   <!-- -->)(3.14159265)<br/>)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="1c9f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">虽然我们在<code class="fe nq nr ns ni b">diameter_fn(2)</code>周围的环境中已经将<code class="fe nq nr ns ni b">3</code>绑定到<code class="fe nq nr ns ni b">PI</code>，但是起作用的值是<code class="fe nq nr ns ni b">3.14159265</code>，我们在<code class="fe nq nr ns ni b">PI</code>周围的环境中绑定的值(直径)直径* PI。</p><p id="402c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以从闭包的工作方式中仔细地算出这一点。<code class="fe nq nr ns ni b">const</code>也是这样工作的吗？让我们来看看:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="498b" class="mv ls iu ni b gz nm nn l no np">((diameter_fn)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3;<br/>  <!-- -->return<!-- --> <!-- -->diameter_fn(2)<br/>})(<br/>   <!-- -->(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>     <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3.14159265;<br/>     <!-- -->return<!-- --> <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<br/>   <!-- -->})()<br/>)<br/>//=&gt; 6.2831853</span></pre><p id="e847" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">是的。用<code class="fe nq nr ns ni b">const</code>将值绑定到名称就像用参数调用将值绑定到名称一样，它使用词法范围。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="4bb5" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">常量也是来自一个阴暗的星球吗？</h2><p id="a771" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">我们刚刚看到用<code class="fe nq nr ns ni b">const</code>绑定的值使用词法范围，就像用参数绑定的值一样。它们在声明它们的环境中被查找。我们知道功能创造环境。参数是在我们创建函数时声明的，因此参数绑定到我们调用函数时创建的环境是有意义的。</p><p id="d951" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是<code class="fe nq nr ns ni b">const</code>语句可以出现在块中，我们看到块可以出现在其他块中，包括函数体。那么<code class="fe nq nr ns ni b">const</code>变量的界限在哪里呢？在函数环境中？还是在与街区相对应的环境中？</p><p id="51dc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以通过制造另一场冲突来检验这一点。但是，我们不是将两个不同的变量绑定到两个不同位置的同一个名称上，而是将两个不同的值绑定到同一个名称上，但是一个环境将被另一个环境完全包围。</p><p id="bf0f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如上所述，让我们从参数开始。我们将从以下内容开始:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="3dcf" class="mv ls iu ni b gz nm nn l no np">((PI)<!-- --> <!-- -->=&gt;<br/>   <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<!-- --> <!-- -->)(3.14159265)</span></pre><p id="1cbb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">无偿地把它包在另一个生命里，这样我们就可以把<code class="fe nq nr ns ni b">PI</code>和别的东西捆绑在一起:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="f8de" class="mv ls iu ni b gz nm nn l no np">((PI)<!-- --> <!-- -->=&gt;<br/>   <!-- -->((PI)<!-- --> <!-- -->=&gt;<br/>     <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<br/>   <!-- -->)(3.14159265)<br/> <!-- -->)(3)</span></pre><p id="b2b6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这仍然会计算出一个计算直径的函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="0f63" class="mv ls iu ni b gz nm nn l no np">((PI)<!-- --> <!-- -->=&gt;<br/>   <!-- -->((PI)<!-- --> <!-- -->=&gt;<br/>     <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI<br/>   <!-- -->)(3.14159265)<br/> <!-- -->)(3)(2)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="f87a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以看到我们的<code class="fe nq nr ns ni b">diameter * PI</code>表达式在最近的父环境中使用了<code class="fe nq nr ns ni b">PI</code>的绑定。但是有一个问题:绑定<code class="fe nq nr ns ni b">3.14159265</code>到<code class="fe nq nr ns ni b">PI</code>是否以某种方式改变了“外部”环境中的绑定？让我们稍微改写一下:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="a2e7" class="mv ls iu ni b gz nm nn l no np">((PI)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->((PI)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{})(3);<br/>   <!-- -->return<!-- --> <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI;<br/> <!-- -->})(3.14159265)</span></pre><p id="5e45" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在我们将<code class="fe nq nr ns ni b">3</code>和<code class="fe nq nr ns ni b">PI</code>绑定在一起，在我们生命中的一个空虚的生命中，我们将<code class="fe nq nr ns ni b">3.14159265</code>和<code class="fe nq nr ns ni b">PI</code>绑定在一起。这种绑定会“覆盖”外层绑定吗？我们的函数会返回<code class="fe nq nr ns ni b">6</code>还是<code class="fe nq nr ns ni b">6.2831853</code>？这是一本书，你已经提前浏览过，所以你知道答案是<strong class="ke iv">否</strong>，内装帧不会覆盖外装帧:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="97ea" class="mv ls iu ni b gz nm nn l no np">((PI)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->((PI)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{})(3);<br/>   <!-- -->return<!-- --> <!-- -->(diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI;<br/> <!-- -->})(3.14159265)(2)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="8d31" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们说，当我们使用另一个绑定中的参数绑定一个变量时，内部绑定<em class="mu">会遮蔽外部绑定</em>。它在自己的范围内有效，但不影响封闭范围内的绑定。</p><p id="bf35" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">那么<code class="fe nq nr ns ni b">const</code>呢。它的工作原理是一样的吗？</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="8065" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3.14159265;<br/>      <br/>   <!-- -->(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>     <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3;<br/>   <!-- -->})();<br/>   <br/>   <!-- -->return<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI;<br/> <!-- -->})(2)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="1385" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">是的，名字和参数一样用<code class="fe nq nr ns ni b">const</code>阴影包围绑定。但是等等！还有呢！！！</p><p id="75cb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">只有当我们调用一个函数时，参数才会被绑定。这就是我们制作这些生活的原因。但是<code class="fe nq nr ns ni b">const</code>语句可以出现在块中。当我们在一个块中使用<code class="fe nq nr ns ni b">const</code>时会发生什么？</p><p id="6048" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们需要一个免费的积木。我们已经看到了<code class="fe nq nr ns ni b">if</code>语句，还有什么比:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b239" class="mv ls iu ni b gz nm nn l no np">if<!-- --> <!-- -->(true)<!-- --> <!-- -->{<!-- -->   <!-- -->// an immediately invoked block statement (IIBS)<!-- --> <!-- -->}</span></pre><p id="f0b0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们来试试:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="293c" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3;</span><span id="fb0a" class="mv ls iu ni b gz nt nn l no np">   <!-- -->if<!-- --> <!-- -->(true)<!-- --> <!-- -->{<br/>     <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3.14159265;<!-- -->    <br/>     <!-- -->return<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI;<br/>   <!-- -->}<br/> <!-- -->})(2)<br/>//=&gt; 6.2831853<!-- -->  </span><span id="13be" class="mv ls iu ni b gz nt nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3.14159265;<br/>   <br/>   <!-- -->if<!-- --> <!-- -->(true)<!-- --> <!-- -->{<br/>     <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3;<br/>   <!-- -->}<br/>   <!-- -->return<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI;<br/> <!-- -->})(2)<!-- -->   <br/>//=&gt; 6.2831853</span></pre><p id="4f71" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">啊！<code class="fe nq nr ns ni b">const</code>语句不仅仅隐藏由函数创建的环境中的值，它们还隐藏由块创建的环境中的值！</p><p id="ef28" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这非常重要。考虑另一种选择:如果<code class="fe nq nr ns ni b">const</code>可以在一个块中声明，但是它总是将名称限制在函数的作用域中，那该怎么办？在这种情况下，我们会看到这样的情况:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="0a3a" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3.14159265;<br/>      <!-- -->if<!-- --> <!-- -->(true)<!-- --> <!-- -->{<br/>  <!-- -->     <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3;<br/>   <!-- -->   <!-- -->}<br/>   <!-- -->return<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI;<!-- --> <!-- -->})(2)<!-- -->   </span><span id="c84d" class="mv ls iu ni b gz nt nn l no np">//=&gt; would return 6 if const had function scope</span></pre><p id="1d9d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果<code class="fe nq nr ns ni b">const</code>总是将其值绑定到函数环境中定义的名称，那么在块中放置一个<code class="fe nq nr ns ni b">const</code>语句只会重新绑定现有的名称，覆盖旧的内容。那会超级混乱。这段代码将“工作”</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2f85" class="mv ls iu ni b gz nm nn l no np">((diameter)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->if<!-- --> <!-- -->(true)<!-- --> <!-- -->{<br/>     <!-- -->const<!-- --> <!-- -->PI<!-- --> <!-- -->=<!-- --> <!-- -->3.14159265;<br/>   <!-- -->}<br/>   <!-- -->return<!-- --> <!-- -->diameter<!-- --> <!-- -->*<!-- --> <!-- -->PI;<br/> <!-- -->})(2)<!-- -->   <br/>//=&gt; would return 6.2831853 if const had function scope</span></pre><p id="1f57" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">还是那句话，令人困惑。通常，我们希望将我们的名字尽可能地绑定在我们需要的地方。这个设计规则被称为最小特权原则，它同时具有质量和安全性的含义。能够在块中绑定一个名字意味着如果名字只在块中需要，我们不会把它的绑定“泄露”给不需要与之交互的代码的其他部分。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="4427" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">重新装订</h2><p id="2eff" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">默认情况下，JavaScript允许我们将新值重新绑定到用参数绑定的名称上。例如，我们可以写:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="48ae" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->evenStevens<!-- --> <!-- -->=<!-- --> <!-- -->(n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->if<!-- --> <!-- -->(n<!-- --> <!-- -->===<!-- --> <!-- -->0)<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->true;<br/>   <!-- -->}<br/>   <!-- -->else<!-- --> <!-- -->if<!-- --> <!-- -->(n<!-- --> <!-- -->==<!-- --> <!-- -->1)<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->false;<br/>   <!-- -->}<br/>   <!-- -->else<!-- --> <!-- -->{<br/>     <!-- -->n<!-- --> <!-- -->=<!-- --> <!-- -->n<!-- --> <!-- -->-<!-- --> <!-- -->2;<br/>     <!-- -->return<!-- --> <!-- -->evenStevens(n);<br/>   <!-- -->}<br/> <!-- -->}</span><span id="c58f" class="mv ls iu ni b gz nt nn l no np"> <!-- -->evenStevens(42)<!-- -->   <!-- -->//=&gt; true</span></pre><p id="1208" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">行<code class="fe nq nr ns ni b">n = n - 2;</code> <em class="mu">给名字<code class="fe nq nr ns ni b">n</code>重新绑定</em>一个新值。让我们尝试一个类似的事情，用<code class="fe nq nr ns ni b">const</code>绑定一个名字。我们已经使用<code class="fe nq nr ns ni b">const</code>绑定了<code class="fe nq nr ns ni b">evenStevens</code>，让我们尝试重新绑定它:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2111" class="mv ls iu ni b gz nm nn l no np">evenStevens<!-- --> <!-- -->=<!-- --> <!-- -->(n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>   <!-- -->if<!-- --> <!-- -->(n<!-- --> <!-- -->===<!-- --> <!-- -->0)<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->true;<br/>   <!-- -->}<br/>   <!-- -->else<!-- --> <!-- -->if<!-- --> <!-- -->(n<!-- --> <!-- -->==<!-- --> <!-- -->1)<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->false;<br/>   <!-- -->}<br/>   <!-- -->else<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->evenStevens(n<!-- --> <!-- -->-<!-- --> <!-- -->2);<br/>   <!-- -->}<br/>}<!-- -->   <br/>//=&gt; ERROR, evenStevens is read-only</span></pre><p id="68fb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">JavaScript不允许我们重新绑定已经用<code class="fe nq nr ns ni b">const</code>绑定的名字。我们可以通过使用<code class="fe nq nr ns ni b">const</code>声明一个带有新函数或块作用域的新绑定来<em class="mu">隐藏</em>，但是我们不能在现有作用域中重新绑定一个带有<code class="fe nq nr ns ni b">const</code>的名字。</p><p id="b936" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是有价值的，因为它极大地简化了程序的分析，一眼就能看出当某个东西与<code class="fe nq nr ns ni b">const</code>绑定时，我们不必担心它的值会改变。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="7c8f" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">命名功能</h1><p id="aa95" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">让我们开门见山吧。这段代码不<em class="mu">而</em>命名一个函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="50a2" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->repeat<!-- --> <!-- -->=<!-- --> <!-- -->(str)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->str<!-- --> <!-- -->+<!-- --> <!-- -->str</span></pre><p id="6e58" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">它没有将函数命名为“repeat ”,原因与<code class="fe nq nr ns ni b">const answer = 42</code>没有将数字命名为<code class="fe nq nr ns ni b">42</code>相同。这种语法将一个匿名函数绑定到环境中的一个名称，但是函数本身仍然是匿名的。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="7873" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated"><code class="fe nq nr ns ni b">function</code>关键字</h2><p id="377f" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">JavaScript<em class="mu"/>有命名函数的语法吗，我们用<code class="fe nq nr ns ni b">function</code>关键字。在ECMAScript 2015创建之前，<code class="fe nq nr ns ni b">function</code>是编写函数的常用语法。</p><p id="987a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是我们用“粗箭头”编写的<code class="fe nq nr ns ni b">repeat</code>函数</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="4339" class="mv ls iu ni b gz nm nn l no np">(str)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->str<!-- --> <!-- -->+<!-- --> <!-- -->str</span></pre><p id="db18" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">下面是使用<code class="fe nq nr ns ni b">function</code>关键字编写的(几乎)完全相同的函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="af62" class="mv ls iu ni b gz nm nn l no np">function<!-- --> <!-- -->(str)<!-- --> <!-- -->{<!-- --> <!-- -->return<!-- --> <!-- -->str<!-- --> <!-- -->+<!-- --> <!-- -->str<!-- --> <!-- -->}</span></pre><p id="d0d2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们来看看明显的区别:</p><ol class=""><li id="1f71" class="oa ob iu ke b kf kg kj kk kn oc kr od kv oe kz of og oh oi bi translated">我们引入一个带有<code class="fe nq nr ns ni b">function</code>关键字的函数。</li><li id="33bd" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">我们要讨论的其他事情是可选的。</li><li id="48fd" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">我们在圆括号中有参数，就像胖箭头函数一样。</li><li id="3093" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">我们没有粗箭头，而是直接指向身体。</li><li id="2102" class="oa ob iu ke b kf oj kj ok kn ol kr om kv on kz of og oh oi bi translated">我们总是使用一个块，我们不能写<code class="fe nq nr ns ni b">function (str) str + str</code>。这意味着如果我们希望函数返回值，我们总是需要使用<code class="fe nq nr ns ni b">return</code>关键字</li></ol><p id="fc9b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果我们省略掉跟在<code class="fe nq nr ns ni b">function</code>关键字后面的“一些可选的东西”,我们可以将所有我们见过的粗箭头函数翻译成<code class="fe nq nr ns ni b">function</code>关键字函数，例如</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9be3" class="mv ls iu ni b gz nm nn l no np">(n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(1.618**n<!-- --> <!-- -->-<!-- --> <!-- -->-1.618**-n)<!-- --> <!-- -->/<!-- --> <!-- -->2.236</span></pre><p id="2e19" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">可以写成:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9fb9" class="mv ls iu ni b gz nm nn l no np">function<!-- --> <!-- -->(n)<!-- --> <!-- -->{<!-- -->   <!-- -->return<!-- --> <!-- -->(1.618**n<!-- --> <!-- -->-<!-- --> <!-- -->-1.618**-n)<!-- --> <!-- -->/<!-- --> <!-- -->2.236;<!-- --> <!-- -->}</span></pre><p id="6df7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这仍然没有<em class="mu">命名</em>一个函数，但是正如我们上面提到的，用<code class="fe nq nr ns ni b">function</code>关键字编写的函数有一个可选的“其他东西”“别的东西”能命名一个函数吗？是的，当然。</p><p id="9b5d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">以下是我们用名称编写的示例函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="f7ad" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->repeat<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->repeat<!-- --> <!-- -->(str)<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->str<!-- --> <!-- -->+<!-- --> <!-- -->str;<br/>};<!-- -->  </span><span id="3439" class="mv ls iu ni b gz nt nn l no np">const<!-- --> <!-- -->fib<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->fib<!-- --> <!-- -->(n)<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->(1.618**n<!-- --> <!-- -->-<!-- --> <!-- -->-1.618**-n)<!-- --> <!-- -->/<!-- --> <!-- -->2.236;<!-- --> <br/>};</span></pre><p id="5c8c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在关键字<code class="fe nq nr ns ni b">function</code>和参数列表之间放置一个名字来命名函数。令人困惑的是，函数的名称与我们可能选择绑定到函数值的名称并不完全相同。例如，我们可以写:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="5703" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->double<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->repeat<!-- --> <!-- -->(str)<!-- --> <!-- -->{<!-- -->   <br/>  <!-- -->return<!-- --> <!-- -->str<!-- --> <!-- -->+<!-- --> <!-- -->str;<!-- --> <br/>}</span></pre><p id="f992" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在这个表达式中，<code class="fe nq nr ns ni b">double</code>是环境中的名字，但是<code class="fe nq nr ns ni b">repeat</code>是函数的实际名字。这是一个<em class="mu">命名的函数表达式</em>。这可能看起来令人困惑，但是请将绑定名称视为环境的属性，而不是函数的属性。而函数的名称是函数的属性，而不是环境的属性。</p><p id="3c65" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">事实上，名称<em class="mu">是</em>的一个属性:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="7ac5" class="mv ls iu ni b gz nm nn l no np">double.name<!-- -->   <!-- -->//=&gt; 'repeat'</span></pre><p id="5b22" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在本书中，我们不研究JavaScript的工具，比如浏览器中内置的调试器，但是我们会注意到，当你在所有现代工具中导航调用栈时，函数的绑定名称会被忽略，但是它的实际名称会显示出来，所以即使函数没有得到正式的绑定，命名函数也是非常有用的，例如</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="01a1" class="mv ls iu ni b gz nm nn l no np">someBackboneView.on('click',<!-- --> <!-- -->function<!-- --> <!-- -->clickHandler<!-- --> <!-- -->()<!-- --> <!-- -->{<!-- -->   <!-- -->//...<!-- --> <!-- -->});</span></pre><p id="5349" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在，函数的实际名称对它的使用环境没有影响。致whit:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="974a" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->bindingName<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->actualName<!-- --> <!-- -->()<!-- --> <!-- -->{<!-- -->   <!-- -->//...<!-- --> <!-- -->};<!-- -->  <br/>bindingName<!-- -->   <br/>//=&gt; [Function: actualName]<!-- -->  </span><span id="637c" class="mv ls iu ni b gz nt nn l no np">actualName<!-- -->   <br/>//=&gt; ReferenceError: actualName is not defined</span></pre><p id="6247" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">所以“actualName”在我们使用命名函数表达式的环境中不受限制。它被束缚在别的地方吗？是的，它是。这里有一个函数决定一个正整数是否为偶数。我们将在生活中使用它，这样我们就不必将它与带有<code class="fe nq nr ns ni b">const</code>的名称绑定在一起:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="3be3" class="mv ls iu ni b gz nm nn l no np">(function<!-- --> <!-- -->even<!-- --> <!-- -->(n)<!-- --> <!-- -->{<br/>   <!-- -->if<!-- --> <!-- -->(n<!-- --> <!-- -->===<!-- --> <!-- -->0)<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->true<br/>   <!-- -->}<br/>   <!-- -->else<!-- --> <!-- -->return<!-- --> <!-- -->!even(n<!-- --> <!-- -->-<!-- --> <!-- -->1)<br/>})(5)<!-- -->   <br/>//=&gt; false<!-- -->  </span><span id="d6af" class="mv ls iu ni b gz nt nn l no np">(function<!-- --> <!-- -->even<!-- --> <!-- -->(n)<!-- --> <!-- -->{<br/>   <!-- -->if<!-- --> <!-- -->(n<!-- --> <!-- -->===<!-- --> <!-- -->0)<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->true<br/>   <!-- -->}<br/>   <!-- -->else<!-- --> <!-- -->return<!-- --> <!-- -->!even(n<!-- --> <!-- -->-<!-- --> <!-- -->1)<!-- --> <br/>})(2)<!-- -->   <br/>//=&gt; true</span></pre><p id="6bc3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">显然，名字<code class="fe nq nr ns ni b">even</code>被绑定到函数体中的函数<em class="mu">。是否绑定到函数体外的函数？</em></p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="af7a" class="mv ls iu ni b gz nm nn l no np">even<!-- -->   <!-- -->//=&gt; Can't find variable: even</span></pre><p id="97f2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">even</code>是绑定在函数本身内部，而不是外部。正如我们在上面看到的，这对于创建递归函数很有用，并且它说明了最小特权原则:如果你不需要<em class="mu">在其他地方给它命名，你就不需要。</em></p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="3f3b" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">函数声明</h2><p id="ea1f" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">还有另一种命名和/或定义函数的语法。它被称为<em class="mu">函数声明语句</em>，它看起来很像一个命名函数表达式，只是我们将它用作一个语句:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="a769" class="mv ls iu ni b gz nm nn l no np">function<!-- --> <!-- -->someName<!-- --> <!-- -->()<!-- --> <!-- -->{<!-- -->   <!-- -->// ...<!-- --> <!-- -->}</span></pre><p id="b4e5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这表现得有点像:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="d652" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->someName<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->someName<!-- --> <!-- -->()<!-- --> <!-- -->{<!-- -->   <!-- -->// ...<!-- --> <!-- -->}</span></pre><p id="cd7c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因为它将环境中的名称绑定到命名函数。然而，有两个重要的区别。首先，函数声明被<em class="mu">提升</em>到它们出现的函数的顶部。</p><p id="e795" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">考虑这个例子，在我们用<code class="fe nq nr ns ni b">const</code>将一个函数绑定到变量<code class="fe nq nr ns ni b">fizzbuzz</code>之前，我们尝试将变量【】用作一个函数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2264" class="mv ls iu ni b gz nm nn l no np">(function<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->fizzbuzz();<br/>   <br/>   <!-- -->const<!-- --> <!-- -->fizzbuzz<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->fizzbuzz<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->"Fizz"<!-- --> <!-- -->+<!-- --> <!-- -->"Buzz";<br/>   <!-- -->}<!-- --> <br/>})()<!-- -->   </span><span id="3b12" class="mv ls iu ni b gz nt nn l no np">//=&gt; undefined is not a function (evaluating 'fizzbuzz()')</span></pre><p id="45da" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在尝试使用函数之前，我们实际上没有将函数绑定到名字<code class="fe nq nr ns ni b">fizzbuzz</code>，所以我们会得到一个错误。但是函数<em class="mu">声明</em>的工作方式不同:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="ec6c" class="mv ls iu ni b gz nm nn l no np">(function<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->fizzbuzz();<br/>   <br/>   <!-- -->function<!-- --> <!-- -->fizzbuzz<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->"Fizz"<!-- --> <!-- -->+<!-- --> <!-- -->"Buzz";<br/>   <!-- -->}<!-- --> </span><span id="5189" class="mv ls iu ni b gz nt nn l no np">})()<!-- -->   <br/>//=&gt; 'FizzBuzz'</span></pre><p id="8fb6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">尽管<code class="fe nq nr ns ni b">fizzbuzz</code>是在函数的后面声明的，JavaScript的行为就像我们写的一样:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="3b7a" class="mv ls iu ni b gz nm nn l no np">(function<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>   <!-- -->const<!-- --> <!-- -->fizzbuzz<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->fizzbuzz<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>     <!-- -->return<!-- --> <!-- -->"Fizz"<!-- --> <!-- -->+<!-- --> <!-- -->"Buzz";<br/>   <!-- -->}<!-- -->    <br/>   <!-- -->return<!-- --> <!-- -->fizzbuzz();<!-- --> <br/>})()</span></pre><p id="f46e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">fizzbuzz</code>的定义被“提升”到其封闭范围的顶部(在这种情况下是一个生命)。这种行为是JavaScript设计中有意为之的，以促进某种编程风格，将主要逻辑放在前面，将“辅助函数”放在底部。在JavaScript中没有必要以这种方式声明函数，但是理解语法和它的行为(尤其是它与<code class="fe nq nr ns ni b">const</code>的不同之处)对于处理产品代码是必不可少的。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="bcd0" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">函数声明警告</h2><p id="ed50" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">函数声明在形式上应该只在我们称之为函数的“顶层”进行。尽管一些JavaScript环境允许使用下面的代码，但是这个例子在技术上是非法的，绝对不是一个好主意:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="d5fd" class="mv ls iu ni b gz nm nn l no np">(function<!-- --> <!-- -->(camelCase)<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->fizzbuzz();<br/>   <br/>   <!-- -->if<!-- --> <!-- -->(camelCase)<!-- --> <!-- -->{<br/>     <!-- -->function<!-- --> <!-- -->fizzbuzz<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>       <!-- -->return<!-- --> <!-- -->"Fizz"<!-- --> <!-- -->+<!-- --> <!-- -->"Buzz";<br/>     <!-- -->}<br/>   <!-- -->}<br/>   <!-- -->else<!-- --> <!-- -->{<br/>     <!-- -->function<!-- --> <!-- -->fizzbuzz<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>       <!-- -->return<!-- --> <!-- -->"Fizz"<!-- --> <!-- -->+<!-- --> <!-- -->"Buzz";<br/>     <!-- -->}<br/>   <!-- -->}<!-- --> <br/>})(true)<!-- -->   </span><span id="0502" class="mv ls iu ni b gz nt nn l no np">//=&gt; 'FizzBuzz'? Or ERROR: Can't find variable: fizzbuzz?</span></pre><p id="c669" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">函数声明不应该出现在块内部。像这样的表达式的大问题是，它们可能在您的测试环境中工作得很好，但在生产环境中却以不同的方式工作。或者，在JavaScript引擎更新时，比如有了新的优化，它可能以一种方式工作，而以另一种方式工作。</p><p id="9190" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">另一个警告是函数声明不能存在于任何T21表达式中，否则它就是一个函数表达式。这是一个函数声明:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="966e" class="mv ls iu ni b gz nm nn l no np">function<!-- --> <!-- -->trueDat<!-- --> <!-- -->()<!-- --> <!-- -->{<!-- --> <!-- -->return<!-- --> <!-- -->true<!-- --> <!-- -->}</span></pre><p id="b5a4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但这不是:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="356c" class="mv ls iu ni b gz nm nn l no np">(function<!-- --> <!-- -->trueDat<!-- --> <!-- -->()<!-- --> <!-- -->{<!-- --> <!-- -->return<!-- --> <!-- -->true<!-- --> <!-- -->})</span></pre><p id="2a2e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">括号使它成为一个表达式，而不是一个函数声明。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="5890" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">组合子和函数装饰子</h1><h2 id="78a6" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">高阶函数</h2><p id="54f8" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">正如我们所见，JavaScript函数将值作为参数并返回值。JavaScript函数是值，因此JavaScript函数可以将函数作为参数、返回函数或两者都作为。一般来说，一个函数要么接受函数作为参数，要么返回一个函数，或者两者都接受，被称为“高阶”函数。</p><p id="0b4a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">下面是一个非常简单的高阶函数，它将一个函数作为参数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="fc25" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->repeat<!-- --> <!-- -->=<!-- --> <!-- -->(num,<!-- --> <!-- -->fn)<!-- --> <!-- -->=&gt;<br/>   <!-- -->(num<!-- --> <!-- -->&gt;<!-- --> <!-- -->0)<br/>     <!-- -->?<!-- --> <!-- -->(repeat(num<!-- --> <!-- -->-<!-- --> <!-- -->1,<!-- --> <!-- -->fn),<!-- --> <!-- -->fn(num))<br/>     <!-- -->:<!-- --> <!-- -->undefined</span><span id="9386" class="mv ls iu ni b gz nt nn l no np">repeat(3,<!-- --> <!-- -->function<!-- --> <!-- -->(n)<!-- --> <!-- -->{<br/>   <!-- -->console.log(`Hello ${n}`)<br/>})<!-- -->   </span><span id="4f38" class="mv ls iu ni b gz nt nn l no np">//=&gt;<!-- -->     <!-- -->'Hello 1'<!-- -->     <!-- -->'Hello 2'<!-- -->     <!-- -->'Hello 3'<!-- -->     <!-- -->undefined</span></pre><p id="7a87" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">高阶函数支配着<em class="mu"> JavaScript Allongé </em>。但在我们继续之前，我们将讨论一些特定类型的高阶函数。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="29cc" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">组合子</h2><p id="9065" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">“组合子”一词在数学中有精确的技术含义:</p><blockquote class="nu nv nw"><p id="088c" class="kc kd mu ke b kf kg kh ki kj kk kl km nx ko kp kq ny ks kt ku nz kw kx ky kz in bi translated">“组合子是一种高阶函数，它只使用函数应用程序和早期定义的组合子来定义其参数的结果。”–<a class="ae la" href="https://en.wikipedia.org/wiki/Combinatory_logic" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="a3fb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果我们正在学习组合逻辑，我们会从最基本的组合子开始，比如<code class="fe nq nr ns ni b">S</code>、<code class="fe nq nr ns ni b">K</code>和<code class="fe nq nr ns ni b">I</code>，然后从那里开始学习实用的组合子。根据雷蒙德·斯穆利安的名著<a class="ae la" href="http://www.amazon.com/gp/product/B00A1P096Y/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B00A1P096Y&amp;linkCode=as2&amp;tag=raganwald001-20" rel="noopener ugc nofollow" target="_blank">模仿一只知更鸟</a>的例子，我们将了解到基本组合子是以鸟类命名的。</p><p id="734e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在本书中，我们将使用“组合子”的更宽松的定义:“高阶纯函数，只接受函数作为参数并返回一个函数。我们不会严格要求在构造中只使用先前定义的组合子。</p><p id="c9b2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们从一个有用的组合子开始:大多数程序员称它为<em class="mu"> Compose </em>，尽管逻辑学家称它为B组合子或“蓝鸟”。下面是典型的编程实现:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="77d2" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->compose<!-- --> <!-- -->=<!-- --> <!-- -->(a,<!-- --> <!-- -->b)<!-- --> <!-- -->=&gt;<br/>   <!-- -->(c)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->a(b(c))</span></pre><p id="9a68" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">假设我们有:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="c4ba" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->addOne<!-- --> <!-- -->=<!-- --> <!-- -->(number)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->number<!-- --> <!-- -->+<!-- --> <!-- -->1;<!-- -->  <br/>const<!-- --> <!-- -->doubleOf<!-- --> <!-- -->=<!-- --> <!-- -->(number)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->number<!-- --> <!-- -->*<!-- --> <!-- -->2;</span></pre><p id="c5ef" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用<code class="fe nq nr ns ni b">compose</code>，您可以在任何地方书写</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2a1a" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->doubleOfAddOne<!-- --> <!-- -->=<!-- --> <!-- -->(number)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->doubleOf(addOne(number));</span></pre><p id="3f99" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">你也可以写:</p><p id="6288" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">const</code> <code class="fe nq nr ns ni b">doubleOfAddOne</code> <code class="fe nq nr ns ni b">=</code> <code class="fe nq nr ns ni b">compose(doubleOf,</code> <code class="fe nq nr ns ni b">addOne);</code></p><p id="98f3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当然，这只是许多例子中的一个。虽然一些程序员认为“应该只有一种方法”，但如果明智地使用，使用组合子以及用大量符号和关键字显式地写出东西会有一些优势。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="f5c6" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">关于组合子的平衡陈述</h2><p id="1d44" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">使用大量组合符的代码倾向于命名动词和副词(如<code class="fe nq nr ns ni b">doubleOf</code>、<code class="fe nq nr ns ni b">addOne</code>和<code class="fe nq nr ns ni b">compose</code>)，同时避免语言关键字和名词的名称(如<code class="fe nq nr ns ni b">number</code>)。因此，一个观点是，当你想强调你正在做的事情以及它们是如何结合在一起的时候，组合子是有用的，当你想强调你正在做的事情的时候，更显式的代码是有用的。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="d01b" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">功能装饰者</h2><p id="1ce8" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated"><em class="mu">函数装饰器</em>是一个高阶函数，它将一个函数作为参数，返回另一个函数，返回的函数是参数函数的变体。这里有一个简单得可笑的装饰:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="ab17" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->not<!-- --> <!-- -->=<!-- --> <!-- -->(fn)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->!fn(x)</span></pre><p id="b4be" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">所以我们可以写<code class="fe nq nr ns ni b">not(someFunction)(42)</code>，而不是写<code class="fe nq nr ns ni b">!someFunction(42)</code>。几乎没有进展。但是像<code class="fe nq nr ns ni b">compose</code>一样，我们可以写:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="b817" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->something<!-- --> <!-- -->=<!-- --> <!-- -->(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->x<!-- --> <!-- -->!=<!-- --> <!-- -->null;</span></pre><p id="4091" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在其他地方，写下:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="627c" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->nothing<!-- --> <!-- -->=<!-- --> <!-- -->(x)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->!something(x);</span></pre><p id="9979" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">或者我们可以写:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="7a4c" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->nothing<!-- --> <!-- -->=<!-- --> <!-- -->not(something);</span></pre><p id="98db" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">not</code>是一个函数装饰器，因为它修改了一个函数，同时保持与原始函数的语义密切相关。函数装饰者并不严格要求是纯函数，所以在制作装饰者方面比组合者有更大的自由度。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="0eab" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">积木</h1><p id="3dae" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">当你在JavaScript中查看函数内部的函数时，会有一点“意大利面条式代码”的感觉。JavaScript的优势在于你可以做任何事情。缺点是你会。有“如果”、“赞成”、“返回”,所有的东西都杂乱无章地放在一起。虽然您不必将自己局限于少量的简单模式，但是理解这些模式是有帮助的，这样您就可以围绕一些基本的构建块来构建您的代码。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="bed6" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">作文</h2><p id="0306" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">这些积木中最基本的一个是<em class="mu">组合</em>:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="a1da" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->cookAndEat<!-- --> <!-- -->=<!-- --> <!-- -->(food)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->eat(cook(food));</span></pre><p id="69e2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">事实上就是这么简单:每当你将两个或更多的函数链接在一起时，你就是在组合它们。您可以像我们刚刚做的那样，用显式JavaScript代码组合它们。你也可以用我们在组合子和装饰子中看到的B组合子或“compose”来概括组合:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="497f" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->compose<!-- --> <!-- -->=<!-- --> <!-- -->(a,<!-- --> <!-- -->b)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->(c)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->a(b(c));<!-- -->  <br/>const<!-- --> <!-- -->cookAndEat<!-- --> <!-- -->=<!-- --> <!-- -->compose(eat,<!-- --> <!-- -->cook);</span></pre><p id="9782" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果这就是全部，构图就没什么大不了的了。但是像许多模式一样，在它适用的时候使用它只有20%的好处。另外的80%来自于组织你的代码，这样你就可以使用它:编写可以用各种方式组合的函数。</p><p id="7215" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当然，你不必使用组合子来实现这些想法，你可以使用if语句。但是<code class="fe nq nr ns ni b">once</code>和<code class="fe nq nr ns ni b">maybe</code>是组合在一起的，所以你可以按照你认为合适的方式将它们链接在一起:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="61e5" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->actuallyTransfer =<!-- --> <!-- -->(from,<!-- --> <!-- -->to,<!-- --> <!-- -->amount)<!-- --> <!-- -->=&gt;<!-- -->   <!-- -->// do something<!-- -->  <!-- -->const<!-- --> <!-- -->invokeTransfer<!-- --> <!-- -->=<!-- --> <!-- -->once(maybe(actuallyTransfer(...)));</span></pre></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="0286" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">部分应用</h2><p id="789e" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">另一个基本构件是<em class="mu">局部应用</em>。当一个函数有多个参数时，我们通过用所有的参数对它求值来把函数“应用”到参数上，产生一个值。但是如果我们只提供一些参数呢？在这种情况下，我们不能得到最终的值，但是我们可以得到一个表示应用程序的<em class="mu">部分</em>的函数。</p><p id="b2e3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">对于这一点，代码比文字更容易。<a class="ae la" href="http://underscorejs.org" rel="noopener ugc nofollow" target="_blank">下划线</a>库提供了一个名为<em class="mu">映射</em>的高阶函数。它对数组的每个元素应用另一个函数，如下所示:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2528" class="mv ls iu ni b gz nm nn l no np">_.map([1,<!-- --> <!-- -->2,<!-- --> <!-- -->3],<!-- --> <!-- -->(n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->n<!-- --> <!-- -->*<!-- --> <!-- -->n)<!-- -->   <!-- -->//=&gt; [1, 4, 9]</span></pre><p id="57cf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们不想瞎写<code class="fe nq nr ns ni b">_.</code>，可以这样写来用:</p><p id="8be8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">const</code> <code class="fe nq nr ns ni b">map</code> <code class="fe nq nr ns ni b">=</code> <code class="fe nq nr ns ni b">_.map;</code></p><p id="b4e1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这段代码通过将函数<code class="fe nq nr ns ni b">(n) =&gt; n * n</code>作为第二个参数来实现map函数的部分应用:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="9972" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->squareAll<!-- --> <!-- -->=<!-- --> <!-- -->(array)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->map(array,<!-- -->  <!-- -->(n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->n<!-- --> <!-- -->*<!-- --> <!-- -->n);</span></pre><p id="baf7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">结果函数–<code class="fe nq nr ns ni b">squareAll</code>–仍然是map函数，只是我们已经应用了它的两个参数之一。很好，但是为什么每次我们想在地图上应用一个函数的时候都要写一个函数呢？我们可以把它抽象得更高一层。<code class="fe nq nr ns ni b">mapWith</code>将任意函数作为参数，返回部分应用的映射函数。</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="1b71" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->mapWith<!-- --> <!-- -->=<!-- --> <!-- -->(fn)<!-- --> <!-- -->=&gt;<!-- -->   <br/>    <!-- -->(array)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->map(array,<!-- --> <!-- -->fn);<!-- -->  </span><span id="6984" class="mv ls iu ni b gz nt nn l no np">const<!-- --> <!-- -->squareAll<!-- --> <!-- -->=<!-- --> <!-- -->mapWith((n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->n<!-- --> <!-- -->*<!-- --> <!-- -->n);<!-- -->  </span><span id="7534" class="mv ls iu ni b gz nt nn l no np">squareAll([1,<!-- --> <!-- -->2,<!-- --> <!-- -->3])<!-- -->   <!-- -->//=&gt; [1, 4, 9]</span></pre><p id="ea3f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">重要的是要看到部分应用与组合是正交的，并且它们可以很好地协同工作:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2824" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->safeSquareAll<!-- --> <!-- -->=<!-- --> <!-- -->mapWith(maybe((n)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->n<!-- --> <!-- -->*<!-- --> <!-- -->n));<!-- -->  </span><span id="a080" class="mv ls iu ni b gz nt nn l no np">safeSquareAll([1,<!-- --> <!-- -->null,<!-- --> <!-- -->2,<!-- --> <!-- -->3])<!-- -->   <!-- -->//=&gt; [1, null, 4, 9]</span></pre><p id="7d9d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们用<code class="fe nq nr ns ni b">compose</code>组合子概括了复合。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="6fda" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">神奇的名字</h1><p id="8fea" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">当一个函数被应用于参数(或被“调用”)时，JavaScript在一个为执行该函数而创建的环境中将参数值绑定到函数的参数名。到目前为止，我们还没有讨论的是，除了您放入参数列表中的任何值之外，JavaScript还将值绑定到一些“神奇”的名称。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="d9df" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">function关键字</h2><p id="a3d2" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">对于这些“神奇”的名字，有两个不同的规则，一个用于使用<code class="fe nq nr ns ni b">function</code>关键字调用函数，另一个用于使用“粗箭头”定义的函数。我们将从用<code class="fe nq nr ns ni b">function</code>关键字定义的函数的工作方式开始。</p><p id="d8f4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">第一个神奇的名字是<code class="fe nq nr ns ni b">this</code>，它被绑定到一个叫做函数上下文的东西上。当我们开始讨论对象和类<em class="mu">时，我们将更详细地探讨<code class="fe nq nr ns ni b">this</code>【编辑:不是在本文中，而是在书中，也许在未来的摘录中】</em>。第二个神奇的名字非常有趣，它叫做<code class="fe nq nr ns ni b">arguments</code>，最有趣的是它包含了一个传递给函数的参数列表:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="70b1" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->plus<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->(a,<!-- --> <!-- -->b)<!-- --> <!-- -->{<!-- -->   <br/>  <!-- -->return<!-- --> <!-- -->arguments[0]<!-- --> <!-- -->+<!-- --> <!-- -->arguments[1];<!-- --> <br/>}<!-- -->  </span><span id="aa4d" class="mv ls iu ni b gz nt nn l no np">plus(2,3)<!-- -->   <br/>//=&gt; 5</span></pre><p id="0bbf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">虽然<code class="fe nq nr ns ni b">arguments</code>看起来像一个数组，但它不是数组:它更像是一个对象，恰好将一些值绑定到属性，这些属性的名称看起来像从零开始的整数:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="ea6a" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->args<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->(a,<!-- --> <!-- -->b)<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->arguments;<!-- --> <br/>}<!-- -->  </span><span id="0c1f" class="mv ls iu ni b gz nt nn l no np">args(2,3)<!-- -->   <br/>//=&gt; { '0': 2, '1': 3 }</span></pre><p id="ec59" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">arguments</code>总是包含传递给函数的所有参数，不管声明了多少个。因此，我们可以这样写<code class="fe nq nr ns ni b">plus</code>:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="2af3" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->plus<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->()<!-- --> <!-- -->{<!-- -->   <!-- -->return<!-- --> <!-- -->arguments[0]<!-- --> <!-- -->+<!-- --> <!-- -->arguments[1];<!-- --> <!-- -->}<!-- -->  </span><span id="2c4b" class="mv ls iu ni b gz nt nn l no np">plus(2,3)<!-- -->   <br/>//=&gt; 5</span></pre><p id="c0c8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当讨论对象时，我们将更深入地讨论属性。这里有一些关于<code class="fe nq nr ns ni b">arguments</code>的有趣的事情:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="a5b1" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->howMany<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->arguments['length'];<!-- --> <br/>}<!-- -->  </span><span id="0e89" class="mv ls iu ni b gz nt nn l no np">howMany()<!-- -->   </span><span id="5816" class="mv ls iu ni b gz nt nn l no np">//=&gt; 0<!-- -->  </span><span id="5996" class="mv ls iu ni b gz nt nn l no np">howMany('hello')<!-- -->   <br/>//=&gt; 1<!-- -->  </span><span id="09eb" class="mv ls iu ni b gz nt nn l no np">howMany('sharks',<!-- --> <!-- -->'are',<!-- --> <!-- -->'apex',<!-- --> <!-- -->'predators')<!-- -->   <br/>//=&gt; 4</span></pre><p id="6ae8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe nq nr ns ni b">arguments</code>绑定最常见的用途是构建可以接受可变数量参数的函数。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h2 id="957f" class="mv ls iu bd lt mw mx dn lx my mz dp mb kn na nb mf kr nc nd mj kv ne nf mn ng bi translated">神奇的名字和肥胖的箭头</h2><p id="0893" class="pw-post-body-paragraph kc kd iu ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz in bi translated">当您调用用粗箭头定义的函数时，神奇的名称<code class="fe nq nr ns ni b">this</code>和<code class="fe nq nr ns ni b">arguments</code>具有不同的行为:当调用函数时，粗箭头函数总是从其封闭范围获取<code class="fe nq nr ns ni b">this</code>和<code class="fe nq nr ns ni b">arguments</code>的绑定，而不是被绑定，就像任何其他绑定一样。</p><p id="787d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">例如，当这个表达式的内部函数用<code class="fe nq nr ns ni b">function</code>定义时，<code class="fe nq nr ns ni b">arguments[0]</code>是指它唯一的参数，<code class="fe nq nr ns ni b">"inner"</code>:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="925a" class="mv ls iu ni b gz nm nn l no np">(function<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->(function<!-- --> <!-- -->()<!-- --> <!-- -->{<!-- --> <!-- -->return<!-- --> <!-- -->arguments[0];<!-- --> <!-- -->})('inner');<!-- --> <br/>})('outer')<!-- -->   </span><span id="cb32" class="mv ls iu ni b gz nt nn l no np">//=&gt; "inner"</span></pre><p id="b928" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是如果我们使用粗箭头，<code class="fe nq nr ns ni b">arguments</code>将被定义在外部环境中，用<code class="fe nq nr ns ni b">function</code>定义的那个。因此<code class="fe nq nr ns ni b">arguments[0]</code>指的是<code class="fe nq nr ns ni b">"outer"</code>，而不是<code class="fe nq nr ns ni b">"inner"</code>:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="342d" class="mv ls iu ni b gz nm nn l no np">(function<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->(()<!-- --> <!-- -->=&gt;<!-- --> <!-- -->arguments[0])('inner');<!-- --> <br/>})('outer')<!-- -->   </span><span id="a0dc" class="mv ls iu ni b gz nt nn l no np">//=&gt; "outer"</span></pre><p id="8522" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">虽然这两种语法具有不同的语义似乎有些不切实际，但当您考虑设计目标时，这是有意义的:胖箭头函数被设计为非常轻量级，并且经常与映射或回调之类的构造一起使用来模拟语法。</p><p id="73ca" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">举一个虚构的例子，这个函数接受一个数字并返回一个数组，该数组表示一个假设的乘法表中的一行。它使用我们在<a class="ae la" href="#buildingblocks" rel="noopener ugc nofollow">构建模块</a>中讨论过的<code class="fe nq nr ns ni b">mapWith</code>。<a class="ae la" href="#fn-mapWith" rel="noopener ugc nofollow"> 24 </a>我们将使用<code class="fe nq nr ns ni b">arguments</code>来展示使用粗箭头和function关键字之间的区别:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="1460" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->row<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->mapWith((column)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->column<!-- --> <!-- -->*<!-- --> <!-- -->arguments[0])(<br/>     <!-- -->[1,<!-- --> <!-- -->2,<!-- --> <!-- -->3,<!-- --> <!-- -->4,<!-- --> <!-- -->5,<!-- --> <!-- -->6,<!-- --> <!-- -->7,<!-- --> <!-- -->8,<!-- --> <!-- -->9,<!-- --> <!-- -->10,<!-- --> <!-- -->11,<!-- --> <!-- -->12]<br/>   <!-- -->)<!-- --> <br/>}<!-- -->  </span><span id="0425" class="mv ls iu ni b gz nt nn l no np">row(3)<!-- -->   </span><span id="d10a" class="mv ls iu ni b gz nt nn l no np">//=&gt; [3,6,9,12,15,18,21,24,27,30,33,36</span></pre><p id="7865" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这很好，因为<code class="fe nq nr ns ni b">arguments[0]</code>指的是我们传递给函数<code class="fe nq nr ns ni b">row</code>的<code class="fe nq nr ns ni b">3</code>。我们的“粗箭头”函数<code class="fe nq nr ns ni b">(column) =&gt; column * arguments[0]</code>在被调用时不会绑定<code class="fe nq nr ns ni b">arguments</code>。但是如果我们重写<code class="fe nq nr ns ni b">row</code>来使用<code class="fe nq nr ns ni b">function</code>关键字，它就会停止工作:</p><pre class="lc ld le lf gu nh ni nj nk aw nl bi"><span id="93b3" class="mv ls iu ni b gz nm nn l no np">const<!-- --> <!-- -->row<!-- --> <!-- -->=<!-- --> <!-- -->function<!-- --> <!-- -->()<!-- --> <!-- -->{<br/>   <!-- -->return<!-- --> <!-- -->mapWith(function<!-- --> <!-- -->(column)<!-- --> <!-- -->{<!-- --> <!-- -->return<!-- --> <!-- -->column<!-- --> <!-- -->*<!-- --> <!-- -->arguments[0]<!-- --> <!-- -->})(<br/>     <!-- -->[1,<!-- --> <!-- -->2,<!-- --> <!-- -->3,<!-- --> <!-- -->4,<!-- --> <!-- -->5,<!-- --> <!-- -->6,<!-- --> <!-- -->7,<!-- --> <!-- -->8,<!-- --> <!-- -->9,<!-- --> <!-- -->10,<!-- --> <!-- -->11,<!-- --> <!-- -->12]<br/>   <!-- -->)<!-- --> <!-- -->}<!-- -->  </span><span id="792d" class="mv ls iu ni b gz nt nn l no np">row(3)<!-- -->   </span><span id="c773" class="mv ls iu ni b gz nt nn l no np">//=&gt; [1,4,9,16,25,36,49,64,81,100,121,144]</span></pre><p id="0c5c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在我们的内部函数在每次被调用时都会绑定<code class="fe nq nr ns ni b">arguments[0]</code>，所以我们得到的结果就好像我们编写了<code class="fe nq nr ns ni b">function (column) { return column * column }</code>一样。</p><p id="eaa3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">虽然这个例子显然不现实，但是有一个通用的设计原则值得关注。有时，一个函数意味着被用作一个大F函数。它有一个名字，它被不同的代码调用，它是代码中的一级实体。</p><p id="37a7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但有时，函数是小f函数。它是要计算的表达式的简单表示。在上面的例子中，<code class="fe nq nr ns ni b">row</code>是一个大F函数，但是<code class="fe nq nr ns ni b">(column) =&gt; column * arguments[0]</code>是一个小F函数，它的存在只是为了给<code class="fe nq nr ns ni b">mapWith</code>一些应用。</p><p id="fa85" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">魔术变量适用于大F函数而不适用于小F函数，这使得使用小F函数作为语法更加容易，将它们视为可以传递给类似<code class="fe nq nr ns ni b">mapWith</code>的函数的表达式或块。</p></div></div>    
</body>
</html>