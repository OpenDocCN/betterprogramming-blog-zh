<html>
<head>
<title>Fuzzy String Matching With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现模糊字符串匹配</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fuzzy-string-matching-with-python-cafeff0d29fe?source=collection_archive---------0-----------------------#2020-06-20">https://betterprogramming.pub/fuzzy-string-matching-with-python-cafeff0d29fe?source=collection_archive---------0-----------------------#2020-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7320" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Levenshtein距离法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a54e8cd683ed8cc5b7e869b2c4b2f424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-If59bMMMtta_uGP_gObg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Henrik Lagercrantz 在<a class="ae kv" href="/s/photos/words-match?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="5e99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我在处理一个数据集，必须匹配字符串。我必须计算字符串匹配的百分比。因为我是用Python工作的，所以我知道肯定有它的库。</p><p id="e90d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管是什么，Python都有它的库！</p><p id="fdcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算机科学中有一个概念叫模糊字符串匹配。它是从字符串中匹配模式的技术。如果您拼错了一个单词，但有一个拼写正确的单词，您可以模糊字符串匹配并找到匹配的百分比。</p><p id="00e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将讨论如何在Python中模糊匹配字符串。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c407" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Python中的FuzzyWuzzy</h1><p id="5831" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在Python中处理字符串匹配问题时，可以导入<a class="ae kv" href="https://pypi.org/project/fuzzywuzzy/" rel="noopener ugc nofollow" target="_blank"> FuzzyWuzzy </a>。FuzzyWuzzy是一个Python库，它使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein距离</a>来计算一个简单易用的包中序列之间的差异。</p><p id="8444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用以下命令安装它:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="880a" class="nb ma iq mx b gy nc nd l ne nf">#for pip users<br/>pip install fuzzywuzzy</span><span id="73e0" class="nb ma iq mx b gy ng nd l ne nf">#for Jupyter notebook<br/>conda install -c conda-forge fuzzywuzzy</span></pre><p id="2419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装完这个库之后，有很多方法可以使用这个库进行字符串匹配。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0939" class="nb ma iq mx b gy nc nd l ne nf">from fuzzywuzzy import process, fuzz</span></pre><p id="d4a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经导入了上面的库。现在，让我们看看这个库的不同用例。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7110" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">模糊模块</h1><h2 id="4e91" class="nb ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated"><strong class="ak">简单比率</strong></h2><p id="ac6e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe ns nt nu mx b">ratio</code>方法比较整个字符串，并遵循两个字符串之间的标准Levenshtein距离相似性比率:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b6e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将比较整个字符串并输出匹配的百分比:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5b93" class="nb ma iq mx b gy nc nd l ne nf"><strong class="mx ir">[Output 0]: </strong>String Matched: 96</span><span id="b2fe" class="nb ma iq mx b gy ng nd l ne nf"><strong class="mx ir">[Output 1]: </strong>String Matched: 91</span><span id="4f27" class="nb ma iq mx b gy ng nd l ne nf"><strong class="mx ir">[Output 2]: </strong>String Matched: 100</span></pre><h2 id="7d1a" class="nb ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated"><strong class="ak">部分比率</strong></h2><p id="9e98" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe ns nt nu mx b">partial ratio</code>方法基于“最优部分”逻辑。如果考虑短串<em class="nx"> k </em>和长串<em class="nx"> m </em>，算法将通过匹配<em class="nx"> k </em>串的长度来评分:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="9820" class="nb ma iq mx b gy nc nd l ne nf">Str_Partial_Match = fuzz.partial_ratio('Hello World', 'Hello World!')<br/>print("String Matched:",Str_Partial_Match)</span><span id="592a" class="nb ma iq mx b gy ng nd l ne nf">Str_Partial_Match = fuzz.partial_ratio('Hello World', 'Hello world')<br/>print("String Matched:",Str_Partial_Match)</span></pre><p id="4676" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码将只寻找部分匹配。在第一种情况下，较小的字符串(<code class="fe ns nt nu mx b">Hello World</code>)将被查找到较大的字符串中，匹配将会发生。</p><p id="bb87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而在第二种情况下，字符串的长度是相同的，但是字母将被匹配:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="9886" class="nb ma iq mx b gy nc nd l ne nf"><strong class="mx ir">[Output 0]: </strong>String Matched: 100</span><span id="43cf" class="nb ma iq mx b gy ng nd l ne nf"><strong class="mx ir">[Output 1]: </strong>String Matched: 91</span></pre><h2 id="bf8b" class="nb ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated"><strong class="ak">令牌分类比率</strong></h2><p id="b146" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe ns nt nu mx b">token sort ratio</code>方法按字母顺序对标记进行排序。然后，应用简单的<code class="fe ns nt nu mx b">ratio</code>方法输出匹配的百分比:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="388d" class="nb ma iq mx b gy nc nd l ne nf">Str_Sort_Match = fuzz.token_sort_ratio('Hello World', 'Hello wrld')<br/>print("String Matched:",Str_Partial_Match)</span><span id="a709" class="nb ma iq mx b gy ng nd l ne nf">Str_Sort_Match = fuzz.token_sort_ratio('Hello World', 'world Hello')<br/>print("String Matched:",Str_Partial_Match)</span></pre><p id="377a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码将忽略单词的顺序。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="668a" class="nb ma iq mx b gy nc nd l ne nf"><strong class="mx ir">[Output 0]: </strong>String Matched: 95</span><span id="6348" class="nb ma iq mx b gy ng nd l ne nf"><strong class="mx ir">[Output 1]: </strong>String Matched: 100<br/></span></pre><h2 id="57d2" class="nb ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated"><strong class="ak">令牌设置比率</strong></h2><p id="56a3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe ns nt nu mx b">token set ratio</code>忽略重复的单词。它类似于<code class="fe ns nt nu mx b">sort ratio</code>方法，但更灵活。它基本上提取公共令牌，然后应用<code class="fe ns nt nu mx b">fuzz.ratio()</code>进行比较:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="cf16" class="nb ma iq mx b gy nc nd l ne nf">String_Matched=fuzz.token_set_ratio('Hello World', 'Hello Hello world')<br/>print(String_Matched)</span></pre><p id="03ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将忽略重复的值。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="fd12" class="nb ma iq mx b gy nc nd l ne nf"><strong class="mx ir">[Output 0]: </strong>100</span></pre><p id="3e60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是时候看看每种方法并进行比较了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="31c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我拿了两根弦。现在，我将使用每个模糊方法来了解字符串相似性:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="b411" class="nb ma iq mx b gy nc nd l ne nf"><strong class="mx ir">Ratio: </strong>57<strong class="mx ir"><br/>Partial_Ratio: </strong>77<strong class="mx ir"><br/>Token_Sort_Ratio: </strong>58<strong class="mx ir"><br/>Token_Set_Ratio: </strong>95</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8cc6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">过程模块</h1><h2 id="0870" class="nb ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated"><strong class="ak">提取</strong></h2><p id="7e1e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">来自<code class="fe ns nt nu mx b">process</code>模块的<code class="fe ns nt nu mx b">extract</code>方法计算字符串向量的相似性得分:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0e0c" class="nb ma iq mx b gy nc nd l ne nf">str2Match = "apple inc"<br/>strOptions = ["Apple Inc.","apple park","apple incorporated","iphone"]</span></pre><p id="9ca3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我必须将字符串列表(<code class="fe ns nt nu mx b">strOptions</code>)与<code class="fe ns nt nu mx b">str2Match</code>)进行匹配:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="46fb" class="nb ma iq mx b gy nc nd l ne nf">Ratios = process.extract(str2Match,strOptions)<br/>print(Ratios)</span></pre><p id="b444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">extract方法将根据与匹配字符串的相似性对列表中的每个字符串进行评分(<code class="fe ns nt nu mx b">str2Match</code>)。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="9b2d" class="nb ma iq mx b gy nc nd l ne nf"><strong class="mx ir">[Output 0]:</strong> [('Apple Inc.', 100), ('apple incorporated', 90), ('apple park', 67), ('iphone', 30)]</span></pre><h2 id="a946" class="nb ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated"><strong class="ak">提取一个</strong></h2><p id="020b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe ns nt nu mx b">extractOne</code>方法输出字符串向量中最相似的字符串及其分数:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="da39" class="nb ma iq mx b gy nc nd l ne nf">Ratios = process.extractOne(str2Match,strOptions)<br/>print(Ratios)</span></pre><p id="c54c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最相似的字符串将以这种方式输出:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1730" class="nb ma iq mx b gy nc nd l ne nf"><strong class="mx ir">[Output 0]:</strong> ('Apple Inc.', 100)</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c3d1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考</h1><ul class=""><li id="c2c6" class="ny nz iq ky b kz mr lc ms lf oa lj ob ln oc lr od oe of og bi translated"><a class="ae kv" href="https://www.datacamp.com/community/tutorials/fuzzy-string-python" rel="noopener ugc nofollow" target="_blank">Python中的模糊字符串匹配</a></li><li id="8257" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated"><a class="ae kv" href="https://github.com/seatgeek/fuzzywuzzy" rel="noopener ugc nofollow" target="_blank">模糊不清</a></li></ul><p id="add8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和平！</p></div></div>    
</body>
</html>