<html>
<head>
<title>React Components vs. React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件与React挂钩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-components-vs-react-hooks-52932d4ab6db?source=collection_archive---------3-----------------------#2019-10-11">https://betterprogramming.pub/react-components-vs-react-hooks-52932d4ab6db?source=collection_archive---------3-----------------------#2019-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">components类和React挂钩之间的区别列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/961286e888f682072de57bfe4e4d3f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ijet6kVJqGgul6adezDLQ.png"/></div></div></figure><p id="d0e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在过去的几个月里，我一直在钻研React hooks，这个新功能一经推出就引起了广泛的关注，直到现在我还没有花过多的时间来研究它。</p><p id="a2bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你在最近几个月被冷冻过，你可以在下面看到它们首次出现的对话:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="6a1f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">到目前为止我尝试了什么？</h1><p id="1d7b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">为了开始习惯使用<strong class="kw iu"> </strong> React钩子，我定义了一个具有以下特征的项目:</p><ul class=""><li id="684a" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">脸书登录</li><li id="44f4" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">对外部API的调用(特别是https://reqres.in/api的<a class="ae nk" href="https://reqres.in/api" rel="noopener ugc nofollow" target="_blank"/>，如果你想弄乱API调用，这是一个真正的发现)</li><li id="3161" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">通过Redux进行状态管理</li><li id="baf3" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">实体创建和编辑表单</li><li id="410d" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">通过React路由器和专用路由保护的应用程序路由</li><li id="b4ea" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">样式组件的使用</li></ul><p id="0401" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我用两种不同的方式发展它:</p><ul class=""><li id="77de" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">使用组件——即旧方法</li><li id="5c83" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">使用钩子——我发现在有趣的地方使用它们，用函数替换所有的类，利用<code class="fe nl nm nn no b">useEffect</code>和<code class="fe nl nm nn no b">useState</code>钩子</li></ul><p id="a825" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两种开发还有另一个不同之处:对于第一种开发，我以最纯粹的老派风格配置webpack。但对于第二种方式，我使用了create react app工具，以查看这两种方式中哪一种我感觉更舒服。(我最终选择了第二个选项，原因很简单，它允许我们忘记所有的初始配置和依赖项的安装。)</p><p id="2b4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我已经通过TypeScript编写了第二个项目，以便了解它是如何用钩子承载的。我尝试将它作为流和PropTypes的替代。</p><p id="b6c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总的来说，迁移很简单，尽管在输入时遇到了一些其他问题——正如所料。然而，它提供的错误预防使得这个工具对于相对较大的项目是有价值的。</p><p id="024f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我将写一份使用React hooks的第一次严肃体验的简要总结，列出我最喜欢的方面和那些比较复杂的方面。</p><p id="8c92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢看项目，你可以去文章的结尾，我给你留了两个到仓库的链接，这样你就可以看到完整的代码，从而直接看到不同之处。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="3750" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">我最喜欢React Hooks的地方是</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/0650f4b9238b1c28fd215139aa85a158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EDmA70zVQTD8nbau"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">照片由<a class="ae nk" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae nk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="3ae4" class="nu ma it bd mb nv nw dn mf nx ny dp mj ld nz oa ml lh ob oc mn ll od oe mp of bi translated">清除器代码</h2><p id="9b42" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在我看来，当你开始用基于钩子的功能组件替换类时，最引人注目的是代码看起来是多么的整洁和有组织。</p><p id="be50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上面的演示视频所示，行开始自动下降，功能被分组并按顺序排列，这使我们不必在不同部分之间跳转文件。</p><p id="6028" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，这也是React团队开发钩子的原因之一:</p><div class="og oh gp gr oi oj"><a href="https://reactjs.org/docs/hooks-intro.html#complex-components-become-hard-to-understand" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">介绍挂钩—反应</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">reactjs.org</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><h2 id="d172" class="nu ma it bd mb nv nw dn mf nx ny dp mj ld nz oa ml lh ob oc mn ll od oe mp of bi translated">再用</h2><p id="9ae0" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">不知道是不是因为开始用hooks实现项目的时候特别有动力，总体感觉是他们非常青睐代码重用。</p><p id="8eca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，在开发用户创建和编辑部分时，想到了利用<code class="fe nl nm nn no b">useReducer</code>钩子来维护表单状态的各种方法。你可以看到其中一个是在自定义钩子<code class="fe nl nm nn no b">useApiCall</code>中实现的，它负责管理调用外部API的整个过程。</p><p id="b093" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，我开始重新思考使用<a class="ae nk" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux Thunk </a>调用API的必要性。现在，我更多地沿着其他开发人员提出的路线，在组件中进行调用，并通过Redux将结果传递给动作。</p><p id="c206" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论如何，我的感觉是这个新功能打开了一个无限可能的世界。</p><h2 id="f0ce" class="nu ma it bd mb nv nw dn mf nx ny dp mj ld nz oa ml lh ob oc mn ll od oe mp of bi translated">使用效果</h2><p id="a423" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">对我来说，这是最强大和最有用的挂钩之一，因为它简化了我们的代码。</p><p id="0e10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以说<code class="fe nl nm nn no b">useEffect</code>是一个集合了以下类生命周期事件的一体化系统:<code class="fe nl nm nn no b">componentDidMount</code>、<code class="fe nl nm nn no b">componentDidUnmount</code>和<code class="fe nl nm nn no b">componentDidUpdate</code>。</p><p id="db6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过这种方式，多亏了<code class="fe nl nm nn no b">useEffect</code>，我们可以将过去在这些事件中复制的所有逻辑集中到一个方法中。我们可以这样做，因为我们传递的方法将总是在组件的每次渲染后执行。</p><p id="e183" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我建议您详细阅读文档以深入了解其特征，因为除了其他方面，我们还可以:</p><ul class=""><li id="0048" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">根据某些道具是否已经改变来决定是否要执行该效果</li><li id="050b" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">在执行效果之前，执行一个函数作为<code class="fe nl nm nn no b">cleanup</code></li><li id="cf60" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">仅在安装和卸载组件时执行该效果</li></ul><h2 id="254d" class="nu ma it bd mb nv nw dn mf nx ny dp mj ld nz oa ml lh ob oc mn ll od oe mp of bi translated">这</h2><p id="0aa2" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">钩子的集成和向功能组件的过渡带来的一个结果是避免了与变量<code class="fe nl nm nn no b">this</code>的斗争，这是许多开发人员，尤其是最初级的开发人员会喜欢的。</p><p id="9a3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">的确，随着<a class="ae nk" href="https://babeljs.io/docs/en/babel-plugin-proposal-class-properties" rel="noopener ugc nofollow" target="_blank">巴别塔插件</a>的到来，这个问题减少了很多，但是在我们开发的时候，不必担心它的价值是非常令人欣慰的(虽然，在我看来，在舒适中获胜不应该阻止学习它如何工作以及它的预期价值是什么)。</p><h2 id="a2a4" class="nu ma it bd mb nv nw dn mf nx ny dp mj ld nz oa ml lh ob oc mn ll od oe mp of bi translated">大量的例子</h2><p id="5a28" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">社区似乎非常鼓励发布钩子，并且已经有一些页面收集了最有趣的目录，例如:</p><div class="og oh gp gr oi oj"><a href="https://usehooks.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">使用挂钩</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">我们给你带来了简单易懂的React钩子代码，这样你就可以了解React钩子是如何工作的，并且感觉更舒服…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">usehooks.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ks oj"/></div></div></a></div><p id="76d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我建议您看一看，因为它可以让您了解其他开发人员是如何使用它们的——这总是很有用的。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1161" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">我最不喜欢React钩子的地方</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/6ce53b67a9e8356274cd1f72531cbc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nA--9JaSMWoY0J_Q"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">约瑟夫·格鲁恩塔尔在<a class="ae nk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="5cc0" class="nu ma it bd mb nv nw dn mf nx ny dp mj ld nz oa ml lh ob oc mn ll od oe mp of bi translated">学习曲线</h2><p id="955b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">现在让我们转到消极的方面，在我看来，我们获得的好处超过了消极的方面。但还是有必要提一下。</p><p id="6421" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，从用类组件编程跳到用钩子编程是一种范式转变。一开始，我们会先担心一些显而易见的事情，比如:</p><ul class=""><li id="d89b" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">用<code class="fe nl nm nn no b">useEffect</code>替换生命周期事件</li><li id="cae7" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">用<code class="fe nl nm nn no b">useState</code>钩子替换状态对象</li></ul><p id="b56c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我怀疑这更进一步，这种变化的背后是理解组件和使用它们的新方式，因为正如我在上一节中提到的，随着我们对它们越来越熟悉，我们将倾向于创建我们自己的定制钩子，并寻找超越简单合成变化的用途。</p><p id="1866" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，已经有收集社区创建的钩子的页面，React Router、Redux Forms或Redux本身等大型库采用它们只是时间问题。</p><p id="a301" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我想说，如果我们想从钩子带来的所有积极方面获益，那么转向使用钩子将是我们必须承担的额外努力。</p><h2 id="fe84" class="nu ma it bd mb nv nw dn mf nx ny dp mj ld nz oa ml lh ob oc mn ll od oe mp of bi translated">当心使用效果</h2><p id="079c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我认为使用钩子时的一个问题是你必须非常小心地使用<code class="fe nl nm nn no b">useEffect</code>,以避免下面的情况导致无限循环:</p><pre class="kj kk kl km gt pa no pb pc aw pd bi"><span id="c5fa" class="nu ma it no b gy pe pf l pg ph">const [item, setItem] = useState(null);</span><span id="f90a" class="nu ma it no b gy pi pf l pg ph">useEffect(() =&gt; {<br/>    const res = await fetch('fromSomeApi');<br/>    const json = await res.json;<br/>    setItem(json);<br/> })</span></pre><p id="deec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，在第一次渲染之后，将执行<code class="fe nl nm nn no b">useEffect</code>函数，在该函数中，通过使用<code class="fe nl nm nn no b">useState</code>钩子启动一个遵循相同过程的新渲染来调用修改状态的<code class="fe nl nm nn no b">setItem</code>方法，最终导致无限循环。</p><p id="c02c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说，强制渲染到<code class="fe nl nm nn no b">useEffect</code>将导致效果被重新执行到无限远。</p><p id="26e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个我们需要注意的方面是依赖于<code class="fe nl nm nn no b">useEffect</code>、<code class="fe nl nm nn no b">useCallback</code>和<code class="fe nl nm nn no b">useMemo</code>钩子的步骤，因为React需要以下规范:我们要在一个会改变的钩子中使用的所有东西，我们必须在第二个参数(甚至是函数)中作为依赖传递。</p><p id="4529" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了帮助我们遵守这条规则，React团队自己开发了一个<code class="fe nl nm nn no b">useMemo</code>插件来验证我们没有违反这条规则:</p><div class="og oh gp gr oi oj"><a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">eslint-plugin-react-hooks</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">React挂钩的ESLint规则</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">www.npmjs.com</p></div></div><div class="os l"><div class="pj l ou ov ow os ox ks oj"/></div></div></a></div><h2 id="9076" class="nu ma it bd mb nv nw dn mf nx ny dp mj ld nz oa ml lh ob oc mn ll od oe mp of bi translated">使用状态</h2><p id="81f0" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">最后，我还想提请注意<code class="fe nl nm nn no b">useState</code>挂钩的工作方式。第一次使用它时，您可能期望得到类似于<code class="fe nl nm nn no b">setState</code>的结果，但事实并非如此。</p><p id="ad48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您有以下内容:</p><pre class="kj kk kl km gt pa no pb pc aw pd bi"><span id="4327" class="nu ma it no b gy pe pf l pg ph">const [person, setPerson] = useState({name: '', email: ''});</span></pre><p id="f20b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当需要更新<code class="fe nl nm nn no b">person</code>对象的一个字段时，我们倾向于以与<code class="fe nl nm nn no b">setState</code>相同的方式使用<code class="fe nl nm nn no b">setPerson</code>，即:</p><pre class="kj kk kl km gt pa no pb pc aw pd bi"><span id="432d" class="nu ma it no b gy pe pf l pg ph">setPerson({ name: 'Gerardo' });</span></pre><p id="af6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望以此作为我们的状态:</p><pre class="kj kk kl km gt pa no pb pc aw pd bi"><span id="2c98" class="nu ma it no b gy pe pf l pg ph">{ name: 'Gerardo', email: ''}</span></pre><p id="cf2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们将得到的是:</p><pre class="kj kk kl km gt pa no pb pc aw pd bi"><span id="c203" class="nu ma it no b gy pe pf l pg ph">{ name: 'Gerardo' }</span></pre><p id="4410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为<code class="fe nl nm nn no b">setPerson</code>方法完全覆盖了对象。</p><p id="8d8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，从React文档来看，如果我们的状态变得非常复杂，我们建议使用<code class="fe nl nm nn no b">useReducer</code>钩子(尽管已经有第三方钩子允许我们以与使用<code class="fe nl nm nn no b">setState</code>相同的方式管理状态)。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="4f74" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">仓库</h1><p id="5974" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">正如我所说的，我将留给您两个存储库，以便您可以下载它们并更仔细地查看它们的差异。</p><p id="d300" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您时间紧迫，我建议您特别关注我开发的定制钩子<code class="fe nl nm nn no b">useApiCall</code>，以及它简化API调用和通过<code class="fe nl nm nn no b">useReducer</code>管理调用状态的方式。</p><p id="2671" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望它对你有用。</p><div class="og oh gp gr oi oj"><a href="https://github.com/ger86/learning-react-components" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">ger 86/学习-反应-组件</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">对组件进行反应。在GitHub上创建一个帐户，为ger 86/learning-react-components的开发做贡献。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="pk l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://github.com/ger86/learning-react-hooks" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">ger 86/学习-反应-挂钩</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">在GitHub上创建一个帐户，为ger86/learning-react-hooks的开发做贡献。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="pl l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>