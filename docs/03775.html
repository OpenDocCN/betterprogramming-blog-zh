<html>
<head>
<title>InlineConfigurable: Configuring Objects in Swift the Kotlin Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">InlineConfigurable:以Kotlin方式在Swift中配置对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/inlineconfigurable-configuring-objects-in-swift-the-kotlin-way-e26cc0a1e0d8?source=collection_archive---------26-----------------------#2020-03-03">https://betterprogramming.pub/inlineconfigurable-configuring-objects-in-swift-the-kotlin-way-e26cc0a1e0d8?source=collection_archive---------26-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通向更具可读性的Swift代码之路</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d97c4ae9cc2e1ee42682071cbcc34b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYz7ZVshP2vxRw-rRZX53g.png"/></div></div></figure><h1 id="17af" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">背景</h1><p id="bf9e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">作为一名Android和iOS开发者，我总是比较这两个平台及其特性。两者都有各自的优点和缺点，这使得发展如此令人兴奋。</p><p id="17b2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我经常发现自己想知道为什么一些很酷的特性在一种语言中实现了，而在另一种语言中却没有。所以在这篇短文中，我们将讨论Kotlin中名为<code class="fe mn mo mp mq b">apply</code>的内联函数，我们将在Swift中实现该函数。它帮助您在一个块中配置一个对象。您将看到它如何使您的代码更易于阅读。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="9a79" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">问题</h1><p id="2199" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你可能会想，“为什么我们需要斯威夫特的科特林的任何东西？”然而，我很有信心，你们大多数人在配置<code class="fe mn mo mp mq b">UITableView</code>时都遇到过这种混乱的<code class="fe mn mo mp mq b">viewDidLoad()</code> <strong class="lo iu"> </strong>方法:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="cc28" class="nh kv it mq b gy ni nj l nk nl">tableView.delegate = <strong class="mq iu">self<br/></strong>tableView.dataSource = <strong class="mq iu">self<br/></strong>tableView.tableFooterView = UIView()<br/>tableView.addSubview(refreshControl)<br/>tableView.separatorStyle = .none<br/>tableView.register(// register cell)<br/>tableView.register(// register cell)</span></pre><p id="a84e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">大多数人会认为这很正常，这段代码没有任何问题。当然，我是站在你这边的——这没什么不对。但是我内心的Android开发者想减少<code class="fe mn mo mp mq b">tableView</code> <strong class="lo iu"> </strong>变量的重复，把所有东西都放在一个块里面。让我们看看:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="5367" class="nh kv it mq b gy ni nj l nk nl">tableView.apply {<br/>    $0.delegate = <strong class="mq iu">self<br/>    </strong>$0.dataSource = <strong class="mq iu">self<br/>    </strong>$0.tableFooterView = UIView()<br/>    $0.addSubview(refreshControl)<br/>    $0.separatorStyle = .none<br/>    $0.register(// register cell)<br/>    $0.register(// register cell)<br/>}</span></pre><p id="1f3f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这看起来更干净，更容易阅读，不是吗？如果你不想阅读这个实现背后的理论，你可以跳过下一章直接进入实现。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="0b01" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated"><strong class="ak">内嵌函数</strong></h1><p id="5be9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">函数式编程的好处之一是能够将一个函数作为参数传递给另一个函数。在斯威夫特。我们称之为<code class="fe mn mo mp mq b">closure</code>，在科特林，它被称为<code class="fe mn mo mp mq b">lambdas</code>。<strong class="lo iu"> </strong>两个人都有各自的问题。</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="5983" class="nh kv it mq b gy ni nj l nk nl">//Kotlin<br/>sampleCollection.filter { it == 1 }</span><span id="a9a9" class="nh kv it mq b gy nn nj l nk nl">//Swift<br/>sampleCollection.filter { $0 == 1 }</span></pre><p id="2521" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在Swift中，您会遇到的最常见的闭包问题是当您没有正确使用它们时发生的保留循环。为了解决这个问题，我们在闭包中使用了<code class="fe mn mo mp mq b">strong</code>、<code class="fe mn mo mp mq b">weak</code>和<code class="fe mn mo mp mq b">unowned</code> <strong class="lo iu"> </strong>引用。</p><p id="b871" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在Kotlin中，这有点复杂，因为它仍然与Java紧密相连。你可以在这里阅读关于高阶函数(lambdas)的一般<a class="ae no" href="https://www.baeldung.com/kotlin-inline-functions" rel="noopener ugc nofollow" target="_blank">。我只讨论存在的一些问题。</a></p><p id="c632" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第一个问题是函数调用开销。如果我们使用上面显示的<code class="fe mn mo mp mq b">filter</code>函数，为了实际执行Kotlin lambda中封装的操作，需要在实例上额外调用一个名为<code class="fe mn mo mp mq b">invoke</code>的特殊方法。由于额外的调用，结果是更多的开销。</p><p id="f4f2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">另一个问题是内存开销。我不想深入探讨，但是大多数时候，JVM在每次调用时都会创建一个函数类型的实例。换句话说，每次我们声明一个lambda，就会创建一个<code class="fe mn mo mp mq b">Function*</code>类型的特殊对象来封装lambda中的代码——从而产生内存开销。</p><p id="27e2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">Kotlin中的关键字<code class="fe mn mo mp mq b">inline</code> <strong class="lo iu"> </strong>可以解决这两个问题，它声明了一个内联函数。使用内联函数时，编译器内联函数体。也就是说，它将主体直接替换到函数被调用的地方。</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="a982" class="nh kv it mq b gy ni nj l nk nl">val numbers = listOf(1, 2, 3, 4, 5)<br/>numbers.each { println(it) }</span></pre><p id="ad94" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上述内容被替换为以下内容:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="e670" class="nh kv it mq b gy ni nj l nk nl">val numbers = listOf(1, 2, 3, 4, 5)<br/>for<!-- --> <!-- -->(number in numbers) {<br/>    println(number)<br/>}</span></pre><p id="8fbd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当使用内联函数时，没有额外的对象分配，也没有额外的虚方法调用，因为我们不是处理lambda，而是将lambda中的代码提取到相应的位置。</p><p id="5e57" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你可能会说，“不，我不需要这种内嵌的东西，因为它不在Swift中。”令人惊讶的是，Swift中也存在内联函数；然而，<code class="fe mn mo mp mq b">@inline</code>关键字是被禁止的。它做的事情与Kotlin中的一样——它用函数的内容替换函数调用，从而减少额外的函数调用开销。阅读<a class="ae no" href="https://swiftrocks.com/the-forbidden-inline-attribute-in-swift.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a>了解更多信息。</p><p id="f513" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">事实证明，在Swift中还有另一种处理行内函数的方式。我们可以称之为函数内部的函数或<em class="nm">嵌套函数。</em>让我们来看看这个例子。</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="1437" class="nh kv it mq b gy ni nj l nk nl"><strong class="mq iu">class</strong> SomeViewController: UIViewController {</span><span id="b810" class="nh kv it mq b gy nn nj l nk nl">    <strong class="mq iu">override</strong> <strong class="mq iu">func</strong> viewDidLoad() {<br/>        <strong class="mq iu">super</strong>.viewDidLoad()<br/>        <br/>        func initHeader() {<br/>            //...<br/>        }</span><span id="6873" class="nh kv it mq b gy nn nj l nk nl">        func initContent() {<br/>            //...<br/>        }</span><span id="268c" class="nh kv it mq b gy nn nj l nk nl">        func initFooter() {<br/>            //...<br/>        }</span><span id="8b86" class="nh kv it mq b gy nn nj l nk nl">        initHeader()<br/>        initContent()<br/>        initFooter()<br/>    }<br/>}</span></pre><p id="1b4c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你可以在这里找到关于这种方法<a class="ae no" href="https://medium.com/@GalvinLi/tinyexperience-when-to-use-inline-function-1c88de4b7ea5" rel="noopener">的更多信息。</a></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="5843" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated"><strong class="ak">在Swift中实施</strong></h1><p id="8ab5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Kotlin中有许多内联扩展函数，但是今天我们只实现一个叫做<code class="fe mn mo mp mq b">apply </code>的函数，它可以帮助你在一个块中配置对象(closure/lambda)。</p><p id="50e7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在Kotlin中，<code class="fe mn mo mp mq b">apply</code>是一个特定类型的扩展函数，它将自己的作用域设置为调用它的对象。<code class="fe mn mo mp mq b">apply</code>对表达式中的对象引用运行，并在完成时返回对象引用。当然，它不仅用于设置属性，还能够在返回之前评估复杂的逻辑。最后，它返回同一个对象，只是做了一些修改。这是它在科特林的样子:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="ac2d" class="nh kv it mq b gy ni nj l nk nl">inline fun T.apply(block: T.() -&gt; Unit): T {<br/>    block()<br/>    return this<br/>}</span></pre><p id="ee10" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在让我们在Swift中实现它。这很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b84d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">迄今为止我们所做的:</p><ul class=""><li id="bdc7" class="nr ns it lo b lp mi ls mj lv nt lz nu md nv mh nw nx ny nz bi translated">我们声明了<code class="fe mn mo mp mq b">InlineConfigurable</code> <strong class="lo iu"> </strong>协议，然后由<code class="fe mn mo mp mq b">NSObject</code> <strong class="lo iu">实现。为了能够使用它，其他类实际上也可以实现这个协议。</strong></li><li id="9b17" class="nr ns it lo b lp oa ls ob lv oc lz od md oe mh nw nx ny nz bi translated">我们编写了一个名为<code class="fe mn mo mp mq b">apply</code> <strong class="lo iu"> </strong>的扩展函数，并使用了一个名为<code class="fe mn mo mp mq b">configurator</code>的闭包。这个闭包可以有任何类型的逻辑。</li><li id="c51e" class="nr ns it lo b lp oa ls ob lv oc lz od md oe mh nw nx ny nz bi translated">我们在这个对象引用上执行了这个逻辑</li><li id="95a9" class="nr ns it lo b lp oa ls ob lv oc lz od md oe mh nw nx ny nz bi translated">我们归还了物品</li></ul><p id="eae5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，您可以随时随地轻松使用名为<code class="fe mn mo mp mq b">apply</code> <strong class="lo iu"> </strong>的功能。例如，你可以在一个程序块内配置你的<code class="fe mn mo mp mq b">UIView</code> <strong class="lo iu"> </strong>:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="57f2" class="nh kv it mq b gy ni nj l nk nl">containerView.apply {<br/>    $0.layer.borderColor = ColorConstants.borderBackground.cgColor<br/>    $0.layer.borderWidth = 1<br/>    $0.layer.cornerRadius = NumberConstants.cornerRadius<br/>    $0.layer.masksToBounds = <strong class="mq iu">true<br/></strong>}</span></pre><p id="aa81" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">任何类型都可以实现该协议，以便从<code class="fe mn mo mp mq b">apply</code>功能中获益。然而，我发现通过<code class="fe mn mo mp mq b">NSObject</code>实现在大多数情况下是足够的，因为它帮助你处理<code class="fe mn mo mp mq b">UIView</code>实例，并且这种重复的变量调用行为通常与<code class="fe mn mo mp mq b">UIView</code> <strong class="lo iu">相关联。</strong></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="8e99" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated"><strong class="ak">总结</strong></h1><p id="1666" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一般来说，内联函数在效率和性能方面非常出色。</p><p id="f9b5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，正如我们之前讨论的，它们在Swift中是被禁止的(也许只是现在)。尽管本文中在Swift中实现的<code class="fe mn mo mp mq b">apply</code> <strong class="lo iu"> </strong>函数并不是真正的内联函数，但它通过减少源文件中的噪音和使代码更具可读性而大有帮助。</p></div></div>    
</body>
</html>