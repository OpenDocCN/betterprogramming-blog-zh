<html>
<head>
<title>How To Never Accidentally Crash a UITableView Again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免UITableView再次意外崩溃</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-13-be-dynamic-with-diffabledatasource-56ed938a0325?source=collection_archive---------0-----------------------#2019-07-19">https://betterprogramming.pub/ios-13-be-dynamic-with-diffabledatasource-56ed938a0325?source=collection_archive---------0-----------------------#2019-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="05fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">介绍<code class="fe ki kj kk kl b">DiffableDataSource</code></h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/09c099a43941bfb448133a5d209bb8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnfUf0Slzc6LYI-4945W8g.jpeg"/></div></div></figure><h1 id="bbcf" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated"><strong class="ak">概述</strong></h1><blockquote class="lq lr ls"><p id="f3a3" class="lt lu lv lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">尝试将第144行插入节0，但更新后节0中只有0行。</p></blockquote><p id="0a2d" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">我想没有一个iOS开发者之前没见过这种崩溃。最后，在十多年后，苹果决定给出一个体面的解决方案，来解决我们在表格和集合视图上遇到的最令人沮丧的问题之一——动画化集合的变化。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="247c" class="ky kz it bd la lb na ld le lf nb lh li jz nc ka lk kc nd kd lm kf ne kg lo lp bi translated"><strong class="ak">苹果在这里混合了一点SwiftUI的概念</strong></h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e6bec6315aaa7b29eda0748cb8ff1ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*XLTR2WyvIUPitq2NP4oKHQ.jpeg"/></div></figure><p id="3217" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">与SwiftUI一起发布的<code class="fe ki kj kk kl b">DiffableDataSource</code>并非巧合。旧的好的<code class="fe ki kj kk kl b">UITableViewDataSource</code>协议基于两种方法——<code class="fe ki kj kk kl b">cellForRow</code>和<code class="fe ki kj kk kl b">numberOfRows</code>——只处理单元和索引路径，<code class="fe ki kj kk kl b">DiffableDataSource</code>被附加到数据本身，并且可以在<code class="fe ki kj kk kl b">Hashable</code>协议的帮助下区分数据项。</p><p id="07a8" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">就像SwiftUI一样，<code class="fe ki kj kk kl b">DiffableDataSource</code>有一种机制，可以在为您计算数据差异的同时应用更改，并几乎自动地将UI转换到新的状态，并带有漂亮的动画。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="ca0c" class="ky kz it bd la lb na ld le lf nb lh li jz nc ka lk kc nd kd lm kf ne kg lo lp bi translated"><strong class="ak">巧妙应用变化；这只是冰山一角</strong></h1><p id="9186" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">苹果向我们出售<code class="fe ki kj kk kl b">DiffableDataSource</code>作为insertRowsAtIndexPath崩溃的解决方案。事实上，它改变了集合处理数据的整个方式，从准备数据项、创建单元格、重新加载特定单元格开始，一直到处理刷新集合的外部服务。</p><p id="9131" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">当你第一次接近<code class="fe ki kj kk kl b">DiffableDataStructure</code>时，你需要暂时忘记<code class="fe ki kj kk kl b">UITableDatasource</code> / <code class="fe ki kj kk kl b">UICollectionViewDatasource</code>是如何工作的，因为<code class="fe ki kj kk kl b">DiffableDataStructure</code>是完全不同的东西。</p><p id="70f1" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">以下是使用<code class="fe ki kj kk kl b">DiffableDataSource</code>时的主要步骤:</p><ol class=""><li id="8e67" class="nl nm it lw b lx ly ma mb mq nn mr no ms np mp nq nr ns nt bi translated">准备符合<code class="fe ki kj kk kl b">Hashable</code>协议的数据项。</li><li id="0662" class="nl nm it lw b lx nu ma nv mq nw mr nx ms ny mp nq nr ns nt bi translated">创建为集合生成单元格的数据源。</li><li id="3891" class="nl nm it lw b lx nu ma nv mq nw mr nx ms ny mp nq nr ns nt bi translated">创建一个快照并用数据项填充它。</li><li id="52fa" class="nl nm it lw b lx nu ma nv mq nw mr nx ms ny mp nq nr ns nt bi translated">通过修改快照并将其应用于数据源来响应更改。</li></ol></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="d9c6" class="ky kz it bd la lb na ld le lf nb lh li jz nc ka lk kc nd kd lm kf ne kg lo lp bi translated"><strong class="ak">数据项</strong></h1><p id="1352" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">快照必须与符合<code class="fe ki kj kk kl b">Hashable</code>的数据项一起工作才能发挥它们的魔力。这听起来可能微不足道，但事实并非总是如此。有时，开发人员创建更多的动态数据源，这些数据源依赖于一些逻辑，而不是结构或对象的列表。例如，<code class="fe ki kj kk kl b">if indexPath.row == 0 { // show something // )</code>是一个常见的用例。在这里，我们需要创建数据项，并根据它们的类型定义数据源和快照。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">不同数据源的模型</p></figure><p id="832c" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">由于枚举成员值和Swift基本类型(String，Int..)都符合<code class="fe ki kj kk kl b">Hashable</code>协议，完成这个任务并不难。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="3314" class="ky kz it bd la lb na ld le lf nb lh li jz nc ka lk kc nd kd lm kf ne kg lo lp bi translated"><strong class="ak">新数据源</strong></h1><p id="641d" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">于是数据源对象替换了符合<code class="fe ki kj kk kl b">UITableViewDataSource</code>的对象，使用起来非常简单。</p><p id="d120" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">你需要做的就是:</p><ol class=""><li id="1047" class="nl nm it lw b lx ly ma mb mq nn mr no ms np mp nq nr ns nt bi translated">声明数据源的两种类型—节类型和行类型。</li></ol><p id="93ad" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">2.分配数据源，并在闭包中根据行类型返回单元格。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">创建数据源</p></figure><p id="d6bb" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">保留对此数据源的引用，因为您将需要它来应用快照。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="d10f" class="ky kz it bd la lb na ld le lf nb lh li jz nc ka lk kc nd kd lm kf ne kg lo lp bi translated"><strong class="ak">使用快照</strong></h1><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">创建快照</p></figure><p id="ce68" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">我们创建了数据源，但是我们没有给它任何数据来处理。因此，如果您想填充数据源，快照是一个不错的选择。</p><p id="951d" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">创建一个与数据源使用相同类型的<code class="fe ki kj kk kl b">NSDiffableDataSourceSnapshot</code>,将项目添加到快照中，并在数据源中应用更改。</p><p id="6e47" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">快照不仅仅可以添加项目和部分。他们还可以移动、删除和重新加载数据源中的项目。</p><p id="23d0" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">工作方法是您可以获取数据源中显示的当前快照并修改它，或者您可以创建一个新的快照并将其应用到您的数据源。</p><p id="47d5" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">此外，您不必保留对传递到快照的对象的引用—一旦传递了这些对象，您的数据源和快照对象就有了对它们的引用。</p><p id="007b" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">现在，我们来谈谈常见的用例，以及如何用快照来实现它们。</p><h2 id="2d7a" class="of kz it bd la og oh dn le oi oj dp li mq ok ol lk mr om on lm ms oo op lo oq bi translated"><strong class="ak">为您的收藏创建初始数据:</strong></h2><p id="9ff3" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">要显示数据，数据源对象需要快照。创建快照，向其中添加数据，然后将其添加到数据源。</p><p id="dc0b" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">注意:快照需要至少一个节才能工作，所以只需添加一个枚举值作为节，以防数据是平面的。</p><p id="db06" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">通常，最好创建一个既接受数据结构又接受快照的函数，并用条目填充快照。</p><h2 id="c4ec" class="of kz it bd la og oh dn le oi oj dp li mq ok ol lk mr om on lm ms oo op lo oq bi translated"><strong class="ak">添加、删除或移动快照中的项目:</strong></h2><p id="2043" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">要更改当前列表，您不必创建新的快照。只需从数据源(<code class="fe ki kj kk kl b">datasource.snapshot()</code>)中检索当前快照，并进行相关更改。</p><p id="e35d" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">如果您想向快照添加一个项目，使用一个<code class="fe ki kj kk kl b">snapshot.appendItems()</code>并传递项目列表和部分。</p><p id="35da" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">如果您想在列表中的特定位置插入一个项目，请使用<code class="fe ki kj kk kl b">snapshot.insertItems</code>。</p><p id="d0a0" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">要删除项目，使用<code class="fe ki kj kk kl b">snapshot.deleteItems()</code>并传递要删除的项目列表。</p><h2 id="117f" class="of kz it bd la og oh dn le oi oj dp li mq ok ol lk mr om on lm ms oo op lo oq bi translated"><strong class="ak">我想重新加载特定的单元格</strong></h2><p id="6788" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">不过，重新加载一个单元格有点棘手。您可以将修改过的项传递给快照，但是当生成单元的闭包运行时，它将传递旧的项。(我不知道这是一个错误还是有意为之，但这就是它的工作方式。)解决方案是始终保留一个更新的数据存储，并在传递到快照之前按ID获取项目。</p><h2 id="813a" class="of kz it bd la og oh dn le oi oj dp li mq ok ol lk mr om on lm ms oo op lo oq bi translated"><strong class="ak">我想用新数据替换当前数据</strong></h2><p id="5c8e" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">如果识别新的更改太复杂，或者您只想用新数据重新加载集合，只需创建一个新的快照，用您想要的内容填充它，并将其应用到数据源。如果当前快照中存在新快照中存在的项目，那么datasource足够智能，可以用一个漂亮的动画来应用这些更改。</p><h2 id="f698" class="of kz it bd la og oh dn le oi oj dp li mq ok ol lk mr om on lm ms oo op lo oq bi translated"><strong class="ak">如何响应选择项目、布局…？</strong></h2><p id="33b7" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">我们说<code class="fe ki kj kk kl b">DiffableDataSource</code>只取代了<code class="fe ki kj kk kl b">UITableViewDataSource</code>。您仍然可以在<code class="fe ki kj kk kl b">DiffableDataSource</code>旁边使用<code class="fe ki kj kk kl b">UITableViewDelegate</code>，并像以前一样实现<code class="fe ki kj kk kl b">didSelectRow</code>。</p><h2 id="5659" class="of kz it bd la og oh dn le oi oj dp li mq ok ol lk mr om on lm ms oo op lo oq bi translated">计算变化似乎是一项繁重的任务。我能从后台线程调用它吗？</h2><p id="e536" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">是的，你可以！不过我不确定这是否有必要，因为看起来苹果工程师在这方面做得很好。你只需要记得让它保持一致；如果从后台线程调用它，只需确保对特定数据源的所有调用都是从后台线程调用的。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="f469" class="ky kz it bd la lb na ld le lf nb lh li jz nc ka lk kc nd kd lm kf ne kg lo lp bi translated"><strong class="ak">我需要支持iOS 12 </strong></h1><p id="fba4" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">欢迎来到现实；在接下来的一年里，你可能需要支持iOS 12用户，所以关于向后兼容性的一些提示:</p><p id="0199" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">仅在iOS 12中将<code class="fe ki kj kk kl b">UITableViewDataSource</code>设置为表格视图。否则，表格视图将在iOS 13中处理两个数据源，而这不是您想要的。</p><p id="f8f0" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">将<code class="fe ki kj kk kl b">UITableViewDataSource</code>移动到不同的类别。这不是强制性的，但是当你需要支持两种不同的API时，最好让你的生活更简单。</p><p id="6c88" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">如果iOS 12中的变化动画对你来说太复杂，就用<code class="fe ki kj kk kl b">UITableView.reloadData()</code>的方法，给iOS 13用户留下更好的体验。iOS 13新版本的采用速度非常快，几个月后iOS 13将成为最受欢迎的iOS版本。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7878" class="ky kz it bd la lb na ld le lf nb lh li jz nc ka lk kc nd kd lm kf ne kg lo lp bi translated"><strong class="ak">所以，这就是不合适视图的稳定性问题的终结，对吗？</strong></h1><p id="9fb1" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated">嗯，差不多了。只要你采取有意义的行动，你就是安全的。但是你还是可以用<code class="fe ki kj kk kl b">DiffableTableView</code>让应用崩溃。</p><p id="9847" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">如何使其崩溃的一些例子:</p><ol class=""><li id="0c00" class="nl nm it lw b lx ly ma mb mq nn mr no ms np mp nq nr ns nt bi translated">向不存在的部分添加项目</li><li id="0c68" class="nl nm it lw b lx nu ma nv mq nw mr nx ms ny mp nq nr ns nt bi translated">删除项目，然后重新加载它</li><li id="b1a5" class="nl nm it lw b lx nu ma nv mq nw mr nx ms ny mp nq nr ns nt bi translated">在根本没有节的情况下添加项目</li><li id="75e8" class="nl nm it lw b lx nu ma nv mq nw mr nx ms ny mp nq nr ns nt bi translated">移动不在快照中的项目</li></ol><p id="156b" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc mq me mf mg mr mi mj mk ms mm mn mo mp im bi translated">我能想到更多的例子，但你明白了。不要在App Store上尝试:)</p><h1 id="47f3" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated"><strong class="ak">总结</strong></h1><p id="2bb6" class="pw-post-body-paragraph lt lu it lw b lx ng ju lz ma nh jx mc mq ni mf mg mr nj mj mk ms nk mn mo mp im bi translated"><code class="fe ki kj kk kl b">DiffableDataSource</code>一定能让你的生活更轻松，给你的用户更好的用户体验。一些挑战随之而来——你需要调整你的应用模式(MVVM/MVP/VIPER/MVC)，看看它如何与新的API集成，对你的模型进行更改，当然，至少在明年仍然支持iOS 12。</p></div></div>    
</body>
</html>