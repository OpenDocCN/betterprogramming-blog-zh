<html>
<head>
<title>Java to C# – C# to Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java到c#–c#到Java</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/java-to-c-c-to-java-f766c9f659c4?source=collection_archive---------0-----------------------#2019-09-06">https://betterprogramming.pub/java-to-c-c-to-java-f766c9f659c4?source=collection_archive---------0-----------------------#2019-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c686" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们带给你一个非常需要的罗塞塔石碑——这两种技术之间的解释性桥梁</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/648764d422314646a4134e59d2d71d40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPMRj_Jbt3DP6Tw89KWRiQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@dtopkin1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">戴恩·托普金</a>在<a class="ae ky" href="https://unsplash.com/search/photos/sheet-music?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ba11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java和C#非常相似。这两种语言都有点源自C++和相似的基本原则。</p><p id="5f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java开发于1995年，旨在创建一种编程模型比C++更简单的语言，同时仍保留一些相同的语言语法，以方便开发人员过渡到Java。</p><p id="4aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">C#是微软在2000年开发的，是其。NET drive，以便开发一种语言和一套技术来解决C++语言的一些已知弱点。它的开发也受到了Java语言的大量“启发”。</p><p id="ed32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这两种语言之间有相似之处，并且有一些共同点，但是对于精通一种技术的开发人员来说，从一种技术转换到另一种技术可能会非常棘手。</p><p id="a682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当不同思维模式的人合作时，创新会发生得最好——然而C#和Java的用户可能有点部落主义。</p><p id="dbd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我认为有必要编写一份指南，帮助人们思考或开始在这两种技术之间进行转换。在某种程度上促进这两个世界之间的更多合作也是很好的——希望尽我的一份力量来缩小它们之间存在的不必要的鸿沟。</p><h2 id="5d0c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">有一些相似之处:</h2><p id="bf72" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java是一种运行在<a class="ae ky" href="https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722" rel="noopener">虚拟机环境(JVM) </a>中的语言，运行Java编译器生成的<em class="mt">字节码</em>。</p><p id="c6e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于C#来说，情况也差不多。这是一种运行在<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/getting-started/introduction-to-the-csharp-language-and-the-net-framework" rel="noopener ugc nofollow" target="_blank">上的语言。NET框架</a>和CLR运行时。它使用一种类似于Java字节码的中间语言，叫做MSIL，通过CLR运行。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="5c6f" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">命名和约定</h1><p id="c506" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">术语、语法和约定方面的一些关键且最明显的差异是:</p><ul class=""><li id="56ba" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">“项目”(Java)——“解决方案”(C#)</li><li id="7348" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">在Java中，方法使用lower case(<code class="fe oa ob oc od b">bar.doAThing()</code>)，而在C#中，公共方法使用PascalCase ( <code class="fe oa ob oc od b">bar.DoAThing()</code>)</li><li id="1824" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">在C#中，接口总是以I为前缀，如在<code class="fe oa ob oc od b">IUserService&lt;T&gt;</code>中，而不是在Java中的<code class="fe oa ob oc od b">UserService&lt;T&gt;</code> <strong class="lb iu"> </strong></li><li id="86c0" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">在Java中，字符串是一个<code class="fe oa ob oc od b">String</code><strong class="lb iu"/>——在C#中，字符串是一个<code class="fe oa ob oc od b">string</code></li><li id="df3c" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">“POJO”(Java)—“POCO”(c#)</li><li id="ffcd" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">包(Java) —名称空间(C#)</li></ul><p id="758e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">包(Java) </strong></p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="3c4b" class="lv lw it od b gy oi oj l ok ol">package dev.andymacdonald;</span><span id="cc67" class="lv lw it od b gy om oj l ok ol">// Code goes here</span></pre><p id="96a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">命名空间(C#) </strong></p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="53e2" class="lv lw it od b gy oi oj l ok ol">namespace Dev.AndyMacdonald <br/>{<br/>  // Code goes here<br/>}</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="45f3" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">句法</h1><h2 id="249e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Java有<code class="fe oa ob oc od b">final</code>变量——C #有<code class="fe oa ob oc od b">readonly</code></h2><p id="7e13" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这里的一个关键区别是Java <code class="fe oa ob oc od b">final</code>变量可以在类中的任何地方赋值一次，而C#的<code class="fe oa ob oc od b">readonly</code>变量只能在构造函数中赋值。</p><h2 id="85a0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">C#有<code class="fe oa ob oc od b">out</code>和<code class="fe oa ob oc od b">ref</code>参数允许通过引用传递参数——Java没有</h2><p id="35ac" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java实际上并不通过方法参数中的引用来传递。</p><p id="d440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以通过引用操作对象和变量，但是在方法中，这些参数是通过值传递的。使用C#，我们可以用<code class="fe oa ob oc od b">out</code>和<code class="fe oa ob oc od b">ref</code>关键字来覆盖这种行为。</p><h2 id="01a3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">注释(Java)-属性(C#)</h2><p id="3dcc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这些基本上是等价的概念，只是实际语法不同。注释和属性都可以通过每种语言各自的反射API实现来访问。</p><p id="f590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java注释:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="3c6e" class="lv lw it od b gy oi oj l ok ol">@PersonallyIdentifiable<br/>private String fullName;</span></pre><p id="b77b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">C#属性:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="f252" class="lv lw it od b gy oi oj l ok ol">[PersonallyIdentifiable]<br/>private string fullName;</span></pre><h2 id="605f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Lombok项目的Getters和setter(Java)-C #属性</h2><p id="6aa7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">C#凭借其内置的<a class="ae ky" href="https://www.tutorialspoint.com/csharp/csharp_properties.htm" rel="noopener ugc nofollow" target="_blank">属性</a> <em class="mt"> </em>特性真正超越了Java。在标准JDK中，没有与此等效的方法，相反，在Java中，必须为每个需要访问器的字段编写getters和setters。</p><p id="6528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些通常只是由开发人员用他们的IDE作为一个欺骗来生成的…尽管还是有点乏味。</p><p id="bef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java getters和setters:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="0009" class="lv lw it od b gy oi oj l ok ol"><br/>public class Element <br/>{<br/>   <br/>  private String symbol;   <br/>  private String name;   <br/>  private int atomicNumber;</span><span id="6797" class="lv lw it od b gy om oj l ok ol">  public int getAtomicNumber() <br/>  {<br/>    return this.atomicNumber;<br/>  }</span><span id="72de" class="lv lw it od b gy om oj l ok ol">  public String getSymbol() <br/>  {<br/>    return this.symbol;<br/>  }</span><span id="df38" class="lv lw it od b gy om oj l ok ol">  public String getName() <br/>  {<br/>    return this.name; <br/>  }</span><span id="dafd" class="lv lw it od b gy om oj l ok ol">  public void setAtomicNumber(int atomicNumber) <br/>  {<br/>    this.atomicNumber = atomicNumber;<br/>  }</span><span id="dbb7" class="lv lw it od b gy om oj l ok ol">  public void setName(String name) <br/>  {<br/>    this.name = name;<br/>  }</span><span id="1e43" class="lv lw it od b gy om oj l ok ol">  public void setSymbol(String symbol) <br/>  {<br/>    this.symbol = symbol;<br/>  }</span><span id="29af" class="lv lw it od b gy om oj l ok ol">}</span></pre><p id="d82d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多Java项目合并了<a class="ae ky" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Project Lombok，</a>Project Lombok在编译时添加了getters、setters、equals和hash代码(以及其他有用的样板文件)。</p><p id="d186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lombok项目—不是标准库的一部分:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c14e" class="lv lw it od b gy oi oj l ok ol">@Getter @Setter<br/>public class Element <br/>{<br/>   <br/>  private String symbol;   <br/>  private String name;   <br/>  private int atomicNumber;</span><span id="b839" class="lv lw it od b gy om oj l ok ol">}</span></pre><p id="562b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">C#内置属性功能:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2148" class="lv lw it od b gy oi oj l ok ol">public class Element <br/>{</span><span id="c5e3" class="lv lw it od b gy om oj l ok ol">  public string Symbol { get; set; }     <br/>  public string Name { get; set; }     <br/>  public int AtomicNumber { get; set; }</span><span id="74e3" class="lv lw it od b gy om oj l ok ol">}</span></pre><h2 id="7a19" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak"> <em class="on">循环</em> </strong></h2><p id="1cec" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">每个循环的Java:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="762e" class="lv lw it od b gy oi oj l ok ol">List&lt;Integer&gt; fibNumbers = Arrays.asList(0, 1, 1, 2, 3, 5, 8, 13);<br/>int count = 0;<br/>for (int element: fibNumbers)<br/>{<br/>    count++;<br/>    System.out.println(String.format("Element #%s: %s", count, element));<br/>}<br/>System.out.println(String.format("Number of elements: %s", count));</span></pre><p id="9b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个循环的C#:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="b756" class="lv lw it od b gy oi oj l ok ol">var fibNumbers = new List&lt;int&gt; { 0, 1, 1, 2, 3, 5, 8, 13 };<br/>int count = 0;<br/>foreach (int element in fibNumbers)<br/>{<br/>    count++;<br/>    Console.WriteLine($"Element #{count}: {element}");<br/>}<br/>Console.WriteLine($"Number of elements: {count}");</span></pre><h2 id="794e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak"> <em class="on">实现接口/继承</em> </strong></h2><p id="7a29" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这两种语言的继承和实现接口并没有太大的不同。Java使用<code class="fe oa ob oc od b">extends</code>或<code class="fe oa ob oc od b">implements</code>关键字；C#使用C++语法(派生声明)<code class="fe oa ob oc od b">B : A</code>来定义继承。</p><p id="2feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用Java中的方法定义和实现接口:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="90a1" class="lv lw it od b gy oi oj l ok ol">package dev.andymacdonald;<br/><br/><br/>import java.util.ArrayList;<br/>import java.util.List;<br/><br/>interface Fish<br/>{<br/>   void swim();<br/>}<br/><br/>class Salmon implements Fish<br/>{<br/><br/>   public void swim()<br/>   {<br/>      System.<em class="mt">out</em>.println("Salmon.Fish");<br/>   }<br/>}<br/><br/>class Cod implements Fish<br/>{<br/>   public void swim()<br/>   {<br/>      System.<em class="mt">out</em>.println("Cod.Swim");<br/>   }<br/>}<br/><br/>public class Program<br/>{<br/>   public static void main()<br/>   {<br/>      List&lt;Fish&gt; fishes = new ArrayList&lt;&gt;();<br/>      fishes.add(new Salmon());<br/>      fishes.add(new Cod());<br/><br/>      for (Fish fish : fishes)<br/>      {<br/>         fish.swim();<br/>      }<br/>   }<br/>}</span></pre><p id="c6ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用C#中的方法定义和实现接口:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="cab5" class="lv lw it od b gy oi oj l ok ol">using System;<br/>using System.Collections.Generic;</span><span id="cf11" class="lv lw it od b gy om oj l ok ol">namespace Dev.AndyMacdonald <br/>{<br/>    interface Fish<br/>    {<br/>        void Swim();<br/>    }</span><span id="66a4" class="lv lw it od b gy om oj l ok ol">    class Salmon : Fish<br/>    {<br/>        public void Swim()<br/>        {<br/>            Console.WriteLine("Salmon.Fish");<br/>        }<br/>    }</span><span id="b1db" class="lv lw it od b gy om oj l ok ol">    class Cod : Fish<br/>    {<br/>        public void Swim()<br/>        {<br/>            Console.WriteLine("Cod.Swim");<br/>        }<br/>    }</span><span id="1df2" class="lv lw it od b gy om oj l ok ol">    class Program<br/>    {<br/>        static void Main()<br/>        {<br/>            List&lt;Fish&gt; fishes = new List&lt;Fish&gt;();<br/>            fishes.Add(new Salmon());<br/>            fishes.Add(new Cod());<br/>            foreach (Fish fish in fishes)<br/>            {<br/>                fish.Swim();<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h2 id="ed77" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak"> <em class="on">指针</em> </strong></h2><p id="02a7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">很简单，Java不做指针，而在C#中可以做指针算术和操作。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="190e" class="lv lw it od b gy oi oj l ok ol"> unsafe {<br/>  int a = 25;<br/>  int * ptr = &amp;a;<br/>  Console.WriteLine($"Value of pointer is {*ptr}");<br/>}</span></pre><h1 id="ad9c" class="nb lw it bd lx nc oo ne ma nf op nh md jz oq ka mg kc or kd mj kf os kg mm nl bi translated">集成驱动电子设备</h1><h2 id="0612" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak"> <em class="on"> Visual Studio </em> </strong></h2><p id="e074" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">C#开发人员传统上通常使用<a class="ae ky" href="https://visualstudio.microsoft.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio IDE </a>。这种情况产生于……的起源。NET是一种闭源技术。微软开发Visual Studio <strong class="lb iu"> </strong>是为了成为所有. NET的一站式商店。</p><p id="bc3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java走了一条不同的道路，从一开始就为开发人员提供了更多的工具选择。这就是为什么Java开发有更多ide的原因(例如IntelliJ、Eclipse、NetBeans)。渐渐地。NET开发人员已经发生了变化，这些年来提供了更多的ide和开发人员选择。</p><h2 id="d7d4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">IntelliJ<em class="on">(Java)——</em>Rider<em class="on">(c#)</em></strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/80ccbd65789001ded3b7dadaf7d6c2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*zunaKLnMaM6ZEhag.png"/></div></figure><p id="3c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JetBrains IDE的用户会发现从一个IDE到另一个IDE的转换非常顺利，如果他们选择转换到他们所针对的技术的JetBrains IDE。键盘快捷键、IDE布局，甚至一些插件都是等价的或可比较的——实际上是同一个IDE。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="fa59" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">依赖性管理</h1><h2 id="231c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">Maven<em class="on">(Java)——</em>NuGet和dotnet CLI <em class="on"> (C#) </em> </strong></h2><p id="6e74" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Maven是一个工具，负责依赖性管理和构建典型Java和JVM应用程序的生命周期。也就是说，它非常灵活，有1000多个插件，可以用来构建其他语言的应用程序，比如PHP和JavaScript。</p><p id="0de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">maven的可配置单元是每个maven项目都有的一个<code class="fe oa ob oc od b">pom.xml</code>文件。对于项目的子模块，可能每个子模块都有一个从父模块继承的pom文件。Maven使用某种远程服务器或存储库来托管和检索包。</p><p id="925a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Maven <code class="fe oa ob oc od b">pom.xml</code>文件(Java):</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2590" class="lv lw it od b gy oi oj l ok ol">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;project <br/>         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br/>         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><span id="53de" class="lv lw it od b gy om oj l ok ol">    &lt;groupId&gt;dev.andymacdonald&lt;/groupId&gt;<br/>    &lt;artifactId&gt;fish-app&lt;/artifactId&gt;<br/>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br/>    &lt;packaging&gt;jar&lt;/packaging&gt;<br/><br/>    &lt;dependencies&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>            &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>        &lt;/dependency&gt;<br/>    &lt;/dependencies&gt;<br/><br/>    &lt;build&gt;<br/>        &lt;plugins&gt;<br/>            &lt;plugin&gt;<br/>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br/>            &lt;/plugin&gt;<br/>        &lt;/plugins&gt;<br/>    &lt;/build&gt;<br/><br/>&lt;/project&gt;</span></pre><p id="04c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最简单的层面上，您可以使用以下命令测试和构建Maven项目:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c4a7" class="lv lw it od b gy oi oj l ok ol">mvn clean install</span></pre><p id="805a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后用这个创建一个包:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="02f3" class="lv lw it od b gy oi oj l ok ol">mvn clean package</span></pre><p id="25fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，像这样部署一个包:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="bc6a" class="lv lw it od b gy oi oj l ok ol">mvn clean deploy</span></pre><p id="f3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.nuget.org/" rel="noopener ugc nofollow" target="_blank"> NuGet </a>履行了一个相似但不完全相同的角色。NET到Maven。NuGet可以使用一些不同的配置文件，但通常使用<code class="fe oa ob oc od b">.csproj</code> <em class="mt">。与Maven一样，NuGet使用一个可以托管包的服务器/存储库。</em></p><p id="7f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NuGet <code class="fe oa ob oc od b">.csproj</code>文件:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="ee56" class="lv lw it od b gy oi oj l ok ol">&lt;Project &gt;<br/>  &lt;PropertyGroup&gt;<br/>    &lt;AssemblyName&gt;MSBuildSample&lt;/AssemblyName&gt;<br/>    &lt;OutputPath&gt;Bin\&lt;/OutputPath&gt;<br/>  &lt;/PropertyGroup&gt;<br/>  &lt;ItemGroup&gt;<br/>    &lt;Compile Include="helloworld.cs" /&gt;<br/>  &lt;/ItemGroup&gt;<br/>  &lt;ItemGroup&gt;<br/>    &lt;PackageReference Include="MyDependency" version="1.0.0" /&gt;<br/>  &lt;/ItemGroup&gt;  <br/>  &lt;Target Name="Build"&gt;<br/>    &lt;MakeDir Directories="$(OutputPath)" Condition="!Exists('$(OutputPath)')" /&gt;<br/>    &lt;Csc Sources="@(Compile)" OutputAssembly="$(OutputPath)$(AssemblyName).exe" /&gt;<br/>  &lt;/Target&gt;<br/>&lt;/Project&gt;</span></pre><p id="0d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NuGet的主要角色是包管理、构造和部署。Java开发人员会注意到，它与Maven没有真正相同的构建阶段概念。此外，。NET开发人员不像Java开发人员那样手动编辑他们的编译文件，而是更喜欢在他们的IDE中操作它们。</p><p id="28cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用下面的<code class="fe oa ob oc od b">nuget</code>命令构建、打包和部署包到NuGet:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="84dc" class="lv lw it od b gy oi oj l ok ol">nuget spec<br/>nuget pack {nuspec file}<br/>nuget push {package file} {apikey} -Source {host url}</span></pre><p id="5d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想测试你的。NET应用程序，您可以运行以下dotnet CLI命令:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="dd8a" class="lv lw it od b gy oi oj l ok ol">dotnet test</span></pre><p id="88b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dotnet CLI <a class="ae ky" href="https://docs.microsoft.com/en-us/nuget/reference/dotnet-commands" rel="noopener ugc nofollow" target="_blank">也可以用作nuget命令</a>的包装器。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="33d9" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">应用服务器</h1><h2 id="3d55" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">Apache Tomcat<em class="on">(Java)——</em>IIS<em class="on">(ASP.NET)</em></strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/587be1aae0ab05fe0ba13773dd3971e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CC92WZcUM-vD-zoz.png"/></div></div></figure><p id="2607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://tomcat.apache.org/" rel="noopener ugc nofollow" target="_blank"> Tomcat </a>是来自Apache Foundation的开源web服务器和servlet容器。尽管Java中广泛使用了许多其他应用服务器，但它是大多数企业软件公司的常见选择。它可以在几乎所有操作系统上运行(例如，Windows、Unix、Linux和Mac OS)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/d3a9f23baddc626ece5572fb5ed0a51e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EsWhMp2N1bSpI8HI"/></div></div></figure><p id="6cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">。NET项目通常部署在<a class="ae ky" href="https://www.iis.net/" rel="noopener ugc nofollow" target="_blank"> IIS </a>上，这是一个只在Windows上运行的web服务器。虽然它的可移植性有限，但它是Windows开发人员的一个非常受欢迎的选择，因为它易于使用和简单，同时还提供一些高级配置选项。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="6363" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">…但是等等！</h1><p id="ce7e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">还有就是。NET Core <strong class="lb iu">、</strong>允许你开发<a class="ae ky" href="https://stackify.com/cross-platform-net-core-apps/" rel="noopener ugc nofollow" target="_blank">跨平台的应用，而不仅仅局限于Windows </a>。</p><p id="e1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为。NET核心web应用程序，您可以将它们打包成独立的web应用程序运行，允许您像这样运行它们:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c6be" class="lv lw it od b gy oi oj l ok ol">dotnet &lt;app_assembly&gt;.dll</span></pre><p id="9018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，您可以运行一个<a class="ae ky" href="https://spring.io/guides/gs/spring-boot/" rel="noopener ugc nofollow" target="_blank">Java Spring Boot web</a><strong class="lb iu"><em class="mt"/></strong>应用程序(它有一个独立的Tomcat服务器):</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1a7e" class="lv lw it od b gy oi oj l ok ol">java -jar &lt;my-application&gt;.jar</span></pre><p id="f995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样访问您闪亮的新web应用程序:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="0776" class="lv lw it od b gy oi oj l ok ol">http://&lt;serveraddress&gt;:&lt;port&gt;</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="25d9" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">库和框架</h1><h2 id="f168" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak"> <em class="on"> Spring框架(Java)—ASP.NET(c#)</em></strong></h2><p id="da9f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Spring框架是Java的一个框架和IoC容器。简而言之，Spring框架负责实例化对象(bean)并管理这些bean在内存中的生命周期。</p><p id="c0d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个<code class="fe oa ob oc od b">ApplicationContext</code> <em class="mt"> </em>(类似ASP中的一个<code class="fe oa ob oc od b">Startup</code>的概念。网)。这个例子使用了Spring Boot:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="6e1c" class="lv lw it od b gy oi oj l ok ol">@SpringBootApplication<br/>public class HumanApplication<br/>{<br/>   public static void main(String[] args) <br/>   {<br/>      SpringApplication.run(HumanApplication.class, args);<br/>   }<br/>}</span></pre><p id="6f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建接口:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="f60b" class="lv lw it od b gy oi oj l ok ol">public interface Organ&lt;T&gt;<br/>{  <br/>   void function();<br/>}</span></pre><p id="a921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现<code class="fe oa ob oc od b">Organ&lt;T&gt;</code>接口:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="fa62" class="lv lw it od b gy oi oj l ok ol">@Component<br/>public class Heart implements Organ&lt;Heart&gt;<br/>{<br/>    public Heart() {}</span><span id="2caa" class="lv lw it od b gy om oj l ok ol">    public void function() <br/>    {<br/>        System.out.println("Buh-dump");<br/>    }<br/>}</span></pre><p id="15b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构造函数将<code class="fe oa ob oc od b">Organ</code>依赖列表注入到<code class="fe oa ob oc od b">Human</code>服务中:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="ac7e" class="lv lw it od b gy oi oj l ok ol">@Service<br/>public class Human <br/>{<br/>    private static final int MAX_SECONDS_OF_LIFE = 3000;</span><span id="1616" class="lv lw it od b gy om oj l ok ol">    private List&lt;Organ&gt; organs;</span><span id="2d2b" class="lv lw it od b gy om oj l ok ol">    public Human(List&lt;Organ&gt; organs) <br/>    {<br/>        this.organs = organs;<br/>    }</span><span id="ca85" class="lv lw it od b gy om oj l ok ol">    @PostConstruct<br/>    public void live() <br/>    {<br/>        for (int i = 0; i &lt; MAX_SECONDS_OF_LIFE; i++) <br/>        {<br/>            organs.forEach(organ -&gt; organ.function());<br/>        }<br/>    }<br/>}</span></pre><p id="a5fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行应用程序…</p><p id="b95e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还活着:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="d18c" class="lv lw it od b gy oi oj l ok ol">Buh-dump<br/>Buh-dump<br/>Buh-dump<br/>Buh-dump<br/>...</span></pre><p id="5700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Spring还附带了一套方便的模块和包。</p><p id="2ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在核心的Spring包中，以及在对框架的约定胜于配置扩展Spring Boot中，为希望访问公共库的开发人员提供了现有技术和定制技术的有用组合，以启动一个项目，提供他们可能需要的所有东西，而不是必须自己编写或跟踪这些实用程序:</p><ul class=""><li id="5bb9" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe oa ob oc od b">RestTemplate</code> (spring-web —用于构造REST和HTTP请求)</li><li id="a485" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oa ob oc od b">JdbcTemplate</code> (spring-data —用于构建JDBC查询和语句)</li><li id="3bc8" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">Spring Security(用于创建和管理应用程序安全模型)</li><li id="97dd" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oa ob oc od b">ObjectMapper</code>(spring-core——Jackson的POJOs映射实用程序)</li><li id="e237" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">等等。</li></ul><p id="be03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ASP.NET在C#世界中扮演着类似的角色，在单一框架中提供IoC功能、常用技术和实用程序。然而，ASP.NET通常只为web应用程序提供IoC功能，而Spring框架为任何类型的应用程序都提供了IoC功能。</p><p id="b27d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就依赖性反转而言，在ASP.NET可以做与Spring非常相似的事情。</p><p id="0e3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像以前一样，定义所需的接口和具体实现:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="041a" class="lv lw it od b gy oi oj l ok ol">public interface Organ&lt;T&gt;<br/>{  <br/>   void Function();<br/>}</span><span id="3a92" class="lv lw it od b gy om oj l ok ol">public class Heart : Organ&lt;Heart&gt;<br/>{<br/>    public Heart() {}</span><span id="7248" class="lv lw it od b gy om oj l ok ol">    public void Function() <br/>    {<br/>        Console.WriteLine("Buh-dump");<br/>    }<br/>}</span></pre><p id="e8d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用注入依赖项的函数:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="b09d" class="lv lw it od b gy oi oj l ok ol">public class Human<br/>{</span><span id="ea1a" class="lv lw it od b gy om oj l ok ol">   private List&lt;IOrgan&gt; _organs;<br/> <br/>   public Human(List&lt;IOrgan&gt; organs)<br/>   {<br/>      _organs = organs;<br/>      this.Live();<br/>   }</span><span id="c5bf" class="lv lw it od b gy om oj l ok ol">   public void Live()<br/>   {<br/>      organs.ForEach(organ =&gt;<br/>      {<br/>         organ.Function();<br/>      });<br/>   }<br/>}</span></pre><p id="729b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义一个<code class="fe oa ob oc od b">Startup</code>并注册服务:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2344" class="lv lw it od b gy oi oj l ok ol">public class Startup  <br/>{    <br/>  public void ConfigureServices(IServiceCollection services)<br/>  {    <br/>    services.AddTransient&lt;IList&lt;IOrgan&gt;&gt;(p =&gt; p.GetServices&lt;IOrgan&gt;().ToList());<br/>  }<br/>}</span></pre><p id="9442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ASP。NET还提供了许多有用的库和实用程序来加速项目的开发。</p><h2 id="7faf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak"><em class="on">(Java)—LINQ(c#)</em></strong></h2><p id="e59b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java和C#都有简化数据集简化的机制——T0流T1和T2 LINQ T3。</p><p id="cab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种技术之间存在一些差异和差距，但是如果您熟悉其中一种技术，您将能够很快使用另一种技术。</p><p id="c032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java流:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="11aa" class="lv lw it od b gy oi oj l ok ol">List&lt;Student&gt; studentList = Arrays.asList( <br/>    new Student(1, "John", 18, 1),<br/>    new Student(2, "Steve", 21, 1),<br/>);</span><span id="9baa" class="lv lw it od b gy om oj l ok ol">List&lt;String&gt; studentNames = studentList.stream()<br/>    .filter(s -&gt; s.getAge() &gt; 18)<br/>    .filter(s -&gt; s.getStandardID() &gt; 0)<br/>    .map(s -&gt; s.getName()).collect(Collectors.toList());</span><span id="85e6" class="lv lw it od b gy om oj l ok ol">studentNames.forEach(name -&gt; System.out.println(name));</span></pre><p id="ca5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LINQ查询(C#):</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="a14a" class="lv lw it od b gy oi oj l ok ol">IList&lt;Student&gt; studentList = new List&lt;Student&gt;() { <br/>    new Student() { StudentID = 1, StudentName = "John", Age = 18, StandardID = 1 } ,<br/>    new Student() { StudentID = 2, StudentName = "Steve",  Age = 21, StandardID = 1 }<br/>};</span><span id="3f9c" class="lv lw it od b gy om oj l ok ol">var studentNames = studentList.Where(s =&gt; s.Age &gt; 18)<br/>                        .Where(st =&gt; st.StandardID &gt; 0)<br/>                        .Select(s =&gt; s.StudentName);</span><span id="2d14" class="lv lw it od b gy om oj l ok ol">foreach(var name in studentNames) {   <br/>    Console.WriteLine(name);<br/>}</span></pre><h2 id="7713" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak"><em class="on">Apache Commons(Java)—CommonLibrary.NET(c#)</em></strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/e4f808b58d8bbaec044f1778161cdf1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NTKS5n7LJXAgajKFFJWViA.png"/></div></div></figure><p id="2be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://commons.apache.org/components.html" rel="noopener ugc nofollow" target="_blank"> Apache Commons </a></p><p id="b84f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要一个处理ZIP文件的工具或一组处理数学表达式和公式的工具，那么Apache Commons可以满足您的需求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/3b43a6a4b0e82920fb3c9ceb8e5bd971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQhyiq56BpYv_IRjsfVfZg.png"/></div></div></figure><p id="af3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以类似的方式，<a class="ae ky" href="https://archive.codeplex.com/?p=commonlibrarynet" rel="noopener ugc nofollow" target="_blank">CommonLibrary.NET</a>也涵盖了这些基础——在一些组件和模块的命名上有一些关键的不同，但是在大多数情况下，它们在目的上是非常等价的。</p><p id="6c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，与Apache Commons不同，CommonLibrary.NET很老了，在项目中不再常用。如果您正在寻找每种技术的不断更新、精选的库列表，我强烈推荐这两个列表:</p><div class="oy oz gp gr pa pb"><a href="https://github.com/akullpp/awesome-java" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">akullpp/awesome-java</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">Java编程语言的优秀框架、库和软件的精选列表。- akullpp/awesome-java</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">github.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://github.com/quozd/awesome-dotnet" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">quozd/awesome-dotnet</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">一个很棒的收藏。NET库、工具、框架和软件- quozd/awesome-dotnet</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">github.com</p></div></div></div></a></div></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="911a" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">测试库</h1><h2 id="05a2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">JUnit<em class="on">(Java)——</em>NUnit<em class="on">(c#)</em></strong></h2><p id="6460" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java的可靠的JUnit库在C#中有直接的对等物。</p><p id="a879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NUnit与JUnit的功能几乎相当，是C#开发人员的热门选择。</p><p id="0a70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JUnit:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1f42" class="lv lw it od b gy oi oj l ok ol">@Test<br/><strong class="od iu">public</strong> <strong class="od iu">void</strong> complexNumberTest()<br/>{<br/>    ComplexNumber result = someCalculation();</span><span id="9d86" class="lv lw it od b gy om oj l ok ol">    Assert.assertEquals("Real", 5.2, result.getRealPart());<br/>    Assert.assertEquals("Imaginary" 3.9, result.getImaginaryPart());<br/>}</span></pre><p id="8d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">努尼特:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="f426" class="lv lw it od b gy oi oj l ok ol">[Test]<br/><strong class="od iu">public</strong> <strong class="od iu">void</strong> ComplexNumberTest()<br/>{<br/>    ComplexNumber result = SomeCalculation();</span><span id="958b" class="lv lw it od b gy om oj l ok ol">    Assert.Multiple(() =&gt;<br/>    {<br/>        Assert.AreEqual(5.2, result.RealPart, "Real");<br/>        Assert.AreEqual(3.9, result.ImaginaryPart, "Imaginary");<br/>    });<br/>}</span></pre><p id="bcd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(有传言称，NUnit最初是通过修改JUnit源代码来运行C#的。)</p><h2 id="6afd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">mock ITO<em class="on">(Java)—</em>Moq<em class="on">(c#)</em></strong></h2><p id="534b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">与JUnit和NUnit一样，Java的<a class="ae ky" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>和C#的<a class="ae ky" href="https://github.com/Moq/moq4/wiki/Quickstart" rel="noopener ugc nofollow" target="_blank"> Moq </a>库之间也存在类似的功能。</p><p id="72f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">莫奇托:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="bc5d" class="lv lw it od b gy oi oj l ok ol">Foo mockFoo = mock(Foo.class);<br/>when(mockFoo.doSomething("ping")).thenReturn(true);</span></pre><p id="a80d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起订量:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4f14" class="lv lw it od b gy oi oj l ok ol">var mock = new Mock&lt;IFoo&gt;();<br/>mock.Setup(foo =&gt; foo.DoSomething("ping")).Returns(true);</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="9e57" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">就是这样</h1><p id="2529" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">感谢阅读！</p><p id="f018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，我无法在这篇文章中描述每一个不同点、相似点和细节——这篇文章已经太长了。</p><p id="15ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望至少我已经讲了足够多的内容，让你有信心做出改变，看看另一半是如何生活的。</p></div></div>    
</body>
</html>