<html>
<head>
<title>Power Up Your Jamstack With the New Nuxt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用新的Nuxt增强您的Jamstack</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/power-up-your-jamstack-with-the-new-nuxt-9b5c3d449876?source=collection_archive---------8-----------------------#2020-08-03">https://betterprogramming.pub/power-up-your-jamstack-with-the-new-nuxt-9b5c3d449876?source=collection_archive---------8-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="337a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">新功能和新功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/905f362358280944b7e00b171a039e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IT_4EPMZI8zbFWl0flCjHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Nuxt和Nuxt内容模块的力量(图片来源:作者)</p></figure><p id="f5b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一直在等待<a class="ae lu" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt </a> 3.0构建Jamstack(静态)应用？没必要这样。最新的Nuxt版本，v2.14，可能正是你正在寻找的。</p><p id="5e22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好奇？我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3344" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是Jamstack？</h1><p id="a21e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">对于不熟悉的人来说，<a class="ae lu" href="https://jamstack.org/" rel="noopener ugc nofollow" target="_blank"> Jamstack </a>(或Jamstack)是一个web开发架构，其中JAM代表客户端JavaScript、可重用API(而不是多个web服务器)和预构建标记(静态HTML文件)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/ec1994d62b21b9ba9dd031dc0628c752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*px_jKqPSaM6NX00p.png"/></div></div></figure><p id="c35e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Jamstack的目标是通过静态构建来提供更快、可伸缩、更安全的应用程序。Jamstack的趋势从2019年开始，我们预计它将在2020年继续流行。</p><p id="d51e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么Nuxt——一个服务器端(SSR) Vue框架——目前在Jamstack上表现如何呢？</p><p id="0eba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们找出答案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="57f0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Jamstack的Nuxt状态(2.13版之前)</h1><p id="e58d" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Nuxt是一个超级酷的框架。它为单个代码库提供了以下两个版本:</p><ul class=""><li id="3446" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated"><code class="fe na nb nc nd b">universal</code> SSR(服务器端渲染)</li><li id="9d20" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe na nb nc nd b">spa</code>单页应用</li></ul><p id="1f48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">后来，为了支持Jamstack，Nuxt团队提供了额外的构建命令<code class="fe na nb nc nd b">nuxt generate</code>作为静态站点生成器(SSG)。</p><p id="80bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，其静态站点生成器机制并不完全是标准静态站点生成器(SSG)的100%预期，具有以下一些限制:</p><ul class=""><li id="35da" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated">与普通SSG不同，在普通SSG中，页面的所有数据都是在构建时预取的，Nuxt引擎在构建时预呈现模板和内容，但在运行时使用<code class="fe na nb nc nd b">fetch</code>和<code class="fe na nb nc nd b">asyncData</code>检索外部数据。因此，生成的页面只是半静态的。此外，通过依赖外部调用来完成客户端的数据获取和呈现，在向用户显示内容时可能会有延迟，从而影响应用程序的整体性能。</li><li id="f393" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">由于Nuxt没有像GraphQL那样的内置数据层，因此Nuxt引擎不知道如何为来自外部数据库的内容自动生成所有动态路由。开发人员必须使用<code class="fe na nb nc nd b">nuxt.config.js</code>文件中的<code class="fe na nb nc nd b">generate.routes</code>属性指定如何生成这些路线。这种额外的工作导致复杂性和可能缓慢的构建时间，从而导致成本效率，特别是当大多数托管服务如Netlify根据构建时间收费时。</li><li id="0384" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">没有内置的<a class="ae lu" href="https://daringfireball.net/projects/markdown/" rel="noopener ugc nofollow" target="_blank">降价</a>支持。我们可以使用<code class="fe na nb nc nd b">@nuxtjs/markdownit</code>模块；然而，开发人员很难对这个模块进行额外的定制。</li></ul><p id="9437" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在这种情况下，静态站点对性能的影响被释放了一半。</p><p id="057f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是随着Nuxt 2.13和Nuxt内容模块的出现，这些限制终于结束了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b425" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从构建过程开始的完全静态</h1><p id="fa96" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了更好的开发者体验，从v2.13开始，Nuxt引入了一个新的属性<code class="fe na nb nc nd b">target: static</code>，而<code class="fe na nb nc nd b">mode</code>在<code class="fe na nb nc nd b">nuxt.config.js</code>内保持<code class="fe na nb nc nd b">universal</code>(默认)或<code class="fe na nb nc nd b">spa</code>，以通知Nuxt引擎。我们的应用程序旨在完全静态。</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="855e" class="nw md it nd b gy nx ny l nz oa">/* nuxt.config.js */<br/>export default {<br/> mode: 'universal', // default mode<br/> target: 'static', // enable full static mode<br/> //...<br/>}</span></pre><h2 id="eacc" class="nw md it bd me ob oc dn mi od oe dp mm lh of og mo ll oh oi mq lp oj ok ms ol bi translated">用n优化构建<code class="fe na nb nc nd b">uxt generate</code></h2><p id="d219" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在Nuxt v2.13之前，为了构建一个静态的代码项目，我们使用了<code class="fe na nb nc nd b">nuxt generate</code>。通过调用<code class="fe na nb nc nd b">nuxt generate</code>，Nuxt引擎实际上触发了<code class="fe na nb nc nd b">nuxt build</code>来启动构建过程，然后在部署之前将应用程序的页面导出到静态HTMLs。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/f312ee2eb1a79169049c0ca83bd42fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BjzPdwd8qdhR4qYU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用nuxt生成时的构建过程</p></figure><p id="0400" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从2.14版本开始，<code class="fe na nb nc nd b">nuxt generate</code>更加智能。它检测何时没有代码更改，并跳过构建步骤。相反，它重用先前的构建缓存并继续生成静态HTMLs。</p><p id="ee16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，Nuxt引擎知道如何检测客户端的任何额外异步API调用(通过<code class="fe na nb nc nd b">asyncData</code>或<code class="fe na nb nc nd b">fetch</code>)并将其从生成的HTML页面分离到相应的有效负载<code class="fe na nb nc nd b">.js</code>文件中。因此，它大大减少了生成的HTML页面的大小。同时，在运行时，有效载荷文件将被预加载，使应用程序的性能得到优化，并消除了客户端导航的额外API调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/a930db8b8c84ce63d881ebabd0611f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*clmPsMQ-htvvEFyM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">改进了异步数据调用的有效负载文件</p></figure><p id="f6ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很棒，不是吗？下一个问题是:为什么我们需要为构建静态应用程序保留缓存？</p><p id="df4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在构建过程中添加缓存支持可以减少不必要的重复部署工作。第一次部署需要将代码和模板完整构建到应用程序文件中，使用并将它们导出到部署所需的静态HTMLs。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/42c02c28e6f1048d4eb20d5affb55509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NvE5ElUikk-SI-Rq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用的首次部署流程</p></figure><p id="645f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，除非代码和模板发生了变化，否则完整版本并不适合在以后的重新部署中运行。在大多数情况下，网站内容会发生变化，例如添加新的博客文章、修改产品内容等。我们只需要为这个特定内容重新生成动态路由或/和HTML。因此，运行一个完整的构建会导致成本低效率，特别是当静态托管服务主要根据构建时间向我们收费的时候。对于这样的用例，为了优化重新部署的构建时间，使用先前构建的缓存并仅生成新的内容更新就足够了，而不是整个周期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/7232542134c8718f3b05b7c845eb1912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xNm7XvAku-6e7I3t"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无代码更改时的智能部署</p></figure><h2 id="b042" class="nw md it bd me ob oc dn mi od oe dp mm lh of og mo ll oh oi mq lp oj ok ms ol bi translated">你提到动态路由，Nuxt会自动抓取它</h2><p id="5ebe" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">从v2.13开始，Nuxt引入了比需要一个数据层更强大的东西，以及<code class="fe na nb nc nd b">generate.routes</code>。只要您在任何页面(例如主页上的博客文章列表)上提到您的动态路由，Nuxt爬虫就会检测并确保所有提到的路由都是在构建和部署期间预先生成的。</p><p id="be98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，Nuxt crawler是自动启用的。然而，如果我们想使用我们的逻辑来生成路线，我们可以通过设置<code class="fe na nb nc nd b">crawler: false</code>来关闭它，并继续在<code class="fe na nb nc nd b">nuxt.config.js</code>中实现<code class="fe na nb nc nd b">export.routes</code>。</p><p id="ddd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很酷，不是吗？还有更多。Nuxt v2.14非常优秀，配合其Nuxt内容模块，静态功耗更高。</p><p id="5a01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来看看Nuxt的内容，好吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c612" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">您编写内容，Nuxt负责呈现</h1><p id="a0c3" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Nuxt内容模块<code class="fe na nb nc nd b">@nuxt/content</code>是由Nuxt团队的Benjamin Canac开发的一个新模块。在写这篇文章的时候，Nuxt内容版本是1.4.1。</p><p id="3bd1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，这个内容模块充当基于Git的headless CMS(内容管理服务),从位于本地项目目录的不同文件类型中获取和处理内容，以便在Nuxt应用程序中使用。</p><p id="e128" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要开始使用Nuxt内容，请运行以下命令之一:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="2f4b" class="nw md it nd b gy nx ny l nz oa">yarn add @nuxt/content<br/><br/>#OR<br/>npm i @nuxt/content</span></pre><p id="0bc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后将模块添加到<code class="fe na nb nc nd b">nuxt.config.js</code>中的<code class="fe na nb nc nd b">modules</code>列表:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="6d81" class="nw md it nd b gy nx ny l nz oa">modules: [<br/> '@nuxt/content'<br/>]</span></pre><p id="3e5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并且该模块已经准备好供您使用。</p><h2 id="ce2d" class="nw md it bd me ob oc dn mi od oe dp mm lh of og mo ll oh oi mq lp oj ok ms ol bi translated">一种简单的使用方法</h2><p id="94fc" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">默认情况下，Nuxt引擎将使用<code class="fe na nb nc nd b">content/</code>部件作为所有降价文件的主目录。</p><p id="3585" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">内容模块全局地将<code class="fe na nb nc nd b">$content</code>函数实例注入到我们的应用程序中，因此我们可以使用它直接从给定的路径中获取内容。例如，我们可以从<code class="fe na nb nc nd b">content/blog</code>目录中检索博客文章列表，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="df5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<code class="fe na nb nc nd b">$content</code>实例接收两个参数:<code class="fe na nb nc nd b">path</code>和一个额外的对象<code class="fe na nb nc nd b">options</code>，它为模块提供额外的配置来覆盖给定路径的默认设置。例如，我们只需要启用<code class="fe na nb nc nd b">deep: true</code>从子目录中获取文件，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="62ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者获取一个文件，我们可以将文件名传递给<code class="fe na nb nc nd b">path</code>参数或者直接作为<code class="fe na nb nc nd b">options</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="8ca4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种方法都是合法的。<code class="fe na nb nc nd b">$content()</code>返回一个<code class="fe na nb nc nd b">QueryBuilder</code>类型的链序列。然后我们可以调用它的方法<code class="fe na nb nc nd b">fetch()</code>开始使用Promise检索内容。</p><p id="b097" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当<code class="fe na nb nc nd b">fetch()</code>解析时，它返回一个对象(如果<code class="fe na nb nc nd b">path</code>是单个文件路径)，或者一个对象数组(如果<code class="fe na nb nc nd b">path</code>是一个目录)。每个对象的结构与下面的截图相似，自动生成的属性为<code class="fe na nb nc nd b">body</code>(主要内容)、<code class="fe na nb nc nd b">createdAt</code>、<code class="fe na nb nc nd b">dir</code>、<code class="fe na nb nc nd b">extension</code>、<code class="fe na nb nc nd b">path</code>、<code class="fe na nb nc nd b">slug</code>(文件名)、<code class="fe na nb nc nd b">toc</code>(目录)和<code class="fe na nb nc nd b">updatedAt</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/f3553b4122027a54eaced998b9df6de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O-IAkRE_bHCnk_t_.png"/></div></div></figure><p id="7d7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们有了返回内容对象，我们可以简单地使用模板部分中的<code class="fe na nb nc nd b">nuxt-content</code>组件来显示内容的主体:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="3203" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样。内容模块将负责呈现并显示您的页面内容，如下例所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/265639a31183d597dc184f78ef27ed0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ux8jDY0Z8AeYSoYn.png"/></div></div></figure><p id="08ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从截图中可以看出，Nuxt Content只显示最基本样式的内容(即没有样式)，以避免在应用CSS样式定制时产生复杂性。Nuxt为我们提供了<code class="fe na nb nc nd b">&lt;nuxt-content&gt;</code>组件的<code class="fe na nb nc nd b">.nuxt-content</code>类选择器，我们可以从那里开始定制样式，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="742b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的内容页面现在看起来更有条理了</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/c253205efea07fc7054a38f96d4daae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KPaXxMbIiummGt8r.png"/></div></div></figure><p id="3af2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅此而已。我们使用Nuxt内容模块将Markdown文件中的内容呈现到页面上，只需要三个简单的步骤:</p><ol class=""><li id="b859" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt ot nk nl nm bi translated"><strong class="la iu">使用<code class="fe na nb nc nd b">$content().fetch()</code>获取</strong>内容。</li><li id="b736" class="ne nf it la b lb nn le no lh np ll nq lp nr lt ot nk nl nm bi translated"><strong class="la iu">相应地使用<code class="fe na nb nc nd b">&lt;nuxt-content&gt;</code>及其道具<code class="fe na nb nc nd b">document</code>渲染</strong>获取的内容。</li><li id="9bc0" class="ne nf it la b lb nn le no lh np ll nq lp nr lt ot nk nl nm bi translated"><strong class="la iu">使用类选择器<code class="fe na nb nc nd b">.nuxt-content</code>将CSS样式</strong>添加到显示的内容中。</li></ol><p id="1c0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很棒？确实如此。那么除此之外，Nuxt Content还提供了其他什么独特的功能吗？</p><h2 id="ec3e" class="nw md it bd me ob oc dn mi od oe dp mm lh of og mo ll oh oi mq lp oj ok ms ol bi translated">搜索和过滤内容结果</h2><p id="6907" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">由于Nuxt Content使用类似于<a class="ae lu" href="https://github.com/techfort/LokiJS/wiki" rel="noopener ugc nofollow" target="_blank"> LokiJS </a>和<a class="ae lu" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>的查询语法，我们可以通过方法序列链在搜索和过滤特定内容结果集时获得高性能。例如，如果我们只想选择每个内容对象的<code class="fe na nb nc nd b">title</code>、<code class="fe na nb nc nd b">slug</code>和<code class="fe na nb nc nd b">updatedAt</code>属性，并按照编辑时间对文章进行排序(降序)，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="4caa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，<code class="fe na nb nc nd b">only</code>接收一个从每个返回的内容对象中选择的键数组，<code class="fe na nb nc nd b">sortBy</code>接受两个参数，一个要排序的键和排序方向。</p><p id="fab3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以使用<code class="fe na nb nc nd b">where</code>过滤符合特定条件的帖子，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="fff7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者您可以使用<code class="fe na nb nc nd b">search(key, value)</code>对字段执行全文搜索:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="58b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，您可以通过限制<code class="fe na nb nc nd b">limit()</code>接收的结果来实现分页:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="2d98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在Nuxt内容文档和LokiJS中探索其他有用的链接方法，以获得这些方法中支持的查询语法。</p><p id="99ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:所有的序列链接必须以<code class="fe na nb nc nd b">fetch()</code>结束，以通过Promise API收集所需的数据。</p><h2 id="1a3d" class="nw md it bd me ob oc dn mi od oe dp mm lh of og mo ll oh oi mq lp oj ok ms ol bi translated">使用PrismJS突出显示代码</h2><p id="a72a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Nuxt Content使用<a class="ae lu" href="https://prismjs.com/" rel="noopener ugc nofollow" target="_blank"> PrismJS </a>作为其内置的处理程序，用于在Markdown内容中突出显示代码。默认主题相当不错；然而，我们总是可以安装<code class="fe na nb nc nd b">prism-themes</code>并从可用的主题列表(24个不同的主题)中选择一个不同的主题用于我们的应用程序:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="e4d8" class="nw md it nd b gy nx ny l nz oa">yarn add prism-themes</span></pre><p id="be60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后在<code class="fe na nb nc nd b">nuxt.config.js</code>中的<code class="fe na nb nc nd b">content.markdown.prism</code>字段下定义想要的主题，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="396d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">带有代码突出显示的呈现内容将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/93ff211cfa99efeef36c931b344c41a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mIVceFEO7uE--0rP.png"/></div></div></figure><p id="2d0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很美，不是吗？没有更复杂的解决方法来支持Markdown的代码高亮显示。此外，由于<code class="fe na nb nc nd b">prism-themes</code> repo是开源的，您可以随时创建自己的自定义主题。</p><h2 id="2364" class="nw md it bd me ob oc dn mi od oe dp mm lh of og mo ll oh oi mq lp oj ok ms ol bi translated">YAML内线降价</h2><p id="3e64" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Nuxt内容的一个很好的特性是能够支持降价文件中的YAML前端事务块，只要它出现在顶部并采用三点划线之间的YAML集的有效形式:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="06da" class="nw md it nd b gy nx ny l nz oa">--- <br/>title: Hello World description: Hello to Nuxt content demo img: nuxt_demo/DSC00856 <br/>author: Maya Shavin <br/>---</span></pre><p id="7959" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Nuxt内容模块将这些字段作为属性注入到传递给<code class="fe na nb nc nd b">nuxt-content</code>组件的<code class="fe na nb nc nd b">document</code>的内容对象中，如下例所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/7730f89233b11631295fd949c279b05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DLoMHM6am1Ukor_7.png"/></div></div></figure><p id="176a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Markdown文件中编写YAML块使我们能够轻松地为一篇博客文章添加更多的定制信息，比如作者的详细信息。</p><h2 id="0c72" class="nw md it bd me ob oc dn mi od oe dp mm lh of og mo ll oh oi mq lp oj ok ms ol bi translated">自动生成目录</h2><p id="1f4e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">当获取一个Markdown文件时，Nuxt content会自动生成一个目录(TOC ),其中包含文件中的所有标题。TOC是一个数组，作为返回内容对象的属性出现。<code class="fe na nb nc nd b">toc</code>数组的每个元素都是一个对象，有三个主要字段:</p><ul class=""><li id="7c9a" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated"><code class="fe na nb nc nd b">id</code> —标题本身为小写，无空格，用于链接</li><li id="c496" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe na nb nc nd b">depth</code> —标题类型(1=h1，2 =h2，等等。)</li><li id="9c4e" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe na nb nc nd b">text</code> —标题的实际文本</li></ul><p id="755f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个包含以下内容的降价文件示例:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="d94f" class="nw md it nd b gy nx ny l nz oa"><strong class="nd iu"># Hello World</strong><br/><br/><strong class="nd iu">## Hello Heading 1</strong><br/><br/>Lorem ipsum dolor sit amet</span></pre><p id="0669" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Nuxt内容将按如下方式生成TOC:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="88c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这个TOC结构中，我们可以相应地构建和显示我们的TOC组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="e716" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太棒了。还有什么？</p><h2 id="f29b" class="nw md it bd me ob oc dn mi od oe dp mm lh of og mo ll oh oi mq lp oj ok ms ol bi translated">都是关于钩子的！</h2><p id="2472" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">目前，Nuxt内容提供了两个主要的挂钩:</p><ul class=""><li id="99fb" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated"><code class="fe na nb nc nd b">content:file:beforeInsert</code>允许在存储文件进行渲染之前向文件添加额外数据。例如，添加外部逻辑是有用的，比如在构建时读取时间计算，从而优化客户端性能。</li><li id="f4f8" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe na nb nc nd b">content:update</code>内容文件更新时。当您想要实现热重装或实时编辑时，这个钩子很有用。</li></ul><p id="e8e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过使用<code class="fe na nb nc nd b">nuxt.config.js</code>中的<code class="fe na nb nc nd b">hooks</code>属性来添加所需的挂钩，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="151b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我们所需要的。现在，获取的文档还会有一个额外的字段<code class="fe na nb nc nd b">readingTime</code>,指示阅读博文需要多长时间，所有这些都是在构建时完成的。客户端不需要额外的工作，即使是计算阅读时间。</p><p id="471d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很酷，不是吗？有了这些功能，我们可以建立一个完全静态的网站，无论是博客还是电子商务商店只使用Markdown文件和Nuxt。</p><p id="3d33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，这些并不是Nuxt内容能够提供的唯一特性。而制作一个高性能且美观的静态网站需要高效工具的组合，其中Nuxt和Nuxt内容是核心。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a2f4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">演示</h1><p id="3c1c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了实验，我为一家旅游公司做了一个演示PWA，使用<a class="ae lu" href="https://nuxtjs.org" rel="noopener ugc nofollow" target="_blank"> Nuxt </a>、<a class="ae lu" href="https://content.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt Content </a>、<a class="ae lu" href="https://tailwindcss.com" rel="noopener ugc nofollow" target="_blank"> TailwindCSS </a>、<a class="ae lu" href="https://cloudinary.com" rel="noopener ugc nofollow" target="_blank"> Cloudinary </a>，使用Netlify自动部署。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/710669867026afd89bd9648929a84296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SCK3cdeloDsbTmex.png"/></div></div></figure><p id="5454" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里查看这个应用:<a class="ae lu" href="https://tfh-tours.netlify.app/" rel="noopener ugc nofollow" target="_blank">https://tfh-tours.netlify.app/</a></p><p id="9119" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而背后的代码一如既往的开源，可以在这个回购中获得:<a class="ae lu" href="https://github.com/mayashavin/tours-nuxt-full-static" rel="noopener ugc nofollow" target="_blank">https://github.com/mayashavin/tours-nuxt-full-static</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad88" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="d1c1" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在我看来，Nuxt v2.1x和Nuxt内容是Nuxt团队发布的优秀产品。除了提到的静态站点的构建改进，新的Nuxt还提供了其他功能，旨在使开发人员的生活更加舒适，例如自动检测、运行时配置、遥测和主题支持的组件。</p><p id="b411" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，Nuxt内容是一个绝对的胜利，你可以与内容实时交互，并充分利用Markdown content提供的功能，同时根据你的应用程序的目标外观和感觉保持用户界面的美观。</p><p id="4b3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您达到了这一行(我很感激)，为什么不试试Nuxt(如果您还没有)，看看它如何增强您的下一个Jamstack项目？</p></div></div>    
</body>
</html>