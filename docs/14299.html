<html>
<head>
<title>How I Over-Engineered a Roku Sleep Timer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何过度设计Roku睡眠定时器的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-over-engineered-a-roku-sleep-timer-c1e5d9cb1e82?source=collection_archive---------3-----------------------#2022-11-26">https://betterprogramming.pub/how-i-over-engineered-a-roku-sleep-timer-c1e5d9cb1e82?source=collection_archive---------3-----------------------#2022-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="246a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我在使用Docker、Python和Flask创建自托管微服务API时做出某些设计决策的思考过程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3942d3a41d8bc7911890cd1de4702e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZzNIXcwu9hfczHjfhwLlsg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Roku睡眠计时器的运行——图片由作者提供</p></figure><p id="6352" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然问题本身相当琐碎，但这里的真实故事是我为自托管定制服务创建一个<a class="ae lr" href="https://github.com/nschenone/docker-python-flask-template" rel="noopener ugc nofollow" target="_blank">可重用模板</a>并将它们安全地公开为API端点的旅程。这篇博客不是Flask和Docker等底层技术的教程，而是概述了我如何构建应用程序以及我做出某些设计决策的思维过程。</p><h1 id="0562" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">动机——一个奇怪的缺失事件</h1><p id="a995" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">第一世界的问题和不必要的解决方案——说出一个更好的组合。虽然这些问题并不重要，但它们可以带来有趣的解决方案，解决超出最初预期范围的问题。一个这样的例子是，网飞上的几集缺失导致了在我的网络上运行的许多定制微服务API控制各种设备和服务。</p><p id="1195" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2019年，我买了第一台便宜的Insignia 32英寸电视和一个Roku流媒体棒。这绝不是一个家庭影院，但它肯定完成了工作。因此，我养成了利用电视内置的睡眠定时器在看节目时睡着的习惯。一切看起来都很棒…直到我意识到我比我最初意识到的更深入我的表演。经过大量调查后，发现虽然电视的睡眠定时器会自动关闭电视，但网飞仍然整夜在后台播放。</p><h1 id="e9c2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">解决方案——制作我自己的睡眠计时器</h1><p id="c107" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">利用我的Python和Docker经验，我决定自己动手。最终结果可以在<a class="ae lr" href="https://github.com/nschenone/roku-sleep-timer" rel="noopener ugc nofollow" target="_blank">这个GitHub repo </a>中找到，看起来如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/bdd90a2ed3fc12c48f7fe10b87839264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFUKyv5hY4CesobbdtsZYw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Roku睡眠定时器架构—图片由作者提供</p></figure><p id="29cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的要求包括:</p><ul class=""><li id="29ce" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">能够在指定的时间段后“睡眠”Roku和电视(例如，关闭当前运行的应用程序并关闭电视)</li><li id="e693" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">取消当前运行的睡眠定时器的能力</li><li id="d308" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">从我的手机轻松安排/取消睡眠定时器</li><li id="704f" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">向应用程序不可知的API公开睡眠定时器的控制</li><li id="c1c2" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">以安全的方式在我的家庭网络外公开API</li></ul><p id="1e8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想出了一个解决方案，它包括几个主要部分:</p><ul class=""><li id="f69a" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">应用逻辑(Roku控制、作业调度、Flask)</li><li id="1763" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">包装(Docker，Docker撰写)</li><li id="1674" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">部署(自托管、Cloudflare代理、NGINX代理管理器)</li><li id="016a" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">调用(苹果快捷键)</li></ul><h1 id="8a80" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用逻辑一:Roku控制</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/b67192e1ac1890b088cfbc0505e065c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m-3f9Up_akmiMZas"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·卡斯滕斯-彼得斯</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="01b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为第一步，我找到了优秀的库<a class="ae lr" href="https://github.com/jcarbaugh/python-roku" rel="noopener ugc nofollow" target="_blank"> python-roku </a>，它允许你通过Python SDK控制你的roku。有一个方便的功能可以自动发现本地网络上的Roku并模拟远程控制:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="affb" class="nk lt iq ng b be nl nm l nn no">from roku import Roku<br/><br/>timeout = 10 # 10 second timeout<br/>my_roku = Roku.discover(timeout)[0] # returns a list of Roku devices<br/><br/>my_roku.home()<br/>my_roku.right()<br/>my_roku.select()</span></pre><p id="b92b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以这种方式用你的笔记本电脑控制你的电视是令人难以置信的满足感(然而效率很低)。此外，如果您的电视支持<a class="ae lr" href="https://en.wikipedia.org/wiki/Consumer_Electronics_Control" rel="noopener ugc nofollow" target="_blank"> HDMI-CEC </a>，您还可以使用Roku遥控器来控制音量和电源。这也适用于Python SDK:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="b5a9" class="nk lt iq ng b be nl nm l nn no">my_roku.poweron()<br/>my_roku.poweroff()</span></pre><p id="084a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经过一些试验，我发现最佳的命令组合是关闭当前运行的应用程序，等待2秒钟播放动画，然后关闭电视:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="a991" class="nk lt iq ng b be nl nm l nn no">from time import sleep<br/><br/># Prevents Roku from waking up TV if timer is triggered while TV is off<br/>if my_roku.active_app.id != "None":<br/>    my_roku.home()<br/><br/>    # Gives enough time to close open apps before turning off<br/>    sleep(2)<br/><br/># Power off TV once app is closed<br/>my_roku.poweroff()</span></pre><p id="00da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还添加了一项检查，以确保回家前Roku上的应用程序当前处于打开状态。这可以防止电视在睡眠定时器意外启动时被打开。</p><p id="a1f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这些命令正是我所寻找的，但我不想立即运行它们。相反，我想在一段特定的时间后运行它们。</p><h1 id="c5fc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用逻辑II:作业调度</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/cece7b2cfa994f6329df31398146c9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fGD4D7VghHxKH1wG"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/es/@insungyoon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> insung yoon </a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cc6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我找到了<code class="fe nq nr ns ng b"><a class="ae lr" href="https://apscheduler.readthedocs.io/en/3.x/" rel="noopener ugc nofollow" target="_blank">APScheduler</a></code>或高级Python调度程序库。这个健壮的库允许使用各种调度器、作业存储、执行器和触发器来调度一次性或重复的命令。</p><p id="2746" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我的简单应用程序，我所需要的就是将一个作业排队，在X分钟后运行一个给定的Python函数，并清除当前的作业队列。这可以使用内存中的<code class="fe nq nr ns ng b">BackgroundScheduler</code>轻松完成。对于更重要的应用程序，有更多的容错方法来存储和执行作业队列。</p><p id="9402" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下示例在5分钟后运行<code class="fe nq nr ns ng b">trigger_sleep</code> Python函数:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="818c" class="nk lt iq ng b be nl nm l nn no">from datetime import datetime, timedelta<br/>from apscheduler.schedulers.background import BackgroundScheduler<br/><br/>def trigger_sleep():<br/>    print("ZzZzZz")<br/><br/>scheduler = BackgroundScheduler()<br/>scheduler.start()<br/><br/>scheduler.add_job(<br/>    trigger_sleep,<br/>    run_date=(timedelta(minutes=5) + datetime.now())<br/>)</span></pre><p id="c13e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，您可以像这样清除当前作业队列:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="d789" class="nk lt iq ng b be nl nm l nn no">for job in scheduler.get_jobs():<br/>    job.remove()</span></pre><p id="fec6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我对来自<a class="ae lr" href="https://github.com/jcarbaugh/python-roku" rel="noopener ugc nofollow" target="_blank"> python-roku </a>的命令进行排队所需要的一切，但是只在它们被调度的时候执行它们。</p><h1 id="e966" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用逻辑III:将所有内容整合在一起</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/6ca3376cb444f95fd1b6b588118bcf00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lg5UnBsyAJ94KPEVtlHCVg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上下文中的RokuSleepTimer Python脚本-图片由作者提供</p></figure><p id="210c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我将Roku控件和作业调度放在一个专用类中，以便更容易地从Flask应用程序中进行控制。最后一个<code class="fe nq nr ns ng b">RokuSleepTimer</code>类处理睡眠和调度逻辑:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="090a" class="nk lt iq ng b be nl nm l nn no">from datetime import datetime, timedelta<br/>from time import sleep<br/><br/>from apscheduler.schedulers.background import BackgroundScheduler<br/>from roku import Roku<br/><br/><br/>class RokuSleepTimer:<br/>    """<br/>    Sleep timer for Roku. Will interact with Roku via Python SDK<br/>    and schedule sleep job using APScheduler. Automatically connects<br/>    to the first Roku it finds on the network.<br/>    """<br/><br/>    def __init__(self):<br/>        # Start background scheduler for sleep jobs<br/>        self.scheduler = BackgroundScheduler()<br/>        self.scheduler.start()<br/><br/>        # Find first roku on network<br/>        self.discover()<br/>        print(f"Using roku at IP: {self.host}")<br/><br/>    def on(self) -&gt; str:<br/>        """<br/>        Turn TV on via Roku.<br/><br/>        :return: On message<br/>        """<br/>        self.roku.poweron()<br/>        return "on"<br/><br/>    def off(self) -&gt; str:<br/>        """<br/>        Turn TV off via Roku.<br/><br/>        :return: Off message<br/>        """<br/>        self.roku.poweroff()<br/>        return "off"<br/><br/>    def discover(self, timeout: int = 10) -&gt; None:<br/>        """<br/>        Find the first Roku on the network.<br/><br/>        :param timeout: Number of seconds before search times out.<br/>        """<br/>        self.roku = Roku.discover(timeout=timeout)[0]<br/><br/>    def trigger_sleep(self) -&gt; None:<br/>        """<br/>        Sleep mechanism. If an app is open, go to the<br/>        home screen, wait, and power off.<br/>        """<br/>        # Prevents Roku from waking up TV if timer is triggered while TV is off<br/>        if self.roku.active_app.id != "None":<br/>            self.roku.home()<br/><br/>            # Gives enough time to close open apps before turning off<br/>            sleep(2)<br/>        self.roku.poweroff()<br/><br/>    def stop_sleep(self) -&gt; str:<br/>        """<br/>        Stop sleep timer by removing all jobs in scheduler.<br/><br/>        :return: Stop message<br/>        """<br/>        for job in self.scheduler.get_jobs():<br/>            job.remove()<br/>        return "Stopped sleep timer"<br/><br/>    def schedule_sleep(self, minutes: int) -&gt; str:<br/>        """<br/>        Schedule sleep job after the specified number of minutes.<br/><br/>        :param minutes: Number of minutes to wait before sleeping<br/><br/>        :return: Job schedule success message<br/>        """<br/>        self.scheduler.add_job(<br/>            self.trigger_sleep, run_date=(timedelta(minutes=minutes) + datetime.now())<br/>        )<br/>        return (<br/>            f"Started sleep timer for {minutes} minutes. Enjoy the show, sleep tight!"<br/>        )<br/><br/>    @property<br/>    def host(self) -&gt; str:<br/>        """<br/>        Helper to get IP address of Roku device.<br/><br/>        :return: IP address of Roku<br/>        """<br/>        return self.roku.host</span></pre><p id="95ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然休眠/调度逻辑已经完成，我需要一种方法来调用作为API的<code class="fe nq nr ns ng b">RokuSleepTimer</code>。</p><h1 id="cfdc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用逻辑四:烧瓶</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/2b660473380b0a3be8588865f0a8e0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kv13fLLXk47xckysQozKbw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上下文中的Flask Python脚本-图片由作者提供</p></figure><p id="3064" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于这个应用程序相对简单，我决定使用<a class="ae lr" href="https://flask.palletsprojects.com/en/2.2.x/" rel="noopener ugc nofollow" target="_blank">Flask</a>——一个经典的轻量级web框架。它很简单，不固执己见，使用起来非常简单。</p><p id="2b1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就设计API而言，睡眠定时器只需要两条路线:</p><ul class=""><li id="b117" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">GET — <code class="fe nq nr ns ng b">/start/&lt;int:minutes&gt;</code>:启动睡眠定时器X分钟</li><li id="64d5" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">GET — <code class="fe nq nr ns ng b">/stop</code>:取消任何正在运行的睡眠定时器</li></ul><p id="2b61" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还添加了一些生活质量路线，以使调试更容易:</p><ul class=""><li id="2d78" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">GET — <code class="fe nq nr ns ng b">/</code>:确保服务运行的健全性测试</li><li id="324d" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">GET — <code class="fe nq nr ns ng b">/on</code>:手动打开Roku + TV</li><li id="dde4" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">GET — <code class="fe nq nr ns ng b">/off</code>:手动关闭Roku + TV</li><li id="3d88" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">GET — <code class="fe nq nr ns ng b">/discover</code>:通过搜索网络重新连接Roku</li><li id="7b3d" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">GET — <code class="fe nq nr ns ng b">/host</code>:获取Roku设备的IP地址</li></ul><p id="b393" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终的烧瓶应用程序如下所示:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="6e2b" class="nk lt iq ng b be nl nm l nn no">import os<br/><br/>from flask import Flask<br/><br/>from roku_sleep_timer import RokuSleepTimer<br/><br/>app = Flask(__name__)<br/>sleep_timer = RokuSleepTimer()<br/><br/><br/>@app.route("/")<br/>def home() -&gt; str:<br/>    """<br/>    Test connection to app.<br/><br/>    :return: Successful connection message<br/>    """<br/>    return "Connected"<br/><br/><br/>@app.route("/host")<br/>def host() -&gt; str:<br/>    """<br/>    Get IP address of Roku.<br/><br/>    :return: IP address of Roku<br/>    """<br/>    return sleep_timer.host<br/><br/><br/>@app.route("/on")<br/>def on() -&gt; str:<br/>    """<br/>    Turn TV on via Roku.<br/><br/>    :return: On message<br/>    """<br/>    return sleep_timer.on()<br/><br/><br/>@app.route("/off")<br/>def off() -&gt; str:<br/>    """<br/>    Turn TV off via Roku.<br/><br/>    :return: Off message<br/>    """<br/>    return sleep_timer.off()<br/><br/><br/>@app.route("/discover")<br/>def discover() -&gt; str:<br/>    """<br/>    Reset Roku connection to re-find first<br/>    Roku on the network.<br/><br/>    :return: IP address of Roku<br/>    """<br/>    sleep_timer.discover()<br/>    return sleep_timer.host<br/><br/><br/>@app.route("/start/&lt;int:minutes&gt;")<br/>def schedule_sleep(minutes: int):<br/>    """<br/>    Schedule sleep job after the specified number of minutes.<br/><br/>    :param minutes: Number of minutes to wait before sleeping<br/><br/>    :return: Job schedule success message<br/>    """<br/>    return sleep_timer.schedule_sleep(minutes=minutes)<br/><br/><br/>@app.route("/stop")<br/>def stop_sleep() -&gt; str:<br/>    """<br/>    Stop sleep timer by removing all jobs in scheduler.<br/><br/>    :return: Stop message<br/>    """<br/>    return sleep_timer.stop_sleep()<br/><br/><br/>if __name__ == "__main__":<br/>    app.run(host="0.0.0.0", port=int(os.getenv("FLASK_PORT")))</span></pre><p id="24d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我能够通过Flask API调用<code class="fe nq nr ns ng b">RokuSleepTimer</code>，我对应用程序逻辑感到满意。下一个任务是使用Docker和Docker Compose将所有东西打包。</p><h1 id="1c74" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包装一:码头工人</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/0650f8f1a68742f0265c077eb30295f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YW2MbpC5VavhBETM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@exdigy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张秀坤·吕克曼</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5618" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，为什么我使用<a class="ae lr" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> Docker </a>来打包应用程序？</p><p id="8348" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然我可以简单地运行Flask应用程序，但Docker允许环境之间的可移植性/一致性，与主机设备隔离，以及对包和硬件资源的粒度控制。</p><p id="a421" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也使得未来使用相同的技术创建更多服务变得非常简单——剧透警报——<a class="ae lr" href="https://github.com/nschenone/docker-python-flask-template" rel="noopener ugc nofollow" target="_blank">我为此创建了自己的可重用微服务模板</a>。</p><p id="2ddc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了打包应用程序，首先我像这样组织目录结构:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="ded7" class="nk lt iq ng b be nl nm l nn no">├── Dockerfile           # Recipe for building Docker image<br/>├── docker-compose.yml   # Builds image and deploys Docker container<br/>├── requirements.txt     # Python dependencies<br/>├── .env                 # Environment file for secret management<br/>├── Makefile             # Helper to start, stop, and restart app<br/>└── src                  # Source code<br/>    ├── app.py                # Flask application<br/>    └── roku_sleep_timer.py   # Roku control and job scheduling</span></pre><p id="e8b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nq nr ns ng b">Dockerfile</code>完成大部分工作——它负责复制源代码、安装Python依赖项和启动Flask服务器:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="1ef1" class="nk lt iq ng b be nl nm l nn no">#Download Python from DockerHub and use it<br/>FROM python:3.11<br/><br/>#Set the working directory in the Docker container<br/>WORKDIR /code<br/><br/>#Copy the dependencies file to the working directory<br/>COPY requirements.txt .<br/><br/>#Install the dependencies<br/>RUN pip install -r requirements.txt<br/><br/>#Copy the Flask app code to the working directory<br/>COPY src/ .<br/><br/>#Run the container<br/>CMD [ "python", "./app.py" ]</span></pre><p id="d844" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Python依赖关系在<code class="fe nq nr ns ng b">requirements.txt</code>文件中指定——最佳实践规定固定特定版本的库，以防止由于更新导致的意外行为:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="d649" class="nk lt iq ng b be nl nm l nn no">Flask==2.0.1<br/>roku==4.1.0<br/>APScheduler==3.7.0</span></pre><p id="165b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，<code class="fe nq nr ns ng b">src</code>目录中的<code class="fe nq nr ns ng b">app.py</code>和<code class="fe nq nr ns ng b">roku_sleep_timer.py</code>文件使用前面几节中的代码填充</p><h1 id="a636" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包装二:Docker撰写</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/cf452738f35caf4e2ff16ddebfaf2f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjGtOJ1pr4IGpLzHE4OQGA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上下文中的Docker容器—按作者排序的图像</p></figure><p id="5593" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么<code class="fe nq nr ns ng b">docker-compose.yml</code>、<code class="fe nq nr ns ng b">.env</code>、<code class="fe nq nr ns ng b">Makefile</code>文件是干什么用的呢？他们将实际使用<code class="fe nq nr ns ng b">Dockerfile</code>来启动应用程序容器。</p><p id="51b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>比Docker高一级——它允许创建在YAML文件(<code class="fe nq nr ns ng b">docker-compose.yml</code>)中定义的多容器应用程序:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="01f5" class="nk lt iq ng b be nl nm l nn no">version: "3.3"<br/><br/>services:<br/>  flask:<br/>    restart: unless-stopped<br/>    build: .<br/>    image: roku_sleep<br/>    container_name: roku_sleep<br/>    network_mode: "host"       # This was necessary to find Roku on network<br/>    environment:<br/>      - FLASK_PORT=${FLASK_PORT}</span></pre><p id="49ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这个应用程序只有一个容器，但是还有其他好处。Docker Compose允许轻松构建Docker映像并从一个<code class="fe nq nr ns ng b">.env</code>文件注入环境变量。这对于在应用程序中添加任何API键或其他秘密非常有用，无需硬编码任何值。在这种情况下，烧瓶端口通过<code class="fe nq nr ns ng b">.env</code>文件添加。</p><p id="c4c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也许最重要的是，这意味着不再有任何笨拙的<code class="fe nq nr ns ng b">docker run</code>命令带有许多许多参数。要构建Docker映像并运行应用程序，只需运行<code class="fe nq nr ns ng b">docker-compose up -d --build</code>。这将使用您更新的源代码构建映像，并作为后台进程旋转容器。同样，您可以用<code class="fe nq nr ns ng b">docker-compose down</code>停止容器。</p><p id="df5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我为生活质量添加了一个助手<code class="fe nq nr ns ng b">Makefile</code>:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="4a9b" class="nk lt iq ng b be nl nm l nn no">.PHONY: help<br/><br/>help:<br/> @echo "Usage:"<br/> @echo "    up:       Start app"<br/> @echo "    down:     Stop app"<br/> @echo "    restart:  Restart app"<br/><br/>up:<br/> docker-compose up -d --build<br/><br/>down:<br/> docker-compose down<br/><br/>restart: down up</span></pre><p id="91e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些意味着我可以在开发时快速试验和迭代——编辑源代码并运行<code class="fe nq nr ns ng b">make up</code>来重新部署应用程序。这整个目录和文件结构被构建到我自己的可重用微服务模板中，用于创建未来的服务。</p><p id="30c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在应用程序已经和Docker和Docker Compose打包在一起了，我需要一个地方来存放它。</p><h1 id="e6e0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">部署I:自托管</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/ff3c58d8d9ea7661872594c9eec12998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lz9g8s7Iqy1behKM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@ismailenesayhan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">i̇smail·埃尼斯·艾汉</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bcad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为<code class="fe nq nr ns ng b">RokuSleepTimer</code>需要直接连接到Roku，所以应用程序需要托管在我的家庭网络上。我选择将它托管在我的个人服务器上——我办公桌下运行Ubuntu的计算机塔，它负责我的媒体库、数据科学工作台、定制微服务API和其他杂项Docker服务。</p><p id="cf8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是说，Raspberry Pi、台式电脑或笔记本电脑都可以很好地工作——唯一的要求是Docker容器正在运行。在<code class="fe nq nr ns ng b">docker-compose.yml</code>文件中的参数<code class="fe nq nr ns ng b">restart: unless-stopped</code>将确保容器在底层主机重启或关闭时重启。</p><p id="40d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然API现在可以通过<code class="fe nq nr ns ng b">localhost</code>在我的家庭网络中使用，但我最初的需求之一是能够以安全的方式访问网络外部的API。</p><h1 id="bd96" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">部署II: Cloudflare代理</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/60d9a59c11768520a6a6a03533595b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMzT_1i22IRyzkmnH7ol6Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">连接客户端和家庭网络的Cloudflare图片由作者提供</p></figure><p id="39f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了通过公共互联网连接到我的API，我需要在一个定制的域上公开它。你可以从Freenom 获得一个免费域名，但是，我在使用它的时候遇到了一些问题。如果你这样做了，请务必及时更新你的域名——我的域名过期了，我无法取回。我选择从<a class="ae lr" href="https://www.namecheap.com/" rel="noopener ugc nofollow" target="_blank"> Namecheap </a>购买我的域名，它相对便宜，到目前为止运行良好。</p><p id="75c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从那里，<a class="ae lr" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare </a>负责管理DNS，并作为代理隐藏我的家庭公共IP地址:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/e3cf2487e8ace827a6458a0258f40321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_UqD44LpuvoD8f_a1VrGA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Cloudflare DNS条目—作者图片</p></figure><p id="1f62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代理功能不能被低估——在线暴露您的公共IP地址是邀请不需要的客人进入您的网络的一个很好的方式。使用Cloudflare DNS和代理，我可以在<code class="fe nq nr ns ng b">sleeptimer.mydomain.com</code>访问我的API，同时只暴露一个Cloudflare IP地址。</p><p id="ee87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Cloudflare还提供了一些其他安全选项，如使用WAF (Web应用程序防火墙)按地理位置阻止传入请求的能力。我添加了一条规则来阻止任何来自美国以外的请求:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/7b5762c28933abdacc1f153a1c37733f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvBvpeS7KVAKhMO6t9LMLg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Cloudflare WAF防火墙规则—图片由作者提供</p></figure><p id="ec0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我发现这是最有助于阻止不需要的请求到达我的网络的设置。Cloudflare甚至有一些出色的分析仪表盘，用于显示每个国家/地区拦截了多少威胁:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/00d6e07454e50a202c9447d1edc5f752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*124O8ZNpHr_hqmuocY6qmQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按国家/地区阻止的威胁-按作者分类的图片</p></figure><p id="0c3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法对于将传入请求路由到我的网络非常有效——但是，DNS记录只指向我的公共IP。一旦一个请求进入网络，没有关于做什么的指导。</p><h1 id="0b8d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">部署III: NGINX代理管理器</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/108c4da36c11a5fd844286cabc020872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofTO99OL-n6PSZenZ9EOFA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NGINX架构中的代理管理器—图片由作者提供</p></figure><p id="7cb6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">把<a class="ae lr" href="https://nginxproxymanager.com/" rel="noopener ugc nofollow" target="_blank"> NGINX代理管理器</a> (NPM)想象成剧院的引座员——它根据域和子域将传入的请求定向到所需的服务。这是确保进入<code class="fe nq nr ns ng b">sleeptimer.mydomain.com</code>的请求被路由到网络上特定的IP地址和端口的机制。我主要是跟着这个优秀的<a class="ae lr" href="https://www.youtube.com/watch?v=cI17WMKtntA" rel="noopener ugc nofollow" target="_blank">视频</a>通过Docker设置NPM，连接到Cloudflare:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用您的域设置超级简单的Cloudflare和Nginx代理管理器——极客</p></figure><p id="d1b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下NPM配置将我的域连接到在我的本地服务器上运行的服务，IP地址为<code class="fe nq nr ns ng b">192.168.1.168</code>，端口为<code class="fe nq nr ns ng b">5001</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/944e831b711e941f050edc15683084fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFjjpPQqTOKlB6Avo_pzKQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NGINX代理管理器设置—作者图片</p></figure><p id="71ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是因为HTTP (80)和HTTPS (443)的端口在路由器上被转发到运行NPM的机器——在本例中，是在<code class="fe nq nr ns ng b">192.168.1.168</code>的同一台服务器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/363b168b9d94eb842e757f476c2f5cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHAaAfNN8ZCOfY6ftvVsKw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">路由器端口转发设置—作者图片</p></figure><p id="e9ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有其他安全设置，如自动添加SSL证书的能力，以及在发出请求时要求用户/密码验证。这些设置在上面链接的<a class="ae lr" href="https://www.youtube.com/watch?v=cI17WMKtntA" rel="noopener ugc nofollow" target="_blank">视频</a>中有更全面的解释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/c9681d8a96ff6bf52587b1c21a8294b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHowaWZO4tX0WuGH1c8jVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SSL证书设置-按作者分类的图像</p></figure><p id="f4b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些都意味着我的应用程序终于可以被某个最终用户客户端调用了。</p><h1 id="8a9c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">调用:苹果快捷键</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/dfc7104b97099b54da8d638a44239e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29yp8rOckIMpOfVD93kwWA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">架构中的HTTP(S)客户端—作者图片</p></figure><p id="e60d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以这种方式公开API的好处在于它是客户端不可知的——任何发出HTTP(S)请求的方法都可以。</p><p id="c392" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个使用Python <code class="fe nq nr ns ng b">requests</code>库的简单示例，其中授权信息<code class="fe nq nr ns ng b">username:password</code>以base64编码格式在头中提供:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="1da9" class="nk lt iq ng b be nl nm l nn no">import requests<br/>requests.get(<br/>    url="https://sleeptimer.mydomain.com",<br/>    headers={"Authorization": "Basic dXNlcm5hbWU6cGFzc3dvcmQ"}<br/>)<br/><br/># returns "Connected"</span></pre><p id="9397" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种一般模式可以用任何方法复制。因为我有一部iPhone，所以我选择使用所有更新的苹果产品自带的原生<a class="ae lr" href="https://support.apple.com/guide/shortcuts/welcome/ios" rel="noopener ugc nofollow" target="_blank">苹果快捷方式</a>应用。它是一个简单的基于GUI的工具，用于Apple生态系统中的通用自动化。非苹果用户的另一个很好的选择是<a class="ae lr" href="https://ifttt.com/" rel="noopener ugc nofollow" target="_blank"> IFTTT </a>。</p><p id="17ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下快捷方式提示用户输入分钟数，并使用提供的数字和授权信息启动睡眠定时器。此处<a class="ae lr" href="https://www.icloud.com/shortcuts/7e516d9a588c468580bd7580064b9595" rel="noopener ugc nofollow" target="_blank">提供了一个模板</a>，您可以根据自己的需要进行修改:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/2dc2e3aa278aceb4737e3ed9be638521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0XetVRIp8axHN68uaKkHA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">苹果睡眠定时器快捷方式——作者图片</p></figure><p id="3a48" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从那里，可以通过主屏幕上的小工具或通过Siri的语音控制轻松调用睡眠定时器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3942d3a41d8bc7911890cd1de4702e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZzNIXcwu9hfczHjfhwLlsg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Roku睡眠计时器的运行——图片由作者提供</p></figure><h1 id="50f7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结束语</h1><p id="4112" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">总的来说，这是为了解决一个简单而不重要的问题而付出的大量工程努力。然而，这里真正的故事是用于在家中自托管服务并将它们安全地公开为面向公众的API的整体方法和技术。</p><p id="02af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个项目是在我的网络上创建附加服务的门户。我利用从Roku项目中学到的知识创建了我自己的可重用微服务模板，比如托管网站、向我的个人Slack工作区发送通知、通过YNAB自动生成支出报告以及从数据库中检索任务。</p><p id="649e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">向系统添加新服务非常简单:</p><ul class=""><li id="b9d1" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">使用<a class="ae lr" href="https://github.com/nschenone/docker-python-flask-template" rel="noopener ugc nofollow" target="_blank">模板</a>将新的Dockerized应用程序部署到服务器上的给定端口</li><li id="7e4f" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">在Cloudflare中为新子域名添加DNS路由(例如<code class="fe nq nr ns ng b">service.mydomain.com</code>)</li><li id="e811" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">在NGINX代理管理器中添加route，将传入请求路由到新服务</li></ul><p id="b685" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望本指南对您有所帮助，并激励您为任何对您有用的东西创建自己的自托管服务！</p><h1 id="0458" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考</h1><ul class=""><li id="adf9" class="mq mr iq kx b ky mk lb ml le ok li ol lm om lq mv mw mx my bi translated"><a class="ae lr" href="https://support.apple.com/guide/shortcuts/welcome/ios" rel="noopener ugc nofollow" target="_blank">苹果快捷方式用户指南</a></li><li id="9aeb" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://apscheduler.readthedocs.io/en/3.x/" rel="noopener ugc nofollow" target="_blank"> APScheduler(高级Python调度程序)</a></li><li id="c1d1" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://en.wikipedia.org/wiki/Consumer_Electronics_Control" rel="noopener ugc nofollow" target="_blank"> CEC(消费电子控制)</a></li><li id="2f2b" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank">云闪</a></li><li id="f76b" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="f5c7" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker撰写</a></li><li id="84de" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://github.com/nschenone/docker-python-flask-template" rel="noopener ugc nofollow" target="_blank"> Docker Python烧瓶模板GitHub Repo </a></li><li id="654b" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://flask.palletsprojects.com/en/2.2.x/" rel="noopener ugc nofollow" target="_blank">烧瓶</a></li><li id="ff3e" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://ifttt.com/explore" rel="noopener ugc nofollow" target="_blank"> IFTTT (If This Then That) </a></li><li id="fa31" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://nginxproxymanager.com/" rel="noopener ugc nofollow" target="_blank"> NGINX代理管理器</a></li><li id="9dbf" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://github.com/jcarbaugh/python-roku" rel="noopener ugc nofollow" target="_blank"> Python Roku </a></li><li id="d6e0" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://github.com/nschenone/roku-sleep-timer" rel="noopener ugc nofollow" target="_blank"> Roku睡眠定时器GitHub Repo </a></li><li id="3221" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><a class="ae lr" href="https://www.youtube.com/watch?v=cI17WMKtntA" rel="noopener ugc nofollow" target="_blank">使用您的域名设置超级简单的Cloudflare和Nginx代理管理器</a></li></ul></div></div>    
</body>
</html>