<html>
<head>
<title>Understand JavaScript Closures in 4 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在4分钟内理解JavaScript闭包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-javascript-closures-in-4-minutes-adfd30fc568f?source=collection_archive---------9-----------------------#2021-04-15">https://betterprogramming.pub/understand-javascript-closures-in-4-minutes-adfd30fc568f?source=collection_archive---------9-----------------------#2021-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="111d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">闭包是JavaScript中的一个重要概念。许多教程使它看起来比实际更复杂。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74ce218339818e3c112648e2e6e9aae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fzKkJMWJsW1DgSZu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cebbbinghaus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·罗宾·艾宾浩斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e8e4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">快速定义</h1><p id="da52" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在JavaScript中，闭包意味着内部函数可以访问属于外部函数的变量。即使外部函数的执行已经完成，这也适用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/3a8456da50ca0d5fd5ddb82f12aeac51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkRWCvHFUkPEBj1Uz4qopQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由于JavaScript中闭包的性质，可以在increment函数中访问counter变量。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="cd24" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">例子</h1><h2 id="712a" class="mv lh it bd li mw mx dn lm my mz dp lq mh na nb ls ml nc nd lu mp ne nf lw ng bi translated">正则函数的一个例子</h2><p id="5b34" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在进入闭包之前，让我们看看一个常规函数是如何工作的:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="584b" class="mv lh it ni b gy nm nn l no np"><strong class="ni iu">function</strong> hello() {<br/>  <strong class="ni iu">const</strong> sentence = "Hello world"<br/>  console.log(sentence);<br/>}</span><span id="80ba" class="mv lh it ni b gy nq nn l no np">hello(); // prints "Hello world" to the console</span></pre><p id="76e9" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">当调用<code class="fe nw nx ny ni b">hello()</code>时，花括号之间的代码执行。当执行完成时，您不能再访问变量(例如<code class="fe nw nx ny ni b">sentence</code>)。这是非常基本的，你可能已经知道了。</p><p id="a717" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">然而，在特定的设置下，当一个函数执行完成时，你<em class="nz">仍然可以</em>访问那些“应该”不可访问的变量。当然，我指的是这种设置的闭包。</p><h2 id="7605" class="mv lh it bd li mw mx dn lm my mz dp lq mh na nb ls ml nc nd lu mp ne nf lw ng bi translated">使用闭包的例子</h2><p id="793c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">例如，让我们在函数中创建一个内部函数<em class="nz">，并返回它:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="ba70" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated"><code class="fe nw nx ny ni b">outer</code>函数返回<code class="fe nw nx ny ni b">inner</code>函数。这意味着你可以将返回的<code class="fe nw nx ny ni b">inner</code>函数赋给一个变量。例如:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="faa3" class="mv lh it ni b gy nm nn l no np"><strong class="ni iu">const</strong> greet = outer()</span></pre><p id="1852" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">现在您可以调用带括号的<code class="fe nw nx ny ni b">greet</code>(像任何其他函数一样)来执行附加到它的<code class="fe nw nx ny ni b">inner</code>函数的代码:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="da97" class="mv lh it ni b gy nm nn l no np">greet()</span></pre><p id="6f01" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">输出:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b05d" class="mv lh it ni b gy nm nn l no np">Hello world</span></pre><p id="a4c3" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">但是等一下……因为<code class="fe nw nx ny ni b">greet()</code>现在执行<code class="fe nw nx ny ni b">inner</code>函数的代码，这意味着当只定义了<code class="fe nw nx ny ni b">b</code>时，它试图记录<code class="fe nw nx ny ni b">a+b</code>:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="08f4" class="mv lh it ni b gy nm nn l no np">// This function gets executed when calling <em class="nz">greet()</em></span><span id="5cda" class="mv lh it ni b gy nq nn l no np"><strong class="ni iu">function</strong> inner() {<br/>     <strong class="ni iu">const</strong> b = "World"; <br/>     console.log(a+b);<br/>}</span></pre><p id="2c99" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">但是你也看到了它工作得很好。这意味着<code class="fe nw nx ny ni b">greet()</code>必须能够访问<code class="fe nw nx ny ni b">a</code>，即使看起来不可能。</p><p id="1f6a" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">多亏了闭包，事实确实如此。请记住闭包的含义:即使在外部函数的执行完成之后，内部函数也可以访问外部函数的变量。</p><p id="f1ce" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">记住这一点，<code class="fe nw nx ny ni b">inner</code>函数实际上知道它在一个名为<code class="fe nw nx ny ni b">outer</code>的函数中。因此，它保存了属于<code class="fe nw nx ny ni b">outer</code>函数的变量。这就是为什么<code class="fe nw nx ny ni b">greet()</code>仍然可以访问值<code class="fe nw nx ny ni b">a</code>的原因。当<code class="fe nw nx ny ni b">outer()</code>被调用时，<code class="fe nw nx ny ni b">inner</code>保存变量<code class="fe nw nx ny ni b">a</code>以备后用。</p><p id="e575" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">干得好！现在您知道了JavaScript中闭包的基本工作原理。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e82b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">闭包的真实例子</h1><p id="48a1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">让我们设置一个计数器:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3b5f" class="mv lh it ni b gy nm nn l no np"><strong class="ni iu">var</strong> counter = 0;</span><span id="f489" class="mv lh it ni b gy nq nn l no np"><strong class="ni iu">function</strong> increment() {<br/>  counter++;<br/>}</span></pre><p id="d612" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">调用<code class="fe nw nx ny ni b">increment()</code>工作正常。但是有一个问题:变量<code class="fe nw nx ny ni b">counter</code>也可以在<code class="fe nw nx ny ni b">increment</code>之外调整，所以它可能会被意外地设置为<code class="fe nw nx ny ni b">1000</code>，例如，在代码的其他地方。这是不实际的。</p><p id="eefb" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">为了构建一个可靠的计数器，您需要将它与<code class="fe nw nx ny ni b">increment</code>函数耦合起来，这样代码的其他部分就不会意外地搞乱它。</p><p id="85e8" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">这就是闭包派上用场的地方。让我们通过在前面看到的函数结构中使用相同的<em class="nz">函数来重新实现计数器:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b6a3" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">让我们更仔细地研究一下实现，以便充分利用它:</p><ul class=""><li id="9821" class="oc od it ma b mb nr me ns mh oe ml of mp og mt oh oi oj ok bi translated"><code class="fe nw nx ny ni b">createCounter</code>是一个外部函数。它将一个<code class="fe nw nx ny ni b">counter</code>变量设置为<code class="fe nw nx ny ni b">0</code>，并返回一个名为<code class="fe nw nx ny ni b">increment</code>的内部函数。</li><li id="ade9" class="oc od it ma b mb ol me om mh on ml oo mp op mt oh oi oj ok bi translated"><code class="fe nw nx ny ni b">increment</code>负责递增<code class="fe nw nx ny ni b">counter</code>变量。</li><li id="24db" class="oc od it ma b mb ol me om mh on ml oo mp op mt oh oi oj ok bi translated">由于JavaScript中的自然闭包，<code class="fe nw nx ny ni b">increment</code>可以访问属于<code class="fe nw nx ny ni b">createCounter</code> <em class="nz">的变量，即使在</em>的<code class="fe nw nx ny ni b">createCounter</code>执行完成之后。这样，<code class="fe nw nx ny ni b">increment</code>就可以把<code class="fe nw nx ny ni b">1</code>加到<code class="fe nw nx ny ni b">counter</code>上。</li></ul><p id="4eb6" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">现在，让我们调用<code class="fe nw nx ny ni b">createCounter()</code>来设置计数器:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="35ec" class="mv lh it ni b gy nm nn l no np"><strong class="ni iu">let</strong> add = createCounter();</span></pre><p id="6fd9" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">在引擎盖下，这一行创建了一个被设置为<code class="fe nw nx ny ni b">0</code>的<code class="fe nw nx ny ni b">counter</code>变量。然后名为<code class="fe nw nx ny ni b">increment</code>的内部函数被返回并存储到名为<code class="fe nw nx ny ni b">add</code>的变量中。</p><p id="5aaa" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">现在可以调用<code class="fe nw nx ny ni b">add</code>来增加<code class="fe nw nx ny ni b">counter</code>。让我们做三次，看看会发生什么:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9135" class="mv lh it ni b gy nm nn l no np">add();<br/>add();<br/>add();</span></pre><p id="adee" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">输出:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d8bd" class="mv lh it ni b gy nm nn l no np">1<br/>2<br/>3</span></pre><p id="b6b3" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">这样做是因为像前面一样，调用<code class="fe nw nx ny ni b">add()</code>会执行内部函数<code class="fe nw nx ny ni b">increment</code>的代码，该函数仍然可以访问<code class="fe nw nx ny ni b">counter</code>变量:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7c6a" class="mv lh it ni b gy nm nn l no np"><strong class="ni iu">function</strong> increment() {<br/>     counter++;<br/>     console.log(counter);<br/>}</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fcd9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="99e3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在JavaScript中，闭包是一个使函数能够访问其作用域之外的变量的特性——即使在外部作用域被破坏之后。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/3a8456da50ca0d5fd5ddb82f12aeac51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkRWCvHFUkPEBj1Uz4qopQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">变量counter可以在内部函数increment中访问。</p></figure><p id="6ec7" class="pw-post-body-paragraph ly lz it ma b mb nr ju md me ns jx mg mh nt mj mk ml nu mn mo mp nv mr ms mt im bi translated">感谢阅读。希望你觉得有用。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1e0c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">资源</h1><div class="oq or gp gr os ot"><a href="https://devdocs.io/javascript/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">DevDocs</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">JavaScript API文档，包括即时搜索、离线支持、键盘快捷键、移动版本等等。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">devdocs.io</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>