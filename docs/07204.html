<html>
<head>
<title>3 Concurrent Patterns Used in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中使用的3种并发模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-concurrent-patterns-used-in-golang-b107c52f1c06?source=collection_archive---------0-----------------------#2020-12-17">https://betterprogramming.pub/3-concurrent-patterns-used-in-golang-b107c52f1c06?source=collection_archive---------0-----------------------#2020-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="74c4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go中的并发性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/52e2ab080b519bc394f31a32be829f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*KHjeTlOeAyTRH_RR_6M4mQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来自<a class="ae ku" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>。</p></figure><p id="b40a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当一个程序或者一个算法是<em class="lr">并发</em>时，意味着它被设计成分解成更小的部分，这些部分将在独立的进程中并行执行。换句话说，正如<a class="ae ku" href="https://blog.golang.org/waza-talk" rel="noopener ugc nofollow" target="_blank">罗布·派克所说</a>:</p><blockquote class="ls"><p id="6491" class="lt lu it bd lv lw lx ly lz ma mb lq dk translated">“并发是指同时处理许多事情。并行就是同时做很多事情。”</p></blockquote><p id="dac8" class="pw-post-body-paragraph kv kw it kx b ky mc ju la lb md jx ld le me lg lh li mf lk ll lm mg lo lp lq im bi translated">并发性与程序的设计有很大关系。当设计开始时，重用以前解决问题的模式是一个好主意，这样可以避免重新发明轮子。</p><p id="366c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，我将向您展示在Go中实现并发计数器的三种不同模式。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="c64e" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">1.原子的</h1><p id="e6ec" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated"><code class="fe nl nm nn no b"><a class="ae ku" href="https://golang.org/pkg/sync/atomic" rel="noopener ugc nofollow" target="_blank">sync/atomic</a></code>由Go out of the box提供，允许您在多个goroutines中安全地执行整数的原子操作。</p><p id="a920" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们的例子中，我们将从不同的goroutines同时增加我们的计数器。为此，我们将调用<code class="fe nl nm nn no b">AddInt32</code>，传递一个指向计数器的指针和一个增量作为参数。然后，为了安全地访问计数器值，我们可以使用<code class="fe nl nm nn no b">LoadInt32</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">并发计数器的原子方法</p></figure><p id="743d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里的输出是什么？</p><pre class="kj kk kl km gt nr no ns nt aw nu bi"><span id="050b" class="nv mp it no b gy nw nx l ny nz">Counter: 100</span></pre><p id="e3b5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意，goroutines正在后台运行，并且在执行<code class="fe nl nm nn no b">log.Printf</code>时仍将运行，因此我们需要使用<code class="fe nl nm nn no b"><a class="ae ku" href="https://golang.org/pkg/sync/#WaitGroup" rel="noopener ugc nofollow" target="_blank">sync.WaitGroup</a></code>来等待它们。</p><p id="4bef" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">基本上，我们将我们的算法分成100个更小的部分，并以两个一批的方式分派它们，从而异步地将计数器加1。这种方法基于共享内存——更具体地说，共享对整数的引用——并同步对它的访问。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="7311" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">2.互斥（体）…</h1><p id="5f0d" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">互斥锁允许你同步访问更复杂的数据结构。在本例中，我们将使用<code class="fe nl nm nn no b"><a class="ae ku" href="https://golang.org/pkg/sync/#RWMutex" rel="noopener ugc nofollow" target="_blank">sync.RWMutex</a></code>，它提供了两种锁定模式:</p><ul class=""><li id="7114" class="oa ob it kx b ky kz lb lc le oc li od lm oe lq of og oh oi bi translated"><code class="fe nl nm nn no b">Lock/Unlock</code>:在写入模式下锁定/解锁数据结构。作者和读者都不能访问它。</li><li id="d747" class="oa ob it kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated"><code class="fe nl nm nn no b">RLock/RUnlock</code>:在读取模式下锁定/解锁数据结构。读者可以访问它，但作者不能。利用这一点，您可以在有大量读者和少量作者的情况下获得更好的性能。</li></ul><p id="9802" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">考虑到这一点，我们将创建一个<code class="fe nl nm nn no b">counter</code>数据结构，它由计数器的实际值和同步其访问的互斥体组成。我们还将分别实现<code class="fe nl nm nn no b">increment</code>和<code class="fe nl nm nn no b">getValue</code>方法来安全地更新和访问计数器的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">并发计数器的互斥方法</p></figure><p id="3621" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">值得注意的是，我们需要在执行操作后解锁互斥体。否则，即将到来的将无限期等待，你的程序最终会崩溃。</p><p id="a449" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">和前面的例子一样，这种方法通过共享内存来工作。但是在这种情况下，结构引用是从多个goroutines中访问的。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="70b7" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">3.频道</h1><p id="0cf5" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">在这篇<a class="ae ku" href="https://blog.golang.org/codelab-share" rel="noopener ugc nofollow" target="_blank">博客文章</a>中，Go团队描述了一种新的处理并发的优雅方式:</p><blockquote class="ls"><p id="3144" class="lt lu it bd lv lw lx ly lz ma mb lq dk translated">“不要通过共享内存来交流；而是通过交流来分享记忆。”</p></blockquote><p id="57df" class="pw-post-body-paragraph kv kw it kx b ky mc ju la lb md jx ld le me lg lh li mf lk ll lm mg lo lp lq im bi translated">这意味着不要在共享内存中与复杂的互斥情况作斗争，而要使用通道来传递goroutines。</p><p id="034b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是……为什么呢？</p><p id="8e2a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当向通道发送消息时，只有一个goroutine将接收它，因此从那里访问数据是安全的，并且不需要显式同步，因为它是由Go在幕后处理的。</p><p id="18cb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">按照这种方法，我们将有一个goroutine来保存计数器的状态，另一方面，其他go routine将发送消息，第一个go routine将接收这些消息以与状态进行交互。我们有两种类型的消息:</p><ul class=""><li id="405f" class="oa ob it kx b ky kz lb lc le oc li od lm oe lq of og oh oi bi translated"><code class="fe nl nm nn no b">incrementOp</code>:请求递增计数器的操作。</li><li id="b500" class="oa ob it kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated"><code class="fe nl nm nn no b">valueOp</code>:请求计数器值的操作。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">并行计数器的通道方法</p></figure><p id="25fe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意，所有操作都有一个<code class="fe nl nm nn no b">res</code>通道，其目的如下:</p><ul class=""><li id="f85c" class="oa ob it kx b ky kz lb lc le oc li od lm oe lq of og oh oi bi translated">接收操作的响应</li><li id="6119" class="oa ob it kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated">同步goroutines</li></ul><p id="91c1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如您所见，这种策略不像前面的策略那样基于共享内存<strong class="kx iu"> </strong>，而是依赖于通过通道发送操作。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="b454" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">包扎</h1><p id="b629" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">并发可能很难，因此找到合适的工具来解决您的问题很重要:</p><ul class=""><li id="0ff6" class="oa ob it kx b ky kz lb lc le oc li od lm oe lq of og oh oi bi translated"><code class="fe nl nm nn no b"><a class="ae ku" href="https://golang.org/pkg/sync/atomic" rel="noopener ugc nofollow" target="_blank">sync.atomic</a></code>:用整数做运算时有用。</li><li id="1b57" class="oa ob it kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated"><code class="fe nl nm nn no b"><a class="ae ku" href="https://golang.org/pkg/sync/#Mutex" rel="noopener ugc nofollow" target="_blank">sync.Mutex</a></code>和<code class="fe nl nm nn no b"><a class="ae ku" href="https://golang.org/pkg/sync/#RWMutex" rel="noopener ugc nofollow" target="_blank">sync.RWMutex</a></code>:用于同步访问更复杂的数据结构。这是经典的方法，允许自定义锁定。</li><li id="9240" class="oa ob it kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated">通道:当互斥不是一个选项或者操作起来很复杂的时候。</li></ul><p id="1aba" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">编码快乐！感谢阅读。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="0a64" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">资源</h1><div class="oo op gp gr oq or"><a href="https://github.com/mmontes11/go-examples/tree/master/concurrency/counter" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">mmontes 11/go-示例</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ko or"/></div></div></a></div><ul class=""><li id="c93e" class="oa ob it kx b ky kz lb lc le oc li od lm oe lq of og oh oi bi translated"><a class="ae ku" href="https://blog.golang.org/waza-talk" rel="noopener ugc nofollow" target="_blank">https://blog.golang.org/waza-talk</a></li><li id="00ed" class="oa ob it kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated">https://blog.golang.org/codelab-share<a class="ae ku" href="https://blog.golang.org/codelab-share" rel="noopener ugc nofollow" target="_blank"/></li><li id="d913" class="oa ob it kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated">【https://golang.org/pkg/sync/atomic T4】</li><li id="ef14" class="oa ob it kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated"><a class="ae ku" href="https://golang.org/pkg/sync/" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/sync</a></li><li id="47a1" class="oa ob it kx b ky oj lb ok le ol li om lm on lq of og oh oi bi translated"><a class="ae ku" href="https://gobyexample.com/" rel="noopener ugc nofollow" target="_blank">https://gobyexample.com</a></li></ul></div></div>    
</body>
</html>