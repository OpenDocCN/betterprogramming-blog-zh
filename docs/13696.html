<html>
<head>
<title>An Invention of JavaScript Threadable Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript线程类的发明</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-invention-of-js-threadable-class-8e8e82e1615?source=collection_archive---------10-----------------------#2022-09-17">https://betterprogramming.pub/an-invention-of-js-threadable-class-8e8e82e1615?source=collection_archive---------10-----------------------#2022-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bc9a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们实现promisified，一个可线程化的JavaScript函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dcfbb8a3992f9c5bd79dfc4f0827ebc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yz3JNKsIYHF1f8GD"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@amir_v_ali?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿米拉里·米尔哈西米安</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5d4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript通过其本地事件驱动的异步处理对并发性进行了合理的抽象，通过Web Workers对并行性进行了抽象。但是，我总觉得缺少了一个环节。</p><p id="79c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然对于IO来说已经足够了，但事件驱动的并发性只是一种模拟，仍然在单线程上运行。这实际上是因为JavaScript背后的原始想法是巧妙地在浏览器窗口上显示元素。</p><p id="9aff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，试着聪明一点，一些繁重的计算可能需要一些时间来完成，明智的做法是将这些繁重的任务分成一些子任务，并以并行方式在单独的线程上同时处理它们。因此我们有了网络工作者。请注意名称中的“Web”部分。它还在瞄准显示器。</p><p id="9452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，Web Workers提供了一个基于回调的有限API。更糟糕的是，您必须提前将并行任务设置为单独的任务。js文件。</p><p id="0f15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的设计模式是基于更新网页内容。然而，我认为JavaScript是一种完全成熟的语言，应该有更好的抽象来处理通用并行处理需求。JavaScript拥有完美完成这项任务所需的所有工具。所以让我们勇敢一点，尝试去做。</p><h2 id="003e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">我们的设计标准应该是什么？</h2><ol class=""><li id="eb16" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated">使用workers需要一个异步接口。于是我们有了JS里最美的一个，也就是承诺。</li><li id="f28f" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">这个想法是将任何标准函数变成异步线程函数。这意味着我们必须为标准功能增加额外的功能。可扩展的<code class="fe nb nc nd ne b">Class</code>抽象用于通过扩展函数构造函数来提高函数的容量。</li><li id="82a5" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">我们可能更喜欢这样的升级函数来保持它们的正常行为，这样它们也可以被同步调用。</li></ol><p id="079f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以没错，我们会在这个题目下实现promisified threadable函数。</p><p id="b2d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该知道，只有当任务繁重到足以抵消大量工作线程的成本时，线程才有价值。仅仅因为你有八个内核，并不意味着任何线程功能的执行速度会快八倍。没有这个功能。正如您将在下面的示例中看到的，有时不使用任何低于阈值的线程会更有效。所以首先，我们必须决定是否值得努力。<code class="fe nb nc nd ne b">Threadable</code>类是理想的，甚至可以测试它是否值得。</p><p id="010a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使这篇文章更加有趣和有益，让我们不要使用像加法这样愚蠢的函数，而是将一个更有用的函数变成threadable，一举两得。假设我们想要实现<code class="fe nb nc nd ne b"><em class="nf">π</em></code>函数，并使其可线程化。</p><p id="d6bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd ne b"><em class="nf">π(n)</em></code>函数给出了最高达<code class="fe nb nc nd ne b"><em class="nf">n</em></code>的素数。正如你可能很容易猜到的，随着<code class="fe nb nc nd ne b"><em class="nf">n</em></code>的增长，它有可能成为一项繁重的任务。虽然这与Riemann Zeta函数无关，但我将向您展示一个用JavaScript实现的Sundaram改良筛的最佳实现。所以让我们继续无耻地从<a class="ae kv" href="https://stackoverflow.com/a/41434702/4543207" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>中复制它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6a76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不要太担心它是如何工作的。它只是一个修改过的<code class="fe nb nc nd ne b"><em class="nf">π(n)</em></code>函数，计算两个极限之间的素数。比如500K到1M之间有多少素数- &gt; 36960种。我们需要这样做，因为我们适当的可线程化的<code class="fe nb nc nd ne b"><em class="nf">π(n)</em></code>函数将把<code class="fe nb nc nd ne b">0 <em class="nf">— n</em></code>范围分成类似于<code class="fe nb nc nd ne b">0 — <em class="nf">n</em>/8, <em class="nf">n</em>/8–<em class="nf">n</em>/4, …, 7<em class="nf">n</em>/8 — <em class="nf">n</em> </code>的子范围，以便在单独的线程中处理。</p><p id="1f71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是引入Threadable类的时候了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="68af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，任何函数<code class="fe nb nc nd ne b">f(a)</code>都变成可线程化的，如下所示:</p><pre class="kg kh ki kj gt ni ne nj nk aw nl bi"><span id="1255" class="ls lt iq ne b gy nm nn l no np">var g = new Threadable(f); // g is now threadable version of f</span></pre><p id="9314" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你有两个选择。如果你像<code class="fe nb nc nd ne b">g.spawn(a)</code>一样调用它，那么它在一个单独的线程上运行，并返回一个承诺，一旦工人发送回一个包含数据的消息，这个承诺将被解决。</p><p id="4d8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以像<code class="fe nb nc nd ne b">g(a)</code>一样以单线程方式同步运行<code class="fe nb nc nd ne b">g</code>。</p><p id="5fdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在回到我们的测试，代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="340c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我在这里向您展示一些基准测试，它们都来自我的垃圾AMD FX 8370八核台式机:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/abceaaa7d2bc5ed96dafbccfb66c8e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*jt5exBaZHs0ANJS7VXW6vQ.png"/></div></figure><p id="23bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所猜测的，生成八个线程的开销大约是95毫秒。因此，对于这个函数，切换到线程操作的阈值大约在<code class="fe nb nc nd ne b">n = 20M</code>左右，这意味着在<code class="fe nb nc nd ne b">n = 20,000,000</code>以下，我们最好保持单线程。</p><p id="dce8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nf">感谢阅读！敬请关注更多内容。</em></p></div></div>    
</body>
</html>