<html>
<head>
<title>DOM Manipulation and the Dangers of ‘innerHTML’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DOM操作和“innerHTML”的危险</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dom-manipulation-the-dangers-of-innerhtml-602f4119d905?source=collection_archive---------4-----------------------#2020-07-14">https://betterprogramming.pub/dom-manipulation-the-dangers-of-innerhtml-602f4119d905?source=collection_archive---------4-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cbdb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用JavaScript更改DOM时避免使用<code class="fe ki kj kk kl b">'innerHTML’</code>的5个原因</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e3249d0431102dc2def1d916654fecd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-xxY7jhxmvJKdF8R"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@grakozy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格雷格·拉科齐</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="ce7e" class="ld le it bd lf lg lh li lj lk ll lm ln jz lo ka lp kc lq kd lr kf ls kg lt lu bi translated">介绍</h1><p id="531f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">当我编写一些基本的JS来进行DOM操作和事件监听时，我遇到了一个让我困惑的bug。我花时间研究堆栈溢出，寻找解决方案，但无济于事。为了复制这个bug，我将展示我的代码的一个简化版本。</p><p id="f9ff" class="pw-post-body-paragraph lv lw it lx b ly mr ju ma mb ms jx md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">首先，我有一个主体中只有一个<code class="fe ki kj kk kl b">div</code>的基本HTML文件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">带有单个div的基本HTML</p></figure><p id="aa30" class="pw-post-body-paragraph lv lw it lx b ly mr ju ma mb ms jx md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">在JavaScript文件中，我向DOM添加了一些节点，并在一个按钮上创建了一个事件监听器:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">使用“innerHTML”进行DOM操作</p></figure><p id="5e61" class="pw-post-body-paragraph lv lw it lx b ly mr ju ma mb ms jx md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">在浏览器中，我的页面如期出现。有一个图像，后面是一个按钮和一些我添加到DOM中的附加文本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi my"><img src="../Images/68f3064da6546f06197e9554e155aa64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSwJPi--VkjCFQJw_umDtg.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">web浏览器中的内容</p></figure><p id="3717" class="pw-post-body-paragraph lv lw it lx b ly mr ju ma mb ms jx md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">快速浏览一下代码，这个按钮有一个明确定义的用途。当它被点击时，字符串<code class="fe ki kj kk kl b">hello</code>应该被输出到控制台。但是，单击该按钮时，不会打印任何内容。为什么？</p><p id="95af" class="pw-post-body-paragraph lv lw it lx b ly mr ju ma mb ms jx md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">首先，让我们试着找出bug是从哪里被引入到代码中的。首先，我将注释掉<code class="fe ki kj kk kl b">div.innerHTML +=</code>行。</p><p id="d021" class="pw-post-body-paragraph lv lw it lx b ly mr ju ma mb ms jx md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">现在，当我点击按钮时，一切都按预期运行。点击按钮后，<code class="fe ki kj kk kl b">hello</code>将被登录到控制台。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mz"><img src="../Images/4f001a48e32f5f7ba82009eb897a0bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PH6_9ES-w0gFfvSlETpUKg.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">按钮按预期工作</p></figure><p id="38f2" class="pw-post-body-paragraph lv lw it lx b ly mr ju ma mb ms jx md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">显然，带有<code class="fe ki kj kk kl b">innerHTML +=</code>的那一行引起了重大问题。作为一名JS程序员，使用诸如<code class="fe ki kj kk kl b">++</code>和<code class="fe ki kj kk kl b">+=</code>这样的操作符似乎很自然。然而，将<code class="fe ki kj kk kl b">+=</code>操作符与<code class="fe ki kj kk kl b">innerHTML</code>一起使用将会导致重大问题。下面我们来讨论一下原因。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="f0bc" class="ld le it bd lf lg nh li lj lk ni lm ln jz nj ka lp kc nk kd lr kf nl kg lt lu bi translated">追加到<code class="fe ki kj kk kl b">'innerHTML'</code>重新解析整个标签</h1><p id="b40a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">当您将append操作符与<code class="fe ki kj kk kl b">innerHTML</code>一起使用时，Javascript将重新解析整个标签的内容，并重新创建所有的HTML元素。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="c954" class="ld le it bd lf lg nh li lj lk ni lm ln jz nj ka lp kc nk kd lr kf nl kg lt lu bi translated"><code class="fe ki kj kk kl b">'innerHTML'</code>非常慢</h1><p id="aa4b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">作为前一个原因的自然副作用，重新解析使得<code class="fe ki kj kk kl b">innerHTML</code>非常慢。对于包含静态文本的小型HTML文档，这可能不是问题。但是，对于较大的文档，重新解析过程非常耗时，并且可能会产生意想不到的副作用。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="aa9f" class="ld le it bd lf lg nh li lj lk ni lm ln jz nj ka lp kc nk kd lr kf nl kg lt lu bi translated"><code class="fe ki kj kk kl b">'innerHTML’</code>删除事件监听器</h1><p id="297d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">从我们简短的实验中得出的最明显的结论是<code class="fe ki kj kk kl b">innerHTML</code>删除了之前已经添加到DOM中的事件监听器。由于整个标签(我们代码中的<code class="fe ki kj kk kl b">div</code>)正在被重新解析，事件监听器在这个过程中丢失了。不要使用<code class="fe ki kj kk kl b">+=</code>操作符，而是使用DOM函数，比如<code class="fe ki kj kk kl b">append()</code>。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="b75b" class="ld le it bd lf lg nh li lj lk ni lm ln jz nj ka lp kc nk kd lr kf nl kg lt lu bi translated"><code class="fe ki kj kk kl b">'innerHTML’</code>存在安全风险</h1><p id="75d6" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">使用<code class="fe ki kj kk kl b">innerHTML</code>会给你的网站带来潜在的安全风险。恶意用户可以使用跨站点脚本(XSS)来添加恶意客户端脚本，从而窃取存储在会话cookies中的私人用户信息。</p><p id="203f" class="pw-post-body-paragraph lv lw it lx b ly mr ju ma mb ms jx md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">你可以在<code class="fe ki kj kk kl b">innerHTML</code>上阅读<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#:~:text=Security%20considerations,creating%20a%20potential%20security%20risk.&amp;text=Although%20this%20may%20look%20like,attack,%20the%20result%20is%20harmless." rel="noopener ugc nofollow" target="_blank"> MDN文档</a>。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="b1c9" class="ld le it bd lf lg nh li lj lk ni lm ln jz nj ka lp kc nk kd lr kf nl kg lt lu bi translated">符合W3C的方法可以很容易地添加新的DOM元素</h1><p id="9744" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">诸如<code class="fe ki kj kk kl b">.createElement()</code>、<code class="fe ki kj kk kl b">appendChild()</code>、<code class="fe ki kj kk kl b">append()</code>和<code class="fe ki kj kk kl b">removeChild()</code>之类的方法允许安全的DOM操作，而没有<code class="fe ki kj kk kl b">innerHTML</code>(更具体地说是<code class="fe ki kj kk kl b">innerHTML+=</code>)的意外后果。除非你只是在一个HTML标签中设置文本，比如一个<code class="fe ki kj kk kl b">&lt;p&gt;</code>或者<code class="fe ki kj kk kl b">&lt;div&gt;</code>，否则请远离<code class="fe ki kj kk kl b">innerHTML</code>。</p><p id="ec81" class="pw-post-body-paragraph lv lw it lx b ly mr ju ma mb ms jx md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">对于初学者来说，<code class="fe ki kj kk kl b">innerHTML</code>似乎是操作DOM上基本元素的最简单、最优雅的方式。然而，随着您的JS变得越来越复杂，您的DOM变得越来越大，<code class="fe ki kj kk kl b">innerHTML</code>将损害性能并引入安全风险。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="886e" class="ld le it bd lf lg nh li lj lk ni lm ln jz nj ka lp kc nk kd lr kf nl kg lt lu bi translated">参考资料和补充阅读</h1><ul class=""><li id="5a5a" class="nm nn it lx b ly lz mb mc me no mi np mm nq mq nr ns nt nu bi translated"><a class="ae lc" href="https://www.tutorialspoint.com/disadvantages-of-using-innerhtml-in-javascript#:~:text=There%20is%20no%20append%20support,changing%20innerHTML%20directly%20very%20slow.&amp;text=innerHTML%20does%20not%20provide%20validation,the%20document%20and%20break%20it." rel="noopener ugc nofollow" target="_blank">“在JavaScript中使用innerHTML的缺点”</a></li></ul></div></div>    
</body>
</html>