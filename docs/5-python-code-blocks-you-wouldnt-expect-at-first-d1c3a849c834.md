# 你一开始不会想到的 5 个 Python 代码块

> 原文：<https://betterprogramming.pub/5-python-code-blocks-you-wouldnt-expect-at-first-d1c3a849c834>

## 知道引擎盖下到底发生了什么，这样你就不会感到惊讶了

![](img/d3d640fd287248bededcbd9b83bce660.png)

[米妮周](https://unsplash.com/@marslady?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片。

Python 是一种流行的编程语言。它有一个非常简单的语法，接近简单的英语，通常对初学者来说很清楚。这使得 Python 成为目前使用最广泛的编程语言之一。

尽管在初学者中很常见，但一些 Python 设计的特性可以组合起来，并带来意想不到的可能性。很多时候，这意味着一个不受欢迎的行为，因此是一个 bug。大多数习惯了经典编程语言(如 C、C++、C#和 Java)的程序员可能会发现下面的例子真的很令人惊讶。

这些例子也可以在 Replit 上访问和执行[。](https://replit.com/@fabioveronese/PythonUnexpected)

# 1.猴子补丁

改变一个变量的实例，重新声明它，以及其他一些事情都是 Python 类型化策略的可怕后果。但是你认为重写一个给定类的方法的实现是可能的吗？并在运行时完成？也许只是在特定的情况下？这正是猴子补丁是什么，而且确实可以非常危险。

但是如果你知道你在做什么，它可能会让你马上修复有问题的组件，或者避免为特定的修改做公关。

假设你给一个公共成员赋值。这也正是您(或多或少)对方法属性所做的事情。第 28 行和第 31 行之间的区别在于，类级别的普通赋值用于所有已经存在的实例，以及从那时起的所有新实例。第 31 行仅对单个实例有效，另一个实例不受影响。

# 2.交换电话

一个类嵌入了称为方法的函数，这些函数作用于实例以产生给定的结果或修改。预计您可以在给定的实例上调用这样的方法，但不能调用来自另一个类的方法。

实际上，这里发生的是类`JuiceFruit`是一个`class`对象的实例。所以你可以访问它的方法，而不需要调用构造函数，只要你提供实例(`self`参数)来操作。因为我们有 duck 类型，如果实例有函数需要的东西，方法运行得很好。

# 3.纠缠

许多开发人员喜欢组织有序的代码。所以当需要声明一个常量或者一些初始化值的时候，他们更喜欢把这样一段代码放在编程单元的顶部(也就是`entanglement.py`)。然而，当使用列表和字典时，这可能会导致意想不到的后果。

在下面的例子中，这被用作一个特性。但是没有经验的程序员可能会为了顺序而错误地编写代码。

您所期望的是两个对象实例没有链接。没有明确的行声明这样的链接。但是如果我们更深入地分析代码，我们会发现第 4 行是一个浅拷贝，其中的`quantic_properties`是一个字典。这意味着`quantic_properties`实例在构造函数调用中被保留，并且只有引用被分配给`EntangledParticle`字段。

当作用于一个实例时，我们实际上改变了原始的`quantic_properties`字典，所以所有其他的实例都会受到影响。

# 4.相同但不相同

Python 中最常见的数值类型只有`int`和`float`。而且通常情况下，不需要其他任何东西。但是浮点精度有[它的局限性](https://realpython.com/python-numbers/#make-python-lie-to-you)，有些时候没什么经验的开发者是不会考虑的。当比较`float`变量和`int`文字时，通常可以忽略的小近似值会产生有趣的效果。

所以，当做一些严肃的数学或金融时，记得使用适当的数字类型和库。

# 5.多输入多输出

Python 函数可以声明为接受未定义数量的有序输入和命名输入。这就是`*args`和`**kwargs`的目的(即使名字只是一个转换，但是`*`和`**`在做所有的工作)。一个鲜为人知的事实是，Python 为它们使用了一个简单的列表和字典，您可以用它为函数调用提供一个集合和/或一个字典。这意味着您可以使用一组可变的参数来调用该函数。

额外的好处是，您可以在结果上利用一个类似的特性，具有不确定数量的输出。这一次，它们以元组的形式出现，但是您也可以一次将它们赋给变量。

当然，你要知道自己在做什么。请记住，尊重[单一责任原则](https://en.wikipedia.org/wiki/Single-responsibility_principle)总是一个更好的主意。

# 外卖

Python 很有趣，但是在这种情况下，自由也有不好的一面:更容易失败。从这个角度来看，更传统的编程语言具有更健壮的语法，这可能会以减少自由度为代价产生更少的错误代码。