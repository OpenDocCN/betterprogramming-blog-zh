<html>
<head>
<title>Implement a Passwordless Authentication App With WebAuthn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用WebAuthn实现无密码认证应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-a-passwordless-authentication-app-with-webauthn-aa3635d5d943?source=collection_archive---------4-----------------------#2022-03-28">https://betterprogramming.pub/implement-a-passwordless-authentication-app-with-webauthn-aa3635d5d943?source=collection_archive---------4-----------------------#2022-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cce9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过本实践教程了解无密码身份验证机制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4453d7f9827f1714e9fbd81629e1fb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g-pTkKSkoyKyGc7-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@theregisti?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">注册</a>的照片</p></figure><p id="2188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，让我们通过构建FIDO2服务器并学习如何使用WebAuthn API与它交互来实现无密码认证应用程序。此外，在实现无密码身份验证机制时，探索一些技巧和资源。</p><h1 id="5b79" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">FIDO2、WebAuthn和CTAP</h1><p id="df30" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">FIDO2由W3C的Web认证规范(WebAuthn)和FIDO联盟的客户端到认证者协议(CTAP)组成。依赖方(RP的缩写，在我们的例子中是我们的应用程序)将使用WebAuthn API与Authenticator进行交互，以创建和管理公钥/私钥。一个全功能的无密码认证系统包括:</p><ol class=""><li id="1bab" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">RP应用服务器和FIDO服务器。<br/>(可单独建造或组合建造)</li><li id="ee91" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">调用WebAuthn API的前端RP应用程序</li><li id="8cf3" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">可以运行WebAuthn API的兼容浏览器。</li><li id="00aa" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">兼容FIDO2的认证器。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/f64ea7e911c3a675e2d49059b29bf370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RofVMutf8DX9HQn1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自FIDO Alliance</p></figure><p id="dcc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于其他FIDO规范的更多细节，FIDO诞生的背景，请看我以前的文章。<a class="ae ky" href="https://levelup.gitconnected.com/fido-webauthn-passwordless-lets-go-bananas-b58106a762f0" rel="noopener ugc nofollow" target="_blank">FIDO web authn pass less:我们去香蕉吧！</a></p><p id="37c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看上面的图片，我们需要实现的只有2件事:</p><ol class=""><li id="1295" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">RP应用服务器和FIDO服务器。</li><li id="1554" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">调用WebAuthn API的前端RP应用程序</li></ol><p id="b316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于FIDO Alliance，最困难的部分已经完成，他们与平台提供商、设备制造商合作，在认证器中实现CTAP协议，并将其公开给WebAuthn API，因此我们只需在浏览器中调用简单的函数。</p><h1 id="0def" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">想先试试吗？</h1><p id="c389" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是我们的演示网站，看看吧，四处玩玩~<a class="ae ky" href="https://webauthn.cedarcode.com/" rel="noopener ugc nofollow" target="_blank">https://webauthn.cedarcode.com</a></p><h1 id="13a9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">履行</h1><p id="bfee" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于FIDO服务器，我们可以通过使用开源库或使用其他方的现有解决方案来自己构建它。就我个人而言，我会使用Rails，因为它实现起来更快。在本文中，我将使用<a class="ae ky" href="https://github.com/cedarcode/webauthn-ruby" rel="noopener ugc nofollow" target="_blank"> webauthn-ruby </a>用于FIDO服务器，使用<a class="ae ky" href="https://github.com/github/webauthn-json" rel="noopener ugc nofollow" target="_blank"> webauthn-json </a>用于调用WebAuthn API。</p><p id="63d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是我们的应用程序<a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app" rel="noopener ugc nofollow" target="_blank">web authn-rails-demo-app</a>的存储库。</p><h2 id="a109" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">准备好</h2><p id="12d2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">打开Gemfile并添加<code class="fe nt nu nv nw b">webauthn-ruby</code> gem，然后运行<code class="fe nt nu nv nw b">bundle</code>进行安装。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="687e" class="nh lw it nw b gy ob oc l od oe">gem 'webauthn'</span></pre><p id="112e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，打开webauthn配置<code class="fe nt nu nv nw b">config/initializers/webauthn.rb</code>，并将<code class="fe nt nu nv nw b">config.origin</code>更改为您的应用程序域。</p><h2 id="79db" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">登记</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/9566c540edac922a88f6a1bd5fdff41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aawwoaZu7d02FlBI.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自Mozilla</p></figure><p id="88f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤0(不在上图中)是用户输入他们的用户名和认证者的昵称。在用户点击“使用WebAuthn注册”之后，它将调用一个POST请求到端点<code class="fe nt nu nv nw b">/registration</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/3b48c424388355ad64ed61b63cbabfb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4a7MBZxxvhSry8aTRRX2A.png"/></div></div></figure><p id="7b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nt nu nv nw b"><a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/controllers/registrations_controller.rb#L7-L28" rel="noopener ugc nofollow" target="_blank">RegistrationsController#create</a></code>控制器中，我们将准备<code class="fe nt nu nv nw b">PublicKeyCredentialCreationOptions</code>发送给JavaScript应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e4a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是第16行的响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="619c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu oj my mz na bi translated"><code class="fe nt nu nv nw b">challenge</code>:FIDO服务器生成的随机字符串，用于维护步骤1和步骤5之间的状态完整性。该角色与OAuth中的<code class="fe nt nu nv nw b">state</code>参数相同。</li><li id="a98e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">timeout</code>:用户与认证者交互的超时值。</li><li id="ab67" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">rp</code>:关于RP的信息。<code class="fe nt nu nv nw b">rp.name</code>为必填项。</li><li id="d552" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">user</code>:用户信息。</li><li id="5dea" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">user.id</code>:服务器生成的标识符，不是PII(例如:电子邮件、用户名)。为了确保安全操作，必须基于该id成员而不是displayName或Name成员做出身份验证和授权决定。</li><li id="0410" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">user.name</code> <code class="fe nt nu nv nw b">user.displayName</code>:用户名称，仅用于显示。</li><li id="7f88" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">pubKeyCredParams</code>:服务器支持的签名算法列表。欲望的顺序是自上而下的。该算法名称在<a class="ae ky" href="https://www.iana.org/assignments/cose/cose.xhtml" rel="noopener ugc nofollow" target="_blank"> IANA COSE算法注册中心注册。</a>例如:<code class="fe nt nu nv nw b">-7: ES256</code>，<code class="fe nt nu nv nw b">-257: RS256</code></li></ul><p id="02f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FIDO可以指定的其他选项有:</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="553e" class="nh lw it nw b gy ob oc l od oe">  ...<br/>  "attestation": "none",<br/>  "authenticatorSelection": {<br/>    "authenticatorAttachment": "platform",<br/>    "userVerification": "required"<br/>  },<br/>  ...</span></pre><ul class=""><li id="5d85" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu oj my mz na bi translated"><code class="fe nt nu nv nw b">attestation</code>:表示FIDO服务器将如何从认证者处接收凭证。它就像一个证书。可能的值有:<code class="fe nt nu nv nw b">direct indirect none</code>。通常，这被设置为无。通常不需要请求证明，除非合规性需要(例如，银行、企业或政府)。有关FIDO <a class="ae ky" href="https://fidoalliance.org/fido-technotes-the-truth-about-attestation" rel="noopener ugc nofollow" target="_blank">认证</a>的更多信息。</li><li id="4126" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">authenticatorSelection</code> : FIDO服务器对认证器的偏好</li><li id="2a80" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">authenticatorSelection.authenticatorAttachment</code>:过滤可用授权码。如果你想要一个认证器连接到设备，使用<code class="fe nt nu nv nw b">platform</code>。对于漫游授权码，使用<code class="fe nt nu nv nw b">cross-platform</code>。</li><li id="c0f3" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">authenticatorSelection.userVerification</code>:确定认证者本地用户验证是<code class="fe nt nu nv nw b">required</code>、<code class="fe nt nu nv nw b">preferred</code>还是<code class="fe nt nu nv nw b">discouraged</code>。</li></ul><p id="2d90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，JavaScript应用程序接收<a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/javascript/controllers/new_registration_controller.js#L19" rel="noopener ugc nofollow" target="_blank">new _ registration _ controller . JS</a>中的JSON，并调用<a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/javascript/credential.js#L35" rel="noopener ugc nofollow" target="_blank"> credential.js </a>中的<code class="fe nt nu nv nw b">webauthn-json</code> JS库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="a914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nw b">webauthn-json</code> js库接收JSON，填充其他需要的参数并创建<code class="fe nt nu nv nw b">PublicKeyCredentialCreationOptions</code>，然后调用WebAuthn API <code class="fe nt nu nv nw b">navigator.credentials.create()</code>。这是我们图表中的第二步。然后，浏览器将要求用户选择验证器，如果需要，将执行本地用户验证(步骤3)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/57f611949fce821ead46afb45471fd86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYNcCV9VNVkk-SGg4o8MBw.png"/></div></div></figure><p id="6cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设认证者能够验证用户，成功创建新的密钥对…，然后认证者将<code class="fe nt nu nv nw b">attestationObject</code>返回给浏览器(步骤4)，然后WebAuthn API创建<code class="fe nt nu nv nw b">AuthenticatorAttestationResponse</code>，我们的JS代码<a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/javascript/credential.js#L13-L32" rel="noopener ugc nofollow" target="_blank">在回调</a>中将此响应发送给FIDO服务器。响应如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="291a" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu oj my mz na bi translated"><code class="fe nt nu nv nw b">rawId</code>:标识公钥的唯一ID。</li><li id="a103" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">id</code> : base64url编码版本的<code class="fe nt nu nv nw b">rawId</code></li><li id="a822" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">type</code>:始终固定在<code class="fe nt nu nv nw b">public-key</code></li><li id="c6a7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">response.clientDataJSON</code>:用base64url编码的JSON对象，该内容将被添加到<code class="fe nt nu nv nw b">attestationObject</code>中的<code class="fe nt nu nv nw b">authData</code>中，并由认证者签名。我们可以解码来查看信息。认证者将密钥对与域绑定，只有这个注册的域能够使用密钥对。这就是它对网络钓鱼的强大抵抗力。</li></ul><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="9a2b" class="nh lw it nw b gy ob oc l od oe">{<br/>  "type": "webauthn.create",<br/>  "challenge": "<!-- -->Wj4vWoL1BeG0PB8iJTKMfvLH8rBt3CA6PfM4QBIyKmU<!-- -->",<br/>  "origin": "http://localhost:3000",<br/>  "crossOrigin": false<br/>}</span></pre><ul class=""><li id="a17a" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu oj my mz na bi translated"><code class="fe nt nu nv nw b">response.attestationObject</code> : CBOR编码和base64url编码，就像证书一样。关于<code class="fe nt nu nv nw b">attestationObject</code>结构的更多细节:<a class="ae ky" href="https://www.w3.org/TR/webauthn/#fig-attStructs" rel="noopener ugc nofollow" target="_blank"> W3C文档</a>。</li></ul><p id="62ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在步骤6中，我们的FIDO服务器接收<code class="fe nt nu nv nw b">AuthenticatorAttestationResponse</code>，验证挑战以确保它是一个有效的请求，同时<code class="fe nt nu nv nw b">webauthn-ruby</code> gem在内部验证证明(如果需要)。假设一切都是正确的，将会创建一个带有公钥、id和其他相关信息但没有秘密的用户帐户。<br/> <a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/controllers/registrations_controller.rb#L30-L57" rel="noopener ugc nofollow" target="_blank">注册_控制器. rb </a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="ac76" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">为帐户注册更多安全密钥</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f35fc8e1129949cb8d0e306d9b19f9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOsy_BCMHnwXFqd-KVXiAw.png"/></div></div></figure><p id="6c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注册后，用户登录。他们可以向自己的帐户添加更多的安全密钥。点击“添加安全密钥”按钮时，将向<code class="fe nt nu nv nw b">/credentials</code>发出POST请求。然后重复我们的注册图中的步骤1至步骤6，唯一的一点不同是FIDO服务器在第8行指定了一个名为<code class="fe nt nu nv nw b">exclude</code>的附加参数，这意味着来自同一用户的所有先前注册的授权码都将被拒绝。<br/> <a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/controllers/credentials_controller.rb#L4-L18" rel="noopener ugc nofollow" target="_blank">凭据_controller.rb </a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="7d2b" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">证明</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/5087637d0ba5897b24daaaca2d9e5f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UckfCgyaanmfUPWF.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自Mozilla</p></figure><p id="d593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤0(不在上图中)是当用户注销时，在表单中填写用户名并单击“使用WebAuthn登录”。然后，将向<code class="fe nt nu nv nw b">/session</code>发出POST请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/a595c6245a90e2a31e35008326eb7840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-e98SLWufFLfmAxAOwBiag.png"/></div></div></figure><p id="aa01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致了第一步，在<code class="fe nt nu nv nw b"><a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/controllers/sessions_controller.rb#L7-L23" rel="noopener ugc nofollow" target="_blank">sessions_controller.rb</a></code>中，我们准备传递给Javascript端的选项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="29c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第11行的JSON如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="cb37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经熟悉了其他字段，这次登录时，唯一的不同是我们有了<code class="fe nt nu nv nw b">allowCredentials</code>,这意味着FIDO服务器只允许通过指定其id来使用以前注册的授权码。例如，上面的id <code class="fe nt nu nv nw b">Abn91…</code>就是我们在<code class="fe nt nu nv nw b">AuthenticatorAttestationResponse</code>(注册步骤5)中收到的同一个公钥id。</p><p id="6ce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，JavaScript应用程序在<a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/javascript/controllers/new_session_controller.js#L9-L14" rel="noopener ugc nofollow" target="_blank">new _ session _ controller . JS</a>中接收上述JSON，并调用<a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/javascript/credential.js#L44-L52" rel="noopener ugc nofollow" target="_blank"> credential.js </a>中的<code class="fe nt nu nv nw b">webauthn-json</code> JS库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="2a0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nw b">webauthn-json</code> js库接收JSON，填充其他需要的参数并创建<code class="fe nt nu nv nw b">PublicKeyCredentialRequestOptions</code>，然后调用WebAuthn API <code class="fe nt nu nv nw b">navigator.credentials.get()</code>。这是我们图表中的第二步。然后，浏览器将要求用户仅选择已注册的认证器，如果需要，将执行本地用户验证(步骤3)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/adddbc91fec52a805cab92d2433da3ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQpjzpQp900ir4U_19691Q.png"/></div></div></figure><p id="6fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设验证者能够验证用户，成功创建断言…，然后验证者将<code class="fe nt nu nv nw b">authenticatorData</code>、<code class="fe nt nu nv nw b">signature</code>返回给浏览器(步骤4)，然后WebAuthn API创建<code class="fe nt nu nv nw b">AuthenticatorAssertionResponse</code>，我们的JS代码<a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/javascript/credential.js#L13-L32" rel="noopener ugc nofollow" target="_blank">在回调</a>中将此响应发送给FIDO服务器。响应如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="dcc8" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu oj my mz na bi translated"><code class="fe nt nu nv nw b">response.authenticatorData</code> : CBOR编码，base64url编码，与<code class="fe nt nu nv nw b">attestationObject</code>结构相同。</li><li id="f4ba" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">response.userHandle</code> : user.id (id在<code class="fe nt nu nv nw b">id name displayName</code>中)</li><li id="48f7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><code class="fe nt nu nv nw b">response.clientDataJSON</code>:一个用base64url编码的JSON对象，该内容将被添加到<code class="fe nt nu nv nw b">authenticatorData</code>中的<code class="fe nt nu nv nw b">authData</code>中，并由认证者签名。我们可以解码来查看信息。</li></ul><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="d6de" class="nh lw it nw b gy ob oc l od oe">{<br/>  "type": "webauthn.get",<br/>  "challenge": "<!-- -->pW3wrtt7b65n5ehxWbVpb8vGml9EGn9yXXTcuBzXI7E<!-- -->",<br/>  "origin": "http://localhost:3000",<br/>  "crossOrigin": false<br/>}</span></pre><p id="71c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在步骤6中，我们的FIDO服务器接收<code class="fe nt nu nv nw b">AuthenticatorAssertionResponse</code>，验证挑战以确保它是一个有效的请求，验证<code class="fe nt nu nv nw b">sign_count</code>，同时<code class="fe nt nu nv nw b">webauthn-ruby</code> gem在内部验证断言(如果需要)。假设一切都是正确的，用户<code class="fe nt nu nv nw b">sign_count</code>值将被更新，用户将登录。<br/><a class="ae ky" href="https://github.com/cedarcode/webauthn-rails-demo-app/blob/d9b73e20a7272e8d9f7a26c48ec49e5100295939/app/controllers/sessions_controller.rb#L25-L50" rel="noopener ugc nofollow" target="_blank">sessions _ controller . Rb</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="0925" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">验证证明和断言</h2><p id="cae8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我简单解释的一部分是验证证明(当注册时)和验证断言(当认证时)。这个验证逻辑是由<code class="fe nt nu nv nw b">webauthn-ruby</code> gem内部完成的。每个认证器都有自己的验证方式，实现起来非常复杂和耗时，所以我们应该把这项工作留给库。</p><p id="587e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想阅读更多关于这个主题的内容，我推荐这篇文章:<a class="ae ky" href="https://medium.com/@herrjemand/verifying-fido2-responses-4691288c8770" rel="noopener"> WebAuthn/FIDO2:验证断言响应</a>作者阿克曼·塞维多夫</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="f489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唷，一下子覆盖所有流量是相当困难的。😅<br/>如果到目前为止你还在遵循教程，给自己一点掌声吧！！👏👏👏👏👏</p><h1 id="4a71" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">其他考虑</h1><h2 id="7ec3" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">实施FIDO2用于无密码还是2FA还是两者都用？</h2><p id="d3d4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在为您的应用程序实现FIDO2时，有两种使用情形。您可以实现无密码身份验证流程(如本教程中的示例)或实现2FA方法(注册FIDO2兼容的安全密钥)。</p><p id="b1e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于无密码方法，UX得到了很大的提高，但我们需要考虑恢复方法。我们仍然必须提供替代的登录方法，如密码，或在电子邮件中发送恢复链接，或发送短信。如果用户设置了一个弱密码，无论无密码是否开启，他们的帐户仍然会被泄露。使用电子邮件或SMS等恢复方法，最终，用户将需要电子邮件提供商的密码，并且SMS文本消息并不总是100%可信的，因此不是每个用户都会设置电话号码。无论FIDO2强安全级别如何，这都会将整个帐户的安全级别降低到帐户恢复方法的安全级别。虽然无密码不会提高安全级别，但这样做还是有好处的，可以提高整体UX。</p><p id="baf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:雅虎日本，<a class="ae ky" href="https://nulab.com/ja/blog/nulab/webauthn_demo/" rel="noopener ugc nofollow" target="_blank">纽拉布</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f37beb129a64802ede7367ab57aea4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-0_-q6hkfNlWxRTc8af1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自雅虎日本——使用生物认证登录</p></figure><p id="9e26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法是将FIDO实现为2FA方法，而不是TOTP。FIDO设置过程比TOTP快得多，也简单得多。但是，为了将FIDO设置为2FA，仍需要将TOTP配置为帐户恢复方法。</p><p id="948f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:Github、Twitter</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/ec63f78c8bfa8caf196ccf74d9bd310e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8Z0PAj5qQj6q1_on"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自Github</p></figure><p id="5633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种方法非常适合B2C应用程序。对于正常用户来说，通常不在乎设置2FA。我们可以使用密码计量栏，敦促用户设置强密码，然后设置FIDO以方便登录。</p><p id="0dac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法适用于B2B应用程序，这通常更容易实施2FA，并且用户已经习惯了2FA流程。</p><h2 id="925a" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">密码=(已同步)WebAuthn凭据(WIP)</h2><p id="bd70" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如前所述，无论FIDO2强安全级别如何，整个帐户的安全级别都可以降低到帐户恢复方法的安全级别。我们需要考虑如何做账户回收。</p><p id="6908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WWDC21上，苹果推出了一项新的“iCloud钥匙串中的Passkeys”功能。基本上，所有的WebAuthn凭证在所有的苹果设备上都是同步的。因此，如果用户丢失了之前注册为验证者的设备，只要他们可以访问他们的Apple帐户，他们就可以访问存储在iCloud Keychain中的所有凭据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/c99237a0a7041e94c2099c1422be821c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kY4_ZlOmklpP0T9q.png"/></div></div></figure><p id="b854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到现在，只有苹果公司推出了这一功能。个人听说其他平台也会在2022年末发布同样的功能。</p><h2 id="8e0e" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">用户存在与用户验证</h2><p id="6c65" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">来自<a class="ae ky" href="https://developers.yubico.com/WebAuthn/WebAuthn_Developer_Guide/User_Presence_vs_User_Verification.html" rel="noopener ugc nofollow" target="_blank"> Yubico </a>的这篇文章很好地解释了这一点。注册和身份验证都需要以下一项或两项:</p><ul class=""><li id="99c2" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu oj my mz na bi translated">用户存在:这个最基本的配置只不过是一个FIDO2调用，提示用户触摸安全密钥或以某种方式与验证者交互。</li><li id="0206" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated">用户验证:FIDO2调用，其中验证器验证用户是否被授权使用验证器，并向RP发送用户验证是否成功的信号。</li></ul><p id="29d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户<strong class="lb iu">验证</strong>用于确保向服务认证的人实际上是他们为了该服务而声称的人。用户验证可以采取各种形式，例如密码、PIN、指纹、公钥证书等。重点是将一个用户与任何其他用户区分开，即唯一地识别用户。</p><p id="06f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用用户<strong class="lb iu">存在</strong>，目的不是识别用户，而是确保用户实际存在并控制认证者。</p><p id="38c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每种类型的使用案例:</p><ul class=""><li id="6e23" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu oj my mz na bi translated">用户在场适用于第二因素身份验证(2FA)</li><li id="5e42" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated">不建议对2FA进行用户验证，因为用户已经输入了通过网络发送给服务器的共享密码</li><li id="855d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated">用户验证适用于无密码场景和多因素身份验证(MFA ),因为它将“您拥有的东西”和“您是什么”/“您知道的东西”结合在一个手势中。</li></ul><h2 id="fc57" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">FIDO桌面认证器UX指南</h2><p id="a011" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">FIDO UX指南是一套最佳实践，旨在帮助服务提供商鼓励他们的客户在桌面环境中使用FIDO身份验证登录。这些指南旨在加速FIDO实施过程中的决策制定，并规定在用户从了解FIDO到注册和随后登录的整个过程中应向其提供哪些信息和控制。</p><p id="0d82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里阅读关于FIDO UX指南:<br/>【https://fidoalliance.org/ux-guidelines/ux-guideline-pdf/】T2</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">听听FIDO联盟成员对UX在FIDO实施中的重要性的看法。</p></figure><h1 id="fab2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">其他语言库和资源</h1><p id="3c55" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，作为一个例子，我使用Rails并使用<code class="fe nt nu nv nw b"><a class="ae ky" href="https://github.com/cedarcode/webauthn-ruby" rel="noopener ugc nofollow" target="_blank">webauthn-ruby</a></code>构建一个FIDO服务器。其他编程语言的开源库见<a class="ae ky" href="https://webauthn.io/" rel="noopener ugc nofollow" target="_blank"> webauthn.io </a>或<a class="ae ky" href="https://bit.ly/AwesomeWebAuthn" rel="noopener ugc nofollow" target="_blank"> AwesomeWebAuthn </a>。</p><p id="bb88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果想使用其他方的现有解决方案，可以看看<a class="ae ky" href="https://fidoalliance.org/certification/fido-certified-products/" rel="noopener ugc nofollow" target="_blank"> FIDO联盟官方页面</a>。</p><h1 id="091e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="a31f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一篇很长的文章，很抱歉😅。我希望你已经学到了一些东西，如果你有问题，随时留下评论。💪</p><p id="731f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们已经介绍了如何实现无密码认证应用程序，并逐步了解代码如何运行。我们还讨论了实施FIDO的方式、用户存在和用户验证的区别、UX的最佳实践，并探索了其他相关资源。</p><h1 id="3462" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="5677" class="ms mt it lb b lc mn lf mo li ox lm oy lq oz lu oj my mz na bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API" rel="noopener ugc nofollow" target="_blank"> Web认证API</a>(developer.mozilla.org)</li><li id="9ee4" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated"><a class="ae ky" href="https://www.w3.org/TR/2021/WD-webauthn-3-20210427/" rel="noopener ugc nofollow" target="_blank"> Web认证:用于访问第3级公钥证书的API</a>(www.w3.org)</li><li id="4612" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi"><a class="ae ky" href="https://techblog.yahoo.co.jp/advent-calendar-2018/webauthn/" rel="noopener ugc nofollow" target="_blank">Yahoo! JAPANでの生体認証の取り組み（FIDO2サーバーの仕組みについて）</a> (techblog.yahoo.co.jp)</li><li id="7f99" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu oj my mz na bi translated">(engineering.mercari.com)webauthnことはじめ</li></ul></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="dea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pa">感谢您阅读这篇文章！如果你有任何问题，请留言。如果你觉得这篇文章有帮助，请按住鼓掌按钮，让其他人也能发现。请务必在下面注册我的时事通讯，或者在Medium上关注我，以获得更多类似的文章。</em> ☝️👏 😄</p></div></div>    
</body>
</html>