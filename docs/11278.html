<html>
<head>
<title>Serving a Node.js API on Amazon Elastic Kubernetes Service and CloudFront</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Amazon Elastic Kubernetes服务和CloudFront上提供Node.js API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/serving-a-node-js-api-on-amazon-elastic-kubernetes-service-eks-cloudfront-114e590e8d9e?source=collection_archive---------4-----------------------#2022-03-05">https://betterprogramming.pub/serving-a-node-js-api-on-amazon-elastic-kubernetes-service-eks-cloudfront-114e590e8d9e?source=collection_archive---------4-----------------------#2022-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a51a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在这个演示中，我们在亚马逊EKS Kubernetes集群中设置了一个Node.js Express服务器，并通过CloudFront为其提供服务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/024de792a9aeb1f4b8884e3118b3ae73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lF22yPXDljP0_3SDDXbjbw.jpeg"/></div></div></figure><p id="905d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Kubernetes是一个成熟的容器编排框架，支持容器化应用程序的开源部署、伸缩和管理。虽然对于最简单的应用程序来说，Kubernetes可能过于健壮，但它确实提供了出色的正常运行时间和可靠性标准，例如，通过对应用程序进行平滑的滚动更新。</p><p id="d7cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">弹性Kubernetes服务(EKS)是一项由AWS管理的服务，它消除了管理Kubernetes部署中一些臭名昭著的复杂性。反过来，CloudFront可以用来缓存来自部署的响应，从而控制计算成本。</p><p id="d4ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个演示中，我们将在Kubernetes集群中设置一个简单的Express服务器，并通过CloudFront为其提供服务。在我们开始之前，我们的本地机器应该已经安装了以下工具:</p><ul class=""><li id="7571" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="fdc5" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" rel="noopener ugc nofollow" target="_blank"> aws </a></li><li id="9e98" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://docs.aws.amazon.com/eks/latest/userguide/install-kubectl.html" rel="noopener ugc nofollow" target="_blank">库贝克特尔</a></li><li id="2ca3" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" rel="noopener ugc nofollow" target="_blank"> eksctl </a></li></ul><p id="8951" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还假设我们拥有对域名的控制权，应用程序可以从这个域名获得服务。演示应用程序和相关的配置文件可以在这里找到:<a class="ae lw" href="https://github.com/alexcolb/eks-nodejs-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/alexcolb/eks-nodejs-demo</a></p><h2 id="b17c" class="mc md iq bd me mf mg dn mh mi mj dp mk la ml mm mn le mo mp mq li mr ms mt mu bi translated">准备Docker映像</h2><p id="e6fd" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">Kubernetes是一个容器编排框架，这意味着我们需要为我们的应用程序创建和托管一个Docker映像。我们将从<a class="ae lw" href="https://hub.docker.com/repository/create" rel="noopener ugc nofollow" target="_blank">在Docker Hub </a>(例如<code class="fe na nb nc nd b">my-docker-username/my-app</code>)上创建一个公共存储库开始。</p><p id="15f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lw" href="https://github.com/alexcolb/eks-nodejs-demo/blob/main/Dockerfile" rel="noopener ugc nofollow" target="_blank">在我们的项目根</a>中定义了一个 <code class="fe na nb nc nd b"><a class="ae lw" href="https://github.com/alexcolb/eks-nodejs-demo/blob/main/Dockerfile" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code> <a class="ae lw" href="https://github.com/alexcolb/eks-nodejs-demo/blob/main/Dockerfile" rel="noopener ugc nofollow" target="_blank">之后，我们运行:</a></p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="3fd1" class="mc md iq nd b gy ni nj l nk nl">$ docker login<br/>$ docker build -t <strong class="nd ir"><em class="nm">my-docker-username</em>/<em class="nm">my-app</em></strong> .<br/>$ docker push <strong class="nd ir"><em class="nm">my-docker-username</em>/<em class="nm">my-app</em></strong></span></pre><p id="4698" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们创建的docker映像现已在Docker Hub公开发布:https://hub.docker.com/repository/docker/<strong class="kt ir"><em class="nm">我的-Docker-用户名</em> / <em class="nm">我的-app </em> </strong></p><h2 id="b068" class="mc md iq bd me mf mg dn mh mi mj dp mk la ml mm mn le mo mp mq li mr ms mt mu bi translated">创建Kubernetes的ConfigMap YAML配置</h2><p id="57db" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">接下来，我们至少创建、熟悉并修改下面三个YAML文件中的<strong class="kt ir">TODO</strong>-注释值，这些值告诉Kubernetes我们希望我们的集群是什么样子。</p><p id="176e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">API . deployment . YAML(</strong><a class="ae lw" href="https://github.com/alexcolb/eks-nodejs-demo/blob/main/config/api.deployment.yaml" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">GitHub</strong></a><strong class="kt ir">)</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a11a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">API . service . YAML(</strong><a class="ae lw" href="https://github.com/alexcolb/eks-nodejs-demo/blob/main/config/api.service.yaml" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">GitHub</strong></a><strong class="kt ir">)</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8117" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">API . external-DNS . YAML(</strong><a class="ae lw" href="https://github.com/alexcolb/eks-nodejs-demo/blob/main/config/api.external-dns.yaml" rel="noopener ugc nofollow" target="_blank">T22】GitHub</a><strong class="kt ir">)</strong></p><p id="a860" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个较长的、不太标准的ConfigMap类型，所以只需从提供的git存储库中复制它。但是，请确保编辑<code class="fe na nb nc nd b"><strong class="kt ir">--domain-filter</strong></code>中的域，以匹配您的应用程序的域。这个文件的重要性将在以后变得更加清楚。</p><h2 id="bf7a" class="mc md iq bd me mf mg dn mh mi mj dp mk la ml mm mn le mo mp mq li mr ms mt mu bi translated">创建我们的EKS集群</h2><p id="f8e9" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">在继续之前，<a class="ae lw" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html" rel="noopener ugc nofollow" target="_blank">我们需要配置我们的AWS凭证</a>。然后，为了创建集群，我们等待以下命令完成:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="f21a" class="mc md iq nd b gy ni nj l nk nl">$ eksctl create cluster --name <strong class="nd ir">my-cluster</strong> --region eu-west-1 --nodegroup-name linux-nodes --node-type t2.small --nodes 1</span></pre><p id="2a2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以更改我们的名称空间并应用我们的两个YAML配置，如下所示。其中，这将把我们的Docker映像部署到集群上。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="0a8e" class="mc md iq nd b gy ni nj l nk nl">$ kubectl config set-context --current --namespace=kube-system<br/>$ kubectl apply -f api.deployment.yaml<br/>$ kubectl apply -f api.service.yaml<br/>$ kubectl get pods --watch</span></pre><p id="7ebf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一个命令让我们观察到我们的两个pod正在被创建，并有希望最终处于<em class="nm">运行</em>状态。如果您需要调试出现故障的pod，这些命令将被证明是有用的:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="1b02" class="mc md iq nd b gy ni nj l nk nl">$ kubectl describe pod/<strong class="nd ir">my-pod-name</strong><br/>$ kubectl logs pod/<strong class="nd ir">my-pod-name</strong></span></pre><blockquote class="np nq nr"><p id="455b" class="kr ks nm kt b ku kv jr kw kx ky ju kz ns lb lc ld nt lf lg lh nu lj lk ll lm ij bi translated">如果您观察到“exec格式错误”,并且您的机器运行在Apple Silicon上，您可能需要在其他地方创建Docker映像。</p></blockquote><p id="8d4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了检查我们迄今为止的进展，我们可以访问我们集群向世界开放的短暂的URI。换句话说，在DNS信息传播一段时间后，我们可以在浏览器中观察我们部署的API！为此，让我们使用这个命令来获取我们的<em class="nm">外部IP </em>和<em class="nm">端口:</em></p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="8dc2" class="mc md iq nd b gy ni nj l nk nl">$ kubectl get service</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/80cc3d718aa0146df4ad1acc840ad28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAlqVU4GzgBRYHkY_ITdmw.png"/></div></div></figure><h2 id="2fdc" class="mc md iq bd me mf mg dn mh mi mj dp mk la ml mm mn le mo mp mq li mr ms mt mu bi translated">配置对群集的DNS访问</h2><p id="f368" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">我们现在面临的问题是，每当我们的服务更新时，这个URI都会改变，所以我们不能将其原样用于入站流量。相反，我们将利用<a class="ae lw" href="https://github.com/kubernetes-sigs/external-dns" rel="noopener ugc nofollow" target="_blank"> <em class="nm">外部dns </em> </a>使我们的服务能够被公共dns发现。</p><p id="4a8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们在<a class="ae lw" href="https://console.aws.amazon.com/route53/v2/hostedzones#CreateHostedZone" rel="noopener ugc nofollow" target="_blank"> AWS Route 53 </a>中创建一个名为<code class="fe na nb nc nd b">external-dns.<strong class="kt ir">my-domain.com</strong></code>的新托管区域，记下它的ID。</p><p id="c0d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们设置一个服务帐户，授权我们的集群将应用程序的短暂URI更新到DNS。首先，我们在AWS IAM 中创建以下JSON策略<a class="ae lw" href="https://console.aws.amazon.com/iam/home#/policies$new?step=edit" rel="noopener ugc nofollow" target="_blank">，注意它的ARN:</a></p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="a075" class="mc md iq nd b gy ni nj l nk nl">{<br/>  "Version": "2012-10-17",<br/>  "Statement": [<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": [<br/>        "route53:ChangeResourceRecordSets"<br/>      ],<br/>      "Resource": [<br/>        "arn:aws:route53:::hostedzone/<strong class="nd ir">my-hosted-zone-id</strong>"<br/>      ]<br/>    },<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": [<br/>        "route53:ListHostedZones",<br/>        "route53:ListResourceRecordSets"<br/>      ],<br/>      "Resource": [<br/>        "*"<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><blockquote class="np nq nr"><p id="9b7f" class="kr ks nm kt b ku kv jr kw kx ky ju kz ns lb lc ld nt lf lg lh nu lj lk ll lm ij bi translated">我们小心地不让Kubernetes访问面向生产的托管区域。即使我们决定使用实际域的子域，<a class="ae lw" href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-routing-traffic-for-subdomains.html" rel="noopener ugc nofollow" target="_blank">我们也应该将外部dns流量路由到独立的托管区域</a>。</p></blockquote><p id="2e36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以创建服务帐户，并验证其与群集的连接:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="a0c2" class="mc md iq nd b gy ni nj l nk nl"><em class="nm">$ </em>eksctl utils associate-iam-oidc-provider --region=eu-west-1 --cluster=<strong class="nd ir">my-cluster </strong>--approve</span><span id="1a5d" class="mc md iq nd b gy nw nj l nk nl">$ eksctl create iamserviceaccount \<br/>  --name external-dns \<br/>  --namespace kube-system \<br/>  --cluster<strong class="nd ir"> my-cluster</strong> \<br/>  --attach-policy-arn <strong class="nd ir">my-iam-policy-arn</strong> \<br/>  --approve</span><span id="e466" class="mc md iq nd b gy nw nj l nk nl"><em class="nm">$ </em>kubectl describe sa external-dns</span></pre><p id="1020" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们部署了<em class="nm">外部dns </em> Kubernetes pod，它将动态更新Route 53记录以指向我们的临时URL:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="2875" class="mc md iq nd b gy ni nj l nk nl">$ kubectl apply -f api.external-dns.yaml</span></pre><p id="f910" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过访问我们的新静态地址来验证这一点，例如<code class="fe na nb nc nd b">http://my-service.external-dns.<strong class="kt ir">my-domain.com</strong>:8080</code></p><h2 id="91bd" class="mc md iq bd me mf mg dn mh mi mj dp mk la ml mm mn le mo mp mq li mr ms mt mu bi translated">将云锋指向EKS</h2><p id="81fa" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">我们现在想把我们的集群放在一个负载均衡器后面，这样API响应就不必在每次被请求时都重新计算。<a class="ae lw" href="https://console.aws.amazon.com/cloudfront/v3/home#/distributions/create" rel="noopener ugc nofollow" target="_blank">在AWS CloudFront中，我们创建了一个新的发行版</a>。<em class="nm">源域</em>应该是Route 53中存储的任意记录<em class="nm"> external-dns </em>，例如<code class="fe na nb nc nd b">my-service.external-dns.my-domain.com</code>，HTTP端口的值应该是ConfigMaps中配置的任意值，例如<code class="fe na nb nc nd b">8080</code>。我们还必须创建一个自定义的<em class="nm">缓存策略</em>，将<em class="nm">查询字符串</em>设置为<code class="fe na nb nc nd b">All</code>，这将告诉CloudFront在考虑端点缓存时包含HTTP查询字符串。</p><p id="96a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦部署完成，我们就可以通过CloudFront发行版中的<em class="nm">发行域名</em>下面列出的URI访问该应用程序！</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="51e2" class="mc md iq bd me mf mg dn mh mi mj dp mk la ml mm mn le mo mp mq li mr ms mt mu bi translated">成本估算和删除</h2><p id="ec89" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">当应用以下定价时，每月静态成本约为145美元(或每小时0.20美元):</p><ul class=""><li id="dd3b" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">每<em class="nm">小时使用亚马逊EKS集群0.100美元</em></li><li id="3358" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">0.025美元每<em class="nm">按需Linux t2 .小实例</em> <strong class="kt ir"> <em class="nm"> </em> </strong>小时</li><li id="4ac0" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">每个<em class="nm"> ELB负载平衡器</em> <strong class="kt ir"> </strong>小时0.028美元</li><li id="f988" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">每个<em class="nm"> NAT网关</em>小时0.048美元</li></ul><p id="365d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过运行以下命令随时删除我们的集群:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="86c7" class="mc md iq nd b gy ni nj l nk nl">$ eksctl delete cluster --name <strong class="nd ir">my-cluster</strong> --region eu-west-1</span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="1dc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">致谢和进一步阅读:</p><ul class=""><li id="0bbf" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://peiruwang.medium.com/eks-exposing-service-with-external-dns-3be8facc73b9" rel="noopener">https://Pei ruwang . medium . com/eks-exposure-service-with-external-DNS-3be 8 facc 73 b 9</a></li><li id="0799" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">https://learnk8s.io/deploying-nodejs-kubernetes-eks<a class="ae lw" href="https://learnk8s.io/deploying-nodejs-kubernetes-eks" rel="noopener ugc nofollow" target="_blank"/></li><li id="1207" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">https://www.youtube.com/watch?v=p6xDCz00TxU&amp;t = 171s</li></ul></div></div>    
</body>
</html>