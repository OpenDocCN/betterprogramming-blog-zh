<html>
<head>
<title>The Prime Directive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">主要指令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-prime-directive-35bf7aa10e8c?source=collection_archive---------3-----------------------#2019-02-20">https://betterprogramming.pub/the-prime-directive-35bf7aa10e8c?source=collection_archive---------3-----------------------#2019-02-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="2038" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用Angular中的指令和自定义验证器验证数据</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/63cc1ca5eb79b1da1d78ffcead22d86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PBcoNTGDq0a_A9mF"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Nelson </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="2bf6" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">介绍</h1><p id="a5d1" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">使用Angular构建站点时，首先要做的事情之一是确保用户输入的格式正确并经过验证。您不希望以电话号码字段中的字母或格式不正确的邮政编码结束。</p><p id="7c26" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">Angular提供了两种主要的方法来确保数据的格式和有效性:指令和验证器。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="aae4" class="la lb iu bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">应用程序</h1><p id="f070" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">在本文中，我们将讨论一个简单的应用程序，它只有一个编辑字段，您只能在其中添加数字——只有当这些数字生成一个质数时，它才会被正确验证。</p><p id="03f8" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">应用程序可以在这里查看和播放<a class="ae kz" href="https://vbwigzmp.github.stackblitz.io" rel="noopener ugc nofollow" target="_blank">，代码可以在GitHub </a>上找到，或者通过这个<a class="ae kz" href="https://stackblitz.com/github/nickhodges/primedirective" rel="noopener ugc nofollow" target="_blank">完整的StackBlitz视图</a>找到。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="0a67" class="la lb iu bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">指令</h1><p id="e2a4" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">确保正确收集数据的第一种方法叫做<em class="nf">指令</em>。在Angular中，指令用于通过向HTML元素添加属性来扩展HTML。您可能熟悉像<code class="fe ng nh ni nj b">ngFor</code>和<code class="fe ng nh ni nj b">ngIf</code>这样的指令。</p><p id="2a28" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">Angular为您提供了创建自己的指令的能力。要创建一个指令，你需要在一个类中放置<code class="fe ng nh ni nj b"><a class="ae kz" href="https://angular.io/api/core/Directive" rel="noopener ugc nofollow" target="_blank">@Directive</a></code> <strong class="lu iv"> </strong>装饰器。装饰器有许多参数可以接受，但最重要的一个是<code class="fe ng nh ni nj b">selector</code>，它定义了将在HTML中使用的名称，以标识使用该指令的元素。</p><p id="562c" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">下面是我们在演示应用程序中定义的<code class="fe ng nh ni nj b">numbersonly</code>指令的基本版本:</p><pre class="kk kl km kn gu nk nj nl nm aw nn bi"><span id="1d31" class="no lb iu nj b gz np nq l nr ns">@Directive({selector: '[numbersonly]'})</span><span id="9091" class="no lb iu nj b gz nt nq l nr ns">export class NumbersOnlyDirective {</span><span id="d71a" class="no lb iu nj b gz nt nq l nr ns">...</span><span id="5e25" class="no lb iu nj b gz nt nq l nr ns">}</span></pre><p id="c0c1" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">这里我们定义了一个<code class="fe ng nh ni nj b">NumbersOnlyDirective</code>，当<code class="fe ng nh ni nj b">numbersonly</code>选择器被放置在HTML标签中时，它将被使用，如下所示:</p><pre class="kk kl km kn gu nk nj nl nm aw nn bi"><span id="13e4" class="no lb iu nj b gz np nq l nr ns">&lt;input placeholder="Enter only prime numbers!" <strong class="nj iv">numbersonly</strong> /&gt;</span></pre><p id="9215" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">当然，这个类必须实际做一些有用的事情。以下是该项目的完整说明:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="8390" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">关于这个类，有许多事情需要注意:</p><ul class=""><li id="82e1" class="nw nx iu lu b lv mo ly mp mb ny mf nz mj oa mn ob oc od oe bi translated">这个类叫做<code class="fe ng nh ni nj b">NumbersOnlyDirective</code>。它的选择器自然被称为<code class="fe ng nh ni nj b">numbersonly</code>。</li><li id="a574" class="nw nx iu lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">该类在其构造函数中引入一个<code class="fe ng nh ni nj b">ElementRef</code>，它将是对指令将嵌入其中的元素的引用。一会儿我们将看到元素中使用的选择器。</li><li id="25ac" class="nw nx iu lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">这个类有三个方法，分别用于处理在输入框中输入文本的三种方式:键入、粘贴和拖动。</li><li id="7cd2" class="nw nx iu lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">这些方法中的每一个都用<a class="ae kz" href="https://angular.io/api/core/HostListener" rel="noopener ugc nofollow" target="_blank"/><code class="fe ng nh ni nj b"><a class="ae kz" href="https://angular.io/api/core/HostListener" rel="noopener ugc nofollow" target="_blank">@HostListener</a></code><a class="ae kz" href="https://angular.io/api/core/HostListener" rel="noopener ugc nofollow" target="_blank">装饰器</a>装饰。这个装饰器将来自浏览器的事件绑定到您的TypeScript中的代码。它有两个参数——它将绑定到的事件的名称和事件发生时传递给处理程序方法的参数。结果是，当给定事件发生时，将调用此代码。例如，如果您将一些文本拖放到input元素中，那么<code class="fe ng nh ni nj b">onDrop</code>事件将被触发，文本在被插入到input元素之前将被去除所有非数字字符。</li><li id="24a2" class="nw nx iu lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated"><code class="fe ng nh ni nj b">onKeyDown</code>方法将使输入只接受数字键和导航键。<code class="fe ng nh ni nj b">onPaste</code>方法只接受通过粘贴的数字，这与<code class="fe ng nh ni nj b">onDrop</code>方法非常相似。</li><li id="f5f3" class="nw nx iu lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated"><code class="fe ng nh ni nj b">onKeyDown</code>方法使用一组常数值来确定哪些键是可接受的，哪些是不可接受的。那些常量可以在<a class="ae kz" href="https://github.com/NickHodges/primedirective/blob/master/src/app/app.consts.ts" rel="noopener ugc nofollow" target="_blank">这个名为<code class="fe ng nh ni nj b">app.consts.ts</code>的项目文件</a>中找到。最终结果是只有数字键和导航键(删除、退格等。)被控件接受，所有其他的都被忽略。</li></ul><p id="74af" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">这是我们的应用程序中的一个HTML模板，在<code class="fe ng nh ni nj b">&lt;input&gt;</code>元素中使用了<code class="fe ng nh ni nj b">numbersonly</code>指令。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="4b25" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">注意<code class="fe ng nh ni nj b">&lt;input&gt;</code>标签上有一个<code class="fe ng nh ni nj b">numbersonly</code>属性。当<code class="fe ng nh ni nj b">onKeyDown</code>、<code class="fe ng nh ni nj b">onPaste</code>和<code class="fe ng nh ni nj b">onDrop</code>事件在该输入中发生时，这将导致该输入执行来自<code class="fe ng nh ni nj b">NumbersOnlyDirective</code>的所有代码。因此，当您试用该应用程序时，您会注意到除了输入数字之外，没有别的方法——这正是我们想要的。</p><p id="30dd" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">最后，为了确保系统知道我们的指令，我们需要将它声明为我们主<code class="fe ng nh ni nj b">AppModule</code>的<code class="fe ng nh ni nj b">@NgModule</code>装饰器的一部分:</p><pre class="kk kl km kn gu nk nj nl nm aw nn bi"><span id="515d" class="no lb iu nj b gz np nq l nr ns">@NgModule({</span><span id="38bc" class="no lb iu nj b gz nt nq l nr ns">declarations: [AppComponent, NumbersOnlyDirective],</span><span id="ef97" class="no lb iu nj b gz nt nq l nr ns">...</span><span id="2798" class="no lb iu nj b gz nt nq l nr ns">})</span><span id="c243" class="no lb iu nj b gz nt nq l nr ns">export class AppModule {}</span></pre></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="21eb" class="la lb iu bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">自定义验证程序</h1><p id="d119" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">自定义指令允许您控制给定HTML元素的功能。然而，即使我们的HTML控件现在可以将输入限制为特定类型的字符，我们可能仍然希望验证该输入，并确保即使在输入限制之后它也是正确的形式。例如，即使您可能将输入限制为有效的电子邮件字符，您仍然需要确保用户输入了格式有效的电子邮件地址。</p><p id="cde5" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">在我们的例子中，我们想要的唯一有效的输入是质数。为了做到这一点，我们可以通过创建一个定制的<em class="nf">验证器</em>来插入Angular的验证过程。要创建一个定制的验证器，你需要创建一个新的类，这个类有一个方法<a class="ae kz" href="https://angular.io/api/forms/ValidatorFn" rel="noopener ugc nofollow" target="_blank">返回一个</a> <code class="fe ng nh ni nj b"><a class="ae kz" href="https://angular.io/api/forms/ValidatorFn" rel="noopener ugc nofollow" target="_blank">ValidatorFn</a></code>，这是一个知道如何验证内容的特殊函数。一个<code class="fe ng nh ni nj b">ValidatorFn</code>采取这种形式:</p><pre class="kk kl km kn gu nk nj nl nm aw nn bi"><span id="fd01" class="no lb iu nj b gz np nq l nr ns">interface <a class="ae kz" href="https://angular.io/api/forms/ValidatorFn" rel="noopener ugc nofollow" target="_blank">ValidatorFn</a> {<a class="ae kz" href="https://angular.io/api/forms/ValidatorFn#call" rel="noopener ugc nofollow" target="_blank">(control: AbstractControl): ValidationErrors | null</a> }</span></pre><p id="a1a0" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">在我们的例子中，我们希望验证输入到输入控件中的数字是一个质数，因此我们最终得到了以下文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="835b" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">以下是关于上述文件的一些注意事项:</p><ul class=""><li id="14db" class="nw nx iu lu b lv mo ly mp mb ny mf nz mj oa mn ob oc od oe bi translated">它利用一个独立的函数<code class="fe ng nh ni nj b">isPrime</code>，来确定一个给定的<code class="fe ng nh ni nj b">number </code>是否是质数。</li><li id="ecab" class="nw nx iu lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">它创建了一个名为<code class="fe ng nh ni nj b">isPrimeNumber</code>的静态函数，该函数与一个<code class="fe ng nh ni nj b">ValidatorFn</code>的契约相匹配，从而返回一个函数来验证该数字是否是一个质数。</li><li id="a2a1" class="nw nx iu lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">注意，函数本身的返回值要么是一个简单的对象，要么是<code class="fe ng nh ni nj b">null</code>。在我看来有点奇怪的结果中，如果控件有效，它返回<code class="fe ng nh ni nj b">null</code>,如果无效，则返回对象。而对象的值是<code class="fe ng nh ni nj b">true</code>。我觉得这很奇怪，但事情就是这样。</li></ul><p id="c654" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">为了利用自定义验证器，我们将其导入，然后将其添加到表单所在组件的<code class="fe ng nh ni nj b">ngOnInit()</code>方法的<code class="fe ng nh ni nj b">FormControl</code>中的验证器列表中:</p><pre class="kk kl km kn gu nk nj nl nm aw nn bi"><span id="8fad" class="no lb iu nj b gz np nq l nr ns">ngOnInit(): void {</span><span id="7ae5" class="no lb iu nj b gz nt nq l nr ns">this.noPrimeInput = new FormControl('', [</span><span id="e16f" class="no lb iu nj b gz nt nq l nr ns">    Validators.required,</span><span id="fb7f" class="no lb iu nj b gz nt nq l nr ns"><strong class="nj iv">    NumberValidators.isPrimeNumber()</strong></span><span id="ab48" class="no lb iu nj b gz nt nq l nr ns">]);</span><span id="421e" class="no lb iu nj b gz nt nq l nr ns">this.formModel = this.fb.group({noPrimeInput: this.noPrimeInput});</span><span id="6f91" class="no lb iu nj b gz nt nq l nr ns">}</span></pre><p id="9b19" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">主要组件如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="a02f" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">注意:</strong>这个组件的HTML如上所示。</p><p id="1c2c" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">关于上面的代码，有几点需要注意:</p><ul class=""><li id="208a" class="nw nx iu lu b lv mo ly mp mb ny mf nz mj oa mn ob oc od oe bi translated">与内置验证器不同，自定义验证器是通过方法名(包括括号)调用的。</li><li id="4d77" class="nw nx iu lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">该组件使用各种方法来显示或隐藏一个标签，该标签声明给定的数字是质数。这主要是内务代码，所以我们不会在这里讨论它。</li></ul></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="d07d" class="la lb iu bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">完整的申请</h1><p id="62ea" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">在这一点上，我们已经使用了一个定制的指令和一个定制的验证器来完成我们设定的任务——也就是说，只通过<code class="fe ng nh ni nj b">NumbersOnlyDirective</code>来限制对数字的输入，并通过<code class="fe ng nh ni nj b">NumberValidators.isPrime()</code>方法来确保我们只在数字是质数时才验证输入。</p><p id="d903" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">同样，您可以在这里看到正在运行的应用<a class="ae kz" href="https://stackblitz.com/github/nickhodges/primedirective" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="5c96" class="la lb iu bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">结论</h1><p id="9fd7" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">输入控制和验证是应用程序中非常重要和基本的部分。让用户容易做正确的事情是良好用户体验的一部分。通过使用自定义指令和自定义验证器，您可以确保用户输入的数据被正确格式化和存储。</p></div></div>    
</body>
</html>