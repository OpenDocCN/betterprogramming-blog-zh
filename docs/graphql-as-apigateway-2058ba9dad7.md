# GraphQL 作为 API 网关

> 原文：<https://betterprogramming.pub/graphql-as-apigateway-2058ba9dad7>

## 讨论图 QL 的 N+1 问题

![](img/30926ca0dfa807bfc0538527c47e166e.png)

在我之前的博客中，我解释了 GraphQL 如何用于微服务间的通信。我曾提到 GraphQL 也可以作为微服务的 APIGateway。在这篇博客中，我将讨论如何从 APIGateway 利用 GraphQL，以及一个众所周知的问题。

我们可以有不同的客户端(web、移动等)和多个微服务。所有这些微服务将只有一个网关。这里我将同时使用 REST 和 GraphQL。REST 用于客户端与网关之间的通信，然后网关将通过 GraphQL 与服务通信，并将响应返回给客户端。响应可以来自单个服务，也可以来自多个服务的聚合数据。API 网关当然可以执行其他常用功能，如负载平衡、授权/认证或为 express 应用程序提供额外的安全性等。

# **实施**

在这里，我将展示如何使用 APIGateway 从单个服务中获取数据。(在我之前的博客中，我已经解释了 HTTP POST 请求是如何通过查询和变量产生的，所以这里不再解释。)

在这里，APIGateway 用于返回来自不同服务的聚合数据:

**GraphQL N+1 问题:**

当我们开始深入研究 GraphQL 时，我们将开始听到人们谈论 GraphQL 的这个问题。那么什么是 GraphQL N+1 问题呢？

假设我们想要获取所有用户的所有帖子。

如果我们使用 REST，我们将进行两次 GET 调用——一次获取所有用户，另一次获取这些用户的所有帖子。

但是对于 GraphQL，我们都知道 GraphQL 使用解析器函数来处理任何查询。解析程序同时解析同一级别的字段，在后续请求中，子级别的字段将被解析。

因此，在这种情况下，首先解析器将运行查询`getAllUsers`来获取用户列表，假设我们在数据库中有 4 个用户，然后它将为这 4 个用户中的每一个运行`getPostsByUserId`，这样它将获取子级字段的数据。

在每个请求之后，我们需要聚集用户并发布数据，如下所示:

最后，合并所有数据。这样，解析器进行 1+N(在本例中是 1+4)个查询。

因为发现问题是找到解决方案的第一步，所以这个问题也可以通过使用数据的批处理和缓存来解决(或者至少我们可以说是优化的)，并且有多个包可用于此( [DataLoader 包](https://www.npmjs.com/package/dataloader)等)

# **结论**

如前一篇博客所述——graph QL 提供了精确提取数据(没有提取不足或提取过多)的好处，因此，它非常快，并在内部处理数据的聚合。

在这篇博客中，我们讨论了 GraphQL N+1 问题。因此，根据业务用例，在权衡利弊之后，我们可以使用 GraphQL 作为微服务之间的通信。

你可以在 [GitHub 库](https://github.com/aindrila-choudhuri/graphql-microservices-communication)中找到完整的源代码。

继续编码，继续改变世界！:)