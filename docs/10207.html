<html>
<head>
<title>Exploring Socket.IO in a React Working Environment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索插座。反应式工作环境中的IO</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-socket-io-in-react-working-environment-e505bf1c857c?source=collection_archive---------5-----------------------#2021-12-13">https://betterprogramming.pub/exploring-socket-io-in-react-working-environment-e505bf1c857c?source=collection_archive---------5-----------------------#2021-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5385" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">插座。IO提供企业级WebSocket</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e69686de121dfae25e8833b7d69df345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOsai25KUmH-dAlVr2IvbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="93d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">WebSocket协议在2011年12月被IETF标准化为<a class="ae lu" href="https://datatracker.ietf.org/doc/html/rfc6455" rel="noopener ugc nofollow" target="_blank"> RFC 6455 </a>，而<a class="ae lu" href="https://www.w3.org/TR/2009/WD-websockets-20091222/" rel="noopener ugc nofollow" target="_blank"> WebSocket API </a>由W3C在2009年12月指定。截至目前，所有主流浏览器都支持WebSocket API。</p><p id="c953" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://github.com/socketio/socket.io" rel="noopener ugc nofollow" target="_blank">插座。IO </a>是一个支持客户端和服务器之间实时、双向和基于事件的通信的库。它是WebSocket API的一个“微小”包装器。但是插座。IO不是WebSocket实现。而是依靠<a class="ae lu" href="https://github.com/socketio/engine.io" rel="noopener ugc nofollow" target="_blank">发动机。IO </a>，其默认行为是首先建立一个长轮询连接，然后升级到更好支持的传输，比如WebSocket。</p><p id="48ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然插座。IO非常像WebSocket，是一个套接字。IO服务器/客户端无法与WebSocket客户端/服务器通信。</p><p id="ab91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么我们需要插座。IO因为我们已经有了WebSocket API？</p><p id="460d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是因为WebSocket是最起码的标准，而Socket。IO提供企业级WebSocket。</p><ul class=""><li id="4792" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">一个插座。IO客户端在创建时会自动连接到服务器。当连接丢失或出错时，它会按照预先配置的尝试次数重新连接到服务器。默认设置是重试次数不限。</li><li id="3252" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">插座。IO连接可以是SSL，可以设置认证令牌。</li><li id="f980" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">插座。IO支持命名空间和房间来分段通信。</li><li id="8a4c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">插座。IO提供日志记录和调试支持。</li><li id="b097" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">插座。除了CJS，IO还支持ES模块。</li><li id="99c3" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">插座。IO是一个有社区支持的库，而WebSocket只是一个协议。</li></ul><p id="dfc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将探讨其中的一些特性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0f27" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设置套接字。React环境中的IO</h1><p id="95e9" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">让我们设置套接字。在<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/10-fun-facts-about-create-react-app-eb7124aa3785"> Create React App </a>环境中的IO。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="196d" class="ns mr it no b gy nt nu l nv nw">npx create-react-app react-socket<br/>cd react-socket</span></pre><p id="0713" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要一个客户端和一个服务器来相互通信。为了简化任务，我们将客户机和服务器设置在同一个存储库中。</p><p id="8b00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装服务器包:<code class="fe nx ny nz no b">npm i socket.io</code>。</p><p id="f3db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装客户端包:<code class="fe nx ny nz no b">npm i socket.io-client</code>。</p><p id="bc1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，<code class="fe nx ny nz no b">package.json</code>在<code class="fe nx ny nz no b"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/package-jsons-dependencies-in-depth-a1f0637a3129">dependencies</a></code>中包含了两个额外的包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ba99" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设置客户端套接字。超正析象管(Image Orthicon)</h1><p id="947f" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们创建了一个只有一个按钮<code class="fe nx ny nz no b">Click to request date from server</code>的用户界面。点击按钮发送一个套接字。对服务器的IO请求。收到请求后，服务器会用当前日期进行响应。客户端接收服务器日期并将其显示在屏幕上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/16b6ffa0ce2b55a6002ec2ab6ce95323.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*PUMzon9KyY_C029zXCWnDQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d59a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们修改<code class="fe nx ny nz no b">src/App.js</code>作为一个客户端。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0c8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2号线从<code class="fe nx ny nz no b">'socket.io-client'</code>进口<code class="fe nx ny nz no b">io</code>。</p><p id="82fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过调用<code class="fe nx ny nz no b">io('http://localhost:5000')</code>(第9行)来初始化一个套接字，这里我们假设服务器正在运行。如果客户端和服务器位于同一原点，则不需要指定URL。</p><p id="508c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有3个特殊事件需要收听:<code class="fe nx ny nz no b">'connect'</code>、<code class="fe nx ny nz no b">'disconnect'</code>、<code class="fe nx ny nz no b">'connect_error'</code>，分别在11号线、13号线、17号线收听。</p><p id="4273" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第21行监听自定义事件<code class="fe nx ny nz no b">'responseDate'</code>。</p><p id="f417" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们调用<code class="fe nx ny nz no b">useRef</code>(第6行)来生成一个引用以保持套接字的持久性(第23行)。客户端请求由按钮的<code class="fe nx ny nz no b">onClick</code>方法调用(第30行)。</p><p id="6c6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务器响应被保存到第21行的状态<code class="fe nx ny nz no b">serverData</code>。然后，由第34行呈现。</p><p id="d975" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nx ny nz no b">socket.on(eventName, listener)</code>是套接字中的一个方法。IO库。套接字连接侦听指定的事件，并调用回调侦听器。还有其他套接字方法，<code class="fe nx ny nz no b">socket.once(eventName, listener)</code>、<code class="fe nx ny nz no b">socket.off(eventName, listener)</code>、<code class="fe nx ny nz no b">socket.removeAllListeners([eventName])</code>、<code class="fe nx ny nz no b">socket.onAny(listener)</code>、<code class="fe nx ny nz no b">socket.prependAny(listener)</code>、<code class="fe nx ny nz no b">socket.offAny([listener])</code>。</p><p id="fe2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行应用程序，<code class="fe nx ny nz no b">npm start</code>。用户界面可从<code class="fe nx ny nz no b">http://localhost:3000</code>处的浏览器访问。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ec9fdbc9b050ad825ba839a65c6f4541.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*Y1263c0lETp35j4S1rfT_w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4a1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">控制台上有一个错误:<code class="fe nx ny nz no b">Client connect_error: Error: server error</code>。这个错误是由上面代码中第18行的<code class="fe nx ny nz no b">connect_error</code>监听器捕获的。</p><p id="885a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为没有服务器运行，所以没有<code class="fe nx ny nz no b">connect</code>发生，并且点击按钮在用户界面上没有响应。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="55a8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">在生产模式下运行客户端和服务器</h1><p id="1a27" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们需要建立一个双向通信的服务器。Create React应用程序有一个内置的<a class="ae lu" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>服务器，我们将使用它作为服务器。</p><p id="c4ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，禁止对不同来源(域、方案或端口)的请求。为了简化设置，我们在生产模式下运行客户机，由同一个Express服务器托管。</p><p id="e684" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">按照<a class="ae lu" href="https://javascript.plainenglish.io/a-hands-on-guide-for-creating-a-production-ready-react-app-864ad98e7497" rel="noopener ugc nofollow" target="_blank">生产就绪反应应用</a>中描述的步骤，我们执行命令<code class="fe nx ny nz no b">npm run build</code>。生成的<code class="fe nx ny nz no b">build</code>目录包含要部署的代码。</p><p id="e48b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将以下<code class="fe nx ny nz no b">server/index.js</code>放入Create React应用程序存储库中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="8e8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第3行创建了一个Express服务器。</p><p id="7336" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第4行从环境变量中读取端口。如果未设置，默认值为5000。</p><p id="e8f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第6–7行服务于产品网页。</p><p id="89cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第9行在指定的端口启动Express服务器。</p><p id="8b08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行<code class="fe nx ny nz no b">node server</code>，在<code class="fe nx ny nz no b">http://localhost:5000</code>可以进入用户界面。</p><p id="d99a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它仍然没有任何服务器响应，因为运行的服务器还没有配置Socket.IO。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ec9fdbc9b050ad825ba839a65c6f4541.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*Y1263c0lETp35j4S1rfT_w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="91ed" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">运行套接字。客户端和服务器之间的IO</h1><p id="5695" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">服务器端套接字。IO可以作为独立服务器运行，也可以与以下服务器一起运行:</p><ul class=""><li id="3bd0" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">HTTP服务器</li><li id="945f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">HTTPS服务器</li><li id="da70" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">HTTP/2服务器</li><li id="89ca" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">表达</li><li id="643a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> Koa </a></li><li id="ff17" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank">窝</a></li><li id="18f2" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank">加速</a></li></ul><p id="098b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们配置插座。IO服务器在<code class="fe nx ny nz no b">server/index.js</code>，连同Express服务器。还需要一个HTTP包装器，因为当调用<code class="fe nx ny nz no b">app.listen</code>时，pure Express服务器会创建一个新的HTTP服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c598" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第3行创建了一个Express服务器。</p><p id="dd42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第4行用HTTP包装了服务器。</p><p id="1d1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第5行用HTTP包装器初始化<code class="fe nx ny nz no b">io</code>。</p><p id="1c81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第6行从环境变量中读取端口。如果未设置，默认值为5000。</p><p id="93e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第8–9行服务于生产网页。</p><p id="fea8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第11行监听内置事件<code class="fe nx ny nz no b">'connection'</code>，并设置其他监听器。</p><p id="4c93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第14–20行监听自定义事件，<code class="fe nx ny nz no b">'requestDate'</code>。收到事件后，它调用服务器日期(第15行)。它发出事件的日期<code class="fe nx ny nz no b">'responseDate'</code>。没有必要对要发送的内容运行<code class="fe nx ny nz no b">JSON.stringify()</code>，因为它会自动完成。对于不可序列化的对象，如Map和Set，必须手动序列化。</p><p id="5a89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第22行监听内置事件<code class="fe nx ny nz no b">'disconnect'</code>，并打印出消息。</p><p id="2418" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第25行在指定的端口启动HTTP服务器。</p><p id="3189" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于服务器实现，单击用户界面上的按钮会显示服务器日期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/16b6ffa0ce2b55a6002ec2ab6ce95323.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*PUMzon9KyY_C029zXCWnDQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bfff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是多次点击UI按钮时的服务器端消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c3e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是来自客户端的连接消息:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="0d6f" class="ns mr it no b gy nt nu l nv nw">Client connected: 3lonJaSII81adDqdAAAB</span></pre><p id="558a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">刷新客户端UI时，服务器端会显示以下信息:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="c108" class="ns mr it no b gy nt nu l nv nw">Server disconnect: <!-- -->3lonJaSII81adDqdAAAB<br/>Server connected: vgc7rEKVV-XSfzSlAAAD</span></pre><p id="5d7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当服务器停止时，客户端会显示以下信息:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7a2b" class="ns mr it no b gy nt nu l nv nw">Client disconnected: transport close<br/>Client connect_error: Error: xhr poll error</span></pre><p id="ae17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务器停止后，通信会退回到长轮询，轮询会遇到错误。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d04b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">为WebSockt启用CORS。超正析象管(Image Orthicon)</h1><p id="7862" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们在同一个Express服务器上托管了客户端和服务器。如果不是呢？</p><p id="a1fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在运行<code class="fe nx ny nz no b">node server</code>的同时，执行<code class="fe nx ny nz no b">npm start</code>在<code class="fe nx ny nz no b">http://localhost:3000</code>托管另一个客户端。</p><p id="c017" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们遇到以下错误:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f339" class="ns mr it no b gy nt nu l nv nw">Access to XMLHttpRequest at 'http://localhost:5000/socket.io/?EIO=4&amp;transport=polling&amp;t=Nr0ASQf' from origin 'http://localhost:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.</span></pre><p id="00e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">跨来源资源共享(CORS)是一种基于HTTP头的机制，它允许服务器指示除其自身以外的任何来源(域、方案或端口),浏览器应该允许从这些来源加载资源。</p><p id="cedb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nx ny nz no b">server/index.js</code>中，我们配置<code class="fe nx ny nz no b">io</code>来启用CORS:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c9b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们可以在两个URL上运行应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/19b076a8b6ed05403f42645c094396db.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*4NKlyiMpJtuQx8kCqIBR7g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="76b8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">广播事件的各种方式</h1><p id="ae39" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在前面有两个客户端的例子中，我们发现了一些有趣的东西。单击每个应用程序的按钮只会更新它自己的日期。这是因为<code class="fe nx ny nz no b">socket.emit</code>只向自己的套接字实例发送事件。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d28f" class="ns mr it no b gy nt nu l nv nw">socket.emit('responseDate', date);</span></pre><p id="7a8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将其更改为向除发送者之外的所有连接的客户端广播事件。下面的代码通过单击每个应用程序的按钮来更新另一个应用程序的<code class="fe nx ny nz no b">date</code>。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2b90" class="ns mr it no b gy nt nu l nv nw">socket.broadcast.emit('responseDate', date);</span></pre><p id="899c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将事件发送给所有客户端吗？</p><p id="58f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是，<code class="fe nx ny nz no b">io.emit</code>向所有连接的客户端发送事件。下面的代码通过单击每个应用程序的按钮来更新两个应用程序的<code class="fe nx ny nz no b">date</code>。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="df32" class="ns mr it no b gy nt nu l nv nw">io.emit('responseDate', date);</span></pre><p id="ea70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用一个<a class="ae lu" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis适配器</a>或另一个兼容的适配器来设置多个插座。IO服务器。在这种情况下，<code class="fe nx ny nz no b">io.emit</code>将广播到所有服务器，然后广播到它们的所有客户端。下面的代码可以将广播限制到仅连接到当前服务器的那些客户端。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="89e3" class="ns mr it no b gy nt nu l nv nw">io.local.emit('responseDate', date);</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dbc1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">按名称空间和房间细分通信</h1><p id="327e" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">名称空间是一个通信通道，它将应用程序的逻辑拆分到一个共享连接上(也称为“多路复用”)。名称空间允许为套接字创建不同的上下文。IO一起工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6eb4d62dfaf5add9b2f7bd8fa4755380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdyF3AJgh6RxXD-Byl72gg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2c3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">房间是插座可以<code class="fe nx ny nz no b">join</code>和<code class="fe nx ny nz no b">leave</code>的任意通道。它可用于向客户端子集广播事件。可以在名称空间内创建文件室。例如，<code class="fe nx ny nz no b">red</code>名称空间中的<code class="fe nx ny nz no b">room0</code>只与<code class="fe nx ny nz no b">red</code>名称空间中的<code class="fe nx ny nz no b">room0</code>通信。如果创建的文件室没有名称空间，则它存在于“全局名称空间”中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58bd3bfa7329e0717d091f963b0ee4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doGlDM0QNC18KqfOFhwAnQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="944d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们创建一个套接字。带有名称空间和房间的IO示例。下面是<code class="fe nx ny nz no b">src/App.js</code>中的客户端代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0fa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第10–16行定义了一个没有任何名称空间的套接字。它监听所有事件(第12行)并将其附加到当前全局消息(第13行)。第16行在断开连接时关闭监听器。</p><p id="e8f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第18–24行定义了一个名称空间为<code class="fe nx ny nz no b">red</code>的套接字。它监听所有事件(第20行)并将其附加到当前红色消息(第21行)。第24行在断开连接时关闭监听器。</p><p id="0d33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第26–32行定义了一个名称空间为<code class="fe nx ny nz no b">blue</code>的套接字。它监听所有事件(第28行)并将其附加到当前蓝色消息(第29行)。第32行在断开连接时关闭监听器。</p><p id="040c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是<code class="fe nx ny nz no b">server/index.js</code>中的服务器代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d067" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第16–24行定义了一个没有任何名称空间的套接字。一旦连接，它就加入一个全局<code class="fe nx ny nz no b">roomN</code>(第19行)，其中N是一个递增的数(第23行)，从0开始(第16行)。然后，它向房间发送3个事件。</p><p id="2542" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第26–35行定义了一个名称空间为<code class="fe nx ny nz no b">red</code>的套接字。连接后，它加入一个红色的<code class="fe nx ny nz no b">roomN</code>(第30行)，其中N是一个递增的数字(第34行)，从0开始(第26行)。然后，它向房间发送3个事件。</p><p id="0c2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第37–46行定义了一个名称空间为<code class="fe nx ny nz no b">blue</code>的套接字。连接后，它加入一个蓝色的<code class="fe nx ny nz no b">roomN</code>(第41行)，其中N是一个递增的数字(第45行)，从0开始(第37行)。然后，它向房间发送3个事件。</p><p id="6494" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个客户端是在<code class="fe nx ny nz no b">http://localhost:5000</code>的生产构建。执行<code class="fe nx ny nz no b">npm start</code>在<code class="fe nx ny nz no b">http://localhost:3000</code>托管另一个客户端。我们可以看到消息是如何在特定的名称空间和房间中分段的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9d8e58935f9afd791e21b78512d47dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*nGC7iZ-5WhBiWWofT4lpOA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6305" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nx ny nz no b">http://localhost:5000</code>处的第一个连接有<code class="fe nx ny nz no b">GlobalRoom0</code>、<code class="fe nx ny nz no b">RedRoom0</code>和<code class="fe nx ny nz no b">BlueRoom0</code>。<code class="fe nx ny nz no b">http://localhost:3000</code>处的第二个连接有<code class="fe nx ny nz no b">GlobalRoom1</code>、<code class="fe nx ny nz no b">RedRoom1</code>和<code class="fe nx ny nz no b">BlueRoom1</code>。如果刷新其中一个客户端，我们可以看到房间指数增加。</p><p id="6a83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个房间接收发送给它的3个事件。所有这3个事件可能都是分段的，在名称空间之间，也在房间之间。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1f88" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">日志记录和调试功能</h1><p id="51b9" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">插座。IO提供了出色的日志记录和调试功能。我们可以打开调试标志来运行服务器:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="0d0e" class="ns mr it no b gy nt nu l nv nw">DEBUG=* node server</span></pre><p id="41fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下文件显示了第一个客户端连接之前的所有消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="9c31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是不是太过分了？</p><p id="02bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大概吧。</p><p id="46c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">调试消息可以按范围过滤。这可以通过在<code class="fe nx ny nz no b">*</code>前面加上一个选定的范围来实现。如果有多个作用域，可以用逗号分隔。</p><p id="56f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下示例显示了<code class="fe nx ny nz no b">socket.io:client</code>消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c5ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是干净有用多了吗？</p><p id="02b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下示例显示了<code class="fe nx ny nz no b">socket.io:client</code>消息以及<code class="fe nx ny nz no b">engine</code>消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="96af" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">插座。IO支持ES模块</h1><p id="67fe" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">到目前为止，服务器示例都是以<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/what-are-cjs-amd-umd-esm-system-and-iife-3633a112db62"> CommonJS (CJS)格式</a>编写的。ES模块(ESM)从ES2015开始成为JavaScript使用的官方标准。它广泛应用于JavaScript客户端开发。它还被作为附加类型的超集的TypeScript所采用。插座。IO也支持ES模块。</p><p id="7c43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">名称空间和房间的服务器代码的最后一个例子可以由ESM代码编写，用<code class="fe nx ny nz no b">server/index.mjs</code>命名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="44c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nx ny nz no b">Server</code>可以通过<code class="fe nx ny nz no b">'socket.io'</code>(第6行)导入，不使用<code class="fe nx ny nz no b">require</code>。</p><p id="a522" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">参照<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/what-might-be-coming-in-npm-9-6985cf2678a6">ES模块</a>的说明，可以用<code class="fe nx ny nz no b">node server/index.mjs</code>执行。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="72cd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="d66b" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们已经检查了一些插座。木卫一的特点。给出的例子显示了如何在客户机和服务器之间建立WebSocket连接。这些通信是实时的、双向的和基于事件的。它们可以用名称空间和房间来划分。插座。IO支持ES模块，并提供日志和调试支持。</p><p id="17d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您不想自己构建一个企业级WebSocket，那么Socket。IO是专注于应用开发的好选择。</p><p id="2367" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Domino Data Lab使用Socket.IO，它非常适合客户端和服务器通信。</p><p id="76d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae lu" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>