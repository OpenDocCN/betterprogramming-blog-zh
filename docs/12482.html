<html>
<head>
<title>How To Boost Your iOS Code Performance: Reduce Searching In Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高iOS代码性能:减少数组搜索</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-boost-your-ios-code-performance-reduce-searching-an-array-55fbdfee2050?source=collection_archive---------8-----------------------#2022-06-08">https://betterprogramming.pub/how-to-boost-your-ios-code-performance-reduce-searching-an-array-55fbdfee2050?source=collection_archive---------8-----------------------#2022-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ee1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">优化快速和客观的C代码速度的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b9eaad1f331f6602db9791158bd4a210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SJTtaOVZFfBsSqKp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aronvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aron视觉效果</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2e0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代一个数组的时间复杂度是O(n)。听起来可以接受吧？当我们在截止日期前有大量的工作要做时，我们可能会忽略它对代码性能的影响，而不会花更多的精力去考虑更好的解决方案。但是，一旦使用这种技能成为一种自然的反应，我们可能会意识不到我们甚至在代码中编写了嵌套的for循环或嵌套过滤器，这将时间复杂度增加到O(n)，并且我们很可能在以后遭受性能问题。</p><p id="748f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试在非顺序集合类型中搜索，如<code class="fe lv lw lx ly b">Set</code>和<code class="fe lv lw lx ly b">Dictionary</code>，而不是<code class="fe lv lw lx ly b">Array</code>，因为在<code class="fe lv lw lx ly b">Set</code>和<code class="fe lv lw lx ly b">dictionary</code>中搜索的时间复杂度是O(1)，而在<code class="fe lv lw lx ly b">Array</code>中搜索的时间复杂度是O(n)。</p><p id="b18c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示如何使用<code class="fe lv lw lx ly b">Set</code>和<code class="fe lv lw lx ly b">dictionary</code>优化速度。</p><h1 id="ed0c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">示例1:设置</h1><p id="37a6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在示例1中，有所有会员的数据和白金会员的id。目标是用<code class="fe lv lw lx ly b">platinumMemberIDs</code>从<code class="fe lv lw lx ly b">members</code>中派生出一组白金会员。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="c5f5" class="na ma it ly b gy nb nc l nd ne">let members: [Member]<br/>let platinumMemberIDs:[Int]</span></pre><h2 id="1962" class="na ma it bd mb nf ng dn mf nh ni dp mj li nj nk ml lm nl nm mn lq nn no mp np bi translated">优化前</h2><p id="829b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">filter(_:)</code>的时间复杂度为O(n)，数组实例方法<code class="fe lv lw lx ly b">contains(_:)</code>的时间复杂度也为O(n)。</p><p id="68fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的方法遍历<code class="fe lv lw lx ly b">members</code>数组。在每次迭代中，它在<code class="fe lv lw lx ly b">platinumMemberIDs</code>中搜索以检查<code class="fe lv lw lx ly b">platinumMemberIDs</code>是否包含当前成员的id。</p><p id="ad24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法的时间复杂度为O(n)。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="8175" class="na ma it ly b gy nb nc l nd ne">var platinumMembers = members.filter {<br/>    platinumMemberIDs.contains($0.id)<br/>}</span></pre><h2 id="c071" class="na ma it bd mb nf ng dn mf nh ni dp mj li nj nk ml lm nl nm mn lq nn no mp np bi translated">优化后</h2><p id="0564" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">由于<code class="fe lv lw lx ly b">platinumMemberIDs</code>的顺序无关紧要，我们可以将该数据保存在非顺序收集类型<code class="fe lv lw lx ly b">Set</code>中。在a <code class="fe lv lw lx ly b">Set</code>中搜索的时间复杂度为O(1)。总的时间复杂度降低到O(n)。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="6c9a" class="na ma it ly b gy nb nc l nd ne">let platinumMemberIDSet = Set(platinumMemberIDs)</span><span id="7dcb" class="na ma it ly b gy nq nc l nd ne">var platinumMembers = members.filter {<br/>    platinumMemberIDSet.contains($0.id)<br/>}</span></pre><h1 id="d222" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">示例2:字典</h1><p id="d01c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在示例2中，有两组来自不同来源的用户，我们希望找出他们的交集。只要一个用户的电子邮件与另一个组中的另一个用户的电子邮件相同，我们就认为他们是同一个用户。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="64e2" class="na ma it ly b gy nb nc l nd ne">let starUsers: [User]<br/>let recentUsers: [User]</span></pre><h2 id="ca69" class="na ma it bd mb nf ng dn mf nh ni dp mj li nj nk ml lm nl nm mn lq nn no mp np bi translated">优化前</h2><p id="8d21" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最简单的方法是编写嵌套的for-loops来找出重复的用户，但是时间复杂度会是O(n)，不是很理想。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="1153" class="na ma it ly b gy nb nc l nd ne">var duplicatedUsers = [User]()</span><span id="cff3" class="na ma it ly b gy nq nc l nd ne">for star in starUsers {<br/>  for recent in recentUsers {<br/>    if star.email == recent.email {<br/>      duplicatedUsers.append(star)<br/>    }<br/>  }<br/>}</span></pre><h2 id="fa29" class="na ma it bd mb nf ng dn mf nh ni dp mj li nj nk ml lm nl nm mn lq nn no mp np bi translated">优化后</h2><p id="b79b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为了降低时间复杂度，我们可以简单地从<code class="fe lv lw lx ly b">recentUsers</code>数组创建一个字典，其中每个用户的电子邮件作为键，用户对象作为值。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="8f91" class="na ma it ly b gy nb nc l nd ne">let recentUserMap = Dictionary(uniqueKeysWithValues: recentUsers.map { ($0.email, $0) })</span></pre><p id="3e25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们搜索<code class="fe lv lw lx ly b">starUsers</code>数组，但是在每次迭代中，我们不需要迭代<code class="fe lv lw lx ly b">recentUsers</code>数组来找出优化后的重复用户。相反，我们直接从<code class="fe lv lw lx ly b">recentUserMap</code>访问一个最近用户的用户对象，该用户的电子邮件与当前的明星用户相同。时间复杂度降低到O(n)。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="8269" class="na ma it ly b gy nb nc l nd ne">let duplicatedUsers = starUsers.filter {<br/>  guard let _ = recentUserMap[$0.email] else { return false }<br/>  return true<br/>}</span></pre><p id="7773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，这里有另一篇你可能喜欢的文章:</p><h1 id="f200" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">如何通过减少集合类型初始化来提高iOS代码性能</h1><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-boost-your-ios-code-performance-by-reducing-collection-type-initialisation-564bffee94a3"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">如何通过减少集合类型初始化来提高iOS代码性能</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">优化快速和客观的C代码速度的技巧</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">better编程. pub</p></div></div><div class="od l"><div class="oe l of og oh od oi ks nu"/></div></div></a></div></div></div>    
</body>
</html>