<html>
<head>
<title>Did You Know That Almost Everything Is an Object in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你知道吗，在JavaScript中几乎所有的东西都是对象。</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/did-you-know-that-almost-everything-is-an-object-in-javascript-f06c3f69faf1?source=collection_archive---------5-----------------------#2021-04-06">https://betterprogramming.pub/did-you-know-that-almost-everything-is-an-object-in-javascript-f06c3f69faf1?source=collection_archive---------5-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c86d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你可能听说过这个，但是让我们看看是否真的是这样</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be0453de24a88f553253448b0466b851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4k7Db-L-9lBOcO7U"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Boris Stefanik 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="4804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们应该理解在这种语言中一个对象实际上是什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bedd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目标</h1><p id="f2aa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对象是属性的动态集合，其原型具有隐藏属性。</p><p id="5b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个定义对你来说可能看起来不同，因为在其他语言中对象是一个类的实例。在JavaScript中，它只是键值对的集合。</p><p id="5b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了一个对象，我们就可以添加、编辑或删除它的属性。考虑以下空对象:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="281d" class="ne md it na b gy nf ng l nh ni">const game = {};<br/>game.name = 'Candy Crush'; //prop added<br/>game.name = 'Candy Crush Saga'; //prop edited<br/>delete game.name //prop deleted</span></pre><p id="ac3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象确实有一个对原型对象的隐藏属性，叫做<code class="fe nj nk nl na b">__proto__</code>。所有对象都继承内置<code class="fe nj nk nl na b">Object.proptotype</code>对象的属性。下面是我们如何检查这一点:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a376" class="ne md it na b gy nf ng l nh ni">game.__proto__ === Object.prototype;<br/>//true</span><span id="b657" class="ne md it na b gy nm ng l nh ni">Object.getPrototypeOf(game) === Object.prototype;<br/>//true</span></pre><p id="a090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">Object.getPrototypeOf()</code>是获取对象原型的更好选择。我使用<code class="fe nj nk nl na b">__proto__</code>属性只是为了显示一个隐藏的属性实际上存在于新创建的对象上。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8fbd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数组</h1><p id="749d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数组是对象吗？</p><p id="90c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住对象是什么:道具的动态集合。让我们创建一个空数组，并向其中添加新属性:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c041" class="ne md it na b gy nf ng l nh ni">const flightArr = [];</span><span id="ee29" class="ne md it na b gy nm ng l nh ni">flightArr.no = 815; //prop added<br/>flightArr.from = 'Sydney'; //prop added<br/>delete flightArr.no //prop delete</span></pre><p id="9f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们检查数组是否有其原型的隐藏道具，<code class="fe nj nk nl na b">Array.prototype</code>:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e4c4" class="ne md it na b gy nf ng l nh ni">flightArr.__proto__ === Array.prototype;<br/>//true</span><span id="4ceb" class="ne md it na b gy nm ng l nh ni">Object.getPrototypeOf(flightArr) === Array.prototype;<br/>//true</span></pre><p id="3f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组确实是对象，但是它们不应该像前面的例子那样使用。下面，您可以查看我们如何创建一个简单的数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c96c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该知道的是，数组是使用对象模拟的。使用类似于下面的对象模拟以前的阵列:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5385" class="ne md it na b gy nf ng l nh ni">{<br/> '0': 'Jack',<br/> '1': 'Locke',<br/> '2': 'Kate'<br/>}</span></pre><p id="727e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它是一个对象，我们可以使用字符串键访问它上面的元素。数组索引被转换为字符串。这就是为什么索引<code class="fe nj nk nl na b">1</code>和键串<code class="fe nj nk nl na b">'1'</code>返回相同的元素:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ebd7" class="ne md it na b gy nf ng l nh ni">arr['1'];<br/>//'Locke'</span><span id="609b" class="ne md it na b gy nm ng l nh ni">arr[1] === arr['1'];<br/>//true</span></pre><p id="1029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连JavaScript都搞混了，说数组是对象。只是尝试一下<code class="fe nj nk nl na b">typeof</code>操作符。为了确定一个值实际上是否是一个数组，我们需要使用<code class="fe nj nk nl na b">Array.isArray</code>:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5326" class="ne md it na b gy nf ng l nh ni">const arr = [];</span><span id="c023" class="ne md it na b gy nm ng l nh ni">typeof arr<br/>//'object'</span><span id="5999" class="ne md it na b gy nm ng l nh ni">Array.isArray(<!-- -->arr);<br/>//true</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="479c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">功能</h1><p id="c806" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数也是对象吗？</p><p id="2ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着创建一个函数，并开始向它添加属性:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1797" class="ne md it na b gy nf ng l nh ni">const movie = function(){};<br/>movie.title = 'Toc Toc'; //prop added<br/>movie.year = 2017; //prop added<br/>delete movie.year; //prop deleted</span></pre><p id="503c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的<code class="fe nj nk nl na b">Integer</code>函数，它将其他值转换成整数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="551b" class="ne md it na b gy nf ng l nh ni">const Integer = function(value){ <br/>  return parseInt(value);<br/>};</span><span id="3cb3" class="ne md it na b gy nm ng l nh ni">Integer('123');<br/>//123</span></pre><p id="db7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，我们可以向它添加两个属性——一个保存<code class="fe nj nk nl na b">MAX_VALUE</code>数值，另一个存储函数。我们能够在<code class="fe nj nk nl na b">Integer</code>函数上调用<code class="fe nj nk nl na b">isInteger</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你觉得熟悉吗？</p><p id="c9ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的内置函数(<code class="fe nj nk nl na b">Number</code>、<code class="fe nj nk nl na b">String</code>、<code class="fe nj nk nl na b">Boolean</code>、<code class="fe nj nk nl na b">Object</code>)都是这样的。</p><p id="cec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">Number</code>函数将字符串转换成数字，但是<code class="fe nj nk nl na b">Number</code>也是一个对象，有类似<code class="fe nj nk nl na b">isInteger</code>、<code class="fe nj nk nl na b">isNaN</code>等方法。它保存像<code class="fe nj nk nl na b">Number.EPSILON</code>或<code class="fe nj nk nl na b">Number.MAX_VALUE</code>这样的数据对象。它还有一个<code class="fe nj nk nl na b">Number.prototype</code>属性，保存用于所有数字的原型。</p><p id="d1b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们可以说函数是一个可调用的对象。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3949" class="ne md it na b gy nf ng l nh ni">const x = function(){ return 'Hi' };<br/>x.type = 'Greeting';</span><span id="84f3" class="ne md it na b gy nm ng l nh ni">console.log(x());<br/>console.log(x.type);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0180" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基元</h1><p id="1057" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">以下内置类型是原语:<code class="fe nj nk nl na b">boolean</code>、<code class="fe nj nk nl na b">number</code>、<code class="fe nj nk nl na b">bigint</code>、<code class="fe nj nk nl na b">string</code>、<code class="fe nj nk nl na b">symbol</code>、<code class="fe nj nk nl na b">null</code>和<code class="fe nj nk nl na b">undefined</code>。</p><p id="e0a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原语是对象吗？我们能给它们添加属性吗？</p><p id="dcc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下一个例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4dec" class="ne md it na b gy nf ng l nh ni">const text = "Hi";<br/>text.type = 'greeting';</span><span id="9191" class="ne md it na b gy nm ng l nh ni">console.log(text.type);<br/>//undefined</span></pre><p id="ba43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能添加、编辑或删除字符串等原语的属性，但是我们可以访问从<code class="fe nj nk nl na b">String.prototype</code>继承的所有方法，就像它们是对象一样。</p><p id="0caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们试图使用访问操作符访问一个属性时，JavaScript会临时将字符串值转换成一个<code class="fe nj nk nl na b">String</code>对象，并访问新创建的对象的属性:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="20b2" class="ne md it na b gy nf ng l nh ni">'<!-- -->in bruges<!-- -->'.toUpperCase(); <br/>// "IN BRUGES"</span></pre><p id="a559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，会发生这样的事情:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8d66" class="ne md it na b gy nf ng l nh ni">new String('<!-- -->in bruges<!-- -->').toUpperCase();</span></pre><p id="23fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当试图访问字符串上的<code class="fe nj nk nl na b">toUpperCase</code>属性时，JavaScript会围绕它构建一个临时包装器对象，并访问<code class="fe nj nk nl na b">toUpperCase</code>属性。访问该属性后，包装对象可以被销毁。</p><p id="d99e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe nj nk nl na b">null</code>和<code class="fe nj nk nl na b">undefined</code>之外的其他原语都有这些将原语转换为包装对象的内置函数:<code class="fe nj nk nl na b">Boolean</code>、<code class="fe nj nk nl na b">Number</code>、<code class="fe nj nk nl na b">BigInt</code>、<code class="fe nj nk nl na b">Symbol</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4590" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">空且未定义</h1><p id="0025" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/programming-essentials/essential-things-on-undefined-and-null-178e2baa21b8" rel="noopener"> null和undefined </a>仍然是原语，但不作为对象处理。</p><p id="4baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">null</code>和<code class="fe nj nk nl na b">undefined</code>不会被转换成对象包装器。试图访问这些原语的属性将会引发错误:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8ecb" class="ne md it na b gy nf ng l nh ni">null.msg; <br/>// Uncaught TypeError: Cannot read property 'msg' of null</span><span id="52cd" class="ne md it na b gy nm ng l nh ni">undefined.length; <br/>// Uncaught TypeError: Cannot read property 'msg' of undefined</span></pre><p id="02b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们不能给这两个值添加属性。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1097" class="ne md it na b gy nf ng l nh ni">const x = null;</span><span id="d287" class="ne md it na b gy nm ng l nh ni">x.msg = 'Hi';<br/>//Uncaught TypeError: Cannot set property 'msg' of null</span></pre><p id="1f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，JavaScript是误导性的，它说<code class="fe nj nk nl na b">null</code>是一个对象:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b62b" class="ne md it na b gy nf ng l nh ni">typeof(null);<br/>//'object'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="27aa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="5740" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数和数组都是对象，但并不是JavaScript中的所有东西都是对象。</p><p id="11b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原语不是对象，但总的来说JavaScript试图让它们看起来像对象，并保持一切都是对象的假象。这种方法有两个例外:<code class="fe nj nk nl na b">null</code>和<code class="fe nj nk nl na b">undefined</code>。这两个值不被视为对象。基元值到包装器对象的转换发生在幕后，可能使基元看起来像对象，但是属性是在包装器对象上访问的。</p><p id="5545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，除了原语之外的所有值都是对象，甚至原语也试图看起来像JavaScript中的对象。</p><p id="ad0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>