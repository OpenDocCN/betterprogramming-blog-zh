<html>
<head>
<title>Beginning Python Programming — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python编程入门—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginning-python-programming-part-2-reference-types-pointers-and-collection-types-a806ef6b92cf?source=collection_archive---------1-----------------------#2019-05-19">https://betterprogramming.pub/beginning-python-programming-part-2-reference-types-pointers-and-collection-types-a806ef6b92cf?source=collection_archive---------1-----------------------#2019-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fafa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">引用类型、指针和集合类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/675e084b2013d72121c4eed8486164eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TIGO3dUA1yew3af4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·劳顿在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="f1ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python系列的第一部分<a class="ae ky" href="https://medium.com/@broebling/beginning-python-programming-part-1-variables-constants-and-types-1199da1572c8" rel="noopener">中，我们介绍了变量、常量和类型。今天，我们将讨论引用类型、指针和集合类型！</a></p><p id="165c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其他编程语言中，你会有值类型的概念。在Python中，这个概念是不存在的。相反，我们只有引用类型。尽管我很想深入研究，但有一个先决条件是所有面向对象语言共有的，但也是最难理解的概念之一，叫做指针。</p><h1 id="d2e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">初步材料</h1><p id="b8ad" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">上次我们谈到了内存，以及它是如何以块、字节和位的形式排列的。我想在这里详述一下，给你们一些记忆是如何工作的视觉表现。</p><p id="dd1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个保存值<strong class="lb iu"> Hello </strong>的字符串。没什么特别的，我们以前做过。</p><p id="d3b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在上一篇文章中告诉过你，内存保存值。如果我们可以看看这段记忆，它会是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/e990d4756c2325809e280a7fa4fe7295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjtNnINmLehSTDFbpgvcgg.png"/></div></div></figure><p id="ad88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我打赌你在问字符串末尾的<code class="fe mt mu mv mw b">\0</code>是什么！这被称为空终止符。斜线告诉程序为一个命令做好准备，零代表什么。这就是字符串值的存储方式，让程序知道字符串何时结束，同时仍然允许使用空格。</p><p id="001f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数字有点不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/0fa1e5e435e596efe376e7b49ca4ae2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eaEHygl5FPyOe3Lfodb1GQ.png"/></div></div></figure><p id="0ea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数字以二进制数的形式存储。二进制很容易理解，从内存块最右边的1开始，一直向左，每次将当前值乘以2。如果你熟悉显卡或记忆棒，这就是为什么我们看到8位(雅达利，NES)，16位(世嘉创世纪，SNES)，32位(PlayStation)，64位(任天堂64)，等等。</p><p id="396f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在二进制中，如果一个位置是0，它是off，它是false。如果一个位置是1，它是on，或true。<br/>基于这个逻辑，我们只需要计算其中有1的位置。你能算出上图中的数字吗？</p><p id="9494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这是一组8位的内存，没错，是一个完整字节的内存。之前我说过字符串中的每个字符是2个字节，这意味着我们用16位来存储一个字符。二进制的16位给了我们128的最大值。然而，当我们谈论职位时，我们总是从0开始。所以16位给你一个全范围的<code class="fe mt mu mv mw b">0-127</code>。如果您想知道如何获取超出该范围的字符，我将为您介绍<a class="ae ky" href="http://www.asciitable.com" rel="noopener ugc nofollow" target="_blank"> ASCII表</a>，您可以在其中看到自己的值。你甚至会看到隐藏的字符，比如上面显示的空终止符<code class="fe mt mu mv mw b">/0</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/37aa5baf1eea3fc320af5e5ee78cadc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*ZWtMdrzlWjyEkrDUXMRWqA.png"/></div></figure><p id="3d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存将值存储在三个地方:<em class="mx">静态</em>内存、<em class="mx">堆栈</em>和<em class="mx">堆。</em></p><p id="7dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态内存和堆栈内存的访问速度很快，但是从堆中访问东西的速度很慢(在计算机时间内)。虽然对您来说可能不慢，但是从堆栈中加载可能需要一毫秒或更短的时间，从堆中加载可能需要10 ms。在大多数语言中，您可以根据变量的类型选择在哪里实例化变量。在Python中，解释器(底层引擎)会查看您的代码，并根据变量的<em class="mx">作用域假设变量应该存储在内存中的什么位置。现在谈论范围还为时过早，但是我保证我们会在以后的文章中讨论它。</em></p><p id="b03e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧。</p><h1 id="50a2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">引用类型和指针</h1><p id="4c2f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">引用类型使用指针在内存中存储值。在我们深入讨论如何使用它们之前，我们真的需要了解一下指针。</p><p id="74d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看一个典型的C程序，你会发现到处都在使用指针。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<code class="fe mt mu mv mw b">char *name = “Bob";</code>时，我们通过使用<code class="fe mt mu mv mw b">*</code>来制作指针。这告诉系统，给我一个<em class="mx">地址</em>，我可以在内存中存储这个值。然后系统会说“好的，你可以用第3块来表示你的价值。”然后在第3块中保存<code class="fe mt mu mv mw b">"Bob"</code>(当然没有引号)。</p><p id="c9fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用<code class="fe mt mu mv mw b">printf("%x", name);</code>请求name的值，您将只看到地址，它可能看起来类似于<code class="fe mt mu mv mw b">0x03</code>只是更长一些。这是该内存块的十六进制表示。如果你想要值<code class="fe mt mu mv mw b">Bob</code>，那么你必须使用<code class="fe mt mu mv mw b">printf(*name);</code>(两个打印语句都在C中)。</p><p id="1fba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在C语言中，如果你想从任何地方改变这个值，你可以使用<code class="fe mt mu mv mw b">&amp;name </code>，它告诉你获取这个值的地址并对它做一些事情。当值改变时，您可以通过引用<code class="fe mt mu mv mw b">*name</code>立即使用新值。</p><p id="71c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在引擎盖下，Python查看您的变量并为您完成所有这些<code class="fe mt mu mv mw b">*</code>魔法。它让每一个程序员的工作都因此变得更加轻松。因为它为您处理了所有这些，所以您不必担心会产生内存泄漏，但是，您仍然需要担心一些称为竞争条件的问题，我们将在后面讨论。</p><p id="8129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我提出引用类型的原因是因为我们将在本系列的下一部分讨论更高级的类型。我只是想让你在我们开始之前熟悉一下引用类型是如何工作的。</p><p id="1d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我记住引用类型的方法是想象一个宝箱。它不属于任何人，但是我一找到它，我就记下它在哪里，这样我就可以随时回来找它。如果我想看地图看它在哪里或者告诉别人，我用<code class="fe mt mu mv mw b">&amp;</code>。如果我想打开它，看看里面的宝藏，我用<code class="fe mt mu mv mw b">*</code>。如果我想把东西放进去或者拿出来，还是要先用<code class="fe mt mu mv mw b">*</code>才能拿到。</p><p id="5fa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你在C指针中存储一个像<code class="fe mt mu mv mw b">Bob</code>这样的值时，你实际上是把每个字母放在一个单独的内存块中。你真正知道的只是<code class="fe mt mu mv mw b">B</code>在哪里；空终止符<code class="fe mt mu mv mw b">/0</code>告诉计算机什么时候停止<em class="mx">在内存中的迭代</em>并返回它所拥有的任何值。就当是街霸里的一键连击吧。当我们谈到集合类型的时候，我会详细讨论这个问题，如果你根据我将要介绍的类型，把字符串在C语言中的工作方式(也称为C-Strings)联系起来，那么你是正确的。</p><p id="c8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着我们的继续，你会有一些想法。如果你想学习C、C++或Objective-C，这些都是非常重要的信息，然而，使用Python，它们很好地隐藏了所有这些复杂性，所以你几乎不必担心<code class="fe mt mu mv mw b">&amp;</code>或<code class="fe mt mu mv mw b">*</code> <em class="mx">运算符</em>。</p><p id="193a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引用类型可以存储在堆栈中，也可以存储在堆中。如果程序员使用<code class="fe mt mu mv mw b">malloc</code>为引用类型手动分配内存，您将知道引用类型是否存储在堆中。*</p><p id="3cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">*任何用malloc创建的变量在程序结束时都不会自行消失，您必须根据您的语言调用</em> <code class="fe mt mu mv mw b"><em class="mx">dealloc</em></code> <em class="mx">或</em> <code class="fe mt mu mv mw b"><em class="mx">free</em></code> <em class="mx">来从内存中删除该值，否则，它会一直留在内存中，直到计算机重新启动。这就是所谓的“内存泄漏”。</em></p><p id="b9e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python为您处理所有这些，因此您不必担心<code class="fe mt mu mv mw b">malloc</code>、<code class="fe mt mu mv mw b">dealloc</code>或<code class="fe mt mu mv mw b">free</code>。有一个例外，你可以使用<code class="fe mt mu mv mw b">del</code>来清空存储变量的内存，但是你通常不需要使用这个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/8d619eebb7476019c9fcd591b30e89ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3rEaL5dm8LbU05w4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="4fd0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">集合类型</h1><p id="b8fb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">集合类型是包含项集合的类型。主要有两种:<em class="mx">列表</em>和<em class="mx">词典。</em>一些语言将列表称为<em class="mx">数组。</em>如果你需要在另一种语言的例子和Python之间翻译代码，要知道它们指的是同一类型的集合。</p><ol class=""><li id="d959" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated"><strong class="lb iu">列表</strong> —列表包含有序的相似元素，这些元素通过其索引<em class="mx">可寻址</em>。索引由从列表开始的项目数定义。如果我们这样定义一个列表:<br/> <code class="fe mt mu mv mw b">my_list = ["eggs", "milk", "butter", "cheese"]</code> <br/>我们能够通过使用<code class="fe mt mu mv mw b">‘my_list[0]’</code>来检索这些值中的每一个，这将给我们值<code class="fe mt mu mv mw b">eggs</code>，因为它是从列表开始的0个位置。使用这个逻辑，如果我们想要<code class="fe mt mu mv mw b">butter</code>，我们将使用<code class="fe mt mu mv mw b">my_list[2]</code>，因为它距离<code class="fe mt mu mv mw b">eggs</code>有<code class="fe mt mu mv mw b">2</code>个位置。如果我们想改变存储在列表中的值，我们可以使用<br/> <code class="fe mt mu mv mw b">my_list[2] = "Sugar"</code>。令人惊讶的是，在C弦中，这更有意义。当我们在C-string中存储<code class="fe mt mu mv mw b">Bob</code>时，我们实际上创建了一个字符的<em class="mx">数组</em>(因此是char类型)。如果我们说<code class="fe mt mu mv mw b">name[0]</code>,它会返回<code class="fe mt mu mv mw b">B</code>,因为它从数组开始就是0块内存。如果你在数组之外，你会遇到问题。大多数时候，电脑会帮你避免说“索引超出范围”或类似的话。如果你在程序运行时遇到这个问题，程序就会崩溃。<br/>更具体到Python，您可以使用下面的语法使用列表片段:<br/> <code class="fe mt mu mv mw b">my_list[1:3]</code>这将返回列表中的第2和第3项。<br/>您也可以使用开放式范围，例如:<br/> <code class="fe mt mu mv mw b">my_list[:2]</code>返回列表中从第一个元素到第二个元素的所有内容，<code class="fe mt mu mv mw b">my_list[1:]</code>从第二个元素开始，一直到最后。<br/>这样理解的方式是:<br/> <code class="fe mt mu mv mw b">my_list[&lt;start position&gt;:&lt;stop position — 1&gt;]<br/></code>也可以用负数来排除末尾的值。<br/> <code class="fe mt mu mv mw b">my_list[:-2]</code>返回列表中除最后两个元素之外的所有内容。<br/>列表可以包含任何类型的变量，所以<code class="fe mt mu mv mw b">[True', 'three', 3]</code>，即一个布尔值、一个字符串和一个数字，仍然是一个有效的列表。感谢<a class="nl nm ep" href="https://medium.com/u/66a601633f9c?source=post_page-----a806ef6b92cf--------------------------------" rel="noopener" target="_blank">格雷格</a>。</li><li id="9e37" class="nc nd it lb b lc nn lf no li np lm nq lq nr lu nh ni nj nk bi translated">字典<strong class="lb iu"/>——我让你猜猜为什么它会这样命名。字典和数组的相似之处在于它们都包含相同类型的值，但是它们是不同的，因为它们是无序的。它们确实包含索引，但索引通常是一个字符串值。考虑到这一点，你可能会想到字典中的一个词，然后是它的定义。大概就是这么回事吧！您可以使用以下代码定义一个字典:<br/><code class="fe mt mu mv mw b">my_dictionary = {"Kevin": "Lead Minion", "Bob", "Determined Minion", "Stewart": "Rocker Minion"}</code><br/><code class="fe mt mu mv mw b">:</code>将键和值分开。<br/>我们可以通过使用<code class="fe mt mu mv mw b">my_dictionary["Kevin"]</code> <br/>来获得其中任何一个的值。你可以使用与列表相同的语法在字典中设置值，只需使用<em class="mx">键</em>来设置<em class="mx">值。</em> Python不关心确保值是同一类型，例如:<br/> <code class="fe mt mu mv mw b">my_dictionary["Bob"] = "King Bob"</code>是允许的。<br/>T4也是允许的。使用<br/> <code class="fe mt mu mv mw b">my_dictionary = {}</code>可以声明和实例化字典。</li></ol><p id="442c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中广泛使用字典和列表。您需要小心处理列表，使其不超出元素的范围。如果您试图访问一个字典中不存在的值，您将收到一个<code class="fe mt mu mv mw b">KeyValue</code>错误。</p><h1 id="8e83" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="b46d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">今天我们学习了引用类型，集合类型，以及一些关于内存的知识。</p><h1 id="bb9a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">下一步是什么</h1><p id="e52b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在下一篇文章中，我们将讨论操作符和<code class="fe mt mu mv mw b">None</code>。大部分初步的背景信息已经结束，很快我们就可以享受编程的乐趣了。</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/@broebling/beginning-python-programming-part-3-operators-and-none-3a80de041411" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">Python编程入门第3部分—运算符和无</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">在上一篇文章中，我们讨论了引用类型、指针和集合类型。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div></div></div>    
</body>
</html>