<html>
<head>
<title>REST API in Go with PostgreSQL and sqlc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PostgreSQL和sqlc在Go中使用REST API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-c765d571b9e7?source=collection_archive---------2-----------------------#2022-08-17">https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-c765d571b9e7?source=collection_archive---------2-----------------------#2022-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a1ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Go第1部分构建现代REST API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bf48c9bc557477057a30bf2d02fde831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpFLpJaxkfSiCi57JAB8FQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/s/photos/sql?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@sunder_2k25?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sunder Muthukumaran </a>拍摄</p></figure><p id="2efc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是一系列文章中的第一篇，涵盖了逐步实现现代REST API微服务的所有方面:</p><ol class=""><li id="2e00" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">用sqlc定义SQL优先数据模型</strong></li><li id="b88f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-39b0e966534a" rel="noopener">用Gin实现REST API</a></li><li id="55cf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-1d48767a813" rel="noopener">用Viper配置</a></li><li id="6a11" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-e0070aa1b383" rel="noopener">在容器中构建和运行</a></li><li id="a673" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-7c916ce2816a" rel="noopener">集装箱测试</a></li></ol><p id="0265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该系列的所有代码都可以在https://github.com/bquenin/go-modern-rest-api-tutorial<a class="ae kv" href="https://github.com/bquenin/go-modern-rest-api-tutorial" rel="noopener ugc nofollow" target="_blank">获得</a></p><h1 id="5298" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">我们的数据模型的真实来源是什么？</h1><p id="831d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">将数据库模型和查询与代码同步通常有两种主要方法:</p><ul class=""><li id="72ab" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated"><strong class="ky ir">代码优先</strong>:代码是真理的源泉，数据库模式就是从中生成的。这就是ORM库如<a class="ae kv" href="https://github.com/go-gorm/gorm" rel="noopener ugc nofollow" target="_blank"> gorm </a>所做的。</li><li id="b441" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated"><strong class="ky ir"> SQL第一</strong>:反过来说，SQL模式是真理的来源，代码就是从中生成的。最流行的库是sqlc。</li></ul><p id="6bfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种方法各有利弊。当您希望ORM库为您处理所有样板CRUD操作时，代码优先通常更好。但是，如果您想要微调数据库查询，它可能会碍事。在这种情况下，SQL优先的方法可能更合适，允许您完全控制您的数据库模式并微调您的SQL查询，这可能是必要的，具体取决于您正在构建的API的类型。然而，使用这种方法，您将不得不自己编写所有的SQL查询。</p><p id="9d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哪个更好没有对错之分。这完全取决于您觉得哪种方式更合适，因为您可以使用这两种方式构建生产级应用程序。在本教程中，我们将关注SQL优先的方法，并使用<a class="ae kv" href="https://sqlc.dev/" rel="noopener ugc nofollow" target="_blank"> sqlc </a>从我们的SQL模式和查询中生成代码。</p><h1 id="1bff" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">SQL优先数据模型</h1><p id="7074" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">定义数据模型是实现REST API微服务的关键步骤。你必须掌握正确的概念，并且很好地理解你的消费领域。</p><p id="4599" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这超出了本教程的范围，我们将只关注如何一步一步地构建REST API微服务。因此，我们将使用与sqlc教程中相同的模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">schema.sql</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">查询. sql</p></figure><p id="29ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ng"> schema.sql </em>文件描述了一个简单的Author对象，而<em class="ng"> queries.sql文件</em>提供了所有的CRUDL(创建、读取、更新、删除和列表)查询。正如您所注意到的，每个查询前面都有一个注释，提供要生成的函数的名称以及它返回多少结果(其中一个是<strong class="ky ir"> exec，one，</strong>和<strong class="ky ir"> many </strong>)。这个例子很简单，但是如果您的模型更复杂，可以参考sqlc文档。</p><p id="0b44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">部分更新SQL查询更复杂，因为sqlc中的查询必须事先完全结构化。因此，每个字段都根据相关布尔值的存在进行有条件的更新。例如，只有当<strong class="ky ir">更新名称</strong>字段为真时，才会更新<strong class="ky ir">名称</strong>字段。</p><p id="e339" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢<a class="nh ni ep" href="https://medium.com/u/9644bc03a055?source=post_page-----c765d571b9e7--------------------------------" rel="noopener" target="_blank"> Brandur </a>关于sqlc和Postgres 的<a class="ae kv" href="https://brandur.org/sqlc" rel="noopener ugc nofollow" target="_blank">好文章。</a></p><h1 id="96ba" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">生成Go代码</h1><p id="abee" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">首先，我们需要配置sqlc:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">sqlc.yaml</p></figure><p id="e4e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们配置<code class="fe nj nk nl nm b">sqlc</code>来产生Postgres兼容的代码。我们还为生成的代码指定了模式和查询文件、输出路径和包名。我们的项目结构如下所示:</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="7571" class="nr mh iq nm b gy ns nt l nu nv">├── sql<br/>│   ├── queries.sql<br/>│   └── schema.sql<br/>└── sqlc.yaml</span></pre><p id="35b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以通过运行以下命令来生成代码:</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="efdf" class="nr mh iq nm b gy ns nt l nu nv">sqlc generate</span></pre><p id="e0d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它生成以下文件:</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="7b10" class="nr mh iq nm b gy ns nt l nu nv">├── <strong class="nm ir">internal</strong><br/>│   └── <strong class="nm ir">database</strong><br/>│       ├── <strong class="nm ir">db.go</strong><br/>│       ├── <strong class="nm ir">models.go</strong><br/>│       └── <strong class="nm ir">queries.sql.go</strong><br/>├── sql<br/>│   ├── queries.sql<br/>│   └── schema.sql<br/>└── sqlc.yaml</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">models.go</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">query . SQL . go</p></figure><p id="4a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在标题中看到的，这段代码不能手动编辑。如果需要修改任何内容，必须在<em class="ng"> schema.sql </em>或<em class="ng"> queries.sql </em>文件中完成。您还可以更改<em class="ng"> sqlc.yaml </em>配置来调整代码生成参数。</p><h1 id="688c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用生成的代码</h1><p id="9e9a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">sqlc生成的代码依赖于Go标准库SQL抽象。这意味着我们需要使用适当的Go SQL驱动程序来实例化到数据库的连接。以下文件就是这样做的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">postgres.go</p></figure><p id="582a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以实例化我们的Postgres数据库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">main.go</p></figure><h1 id="ff2f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">下一步是什么？</h1><p id="0d30" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在我们已经完成了我们的数据库实现，我们将看看如何实现我们的REST API。</p></div></div>    
</body>
</html>