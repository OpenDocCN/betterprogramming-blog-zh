<html>
<head>
<title>Inspecting Properties of Callables With Function Traits in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中用函数特征检验可调用函数的性质</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/inspecting-properties-of-callables-with-function-traits-in-c-6bb2d9388fc5?source=collection_archive---------7-----------------------#2021-12-02">https://betterprogramming.pub/inspecting-properties-of-callables-with-function-traits-in-c-6bb2d9388fc5?source=collection_archive---------7-----------------------#2021-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="17f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解我们如何检查可调用的属性来提高代码的抽象层次</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ed3cb49d8b83e53c17cca4e9de3561df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2zZeWvgZKMF_hIcv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">福蒂斯·福托普洛斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="7ba5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">模板元编程</h1><h2 id="a467" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">概观</h2><p id="2d67" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">C++中的模板元编程(TMP)是一种在编译时使用模板执行计算的技术。这种技术可以被认为是用类型编程来生成源代码。没错，就是编码生成代码。</p><p id="ec3b" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这种技术主要用于库，使它们通用。这是一个非常广泛和复杂的主题，但是理解基础知识和常用技术对于普通开发人员提高代码的抽象级别是非常重要的。</p><p id="35a6" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我知道TMP可以做很多事情，但是在本文中我们需要知道的是，模板元编程允许我们在编译时获取类型、值和操作类型。让我们看一些例子。</p><p id="f3a8" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们可以通过使用<code class="fe ne nf ng nh b">std::is_integral</code>来检查一个类型是否是整型。在下面的代码中，我们希望有一个仅适用于整型的<code class="fe ne nf ng nh b">print()</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f62f" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">当我们向它传递非整数类型时，例如，<code class="fe ne nf ng nh b">print(1.5)</code>,我们会得到一个类似这样的编译错误:</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="635e" class="lr la it nh b gy no np l nq nr">error: static assertion failed: print() only supports integral type</span></pre><p id="dd85" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">另一个例子是当我们想要修改一个类型时，比如从一个变量中删除一个<code class="fe ne nf ng nh b">const</code>限定符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0717" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">变量<code class="fe ne nf ng nh b">x</code>是一个带有<code class="fe ne nf ng nh b">const</code>限定符的变量。我们可以通过使用<code class="fe ne nf ng nh b">std::remove_const</code>来移除它的<code class="fe ne nf ng nh b">const</code>限定符。上面的代码打印出来:</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="7798" class="lr la it nh b gy no np l nq nr">1<br/>0</span></pre><p id="2191" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">第<code class="fe ne nf ng nh b">4</code>行在编译时被计算以产生一个<code class="fe ne nf ng nh b">int</code>，没有<code class="fe ne nf ng nh b">const</code>限定符，所以第<code class="fe ne nf ng nh b">5</code>行是<code class="fe ne nf ng nh b">int y = 2;</code>。<code class="fe ne nf ng nh b">std::is_const</code>是TMP实现的另一个例子，如果变量有一个<code class="fe ne nf ng nh b">const</code>限定符，则返回<code class="fe ne nf ng nh b">true</code>，否则返回<code class="fe ne nf ng nh b">false</code>。</p><p id="4aac" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">需要注意的重要一点是，我们使用<code class="fe ne nf ng nh b">::value</code>从类模板中获取值，使用<code class="fe ne nf ng nh b">::type</code>获取可以修改或不修改的类型，这取决于我们使用的类模板。</p><h2 id="f9d7" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">可变模板</h2><p id="3d4b" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">与我们的主题相关的另一个重要概念是变量模板，我们将在这里简要讨论它。顾名思义，可变模板是一种接受可变数量参数的模板。</p><p id="06f9" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">如果你懂C编程语言，你应该知道<code class="fe ne nf ng nh b">printf()</code>可以接受任意数量的参数。为了拥有可变数量的参数，我们可以在声明函数时使用省略号<code class="fe ne nf ng nh b">…</code>。我们来看看<code class="fe ne nf ng nh b">printf()</code>是怎么申报的:</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="3f9c" class="lr la it nh b gy no np l nq nr">void printf(const char *fmt, …);<!-- --> </span></pre><p id="1c51" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">省略号告诉编译器这个函数可以接受任意数量的参数。</p><p id="4007" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">模板也可以有任意数量的参数，它们被称为可变模板。使用省略号，我们可以告诉编译器我们的模板可以接受<strong class="mi iu"> <em class="ns">零</em> </strong>或者更多的参数。现在让我们看一些例子和它们的可视化来帮助理解可变模板是如何工作的。</p><h2 id="f104" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">可变函数模板</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="97bd" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ne nf ng nh b">print()</code>函数接受任意数量的参数，如果它们有一个重载的<code class="fe ne nf ng nh b">&lt;&lt;</code>操作符来支持输出流的打印，就打印出来。幕后发生的是，当我们编译这段代码时，编译器为我们生成了一堆函数。</p><p id="2a90" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">当编译器读取第<code class="fe ne nf ng nh b">16</code>行时，它生成以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="753a" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">注意第<code class="fe ne nf ng nh b">11</code>行的<code class="fe ne nf ng nh b">args…</code>语法将参数列表扩展为<code class="fe ne nf ng nh b">(t2, t3)</code>。然后编译器继续生成我们在函数体中调用的两个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6b94" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这个过程继续进行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="94df" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们现在知道它是如何工作的了。一些要点是:</p><ul class=""><li id="b0fc" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated"><code class="fe ne nf ng nh b">typename… Args</code>转换为类型列表，如<code class="fe ne nf ng nh b">&lt;double, char const*&gt;</code></li><li id="b2fa" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ne nf ng nh b">Args… args</code>转换为类型和名称，如<code class="fe ne nf ng nh b">(double t1, char const* t2)</code></li><li id="55f8" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ne nf ng nh b">args…</code>转换为名称，如<code class="fe ne nf ng nh b">(t1, t2)</code></li></ul><h2 id="47c0" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">可变类模板</h2><p id="cc3e" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我们可以对类模板做同样的事情，我们可以使用省略号<code class="fe ne nf ng nh b">…</code>告诉编译器我们的类模板接受<strong class="mi iu"> <em class="ns">零个</em> </strong>或更多的模板参数。演示可变类模板最常见的例子是通过实现一个元组。元组是不可变的数据结构，可以包含不同类型的数据(异构的)。在C++中，<code class="fe ne nf ng nh b">std::tuple</code>可以认为是<code class="fe ne nf ng nh b">std::pair</code>的泛化。</p><p id="55b2" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">让我们看看如何用可变类模板在C++中实现元组的简化版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2009" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们有两个类模板，一个是主模板，另一个是它的部分专门化。就像在可变函数模板中一样，我们使用递归来实现元组。在第<code class="fe ne nf ng nh b">19</code>行发生了什么，编译器生成如下的类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e795" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">通过递归，编译器为我们生成了三个类。下面的类图显示了这些类之间的关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bf1f4755934142db6d5d97967dd557fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*zH2cBmPYRlFLpGOIkmC0SQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">元组类图(图片作者提供)</p></figure><p id="b160" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这就是我们的数据在内存中的存储方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/a9fc5d101717a1ca6fcaea4ed072b359.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*He7DXtwpYN1vg9iE7SmIKg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们数据的内存布局(图片由作者提供)</p></figure><p id="34d9" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们可以看到，我们的数据是按照与其声明相反的顺序存储的。这是因为类是如何生成的。我们可以从可变模板中学到很多东西，但是在理解了上面的想法之后，理解我想在本文中讨论的主题，即如何检查可调用的属性，可能就足够了。</p><h1 id="4b3a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">可赎回财产的检查</h1><h2 id="68cf" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">类型特征概述</h2><p id="376d" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">Type Traits是一种使用模板元编程来检查和修改类型属性的技术。在上面的第一部分中，我们看到了一个使用<code class="fe ne nf ng nh b">std::integral</code>的例子，它是type traits的类模板之一。用<code class="fe ne nf ng nh b">std::integral</code>我们可以检查一个变量是否是整型的。</p><h2 id="5d20" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">功能特征</h2><p id="2c15" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">在本文中，我们希望对<strong class="mi iu">调用</strong>做同样的事情。我们希望能够检查一个可调用的。现在可能不太清楚我们为什么要这样做，但是现在，让我们假设让我们的代码更加<strong class="mi iu"> <em class="ns">通用</em> </strong>是有用的。在以后的文章中，我们将在实际例子中使用这种技术。在C++中，我们有各种各样的可调用函数，其中一些是:</p><ul class=""><li id="2378" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated">非成员函数</li><li id="b017" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">成员函数</li><li id="df06" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">函子</li><li id="ac27" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">Lambdas(捕获和无捕获)</li></ul><p id="1c29" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们想要的是将一个callable传递给一个名为<code class="fe ne nf ng nh b">function_traits</code>的类模板，并能够检查以下内容:</p><ul class=""><li id="0108" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated">Arity，参数的数量，0或更多</li><li id="56fd" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">返回类型</li><li id="f830" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">参数类型</li></ul><p id="4881" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们可以使用模板元编程和可变模板来实现这一点。</p><h2 id="21d5" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">接口</h2><p id="4cd7" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我们希望提供三种接口，如下所示:</p><ul class=""><li id="33bc" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated"><code class="fe ne nf ng nh b">function_traits&lt;T&gt;::arity</code></li><li id="c8d8" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ne nf ng nh b">function_traits&lt;T&gt;::result_type</code></li><li id="dd56" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ne nf ng nh b">function_traits&lt;T&gt;::template arg&lt;Index&gt;</code></li></ul><h2 id="23bc" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">课程模板</h2><p id="5cec" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我们想要专门化的主要版本是函数指针，如下面的代码所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d4b1" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">如你所见，这里我们专门化了<code class="fe ne nf ng nh b">ReturnType(*)(Arguments…)</code>，它是一个变量函数指针。当我们传递一个函数指针时，这个版本会工作得很好。</p><p id="fe38" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">对于<code class="fe ne nf ng nh b">result_type</code>，我们可以简单的在<code class="fe ne nf ng nh b">ReturnType</code>上加一个<code class="fe ne nf ng nh b">typedef</code>。对于<code class="fe ne nf ng nh b">arity</code>，我们可以使用<code class="fe ne nf ng nh b">sizeof…</code>运算符来查询一个参数包中元素的数量。此外，我们没有重新发明轮子，而是使用标准库来创建一个可调用参数的<code class="fe ne nf ng nh b">std::tuple</code>对象，并使用<code class="fe ne nf ng nh b">std::tuple_element&lt;Index, std::tuple&lt;Arguments…&gt;::type</code>来获取第Index-th参数的类型。</p><p id="3063" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">接下来，我们添加从这个主版本继承的类模板，以便我们可以将它们转换到主版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="71d2" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">两个版本都是指向成员函数的指针，第一个版本是针对<code class="fe ne nf ng nh b">const</code>成员函数<code class="fe ne nf ng nh b">ReturnType(ClassType::*)(Arguments…) const</code>的，第二个版本是针对非<code class="fe ne nf ng nh b">const</code>成员函数<code class="fe ne nf ng nh b">ReturnType(ClassType::*)(Arguments…)</code>的。我们现在做的是将这两个版本转换成主版本。</p><p id="5e95" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">最后，我们添加主要的类模板，如下面的代码所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="647d" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这个版本接受任何实现<code class="fe ne nf ng nh b">operator()</code>的类型，比如lambdas、functors和<code class="fe ne nf ng nh b">std::function</code>对象。这里发生的是，函数对象类型被转换成指向成员函数的指针。Lambdas将被转换为<code class="fe ne nf ng nh b">const</code>成员函数。</p><p id="4a38" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">下图说明了这些类模板之间的关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/d801ecee7259dfcb577aa846ea7a9fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*xgHzkpe-QnzJx167NMRj0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">功能特征类图(图片由作者提供)</p></figure><h2 id="75b5" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">例子</h2><p id="74b7" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">为了更好地理解它，我们来看一些例子。我们首先创建一个自由函数来打印我们的可调用函数的arity。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="59ae" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">首先，我们可以尝试检查下面的free(非成员)函数的arity。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c7a9" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">当我们调用<code class="fe ne nf ng nh b">print_arity(print);</code>时，编译器将使用主版本<code class="fe ne nf ng nh b">function_traits&lt;void (*)(int, int, int)&gt;::arity</code>直接生成该类，它将打印<code class="fe ne nf ng nh b">3</code>。</p><p id="92f7" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">接下来，我们将使用函子测试它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="34d7" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">当我们创建一个名为<code class="fe ne nf ng nh b">test</code>的<code class="fe ne nf ng nh b">Test</code>实例，并调用<code class="fe ne nf ng nh b">print_arity(test)</code>时，编译器将依次创建以下内容:</p><ul class=""><li id="d8bb" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated"><code class="fe ne nf ng nh b">struct function_traits&lt;Test&gt; : public function_traits&lt;void (Test::*)(int, int)&gt;</code></li><li id="1962" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ne nf ng nh b">function_traits&lt;void (Test::*)(int, int)&gt; : public function_traits&lt;void (*)(int, int)&gt;</code></li><li id="2b98" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ne nf ng nh b">function_traits&lt;void (*)(int, int)&gt;::arity</code></li></ul><p id="cada" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">其中会打印<code class="fe ne nf ng nh b">2</code>。</p><p id="5a76" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">lambdas的结果是相似的，唯一的区别是它将使用指向成员函数的指针的<code class="fe ne nf ng nh b">const</code>版本。例如，我们可以传递一个类似于<code class="fe ne nf ng nh b">print_arity([](const int x){});</code>的lambda，我们的代码将打印<code class="fe ne nf ng nh b">1</code>。</p><h2 id="60e2" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">成员函数</h2><p id="62e6" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我们也可以像在<code class="fe ne nf ng nh b">print_arity(&amp;Test::sum);</code>中那样直接传递成员函数，这将直接使用指向成员函数的指针的<code class="fe ne nf ng nh b">const</code>版本并正确打印<code class="fe ne nf ng nh b">0</code>。</p><p id="6183" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">但是，我们应该注意，它没有计算调用成员函数所需的<code class="fe ne nf ng nh b">this</code>指针。这意味着我们只能检查它，而不能调用它。如果我们想稍后调用它，我们可以使用<code class="fe ne nf ng nh b">std::bind</code>并将其包装在一个<code class="fe ne nf ng nh b">std::function</code>对象中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b265" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ne nf ng nh b">print_arity(f)</code>将正确打印<code class="fe ne nf ng nh b">0</code>，我们可以调用<code class="fe ne nf ng nh b">f()</code>返回<code class="fe ne nf ng nh b">3</code>。</p><p id="f651" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这里是完整的<code class="fe ne nf ng nh b">function_traits</code>代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="686c" class="kz la it bd lb lc or le lf lg os li lj jz ot ka ll kc ou kd ln kf ov kg lp lq bi translated">关键要点</h1><ul class=""><li id="2f5a" class="nt nu it mi b mj mk mm mn lw ow lz ox mc oy my ny nz oa ob bi translated">模板元编程允许我们在编译时执行计算来获取值、类型和操作类型。就是编码生成代码。</li><li id="978c" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">可变模板允许我们处理带有任意数量参数的模板。</li><li id="de6d" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">函数特征可以帮助我们考察可调用函数的性质。我们可以检查返回类型、参数数量和单个参数的类型等属性。</li></ul></div></div>    
</body>
</html>