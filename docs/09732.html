<html>
<head>
<title>Creating Accessible Markups With CSS Display Contents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CSS显示内容创建可访问的标记</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-accessible-markups-with-css-display-contents-9cdba5f1eaa8?source=collection_archive---------9-----------------------#2021-10-04">https://betterprogramming.pub/creating-accessible-markups-with-css-display-contents-9cdba5f1eaa8?source=collection_archive---------9-----------------------#2021-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecf7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用这个CSS特性改进你的HTML标记</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97cd9f4b9fe31d81405d0cf783e774f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLO2FoyPjLf_YkKP3iW4sQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的标题</p></figure><p id="5378" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CSS display属性最常见的用法是定义元素的外部和内部布局。我们最常用的是块、内联元素、flex和grid。</p><p id="9acd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">CSS Display Module Level 3</code>中可以找到<code class="fe lu lv lw lx b">display</code>属性的所有规范。截至2021年9月，一个新的财产<code class="fe lu lv lw lx b">contents</code>可以在那里找到。在那之前很久，它被添加到Firefox中，后来被证明是一个成功的实验。</p><p id="ebfc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是什么？它是如何工作的？它可以投入生产使用了吗？</p><p id="a346" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们将研究为什么这个新功能会改变游戏规则，以及它将如何影响用户和他们的可用性。</p><h1 id="94a2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">它是如何工作的？</h1><p id="01ba" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">让我们首先深入研究CSS规范，以获得正式的定义:</p><blockquote class="mv mw mx"><p id="9277" class="ky kz my la b lb lc ju ld le lf jx lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated">元素本身不生成任何框，但是它的子元素和伪元素仍然生成框，文本也照常运行。出于框生成和布局的目的，元素必须被视为在元素树中被其内容所替换(包括其源文档子元素及其伪元素，如::before和::after伪元素，它们通常在元素的子元素之前/之后生成)。”—<a class="ae nc" href="https://drafts.csswg.org/css-display/#valdef-display-contents" rel="noopener ugc nofollow" target="_blank">csswg.org</a></p></blockquote><p id="3adf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">TL；DR: </strong>通过使用<code class="fe lu lv lw lx b">display: contents</code>元素不会产生一个特定的盒子。相反，它会将其伪框和子框替换为其父框的子框。</p><p id="9965" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">contents</code>之前，只有一个选项可以控制一个元素是否会生成任何盒子:<code class="fe lu lv lw lx b">display: none</code>。使用它意味着元素及其后代不会生成框或文本串。</p><h2 id="1baf" class="nd lz it bd ma ne nf dn me ng nh dp mi lh ni nj mk ll nk nl mm lp nm nn mo no bi translated">基本行为</h2><p id="25fa" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">为了更好地理解这个新的显示属性值，让我们从一个简单的例子开始。我们将通过将这个新的显示应用到一个具有填充和背景色的div来显示结果。</p><p id="d2d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4a69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它输出以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ecb0906dff6e63b6c4a30224ab21055c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*VaDsi6tWSbmW10hz2NRL2g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上面代码的布局结果</p></figure><p id="572f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们将显示修改为<code class="fe lu lv lw lx b">contents</code>，就像这样:</p><pre class="kj kk kl km gt ns lx nt nu aw nv bi"><span id="6759" class="nd lz it lx b gy nw nx l ny nz">.content {<br/>  <strong class="lx iu">display: contents;</strong><br/>  background: #ff555e;<br/>  padding: 2rem;<br/>}</span></pre><p id="9633" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/dd98abe9b91b17fa8b7ac587e4ced531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*KXp5HN5icnNMHoV-c-Fvbw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上面代码的布局结果与显示内容</p></figure><p id="a287" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">属于<code class="fe lu lv lw lx b">.content</code>的填充和颜色。为什么？因为<code class="fe lu lv lw lx b">.content</code>是不渲染的，它的子节点是直接作为<code class="fe lu lv lw lx b">.container</code>的子节点放置的。</p><h2 id="601c" class="nd lz it bd ma ne nf dn me ng nh dp mi lh ni nj mk ll nk nl mm lp nm nn mo no bi translated">伪元素和事件是如何受到影响的？</h2><p id="da02" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">在前面的例子中，我们已经看到了元素是如何从布局中消失的。但是它仍然会出现在标记中。这对它的事件和伪类有什么影响？</p><ul class=""><li id="678e" class="ob oc it la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated"><strong class="la iu">伪元素</strong>:不受影响。它们将按预期工作，因为它们对div的内容有影响，而对布局没有影响。</li><li id="7840" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><strong class="la iu">状态事件</strong> : <strong class="la iu"> </strong>不配合显示内容。因为div不会被渲染，所以它们没有任何效果。像hover这样的伪类不会有什么影响。</li><li id="e2fb" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><strong class="la iu">事件点击</strong>:即使元素没有被渲染，它仍然存在于DOM中。可以绑定事件，因为它们将传播到它们的子节点。如前所述，标记仍然存在于DOM中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="bb73" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">它闪耀在哪里？</h1><p id="3612" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">第一个例子并不令人印象深刻。好像都不值得。它不是为那个特定的场景准备的。<code class="fe lu lv lw lx b">display: contents</code>是为了与Flex和Grid结合使用。为什么？</p><p id="714d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那两个布局刚好能作用在一级子上。现在有了显示内容，我们可以让子节点成为Flex/Grid布局的一部分。</p><p id="2add" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6c5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c9f3d9079a92b3b6eba05596299dbf50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkOqjmFdFprKfuEU1vKW3A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上面代码的布局结果</p></figure><p id="5bca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意所有的<code class="fe lu lv lw lx b">.element</code> div是如何参与flex布局的，即使它们不是<code class="fe lu lv lw lx b">.container</code>的第一级子元素。</p><p id="f937" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">⚠️不要搞错了，这不是子网格的替代物。这一特征服务于完全不同的目的。</p><h1 id="5ea1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">为什么重要？</h1><p id="e324" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">所以我们看到了它是如何工作的，但不知道为什么。为什么不删除这个父元素呢？布局结果将是相同的。这到底是怎么回事？这都是关于HTML语义标记的。</p><p id="10c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们之前看到的，Grid和Flex只能与第一层的子节点交互。这种限制的问题在于它规定了我们的语义HTML。布局约束迫使我们产生可读性较差的HTML代码。这最终会损害设备的可访问性。为什么？</p><p id="e4c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">HTML标记被转换成DOM树。然后，浏览器基于此创建一个可访问性树。特定于平台的可访问性API使用该树为需要辅助技术的用户提供更好的体验。产生一个清晰而全面的标记意味着浏览器能够更好地帮助用户。</p><p id="03dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如何检查呢？您可以访问<code class="fe lu lv lw lx b">developers tools &gt; Elements &gt; Accessibility</code> Chrome开发工具中的可访问性选项。让我们来看看谷歌的输入搜索是什么样子的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/93c11ae78599350c73a9a0f3172b77fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*rSJDDm-4kBmCowbLIQQCMw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查谷歌输入搜索输入文本的标题</p></figure><p id="2716" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看我们的标记是如何改进的。我们现在能够从这一点出发:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="988d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到这个更正确的标记:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0716" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将列表包装在一个<code class="fe lu lv lw lx b">&lt;ul&gt;</code>标签中，这比我们的第一次尝试在语义上更加正确。我们的CSS Flex/Grid布局不再限制我们的标记。</p><h1 id="8e5c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">CSS对它的支持是什么？</h1><p id="e904" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">下面我们可以看到当前支持的截图。只有<code class="fe lu lv lw lx b">70%</code>完全支持和<code class="fe lu lv lw lx b">23%</code>部分支持，说明它的支持度有点低。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/9743f4727f09ad8880ac73b37d14fa69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F689gfVv-S0P5sKucksRYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">caniuse.com</p></figure><p id="5993" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是什么意思？这应该被认为是一个渐进的增强。我们仍然应该预见到浏览器可能不会实现这个特性并提供一个后备。像<code class="fe lu lv lw lx b">CSS Supports</code>这样的工具可以帮助我们根据可用的功能定制用户体验。</p><h1 id="579b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">最后的想法</h1><p id="54fb" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我希望这篇文章能帮助您看到这个特性的价值。它帮助我们将标记从布局的限制中解放出来。多年来，我们一直面临这些限制的困扰。</p><p id="9cc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们不应该忽视可及性。这是一个应该得到更多关注的重要话题。我们有责任让我们的内容达到最大化。</p><p id="d4f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯。如果你喜欢你所读到的，看看下面这个故事:</p><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/mastering-css-before-and-after-ecf1d59d9a3d"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">掌握CSS ::before和::after</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">深入研究CSS中的::before和::after伪元素</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">better编程. pub</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>