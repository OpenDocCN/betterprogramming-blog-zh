<html>
<head>
<title>Deep Linking &amp; Push Notifications in React Native with Pusher Beams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native中的深度链接和推送通知与推送波束</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deep-linking-push-notifications-in-react-native-with-pusher-beams-23525ede30da?source=collection_archive---------5-----------------------#2019-06-04">https://betterprogramming.pub/deep-linking-push-notifications-in-react-native-with-pusher-beams-23525ede30da?source=collection_archive---------5-----------------------#2019-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dbe4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建、添加和测试推送通知</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5e1c2d2e55cbc3af7efb4f10c8fb36b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NprnzIlcl4QcBNFc0NpzxA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">免费图片来自<a class="ae kv" href="https://www.pexels.com/photo/white-apple-iphone-on-wooden-table-48605/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/white-apple-iphone-on-wood-table-48605/</a></p></figure><p id="a4b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Zept，我们努力帮助成千上万来自世界各地的合格的外国学生找到加拿大的大学和学院，不仅满足他们的需求，而且最有可能接受他们。对于我们的目标人群来说，电子邮件并不能解决问题，事实证明，短信也不可靠。推送通知是我们的最佳选择。</p><p id="b102" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要向学生发送学校的最新信息，并在大学招聘人员联系他们时通知他们。为此，我们使用<a class="ae kv" href="https://pusher.com/beams" rel="noopener ugc nofollow" target="_blank">推杆梁</a>。</p><p id="7f6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经为websockets使用了Pusher，所以使用Beams进行推送通知(PN)应该不会很难，对吧？</p><p id="83f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个艰难的旅程，但这里是我们如何让它工作</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/2dc9f0b394e726c5c321f1e956d56150.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*KuRF9HX_A5MRyfdbcLDDLA.gif"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="182f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">向您的应用程序添加深度链接</h1><p id="2b27" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了让PN跨两个平台工作，我们发现我们需要建立深度链接。有许多关于如何正确做到这一点的指南；这是一个节略部分。</p><h2 id="723c" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">深度链接？</h2><p id="c77d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我假设你明白什么是深度链接，但快速回顾一下:深度链接是设置你的应用程序来拦截来自你的网站的真实网址，并在应用程序中处理它们。例如，“https://test.com/message/abc”应打开应用程序以发送消息“abc”。</p><p id="7573" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">清楚了吗？如果没有，请在此阅读更多内容:</p><div class="nj nk gp gr nl nm"><a href="https://medium.com/react-native-training/deep-linking-your-react-native-app-d87c39a1ad5e" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">深度链接您的React原生应用</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">在这篇文章中，我将快速介绍如何使用……</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kp nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://hackernoon.com/react-native-deep-linking-for-ios-and-android-d33abfba7ef3" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">反应iOS和Android的原生深度链接</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">我们生活在一个万物互联的新时代，我们比以前更频繁地分享链接。我们也希望我们的客户…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">hackernoon.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa kp nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://facebook.github.io/react-native/docs/linking" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">链接本地反应</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">本节仅适用于使用react-native init或expo init或Create React…创建的项目</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">facebook.github.io</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa kp nm"/></div></div></a></div><h2 id="fc72" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">为什么推送通知需要深度链接</h2><p id="a475" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在发布时，推送包不能将来自推送通知的有效负载发送到代码的JavaScript部分。在添加之前，我们决定确保PN打开应用程序正确部分的最简单方法是<a class="ae kv" href="https://github.com/pusher/push-notifications-android/pull/76" rel="noopener ugc nofollow" target="_blank">利用深度链接</a>。</p><p id="642c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Android，我们将随PN发送一个链接，该链接将被视为深度链接点击，并将用户发送到应用程序的正确部分。</p><h2 id="e8e3" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">创建<code class="fe od oe of og b">.well-known</code>文件夹和相关文件</h2><p id="0680" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">要建立深度链接，你需要在你的网站根目录下创建一个名为<code class="fe od oe of og b">/.well-known/</code>的文件夹，并添加<code class="fe od oe of og b">/.well-known/assetlinks.json</code>文件。对于Android，像这样:</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="663e" class="mx mb iq og b gy ol om l on oo">[{<br/>    "relation": ["delegate_permission/common.handle_all_urls"],<br/>    "target": {<br/>        "namespace": "android_app",<br/>        "package_name": "package_name",<br/>        "sha256_cert_fingerprints":<br/>        ["package_cert_fingerprint"]<br/>    }<br/>}]</span></pre><p id="ab66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为iOS创建一个<code class="fe od oe of og b">/.well-known/apple-app-site-association</code>文件，像这样:</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="c257" class="mx mb iq og b gy ol om l on oo">{<br/>    "applinks": {<br/>        "apps": [],<br/>        "details": [<br/>            {<br/>                "appID": "appId",<br/>                "paths": [ "/paths-you-want-to-support", "/messenger"]<br/>            }<br/>        ]<br/>    }<br/>}</span></pre><h2 id="b792" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">向iOS添加深度链接</h2><p id="088b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">将授权添加到XCode，以便iOS知道哪些域要连接到您的应用程序。</p><p id="951a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到<strong class="ky ir">功能</strong> &gt; <strong class="ky ir">关联域，</strong>并添加您想要连接到您的应用程序的域。你需要打开它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/c72ac4a38babcbd310b01306d1224fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FszKII8iP7x_fMaMgppD9g.png"/></div></div></figure><h2 id="1a9f" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">向Android添加深度链接</h2><p id="d7b3" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">你现在需要给<code class="fe od oe of og b">AndroidManifest.xml</code>添加意图过滤器来处理你在Android中的深层链接。</p><p id="acff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个如何设置你的清单文件来处理<code class="fe od oe of og b">/messenger/*</code>链接的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/b0b65f9c2ba8721d299491d48ffc5026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*f84q1qB-YGD6iYMR-8pK5g.png"/></div></figure><h2 id="8484" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">在你的代码中处理深度链接</h2><p id="5c59" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了处理链接，我在我的根组件中使用了下面的代码版本来设置监听器并处理深度链接中发送的初始加载URL。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="f893" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍后我将介绍<code class="fe od oe of og b">handleDeepLink</code>功能。现在，你可以简单地使用<code class="fe od oe of og b">console.log</code>和<code class="fe od oe of og b">url</code>。</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="438b" class="mx mb iq og b gy ol om l on oo">const handleDeepLink = (url: string) =&gt; console.log(url);</span></pre><h2 id="9914" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">测试深度链接</h2><p id="417b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了测试这些链接，我在我的测试设备上安装了<a class="ae kv" href="https://slack.com" rel="noopener ugc nofollow" target="_blank"> Slack </a>应用程序，并给自己发了一个链接。然后，为了进行测试，我简单地点击了设备上的那个链接，看看它是否能在正确的应用程序中使用正确的URL<code class="fe od oe of og b">console.log</code>打开。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="4ec6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">为您的应用程序添加Pusher Beams推送通知</h1><h2 id="dd62" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">先决条件</h2><ul class=""><li id="0350" class="ot ou iq ky b kz ms lc mt lf ov lj ow ln ox lr oy oz pa pb bi translated">创建一个Pusher Beams帐户，并按照他们的说明设置苹果和谷歌Firebase服务</li></ul><p id="b4fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pc">注意:我们调整了react-native-pusher-push-notifications包。Pusher不支持这个包，他们目前也没有官方的React原生包</em></p><p id="cf20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这一点，我们使用第三方，非官方的包来连接Pusher的推送通知包，以反应我们已经稍微调整的本地工作。</p><p id="fcd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，有哪些调整呢？</p><p id="da77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在Android中使用推送通知(PN)，我们制作了Pusher的推送通知-android包<a class="ae kv" href="https://github.com/ZeptInc/push-notifications-android/releases/tag/1.5.0-alpha" rel="noopener ugc nofollow" target="_blank">的一个分支，用于处理深度链接</a>。特别感谢埃米尔·卡尔松，他做了很多繁重的工作。</p><h2 id="5e46" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">为iOS安装Pusher的Swift包</h2><p id="e7b9" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们使用<a class="ae kv" href="https://github.com/Carthage/Carthage" rel="noopener ugc nofollow" target="_blank"> Carthage </a>来添加这种依赖性。只需将下面的代码添加到您的<code class="fe od oe of og b">/ios/Cartfile</code>文件中。然后运行<code class="fe od oe of og b">carthage bootstrap</code>安装。</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="1d58" class="mx mb iq og b gy ol om l on oo">github "pusher/push-notifications-swift" ~&gt; 1.3.0</span></pre><h2 id="9204" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">按照iOS和Android的说明安装软件包</h2><p id="1ebf" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">遵循此处的<strong class="ky ir">手册</strong>说明:</p><div class="nj nk gp gr nl nm"><a href="https://github.com/ZeptInc/react-native-pusher-push-notifications/tree/v.2.4.0-zept-master" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">ZeptInc/react-本机推送通知</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">在Javascript中管理推送兴趣订阅和通知事件。…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="pd l nx ny nz nv oa kp nm"/></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="654d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">为用户订阅梁/兴趣</h1><p id="8fc5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在我们已经连接到推送Beams，我们需要在我们的应用程序中初始化Beams，并为用户订阅<code class="fe od oe of og b">interests </code>，这样我们就可以向他们发送消息。</p><p id="c27c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Zept使用了<a class="ae kv" href="https://github.com/redux-observable/redux-observable" rel="noopener ugc nofollow" target="_blank"> Redux Observables </a>，所以我们有了一个用户一登录就触发的epic。它设置他们的推送订阅，当用户注销时，另一个单独的用户取消订阅。</p><p id="1cac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为用户订阅了几个公共的<code class="fe od oe of og b">interests.</code>,每个用户都有一个由我们的服务器提供的自定义兴趣代码(例如<code class="fe od oe of og b">user-{userId}</code>)让我们可以给他们发送个性化的内容。</p><p id="1273" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们的<code class="fe od oe of og b">util </code>文件的代码示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="55a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，默认情况下，用户每次登录时都会订阅<code class="fe od oe of og b">general</code>和<code class="fe od oe of og b">user-{user.id}</code>。这一部分可能需要修改以满足您的需求。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c424" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">测试推送通知</h1><p id="106f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><em class="pc">注意:iOS通知仅适用于物理设备。它们不能在模拟器上工作。</em></p><p id="88f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用Pusher的调试控制台(登录后可用)或使用<a class="ae kv" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>。我更喜欢邮递员。这是一个示例负载:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="65f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你的应用设置正确，iOS应该处理推送通知负载，Android应该打开一个带有你的网站URL的<code class="fe od oe of og b">View intent</code>。两者都应该记录一条控制台消息<code class="fe od oe of og b">https://yourdomain/messenger/abcde</code>。</p><p id="9006" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在iOS上，这种推送通知应该在你的应用程序图标上添加一个徽章，上面写着<strong class="ky ir"> 5 </strong>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f5d3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">处理深层链接</h1><p id="3a20" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">最后一步是处理深层链接。在Zept，我们在网站上使用React-Router，在React Native中使用React-Navigation。我们希望尽可能多地重用代码，并防止URL更改破坏未来的代码。因此，我们编写了一个<code class="fe od oe of og b">util </code>函数来帮助我们在web中连接我们的路线，并做出本地反应，并且(希望)防止未来出现意外。</p><p id="142b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在网络和本地路由中使用常量。例如:</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="0637" class="mx mb iq og b gy ol om l on oo"><em class="pc">// Web:</em><br/>ROUTE = {<br/>    MESSENGER_CONVERSATION: (conversationId?: <strong class="og ir">string</strong>) =&gt;<br/>        conversationId<br/>            ? `/messenger/${conversationId}`<br/>            : "/messenger/:conversationId"<br/>}</span><span id="9a6f" class="mx mb iq og b gy pe om l on oo"><em class="pc">// Native: </em><br/>APP_STACK_ROUTE: {<br/>    MESSENGER_CONVERSATION_SCREEN:<br/>        "app_stack_routes/messenger_conversation"<br/>}<br/>// native then has a params object with conversationId included</span></pre><p id="7136" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我希望能够将它们相互匹配/连接起来，就像这样:</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="c313" class="mx mb iq og b gy ol om l on oo"><strong class="og ir">const </strong>ROUTE_MATCHES: IRouteMatches = [<br/>    {<br/>        webPath: ROUTE.MESSENGER_CONVERSATION(),<br/>        rnPath: APP_STACK_ROUTES.MESSENGER_CONVERSATION_SCREEN<br/>    }<br/>];</span></pre><p id="c60c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我写了一个函数，它将接受我的<code class="fe od oe of og b">ROUTE_MATCHES</code>并自动进行转换。</p><h2 id="d8bf" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">去抖<code class="fe od oe of og b">handleDeepLink</code>功能</h2><p id="27df" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我用<code class="fe od oe of og b">rxjs </code>去抖<code class="fe od oe of og b">handleDeepLink</code>，因为我发现它偶尔会发射多次。</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="79fc" class="mx mb iq og b gy ol om l on oo"><strong class="og ir">export const </strong>handleDeepLink = (url: <strong class="og ir">string</strong>): <strong class="og ir">void </strong>=&gt; {<br/>    <strong class="og ir">if </strong>(!url) <strong class="og ir">return</strong>;<br/>    onChangeUrl$.next(url);<br/>};<br/><strong class="og ir">const </strong>onChangeUrl$: Subject&lt;<strong class="og ir">string</strong>&gt; = <strong class="og ir">new </strong>Subject&lt;<strong class="og ir">string</strong>&gt;();<br/><strong class="og ir">const </strong>urlSubscription: Observable&lt;<strong class="og ir">string</strong>&gt; = onChangeUrl$.pipe(debounceTime(100));<br/>urlSubscription.subscribe(processUrl);</span></pre><h2 id="2d5f" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">处理URL</h2><p id="8031" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">第一步是使用<a class="ae kv" href="https://regexr.com/" rel="noopener ugc nofollow" target="_blank"> regex </a>将URL分解成基本部分；<code class="fe od oe of og b">protocol</code>、<code class="fe od oe of og b">tld</code>、<code class="fe od oe of og b">path,</code>和<code class="fe od oe of og b">querystring.</code></p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="d679" class="mx mb iq og b gy ol om l on oo"><strong class="og ir">const </strong>REGEX_DECONSTRUCT_URL = /^(.*?):\/\/(.*?)(\/.*?)(\?(.*))?$/;</span><span id="ef89" class="mx mb iq og b gy pe om l on oo"><strong class="og ir">const </strong>deconstructedUrl = REGEX_DECONSTRUCT_URL.exec(url);<br/>    <strong class="og ir">if </strong>(!deconstructedUrl) <strong class="og ir">return</strong>;<br/>    <strong class="og ir">const </strong>[originalUrl, protocol, tld, path, ignore, querystring] = deconstructedUrl;</span></pre><p id="404c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以循环遍历路径，直到找到一个与上面的<code class="fe od oe of og b">ROUTE_MATCHES</code>匹配的路径。</p><pre class="kg kh ki kj gt oh og oi oj aw ok bi"><span id="7e08" class="mx mb iq og b gy ol om l on oo"><strong class="og ir">if </strong>(protocol === "https" &amp;&amp; tld.includes("yourdomain")) {<br/>    <strong class="og ir">for </strong>(<strong class="og ir">let </strong>i = 0; i &lt; ROUTE_MATCHES.length; i++) {<br/>        <strong class="og ir">if </strong>(matchPath(ROUTE_MATCHES[i], path, querystring)) {<br/>            // loop until one matches<br/>            <strong class="og ir">break</strong>;<br/>        }<br/>    }<br/>}</span></pre><p id="84b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了匹配到<code class="fe od oe of og b">webPath</code>的路径，我使用了<code class="fe od oe of og b">pathToRegexp</code>(React-Router使用的同一个包)来匹配<code class="fe od oe of og b">webPath</code>模式和<code class="fe od oe of og b">rnPath</code>模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="172a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是最终产品:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="0b29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pc">注意:您可以使用这里的说明创建一个</em><code class="fe od oe of og b"><em class="pc">NavigationService</em></code><em class="pc">:</em></p><div class="nj nk gp gr nl nm"><a href="https://reactnavigation.org/docs/en/navigating-without-navigation-prop.html" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">没有导航属性的导航反应导航</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">调用导航道具上的navigate或popToTop等函数并不是在你的应用中导航的唯一方式…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">reactnavigation.org</p></div></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9a60" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="4503" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">所以现在你的应用应该能够:</p><ol class=""><li id="d927" class="ot ou iq ky b kz la lc ld lf pf lj pg ln ph lr pi oz pa pb bi translated">正确处理来自web应用程序的深层链接，允许您发送电子邮件、短信和其他将在本机应用程序中打开的链接</li><li id="3f9d" class="ot ou iq ky b kz pj lc pk lf pl lj pm ln pn lr pi oz pa pb bi translated">给你的用户发送推送通知，这将会把你的深层链接直接发送给你的应用程序的正确部分。</li></ol><p id="042f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读，我希望这能帮助您改进您的项目。</p></div></div>    
</body>
</html>