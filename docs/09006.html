<html>
<head>
<title>Mastering Function Overloading in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中掌握函数重载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-function-overloading-in-typescript-97108369570a?source=collection_archive---------4-----------------------#2021-07-06">https://betterprogramming.pub/mastering-function-overloading-in-typescript-97108369570a?source=collection_archive---------4-----------------------#2021-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9791" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用重载功能创建更全面、更易读的函数类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ba255bc18dbc10fdc45f8e19c2c5a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fqxtDIjdCUyNyYKn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cebbbinghaus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·罗宾·艾宾浩斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure><p id="18d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何类型语言的背景，你可能熟悉重载的概念。如果不是，让我们快速回顾一下它是什么:</p><blockquote class="lv lw lx"><p id="77cf" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“在某些编程语言中，函数重载或方法重载是指用不同的实现创建多个同名函数的能力。对重载函数的调用将根据调用的上下文运行该函数的特定实现，允许一个函数调用根据上下文执行不同的任务。— <a class="ae ky" href="https://en.wikipedia.org/wiki/Function_overloading" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="0aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个有用的特性。假设Javascript不是类型化的，是否有可能在那里实现它？它的警告是什么？</p><p id="4427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Typescript呢？它本身支持重载吗？它有什么缺陷吗？</p><p id="ebbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将回答这些问题。一旦我们涵盖了所有的基础，我们将看到一些最佳实践。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="0520" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">JavaScript重载</h1><p id="b6f9" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">JavaScript中有可能使用重载吗？不是从严格的角度来说。我们可以设法实现类似重载的东西，但是这种方法有一些缺陷。让我们用一些例子来研究这些。</p><p id="2b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要创建一个可以接受1-3个字符串参数的<code class="fe ng nh ni nj b">concatString</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4c21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来不错。但是如果我们像这样调用这个方法会发生什么呢？</p><pre class="kj kk kl km gt nm nj nn no aw np bi"><span id="d082" class="nq mk it nj b gy nr ns l nt nu">concatString('one', true);</span></pre><p id="8f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法不会崩溃，但会返回不正确的结果。这很容易解决。我们可以检查<code class="fe ng nh ni nj b">typeof</code>参数，只接受字符串。</p><pre class="kj kk kl km gt nm nj nn no aw np bi"><span id="ed06" class="nq mk it nj b gy nr ns l nt nu">if(s2 &amp;&amp; typeof s2 === 'string')</span></pre><p id="ffeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以不同类型的问题就“解决了”如果我们用不同数量的参数调用这个方法呢？这是另一个快速解决方案。我们可以检查<code class="fe ng nh ni nj b">arguments</code>的长度，如果超过了，就返回一个错误。在这种情况下，这将是三个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fbd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要看看这个例子，就很容易理解为什么JavaScript社区已经习惯于忽略重载。方法变得更大，更难阅读，更难维护。错误只在运行时被发现。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="a5b8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">拯救打字稿</h1><p id="8271" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">TypeScript结束了动态编码的混乱。有了类型化的方法，你的函数暴露了什么，返回了什么就很清楚了。它本身支持重载吗？</p><p id="9f02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，它是！然而，它将会以一种与我们习惯的稍微不同的方式。TypeScript只能在编辑和构建时提供帮助。这是因为代码最终会被转换成JavaScript。在运行时，我们将拥有与JavaScript相同的工具。虽然它并不完美，但整理我们的打字应该是相当不错的。</p><p id="78c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重温一下前面的例子。然而，这个非常简单，我们不需要使用任何重载语法。我们只需将参数声明为可选的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将修饰符与类型结合起来，我们能够表达大量的签名契约。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ee4d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">更复杂的情况</h1><p id="6ce3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果我们想做一些更具体的事情呢？假设我们想基于参数返回一个不同的类型。仅仅用上面提到的技术我们不可能做到这一点。</p><p id="a7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的方法中，返回的类型将是<code class="fe ng nh ni nj b">string | number</code>。Typescript将推断可能的返回类型，并使用联合语法将它们连接起来。</p><p id="3949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过查看该方法，我们可以看到，如果参数是一个<code class="fe ng nh ni nj b">string</code>，它将返回一个<code class="fe ng nh ni nj b">string</code>。否则，它将返回一个<code class="fe ng nh ni nj b">number</code>。如果我们想用更具体的类型来表达呢？我们可以使用重载语法将参数的类型映射到返回类型。</p><p id="9fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="29a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们向函数传递一个<code class="fe ng nh ni nj b">string</code>时，我们将得到一个<code class="fe ng nh ni nj b">string</code>类型。当没有参数时，返回的类型将是<code class="fe ng nh ni nj b">number</code>。</p><p id="678c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种语法是如何工作的？</p><ul class=""><li id="8296" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><code class="fe ng nh ni nj b">function helloWorld(): number</code>:这是第一次过载。</li><li id="ca8a" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">这是我们第二次超载了。</li><li id="a737" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">这是我们的基本功能。它需要容纳前面声明的所有可能的重载。它需要符合上面声明的所有返回类型。在这种情况下，我们的返回类型是推断出来的，它是<code class="fe ng nh ni nj b">string | number</code>。</li></ul><p id="cab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用不兼容的返回类型会发生什么？TypeScript无法编译。它将显示一个错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解声明重载的顺序很重要，这一点很重要。基函数必须是最后声明的函数。让我们检查一下TypeScript文档以了解更多信息:</p><blockquote class="lv lw lx"><p id="0aa1" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">为了让编译器选择正确的类型检查，它遵循与底层JavaScript类似的过程。它查看重载列表，并从第一个重载开始，尝试用提供的参数调用函数。如果找到匹配项，它会选择该重载作为正确的重载。因此，习惯上从最具体到最不具体对重载进行排序。— <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/functions.html" rel="noopener ugc nofollow" target="_blank">打字稿文件</a></p></blockquote><p id="7f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过颠倒工作示例中重载方法声明的顺序来证明这一点。这会给我们带来大量的错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="353a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从文档中可以看出，顺序应该是从限制性更强到限制性更弱。我们之前的基本方法<code class="fe ng nh ni nj b">function helloWorld(s: string): string</code>，是限制性最小的。所以应该是最后一个。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ba15" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">组合多种参数类型</h1><p id="aca0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们已经看到，我们可以根据实参参数改变返回类型。如前所述，我们唯一的限制是基函数必须符合所有的类型变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe ng nh ni nj b">arg1</code>和<code class="fe ng nh ni nj b">arg2</code>必须是<code class="fe ng nh ni nj b">string | number</code>类型，以符合前面重载中描述的可能类型。一旦你掌握了它，它就是直观的。</p><p id="ac56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">⚠️:有一个小警告要记住。TypeScript将无法根据参数在函数体上推导类型。目前，基方法不知道它的重载声明。这意味着即使您在函数体中检查到<code class="fe ng nh ni nj b">arg1</code>是一个字符串，Typescript也不会推断出<code class="fe ng nh ni nj b">arg2</code>也应该是一个字符串。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="6a3c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">超载的注意事项</h1><p id="9f50" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在我们已经了解了Typescript重载，让我们看看最常见的注意事项:</p><h2 id="0ebc" class="nq mk it bd ml oj ok dn mp ol om dp mt li on oo mv lm op oq mx lq or os mz ot bi translated">1.避免编写仅尾部参数不同的几个重载</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到两个接口是如何相等的，但是第一个接口比第二个接口更冗长。在这种情况下，最好使用可选参数。</p><h2 id="9a14" class="nq mk it bd ml oj ok dn mp ol om dp mt li on oo mv lm op oq mx lq or os mz ot bi translated">2.避免编写只有一种参数类型不同的重载</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c65b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像前面的例子一样，第一个接口变得非常冗长。最好使用联合。</p><p id="433e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一般的经验法则，尽量保持一切简单。只有当重载语法真正增加了你的契约的价值时，才使用它。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d4fd" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">最后的想法</h1><p id="1ac2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">重载是TypeScript中一个重要而有用的特性。它不应该被滥用。正如我们已经看到的，有时仅仅使用<code class="fe ng nh ni nj b">optional</code>修饰符就足够了。</p><p id="7f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript函数重载将帮助您整理代码。如果使用得当，它会使你的代码更具可读性，更易于维护。它将使你的合同更加丰富和精确。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://ko-fi.com/G2G46F6T3"><div class="gh gi ou"><img src="../Images/98a7abfbf1b720aaad1fdcfc560741f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*p18RBtL68bAWVrQ6G137gA.jpeg"/></div></a></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="0ca9" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">相关文章</h1><div class="ov ow gp gr ox oy"><a rel="noopener  ugc nofollow" target="_blank" href="/top-5-typescript-features-you-should-master-2358db9ab3d5"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">您应该掌握的五大打字稿功能</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">使用这些必须知道的特性来提高您的打字稿知识</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">better编程. pub</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a rel="noopener  ugc nofollow" target="_blank" href="/typescript-a-gentle-introduction-to-mapped-types-f65e45fa2598"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">TypeScript:映射类型的简明介绍</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">学习构建自己的一套TypeScript工具</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">better编程. pub</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ks oy"/></div></div></a></div></div></div>    
</body>
</html>