<html>
<head>
<title>Understand 5 Scopes of Pytest Fixtures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Pytest夹具的5个范围</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-5-scopes-of-pytest-fixtures-1b607b5c19ed?source=collection_archive---------0-----------------------#2020-06-24">https://betterprogramming.pub/understand-5-scopes-of-pytest-fixtures-1b607b5c19ed?source=collection_archive---------0-----------------------#2020-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="81bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python高效地运行您的测试代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb84c976dbf6f3b0b3e6e0228da8730c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R8K8NfsR9I0KlgQS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dtravisphd" rel="noopener ugc nofollow" target="_blank">大卫·特拉维斯</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bf16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python有三个主流的单元测试框架:内置的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">unittest</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://nose.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">nosetests</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.pytest.org/en/stable/" rel="noopener ugc nofollow" target="_blank">pytest</a></code>。根据互联网上许多<a class="ae ky" href="https://www.google.com/search?newwindow=1&amp;safe=active&amp;sxsrf=ALeKk03skdFP02yOonee-FrLmk_-A5N1GA%3A1591645399975&amp;ei=15TeXveFO4G1sAfhkbLgAw&amp;q=the+best+unit+test+framework+for+python&amp;oq=&amp;gs_lcp=CgZwc3ktYWIQARgHMgcIIxDqAhAnMgcIIxDqAhAnMgcIIxDqAhAnMgcIIxDqAhAnMgcIIxDqAhAnMgcIIxDqAhAnMgcIIxDqAhAnMgcIIxDqAhAnMgcIIxDqAhAnMgcIIxDqAhAnOgQIABBHUJDOAViQzgFg1uUBaAFwA3gAgAEAiAEAkgEAmAEAoAEBqgEHZ3dzLXdperABCg&amp;sclient=psy-ab" rel="noopener ugc nofollow" target="_blank"> <em class="lz">非官方</em>排名</a>，<code class="fe lv lw lx ly b">Pytest</code>是最受欢迎的测试框架，这要归功于它最少的样板文件、丰富的特性和<a class="ae ky" href="https://docs.pytest.org/en/2.7.3/plugins_index/index.html" rel="noopener ugc nofollow" target="_blank">越来越多的插件</a>。</p><p id="8e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Test_fixture" rel="noopener ugc nofollow" target="_blank">测试夹具</a>是在电子和软件中使用的概念。它是一个软件或设备，建立一个系统来满足过程的某些先决条件。它最大的优点是提供了一致的结果，因此测试结果是可重复的。夹具的例子可以是将测试集加载到数据库，读取配置文件，设置环境变量，等等。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a371" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Pytest中的Fixture是什么？</h1><p id="b4f3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">夹具在Pytest中起着相当重要的作用。与通常具有<code class="fe lv lw lx ly b">setup()</code>和<code class="fe lv lw lx ly b">teardown()</code>功能的经典xUnit风格相比，Pytest中的夹具更加灵活和扁平。每个fixture都是在一个函数上使用<code class="fe lv lw lx ly b">@pytest.fixture</code> decorator定义的，这个函数会像读取配置文件一样完成工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/b01368fce447b176b80b9a06451fe5e2" rel="noopener ugc nofollow" target="_blank"> pytest-example.py </a></p></figure><p id="3c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们调用fixture函数的方式不同于我们通常在源代码中所做的。在源代码中，我们调用另一个函数内部的一个函数，然后我们会得到返回对象，像<code class="fe lv lw lx ly b">config = read_config()</code>。</p><p id="6b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在Pytest中，我们可以<em class="lz">使用fixture函数作为测试函数</em>的输入参数，并且该输入参数已经是返回对象。这种行为称为<a class="ae ky" href="https://docs.pytest.org/en/stable/fixture.html#fixtures-a-prime-example-of-dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。我们可以根据需要多次注入fixture函数。</p><p id="3394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是每次注入都会执行一次fixture函数。因此，在下面的例子中，它打开同一个文件两次。</p><p id="884b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有办法控制fixtures的执行，让我们的测试代码更有效率？是的，这就是为什么我们需要理解Pytest fixtures的不同范围。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/25de62736ce0f73bf167d5c141273c0d" rel="noopener ugc nofollow" target="_blank"> pytest-function.py </a></p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="dc37" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Pytest夹具的5个范围</h1><p id="e146" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Pytest fixtures有五个不同的作用域:函数、类、模块、包和会话。范围基本上控制了每个fixture的执行频率。</p><h2 id="0936" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">功能</h2><p id="810d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">函数是默认作用域，没有显式添加<code class="fe lv lw lx ly b">scope="function"</code>。将根据测试功能执行夹具。如果设备只使用一次，或者它包含一个非常简单的操作，或者您每次都想要一个不同的值，那么这个范围就很适用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/dfd023286097e903b7524119891a0f27" rel="noopener ugc nofollow" target="_blank">py test-fixture-function . py</a></p></figure><h2 id="017d" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">班级</h2><p id="d413" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">scope <em class="lz"> </em>类为每个测试类运行fixture。如果你有几个做类似事情的测试函数，比如算术运算或数据库查询，你可以用装饰器<code class="fe lv lw lx ly b">@<a class="ae ky" href="https://docs.pytest.org/en/stable/reference.html#pytest-mark-usefixtures" rel="noopener ugc nofollow" target="_blank">pytest.mark.usefixtures</a>("fixture-name")</code>把它们放在同一个测试类中。这个特殊的装饰器将fixture添加到一个测试类中，fixture将在任何测试函数之前执行。查看下面的日志。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/7ab383bee1bf1f375a66dc8d85ee403c" rel="noopener ugc nofollow" target="_blank">py test-fixture-class . py</a></p></figure><p id="424f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pytest中的<code class="fe lv lw lx ly b">yield</code>语句有一个特殊用法，允许你在所有测试函数之后执行fixture <em class="lz">。<code class="fe lv lw lx ly b">yield</code>之前的代码作为设置代码，<code class="fe lv lw lx ly b">yield</code>之后的代码作为拆卸代码。一个典型的例子是测试数据库。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/c33fb362226637267223dca1f60d38e0" rel="noopener ugc nofollow" target="_blank">py test-fixture-class-db . py</a></p></figure><h2 id="4355" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">模块和封装</h2><p id="6ef3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">到目前为止，您一定已经观察到了这里的模式。因此，作用域模块运行每个模块的fixture，作用域包运行每个包的fixture。范围模块比包使用得更频繁。让我们回到第一个例子，我们有一个打开配置文件的<code class="fe lv lw lx ly b">read_config</code>夹具。这是使用作用域模块或更高作用域的一个很好的用例，因为我们只想打开文件一次，并多次重用配置对象。您可以将下面的日志与<a class="ae ky" href="https://gist.github.com/highsmallxu/25de62736ce0f73bf167d5c141273c0d" rel="noopener ugc nofollow" target="_blank"> pytest-function.py </a>的日志进行比较。你能看出区别吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/f5b0be8eb689c0e78c4d73516f19728e" rel="noopener ugc nofollow" target="_blank">py test-fixture-module . py</a></p></figure><h2 id="650e" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated"><strong class="ak"> <em class="ns">会话</em> </strong></h2><p id="0107" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">最后也是最广泛的作用域是会话。具有作用域会话的装置在每个会话中只执行一次。每次运行<code class="fe lv lw lx ly b">pytest</code>，都被认为是一个会话。作用域会话是为昂贵的操作设计的，例如截断表和将测试集加载到数据库。</p><h2 id="0388" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated"><strong class="ak"> conftest.py </strong></h2><p id="10de" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有了范围函数、类和模块，将fixtures和tests放在同一个文件中是有意义的。但是使用scope session，有一个更好的地方来放置这些设备。这是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.pytest.org/en/2.7.3/plugins.html?highlight=re#conftest-py-local-per-directory-plugins" rel="noopener ugc nofollow" target="_blank">conftest.py</a></code>文件，Pytest的本地每个目录的插件。Pytest将使<code class="fe lv lw lx ly b">conftest.py</code>中的夹具对同一目录中的所有测试<strong class="lb iu">可用。下面的例子是对第一个例子的扩展。</strong></p><p id="800f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">conftest.py</code>中，我们有夹具<code class="fe lv lw lx ly b">read_config</code>和<em class="lz">作用域</em>会话。这个fixture由两个测试文件中的四个测试函数使用。由于<code class="fe lv lw lx ly b">conftest.py</code>中的fixture对于整个目录都是可用的，<em class="lz">我们不需要在测试文件中显式地导入那些fixture，Pytest会为我们做这件事。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/ad3618d0176364e32307360484a03f1b" rel="noopener ugc nofollow" target="_blank">py test-fixture-session . py</a></p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2760" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">自动使用装置</h1><p id="2e37" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">到目前为止，我们不得不使用fixture作为测试函数的输入参数来触发它。但实际上，一个fixture也可以用另一个关键字<code class="fe lv lw lx ly b">autouse=True</code>自动触发。在这个例子中，fixture <code class="fe lv lw lx ly b">function_autouse</code>被自动执行，而没有在任何地方被提及。</p><p id="7091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<code class="fe lv lw lx ly b">autouse=True</code>并不意味着它将是整个比赛中第一个被触发的比赛。还是和它的范围有关:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/b3f2a47380ffeb2ba52935104ca4cfbe" rel="noopener ugc nofollow" target="_blank">py test-fixture-autouse . py</a></p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d986" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">夹具的执行顺序</h1><p id="ea7f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们先记住基本的执行顺序:<em class="lz">会话&gt;包&gt;模块&gt;类&gt;函数。查看下面的日志。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/7096835e696cbc8b119574796ffcb7f1" rel="noopener ugc nofollow" target="_blank">py test-fixture-order . py</a></p></figure><p id="56c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们为每个范围再添加一个带有<code class="fe lv lw lx ly b">autouse=True</code>的夹具，并考虑顺序:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="75ba" class="ng mi it ly b gy nx ny l nz oa">test/test_code1.py::test_order <br/>-------- live log setup --------<br/>INFO     root:test_code1.py:13 scope session with autouse<br/>INFO     root:test_code1.py:8 scope session<br/>INFO     root:test_code1.py:23 scope package with autouse<br/>INFO     root:test_code1.py:18 scope package<br/>INFO     root:test_code1.py:33 scope module with autouse<br/>INFO     root:test_code1.py:28 scope module<br/>INFO     root:test_code1.py:43 scope class with autouse<br/>INFO     root:test_code1.py:38 scope class<br/>INFO     root:test_code1.py:48 scope function with autouse<br/>INFO     root:test_code1.py:53 scope function</span></pre><p id="511b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是你所期望的吗？基本上，该顺序基于两条规则:</p><ul class=""><li id="c64e" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">首先执行更高范围的Fixtures。</li><li id="8eb2" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">带有<code class="fe lv lw lx ly b">autouse=True</code>的fixture在相同范围内的其他fixture之前执行。</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="cf18" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="412d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Pytest fixtures通过使用依赖注入或自动触发(autouse)多次重用相同的对象或相同的函数来提高测试代码的效率。fixture的五个不同范围控制每个fixture的执行频率。fixture的范围越大，fixture执行得越早。</p><p id="a30b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<code class="fe lv lw lx ly b">conftest.py</code>是一个放置带有范围会话的夹具的好地方。它们对整个目录都可用，不需要显式导入。</p><p id="f72b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章！如果你有任何想法，请在下面留下你的评论。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="49f9" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">参考</h1><div class="op oq gp gr or os"><a href="https://docs.pytest.org/en/stable/fixture.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">pytest fixtures:显式、模块化、可扩展——py test文档</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">软件测试夹具初始化测试功能。它们提供了一个固定的基线，这样测试可以可靠地执行，并且…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">docs.pytest.org</p></div></div></div></a></div><div class="op oq gp gr or os"><a href="https://pythontesting.net/framework/pytest/pytest-fixtures/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">pytest fixtures第1部分— Python测试</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">处理夹具是pytest真正出色的领域之一。这是相当难以置信的轻描淡写。的…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">pythontesting.net</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>