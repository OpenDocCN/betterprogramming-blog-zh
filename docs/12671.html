<html>
<head>
<title>Keeping Track of Database Schema Changes Using Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go跟踪数据库模式的变化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/database-migrations-f3a227e29f5f?source=collection_archive---------4-----------------------#2022-06-21">https://betterprogramming.pub/database-migrations-f3a227e29f5f?source=collection_archive---------4-----------------------#2022-06-21</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="00cf" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">帮助您更改数据库的提示</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/b9132b4c15ff2ae9384633b4a1a43bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWeHJi1LoR_IoMvczrBAJw.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">迁移帮助您构建数据库模式</p></figure><h1 id="5895" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">概观</h1><p id="007a" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">您是否想过开发人员如何处理项目数据库模式的变化？当添加新的表/列/索引时，或者当删除表、列或索引时，它们做什么？</p><p id="1810" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">他们如何确保参与项目的每个人都将所有更改应用到他们的数据库中？为此，他们跟踪对数据库模式所做的每次更改的历史。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mp"><img src="../Images/e06601e2a84f9e25bbace6da7b12ff11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRG21vnyguQOtYH0PUzXOQ.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">带有版本控制系统的SQL迁移协议</p></figure><p id="88ef" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">这是我第一次与其他人一起工作时才知道的，我读了该项目的自述文件，并说我必须运行“迁移”来更新我的数据库模式。</p><p id="cfb6" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">这让我问自己:我以前怎么没想过要处理这么明显的事情？嗯，因为我从来没有关掉电脑或重新格式化我的电脑，所以它让我从零开始重新安装整个项目，以意识到我没有办法在没有备份的情况下恢复我的数据库。</p><p id="b869" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">我在本文中的目标是向您展示这种数据库迁移是如何工作的，以便您知道当新的更改应用到数据库时应该做什么，无论您是独自工作还是与其他人一起工作。</p><h1 id="3739" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">它是如何工作的</h1><p id="a3b7" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">它的工作方式很简单，你必须做和你保存项目代码历史时一样的事情。因此，我们需要一个像<a class="ae mq" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> GIT </a>这样的版本控制系统。在那里，我们可以确保参与项目的每个人都可以拥有最新的数据库变更历史。</p><p id="2fb6" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">在这里，我将向您展示处理数据库迁移的两种方法，但是首先，让我们看看它们有什么共同点:</p><p id="3a20" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">您将编写包含SQL的文件，其名称格式如下:<code class="fe mr ms mt mu b">{version}_{description}.{up/down}.{ext}</code></p><p id="8ed5" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">描述可以是对迁移文件用途的简短说明，例如:</p><ol class=""><li id="dafd" class="mv mw ir lq b lr mk lu ml lx mx mb my mf mz mj na nb nc nd bi translated"><code class="fe mr ms mt mu b">create_users_table</code></li><li id="e772" class="mv mw ir lq b lr ne lu nf lx ng mb nh mf ni mj na nb nc nd bi translated"><code class="fe mr ms mt mu b">adds_birthdate_column_to_users_table</code></li><li id="4454" class="mv mw ir lq b lr ne lu nf lx ng mb nh mf ni mj na nb nc nd bi translated"><code class="fe mr ms mt mu b">drops_country_column_from_users_table</code></li></ol><p id="9fb6" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">将更改应用到模式的SQL(称为向上迁移)和反转这些更改的SQL(称为向下迁移)</p><p id="ee7f" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">这就是为什么在前一点中，名称格式指示是向上迁移还是向下迁移</p><p id="6800" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated"><strong class="lq is">注</strong>:有些库管理一个文件，用注释表示<code class="fe mr ms mt mu b">up</code> SQL和<code class="fe mr ms mt mu b">down</code> SQL</p><h2 id="f5c4" class="nj kx ir bd ky nk nl dn lc nm nn dp lg lx no np li mb nq nr lk mf ns nt lm nu bi translated"><strong class="ak">按顺序运行迁移的方法</strong></h2><p id="be45" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">为此，我们利用文件名格式的版本，您可以输入序列号或创建文件时的时间戳，这样当我们运行迁移时，我们将按升序执行它们。这是必要的，因为您可能会添加依赖于要先执行的其他迁移的迁移。</p><h2 id="4333" class="nj kx ir bd ky nk nl dn lc nm nn dp lg lx no np li mb nq nr lk mf ns nt lm nu bi translated"><strong class="ak">确保我们不会运行两次迁移</strong></h2><p id="1388" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">库可能会创建一个表来记录已执行的迁移，这样就不会重复了。</p><p id="cd67" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">文件的扩展名取决于您选择的处理迁移的方法</p><p id="844b" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">它可以是. sql文件或您的编程语言的扩展</p></div><div class="ab cl nv nw hv nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ik il im in io"><p id="d66f" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">现在我们知道了它们的共同点，让我们来看看每种方法的作用。</p><h1 id="7d44" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">纯SQL的迁移</h1><p id="274f" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">在这里，您必须创建一个目录来存储<code class="fe mr ms mt mu b">.sql</code>文件，该文件将包含对数据库模式所做的更改以及撤销这些更改的方法。按照上一节描述的格式，您将得到如下文件:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/0cf5745f1ce328ea8416bbc19d2e0660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*p8CFVx5zQZWb_d577giqBw.png"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">SQL迁移目录树</p></figure><p id="70d8" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">然后在您的迁移文件中，只需写下您想要进行的更改。例如，上图中的<code class="fe mr ms mt mu b">000001_create_users_table.up.sql</code>迁移应该是这样的:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="31f5" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">对于迁移<code class="fe mr ms mt mu b">000001_create_users_table.down.sql</code>，逆转<code class="fe mr ms mt mu b">up</code>迁移文件所做的更改所需的SQL:</p><pre class="kh ki kj kk gu of mu og oh aw oi bi"><span id="6c70" class="nj kx ir mu b gz oj ok l ol om">DROP TABLE IF EXISTS users;</span></pre><p id="b20d" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated"><strong class="lq is">注意</strong>:有些库可以从GitHub、GitLab、AWS s3等来源读取SQL文件。</p><p id="0184" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">对于这种方法，您可以使用以下库:</p><ol class=""><li id="c239" class="mv mw ir lq b lr mk lu ml lx mx mb my mf mz mj na nb nc nd bi translated"><a class="ae mq" href="https://github.com/golang-migrate/migrate" rel="noopener ugc nofollow" target="_blank">https://github.com/golang-migrate/migrate</a></li><li id="843f" class="mv mw ir lq b lr ne lu nf lx ng mb nh mf ni mj na nb nc nd bi translated"><a class="ae mq" href="https://github.com/pressly/goose" rel="noopener ugc nofollow" target="_blank">https://github.com/pressly/goose</a></li><li id="8bb1" class="mv mw ir lq b lr ne lu nf lx ng mb nh mf ni mj na nb nc nd bi translated"><a class="ae mq" href="https://www.prisma.io/migrate" rel="noopener ugc nofollow" target="_blank">https://www.prisma.io/migrate</a></li><li id="75b0" class="mv mw ir lq b lr ne lu nf lx ng mb nh mf ni mj na nb nc nd bi translated"><a class="ae mq" href="https://pypi.org/project/yoyo-migrations/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/yoyo-migrations/</a></li><li id="47f8" class="mv mw ir lq b lr ne lu nf lx ng mb nh mf ni mj na nb nc nd bi translated"><a class="ae mq" href="https://github.com/alexyslozada/migrations" rel="noopener ugc nofollow" target="_blank">https://github.com/alexyslozada/migrations</a></li></ol><h1 id="105b" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">使用您的编程语言进行迁移</h1><p id="c6e0" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">这里应用了与纯SQL迁移中相同的约定，但不是使用<code class="fe mr ms mt mu b">.sql</code>迁移，而是使用编程语言的扩展进行迁移，在我的例子中，我将使用Golang，所以我之前向您展示的文件结构看起来像这样，带有时间戳版本而不是序列:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj on"><img src="../Images/5777d6e69f0106897ad9b8fcb02b685a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*OAGf6eyjAcQVli2deBsfqg.png"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">转到SQL移植目录</p></figure><p id="6dca" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">如您所见，与前面的方法不同，这里我们只有三个文件。这是为什么呢？这是因为我正在使用的图书馆。我们在同一个文件中指明了<code class="fe mr ms mt mu b">up</code>和<code class="fe mr ms mt mu b">down</code>迁移。以下是<code class="fe mr ms mt mu b">users</code>表的内容:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="38ae" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">这里有一个传递给<code class="fe mr ms mt mu b">goose.AddMigration()</code>的<code class="fe mr ms mt mu b">up</code>和<code class="fe mr ms mt mu b">down</code>函数。根据您的编程语言和您使用的库，这显然会有所不同。</p><p id="dfd2" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">对于这种方法，您可以使用以下库:</p><ol class=""><li id="d384" class="mv mw ir lq b lr mk lu ml lx mx mb my mf mz mj na nb nc nd bi translated"><a class="ae mq" href="https://github.com/pressly/goose" rel="noopener ugc nofollow" target="_blank">https://github.com/pressly/goose</a></li><li id="5db0" class="mv mw ir lq b lr ne lu nf lx ng mb nh mf ni mj na nb nc nd bi translated"><a class="ae mq" href="https://laravel.com/docs/9.x/migrations" rel="noopener ugc nofollow" target="_blank">https://laravel.com/docs/9.x/migrations</a></li><li id="6890" class="mv mw ir lq b lr ne lu nf lx ng mb nh mf ni mj na nb nc nd bi translated"><a class="ae mq" href="https://pypi.org/project/yoyo-migrations/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/yoyo-migrations/</a></li></ol><h1 id="4eba" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">如果我处于项目中期并且没有迁移，该怎么办？</h1><p id="ad55" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">为此，您可以创建数据库模式的备份，这样您就可以将它添加为初始迁移，但是您必须确保您使用的库不会在您的本地数据库中执行它(因为您已经有了那些更改)，因此您必须深入到该库以查看它们如何跟踪已经运行的迁移，据我所知，它们会在您的数据库中创建一个表，所以您可以从那里开始。</p><p id="59ad" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">然后，您可以开始跟踪数据库的变化。如果您想要一个新表，请添加一个迁移。如果你想删除一列？添加迁移。如果你想要一个索引？添加迁移。请记住，对数据库模式的每个更改都必须有一个迁移。</p><h1 id="227b" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">结论</h1><p id="71bd" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">在这里，我向您概述了数据库迁移，以及如何处理它们的两种常见方法。就个人而言，我喜欢使用第一种方法，因为我只需要担心编写SQL，而不用担心用我的编程语言编写代码来执行迁移。我已经用这个方法三年多了，从来没有必要使用第二种方法。</p><p id="541e" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">如果您还没有开始使用这些迁移，我希望您今天已经学到了一些新东西并开始使用它们。三年前我不知道如何使用它们，但是通过练习，你会准备好使用它们或者把它们教给其他开发者。</p><p id="f41e" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">如果您想知道如何自动创建和运行文件迁移，请参考我提到的库。在那里他们解释如何使用它们。</p><p id="70a7" class="pw-post-body-paragraph lo lp ir lq b lr mk js lt lu ml jv lw lx mm lz ma mb mn md me mf mo mh mi mj ik bi translated">感谢您的阅读，下一篇文章再见。</p></div></div>    
</body>
</html>