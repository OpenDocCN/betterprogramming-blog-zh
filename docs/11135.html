<html>
<head>
<title>Implement Event-driven Architecture With Minimal Effort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以最小的努力实现事件驱动的架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-event-driven-architecture-with-minimal-effort-182c3bbe5524?source=collection_archive---------8-----------------------#2022-02-21">https://betterprogramming.pub/implement-event-driven-architecture-with-minimal-effort-182c3bbe5524?source=collection_archive---------8-----------------------#2022-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="824b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">时间耦合是最容易被忽视的陷阱</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/0d46d8b9c5ae2950ef1e8f4dc8a62d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WLldaPqvSOjRmN8s"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆罕默德·拉赫马尼</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0789" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上次，我们<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/temporal-coupling-in-code-e74899f7a48f">解释了时间耦合</a>可以通过事件驱动架构有效解决。其中，我们分别讨论了这三种方法。从可靠性最低的开始，简单的使用事件发射器就可以事半功倍的解决大部分情况；其次，为了进一步提高可靠性，可以引入消息队列，保证事件至少执行一次。最后，实现事件源以确保事件不会丢失。</p><p id="af95" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，在资源有限的组织中，消息队列似乎遥不可及。这里的资源包括人力资源和组织预算，无论是没有额外的人力来维护一个新的消息服务，还是没有额外的资金来启动一个消息服务。消息队列是受限组织中的高价系统之一。</p><p id="2829" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，在本文中，我将介绍如何用最少的资源通过事件驱动架构实现解耦。</p><h1 id="5b15" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">系统概况</h1><p id="8792" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">为什么会诞生这个话题？因为我们的一个产品属于这个受限组织。因此，在系统演进的过程中，我们通过做出大量的设计决策来逐步提高可靠性。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/c58380f0fbb4e0d0c6090155f6b98b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*K25enigwiBGTjRrQnfCPDQ.png"/></div></figure><p id="6990" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面的整体架构是我们系统的最终外观。从图中我们可以看到，没有消息队列。即便如此，我们仍然实现了高可靠性。至少，出了问题，还有挽回的办法。</p><p id="59b1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">组件、警报管理器、crontab和DB都存在于系统中，没有添加其他组件。我们只是将最初由函数执行的单元分成发射器和处理程序。</p><p id="b60a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在下一节中，我将一步步解释我们是如何做到的。</p><h1 id="5910" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">系统进化</h1><p id="005e" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">整个系统演进过程经历了四个阶段，我们逐渐提高了整个系统的可靠性。</p><ul class=""><li id="3dd8" class="mr ms iq kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated">尽力而为:在开始时，我们简单地将函数分成发射器和处理器，仅此而已。这是最基本的做法，所有的事件都是一劳永逸的。当然，如果没有意外发生，这样的实施其实并不坏。可以用最少的资源实现解耦。但是前面文章提到，主要有两个问题，<strong class="kz ir">事件损失</strong>和<strong class="kz ir">发射损失</strong>。</li><li id="464b" class="mr ms iq kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated">与警报管理器集成:当处理程序执行失败时，我们添加一个警报。通过将必要的信息写入<code class="fe nf ng nh ni b">Elastic Search</code>并呈现在<code class="fe nf ng nh ni b">Kibana</code>上，负责人可以在收到slack的警报后采取相应的行动。也就是说，我们通过人工恢复来解决<strong class="kz ir">事件损失</strong>。</li></ul><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/df737a2b8b1132fb741250a37d4defc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*iOo7d75YrvR94pEsY9U0LA.png"/></div></figure><ul class=""><li id="00e2" class="mr ms iq kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated">事件源:为了更完整地跟踪事件以避免<strong class="kz ir">事件损失</strong>和<strong class="kz ir">发射损失</strong>，我们使用现有的数据库来实现事件源的简化版本。在发射事件之前，发射器将元数据写入数据库，并标记预期的处理程序。如果写入数据库失败，则被视为事件发射失败，将触发警报管理器。当处理程序完成事件时，它还会将自身更新到数据库中。对于上面提到的示例，事件的元数据如下所示:</li></ul><pre class="kh ki kj kk gt nk ni nl nm aw nn bi"><span id="ce9d" class="no lu iq ni b gy np nq l nr ns">{<br/>    eventName: "purchased",<br/>    createAt: "2022/01/01 1:11:11",<br/>    expected: ["giveCoupon", "lottery"],<br/>    status: 0, // 0: emitted, 1: timeout, 2: processed<br/>    done: [],<br/>    args: ["user A", 5000]<br/>}</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/6b78e7bb9463a92f61b73208c4d2f77d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*EURDW5EBuwGQbdqIsU692A.png"/></div></figure><ul class=""><li id="6a8b" class="mr ms iq kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated">应用crontab加事件幂等性:此时此刻，与前面完整的架构图相同。以上步骤都有一个致命的缺陷，需要人工恢复。虽然这可以确保问题最终得到解决，但平均恢复时间(MTTR)将会相当长。因此，通过我在<a class="ae kw" href="https://lazypro.medium.com/design-patterns-of-event-driven-architecture-bf0121cfda7b" rel="noopener">上一篇文章</a>中介绍的工作流事件模式，可以进一步增强整个恢复机制。通过crontab定期检查哪些事件没有正确执行，然后重新运行它。</li></ul><p id="7e65" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有两个要点值得注意。首先，每个事件的处理必须是幂等的，这一点即使在使用消息队列时也非常重要。因为消息队列保证至少一次，而不是恰好一次。其次，即使有幂等性，重试次数也应该有上限。如果重试几次失败，我们还是要通知负责人处理后续事宜。</p><h1 id="b871" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">权衡取舍</h1><p id="d596" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">其实上面的架构有很多值得讨论的地方。举个例子，</p><ul class=""><li id="9226" class="mr ms iq kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated">了解发射器向数据库写入数据时需要哪些处理程序。换句话说，发射器以某种方式耦合到处理程序。但是，在我看来，这样的耦合是可以接受的。只要可以通过适当的编码减少耦合，例如，有一个全局映射表来拥有每个事件和处理程序之间的关系，那么这可以被视为一种配置而不是耦合。</li><li id="a114" class="mr ms iq kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated">在处理程序中重试，而不是crontab。各有各的优势。在处理程序中重试可以尽快恢复错误，但有时处理程序失败的主要原因是数据库拥塞，立即重试会进一步增加数据库的负载。</li><li id="6c0e" class="mr ms iq kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated">数据不一致。处理程序成功执行，但更新失败。使用幂等性来确保即使重复执行也不会导致问题。另一方面，发射器的任务成功执行，但未能写入数据库，必须手动重新发射。这可以通过一种更复杂的机制来实现自动重试，但以更复杂的代价来说，我认为对于写入失败的情况来说不值得。</li></ul><h1 id="e0f3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="de8d" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">在本文中，我们将讨论一些受限组织在事件驱动架构中面临的一些权衡。不得不说，事件驱动架构本身就是一个高度复杂的架构，它是否真的适合小组织一直是争论的问题。然而，本文提供了一种在小型系统上实现事件驱动架构的简单方法。除了不创建新的组件之外，它不会产生太多的编码复杂性，并且是一个易于实践的实现。</p><p id="62e8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">尽管如此，在这一长串设计决策中为每个组织找到正确的方法并不容易。每一个直截了当的回答背后，都有很多考量和可能的风险。当我在设计一个系统，尤其是一个分布式系统时，我总是提醒自己要小心FLP定理。</p><blockquote class="nt nu nv"><p id="e68b" class="kx ky nw kz b la lb jr lc ld le ju lf nx lh li lj ny ll lm ln nz lp lq lr ls ij bi translated">没有一个完全异步的一致协议能够容忍甚至一个未宣布的进程死亡</p></blockquote><p id="c723" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">用简单的英语来说，就是墨菲定律。</p><blockquote class="nt nu nv"><p id="f95b" class="kx ky nw kz b la lb jr lc ld le ju lf nx lh li lj ny ll lm ln nz lp lq lr ls ij bi translated"><em class="iq">任何可能出错的事情都会出错。</em></p></blockquote><p id="f7a9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如何在有限的资源下尽可能可靠，无论是在时间、人力还是成本方面，都是系统设计中最有趣的部分。</p></div></div>    
</body>
</html>