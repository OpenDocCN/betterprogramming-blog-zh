<html>
<head>
<title>Extending iOS Apps With Plug-Ins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用插件扩展iOS应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/extending-ios-apps-with-plug-ins-e4119d064f2d?source=collection_archive---------8-----------------------#2020-06-01">https://betterprogramming.pub/extending-ios-apps-with-plug-ins-e4119d064f2d?source=collection_archive---------8-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2241" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个应用程序，加载一个插件并显示该插件的一些UI</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e86611cc339c611fb16bd67caf58bce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YcF8newhWks3poli"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·卡丽在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="d7df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于桌面应用程序来说，应用程序扩展或插件非常常见。Web浏览器提供了大量的插件选择，而许多开发环境，如Visual Studio Code或Android Studio，在其插件市场中提供的功能远远多于其原始应用程序。图形设计软件也有插件，允许你扩展应用程序的功能。</p><p id="8c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，iOS应用程序没有很多扩展。通常，你会得到一个具有固定功能的产品。总的来说，苹果似乎不喜欢插件。Xcode是少数几个不能用插件扩展的开发环境之一。你得到你所得到的，如果有新的东西出现，你需要更新整个应用程序。</p><p id="d290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不知道为什么苹果不喜欢插件，但是对于iOS应用，有一个解释。在App Store中发布一个应用程序之前，这是iOS应用程序的主要分发方式，苹果会对其进行审查。他们有一长串的规则，如果他们发现你的应用程序没有满足他们的至少一个要求，他们就会拒绝它。</p><blockquote class="lv lw lx"><p id="22b4" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“2.5.2应用程序应独立于其捆绑包，不得在指定的容器区域之外读取或写入数据，也不得下载、安装或执行引入或更改应用程序(包括其他应用程序)的特性或功能的代码。旨在教授、开发或允许学生测试可执行代码的教育应用程序可以在有限的情况下下载代码，前提是此类代码不用于其他目的。这类应用程序必须使应用程序提供的源代码完全可供用户查看和编辑。”— <a class="ae ky" href="https://developer.apple.com/app-store/review/guidelines/" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote><p id="7038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问，“网络浏览器呢？”iOS设备上的网页浏览器在功能上也非常有限。他们可以显示网页内容，但不能超出这个范围。此外，显示web内容也受到相同准则的限制:</p><blockquote class="mc"><p id="9e6d" class="md me it bd mf mg mh mi mj mk ml lu dk translated">“2.5.6浏览网页的应用程序必须使用适当的WebKit框架和WebKit Javascript。”— <a class="ae ky" href="https://developer.apple.com/app-store/review/guidelines/" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote><p id="6288" class="pw-post-body-paragraph kz la it lb b lc mm ju le lf mn jx lh li mo lk ll lm mp lo lp lq mq ls lt lu im bi translated">好吧，但是如果我们想添加不改变应用程序功能的插件呢？或者我们不想要一个企业分发的app怎么办？有可能动态扩展应用程序的功能吗？简短的回答是“是的”有几种不同的方法。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="2022" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">我们的目标</h1><p id="f60e" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">出于演示目的，让我们制作一个有一个空屏幕、一个容器和一个按钮的应用程序。该按钮将加载我们的插件，运行它，并在容器中显示结果。</p><p id="449a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的插件都会做同样的事情:画一个红绿灯，在红、绿、蓝之间循环切换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d1ff254b29e64f1e5dcc3c4aca6ca5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60UAGrw8AH6FmX326Q7GTQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个红绿灯的三个阶段(截图来自app)。</p></figure><p id="a366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个与插件通信的协议。该协议应包括以下特征:</p><ol class=""><li id="0a3d" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">从Swift代码运行插件</li><li id="d8cf" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">定时器功能</li><li id="d4bc" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">从脚本创建和更改iOS视图</li></ol><p id="750d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们需要双向互动。让我们看看如何能做到这一点。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="7138" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">准备</h1><p id="3676" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">在我们开始添加插件之前，让我们创建一个基础应用程序。创建一个只有一个视图控制器的新项目。这个视图控制器应该只有两个视图:</p><ol class=""><li id="c4a6" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">插件容器</li><li id="52e5" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">开始按钮</li></ol><p id="8fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在更复杂的版本中，你可以从网上加载插件，从二维码扫描，从蓝牙接收，甚至从声波解码。这不会改变任何事情，这就是为什么我将使用最简单的选项——向应用捆绑包添加脚本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/1f32dc2909326fecbfbf8034b06d3184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*s42BZbPzOjt3mvOKej0kPg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">App故事板。</p></figure><p id="6a5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每种类型的插件，Swift代码都是不同的。我会把它附在每一节的末尾。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="fd76" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">Java Script语言</h1><p id="fa3a" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">扩展任何应用程序最简单的方法就是使用JavaScript。首先，JavaScript是一种流行的语言。第二，还有其他语言(例如TypeScript)将它们的代码编译成JavaScript。第三，iOS有一个集成的JavaScript解释器。</p><p id="0ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行JavaScript代码，请使用<a class="ae ky" href="https://developer.apple.com/documentation/javascriptcore" rel="noopener ugc nofollow" target="_blank"> JavaScriptCore </a>框架:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="7e22" class="oq mz it om b gy or os l ot ou"><em class="ly">import </em>JavaScriptCore</span></pre><p id="4eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript需要上下文:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="919d" class="oq mz it om b gy or os l ot ou"><em class="ly">let </em>jsContext = JSContext()</span></pre><p id="c4dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给出了一个可选的上下文。检查上下文是否被创建是一个好习惯，如果没有，显示一个警告。但是为了缩短未来的代码，我将假设上下文将总是被创建:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="3f95" class="oq mz it om b gy or os l ot ou"><em class="ly">let </em>jsContext = JSContext()!</span></pre><p id="895f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将JavaScript文件包含到我们的项目中。我们将一个文本字符串传递给<code class="fe ov ow ox om b">JSContext</code>。文本可以来自任何来源。它可以是硬编码的、来自应用捆绑包的文件或web。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="14fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe ov ow ox om b">jsPluginCode.js</code>添加到您的项目中。下面是我为我们的插件编写的JavaScript代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="2fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免与UIKit函数的冲突，我将视图称为“小部件”</p><p id="4136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift将调用两个功能:</p><ol class=""><li id="c4fc" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe ov ow ox om b">start(width, height)</code>创建部件并设置初始值。它获得两个参数:插件容器的宽度和高度。</li><li id="b2c4" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe ov ow ox om b">tick(delta)</code>告诉我们的脚本一些<code class="fe ov ow ox om b">delta</code>时间过去了，并允许它采取一些行动。在浏览器内JavaScript中，这是不必要的。我们可以使用异步函数，但是当脚本结束时<code class="fe ov ow ox om b">JavaScriptCore</code>停止执行，而不等待所有的异步函数完成(这将是一个永恒的循环，所以我们无论如何也不想去那里)。</li></ol><p id="1a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的脚本可以调用两个函数:</p><ol class=""><li id="2795" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe ov ow ox om b">addWidget(name, args)</code>创建一个具有给定名称(小部件类型)和参数(小部件属性)的小部件。</li><li id="de09" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe ov ow ox om b">updateProperty(widgetTag, property, newValue)</code>用给定的标签更新现有小部件的属性。</li></ol><p id="ae60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个演示，只有一个小部件(<code class="fe ov ow ox om b">Circle</code>)和一个可变属性(<code class="fe ov ow ox om b">backgroundColor</code>)。当然，您可以添加任意数量的小部件和属性。</p><p id="a7ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe ov ow ox om b">Circle</code>小部件具有以下属性:</p><ol class=""><li id="d6b7" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe ov ow ox om b">x</code> —中心的x坐标(数字)</li><li id="58cf" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe ov ow ox om b">y </code> —中心的y坐标(数字)</li><li id="1d28" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe ov ow ox om b">radius</code> —圆的半径(数字)</li><li id="1a7a" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe ov ow ox om b">color</code> —圆的十六进制颜色(十六进制字符串)</li><li id="da8d" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe ov ow ox om b">tag</code> —小部件/视图的标签，以便以后引用(<code class="fe ov ow ox om b">int</code>号)</li></ol><p id="1448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供的JavaScript代码创建了三个圆圈:红色、黄色和绿色。其中一个完全不透明，而另外两个大约有1/3的不透明。</p><p id="13e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox om b">tick</code>函数以毫秒为单位计数。当它到达一秒钟时，它运行<code class="fe ov ow ox om b">loopStep</code>，这将改变我们交通灯的状态，将完全不透明赋予另一种颜色(另一种光)。</p><p id="d0d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你懂JavaScript，这段代码不会引发很多问题。如果没有，就认真看完。你会发现它和Swift没什么不同。</p><p id="1b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS的代码更复杂。我们需要添加四个项目:</p><ul class=""><li id="7b1f" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu pa oc od oe bi translated">当用户点击按钮时运行代码。</li><li id="6cc2" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu pa oc od oe bi translated">添加一个计时器，该计时器将以已知的时间间隔调用<code class="fe ov ow ox om b">tick</code>功能。</li><li id="e7d2" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu pa oc od oe bi translated">可从JavaScript的<code class="fe ov ow ox om b">addWidget</code>函数中调用。</li><li id="7f74" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu pa oc od oe bi translated">可从JavaScript的<code class="fe ov ow ox om b">updateProperty</code>函数中调用。</li></ul><p id="2644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，我们需要添加一个JavaScript异常处理程序来将我们的错误记录到控制台。这将使调试过程更加容易。</p><p id="d7b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用JavaScript的视图控制器的完整源代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="a523" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">左上臂</h1><p id="ee98" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">另一种扩展应用程序的方法是使用Lua。Lua是一种简单的编程语言，最初是为了扩展应用程序而创建的。</p><blockquote class="mc"><p id="e00a" class="md me it bd mf mg mh mi mj mk ml lu dk translated">" Lua是一种强大、高效、轻量级、可嵌入的脚本语言."— <a class="ae ky" href="https://www.lua.org/about.html" rel="noopener ugc nofollow" target="_blank">卢阿</a></p></blockquote><p id="419f" class="pw-post-body-paragraph kz la it lb b lc mm ju le lf mn jx lh li mo lk ll lm mp lo lp lq mq ls lt lu im bi translated">Lua在游戏开发中非常流行。一些游戏引擎使用Lua作为他们的主要语言(例如<a class="ae ky" href="https://love2d.org/" rel="noopener ugc nofollow" target="_blank"><em class="ly">love</em></a>)。其他框架允许你用Lua编写游戏的一部分，比如游戏逻辑或者游戏扩展(例如<a class="ae ky" href="http://polycode.org/" rel="noopener ugc nofollow" target="_blank"> Polycode </a>)。</p><p id="54e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lua是真正的跨平台语言。它的<a class="ae ky" href="https://www.lua.org/ftp/" rel="noopener ugc nofollow" target="_blank">官方框架</a>是用纯C写的，基本上可以在任何地方集成。Lua是免费的，在麻省理工学院许可下发布。</p><blockquote class="mc"><p id="9cfc" class="md me it bd mf mg mh mi mj mk ml lu dk translated">" Lua可以用于任何目的，包括商业目的，完全免费."— <a class="ae ky" href="https://www.lua.org/license.html" rel="noopener ugc nofollow" target="_blank">卢阿</a></p></blockquote><p id="01db" class="pw-post-body-paragraph kz la it lb b lc mm ju le lf mn jx lh li mo lk ll lm mp lo lp lq mq ls lt lu im bi translated">最初的Lua框架可以很容易地集成到Objective-C中，但在Swift中会更复杂。幸运的是，有图书馆可以让它变得更容易。例如，我<a class="ae ky" href="https://github.com/weyhan/lua4swift" rel="noopener ugc nofollow" target="_blank">发现了一个</a>，我将在本节的示例中使用它。</p><p id="931a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">注意:如果您喜欢使用原始的Lua框架，您可以下载它，并使用桥接头将其连接到您的项目。</em></p><p id="cfaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会解释Lua的语法。这方面有很多教程、手册和视频课程。该脚本的逻辑与上一节中的JavaScript代码完全相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="f1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个细节:</p><ul class=""><li id="19cc" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu pa oc od oe bi translated">在JavaScript中，对象非常类似于Swift字典，但是Lua有表。它们的内部结构不同，所以我们不能把它们作为参数传递。传递自定义结构的方法是有的，但我们不会深入到这么深。相反，我修改了<code class="fe ov ow ox om b">addWidget</code>函数来接受一组简单的参数——数字和字符串。它去除了一些灵活性，但使界面相当简单。</li><li id="9dea" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu pa oc od oe bi translated">该脚本返回两个值:<code class="fe ov ow ox om b">start</code>和<code class="fe ov ow ox om b">tick</code>。它们是我们从上一节中知道的函数。当我们读取一个文件时，我们在Swift中得到一个Lua函数。我们调用它，得到两个函数作为结果，保存在变量中，需要的时候调用。</li></ul><p id="5003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当Lua脚本被编写并包含到一个app bundle(名为<code class="fe ov ow ox om b">luaPluginCode.lua</code>)中时，我们集成一个库来解析和执行它。这可以用椰子来完成:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="d482" class="oq mz it om b gy or os l ot ou">platform :ios, '13.0'<br/>use_frameworks!</span><span id="8002" class="oq mz it om b gy pb os l ot ou">target 'Modules_iOS' <strong class="om iu">do<br/>  </strong>pod 'lua4swift', :git =&gt; 'https://github.com/weyhan/lua4swift'<br/><strong class="om iu">end</strong></span></pre><p id="b7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别忘了安装吊舱。如果你不知道pods是如何工作的，你需要安装cocoapods:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="eeb7" class="oq mz it om b gy or os l ot ou">sudo gem install cocoapods</span></pre><p id="5378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，将文件<code class="fe ov ow ox om b">Podfile</code>添加到项目文件夹并运行:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="e155" class="oq mz it om b gy or os l ot ou">pod install</span></pre><p id="a579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在，让我们切换到Swift代码。</p><p id="e429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入Lua库:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="70cd" class="oq mz it om b gy or os l ot ou"><strong class="om iu">import</strong> Lua</span></pre><p id="3970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建虚拟机:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="5f40" class="oq mz it om b gy or os l ot ou"><strong class="om iu">let</strong> vm = Lua.VirtualMachine()</span></pre><p id="0cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将所有函数添加到一个全局名称空间中。有两个函数，就像我们前面的例子一样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c46a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数可以访问视图控制器，所以所有的逻辑都可以在内部完成。我们在一个<code class="fe ov ow ox om b">args</code>变量中得到所有的参数，我们将它分解成六个具有可理解名称的变量。</p><p id="d79f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的就很简单了。我们使用这个参数来设置一个视图并将其添加到我们的容器中。</p><p id="49c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Lua可以获得返回值，我们需要直接指定它。在这种情况下，我们返回<code class="fe ov ow ox om b">.nothing</code>，但是如果需要返回值，可以使用<code class="fe ov ow ox om b">.value</code>。</p><p id="d516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新小部件属性的第二个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="5842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当这些函数完成后，让我们读取我们的文件并将<code class="fe ov ow ox om b">start</code>和<code class="fe ov ow ox om b">tick</code>函数保存在视图控制器属性<code class="fe ov ow ox om b">startFunc</code>和<code class="fe ov ow ox om b">tickFunc</code>中。两者都有类型<code class="fe ov ow ox om b">Function</code>——准确地说是<code class="fe ov ow ox om b">Lua.Function</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="0994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有错误都将打印在控制台中。这包括Lua脚本内部的错误。由于<code class="fe ov ow ox om b">lua4swift</code>库会自动将所有错误输出到控制台，所以我们可以在不需要的时候忽略调用值。</p><p id="0b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的函数调用将如下所示:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="34be" class="oq mz it om b gy or os l ot ou"><strong class="om iu">_</strong> = startFunc?.call([Double(vPluginContainer.bounds.width), Double(vPluginContainer.bounds.height)])</span></pre><p id="3b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="346f" class="oq mz it om b gy or os l ot ou"><strong class="om iu">_</strong> = tickFunc?.call([10.0])</span></pre><p id="9e7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个函数只调用一次，第二个函数每0.01秒调用一次。从视觉上看，这个应用程序与用JavaScript编写的一模一样。</p><p id="9ee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用Lua的视图控制器的完整源代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="fabc" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">动态库</h1><p id="cf9c" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">最后，我们到了有趣的部分。</p><p id="df5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之前展示的内容在许多应用程序中被积极使用。App Store里的一些应用其实是用JavaScript写的。我说的是React Native之类的框架。其他app积极使用Lua。但是如果我们想给应用程序添加一个二进制库呢？</p><p id="4258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们下载了一个为armv7和arm64构建的“胖”库。我们知道这个库有两个功能:<code class="fe ov ow ox om b">start</code>和<code class="fe ov ow ox om b">tick</code>。第一个接受两个<code class="fe ov ow ox om b">Double</code>参数，而另一个接受一个<code class="fe ov ow ox om b">Double</code>参数。我们能叫它吗？这可能吗？</p><p id="debd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想指出，我说的不是苹果的要求。他们很可能会拒绝这样的应用程序。我说的是在现有的iOS应用中“注入”二进制代码的技术可能性。</p><p id="a4f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它分成两步:</p><ol class=""><li id="cac3" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">构建一个iOS框架，并将其包含在应用捆绑包中。</li><li id="64e7" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">分离这个框架，动态加载。</li></ol><h2 id="23cd" class="oq mz it bd na pc pd dn ne pe pf dp ni li pg ph nk lm pi pj nm lq pk pl no pm bi translated">iOS框架</h2><p id="3eaa" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">自古以来，有两种类型的库:静态库和动态库。静态库在编译期间与主二进制文件链接。因此，它们成为输出二进制的一部分。显然，这一个不是我们的选择。</p><p id="375c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态库位于单独的文件中。它们在应用程序启动后加载(通常在开始时)，但不包含在可执行二进制文件中。如果从应用程序文件夹或应用程序捆绑包中删除动态库，应用程序通常会崩溃或显示错误信息。</p><p id="0bf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在苹果iOS平台中，动态库以框架的形式呈现。</p><p id="1900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用下面这个现有的项目，并添加第三个视图控制器。所有UI元素都将位于主部件内部(与前面的示例相同):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/9c66f792cdb5046c333c350cb81137a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-196-7CZWu9xoljonPKzug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建框架目标。</p></figure><p id="4326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我称我的框架为“动态之光”这两部分的代码都很短。它不需要任何额外的知识。这是一个简单的iOS应用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="5b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，在动态模块中，我只使用了<a class="ae ky" href="https://get.foundation/" rel="noopener ugc nofollow" target="_blank">基础</a>框架。这是为了避免对UI的任何引用。实际上，它是前几节中JavaScript和Lua代码的精确复制。</p><p id="c57a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox om b">FrameworkViewController.swift</code>也很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="47aa" class="oq mz it bd na pc pd dn ne pe pf dp ni li pg ph nk lm pi pj nm lq pk pl no pm bi translated">让我们动态加载它</h2><p id="eed3" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">首先，让我们从项目依赖项中移除动态灯光:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/58dfbc9ee39cde7b58bd6caf459615d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TY0sXO21YrNSPT1nnTlZgg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不依赖于DynamicLights。</p></figure><p id="a6d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清理“build”文件夹并再次构建项目。您将得到一条错误消息:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="5ed6" class="oq mz it om b gy or os l ot ou">No such module 'DynamicLights'</span></pre><p id="731f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有道理。我们的主应用程序不再了解我们的动态框架。</p><p id="ee65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择DynamicLights作为构建目标并构建它。在项目导航器中，你会在<code class="fe ov ow ox om b">Products</code>文件夹中看到<code class="fe ov ow ox om b">DynamicLights.framework</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/f7122179f98c855a2d6d65f0fb8f5321.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*QXNr_h2zsVcRVjYKFtZ7FA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动态照明框架。</p></figure><p id="002d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Finder中打开此框架。在<code class="fe ov ow ox om b">DynamicLights.framework</code>文件夹中，您将找到<code class="fe ov ow ox om b">DynamicLights</code>文件(如果您为您的框架选择了另一个名称，文件名会有所不同)。这个文件是我们的动态库。</p><p id="243d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode是智能的，所以如果你把它拷贝到一个应用捆绑包，它会自动链接它——即使你没有明确选择这个选项。<code class="fe ov ow ox om b">DymanicLights.framework</code>并且它的任何部分都不应该在项目捆绑包中。</p><p id="982b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在iOS模拟器上测试过，它可以访问你Mac的文件系统，所以我只是从文件中读取库。如果你想在真实设备上测试它，你必须下载文件，在运行时将它保存到应用程序沙箱中，并从那里加载它。</p><p id="4096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前提到的，苹果反对插件，你很难在App Store中找到可扩展的iOS应用程序，所以苹果没有一个官方的，记录在案的方法来动态地与框架交互。如果您考虑不同的架构、Swift版本、签名和其他环境条件，事情会变得更加复杂。这也是我有点同意苹果的原因。这种方式真的不好。</p><p id="5426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们来说幸运的是，Swift与C兼容，你不能在同一个文件中混合它们，就像Objective-C与C一样，但是你可以在Swift代码中使用C函数。现在说的是<code class="fe ov ow ox om b">dlopen</code>、<code class="fe ov ow ox om b">dlsym</code>、<code class="fe ov ow ox om b">dlclose</code>等函数。要从框架中导出函数，需要添加关键字<code class="fe ov ow ox om b">@_cdecl</code>。</p><p id="538c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了不处理不断变化的全局变量(甚至不确定是否可能)，我添加了设置回调的函数。以下是完整的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ae75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重新构建您的框架并将<code class="fe ov ow ox om b">DynamicLights</code>文件复制到某个已知的位置。理论上，你可以使用Xcode的<code class="fe ov ow ox om b">Derived Data</code>文件夹中的现有路径，但是为了避免混淆，我不推荐这样做。我的道路是<code class="fe ov ow ox om b">/Volumes/Extra/Work/DynamicLights</code>。</p><p id="3405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的视图控制器，用<code class="fe ov ow ox om b">import Darwin</code>替换<code class="fe ov ow ox om b">import DynamicLights</code>。达尔文是苹果操作系统的核心元素。作为一个框架，它提供了对核心C函数的访问，包括<code class="fe ov ow ox om b">dlopen</code>、<code class="fe ov ow ox om b">dlsym</code>和<code class="fe ov ow ox om b">dlclose</code>。</p><p id="2cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有四个功能。其中两个设置回调，而另外两个给出命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="395c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和两个集体成员:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="a47a" class="oq mz it om b gy or os l ot ou"><strong class="om iu">var</strong> handle: UnsafeMutableRawPointer?</span><span id="58d1" class="oq mz it om b gy pb os l ot ou"><strong class="om iu">var</strong> tickFunc: tickFuncPrototype?</span></pre><p id="c305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox om b">handle</code>有一个指向动态加载库的指针。<code class="fe ov ow ox om b">tickFunc</code>是一个我们每秒调用100次的函数(这就是为什么值得保留指针而不是每次都获取它)。</p><p id="0251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们是这样加载动态库的:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="cb7d" class="oq mz it om b gy or os l ot ou">handle = dlopen("/Volumes/Extra/Work/DynamicLights", RTLD_LAZY)</span></pre><p id="d452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到<code class="fe ov ow ox om b">updateProperty</code>和<code class="fe ov ow ox om b">addWidget</code>常量包含我们回调的代码，这是我们的初始化代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="4fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是计时器回调:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="831a" class="oq mz it om b gy or os l ot ou"><strong class="om iu">if</strong> <strong class="om iu">let</strong> tickFunc = tickFunc {<br/>    tickFunc(0.01)<br/>}</span></pre><p id="4baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们在这里使用了一些不安全的造型。如果函数原型在主代码和库代码中不匹配，应用程序就会崩溃。这使得这种方法比使用我们的JavaScript或Lua代码更不安全。</p><p id="b42d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最终版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="c975" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">其他方式</h1><p id="c4ea" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">JavaScript、Lua和原生库并不是扩展iOS应用的唯一方式。还有许多其他的脚本语言。</p><p id="91b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，有一种快速简单的<a class="ae ky" href="https://github.com/marcobambini/gravity" rel="noopener ugc nofollow" target="_blank"> Gravity </a>语言，看起来像Swift。它提供了一个C库，可以集成到Objective-C和Swift应用程序中。</p><p id="81ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更复杂的语言如Python、Perl或Ruby也可以用来扩展现有的应用程序，但通常不值得。</p><p id="2d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要动态布局，可以考虑使用XML或其他标记语言。你可以自己写一个简单的引擎或者使用<a class="ae ky" href="https://github.com/nicklockwood/layout" rel="noopener ugc nofollow" target="_blank">现有的解决方案</a>。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="f8bb" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">结论</h1><p id="595a" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">即使苹果不鼓励使用应用程序扩展，但从技术上来说，使用它们是可能的。</p><p id="1c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展应用程序最安全的方式是使用JavaScript。苹果有一种原生的方式来运行JavaScript代码，你可以使用不同的JavaScript风格，你可以很容易地将代码转移到另一个平台。</p><p id="d6f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出于某种原因，您对JavaScript不太适应，可以使用许多其他脚本语言，比如Lua或更奇特的Gravity。</p><p id="4cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以从外部文件中读取布局。使用外部布局引擎，您可以从XML或其他标记文件导入布局。HTML也可以在iOS应用中解析和渲染。</p><p id="a3fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见。编码快乐！</p></div></div>    
</body>
</html>