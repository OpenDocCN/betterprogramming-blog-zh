<html>
<head>
<title>How to Test Asynchronous Functions Using Expectation in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中使用expect测试异步功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-test-asynchronous-functions-using-expectation-2c9183fd99c9?source=collection_archive---------2-----------------------#2020-04-04">https://betterprogramming.pub/how-to-test-asynchronous-functions-using-expectation-2c9183fd99c9?source=collection_archive---------2-----------------------#2020-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="80b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">是的，你也可以等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/08207efcf01cbc940c0a62d33f0b894d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GilfQWOJMA2hk7Xa1UBeVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aronvisuals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aron视觉效果</a>在<a class="ae ky" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e5d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的应用程序中可能存在异步代码的原因有很多，想到的第一个原因是网络。</p><p id="15cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保持这篇文章的先决条件，这个例子是一个经过一定时间后的简单等待——但是它将向您展示如何使用<a class="ae ky" href="https://developer.apple.com/swift/" rel="noopener ugc nofollow" target="_blank"> Swift </a>和<a class="ae ky" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank"> Xcode </a>工具来充分测试您的代码。</p><p id="adaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本指南展示了如何在单视图应用中测试异步代码，随后的一节介绍了如何在Playgrounds中做同样的事情。别说我什么都不给你！</p><p id="24e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难度:初级|简单<strong class="lb iu"> </strong> | <strong class="lb iu">普通</strong> |挑战</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9350" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件:</h1><p id="cb9c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我真的希望你能够在一个基本的水平上运行项目和完成项目(包括Swift中的闭包和函数，以及可以从测试中初始化的视图控制器)。)</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="34f0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">术语</h1><p id="98c9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">单元测试:软件测试，对软件的单个单元或组件进行测试</p><p id="1d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个允许你在Xcode中运行单元测试、性能测试和UITests的框架</p><p id="5c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">XCTestCase</code>:定义测试用例、测试方法和性能测试的类</p><p id="a8a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">XCTestExpectation</code>:异步测试中的预期结果</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8c8b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">需要测试的一般代码</h1><p id="892f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将测试一个函数，它接受一条消息、时间(双精度)和一个在延迟完成后调用的完成处理程序。</p><p id="98e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的代码如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5c61" class="nh md it nc b gy ni nj l nk nl">func messageAfterDelay(message: String, time: Double, completion: @escaping (String)-&gt;()) {<br/>    DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) {<br/>        completion (message)<br/>    }<br/>}</span></pre><p id="091e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后可以从我们的视图控制器中调用这段代码。在这里，我们只是打印消息:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f735" class="nh md it nc b gy ni nj l nk nl">messageAfterDelay(message: "message", time: 2.0, completion: {      <br/>    message in<br/>        print (message)<br/>}<br/>)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="60c5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在单一视图项目中测试异步代码</h1><p id="363c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将可测试代码从用户界面代码中分离出来有助于单元测试。</p><p id="f937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要理解的重要一点是，我们遵循以下测试部分的顺序:</p><ol class=""><li id="b785" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">设置一个带描述的<code class="fe mz na nb nc b">XCTestExpectation</code>。</li><li id="3545" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">assert</code>我们期望从封闭内部得到的结果。</li><li id="2518" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">fulfil</code>期待。</li><li id="3141" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">waitForExpectations</code>带有合适的超时。</li></ol><p id="f402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有点难以理解，因为根据定义，代码是异步的，因此不一定按照我们指定的顺序运行。</p><p id="fd6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用代码来看看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/42e72060e3fd8f6c9714882053c6b683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQa6xvGyy5PlaYtIIaD3Ag.png"/></div></div></figure><p id="06aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，1。是在其余代码之前完成的，但是<code class="fe mz na nb nc b">messageAfterDelay</code>是运行的，我们知道，在这种情况下，它只会在一秒钟后完成。</p><p id="21ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在代码到达数字4。，我将它编码为等待三秒钟(好吧，有点夸张，因为代码实际上只需要一秒多一点就可以运行)。</p><p id="2027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们测试的函数返回时(如前所述，这应该是运行后的一秒钟)，我们可以在2秒钟内进行测试。对闭包中返回的消息使用<code class="fe mz na nb nc b">XCTAssertEqual</code>。然后我们实现了3中的期望。</p><p id="34b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那我们就完了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f34" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在操场测试</h1><p id="426e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有趣的是，你不需要使用操场支撑和<code class="fe mz na nb nc b">needsIndefiniteExecution</code>。要在操场上运行测试，我们需要在操场顶部导入<code class="fe mz na nb nc b">XCTest</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7133" class="nh md it nc b gy ni nj l nk nl">import XCTest</span></pre><p id="cf8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前一样，我们可以创建要测试的函数:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d0e8" class="nh md it nc b gy ni nj l nk nl">func messageAfterDelay(message: String, time: Double, completion: @escaping (String)-&gt;()) {<br/>    DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) {<br/>        completion (message)<br/>   }<br/>}</span></pre><p id="502f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其可以如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b6b3" class="nh md it nc b gy ni nj l nk nl">class asyncTests: XCTestCase {<br/>    func testDelay() {<br/>        let exp = expectation(description: "\(#function)")<br/>        messageAfterDelay(message: "myMessage", time: 1.0, completion:<br/>        {message in<br/>              XCTAssertEqual(message, "myMessage")<br/>              exp.fulfill()<br/>        })<br/>        waitForExpectations(timeout: 3)<br/>    }<br/>}</span></pre><p id="615a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用以下命令运行它:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4abf" class="nh md it nc b gy ni nj l nk nl">asyncTests.defaultTestSuite.run()</span></pre><p id="9479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过突出显示语法，这更容易阅读，所以我将在这里添加一个要点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在操场上运行时，我们有如下输出。如果您运行相同的代码，您显然会有不同的时间和数据(并且测试运行的时间也可能不同)。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2b23" class="nh md it nc b gy ni nj l nk nl">Test Suite ‘asyncTests’ started at 2020–04–01 12:18:43.989<br/>Test Case ‘-[__lldb_expr_7.asyncTests testDelay]’ started.<br/>Test Case ‘-[__lldb_expr_7.asyncTests testDelay]’ passed (1.021 seconds).<br/>Test Suite ‘asyncTests’ passed at 2020–04–01 12:18:45.012.<br/>Executed 1 test, with 0 failures (0 unexpected) in 1.021 (1.023) seconds</span></pre><p id="ab2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">另类期望</h1><p id="89f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">声明期望有两种选择。</p><p id="4e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您进行测试时，您可以经历以下步骤:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="43f7" class="nh md it nc b gy ni nj l nk nl">let expect = expectation(description: #function)<br/>expect.fulfill()<br/>waitForExpectations(timeout: 3.0)</span></pre><p id="5b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个替代方案可以接受一系列期望:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1eb2" class="nh md it nc b gy ni nj l nk nl">let expectation = XCTestExpectation(description: #function)<br/>expectation.fulfill()<br/>wait(for: [expectation], timeout: 3.0)</span></pre><p id="0f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以接受一系列的期望，而不是单一的期望。</p><p id="f39e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">牛逼？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c9e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="2359" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">无论您是在测试一段代码还是一个项目，您都可能需要测试异步函数。</p><p id="d298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇特别的文章涵盖了测试异步代码。测试网络遵循如上所示的相同模式(您当然应该测试您的网络代码)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="21d2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">回购</h1><p id="a131" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是GitHub上的<a class="ae ky" href="https://github.com/stevencurtis/testasyncfunctions" rel="noopener ugc nofollow" target="_blank">代码</a>，包括游戏场地和单一视图库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f1de" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">扩展你的知识</h1><ul class=""><li id="fa99" class="nm nn it lb b lc mu lf mv li od lm oe lq of lu og ns nt nu bi translated">苹果有一个关于测试异步代码的指南。</li></ul></div></div>    
</body>
</html>