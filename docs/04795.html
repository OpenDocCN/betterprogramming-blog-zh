<html>
<head>
<title>Build a Server-Driven UI Using UI Components in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI中的UI组件构建服务器驱动的UI</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-server-driven-ui-using-ui-components-in-swiftui-466ecca97290?source=collection_archive---------3-----------------------#2020-05-11">https://betterprogramming.pub/build-a-server-driven-ui-using-ui-components-in-swiftui-466ecca97290?source=collection_archive---------3-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eab4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无需提交给Apple，即可随时更改您的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6674483e0402c8e4b9f599053d2586df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V5kRzEsP5a7zxJwY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查尔斯·德鲁维奥在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ef62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将讨论服务器驱动的UI，它使用称为<em class="lv"> UIComponents </em>的可重用组件来实现，并创建一个通用的垂直列表视图来呈现UI组件。它将以UI组件如何服务于不同目的的简短讨论作为结束。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7a03" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">什么是服务器驱动的UI？</strong></h1><ul class=""><li id="7439" class="mv mw it lb b lc mx lf my li mz lm na lq nb lu nc nd ne nf bi translated">在这种架构中，服务器决定需要在应用程序屏幕上呈现的UI视图。</li><li id="3e27" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">在应用程序和服务器之间存在一个契约。这个契约的基础是让服务器控制应用程序的用户界面。</li></ul><p id="467b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那份合同是什么？-服务器定义组件列表。对于在服务器上定义的每个组件，我们在应用程序中都有相应的UI实现(UIComponent)。考虑一个像Hotstar这样的娱乐app，它的合约定义如下图。左边是来自服务器的组件，右边是相应的UI组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/a58329c3241024baa120ea3ed11e22e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0caqOJanQdl7yvrU1Y0pg.png"/></div></div></figure><p id="c06b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作-屏幕没有像故事板那样的预定义布局。相反，它由一个通用的列表视图组成，根据服务器响应垂直呈现多个不同的视图。为了实现这一点，我们必须创建独立的视图，并且可以在整个应用程序中重用。我们将这些可重用的视图称为<em class="lv"> UIComponent </em>。</p><p id="2da6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">契约——对于每个服务器组件，我们都有一个UIComponent。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9d9c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak"> SwiftUI </strong></h1><p id="9773" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Swift是一个UI工具包，允许您以编程、声明的方式设计应用程序屏幕。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fd20" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">SwiftUI中服务器驱动的UI实现</h1><p id="4269" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这是一个分三步走的过程。</p><ol class=""><li id="b037" class="mv mw it lb b lc ld lf lg li nr lm ns lq nt lu nu nd ne nf bi translated">定义独立UIComponents。</li><li id="c0ec" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nu nd ne nf bi translated">基于API响应构造UIComponents。</li><li id="206d" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nu nd ne nf bi translated">在屏幕上呈现UIComponents。</li></ol><h2 id="ef96" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated">1.<strong class="ak">定义独立的UIComponents </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/9fbf6d62b19f62091fb3aef2d4d0206c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vaTfkYDRJuPnUQm8nYskgQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UI组件的图形表示</p></figure><p id="e6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入:首先，为了让UIComponent呈现自己，应该为它提供数据。</p><p id="bdbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:<strong class="lb iu"> <em class="lv"> </em> </strong> UIComponent定义了它的UI。当用于在屏幕内呈现时，它根据提供给它的数据(输入)来呈现自己。</p><p id="62af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> UIComponent实现</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UIComponent.swift</p></figure><ul class=""><li id="f08f" class="mv mw it lb b lc ld lf lg li nr lm ns lq nt lu nc nd ne nf bi translated">所有的UI视图都必须符合这个UI组件协议。</li><li id="081f" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">由于组件呈现在通用的垂直列表中，每个UIComponent都必须独立标识。属性就是用于这个目的的。</li><li id="d67e" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe oi oj ok ol b">render()</code>是定义组件UI的地方。在屏幕上调用这个函数将呈现组件。再来看<code class="fe oi oj ok ol b">NotificationComponent</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通知组件</p></figure><ul class=""><li id="2afa" class="mv mw it lb b lc ld lf lg li nr lm ns lq nt lu nc nd ne nf bi translated"><code class="fe oi oj ok ol b">NotificationUIModel</code>是组件渲染所需的数据。这是UIComponent的输入。</li><li id="bd87" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe oi oj ok ol b">NotificationView</code>是定义组件UI的SwiftUI视图。它将<code class="fe oi oj ok ol b">NotificationUIModel</code>视为附属国。这个视图是UIComponent在屏幕上呈现时的输出。</li></ul><h2 id="a225" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated">2.<strong class="ak">基于API响应构建UIComponents】</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主页控制器. swift</p></figure><ul class=""><li id="9bc0" class="mv mw it lb b lc ld lf lg li nr lm ns lq nt lu nc nd ne nf bi translated"><code class="fe oi oj ok ol b">HomePageController</code>从存储库中加载服务器组件，并将它们转换成UIComponents。</li><li id="5820" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe oi oj ok ol b">uiComponent</code>的属性负责保存UIComponents的列表。用<code class="fe oi oj ok ol b">@Published</code>属性包装它使它成为可观察的。其值的任何变化都将发布到<code class="fe oi oj ok ol b">Observer(View)</code>。这使得<code class="fe oi oj ok ol b">View</code>与应用程序的状态保持同步成为可能。</li></ul><h2 id="2ebc" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated">3.<strong class="ak">在屏幕上渲染ui components</strong></h2><p id="c9d4" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这是最后一部分。屏幕唯一的职责就是渲染<code class="fe oi oj ok ol b">UIComponents</code>。它订阅了<code class="fe oi oj ok ol b">uiComponents</code>可观察值。每当<code class="fe oi oj ok ol b">uiComponents</code>的值改变时，就会通知<code class="fe oi oj ok ol b">HomePage</code>，然后更新它的UI。通用的<code class="fe oi oj ok ol b">ListView</code>用于呈现UIComponents。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主页视图</p></figure><p id="5044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通用的<code class="fe oi oj ok ol b">Vstack:</code>所有的UIComponents都使用内部的<code class="fe oi oj ok ol b">VStack</code>垂直渲染。由于UIComponents是唯一可识别的，我们可以使用<code class="fe oi oj ok ol b">ForEach</code>构造进行渲染。</p><p id="24fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于所有符合UIComponent协议的组件都必须返回一个公共类型，因此<code class="fe oi oj ok ol b">render()</code>函数返回<code class="fe oi oj ok ol b">AnyView</code>。下面是将<code class="fe oi oj ok ol b">View</code>转换成<code class="fe oi oj ok ol b">AnyView</code>的扩展。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5073" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="c177" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们看到了如何使用<code class="fe oi oj ok ol b">UIComponent</code>让服务器控制应用程序的UI。但是有了<code class="fe oi oj ok ol b">UIComponents</code>你可以获得更多。</p><p id="33be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一个没有服务器驱动UI的情况。通常情况下，UI的各个部分会在应用程序中多次使用。这导致了视图和视图逻辑的重复。因此，最好将UI分成有意义的、可重用的UI组件。</p><p id="3814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方式，领域层/业务层可以定义和构造UI组件。此外，业务层可以负责控制UI。</p><p id="5707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在GitHub上找到<a class="ae ky" href="https://github.com/AnupAmmanavar/SwiftUI-Server-Driver-UI" rel="noopener ugc nofollow" target="_blank">项目</a>。</p><p id="2887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看文章“<a class="ae ky" href="https://medium.com/better-programming/create-a-component-based-architecture-in-android-jetpack-compose-96980c191351" rel="noopener">Android Jetpack Compose——创建一个基于组件的架构</a>、“<strong class="lb iu">T5”，里面详细解释了UI组件。由于它使用Jetpack compose-Android的声明式UI套件，因此不难理解。</strong></p></div></div>    
</body>
</html>