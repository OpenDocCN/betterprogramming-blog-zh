<html>
<head>
<title>Kubernetes Authentication Sidecars: A Revelation in Microservice Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes认证边车:微服务架构的启示</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-authentication-sidecars-a-revelation-in-microservice-architecture-12c4608189ab?source=collection_archive---------3-----------------------#2022-09-12">https://betterprogramming.pub/kubernetes-authentication-sidecars-a-revelation-in-microservice-architecture-12c4608189ab?source=collection_archive---------3-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f2dc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">身份验证的历史以及如何在Kubernetes中使用sidecar容器以可重用的方式解决身份验证</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a58140ca4bd8fed977a0f8a213defcc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_BpWdRRlWycpi6QtLSq5A.png"/></div></div></figure><p id="cf54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为软件工程师，我们花了太多的时间来设置认证和调试与认证相关的问题。我们都曾经掉进过这样的兔子洞，在那里我们的身份验证方法并不完全符合我们的预期，我们失去了几天(和头发)抓耳挠腮！</p><p id="aed7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着微服务的普及，越来越多的服务需要我们实现身份验证。在任何组织中，现在都有数百种不同的身份认证处理方式，并且使用了许多不同的库。</p><p id="ed70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着时间的推移，我们已经学会了卸载一些跨领域的问题，比如负载平衡器、API网关和反向代理的SSL终止和IP授权。最近，像Istio和Linkerd这样的服务网格出现了，通过使用与我们的服务运行在同一个Kubernetes pod中的sidecar容器，帮助我们在更接近我们的应用运行的地方解决了一些问题。</p><p id="5ac9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">sidecar方法也可以用来卸载身份验证，这样我们的定制应用程序就不需要担心这个问题了。这篇文章展示了如何使用ASP.NET YARP作为反向代理来验证下游应用程序的请求。然而，任何技术都可以用于下游应用程序，只要它使用HTTP。</p><p id="8423" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里讨论的反向代理思想并不特定于。并且可以使用大多数web技术来实现。</p><p id="5252" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">认证代理的完整代码可以在我的GitHub <a class="ae ln" href="https://github.com/matt-bentley/AuthenticationProxy" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="9155" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">认证的历史</h1><p id="7956" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">因此，在我们研究使用sidecars解决我们的身份验证问题之前，让我们先来看看身份验证是如何发展的。</p><h2 id="859f" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">Cookie身份验证</h2><p id="97d7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Cookies已经被用于验证前端应用程序有一段时间了，但是传统上它们有一些缺点:</p><ul class=""><li id="a385" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">CSRF攻击——CSRF攻击是一种迫使用户发出附带cookie的意外请求的攻击。</li><li id="1e85" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">会话cookie——cookie通常是有状态的，并且绑定到特定的服务器，这使得加载和平衡我们的应用程序变得很困难。这也使得它们很难用于认证我们的前端应用程序的API。</li></ul><h2 id="949f" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">JWT认证</h2><p id="f16b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">JSON Web令牌出现了，它通过提供自我验证的无状态令牌帮助我们解决了cookies的一些缺点。jwt可以被解码以检索用户的声明，并使用公钥在任何服务器上进行验证。</p><p id="76dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于这些原因，近几年来，JWTs被推广者视为认证的圣杯…不幸的是，我们的故事并没有就此结束！使用jwt有一些人们经常忽视或不理解的主要缺点(如果你想了解更多，这里有一篇很棒的文章解释<a class="ae ln" href="https://redis.com/blog/json-web-tokens-jwt-are-dangerous-for-user-sessions/" rel="noopener ugc nofollow" target="_blank"/>):</p><ul class=""><li id="bdc8" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">撤销-不能撤销JWT。即使JWT被泄露，它仍然有效，直到过期，从而导致严重的安全漏洞。</li><li id="f8dc" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">XSS攻击—jwt通常存储在浏览器的本地存储中，这使得它们容易受到跨站点脚本攻击。当攻击者在您的网站上运行恶意JavaScript来提取JWT并将其发送到其他地方时，就会发生XSS。</li></ul><h1 id="b0c5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">网络安全拯救世界！</h1><p id="ee68" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">幸运的是，随着时间的推移，cookies和jwt的许多问题已经被安全特性所阻止:</p><ul class=""><li id="5442" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">SameSite的cookie策略——现在可以在cookie上定义cookie策略，以限制它们在不同站点之间的使用。如果使用了<code class="fe nl nm nn no b">Strict</code>或<code class="fe nl nm nn no b">Lax</code>，则限制跨站点使用。</li><li id="ead9" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">“HttpOnly”cookie—cookie现在可以标记为http only，这可以防止客户端脚本访问它们以阻止XSS攻击。</li><li id="8ca7" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" href="https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/configuration/overview?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">数据保护密钥</a> —用于加密cookie的密钥现在可以安全地集中存储，以便分布式计算可以与cookie一起使用。</li><li id="8f4f" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">CORS和CSPs现在可以在浏览器中实施CORS和内容安全策略，以防范CSRF和XSS的攻击。</li></ul><h2 id="7ba6" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">jwt都死了；饼干万岁！</h2><p id="62c4" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">好吧，你可以对这个标题有所保留……jwt仍然是验证用户身份的一个很好的方法，但是意识到风险是很重要的——确保使用短的过期时间，并且尽可能地限制服务器端的请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/14e6b641f4e894c795a78133bfe866ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/0*2zX2QWuh3LtK2lx-.jpg"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">饼干怪兽——鸣谢:facebook.com</p></figure><p id="0473" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了安全方面的好处，cookies通常会使我们的应用程序更加简单，因为我们不需要定制代码来将它们附加到请求中，也不需要挑战访问我们网站的未经验证的用户。</p><p id="278f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最近，人们开始将他们的jwt安全地存储在HttpOnly cookie中，以便两全其美。</p><h1 id="ce7b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">自我认证方法</h1><p id="335a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们需要实现的所有这些不同的选项和web安全策略听起来很复杂，不是吗？嗯，你是对的。认证有点像雷区，不是你想出错就能出错的！</p><p id="d503" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，知道了这一点，一般来说，我们的团队和服务自己执行所有的认证逻辑。当使用这种方法时，当我们创建一个新项目时，我们必须解决的第一件事就是身份验证。</p><p id="6cf3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用JWTs进行自我验证的典型过程如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/a813387f32f2aeebb3666c35cec43cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBgWwG7h1hPvdVxy9WqRrQ.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">自我认证方法</p></figure><p id="8e78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，jwt用于认证用户，这意味着我们的应用程序必须解决两个不同的问题:</p><ol class=""><li id="b7fb" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nv nd ne nf bi translated">必须在前端编写代码来检索访问令牌并将它们附加到请求上</li><li id="40ce" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nv nd ne nf bi translated">令牌必须经过服务器端验证，才能对用户进行身份验证</li></ol><p id="838a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有许多身份验证SDK可以提供帮助，团队通常用他们自己的库来扩展这些SDK。我们最终采用了这种方法，因为我们所有的开发人员都必须很好地理解这个问题，并且使用了大量不同的方法和库。</p><h1 id="0a6e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">边车认证方法</h1><p id="be10" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了减轻自认证方法的这些缺点，可以使用sidecar容器来代理对我们的服务的请求，并在请求到达我们的代码之前执行认证。</p><p id="cb02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">sidecar模式是一种解耦模式，其中服务的支持功能由附属于主服务的sidecar容器提供。Sidecars位于同一个Kubernetes Pod中，与其相关服务共享相同的生命周期，与服务一起创建和终止。</p><p id="a41b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">身份验证可以通过sidecar代理以多种不同的方式处理，但以下是我使用的方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a58140ca4bd8fed977a0f8a213defcc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_BpWdRRlWycpi6QtLSq5A.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">边车认证方法</p></figure><ul class=""><li id="ee4a" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">OpenId Connect with Authorization代码流用于质询未经身份验证的用户，并在身份验证后保存一个会话cookie</li><li id="080d" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nl nm nn no b">access_token</code>和<code class="fe nl nm nn no b">refresh_token</code>存储在cookie中。这允许任何sidecar实例使用cookie来刷新<code class="fe nl nm nn no b">access_token</code>,并将其发送给下游应用程序，以便它们可以在需要时使用它</li><li id="cff1" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">共享相同的数据保护密钥，以便cookie可以在不同的组件和实例上使用，例如负载平衡服务或另一个微服务</li><li id="ecda" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">用户的身份通过头传递给下游服务</li><li id="14fb" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">ASP。NET YARP(另一个反向代理)用于代理实现。参见下一节的实现</li><li id="2544" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">Cookies或jwt可以用来认证请求。如果在请求中传递了一个承载令牌，它将用于身份验证。否则，将使用cookies</li></ul><h2 id="e751" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">边车认证的好处</h2><p id="addb" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">实现身份验证代理相当复杂，但是这种方法的优点是只需要处理一次。还有其他一些好处:</p><ul class=""><li id="46e2" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">开发可以由拥有该领域专家的平台团队来处理</li><li id="8128" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">可以支持复杂的逻辑，如刷新令牌和支持多种身份验证方法和身份提供者</li><li id="6218" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">更容易迁移到新的协议和方法</li><li id="9843" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">应用程序团队根本不需要身份验证代码。由于cookies是默认使用的，它们将自动被我们的网站使用</li><li id="dd4c" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">通过头传递的身份使得测试更容易，我们可以在没有代理的情况下运行，或者创建一个模拟代理进行测试</li></ul><h2 id="6fe6" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">转发的声明和标题</h2><p id="d984" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">选择报头来传递标识信息，以便下游应用程序不需要额外的配置。jwt可以用于声明，但是下游应用程序需要知道发布机构以及如何验证jwt。</p><p id="a733" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，人们使用这种方法传递身份还有许多其他方式。希望随着时间的推移，越来越多的人采用这种技术，该行业将与一些推荐的最佳实践保持一致，不管是什么。</p><p id="5953" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nl nm nn no b">access_token</code>通过授权头传递给下游请求，以便下游应用程序可以使用它为用户发出额外的请求。不管是使用Cookies还是jwt来验证用户，都将向下游传递<code class="fe nl nm nn no b">access_token</code>。这是可能的，因为<code class="fe nl nm nn no b">access_token</code>存储在cookie中。</p><h1 id="f7d7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">ASP。网络YARP实现</h1><p id="beb9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><em class="nw">如果。NET不是你选择的武器，可以跳过这一节。无论您是否使用，本文的其余部分都适用。NET或其他语言的身份验证边车。</em></p><p id="90a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">YARP(又一个反向代理)是一个帮助创建高性能、生产就绪和高度可定制的反向代理服务器的库。YARP是建立在。NET使用来自ASP.NET的基础设施。YARP的关键区别在于它被设计成易于定制和调整。NET代码来满足每个部署方案的特定需求。</p><p id="d1c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过使用YARP，我们可以使用正常的ASP.NET HTTP请求管道，并在请求被YARP转发到我们的下游服务之前实现cookie和/或JWT认证。</p><p id="f2b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">认证代理的完整代码可以在我的GitHub <a class="ae ln" href="https://github.com/matt-bentley/AuthenticationProxy" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="b071" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">配置YARP网关的大部分代码可以在网关项目的<code class="fe nl nm nn no b">Program.cs</code>中找到。</p><p id="0e20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们分解<code class="fe nl nm nn no b">Program.cs</code>来看看是怎么回事:</p><h1 id="23c8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">证明</h1><p id="66b7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">默认情况下，用户使用OpenId Connect进行质询，并使用cookies进行身份验证。JWT承载认证也被添加为认证方案。<code class="fe nl nm nn no b">CustomAuthenticationSchemeProvider</code>用于选择合适的认证方案。稍后，我们将看到这是如何工作的。</p><p id="025b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用授权代码流作为流程。每次经过验证的请求通过管道时，都会检查<code class="fe nl nm nn no b">access_token</code>的到期时间，如果需要，还会使用<code class="fe nl nm nn no b">refresh_token</code>刷新令牌。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="6219" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">认证方案检测</h2><p id="b3df" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">自定义<code class="fe nl nm nn no b">AuthenticationSchemeProvider</code>用于检测使用哪种方案对用户进行身份验证。如果传递的授权头包含一个不记名令牌，那么将使用JWT。否则，将使用cookies。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="ddc3" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">批准</h2><p id="cf29" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">正常的ASP.NET授权管道也可以用在反向代理上。默认情况下需要一个经过身份验证的用户，并且创建了一个附加的管理策略，允许为特定的下游端点配置管理员列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="35b1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">YARP构型</h1><p id="4511" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">通过标准配置添加和配置YARP。网络配置。这里JSON文件被用来配置代理。稍后，我们将看到在部署到Kubernetes时如何对其进行定制。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a11d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">YARP可以对框外转发的请求执行许多不同的转换。添加了一个定制的<code class="fe nl nm nn no b">ClaimHeaderAppender</code>转换来提取声明并将它们作为头转发给下游服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d313" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果在原始请求中发现了用于转发声明的头名称，那么转换将删除它们，以防止攻击者假冒用户的身份。</p><h1 id="b5fe" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Kubernetes部署</h1><p id="db73" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在我们有了身份验证代理，我们可以将它部署为API网关或sidecar容器。</p><p id="3d90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们将把它部署为Kubernetes pods中的一个sidecar容器，以便所有流入pod的流量都经过身份验证。</p><h2 id="8a59" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">示例应用程序架构</h2><p id="4935" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我的GitHub repo有一个示例应用程序，它使用身份验证代理作为边盘。该应用程序包含一个Blazor WebAssembly单页应用程序和一个ASP.NET核心API。</p><p id="76c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Nginx入口控制器终止SSL，并将流量路由到Web和API pods。入口使用基于路径的路由，使用请求路径前缀将流量路由到适当的服务。流量通过<code class="fe nl nm nn no b">port 80</code>上的Kubernetes服务提供给吊舱。</p><p id="79d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">认证边车容器和服务容器分别使用<code class="fe nl nm nn no b">ports 8081 and 8080</code>，因此具有受限特权的用户可以用来运行容器(<code class="fe nl nm nn no b">USER 1000</code>)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/0a0f34fa9e7ff77262425a98eea165f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7UG-nG0sLpPYS8ZPo2bWA.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">示例应用程序架构</p></figure><h2 id="9e91" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">Kubernetes载货清单</h2><p id="2867" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">每个pod部署使用两个容器。下面显示了API部署:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7d4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nl nm nn no b">api</code>容器运行ASP.NET API，<code class="fe nl nm nn no b">gateway</code>容器运行认证代理。默认情况下，所有经过身份验证的流量都将由网关转发到pod上的<code class="fe nl nm nn no b">http://localhost:8080</code>。</p><p id="1e66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">API服务通过<code class="fe nl nm nn no b">port 8081</code>上的网关侧柜将流量路由到pod。如果不经过网关和身份验证，就不可能向pod发出请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0d47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，所有流量都必须经过身份验证，但是可以通过使用配置映射添加配置文件来覆盖YARP配置。</p><p id="1255" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用于API边车网关的<code class="fe nl nm nn no b">ConfigMap</code>执行以下操作:</p><ul class=""><li id="4021" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">使用匿名策略允许未经身份验证的流量进入API健康端点</li><li id="fa6b" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">使用管理策略将对<code class="fe nl nm nn no b">/api/admin/*</code>路由的访问限制为只有管理员(此处为<code class="fe nl nm nn no b">admin@dev-28752567-admin.okta.com</code>)才能访问</li><li id="a28e" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">对所有其他需要经过身份验证的用户的流量使用默认策略</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2b93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在Kubernetes已经成为大规模部署应用程序的事实方式，很可能会有更多的人开始采用sidecar模式来解决常见的横切关注点。</p><p id="5550" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的组织中有许多服务，那么构建自己的认证代理绝对是一项值得的投资！</p><p id="1660" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你觉得这篇文章很有趣。代码可以在我的GitHub <a class="ae ln" href="https://github.com/matt-bentley/AuthenticationProxy" rel="noopener ugc nofollow" target="_blank">这里</a>找到，如果你想看看的话！</p></div></div>    
</body>
</html>