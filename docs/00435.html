<html>
<head>
<title>Managing Sessions in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Django管理会话</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/managing-sessions-in-django-92ef72db4c63?source=collection_archive---------0-----------------------#2019-05-21">https://betterprogramming.pub/managing-sessions-in-django-92ef72db4c63?source=collection_archive---------0-----------------------#2019-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf43" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过示例了解您的Django会话</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/59b70629aed5ed42320d1fe97543108f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtyNuDtKCm2ZpL5dzT-83Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mimithian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米米·蒂安</a>在<a class="ae ky" href="https://unsplash.com/s/photos/session?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="9439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的文章“<a class="ae ky" href="https://medium.com/@goutomroy/managing-cookies-in-django-34981d9bf0ae" rel="noopener">在Django </a>中管理cookie”中，我讨论了cookie如何让我们轻松地在浏览器中存储数据。尽管毫无疑问cookies是有用的，但它们有以下问题:</p><ol class=""><li id="1f42" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">攻击者可以修改cookie的内容，这可能会破坏您的应用程序</li><li id="e7fa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们不能存储敏感数据</li><li id="9202" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们只能在cookies中存储有限的数据。大多数浏览器不允许cookie存储超过4 Kb的数据。将数据分成多个cookies会导致每个请求的开销过大。此外，你甚至不能依赖每个域的浏览器所允许的cookies数量。</li></ol><p id="9c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过会话轻松解决这些问题。</p><h2 id="0f50" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">会话是这样工作的:</h2><p id="49cc" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当我们使用会话时，数据并不直接存储在浏览器中。相反，它存储在服务器中。</p><p id="dace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Django创建一个惟一的32个字符长的随机字符串，称为会话密钥，并将其与会话数据相关联。</p><p id="ab89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，服务器向浏览器发送一个名为<code class="fe nh ni nj nk b">sessionid</code>的cookie，其中包含会话密钥作为值。</p><p id="9293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后续请求中，浏览器将cookie <code class="fe nh ni nj nk b">sessionid</code>发送给服务器。Django然后使用这个cookie来检索会话数据，并使它在您的代码中可以访问。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="b1e0" class="ns mk it bd ml nt nu nv mo nw nx ny mr jz nz ka mu kc oa kd mx kf ob kg na oc bi translated">会话配置</h1><p id="8baa" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为了在Django中建立一个会话，我们需要在我们的<code class="fe nh ni nj nk b">settings.py</code>中添加两件事情:</p><ul class=""><li id="a295" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu od mb mc md bi translated"><code class="fe nh ni nj nk b">‘django.contrib.sessions.middleware.SessionMiddleware'</code>到<code class="fe nh ni nj nk b">MIDDLEWARE</code></li><li id="03de" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated"><code class="fe nh ni nj nk b">'django.contrib.sessions'</code>至<code class="fe nh ni nj nk b">INSTALLED_APPS</code>。运行<code class="fe nh ni nj nk b">python manage.py migrate</code>来填充表格。该表有三列:<code class="fe nh ni nj nk b">session_key</code>、<code class="fe nh ni nj nk b">session_data</code>和<code class="fe nh ni nj nk b">expire_date</code>。</li></ul><p id="3847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们用<code class="fe nh ni nj nk b">startproject</code>命令创建一个新项目时，它们会被自动添加。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="31fd" class="ns mk it bd ml nt nu nv mo nw nx ny mr jz nz ka mu kc oa kd mx kf ob kg na oc bi translated">测试浏览器的Cookie保存能力</h1><p id="6151" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们知道用户可以配置他们的浏览器不接受任何cookie。因此，Django提供了一些方便的方法来检查浏览器中的cookies支持。<code class="fe nh ni nj nk b">request.sessions</code>对象提供了以下三种方法来检查浏览器中的cookies支持。</p><p id="0c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">set_test_cookie()</code>:设置一个测试cookie，判断用户的浏览器是否支持cookie。由于cookies的工作方式，在用户的下一个页面请求之前，您无法测试这一点。</p><p id="d00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">test_cookie_worked()</code>:根据用户的浏览器是否接受测试cookie，返回<code class="fe nh ni nj nk b">True</code>或<code class="fe nh ni nj nk b">False</code>。由于cookies的工作方式，你必须在之前单独的页面请求中调用<code class="fe nh ni nj nk b">set_test_cookie()</code>。</p><p id="49a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">delete_test_cookie()</code>:删除测试cookie。用这个清理你自己。</p><p id="1250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来讨论一个例子。</p><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="c221" class="mj mk it nk b gy oi oj l ok ol">def e_commerce_home(request):</span><span id="9e65" class="mj mk it nk b gy om oj l ok ol">    if request.session.test_cookie_worked():<br/>        request.session.delete_test_cookie()<br/>    else:<br/>        request.session.set_test_cookie()<br/>        messages.error(request, 'Please enable cookie')</span><span id="c72f" class="mj mk it nk b gy om oj l ok ol">    return render(request, 'home/home.html')</span></pre><p id="5f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户浏览这个页面时，它会检查浏览器中是否启用了cookie。如果没有，那么它会发送一个测试cookie并显示一条错误消息，以便在浏览器中启用cookie。如果浏览器接受cookie，那么它将删除先前发送的测试cookie。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="4434" class="ns mk it bd ml nt nu nv mo nw nx ny mr jz nz ka mu kc oa kd mx kf ob kg na oc bi translated">读取和写入会话数据</h1><p id="15c9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Django <code class="fe nh ni nj nk b">request</code>对象有一个<code class="fe nh ni nj nk b">session</code>属性，其作用类似于一个字典。</p><h2 id="780d" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">#设置会话数据</h2><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="34e0" class="mj mk it nk b gy oi oj l ok ol">request.session[‘user_id’] = ‘20’<br/>request.session[‘team’] = ‘Barcelona’</span></pre><h2 id="3476" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">#读取会话数据</h2><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="41e9" class="mj mk it nk b gy oi oj l ok ol">request.session.get(‘user_id’) # returns ‘20’<br/>request.session.get(‘team’) # returns ‘Barcelona’</span></pre><h2 id="9ab5" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">##删除会话数据</h2><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="c26b" class="mj mk it nk b gy oi oj l ok ol">del request.session[‘user_id’]<br/>del request.session[‘user_id’]</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="bbec" class="ns mk it bd ml nt nu nv mo nw nx ny mr jz nz ka mu kc oa kd mx kf ob kg na oc bi translated">SessionMiddleware的角色</h1><p id="d7c5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">让我们检查一下<code class="fe nh ni nj nk b">‘django.contrib.sessions.middleware.SessionMiddleware'</code>代码，了解一下它是做什么的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="c13d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu od mb mc md bi translated">中间件在视图被调用之前和之后被调用。<code class="fe nh ni nj nk b">process_request(self, request)</code>是之前消耗的，<code class="fe nh ni nj nk b">process_response(self, request, response)</code>是视图调用后消耗的。</li><li id="15ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated"><code class="fe nh ni nj nk b">process_request</code>检查<code class="fe nh ni nj nk b">request.COOKIES</code>中是否有名为<code class="fe nh ni nj nk b">sessionid(default value for settings.SESSION_COOKIE_NAME)</code>的cookie。如果找到，它会尝试使用会话数据库中的<code class="fe nh ni nj nk b">session_key</code>列填充会话。</li><li id="9a1f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated"><code class="fe nh ni nj nk b">process_response</code>检查<code class="fe nh ni nj nk b">request.session</code>是否被修改或创建。然后，它创建会话数据或将会话数据保存到会话数据库，并使用<code class="fe nh ni nj nk b">session_key value</code>将一个<code class="fe nh ni nj nk b">sessionid</code> cookie添加到响应中。如果它发现<code class="fe nh ni nj nk b">request.COOKIES</code>不为空，并且所有会话数据都被删除，那么它从数据库中删除会话行，并从响应中删除cookie，这也删除了浏览器中的cookie。</li></ul><p id="2382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建几个视图来清楚地理解它。</p><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="7bb0" class="mj mk it nk b gy oi oj l ok ol">def <strong class="nk iu">save_session_data</strong>(request):<br/>    # set new data<br/>    request.session['user_id'] = 20<br/>    request.session['team'] = 'Barcelona'<br/>    return HttpResponse("Session Data Saved")</span><span id="039a" class="mj mk it nk b gy om oj l ok ol">def <strong class="nk iu">access_session_data</strong>(request):<br/>    response = ""<br/>    if request.session.get('user_id'):<br/>        user_id = request.session.get('user_id')<br/>        response += "User Id : {0} &lt;br&gt;".format(user_id)<br/>    if request.session.get('team'):<br/>        team = request.session.get('team')<br/>        response += "Team : {0} &lt;br&gt;".format(team)<br/><br/>    if not response:<br/>        return HttpResponse("No session data")<br/>    else:<br/>        return HttpResponse(response)</span><span id="1118" class="mj mk it nk b gy om oj l ok ol">def <strong class="nk iu">delete_session_data</strong>(request):<br/>    try:<br/>        del request.session['user_id']<br/>        del request.session['team']<br/>    except KeyError:<br/>        pass<br/><br/>    return HttpResponse("Session Data cleared")</span></pre><p id="b447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是调用<code class="fe nh ni nj nk b">save_session_data()</code>视图时发生的情况。</p><ol class=""><li id="0126" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">'django.contrib.sessions.middleware.SessionMiddleware'</code>中间件创建一个新的随机会话密钥，并将会话数据与其相关联。</li><li id="d3c6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">'django.contrib.sessions.middleware.SessionMiddleware'</code>使用<code class="fe nh ni nj nk b">'django.contrib.sessions'</code>应用程序将会话数据存储在数据库中。</li><li id="cfd1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，在步骤1中生成的带有随机值(会话密钥)的名为<code class="fe nh ni nj nk b">sessionid</code>的cookie被发送到浏览器。</li><li id="0451" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">从现在开始，浏览器将把这个<code class="fe nh ni nj nk b">sessionid</code> cookie和每个请求一起发送到服务器，允许Python代码使用<code class="fe nh ni nj nk b">request.session</code>访问视图中的会话数据。</li></ol><p id="a595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nh ni nj nk b">save_session_data</code>之后调用<code class="fe nh ni nj nk b">access_session_data</code>时，<code class="fe nh ni nj nk b">sessionid</code> cookie在<code class="fe nh ni nj nk b">request.COOKIES</code>中可用。中间件的<code class="fe nh ni nj nk b">process_request</code>使用这个<code class="fe nh ni nj nk b">sessionid</code>来填充这个请求的会话。</p><p id="199f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nh ni nj nk b">delete_session_data</code>中，我们将删除所有会话数据。中间件识别出这个会话没有会话数据，所以它删除了会话行，也删除了响应cookie，从而删除了浏览器中的cookie。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="4c12" class="ns mk it bd ml nt nu nv mo nw nx ny mr jz nz ka mu kc oa kd mx kf ob kg na oc bi translated">保存会话时</h1><p id="a22f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">默认情况下，Django仅在会话被修改时保存到会话数据库，也就是说，如果它的任何字典值被分配或删除:</p><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="9632" class="mj mk it nk b gy oi oj l ok ol"><em class="op"># Session is modified.</em><br/>request.session['foo'] = 'bar'<br/><br/><em class="op"># Session is modified.</em><br/><strong class="nk iu">del</strong> request.session['foo']<br/><br/><em class="op"># Session is modified.</em><br/>request.session['foo'] = {}</span></pre><p id="adcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里值得一提的另一个要点是，Django只在会话数据被修改时才向浏览器发送会话cookie。在此过程中，它还会更新cookie的到期时间。</p><p id="d119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">会话数据库有三列:</p><p id="4aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">session_key</code>:存储唯一随机会话ID(或SID)</p><p id="6a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">session_data</code> : Django以编码格式存储会话数据。要获得原始数据，使用会话对象的<code class="fe nh ni nj nk b">get_decoded()</code>方法。</p><p id="496e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">expire_date</code>:会话cookie的到期日期</p></div></div>    
</body>
</html>