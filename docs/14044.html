<html>
<head>
<title>Evolving SwiftUI Architecture for Client-Server Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为客户端-服务器应用开发SwiftUI架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/evolving-swiftui-architecture-for-client-server-apps-1c2d449f890?source=collection_archive---------1-----------------------#2022-10-30">https://betterprogramming.pub/evolving-swiftui-architecture-for-client-server-apps-1c2d449f890?source=collection_archive---------1-----------------------#2022-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b6f2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将React.js学习应用于SwiftUI</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b7fe33eb079d7441984dca4b943c711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YhXkLYGbz0k_s0YeHZ9Dyg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">兰斯·安德森在Unsplash上拍摄的照片</p></figure><p id="ef1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上一个架构中，我们详细讨论了使用MV模式的<a class="ae lu" href="https://azamsharp.com/2022/10/06/practical-mv-pattern-crud.html" rel="noopener ugc nofollow" target="_blank"> SwiftUI架构。强烈建议你阅读那篇文章。在本帖中，我们将介绍如何使用从React.js框架中学到的模式和实践来创建SwiftUI客户端/服务器应用程序。</a></p><h1 id="c2cb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在React中使用JSON</h1><p id="cc2f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">React于2013年推出，这意味着React比SwiftUI领先约6年。React、SwiftUI和Flutter都是声明式框架，它们在本质上极其相似。我们可能不会使用React或Flutter来构建应用程序，但我们肯定可以从它们那里学习架构模式，并将其整合到我们的SwiftUI应用程序中。</p><blockquote class="ms mt mu"><p id="f577" class="ky kz mv la b lb lc ju ld le lf jx lg mw li lj lk mx lm ln lo my lq lr ls lt im bi translated">鼓励查看React项目的大型代码库，并了解他们如何实现自己的应用程序。由于两个框架的相似性，相同的技术可以应用于SwiftUI项目。</p></blockquote><p id="cb67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的代码中，您可以看到App组件(类似于SwiftUI视图)，它从一个API获取所有产品，然后将其显示在屏幕上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="edb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">App组件通过React挂钩使用本地/私有状态，如下面的实现所示:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="d668" class="ng lw it nc b gy nh ni l nj nk"><strong class="nc iu">const</strong> [products, setProducts] <strong class="nc iu">=</strong> useState([])</span></pre><p id="3690" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">fetch API用于消费JSON响应，然后最终填充组件的本地状态。</p><p id="728a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这相当于SwiftUI中的<code class="fe nl nm nn nc b">@State</code>。下面你可以找到SwiftUI中内容视图的完整实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="60d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用产品填充了private/local<code class="fe nl nm nn nc b">@State</code>, API调用是从我们的视图(视图模型)中进行的。</p><blockquote class="ms mt mu"><p id="c9dd" class="ky kz mv la b lb lc ju ld le lf jx lg mw li lj lk mx lm ln lo my lq lr ls lt im bi translated"><em class="it"> SwiftUI视图基本等同于React中的组件或者Flutter中的widgets。SwiftUI views充当视图模型。说到这里，你不应该把业务逻辑放在你的视图中(视图模型)。业务逻辑属于模型、域服务或服务器(客户机/服务器)应用程序。</em></p></blockquote><p id="3857" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上述方法的主要问题是，在任何其他视图中很难重用<code class="fe nl nm nn nc b">fetchProducts</code>，因为它是特定视图(视图模型)的一部分。</p><p id="79e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果您不打算在任何其他视图中展示产品，该怎么办呢？在视图(视图模型)内部实现<code class="fe nl nm nn nc b">fetchProducts</code>可以吗？</p><p id="ecac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使在其他视图中您可能不调用<code class="fe nl nm nn nc b">fetchProducts</code>,仍然建议将其移到指定的类中。通过这种方式，您可以随时随地灵活地调用它，还可以添加附加请求头、授权、缓存甚至测试等功能。</p><h1 id="65b0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">实施网络模型</h1><p id="5f81" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如前一节所述，将网络调用转移到一个单独的专用类中是一个好主意。这将允许您在单独的视图中轻松地重用网络呼叫。</p><p id="7fd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nl nm nn nc b">NetworkModel</code>的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e96d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以从<code class="fe nl nm nn nc b">ContentView</code>中直接调用NetworkModel类，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="ms mt mu"><p id="30a6" class="ky kz mv la b lb lc ju ld le lf jx lg mw li lj lk mx lm ln lo my lq lr ls lt im bi translated"><em class="it">你可能会问，如果网络模型只是一个有着花哨名字的网络服务。答案是肯定的……有点。网络模型和典型网络服务的主要区别之一是网络模型也可以存储状态。这由网络模型中的</em> <code class="fe nl nm nn nc b"><em class="it">products</em></code> <em class="it">属性表示。如果你有兴趣创建一个典型的网络层，那么你可以查看我以前的文章</em> <a class="ae lu" href="https://azamsharp.com/2022/10/06/practical-mv-pattern-crud.html" rel="noopener ugc nofollow" target="_blank"> <em class="it">这里</em> </a> <em class="it">。</em></p></blockquote><p id="054e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们甚至可以重构上面的代码来创建<code class="fe nl nm nn nc b">ProductListView</code>和<code class="fe nl nm nn nc b">ProduceCellView</code>。如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="ms mt mu"><p id="968d" class="ky kz mv la b lb lc ju ld le lf jx lg mw li lj lk mx lm ln lo my lq lr ls lt im bi translated">在上面的代码中，ContentView用作容器视图，ProductListView和ProductCellView是表示视图。容器视图用于包含其他视图(可重用视图)。容器视图的主要工作是向子视图提供数据。</p></blockquote><h1 id="acdf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">搜索</h1><p id="db26" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">大多数情况下，当您显示数据列表时，您还希望对数据执行不同的操作，如搜索和排序。让我们看看如何完成搜索的任务。</p><p id="fdfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用<code class="fe nl nm nn nc b">searchable</code>修饰符，这将允许我们创建一个搜索栏。我们还将使用<code class="fe nl nm nn nc b">onChange</code>修饰符，它将在每次用户在文本字段中输入内容时触发。<code class="fe nl nm nn nc b">onChange</code>修饰符调用performSearch函数，该函数搜索从networkModel返回的产品，并将其分配给filteredProducts数组。</p><p id="c595" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的私有属性<code class="fe nl nm nn nc b">products</code>如果不为空，则返回filteredProduct，否则返回所有产品的列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6bff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mv">swift ui中的ContentView也是一个视图模型，不执行任何业务逻辑操作。所有的业务规则都在服务器端运行，只有结果被发送回客户端(iOS App)进行显示。</em></p><p id="dd81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们看看排序，以及如何在我们的应用程序中实现排序。</p><h1 id="e2fe" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">整理</h1><p id="279e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们将允许用户根据产品的标题对产品进行升序或降序排序。<code class="fe nl nm nn nc b">SortDirection</code>实现如下:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="f647" class="ng lw it nc b gy nh ni l nj nk"><strong class="nc iu">enum</strong> <strong class="nc iu">SortDirection</strong> {<br/>    <strong class="nc iu">case</strong> asc<br/>    <strong class="nc iu">case</strong> desc<br/>}</span></pre><p id="78fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分类将通过按下按钮来执行。我们还需要切换按钮的文本。这是由本地@State属性执行的，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="05b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当sortDirection发生变化时，就会触发performSort函数。performSort负责按升序或降序对列表进行排序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d015" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mv">排序功能的核心是</em> <code class="fe nl nm nn nc b"><a class="ae lu" href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/" rel="noopener ugc nofollow" target="_blank"><em class="mv">sorted extension</em></a></code> <em class="mv">，它允许基于关键路径进行排序。这意味着，它是一个可重用的函数。</em></p><p id="46d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mv">您不必满足于整个应用程序只有一个NetworkModel类。单个网络模型可能适用于小型应用程序，但对于大型应用程序，您可以根据请求类型创建多个网络模型。这可以包括用户网络模型、帐户网络模型、产品网络模型、目录网络模型等。</em></p><h1 id="aa4c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">贮藏</h1><p id="c06b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">缓存允许您的客户端(iOS应用程序)从内存或文件系统获得响应，而不是一直到服务器。这可以极大地提高应用程序的性能。即使只有5-6秒的缓存(微缓存)也可以帮助您节省大量请求，并提高应用程序的性能。</p><p id="0bd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缓存层可以在网络模型中实现。缓存将在以后的文章中讨论，但是你可以看看下面的评论来了解一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ad90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时开发人员会在视图和网络之间增加一个中间层。我们喜欢将这一层称为聚合根模型，然后您的网络模型就变成了Webservice。那种方法在上一篇文章 <a class="ae lu" href="https://azamsharp.com/2022/10/06/practical-mv-pattern-crud.html" rel="noopener ugc nofollow" target="_blank"> <em class="mv">中讨论过，这里</em> </a> <em class="mv">。根据您的应用，您可以评估哪种架构更适合您的应用。</em></p><p id="57fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SwiftUI团队在使框架易于使用方面做了大量工作。有时，感觉如此简单，以至于我们开始质疑自己解决方案的有效性。使用React和Flutter时会有相同的体验。声明式用户界面给编程带来了新的概念和模式，这可能不太符合旧的原则。人们必须尝试不同的模式，并选择满足他们需求和标准的模式。</p><h1 id="6296" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="9339" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在本帖中，您了解了用于客户端/服务器应用程序的SwiftUI架构。该架构的灵感来自React应用程序。正如React之前提到的，Flutter和SwiftUI有很多相似之处，作为开发人员，我们应该总是尝试从更成熟的框架中学习。</p><h1 id="85e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">资源</h1><ul class=""><li id="ddc0" class="no np it la b lb mn le mo lh nq ll nr lp ns lt nt nu nv nw bi translated"><a class="ae lu" href="https://www.udemy.com/course/mv-design-pattern-in-ios-for-swiftui/?referralCode=4627986F77F533DEF0C7" rel="noopener ugc nofollow" target="_blank">iOS中的MV设计模式:以苹果的方式构建SwiftUI应用</a></li><li id="e38e" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lu" href="https://azamsharp.com/2022/10/06/practical-mv-pattern-crud.html" rel="noopener ugc nofollow" target="_blank"> SwiftUI架构——MV模式方法完全指南</a></li><li id="6b56" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lu" href="https://azamsharp.com/2022/10/11/embracing-core-data-in-swiftui.html" rel="noopener ugc nofollow" target="_blank">在SwiftUI中拥抱核心数据</a></li><li id="1351" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lu" href="https://azamsharp.com/2022/07/21/view-is-the-view-model.html" rel="noopener ugc nofollow" target="_blank"> SwiftUI视图也是一个视图模型</a></li></ul></div></div>    
</body>
</html>