<html>
<head>
<title>Get Started With WASM in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从《铁锈》中的WASM开始</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/get-started-with-wasm-in-rust-2347056bab4?source=collection_archive---------4-----------------------#2022-08-02">https://betterprogramming.pub/get-started-with-wasm-in-rust-2347056bab4?source=collection_archive---------4-----------------------#2022-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b986" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你未来发展的第一步，在JS中获得性能、强类型等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/151dcfe69f8ef2a488a5465883ef82bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3tuplcAChrIQQaSFRv-8fg.png"/></div></div></figure><p id="e3ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自推出以来，WASM已经成为开发社区中的一项重要技术。一些开发人员可能倾向于避免使用它，坚持使用JavaScript和TypeScript，这对于大多数用例来说是完全有效的设置。然而，WebAssembly为前端世界带来了无与伦比的性能和类型安全(不仅如此)。</p><p id="8643" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">WebAssembly(或WASM)是一种二进制语言，可以通过浏览器有效地转换成机器代码，这比JavaScript运行起来要高效得多。WASM允许像C、Rust和Zig这样的语言在浏览器中执行它们的代码(显然是沙箱化的)。</p><p id="226e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">WebAssembly不只是针对浏览器的。事实上，例如，Stellar正在构建自己的智能合同环境，以便在线执行WASM。这意味着网络组装将在各个行业扮演重要角色。</p><p id="07b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">速度是创建WASM的驱动因素，黑客将恶意的JavaScript代码注入易受攻击的网站，以加载wasm编写的代码，并执行繁重的计算，直接从网站访问者的CPU中挖掘加密，这证明了WebAssembly的性能与JavaScript相比完全处于另一个水平。</p><p id="8638" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管我很想谈谈wasm给游戏带来的潜在安全威胁，特别是因为我一直对做一些网络安全研究感兴趣并参与其中，这值得单独写一篇文章，但这篇文章不是。</p><p id="8187" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天，我们将介绍使用Rust构建WASM的基础知识，并从任何JavaScript代码中执行它(不需要捆绑器)。</p><p id="6db4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章要么是写给那些了解Rust基础知识并想看看它在浏览器上的功能有多强大的人，要么是写给那些好奇的JS开发人员，他们愿意改变他们的工具箱并学习WASM的基础知识。</p><h1 id="45b4" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">设置</h1><p id="5646" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">您将需要标准的Rust设置，如果您已经使用过该语言，我假设您的机器上已经有了这个设置。</p><p id="e8a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我建议安装cargo-generate，只需按几个键就可以在您的目录中设置基本的rustwasm:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="5a6b" class="ms lr it mo b gy mt mu l mv mw">cargo install cargo-generate</span></pre><p id="408d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还需要安装wasm-pack来从Rust构建(而不仅仅是)WebAssembly。命令如下:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="54db" class="ms lr it mo b gy mt mu l mv mw">curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh</span></pre><p id="77fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，您已经具备了开始工作所需的一切，让我们来创建我们的项目:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="1005" class="ms lr it mo b gy mt mu l mv mw">cargo generate --git <a class="ae mx" href="https://github.com/rustwasm/wasm-pack-template" rel="noopener ugc nofollow" target="_blank">https://github.com/rustwasm/wasm-pack-template</a></span></pre><p id="49e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将要求您输入项目名称。选择你认为更合适的。对于这篇文章，我决定用“测试”</p><h1 id="042e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">在JS中导入您的第一个Rust函数</h1><p id="83b0" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">您会注意到我们项目的结构看起来像大多数货物项目。<code class="fe my mz na mo b">src/lib.rs</code>文件(我们项目的根文件)是我们将编译到WASM的文件。然后，我们使用众所周知的<code class="fe my mz na mo b">Cargo.toml</code>文件来管理依赖关系、设置、元数据等等。</p><p id="6583" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开<code class="fe my mz na mo b">lib.rs</code>，让我们看看它目前的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ba1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个简单的启动模板，使用<code class="fe my mz na mo b">wasm-bindingen</code>导入JavaScript的alert函数，然后定义JS将来要调用的(public) <code class="fe my mz na mo b">greet</code>函数。如果启用了<code class="fe my mz na mo b">wee_alloc</code>特性，我们可以忽略将elfin分配器设置为全局分配器的行。</p><p id="36dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们想做两件事:</p><ol class=""><li id="fff2" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp ni nj nk nl bi translated">将rust代码编译成wasm</li><li id="e4c4" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated">从<code class="fe my mz na mo b">index.html</code>页面导入wasm并调用<code class="fe my mz na mo b">greet</code>函数。</li></ol><h2 id="a30b" class="ms lr it bd ls nr ns dn lw nt nu dp ma ld nv nw mc lh nx ny me ll nz oa mg ob bi translated">用铁锈代码建造WASM</h2><p id="76fc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">因为许多开发人员喜欢使用不同的捆绑器，所以我决定在本文中不使用捆绑器，这样读者就可以用一个简单的HTML文件来跟进。为此，我们将在使用<code class="fe my mz na mo b">wasm-pack</code>构建WASM时使用<code class="fe my mz na mo b">--target web</code>标志。</p><p id="f538" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在板条箱的目录中，运行以下命令:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="4377" class="ms lr it mo b gy mt mu l mv mw">wasm-pack build --target web</span></pre><p id="8ef3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将在<code class="fe my mz na mo b">./pkg</code>文件夹中生成一些文件。在这些文件中，有wasm二进制文件(<code class="fe my mz na mo b">projectname_bg.wasm</code>)和一个js文件(<code class="fe my mz na mo b">projectname.js</code>)，为在JavaScript中加载WASM函数提供了一个方便的API。</p><h2 id="f8fa" class="ms lr it bd ls nr ns dn lw nt nu dp ma ld nv nw mc lh nx ny me ll nz oa mg ob bi translated">运行问候功能</h2><p id="d8fc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在项目的根目录下，创建一个<code class="fe my mz na mo b">index.html</code>文件，并导入<code class="fe my mz na mo b">./pkg/projectname.js</code>文件。这将允许您初始化wasm API并调用<code class="fe my mz na mo b">greet()</code>函数。HTML文件应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="74f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您现在服务于<code class="fe my mz na mo b">index.html</code>文件(我使用的是snowpack，所以<code class="fe my mz na mo b">snowpack dev</code>在根目录中)，您将看到由<code class="fe my mz na mo b">greet()</code>函数调用的警告弹出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/fbcb94fb4847894ecf53d48ffa50b6b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBNyJ4ZPdvUC_sY7keYyFA.png"/></div></div></figure><h1 id="b1b0" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">修改DOM</h1><blockquote class="od oe of"><p id="d6f0" class="ku kv og kw b kx ky ju kz la lb jx lc oh le lf lg oi li lj lk oj lm ln lo lp im bi translated">本节假设您已经阅读了上一节。</p></blockquote><p id="1082" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上部分提供了在浏览器中加载Rust所需的几乎所有内容。您可能还想知道如何直接从Rust修改DOM。在这一段中，我将快速向您展示如何操作。</p><p id="7486" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，将web-sys依赖项添加到您的<code class="fe my mz na mo b">Cargo.toml</code>文件中:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="15ea" class="ms lr it mo b gy mt mu l mv mw">[dependencies.web-sys]<br/>version = "0.3.4"<br/>features = [<br/>  'Document',<br/>  'Element',<br/>  'HtmlElement',<br/>  'Node',<br/>  'Window',<br/>]</span></pre><p id="1757" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们必须添加一个函数，使用<code class="fe my mz na mo b">web-sys</code>来调用浏览器窗口，然后访问DOM并添加标题到主体。</p><p id="9774" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们带有新功能的<code class="fe my mz na mo b">lib.rs</code>将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d743" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您现在重建板条箱(<code class="fe my mz na mo b">wasm-pack build --target web</code>，您将能够从您的<code class="fe my mz na mo b">index.html</code>文件导入<code class="fe my mz na mo b">add_heading</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="79cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次提供HTML，您将看到标题。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="a823" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">鉴于围绕WASM的主题数量众多，本文将是一个系列的开始，尤其是在讨论优化与WebAssembly接口的应用程序以更好地适应wasm线性内存模型时。</p><p id="7478" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这篇文章能帮助你开始使用Rust和WASM，或者至少对尝试这项技术感到好奇。最终，我认为WebAssembly做出的承诺足以抓住我的注意力，并且可能会抓住你的注意力。谈到wasm，它还允许用Rust编写Cloudflare workers，实现了最快的无服务器体验之一。</p><p id="ae2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">鉴于我对Cloudflare workers 的兴趣，请继续关注我计划写的这篇文章<a class="ae mx" rel="noopener ugc nofollow" target="_blank" href="/create-and-deploy-your-first-javascript-serverless-worker-e234f3f69cea">。</a></p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="101b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>