<html>
<head>
<title>How To Monitor Internet Connection in Android Using Kotlin and LiveData</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Kotlin和LiveData监控Android中的互联网连接</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-monitor-internet-connection-in-android-using-kotlin-and-livedata-135de9447796?source=collection_archive---------0-----------------------#2021-07-27">https://betterprogramming.pub/how-to-monitor-internet-connection-in-android-using-kotlin-and-livedata-135de9447796?source=collection_archive---------0-----------------------#2021-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8048" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">增强应用程序的离线功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c7936cde7ea6b61ff9545141e6cf9090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oMxSa9oxnKeKYGdk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@szolkin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">谢尔盖·佐尔金</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="63b5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="df27" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如今，任何移动应用程序的基本要求之一就是互联网连接。如果你曾经使用过任何移动应用程序，你可能会看到一个红色或绿色背景的小横幅，根据应用程序的用户界面，在屏幕的顶部或底部指示网络连接状态。</p><p id="c3f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">实现这个特性有两个好处。首先，用户知道他们是离线的，所以他们可以采取适当的行动。第二，如果你正确地实现了它，你的用户界面会很美观。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="8866" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">先决条件</h1><p id="fa8a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是一个看似容易处理的特性，但需要对<code class="fe ne nf ng nh b">ConnectivityManager</code>中的工作原理有更深的理解。这里我们使用<code class="fe ne nf ng nh b">ConnectivityManager</code>来获取网络连接的信息，然后我们使用<code class="fe ne nf ng nh b">LiveData</code>将结果以密封的类格式传递给视图。我们还将使用Kotlin协同例程来解决Android APIs的实时问题。</p><p id="6143" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在继续之前，如果您不知道上面讨论的任何概念，请通读以下文章:</p><ul class=""><li id="46b6" class="ni nj it lt b lu mn lx mo ma nk me nl mi nm mm nn no np nq bi translated">"<a class="ae ky" href="https://medium.com/android-dev-hacks/exploring-livedata-and-kotlin-flow-7c8d8e706324" rel="noopener">探索LiveData和Kotlin流</a>"</li><li id="1aa1" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">"<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-kotlin-sealed-classes-for-state-management-c1cfb81abc6a">如何使用Kotlin密封类进行状态管理</a>"</li><li id="d0d7" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006">科特林协程，从基础到高级</a></li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="9efd" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">密封类</h1><p id="5cfb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://kotlinlang.org/docs/sealed-classes.html" rel="noopener ugc nofollow" target="_blank">根据Kotlin文档</a>，密封的类和接口代表了受限的类层次结构，提供了对继承的更多控制。</p><p id="f7f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先创建一个简单的密封类，它有两种状态，网络可用和不可用。密封类非常适合这个目的，它们使得在类站点处理状态变得很容易。在我们的例子中，是风景。看看一个简单的密封类:</p><pre class="kj kk kl km gt nw nh nx ny aw nz bi"><span id="bf6a" class="oa la it nh b gy ob oc l od oe">sealed class NetworkStatus {<br/>    object Available : NetworkStatus()<br/>    object Unavailable : NetworkStatus()<br/>}</span></pre><p id="a05e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果需要，可以将消息作为参数传递给每个状态。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="a746" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">分析网络监视器类</h1><p id="42ec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将要创建的网络监视器类应该满足以下几点:</p><ul class=""><li id="2ab1" class="ni nj it lt b lu mn lx mo ma nk me nl mi nm mm nn no np nq bi translated">我们希望它能对视图和<code class="fe ne nf ng nh b">Lifecycle</code>感知做出响应。</li><li id="ff2d" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">它应该很容易跨组件重用。</li><li id="590f" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">它应该总是有更新的网络状态信息。</li></ul><p id="bc9d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这三点使我们的网络监视器类易于采用，并提供了强大的功能。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="c39b" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">利用LiveData</h1><p id="5aad" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了涵盖第一点和第二点，我们可以利用<code class="fe ne nf ng nh b">LiveData</code>。正如我们所知，<code class="fe ne nf ng nh b">LiveData</code>具有生命周期意识，并对视图<code class="fe ne nf ng nh b">Lifecycle</code>做出响应。我们可以用类型为<code class="fe ne nf ng nh b">NetworkStatus</code>的<code class="fe ne nf ng nh b">LiveData</code>来扩展我们的类。看一看:</p><pre class="kj kk kl km gt nw nh nx ny aw nz bi"><span id="2f1a" class="oa la it nh b gy ob oc l od oe">class NetworkStatusHelper() : LiveData&lt;NetworkStatus&gt;() { }</span></pre><p id="82db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将允许我们覆盖两个方便的函数，<code class="fe ne nf ng nh b">onActive</code>和<code class="fe ne nf ng nh b">onInactive</code>。我们可以使用这两个函数从系统中恢复和停止监视网络状态，这将在下一节中看到。这将解决我们的第一个问题。看看原始代码:</p><pre class="kj kk kl km gt nw nh nx ny aw nz bi"><span id="13b4" class="oa la it nh b gy ob oc l od oe">class NetworkStatusHelper() : LiveData&lt;NetworkStatus&gt;() {<br/><br/>    override fun onActive() {<br/>        super.onActive()<br/>    }<br/><br/>    override fun onInactive() {<br/>        super.onInactive()<br/>    }<br/>    <br/>}</span></pre><p id="013b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<code class="fe ne nf ng nh b">LiveData</code>作为事实的来源使得跨Android组件重用变得更加容易，这解决了我们的第二点。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="8dd9" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">监控网络连接</h1><p id="dcea" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一步是建立到系统的连接，通过该连接我们可以观察网络连接状态。这可以通过<code class="fe ne nf ng nh b">ConnectivityManager</code>完成。为了访问<code class="fe ne nf ng nh b">ConnectivityManager</code>，我们需要上下文，所以传递上下文最简单的方法是通过构造函数参数。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正在创建<code class="fe ne nf ng nh b">ConnectivityManager instance</code></p></figure><h2 id="fa13" class="oa la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">网络连接监听器</h2><p id="e01b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经创建了实例<code class="fe ne nf ng nh b">ConnectivityManager</code>，下一步是创建一个回调监听器来观察系统级网络连接的变化。这里我们用<code class="fe ne nf ng nh b">ConnectivityManager.NetworkCallback</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<code class="fe ne nf ng nh b">ConnectivityManager class</code>的简单网络监听器</p></figure><p id="d01d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为覆盖函数的名称是不言自明的，所以我跳过了解释部分。下一部分是使用覆盖函数来为我们服务。先说<code class="fe ne nf ng nh b">onAvailable</code>功能。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e080" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一步，我们从<em class="os"> </em> <code class="fe ne nf ng nh b">ConnectivityManager</code>实例中获取网络能力，然后检查它是否具有互联网能力。然后我们将维护一个有效网络的列表，如果列表不为空，我们显示<code class="fe ne nf ng nh b">network available</code>；else，<code class="fe ne nf ng nh b">not available</code>。</p><p id="35fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后是<code class="fe ne nf ng nh b">onLost</code>函数，我们从列表中删除网络并更新<code class="fe ne nf ng nh b">LiveData</code>。看一看:</p><pre class="kj kk kl km gt nw nh nx ny aw nz bi"><span id="866a" class="oa la it nh b gy ob oc l od oe">override fun onLost(network: Network) {<br/>    super.onLost(network)<br/>    <strong class="nh iu">valideNetworkConnections.remove(network)<br/>    announceStatus()</strong><br/>}</span></pre><p id="e54c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，每当网络的任何能力被更新时，就调用<code class="fe ne nf ng nh b">onCapabilitiesChanged</code>功能。在这里，我们将重新检查网络的互联网能力，并采取适当的行动。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe ne nf ng nh b">onCapabilitiesChanged function</code></p></figure><p id="f71a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，为了看到更大的图片，把所有的碎片放在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">完整的网络回拨设计</p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="8857" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">注册/注销connectivityManager回调</h1><p id="cc6d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最佳实践之一是通过在不需要时不使用系统资源来节省系统资源。为了在我们的网络监视器类中实现这一点，我们使用了LiveData的<code class="fe ne nf ng nh b">onActive</code>和<code class="fe ne nf ng nh b">onInactive</code>函数。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">网络监视器类的完整实现</p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="e3c7" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">观察Android组件的状态</h1><p id="8bff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，是时候使用我们的网络监视器从Android活动中观察网络连接的状态，并向用户显示适当的消息。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从任何Android组件观察连接状态</p></figure><p id="9ad4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以将这段代码添加到活动的<code class="fe ne nf ng nh b">onCreate</code>函数中。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="adae" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">Android APIs的问题</h1><p id="7975" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Android APIs中有一个缺陷。使用<code class="fe ne nf ng nh b">onAvailable</code>功能，它们发出网络连接状态，但不是该网络的实际能力，例如，如果它有实时互联网接入。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="cccd" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">解决办法</h1><p id="40f5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要检查网络是否有实时互联网连接，我们需要实际进行网络调用，并根据输出确定网络互联网能力。</p><p id="eb73" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为此，我创建了一个具有单一函数的<code class="fe ne nf ng nh b">InernetAvailablity</code> Kotlin对象。如果有互联网接入，函数的返回类型为<code class="fe ne nf ng nh b">Boolean</code>:<code class="fe ne nf ng nh b">true</code>；else，<code class="fe ne nf ng nh b">false</code>。看一看:</p><pre class="kj kk kl km gt nw nh nx ny aw nz bi"><span id="a714" class="oa la it nh b gy ob oc l od oe">object InernetAvailablity {<br/><br/>    fun check() : Boolean {<br/>        return try {<br/>            val socket = Socket()<br/>            <strong class="nh iu">socket.connect(InetSocketAddress("8.8.8.8",53))</strong><br/>            socket.close()<br/>            <strong class="nh iu">true</strong><br/>        } catch ( e: Exception){<br/>            e.printStackTrace()<br/>            <strong class="nh iu">false</strong><br/>        }<br/>    }<br/><br/>}</span></pre><p id="3152" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果套接字连接建立，没有任何异常，我们确定网络有一个互联网连接；否则，它不会。</p><p id="d72b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们需要在具有协程作用域的<code class="fe ne nf ng nh b">onAvailable</code>和<code class="fe ne nf ng nh b">onCapabilitiesChanged</code>函数中执行这个操作，并且只有当它具有互联网功能时，我们才需要将网络添加到列表中。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查网络的互联网功能</p></figure><p id="b39f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">网络监控实施</p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="e0c0" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">奖金</h1><p id="fa81" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我最近看到了Satya Pavan Kantamani发表的这篇关于Kotlin协程的优秀文章，强烈推荐:</p><div class="ot ou gp gr ov ow"><a rel="noopener  ugc nofollow" target="_blank" href="/asynchronous-programming-with-kotlin-coroutines-5b3417f53ac6"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">用Kotlin协程进行异步编程</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">用协程程序编写阻塞和非阻塞代码</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">better编程. pub</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><p id="c8c4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读！</p></div></div>    
</body>
</html>