<html>
<head>
<title>A Common Misconception About Async/Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中关于Async/Await的一个常见误解</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-common-misconception-about-async-await-in-javascript-33de224bd5f?source=collection_archive---------0-----------------------#2018-02-19">https://betterprogramming.pub/a-common-misconception-about-async-await-in-javascript-33de224bd5f?source=collection_archive---------0-----------------------#2018-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9285" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们应得的英雄</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9370cb278f963fc34379ab2a37a28754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wjqsYrphc4J-yJgSntutJA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加布里埃尔·古斯芒在<a class="ae ky" href="https://unsplash.com/s/photos/sync?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="67cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用promises，我们编写模拟同步代码的异步代码，但是使用<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>，我们编写的异步代码<em class="lz">看起来像</em>同步代码。因此，这往往会导致误解。</p><p id="5c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定写这篇文章，因为自从引入了<a class="ae ky" href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" rel="noopener ugc nofollow" target="_blank"> async/await，</a>以来，我注意到许多开发人员在理解什么是顺序执行时遇到了更多的困难(因为它总是异步执行的)。这些困难已经存在，但是<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>通过接近同步编程风格强调了这一点。</p><p id="df1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个简单的例子，在异步操作之前和之后写一条消息。我们将使用<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>和<code class="fe lv lw lx ly b">promise</code>来实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c7da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些开发人员倾向于认为用<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>编写的函数将总是被同步执行，因为如果我们在继续执行之前同步等待延迟的操作，代码看起来就像。</p><p id="9895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们用这段代码运行它，并与<code class="fe lv lw lx ly b">promise</code>版本进行比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="533f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是输出:</p><pre class="kj kk kl km gt mc ly md me aw mf bi"><span id="0e9d" class="mg mh it ly b gy mi mj l mk ml">(1) with await<br/>(1) before await<br/>(1) with promise<br/>(1) before promise<br/>(1) after all<br/>(1) after await<br/>(1) after promise</span></pre><p id="0434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，函数代码是连续运行的，直到第一次遇到<code class="fe lv lw lx ly b">await</code>。与承诺一样，由调用者决定代码是否按顺序执行。</p><p id="f8b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看更同步的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="149e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是输出结果:</p><pre class="kj kk kl km gt mc ly md me aw mf bi"><span id="39b9" class="mg mh it ly b gy mi mj l mk ml">(2) with await<br/>(2) before await<br/>(2) after await<br/>(2) with promise<br/>(2) before promise<br/>(2) after promise<br/>(2) after all</span></pre><p id="3907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果调用者不使用<code class="fe lv lw lx ly b">await</code>(或<code class="fe lv lw lx ly b">then</code> with promises)，那么你的代码就不会按顺序运行。这就是为什么<code class="fe lv lw lx ly b">async</code>/<code class="fe lv lw lx ly b">await</code>/<a class="ae ky" href="https://blog.lavrton.com/javascript-loops-how-to-handle-async-await-6252dd3c795" rel="noopener ugc nofollow" target="_blank">在使用</a> <code class="fe lv lw lx ly b">forEach</code>这样的结构时不能像预期的那样工作的原因。</p></div></div>    
</body>
</html>