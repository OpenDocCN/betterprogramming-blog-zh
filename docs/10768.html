<html>
<head>
<title>Invalidating All User Sessions With Rails and Devise Gem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rails和design Gem使所有用户会话无效</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/invalidating-all-user-sessions-with-rails-and-devise-gem-b457c15e0dc?source=collection_archive---------13-----------------------#2022-01-26">https://betterprogramming.pub/invalidating-all-user-sessions-with-rails-and-devise-gem-b457c15e0dc?source=collection_archive---------13-----------------------#2022-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="857d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们弄清楚如何从后端终止用户的所有会话，以处理来自IdP的反向通道注销请求。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2fb7ac95250ab8bd4b495f6ef21910b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p3BX3dpXitDXr0dB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Vyshnavi Bisani 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/managing-user-sessions-and-openid-connect-logout-eb886facd321">管理用户会话和OpenID连接注销</a>中，我们了解到其他注销规范推荐使用反向通道注销，因为它不受阻止第三方cookies的影响。</p><p id="c20c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们需要一种从后端管理用户会话的方法，这可能比简单地清除cookies和HTML5本地存储状态更复杂。在本文中，让我们看看如何使用Rails和设计gem来实现这一点。</p><h1 id="4330" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何设计使所有会话无效？</h1><p id="3b2b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/heartcombo/devise" rel="noopener ugc nofollow" target="_blank">device</a>是一个流行的用于认证的Rails库。Devise具有一种行为，即当密码被更改时，该用户的所有登录会话都被终止，但不是实时终止，而是在下一次向服务器发出请求时，该用户将被注销。让我们看看这个机制是如何工作的。</p><h2 id="3306" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">创建会话</h2><p id="11d8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面是<a class="ae ky" href="https://github.com/heartcombo/devise/blob/14863ba4c92cd9781a961be0486f0ea7dfe84144/lib/devise/models/authenticatable.rb#L233-L240" rel="noopener ugc nofollow" target="_blank">创建会话的逻辑</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="436e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">to_key()</code>只是一个获取记录方法id的函数(get <code class="fe ng nh ni nj b">user.id</code>)。<code class="fe ng nh ni nj b">authenticatable_salt</code>是一个获取散列密码的前30个字符的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5c22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户成功登录后，Devise将一对<code class="fe ng nh ni nj b">record.to_key</code>和<code class="fe ng nh ni nj b">record.authenticatable_salt</code>作为键和值写入session_store。例如，我使用Redis作为sesison_store，id和salt不加密地存储在Redis中，只有会话的id(Redis记录的键)被写入cookies。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/4b38ee3038a761ff84b8a9904c78f6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4L_0fxHDS1WGpDwBWQ0xg.png"/></div></div></figure><h2 id="2ce6" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">读取会话</h2><p id="fe50" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在对服务器的每个请求中，cookies都随请求一起发送。session_store(在本例中是Redis)通过键(cookies值)获取会话信息。根据会话信息，设备决定用户是否登录。阅读课的逻辑是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f8e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">to_apdapter.get()</code>是一种通过id获取用户记录的方法。(<code class="fe ng nh ni nj b">User.find()</code>)</p><p id="160e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果密码被更改(或密码被重置)，数据库中的值<code class="fe ng nh ni nj b">authenticatable_salt</code>将会改变，数据库中的salt和cookies中的salt之间的比较将会返回false。设计注销用户并删除cookies。</p><p id="767f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以存储在会话cookies中的salt依赖于密码。如果我们想让一个用户的所有会话无效，默认情况下，Devise提供了一种方法，那就是更改密码。这并不能满足我们的所有需求，因为我们还想在不更改密码的情况下终止所有会话。我们如何做到这一点？</p><h1 id="f5c7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用令牌扩展<code class="fe ng nh ni nj b">salt</code></h1><p id="42c1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将一个<code class="fe ng nh ni nj b">session_token</code>列添加到您的设计模型(例如用户)中，并覆盖设计<code class="fe ng nh ni nj b">#authenticatable_salt</code>方法以包含您的会话令牌:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e82b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在处理Backchannel注销的逻辑中，可以通过调用<code class="fe ng nh ni nj b">current_user.invalidate_all_sessions!</code>重置用户的<code class="fe ng nh ni nj b">session_token</code>来使会话cookie无效。</p><h1 id="7fb9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="42ee" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们以Rails和devise为例，说明了如何终止用户的所有会话来处理来自IdP的反向信道注销请求。总的想法是在数据库中存储一个令牌，将它附加到salt中，在每次请求时将cookies中的salt与数据库中的salt进行比较。如果我们想使一个用户的所有会话无效，就改变令牌！</p><h2 id="da9f" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">参考</h2><ul class=""><li id="6715" class="nl nm it lb b lc mn lf mo li nn lm no lq np lu nq nr ns nt bi translated"><a class="ae ky" href="https://makandracards.com/makandra/53562-devise-invalidating-all-sessions-for-a-user" rel="noopener ugc nofollow" target="_blank">设计:使用户的所有会话无效</a></li></ul></div></div>    
</body>
</html>