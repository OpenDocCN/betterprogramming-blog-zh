<html>
<head>
<title>Dispatch Tables in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的调度表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dispatch-tables-in-python-d37bcc443b0b?source=collection_archive---------1-----------------------#2018-12-24">https://betterprogramming.pub/dispatch-tables-in-python-d37bcc443b0b?source=collection_archive---------1-----------------------#2018-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4825" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用快速字典查找来动态运行函数，而不是使用缓慢、冗长、乏味的if-elif语句</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/924a4fed8cd5e7d4f071116ebb6e36d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vwS-eEG5US2L6_KN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="cd7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你曾经需要根据一个变量的值运行不同的函数吗？想到的第一种方法可能是一长串类似于C风格开关案例的<code class="fe lv lw lx ly b">if-elif</code>语句。</p><p id="8020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，有一个更好的选择:一个调度表<strong class="lb iu">。</strong></p><p id="a784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的调度表基本上是一个函数字典。这个概念不是Python特有的。事实上，这在计算机科学中很常见:</p><p id="dd3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">"调度表是指向函数或方法的指针表."(同前。: <a class="ae ky" href="https://en.wikipedia.org/wiki/Dispatch_table" rel="noopener ugc nofollow" target="_blank"> <em class="lz">维基百科</em> </a> <em class="lz"> ) </em></p><p id="1cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调度表是OOP中实现<a class="ae ky" href="https://en.wikipedia.org/wiki/Late_binding" rel="noopener ugc nofollow" target="_blank">后期绑定</a>最常见的方法之一。<strong class="lb iu"> </strong>后期绑定是指通过名字查找你希望在运行时被调用的函数，而不是硬编码。</p><p id="17cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看使用调度表意味着什么，您应该如何以及为什么利用它们，以及一个示例可能是什么样子。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2297" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">if-elif方法</h1><p id="e784" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们假设您有一个<code class="fe lv lw lx ly b">Date</code>对象，您需要根据它的工作日执行一个特定的函数。这是你利用一组<code class="fe lv lw lx ly b">if-elif</code>陈述的一种方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为了简单起见，让我们假设do_*函数已经在其他地方正确定义了。</p></figure><p id="a11f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相当标准，普通，无聊，Python代码。那有什么问题呢？</p><p id="37f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先也是最重要的，这段代码是<strong class="lb iu">丑陋和不优雅的</strong>。更糟糕的是，写出来容易出错。除非你使用的是一个多插件的现代编辑器，否则你可能会复制粘贴第一个if语句，这很有可能会引入一个bug。</p><p id="4d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，这个代码<strong class="lb iu">不健壮</strong>。各种情况的处理程序之间没有分离，整个逻辑被绑定到一大段代码中。</p><p id="1e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，这段代码效率低下。一串<code class="fe lv lw lx ly b"><em class="lz">if</em></code>是一个O(n)。不是世界上最糟糕的，但我们可以做得更好。</p><p id="ec34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怎么会？嗯，通过使用字典和知道函数是Python中的一等公民</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="8597" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">作为一等公民的职能</h1><p id="7ae6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">任何参与Python开发的人都听过这样的口头禅"<em class="lz">一切都是对象。</em></p><p id="7aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也适用于函数和方法，它们也是对象。一般来说，<strong class="lb iu">函数是Python </strong>中的一等公民。那是什么意思？该定义适用于支持其他实体通常可用的所有操作的编程语言的实体，例如:</p><ul class=""><li id="36aa" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">它们可以存储在变量中。</li><li id="1d87" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">它们可以作为参数传递给函数。</li><li id="2d4c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">它们可以从函数和方法中返回。</li></ul><p id="5a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所想象的，这为程序设计打开了一扇巨大的可能性之门。让我们来看看这个例子，在这个例子中，我们摆弄函数，把它们当作普通变量来传递:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f9a3b9791bd23ab33595de91ea4b6362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*_aski9qv8T3tG4Fsz9absw.png"/></div></figure><p id="030b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键点是第三行，我们将函数<code class="fe lv lw lx ly b">foo</code>赋给变量<code class="fe lv lw lx ly b">bar</code>，从这一点开始我们可以使用<code class="fe lv lw lx ly b">bar()</code>作为<code class="fe lv lw lx ly b">foo()</code>的别名。事实上，<code class="fe lv lw lx ly b">foo()</code>和<code class="fe lv lw lx ly b">foo</code>有着巨大的区别。前者是要求Python执行函数的函数调用。后者是内存中代表函数本身的对象。因此，我们甚至可以将一个函数作为另一个函数的参数来传递:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/6e65c87065e0b48bb1f7182876f0ae9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*jShc_11NhLLtU_mnsC8u2Q.png"/></div></figure><p id="c32d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很酷，不是吗？我们将一个函数传递给另一个函数，并在被调用函数的范围内调用和执行它。顺便说一下，多亏了这个特性，装饰者的整个概念才成为可能。如果你想进一步了解这个话题，我推荐你阅读丹·巴德的这篇<a class="ae ky" href="https://dbader.org/blog/python-first-class-functions" rel="noopener ugc nofollow" target="_blank">优秀文章。</a></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ea12" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Python中的调度表</h1><p id="478a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">那么，我们如何利用这一切来构建Python中的调度表呢？嗯，字典在这里派上用场了。让我们看看如何使用调度表编写与使用<code class="fe lv lw lx ly b">if-elif</code>方法编写的算法完全相同的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">就像以前一样，我们假设do_*函数已经在其他地方定义过了。</p></figure><p id="b315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看出窍门了吗？我们将每个函数分配给一个我们认为方便的键，在本例中是对<code class="fe lv lw lx ly b">Date</code>对象的<code class="fe lv lw lx ly b">weekday()</code>方法的结果。然后，我们使用调度字典来检索与该函数相关联的对象。最后，我们要求Python通过添加<code class="fe lv lw lx ly b">()</code>来执行这个函数。</p><p id="9b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于一系列重要的原因，这种方法更可取。</p><p id="cec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">代码更少更干净</strong>，可读性更好，而且不需要添加一长串<code class="fe lv lw lx ly b">if-elif</code>语句。</p><p id="134e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码是<strong class="lb iu">的方式更加健壮</strong>。各种类型的处理程序是适当分开的。整个调度机制不需要知道关于处理程序的任何具体信息。</p><p id="6e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为前一点的直接结果，<strong class="lb iu">分派机制独立于使用它的代码</strong>。虽然对于我们的具体例子来说可能不是这样，但是如果您需要启用更多的功能或者禁用现有的功能，您只需要对调度字典做一点小小的修改，而不需要改变逻辑本身。这种松散耦合通常是软件工程中理想的设计模式。</p><p id="c6a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像上面的樱桃一样，你正在<strong class="lb iu">将一个O(n)算法转换成O(1) </strong>。Python中的字典是散列表，所以查找过程需要一个恒定的时间，而<code class="fe lv lw lx ly b">if-elif</code>复合需要对整个语句集进行线性扫描。</p></div></div>    
</body>
</html>