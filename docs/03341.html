<html>
<head>
<title>Firebase Storage Gotchas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase存储陷阱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/firebase-storage-gotchas-63a7cfef7677?source=collection_archive---------14-----------------------#2020-02-04">https://betterprogramming.pub/firebase-storage-gotchas-63a7cfef7677?source=collection_archive---------14-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="696f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我在实施私有资产和恢复两天工作时学到的Google云存储要点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9687d8a7df0fe1602b28f1cb89666d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58twqItpOjtMRuQquE2l5w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@element5digital?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Element5数码</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="fd05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你上一次恢复几个工作日是什么时候？</p><p id="d9f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我花了一些时间来为我们的web演示编辑器<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>的每个用户创建私有资产和内容。</p><p id="4217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个工作日之后，我终于注意到我误解了<a class="ae ky" href="https://firebase.google.com/docs/storage" rel="noopener ugc nofollow" target="_blank"> Google云存储</a>的一个基本点，我发现我必须恢复我的新实现，因为我们的资产实际上已经是私有的了。</p><p id="ddaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我写这篇新博客的原因，希望我的“不幸”经历可以在未来帮助其他人。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4acc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">规则:存储没有访问Firestore的权限</h1><p id="1a6f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时候，当事情没有被写下来，我会问自己，是因为它们不可能还是因为它们实际上是可能的。</p><p id="50fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够通过查询<a class="ae ky" href="https://firebase.google.com/docs/firestore" rel="noopener ugc nofollow" target="_blank"> Firestore </a>来编写存储规则就是其中之一，答案是<em class="mz">否</em>T13】。目前无法从其他产品访问Firebase产品。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9725" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">规则:用户读写权限</h1><p id="b697" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以将对存储器的访问、读取和写入限制为仅授权用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是上述规则仍然意味着用户可以覆盖其他用户提供的数据。为了克服这个问题，我们可以在存储中的每个用户的数据前加上他们各自的<code class="fe nc nd ne nf b">userId</code>。</p><p id="7a70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您使用的是<a class="ae ky" href="https://github.com/firebase/firebase-js-sdk" rel="noopener ugc nofollow" target="_blank"> Firebase JavaScript SDK </a>，上传将如下所示:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="32b3" class="nk md it nf b gy nl nm l nn no">const ref: Reference =<br/>      firebase.storage().ref(`${userId}/assets/photo.jpg`);<br/><br/>await ref.put(data);</span></pre><p id="0759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦存储文件在该结构中排序，我们就能够定义如下规则，该规则仅允许用户在各自的存储文件夹中写入和读取数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5f7c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">格式:存储参考</h1><p id="a456" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要使用授予的规则访问权限访问公共文件或私有文件，存储URL可以由以下部分组成:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="e34a" class="nk md it nf b gy nl nm l nn no">&lt;img src={`https://firebasestorage.googleapis.com/v0/b/${projectId}.appspot.com/o/${encodeURIComponent(path)}?alt=media`}/&gt;</span></pre><p id="7225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中,<code class="fe nc nd ne nf b">${projectId}</code>是Firebase项目的ID,<code class="fe nc nd ne nf b">${path}</code>是存储中文件的路径(一个字符串),必须用<code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent" rel="noopener ugc nofollow" target="_blank">encodeURIComponent</a></code>进行编码才能兼容。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="adc8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">获取:使用OAuth 2安全地访问图像</h1><p id="3b9b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们定义上述规则或任何其他仅向经过身份验证的用户授予对存储的访问权限的规则，那么就有可能使用JavaScript通过<a class="ae ky" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth 2 </a>获取和加载图像，正如Bryan Burman在他的博客文章<a class="ae ky" href="https://www.twelve21.io/how-to-access-images-securely-with-oauth-2-0/" rel="noopener ugc nofollow" target="_blank"> <em class="mz">如何使用OAuth 2.0 </em> </a>中所显示的那样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3bcb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">downloadURL:公共但私有</h1><p id="ae7d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是我最大的“陷阱”,也是我恢复工作时间的原因。</p><p id="2618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是否使用，Firebase都会为上传到存储器中的每一项资产创建一个<code class="fe nc nd ne nf b">downloadUrl</code>,它是公开的，不受您的规则限制，并且可以在互联网上访问。</p><p id="e640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，因为该网址包含一个任何人都不可能猜到的<code class="fe nc nd ne nf b">token</code>，只要我们不与任何人分享，这些网址就是私有的。</p><p id="d529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这里的<code class="fe nc nd ne nf b">downloadUrl</code>使用令牌作为参数来授予对文件的访问权限。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="69f6" class="nk md it nf b gy nl nm l nn no">&lt;img src={`https://firebasestorage.googleapis.com/v0/b/${projectId}.appspot.com/o/${path}?alt=media&amp;token=4733325a-78ff-444d-a67c-01fd8ab30fe`}/&gt;</span></pre><p id="1a34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个过程中，这是我的一个转折点，我必须感谢道格·史蒂文森回答了我关于堆栈溢出的问题。</p><p id="87d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在没有绝对把握的情况下，我认为如果您从服务器端使用云解决方案来指示Firebase不生成这样的URL是可能的，但从web/客户端肯定是不可能的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ac5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">downloadUrl:生命周期</h1><p id="6a19" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Firebase存储令牌不会过期(参见<a class="ae ky" href="https://stackoverflow.com/a/42598354" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>)。</p><p id="eb92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在没有任何其他修改的情况下，我们的<code class="fe nc nd ne nf b">downloadUrl</code>也永远不会过期并保持可用。</p><p id="2f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有没有可能在Firebase控制台中使一个特定的URL无效。然而，一旦失效，Firebase将为选中的文件分别创建一个新的<code class="fe nc nd ne nf b">downloadUrl</code>和一个新的<code class="fe nc nd ne nf b">token</code>。</p><p id="74e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样值得注意的是，对于每次覆盖，Firebase还会生成一个新的<code class="fe nc nd ne nf b">token</code>。这意味着，例如，如果我们的应用程序的用户能够上传文件，那么每当他们再次上传文件而不改变其名称时，就会自动创建一个新的<code class="fe nc nd ne nf b">downloadUrl</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b550" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4c96" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就是这样，我想这就是我学习的总结。Firebase Storage绝对是一款不可思议的、对开发者友好的软件，并且<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>的每个用户的所有内容和资产都是私有的，直到他们决定公开分享他们的演示。</p><p id="b80d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到无限和更远的地方。</p><p id="6886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div></div>    
</body>
</html>