<html>
<head>
<title>How to Use React’s Context API and useContext() Hooks Effectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何有效地使用React的上下文API和useContext()钩子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-reacts-context-api-and-usecontext-hooks-effectively-ed98ad9343b6?source=collection_archive---------2-----------------------#2020-03-03">https://betterprogramming.pub/how-to-use-reacts-context-api-and-usecontext-hooks-effectively-ed98ad9343b6?source=collection_archive---------2-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ab87" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避免在上下文的帮助下对你的价值观和你的职能进行正确的操练</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c6fbb44e9f2a252deb620286ebe22d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMbnniXqU0ZfTMWkr2zumA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗伯特·霍维克在Unsplash<a class="ae ky" href="https://unsplash.com/s/photos/pattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><h1 id="c2b9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="f732" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在最近的工作中，由于React的单向数据流，我遇到了一个很常见的问题。在我的应用程序的高层，我打开了一个收银台抽屉，里面有用户选择订购的商品。在另一个低得多的组件中，我触发了这些项目的实际订购。订单成功下达后，我需要抽屉再次自动滑动关闭。</p><p id="9f69" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">跟了这么远？</p><p id="4875" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于我的应用程序的结帐过程的性质，在顶层的父组件(控制抽屉的打开或关闭状态)和抽屉内部的最终结帐子组件(包含下订单的按钮和功能)之间有很多中间组件。</p><p id="f1df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我想避免传递包含抽屉打开状态的属性和在订单成功时将抽屉状态切换回关闭状态的函数。其他中间组件都不需要这些道具，所以这是不需要的额外代码。然后我想到了一个解决方案——我听说过一些，但从来没有必要使用的东西:React的上下文。</p><p id="977b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">今天，我将详细介绍我是如何使用React的上下文API和它的<code class="fe ms mt mu mv b">useContext</code>钩子来避免对应用程序状态和函数的钻取。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="58b5" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">什么是React上下文API？</h1><p id="9d4a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我深入讨论如何使用<a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">上下文API </strong> </a> <strong class="lt iu"> </strong>来帮助解决我的问题之前，让我回顾一下它是什么以及它是如何工作的，这样我们就都在同一页上了。</p><p id="3967" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">React的官方文档在定义上下文方面做得最好:</p><blockquote class="ni nj nk"><p id="87a6" class="lr ls nl lt b lu mn ju lw lx mo jx lz nm mp mc md nn mq mg mh no mr mk ml mm im bi translated">上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。— <a class="ae ky" href="https://reactjs.org/docs/context.html#when-to-use-context" rel="noopener ugc nofollow" target="_blank">反应文件</a></p></blockquote><p id="87a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我在上面描述的场景中一样，React中的上下文是一种在应用程序中传递数据的方式，而不必通过树的每一层显式地传递属性。这是React内置的共享数据的方式，对于React组件树来说，这可以被认为是“全局的”。</p><p id="91fd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这方面的例子包括用户认证、首选语言或主题设置，或者像我的情况一样，子组件告诉父组件将其状态从打开的抽屉切换到关闭的抽屉。</p><p id="cb5e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">是的，您也可以使用Redux进行这种全局状态管理，但是设置Redux、它的动作和调度程序所需的样板代码对于一组相对简单的任务来说是一项额外的工作。另外，随着<a class="ae ky" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> React钩子</strong> </a>的发布，使用上下文变得比以前更容易了。</p><p id="1265" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，我们来谈谈如何使用React的上下文API和<code class="fe ms mt mu mv b">useContext</code>钩子。我将向您展示如何使用我自己的应用程序来实现它。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="7936" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">使用反应上下文</h1><p id="312d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用上下文API的第一件事是创建一个新的上下文文件。这个文件将保存任何数据变量、默认值和函数，当使用这个上下文时，您可能希望这些数据变量、默认值和函数对组件是可访问的。</p><h2 id="a2b3" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://reactjs.org/docs/context.html#reactcreatecontext" rel="noopener ugc nofollow" target="_blank"> React.createContext() </a></h2><p id="d504" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在您的上下文文件中，我倾向于将其命名为<code class="fe ms mt mu mv b">XyzContext.js</code>，您将<strong class="lt iu">创建<code class="fe ms mt mu mv b">Context</code>的这个特定实例</strong>，并为其分配一些默认值。</p><p id="8605" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我为应用程序创建的上下文文件，用于处理收银台的可见性及其可见性状态的切换。</p><p id="ad84" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">createContext()</code></p><p id="5f4e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">CheckoutDrawerContext.js</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/1d19d3e48701182dfa1c37b1e1cb95da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLeBIOHyP2yH-mU9YFEl0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实际上，使用上下文没什么大不了的，设置起来很简单。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4a7e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从我的代码片段中可以看出，创建一个新的上下文实例相对容易。在我的例子中，在调用了<code class="fe ms mt mu mv b">creatContext()</code>之后，我只是传入了一个对象，该对象带有一个关于收银台抽屉当前可见性的布尔值(<code class="fe ms mt mu mv b">showDrawer</code>，默认初始值为<code class="fe ms mt mu mv b">false</code>)和一个名为<code class="fe ms mt mu mv b">toggleCheckoutDrawer()</code>的空箭头函数，该函数最终将与一个实际影响抽屉显示或隐藏状态的函数相关联。</p><p id="bb1c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当React呈现订阅这个<code class="fe ms mt mu mv b">CheckoutDrawerContext</code>对象的组件时，它将从树中它上面最匹配的<code class="fe ms mt mu mv b">Provider</code>中读取当前上下文值。</p><p id="a0bd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">缺省值参数(在本例中为<code class="fe ms mt mu mv b">showDrawer</code>)是<em class="nl">唯一的</em>，当一个组件在树中没有匹配的提供者时使用。</p><p id="8afe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">既然已经创建了这个特定的上下文实例，我们可以继续在我的应用程序中使用它。</p><h2 id="2a05" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank">上下文。提供者</a>及其值</h2><p id="062f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">每个上下文对象都带有一个提供者React组件，该组件允许消费组件订阅上下文更改。</p><p id="9db5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">提供者接受传递给消费组件的<code class="fe ms mt mu mv b">value</code>属性，这些组件是该提供者的后代。同样值得一提的是，一个提供商可以连接到许多消费者。如果多个孩子需要知道或更改提供者的值，他们可以。</p><p id="748c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">Context.Provider</code></p><p id="997c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b"><strong class="lt iu">Cart.js</strong></code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/d982fb8f1628f5351e59c84226a88499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlK8B2h3WJhymIhwx2CNvQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同样，向现有组件添加上下文提供者相当容易，只需包装JSX并从组件传递必要的值或函数。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c9ee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于我的应用程序，在我的顶层<code class="fe ms mt mu mv b">Cart</code>组件中，我将我的<code class="fe ms mt mu mv b">CartDrawer</code>组件包装在我的<code class="fe ms mt mu mv b">CheckoutDrawerContext.Provider</code>中。我这样做是因为嵌套在<code class="fe ms mt mu mv b">CartDrawer</code>中的子组件需要访问<code class="fe ms mt mu mv b">CheckoutDrawerContext.Provider</code>包含的值——在本例中，是<code class="fe ms mt mu mv b">showDrawer</code>状态和<code class="fe ms mt mu mv b">toggleCheckoutDrawer()</code>函数。</p><p id="3efc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">至于传递给<code class="fe ms mt mu mv b">CheckoutDrawerContext.Provider</code>的值，我也是在<code class="fe ms mt mu mv b">Cart.js</code>文件中创建的。</p><p id="98db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">Context.Provider</code>值</p><p id="d4e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">Cart.js</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/9732c0610452d87df43eb7bb5eadbe5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZlBJcgIucBdGkxZP2V3Tg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这些功能一点都不复杂。但它们是我需要传递给上下文的。提供程序，这样它就知道在应用程序中触发同名占位符值时该做什么。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="5a70" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<code class="fe ms mt mu mv b">Cart</code>组件文件中的<code class="fe ms mt mu mv b">useState()</code> React钩子，我用它的setter创建了一个名为<code class="fe ms mt mu mv b">showDrawer</code>的状态来更新布尔值<code class="fe ms mt mu mv b">setShowDrawer</code>。我创建了一个名为<code class="fe ms mt mu mv b">toggleCheckoutDrawer()</code>的函数，它将把<code class="fe ms mt mu mv b">showDrawer</code>的值转换成它的相反值。</p><p id="106d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我在我的<code class="fe ms mt mu mv b">CheckoutDrawerContext</code>文件中用默认值命名了这些状态和函数，但是这并不是必须的——我这样做只是为了方便自己。</p><p id="7c08" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好的，现在<code class="fe ms mt mu mv b">Context.Provider</code>启动并运行，它有自己的值<code class="fe ms mt mu mv b">showDrawer</code>和<code class="fe ms mt mu mv b">toggleCheckoutDrawer()</code>。我准备好进入消费价值观部分了。</p><h2 id="b643" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://reactjs.org/docs/context.html#contextconsumer" rel="noopener ugc nofollow" target="_blank">做出反应。消费者</a>和<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">做出反应</a></h2><p id="3f43" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最初，当上下文第一次与React一起发布时，它只对有状态的、基于类的组件可用。</p><p id="26f5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上下文使用者的语法类似于提供者将其添加到项目中的语法——将使用者包装在需要访问值的代码周围，如下面的示例代码所示。</p><p id="2a94" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">React.Consumer</code>样品。</p><p id="4a43" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">ClassBasedChildComponent.js</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/01b4e400ac0e439335acb43f2c53279e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VC-m3aDhxg82Xw3JvIiwVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是一个基于类的上下文消费者的JSX看起来像什么的例子。</p></figure><p id="f8cf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是因为我的应用程序使用React钩子，而结帐流程是使用功能组件编写的，所以我为需要访问<code class="fe ms mt mu mv b">CheckoutDrawerContext</code>的组件利用了<code class="fe ms mt mu mv b">useContext()</code>钩子。在我看来，这是更干净的代码，更容易理解。</p><p id="2e48" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">React.useContext()</code></p><p id="dad2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">CheckoutSummaryDetails.js</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/3684cc392985173199ea57c5ba62a15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JibWRcVNKmlgkexty6UBDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是CheckoutSummaryDetails组件的精简版本，它使用useContext挂钩来切换收银台的打开或关闭。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="bdd8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的组件<code class="fe ms mt mu mv b">CheckoutSummaryDetails.js</code>是我的应用程序中实际结帐的一个非常精简的版本，但是它服务于这个例子的目的。</p><p id="a744" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，注意<code class="fe ms mt mu mv b">CheckoutDrawerContext</code>被导入到这个<code class="fe ms mt mu mv b">CheckoutSummaryDetails.js</code>文件中。为了实际访问这个上下文的值，我创建了一个新的常量(<code class="fe ms mt mu mv b">checkoutDrawer</code>)，并将命名的上下文包装在<code class="fe ms mt mu mv b">useContext()</code>钩子中。这使我能够访问<code class="fe ms mt mu mv b">CheckoutDrawerContext</code>中的值。剩下的就相当简单了。</p><p id="7d89" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当用户单击标题为“Order Now”的按钮时，组件中的<code class="fe ms mt mu mv b">placeOrder()</code>函数被触发，它触发对API或数据库或其他任何可能需要发送用户信息和所订购商品的地方的<code class="fe ms mt mu mv b">orderItems()</code>调用。当订单发出成功信息时，通过<code class="fe ms mt mu mv b">checkoutDrawer.toggleCheckoutDrawer()</code>触发关闭<code class="fe ms mt mu mv b">CartDrawer</code>的组件。这将把<code class="fe ms mt mu mv b">showDrawer</code>的状态切换到该组件树中更高的四或五层，从<code class="fe ms mt mu mv b">true</code>回到<code class="fe ms mt mu mv b">false</code>，并且<code class="fe ms mt mu mv b">CartDrawer</code>组件将再次从视图中隐藏。</p><p id="9df9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就是这样！React的上下文已经阻止了不必要的属性传递<em class="nl">和</em>允许子组件更新父组件的状态。太棒了。</p><p id="2fad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在没那么难了，是吗？相信我，一旦你成功地使用了一次上下文，在许多其他地方实现它就不在话下了。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="4955" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">结论</h1><p id="9d91" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">React的上下文API和<code class="fe ms mt mu mv b">useContext</code> Hook在理论上是相当容易理解的。第一次实施时，他们就不太清楚了。</p><p id="4695" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但他们帮了大忙。当只有第二层和第六层子组件真正需要这些属性时，通过组件树的几层传递不需要的数据是没有帮助的。这意味着需要跟踪更多的道具，即使所有的中间组件都不需要这些数据。</p><p id="9cd6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">是的，Redux可以做同样的事情，但是即使是最简单的数据也需要很多额外的设置。与Redux不同的是，Context是天生的React——它已经是内置的，随时可以使用，一旦您开始使用它，它就非常直观。一开始我很犹豫要不要试试，但是一旦想通了，我就成了大粉丝。我想你也会的。</p><p id="1b1b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">过几周再来看看——我会写更多关于JavaScript、React、ES6或其他与web开发相关的东西。</p><p id="b327" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢阅读。我希望我已经揭开了React的上下文API和<code class="fe ms mt mu mv b">useContext</code>钩子的神秘面纱，这样你就可以在你自己的React项目中成功地使用它。你不会后悔它使更干净的代码成为可能！</p><h2 id="7e51" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">如果你喜欢读这篇文章，你可能也会喜欢我在《更好的编程》中的其他文章:</h2><ul class=""><li id="2764" class="oi oj it lt b lu lv lx ly ma ok me ol mi om mm on oo op oq bi translated"><a class="ae ky" href="https://medium.com/better-programming/react-socks-and-responsive-web-design-with-react-63b766d000bd" rel="noopener">“React Socks和React响应式网页设计”</a></li><li id="c37f" class="oi oj it lt b lu or lx os ma ot me ou mi ov mm on oo op oq bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-pass-multiple-route-parameters-in-a-react-url-path-4b919de0abbe" rel="noopener">“如何在React URL路径中传递多个路由参数</a></li><li id="829a" class="oi oj it lt b lu or lx os ma ot me ou mi ov mm on oo op oq bi translated"><a class="ae ky" href="https://medium.com/better-programming/github-templates-the-smarter-way-to-formalize-pull-requests-among-development-teams-89f8d6a204f" rel="noopener">“GitHub模板:在开发团队中形式化拉取请求的更聪明的方法</a>”</li></ul></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="c2a7" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">参考资料和更多资源</h1><ul class=""><li id="8d78" class="oi oj it lt b lu lv lx ly ma ok me ol mi om mm on oo op oq bi translated">React <a class="ae ky" href="https://reactjs.org/docs/context.html#updating-context-from-a-nested-component" rel="noopener ugc nofollow" target="_blank">上下文API </a>文档</li><li id="8411" class="oi oj it lt b lu or lx os ma ot me ou mi ov mm on oo op oq bi translated">React钩子<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">使用上下文</a>文档</li></ul></div></div>    
</body>
</html>