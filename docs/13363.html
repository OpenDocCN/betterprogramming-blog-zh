<html>
<head>
<title>Styling Icons in React — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的图标样式—第一部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/styling-icons-in-react-part-i-1a99207a7bc?source=collection_archive---------2-----------------------#2022-08-20">https://betterprogramming.pub/styling-icons-in-react-part-i-1a99207a7bc?source=collection_archive---------2-----------------------#2022-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3467" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">从设计到代码</h2><div class=""/><div class=""><h2 id="d86d" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">一些设计和风格化你的反应图标的技巧。从你的矢量编辑器通过CSS，样式组件和…</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/9552979c3e26e0c9a21df5b6c898ed19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f1_sQCxvudDISEeS"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae le" href="https://unsplash.com/@russn_fckr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> russn_fckr </a>拍摄的照片</p></figure><p id="f884" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-an-icon-system-in-react-16757d73cc35">我之前关于图标的文章</a>中，我提到了一些管理定制图标系统的方法。现在，我们将处理在React环境中对单色图标应用样式的方法。</p><p id="3adb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你可以在这里找到一些关于设计的基本信息。为了更深入，我推荐阅读乔恩·希克斯写的<a class="ae le" href="https://hicks.design/shop/the-icon-handbook" rel="noopener ugc nofollow" target="_blank">图标手册，有些部分有点过时，但仍然非常有效。你也可以在网上找到许多其他资源。一些有趣的指南可以在</a><a class="ae le" href="https://iconutopia.com/" rel="noopener ugc nofollow" target="_blank"> Icon Utopia </a>找到。</p><h1 id="1f19" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">绘图设置</h1><p id="97d2" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我认为，决定设计一个图标集的最常见的原因是需要一个独特的设计，与你正在绘制的图形布局一致，或者需要一些你决定使用的集中没有的图标(混合不同的集几乎不是一个好主意)。</p><p id="6aae" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">要绘制图标集，你需要使用矢量编辑器，如<em class="my"> Illustrator </em>、<em class="my"> Inkscape </em>、<em class="my"> Affinity Designer </em>等。甚至<em class="my"> Figma </em>或<em class="my"> Sketch </em>，虽然不是真正的绘图软件，也可以用于非复杂元素的设计，当然也可以更容易地管理整套图标及其导出到SVG。</p><p id="0294" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从一些草图开始，规划你需要的图标。在画画之前，你还需要决定如何设置你的画布。每个图标通常建在一个正方形区域中。要确定画布的大小，你必须考虑绘图的容易程度(大的话更容易)和图标以实际大小显示的方式(每边可以是14-16px或更小)。非常大的画布会导致对尺寸的错误理解，使图标在真实尺寸下不可读。小的会很难画。</p><p id="6f62" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最终的选择取决于您想要创建的设计类型，在做出最终决定之前做一些测试可能是有用的。以我的经验来看，我一般会设置每边64或者96px的面积。</p><p id="d2fe" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">选择可被预定义的模及其倍数和约数整除的维数非常重要。例如，64和96px布局是为8px模块构建的，也可以被2、4、16和32整除。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="82b7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">设置图标集的最佳方式是将每个元素绘制到<strong class="lh ja">画板</strong>上。当文件导出为SVG时，画板定义它们的视图框，允许您更好地控制图标的位置。此外，您可以轻松地为它们定义网格和参考线。Illustrator在这方面很厉害。</p><div class="kp kq kr ks gt ab cb"><figure class="ng kt nh ni nj nk nl paragraph-image"><img src="../Images/cf5f6e83208bba82d592245065be413c.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*4rmjO18Vf-VReTnLQuW09A.png"/></figure><figure class="ng kt nm ni nj nk nl paragraph-image"><img src="../Images/8f3bd44a76e5920179b40c9f00de217e.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*DlvKqHRgg1UBJa9DtJg6cA.png"/><p class="la lb gj gh gi lc ld bd b be z dk nn di no np translated">illustrator和Inkscape中的图标布局</p></figure></div><p id="5c7e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我发现在Illustrator中管理同一个文件中的许多图标相当麻烦(尤其是在导出阶段)，在Inkscape中也不稳定。出于这个原因，如果可能的话，我更喜欢使用Sketch或Figma，只在最复杂的绘图时才切换到Illustrator。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/27d735f266b33bdc7b01f4f73244e571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98T5-nnIKogJphuG-xnzNA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">从我的一个旧项目中素描画板(更多关于<a class="ae le" href="https://www.behance.net/gallery/90567589/Ada-intranet-for-travel-agencies-%28v2-2020%29" rel="noopener ugc nofollow" target="_blank">行为</a></p></figure><h1 id="289e" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">填充与描边</h1><p id="4358" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">从图标字体切换到SVG，我的第一个图标是基于<em class="my">填充</em>，这是字体的自然方式。</p><p id="b6ed" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是尽管在某些情况下使用fill更容易管理，我很快意识到使用<code class="fe nr ns nt nu b">strokes</code>提供了更多的可能性。</p><p id="0492" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，对于笔画，只需改变其<code class="fe nr ns nt nu b">stroke-width</code>属性，就可以使同一图标具有不同的权重。使用填充，你必须为你需要的每个重量准备一个图标。</p><p id="e88e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">strokes提供的另一个可能性是能够方便地重用图标。一个图标集肯定包括几个常用的字形，您可能需要在其他项目中使用。但是使用<em class="my">填充</em>图标，这只有在你的设计使用相同的图标权重时才有可能。出于这个原因，对于<em class="my">填充</em>图标，我总是保留我的字形的笔画版本，以备将来重用。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/032b80c40ecd99895f34bd657d14cd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylDI6DgIsqRhNwqlY3sRyw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">在Illustrator的预览和大纲视图中，两个图标具有相同的字形。左边一个用<code class="fe nr ns nt nu b"><strong class="bd nw">fill</strong></code>，另一个用<code class="fe nr ns nt nu b"><strong class="bd nw">strokes</strong></code></p></figure><p id="256a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上图代表<em class="my">填充</em>和<em class="my">行程</em>模式下的同一图标。如您所见，尽管它们的结构不同，但在预览模式下看起来是一样的。</p><p id="8202" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你可以使用<em class="my"> SVG属性</em>或者<em class="my"> css </em>来轻松地将你的图标风格化(稍后会有更多的介绍)。基本的css代码是:</p><pre class="kp kq kr ks gt nx nu ny bn nz oa bi"><span id="8218" class="ob mc iq nu b be oc od l oe of">.fill-icon {<br/>  display: inline-block;<br/>  width: 1em;<br/>  height: 1em;<br/>  fill: currentcolor;<br/>  stroke: none;<br/>}<br/><br/>.stroke-icon {<br/>  display: inline-block;<br/>  width: 1em;<br/>  height: 1em;<br/>  fill: none;<br/>  stroke: currentcolor;<br/>  stroke-linecap: round;<br/>  stroke-linejoin: round;<br/>  stroke-width: 4px;<br/>}<br/>.stroke-icon.bold {<br/>  stroke-width: 8px;<br/>}</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="a365" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">非常简单，但是如果你必须同时管理填充和描边呢？您可能需要在您的<em class="my">笔画</em>集合中包含一些<em class="my">填充</em>图标(最常见的情况是需要包含社交网络徽标)。</p><p id="925f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以用一点小技巧轻松解决这个问题。首先，在我们的编辑器中，我们必须注意给我们想要赋予<code class="fe nr ns nt nu b">fill</code>属性的图标名称添加一个<code class="fe nr ns nt nu b">-fill</code>(或者任何你想要的东西)后缀。</p><p id="768a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以下是草图中的一个示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/b5b78fc5620152f26c8dec21a4cc64a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMqRwQzzVWbrAva5W0QvOQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">草图中的填充和描边图标</p></figure><p id="1fbc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们只需修改我在上一篇文章中描述的<a class="ae le" href="https://gist.github.com/massimo-cassandro/fc2b2e472f0e84623fe519bef628a20f#file-gulpfile-web-component-js" rel="noopener ugc nofollow" target="_blank"> gulpfile </a>。受影响的部分是<code class="fe nr ns nt nu b">icons_components</code>任务(前一个gulpfile的第15行到第50行):</p><pre class="kp kq kr ks gt nx nu ny bn nz oa bi"><span id="cb7e" class="ob mc iq nu b be oc od l oe of">let icons_component_list = [],<br/>  is_fill_icon = false;<br/><br/>const component_tpl =<br/>`import BaseIcon from '../base-icon';<br/>export default function (props) {<br/>  return (<br/>    &lt;BaseIcon {...props}@extra_props@&gt;<br/>      &lt;%= contents %&gt;<br/>    &lt;/BaseIcon&gt;<br/>  );<br/>}`;<br/><br/>gulp.task('icons_components', function () {<br/>  return gulp.src([<br/>    svg_files_folder + '/*.svg'<br/>  ])<br/>    .pipe(svgmin( /* svgmin config */ ))<br/><br/>    .pipe(rename(function (path) {<br/>      is_fill_icon = /-fill($|-)/.test(path.basename);<br/>      // path.basename = path.basename.replace('-fill', '');<br/><br/>      icons_component_list.push(path.basename);<br/>      // path.basename = 'icon-' + path.basename;<br/>      path.extname = '.jsx';<br/>    }))<br/>    .pipe(replace(/&lt;\/?svg(.*?)&gt;/g, ''))<br/>    // .pipe(wrap({ src: './icon-components-template.jsx'}))<br/>    .pipe(wrap(component_tpl))<br/>    .pipe(replace('@extra_props@', () =&gt; {<br/>      let extra_props = [<br/>        ...(is_fill_icon ? ['fillIcon={true}'] : [])<br/>      ];<br/>      if(extra_props.length) {<br/>        return ` ${extra_props.join(' ')}`;<br/>      } else {<br/>        return '';<br/>      }<br/>    } ))<br/>    .pipe(gulp.dest(dest_folder + '/src'));<br/>});</span></pre><ul class=""><li id="b6a1" class="oh oi iq lh b li lj ll lm lo oj ls ok lw ol ma om on oo op bi translated">声明了一个新变量(<code class="fe nr ns nt nu b">is_fill_icon</code>)，它将帮助我们在需要时添加特定的代码行。</li><li id="41d0" class="oh oi iq lh b li oq ll or lo os ls ot lw ou ma om on oo op bi translated">在前面的gulpfile中，我们使用了一个外部文件作为图标组件的模板。这个版本使用了一个在gulpfile中声明的变量(<code class="fe nr ns nt nu b">component_tpl</code>)。如果您愿意，可以很容易地切换回来:只需删除第31行并取消对第30行的注释。一个新的<code class="fe nr ns nt nu b">@extra_props@</code>字符串也被添加到模板中，我们将在后面介绍它。</li><li id="fdda" class="oh oi iq lh b li oq ll or lo os ls ot lw ou ma om on oo op bi translated">在<code class="fe nr ns nt nu b">svgmin</code>管道之后，我们使用<code class="fe nr ns nt nu b">gulp-rename</code>来检查当前图标是否是填充图标，方法是对其文件名执行正则表达式测试(第22行)。结果被分配给<code class="fe nr ns nt nu b">is_fill_icon</code>变量。可选地，您可以删除<code class="fe nr ns nt nu b">-fill</code>后缀(本例中的第23行被注释，因为我们有两个具有相同基本名称的图标，<code class="fe nr ns nt nu b">circle</code>和<code class="fe nr ns nt nu b">circle-fill</code>)。</li><li id="bdc1" class="oh oi iq lh b li oq ll or lo os ls ot lw ou ma om on oo op bi translated">然后移除svg标签，结果代码被包装在<code class="fe nr ns nt nu b">component_tpl</code>变量中。</li><li id="26f5" class="oh oi iq lh b li oq ll or lo os ls ot lw ou ma om on oo op bi translated">最后，如果<code class="fe nr ns nt nu b">is_fill_icon</code>是<code class="fe nr ns nt nu b">true</code>，占位符<code class="fe nr ns nt nu b">@extra_props@</code>将被替换为<code class="fe nr ns nt nu b">fillIcon={true}</code>属性(如果为false，则替换为空字符串)。我们使用一个数组来处理我们的额外道具，因为我们稍后将再次使用它来处理非方形图标。</li></ul><p id="202c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这里，您可以看到描边图标和填充图标之间的结果和差异:</p><pre class="kp kq kr ks gt nx nu ny bn nz oa bi"><span id="8884" class="ob mc iq nu b be oc od l oe of">import BaseIcon from '../base-icon';<br/><br/>export default function (props) {<br/>  return (<br/>    &lt;BaseIcon {...props}&gt;<br/>      &lt;circle cx="48" cy="48" r="37"/&gt;<br/>    &lt;/BaseIcon&gt;<br/>  );<br/>}</span></pre><pre class="ov nx nu ny bn nz oa bi"><span id="45e8" class="ob mc iq nu b be oc od l oe of">import BaseIcon from '../base-icon';<br/><br/>export default function (props) {<br/>  return (<br/>    &lt;BaseIcon {...props} fillIcon={true}&gt;<br/>      &lt;circle cx="48" cy="48" r="37"/&gt;<br/>    &lt;/BaseIcon&gt;<br/>  );<br/>}</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="e648" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，我们还需要修改我们的<code class="fe nr ns nt nu b">base-icon.jsx</code>文件来处理我们正在添加的新道具:</p><pre class="kp kq kr ks gt nx nu ny bn nz oa bi"><span id="c69a" class="ob mc iq nu b be oc od l oe of">import classnames from 'classnames';<br/>import PropTypes from 'prop-types';<br/><br/>function BaseIcon(props) {<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;svg  role="img" viewBox='0 0 96 96'<br/>        className={classnames('icon', props.className, {'fill-icon': props.fillIcon})}&gt;<br/>        {props.title &amp;&amp; &lt;title&gt;{props.title}&lt;/title&gt;}<br/>        {props.children}<br/>      &lt;/svg&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>// https://it.reactjs.org/docs/typechecking-with-proptypes.html<br/><br/>BaseIcon.propTypes = {<br/>  fillIcon: PropTypes.bool<br/>};<br/>BaseIcon.defaultProps = {<br/>  fillIcon: false<br/>};<br/><br/>export default BaseIcon;</span></pre><p id="120b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在<a class="ae le" href="https://codesandbox.io/s/react-icons-alternative-styling-e32m45?file=/src/icon-components-alt/base-icon-attributes-inline-css.jsx" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>中显示结果。</p><p id="8870" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">属性用于有条件地向我们的SVG添加一个<code class="fe nr ns nt nu b">fill-icon</code>类。我们使用<a class="ae le" href="https://github.com/JedWatson/classnames" rel="noopener ugc nofollow" target="_blank">类名</a>以一种非常简单的方式管理类。</p><p id="5f88" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这样，我们现在能够使用每一个图标，而不用担心它是一个<em class="my">笔画</em>还是一个<em class="my">填充</em>图标。分配给组件的类将确保应用必要的CSS属性。</p><h1 id="9363" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">属性、外部CSS、样式组件还是…？</h1><p id="17a6" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">有几种方法可以将演示属性应用于图标。</p><p id="b4e5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第一个使用了<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute" rel="noopener ugc nofollow" target="_blank"> SVG属性</a>。您可以将它们应用到<code class="fe nr ns nt nu b">BaseIcon</code>组件，避免使用CSS进行样式化。然而，我不认为这是理想的选择，因为它没有真正将表示与结构数据分开，而这应该是每个项目的需要。此外，使用CSS属性使得组织样式属性更加简单和有效</p><p id="984d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">内联CSS也是如此。</p><p id="3b13" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是一个使用属性或内联CSS的<code class="fe nr ns nt nu b">BaseIcon</code>组件的基本示例。这两个组件产生相同的结果(在<a class="ae le" href="https://codesandbox.io/s/react-icons-alternative-styling-e32m45" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>上运行示例):</p><pre class="kp kq kr ks gt nx nu ny bn nz oa bi"><span id="44db" class="ob mc iq nu b be oc od l oe of">export function BaseIconAttributes(props) {<br/><br/>  return (<br/>    &lt;svg  viewBox='0 0 96 96' role="img"<br/>      width="2em" height="2em"  fill='none' stroke='currentColor' strokeWidth={6}&gt;<br/>      {props.title &amp;&amp; &lt;title&gt;{props.title}&lt;/title&gt;}<br/>      {props.children}<br/>    &lt;/svg&gt;<br/>  );<br/>}<br/><br/><br/>export function BaseIconInlineCSS(props) {<br/><br/>  return (<br/>    &lt;svg  role="img" viewBox='0 0 96 96' style={{<br/>      fill: 'none',<br/>      stroke: 'currentColor',<br/>      strokeWidth: 6,<br/>      width: '2em',<br/>      height: '2em'<br/>    }}&gt;<br/>      {props.title &amp;&amp; &lt;title&gt;{props.title}&lt;/title&gt;}<br/>      {props.children}<br/>    &lt;/svg&gt;<br/>  );<br/>}<br/>view raw</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="5934" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">更方便的方法是使用链接到您的项目的CSS/SCSS文件。如果你不想(或者不能)有一个完整的web组件方法，这当然是一个更好的方法。</p><p id="f175" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是如果你的目标是有一个真正基于组件的项目，有两个有趣的解决方案:<strong class="lh ja">风格组件</strong>和<strong class="lh ja"> CSS模块</strong>。</p><p id="2bdf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">它们不是唯一可用的技术。甚至<a class="ae le" href="https://cssinjs.org/" rel="noopener ugc nofollow" target="_blank"> JSS </a>或<a class="ae le" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">顺风</a>，举两个最重要的例子，都是有效的。选择使用哪一个取决于你面对的项目，取决于你最喜欢什么等等。</p><p id="58b2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">样式化组件</strong> </a>允许你将CSS代码嵌入到你的组件中，使它们完全独立。它们允许更复杂的结果，但是，对于我们的目的，我们只需要一个非常简单的设置。</p><p id="c57a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所有的工作都在<code class="fe nr ns nt nu b">base-icon</code>文件中完成:</p><pre class="kp kq kr ks gt nx nu ny bn nz oa bi"><span id="ea46" class="ob mc iq nu b be oc od l oe of">import classnames from "classnames";<br/>import PropTypes from "prop-types";<br/>import styled from "styled-components";<br/><br/>const Svg = styled.svg`<br/>  display: inline-block;<br/>  width: 3em;<br/>  height: 3em;<br/>  fill: none;<br/>  stroke: currentColor;<br/>  stroke-linecap: round;<br/>  stroke-linejoin: round;<br/>  stroke-width: 4px;<br/>  &amp;.bold {<br/>    stroke-width: 8px;<br/>  }<br/>  &amp;.fill-icon {<br/>    fill: currentColor;<br/>    stroke: none;<br/>  }<br/>`;<br/><br/>function BaseIcon(props) {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Svg<br/>        <br/>        role="img"<br/>        viewBox="0 0 96 96"<br/>        className={classnames(props.className, {<br/>          "fill-icon": props.fillIcon<br/>        })}<br/>      &gt;<br/>        {props.title &amp;&amp; &lt;title&gt;{props.title}&lt;/title&gt;}<br/>        {props.children}<br/>      &lt;/Svg&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>// https://it.reactjs.org/docs/typechecking-with-proptypes.html<br/><br/>BaseIcon.propTypes = {<br/>  fillIcon: PropTypes.bool<br/>};<br/>BaseIcon.defaultProps = {<br/>  fillIcon: false<br/>};<br/><br/>export default BaseIcon;</span></pre><p id="2d75" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如您所见，它包含一个<em class="my">样式的</em> SVG元素，所有CSS属性都被分配给该元素。这是结果:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="3226" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是第一个图标的渲染标记:</p><pre class="kp kq kr ks gt nx nu ny bn nz oa bi"><span id="7635" class="ob mc iq nu b be oc od l oe of">&lt;svg  role="img" viewBox="0 0 96 96" class="sc-dkzDqf cBaVhS"&gt;<br/>  &lt;title&gt;Sample title&lt;/title&gt;<br/>  &lt;polyline points="12 46.782 39.491 80 84.164 17"&gt;&lt;/polyline&gt;<br/>&lt;/svg&gt;</span></pre><p id="63fe" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意如何创建一个独特的类来避免与其他组件冲突。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="a198" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="https://github.com/css-modules/css-modules" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> CSS模块</strong> </a> <strong class="lh ja"> </strong>是构建自包含组件的另一种方式。</p><p id="9424" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于我们来说，这可能是一个过大的技术，但是在一个更大的环境中，你必须与你的项目的其他部分共享设置，这是有意义的。</p><p id="115e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你使用Create React App，<a class="ae le" href="https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/" rel="noopener ugc nofollow" target="_blank"> CSS模块已经配置好</a>，你需要做的就是把CSS文件的扩展名改成<code class="fe nr ns nt nu b">.module.css</code>。但是如果您正在创建一个定制的React配置，您必须根据您的开发环境自己提供必要的更改。你可以在网上找到很多资源和教程(比如LogRocket博客上的<a class="ae le" href="https://blog.logrocket.com/how-to-configure-css-modules-webpack/" rel="noopener ugc nofollow" target="_blank">“如何为webpack配置CSS模块”</a>)。</p><p id="0ab2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，请注意，您也可以将CSS模块与Sass文件一起使用。</p><p id="2dbd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">再深入一点，<em class="my"> CSS窍门</em>有<a class="ae le" href="https://css-tricks.com/css-modules-part-1-need/" rel="noopener ugc nofollow" target="_blank">一些关于CSS模块</a>的有趣文章。</p><p id="6efc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">和前面的例子一样，所有的修改都在<code class="fe nr ns nt nu b">base-icon</code>文件中:</p><pre class="kp kq kr ks gt nx nu ny bn nz oa bi"><span id="25e3" class="ob mc iq nu b be oc od l oe of">import classnames from "classnames";<br/>import PropTypes from "prop-types";<br/>import styles from "./icons.module.css";<br/><br/>function BaseIcon(props) {<br/>  return (<br/>    &lt;svg<br/>      <br/>      role="img"<br/>      viewBox="0 0 96 96"<br/>      className={classnames(styles.icon, props.className, {<br/>        [styles.fillIcon]: props.fillIcon,<br/>        [styles.bold]: props.bold<br/>      })}<br/>    &gt;<br/>      {props.title &amp;&amp; &lt;title&gt;{props.title}&lt;/title&gt;}<br/>      {props.children}<br/>    &lt;/svg&gt;<br/>  );<br/>}<br/><br/>BaseIcon.propTypes = {<br/>  fillIcon: PropTypes.bool,<br/>  bold: PropTypes.bool<br/>};<br/>BaseIcon.defaultProps = {<br/>  fillIcon: false,<br/>  bold: false<br/>};<br/><br/>export default BaseIcon;</span></pre><p id="a1b3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所有的CSS规则现在都从<code class="fe nr ns nt nu b">icons.module.css</code>文件导入，并通过<code class="fe nr ns nt nu b">styles</code>变量应用。</p><p id="7bc3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">事情是这样的:<code class="fe nr ns nt nu b">styles</code>变量现在被用来应用从<code class="fe nr ns nt nu b">icons.module.css</code>文件导入的所有CSS规则。这个文件与前一个非常相似，只有一些小的不同(比如<code class="fe nr ns nt nu b">bold</code>道具)。</p><p id="3d5e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">呈现的输出与样式化组件版本相同。查看<a class="ae le" href="https://codesandbox.io/s/react-icons-css-modules-hxv56b" rel="noopener ugc nofollow" target="_blank"> CSS模块沙箱</a>了解更多细节。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="bb07" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="my"> React图标系统文章:</em></p><ol class=""><li id="4f44" class="oh oi iq lh b li lj ll lm lo oj ls ok lw ol ma oy on oo op bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-an-icon-system-in-react-16757d73cc35">在React中构建图标系统</a></li><li id="f44c" class="oh oi iq lh b li oq ll or lo os ls ot lw ou ma oy on oo op bi translated"><strong class="lh ja">React中的造型图标—第一部分:从设计到代码</strong> <em class="my">(本文)</em></li><li id="48df" class="oh oi iq lh b li oq ll or lo os ls ot lw ou ma oy on oo op bi translated"><a class="ae le" href="https://medium.com/me/stats/post/ddd3c8b328de" rel="noopener">React中的样式图标—第二部分:双色调和非方形图标</a></li></ol></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="0016" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="https://medium.com/@massimo.cassandro/my-dev-publications-eacf6727e4a" rel="noopener"> <em class="my">我的所有出版物</em> </a></p></div></div>    
</body>
</html>