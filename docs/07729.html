<html>
<head>
<title>We Measure the Power of Cars, Computers, and Cellphones. But What About Code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们测量汽车、电脑和手机的功率。但是代码呢？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/we-measure-the-power-of-cars-computers-and-cellphones-but-what-about-code-91ed5583f298?source=collection_archive---------11-----------------------#2021-02-12">https://betterprogramming.pub/we-measure-the-power-of-cars-computers-and-cellphones-but-what-about-code-91ed5583f298?source=collection_archive---------11-----------------------#2021-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解Golang的基准测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d32c47eaf87c93e7b62d6e00e4a34c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17aMnyj2niaMmHScnOOkbw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托马斯·凯利在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不想撒谎——基准测试是<em class="lv">而不是</em>我最大的优势之一。我没有像我希望的那样经常做这件事。但是自从我开始使用Go作为我的首选语言后，它变得越来越频繁了。其中一个原因是因为Go对基准测试有很好的内置支持。</p><p id="a2f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go让我们开发人员使用测试包进行基准测试。因此，测试包附带了基准测试功能。太棒了。</p><p id="15fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想更深入地研究基准测试，但是我将从头开始。读完这篇文章后，我希望我已经让您对基准测试有了更好的理解。</p><p id="2e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始谈论基准测试。软件开发中的基准测试是关于测试我们编写的代码的性能。</p><blockquote class="lw"><p id="9da7" class="lx ly it bd lz ma mb mc md me mf lu dk translated"><strong class="ak">基准</strong>是运行<a class="ae ky" href="https://en.wikipedia.org/wiki/Computer_program" rel="noopener ugc nofollow" target="_blank">计算机程序</a>、一组程序或其他操作的行为，以便评估对象的相对<strong class="ak">性能</strong>。—维基百科</p></blockquote><p id="ff42" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">基准测试允许我们采用不同的解决方案并测试它们的性能，比较测得的速度。作为开发人员，这是非常重要的知识，尤其是当您有一个需要加速和优化的应用程序时。</p><p id="debc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住开发中的一条黄金法则很重要:永远不要过早地优化。仅仅因为我们将学习如何进行基准测试，并不意味着我建议运行和基准测试你拥有的每一段代码。我强烈地感觉到，当你面临性能问题或者纯粹的好奇心正在杀死你的时候，基准测试是一个可以使用的工具。</p><blockquote class="lw"><p id="0a08" class="lx ly it bd lz ma mb mc md me mf lu dk translated">"过早优化是万恶之源."</p><p id="f9a5" class="lx ly it bd lz ma mb mc md me mf lu dk translated">—唐纳德·e·克努特，“计算机编程的艺术”</p></blockquote><p id="32a7" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">在互联网上看到初级开发人员关于不同代码解决方案的帖子并不罕见，他们会问哪一个是最好的。但是当谈论代码时，说某事是最好的，这是我不愿意做的事情。</p><p id="aa22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们坚持使用最高性能的表达方式，因为有时较慢的代码更容易维护和阅读。因此，如果你问我，那段代码更好，当然，除非你面临性能问题。</p><p id="602e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始学习如何使用Go进行基准测试。我从一个初级开发人员那里收集了一些我无法回答的关于性能的问题。</p><p id="21e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会帮他看看的。</p><ul class=""><li id="a968" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mq mr ms mt bi translated">切片还是贴图更快？</li><li id="cc4a" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">切片和贴图的速度受大小影响吗？</li><li id="3ece" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">地图中使用的键类型重要吗？</li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="1d15" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">编写一个超级简单的基准</h1><p id="de69" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">在解决这些问题之前，我将首先构建一个简单的基准，并展示如何用Go完成基准测试。在我们知道如何做到这一点之后，让我们进化它来解开所需的答案。</p><p id="2326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这些基准创建了一个新项目，我建议您也这样做，这样您就可以自己尝试了。您需要创建一个目录并运行:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="0a45" class="oi nh it oe b gy oj ok l ol om">go mod init benching</span></pre><p id="e8df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要创建一个以<code class="fe on oo op oe b">_test.go</code>结尾的文件。我的情况是<code class="fe on oo op oe b">benching_test.go</code>。</p><p id="3116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go中的基准测试是通过测试包完成的，非常像常规的单元测试。就像单元测试一样，基准测试是由相同的Go测试工具触发的。</p><p id="4431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go工具将根据方法的名称知道哪些方法是基准。任何以<code class="fe on oo op oe b">Benchmark</code>开始并接受指向<code class="fe on oo op oe b">testing.B</code>的指针的方法都将作为基准运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要点显示了最低基准方法的样子</p></figure><p id="1e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行带有<code class="fe on oo op oe b">-bench=.</code>标志的<code class="fe on oo op oe b">go test</code>命令来尝试一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/1a55f14d35360435c8c1a72401b04e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*lKacEi52Y9PgL_O26TuZmQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过运行“go test -bench=”。看到输出，我们知道基准测试是有效的</p></figure><p id="2c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在这里停一会儿，反思一下输出。执行的每个基准将输出三个值:名称、基准运行的次数和<code class="fe on oo op oe b">ns/op</code>。</p><p id="75d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个名字不言自明。这是我们在测试文件中设置的名称。</p><p id="8a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基准测试的执行次数很有趣。每个基准测试都要执行多次，并且每次执行都要计时。然后根据运行次数计算执行时间的平均值。这很好，因为运行一次基准测试会提供很差的统计正确性。</p><p id="04d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe on oo op oe b">ns/op</code>代表纳秒/操作。这是方法调用花费的时间。</p><p id="deaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有多个基准，并且只想运行一个或几个，那么您可以用字符串替换点，匹配类似<code class="fe on oo op oe b">-bench=BenchmarkSimplest</code>的名称。记住说<code class="fe on oo op oe b">-bench=Benchmark</code>仍然会触发我们的基准，因为字符串匹配方法的开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/4d6155c2ead4ade7832a527f24ad1491.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*iuLjz6ZTkfcuRQLL4KhNxA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">替换'-bench= '值可以用来指定要运行的基准</p></figure><p id="7f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，现在我们可以对速度进行基准测试，但这可能并不总是我们想要测量的一切。令人欣慰的是，如果我们看一看<a class="ae ky" href="https://golang.org/pkg/testing/" rel="noopener ugc nofollow" target="_blank">测试包</a>，我们可以发现添加<code class="fe on oo op oe b">-benchmem</code>标志将添加关于每操作分配的字节(B/op)和每操作分配(allocs/op)的信息。</p><p id="68fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉分配和内存，我可以推荐一篇文森特·布兰奇的文章。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/c5a66ee47a308f2efe30e3635ba8b7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zru0muQTY4WXN9ICcFlX9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加'-benchmem '标志会添加B/op和allocs/op</p></figure><p id="661b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们很快就准备好开始对真实事物进行基准测试——请再耐心等我一会儿。我们的基准测试中的输入参数<code class="fe on oo op oe b">*testing.B</code>有什么问题？让我们看看标准库中对它的定义，以了解我们在处理什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试。标准库(golang/src/testing/benchmark . go)中的定义</p></figure><p id="eb45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe on oo op oe b">Testing.B</code>是一个保存与运行基准相关的任何数据的结构。它还包含一个名为<code class="fe on oo op oe b">BenchmarkResult</code>的结构，用于格式化输出。如果输出中有你不完全理解的地方，我强烈建议打开<code class="fe on oo op oe b">benchmark.go</code>阅读代码。</p><p id="dab5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一件重要事情是<code class="fe on oo op oe b">N</code>变量。还记得基准测试是如何被多次执行的吗？基准测试执行的次数由<code class="fe on oo op oe b">testing.B</code>中的<code class="fe on oo op oe b">N</code>变量指定。</p><p id="7a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://golang.org/pkg/testing/" rel="noopener ugc nofollow" target="_blank">文档</a>，这需要在基准中考虑，所以让我们更新<code class="fe on oo op oe b">BenchmarkSimplest</code>来考虑<code class="fe on oo op oe b">N</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将精确运行N次的基准测试</p></figure><p id="e642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过制作一个<code class="fe on oo op oe b">for</code>循环来更新它，这个循环将迭代<code class="fe on oo op oe b">N</code>次。当我进行基准测试时，我喜欢将<code class="fe on oo op oe b">N</code>设置为特定的值，所以我确保我的基准测试是公平的。否则，一个基准可能运行100，000次，另一个可能运行两次。</p><p id="6a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过添加<code class="fe on oo op oe b">-benchtime=</code>标志来完成。输入要么是秒，要么是X次，所以要强制基准执行100次，我们可以将其设置为<code class="fe on oo op oe b">-benchtime=100x</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/e40ce40b8c34a9e8fee0e4a9bd6aae37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNo3S9pin9cxO1-3EJ9fPQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试新方法100次</p></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="c009" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">准备，设置，基准！</h1><p id="d2c8" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">是时候开始测试和回答之前关于性能的问题了。</p><ul class=""><li id="449e" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mq mr ms mt bi translated">切片还是贴图更快？</li><li id="59ed" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">切片和贴图的速度受大小影响吗？</li><li id="0352" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">使用的密钥重要吗？</li></ul><p id="aea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将开始实现一个将数据插入地图和切片的基准，然后实现另一个读取数据的基准。我从<a class="ae ky" href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go" rel="noopener ugc nofollow" target="_blank">戴夫·切尼</a>那里偷来的一个技巧是创建一个方法，它接受我们想要进行基准测试的输入参数——这使得对许多不同的价值进行基准测试变得非常容易。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">取X量并将X插入到地图中的方法</p></figure><p id="10bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法将接受一个整数值，该值表示要插入到映射中的整数数量。这样我们就可以测试地图的大小是否会影响插入性能。这个方法将由我们的基准来执行。我还将创建多个基准函数，每个函数插入一个不同的整数进行基准测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行N次并将X项插入地图的基准方法</p></figure><p id="46fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到我如何在每个基准测试中重用相同的方法，但只是修改插入次数了吗？这是一个巧妙的技巧，因为我们可以很容易地测试大量和少量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/49da5524060887c6f47e2aac9678c035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBVvNexbvNyGYz7YBDDLHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">插入到地图中的基准结果</p></figure><p id="4a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以时间增加了——这是意料之中的，因为我们增加了插入的次数。这并没有告诉我们太多，因为我们需要一些东西来比较结果。不过，我们可以花时间来回答一个问题:<strong class="lb iu"> </strong>地图中使用的键类型重要吗？</p><p id="633e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将复制所有的方法，并用一个接口替换使用的键类型。为了使事情更简单，我现在有两个文件，<code class="fe on oo op oe b">benching_map_interface_test.go</code>和<code class="fe on oo op oe b">benching_map_int_test.go</code>。基准方法将与名称相关联——这只是为了在我们添加更多基准时保持一个易于导航的结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用接口作为键将基准插入到地图中</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/6a11c9cc2208299c5eee40e3ec969b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WprWK4YiVICZglz2tigKpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基准测试结果表明，键类型确实很重要</p></figure><p id="2b8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想我们至少找到了一个问题的答案。从结果中我们可以看出，键的类型似乎很重要。考虑到<code class="fe on oo op oe b">1000000</code>基准测试，在该基准测试中使用“Int”而不是<code class="fe on oo op oe b">Interface</code>作为键要快2.23倍。但是，我想我以前从来没有见过一个接口被当作一个键使用。</p><p id="ea68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于键的性能翻倍似乎符合我从Jason Moiron<a class="ou ov ep" href="https://medium.com/u/776ac72010e0?source=post_page-----91ed5583f298--------------------------------" rel="noopener" target="_blank">那里读到的一个结论。他写了《</a><a class="ae ky" href="http://jmoiron.net/blog/go-performance-tales/" rel="noopener ugc nofollow" target="_blank">围棋表演故事集》、</a>很值得一读。</p><ul class=""><li id="b0cf" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mq mr ms mt bi translated">切片还是贴图更快？</li><li id="b199" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">切片和贴图的速度受大小影响吗？</li><li id="58f3" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">d̸o̸e̸s̸̸t̸h̸e̸̸ke̸y̸̸t̸y̸p̸e̸̸u̸s̸e̸d̸̸i̸n̸̸m̸a̸p̸s̸̸m̸a̸t̸t̸e̸r̸？是的，确实如此。</li></ul><p id="67c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，我想花点时间添加一个新的基准，因为它很有趣。在我们刚才运行的基准测试中，地图没有预先分配大小。因此，我们可以改变这一点，并对差异进行基准测试。</p><p id="b48a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要改变的是<code class="fe on oo op oe b">insertXIntMap</code>方法，我们也要改变map的初始化，改为使用X的长度。我已经创建了一个新文件，<code class="fe on oo op oe b">benching_map_prealloc_int_test.go</code>，在这个文件中，我已经修改了<code class="fe on oo op oe b">insertXIntMap</code>方法来预先初始化大小。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我将“make(map[int]int，0)”改为“make(map[int]int，x)”</p></figure><p id="895b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我说过我们可以使用<code class="fe on oo op oe b">-bench=</code>标志来控制运行什么样的基准吗？是时候使用这个技巧了，因为现在我们有了许多基准。但是对于这个特定的基准，我只对比较没有设置大小的地图和有预分配大小的地图感兴趣。</p><p id="65ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将我的新基准命名为<code class="fe on oo op oe b">BenchmarkInsertIntMapPrealloc</code>，因此它们与B <code class="fe on oo op oe b">enchmarkInsertIntMap</code>同名。我们可以以此为契机。这个新的基准文件是另一个<code class="fe on oo op oe b">IntMap</code>基准的精确副本——我只改变了名称和运行方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="78b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行基准测试并更改基准标志。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="e5ef" class="oi nh it oe b gy oj ok l ol om">go test -bench=BenchmarkInsertIntMap -benchmem -benchtime=100x</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/dcbc7fe0ffd0e59db7dd3ae228653090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAFn1RLe7hSwkDtBcAjerw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">地图中预分配大小之间的差异</p></figure><p id="dcf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个基准向我们展示了设置地图的大小有相当大的影响。当你看到<code class="fe on oo op oe b">1000000</code>测试有1.92倍的性能差异时，事实的确如此。看看分配的字节数(B/op) —好得多。</p><p id="1d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续实现切片的插入基准。这将是map实现的一个副本，但是这次使用了一个带有<code class="fe on oo op oe b">append</code>的切片。</p><p id="6378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还将创建预分配片的基准和未分配大小的基准，因为这很有趣。我们可以重新创建<code class="fe on oo op oe b">insertX</code>方法，复制粘贴所有内容，然后搜索<code class="fe on oo op oe b">Map</code>并用<code class="fe on oo op oe b">Slice</code>替换它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">插入到切片中X次，用于基准切片中的插入。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">切片附加的基准</p></figure><p id="f70e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于预分配的片，我们不想使用<code class="fe on oo op oe b">append</code>,因为这会给片增加一个索引。因此，必须更改预分配的索引，以使用正确的索引。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用正确的索引插入值，而不是“追加”</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预分配切片大小基准测试的完整代码</p></figure><p id="7bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经完成了切片基准测试，让我们运行它们并查看结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/7c27ab6d743c45a8dcf9b8a587b3e33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aMDcXU_pBovzHAzcLrjl_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这张图展示了使用切片代替的基准</p></figure><p id="d705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预分配切片和动态切片之间的差异是巨大的。基准测试是<code class="fe on oo op oe b">75388 ns/op</code>对<code class="fe on oo op oe b">7246 ns/op</code>。这是10.4倍速度的性能差异。不过，在某些情况下，使用固定大小的切片可能会很麻烦。我通常不知道我的应用程序的大小，因为它们往往是动态的。</p><p id="3b3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在插入数据时，切片似乎优于地图——在小数字和大数字上。我们还需要测试选择数据的性能。</p><p id="6265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了对此进行基准测试，我们将像刚才一样初始化一个切片和映射，添加<code class="fe on oo op oe b">X</code>数量的项目，然后重置计时器。然后我们将开始衡量我们能多快找到<code class="fe on oo op oe b">X</code>物品。我决定使用索引值<code class="fe on oo op oe b">i</code>迭代切片和地图。我将在下面发布两个基准测试的代码——它们几乎是相同的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从地图中选择的基准</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试切片中选择的基准</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/bff800805d32d7f7a3431c3a88376dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQfQL04ZJ6ViaGB4BKxRBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较地图和切片的基准结果</p></figure><p id="7dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你注意到了，那么<code class="fe on oo op oe b">selectXIntSlice</code>和<code class="fe on oo op oe b">selectXIntMap</code>的代码是相同的——唯一的区别是<code class="fe on oo op oe b">make</code>命令。不过，这两者的性能差异非常明显。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="b789" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">比较基准测试结果</h1><p id="5c95" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">因此，我们现在有了基准数据—让我们将它们汇编成一个表格，以便于查看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含1000000个项目的所有基准的基准测试结果摘要</p></figure><p id="a4fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么切片和地图有多大区别呢？</p><p id="bd83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在比较写入<strong class="lb iu"> </strong>动态大小的性能时，切片快了21.65倍</strong> (1321196/75388)。</p><p id="bc55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在比较写入预分配大小的性能时，切片快了118.35倍</strong> (857588/7246)。</p><p id="f5ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在比较读取的性能时，切片快了177.19倍</strong> (507843/2866)。</p><h2 id="d1d5" class="oi nh it bd ni pd pe dn nm pf pg dp nq li ph pi ns lm pj pk nu lq pl pm nw pn bi translated"><strong class="ak">切片快还是贴图快？</strong></h2><p id="1f60" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">使用这些基准测试，Slices的表现似乎远远优于maps。差异如此之大，我想我一定是搞砸了这些基准。</p><p id="f97e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，地图更容易使用。在这些基准测试中，我们假设我们知道切片中要使用的索引。我能想到很多情况，我们不知道索引，可能不得不迭代整个切片，就像在<code class="fe on oo op oe b">[]User</code>上用<code class="fe on oo op oe b">map[userID]User</code>代替<code class="fe on oo op oe b">for</code>循环。</p><h2 id="8d2e" class="oi nh it bd ni pd pe dn nm pf pg dp nq li ph pi ns lm pj pk nu lq pl pm nw pn bi translated"><strong class="ak">切片和贴图的速度受尺寸影响吗？</strong></h2><p id="f7d9" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">在这些情况下，大小似乎并不重要。</p><h2 id="14d2" class="oi nh it bd ni pd pe dn nm pf pg dp nq li ph pi ns lm pj pk nu lq pl pm nw pn bi translated"><strong class="ak">地图中使用的按键类型重要吗</strong>？</h2><p id="d641" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">是的，确实如此。使用整数证明比接口快2.23倍。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="ec38" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">添加更真实的用例</h1><p id="dae0" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">所以切片看起来更有性能，但是我要说实话——我几乎不知道切片的正确索引。大多数时候，我不得不迭代整个切片来找到我要搜索的内容。这是我经常用地图代替的主要原因。</p><p id="dc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将用这个用例创建一个基准。我们会有一个<code class="fe on oo op oe b">map[userID]User</code>和一个<code class="fe on oo op oe b">[]User</code>。基准测试将是一场寻找特定用户的竞赛。</p><p id="18c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了一个新文件，其中包含生成随机用户的代码。我将在切片和地图中生成10，000，100，000和100万用户。想象一下，如果我们有一个API，用户ID被发送给我们，我们想要找到那个用户。这是我们将要测试的场景。我还将打乱切片，因为这模拟了一个动态添加数据的真实用例。</p><p id="242d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我称这个基准为“拯救大兵瑞恩”我们需要找到他，他有用户ID <code class="fe on oo op oe b">7777</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">切片和地图的更真实用例的基准</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/3b7fecbce664eeb8148bba4c8870a1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zbLoA6qqQc95OoBxBwz4Kw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在地图和切片中查找用户的基准测试结果</p></figure><p id="ff36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，切片不再优于地图。如果您查看结果，您会发现无论地图中有多少项目，地图都会保持相同的速度，而每添加一个项目，切片会花费更长的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较查找用户的性能的基准测试结果摘要</p></figure><p id="be4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个用例中，地图的性能更高，系数为6678.53 x<strong class="lb iu"/>(140917<strong class="lb iu">/</strong>21.1)。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="c75d" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">结论</h1><h2 id="0d46" class="oi nh it bd ni pd pe dn nm pf pg dp nq li ph pi ns lm pj pk nu lq pl pm nw pn bi translated"><strong class="ak">切片还是贴图更快？</strong></h2><p id="98ea" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">当谈到原始功率时，切片的性能更好，但不太复杂，也更难使用——正如我们的“拯救大兵瑞恩”基准测试所展示的那样。有时候权力不是一切。</p><p id="56f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我倾向于使用映射，因为它们提供了对存储值的简单访问。正如编程中的许多情况一样，这取决于您的用例。</p><h2 id="54ac" class="oi nh it bd ni pd pe dn nm pf pg dp nq li ph pi ns lm pj pk nu lq pl pm nw pn bi translated"><strong class="ak">切片和贴图的速度受尺寸影响吗？</strong></h2><p id="b331" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">令我难过的是，我妻子说尺寸确实很重要。我的基准也是这么说的。当使用正确的索引号时—当然，没关系。但是如果你不知道你的值存储在什么索引中，那么大小确实很重要。</p><h2 id="3fdb" class="oi nh it bd ni pd pe dn nm pf pg dp nq li ph pi ns lm pj pk nu lq pl pm nw pn bi translated"><strong class="ak">地图中使用的键类型重要吗？</strong></h2><p id="f1b7" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">是的，确实如此。使用整数证明比接口快2.23倍。</p><p id="17db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天就到这里，我希望你已经了解了一些关于基准测试的知识。我知道我肯定有。完整的代码可以在这里找到<a class="ae ky" href="https://github.com/percybolmer/benchmarking/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="61c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要忘记走出去，为世界树立标杆。</p></div></div>    
</body>
</html>