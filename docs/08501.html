<html>
<head>
<title>Introduction to Parser Combinators in Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Elixir中解析器组合子的介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-parser-combinators-in-elixir-f867fc3b502e?source=collection_archive---------9-----------------------#2021-05-06">https://betterprogramming.pub/introduction-to-parser-combinators-in-elixir-f867fc3b502e?source=collection_archive---------9-----------------------#2021-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af0b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解解析器组合子是如何工作的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/526dbd4f32d1bcc9432f7cd38da1c823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PaQV44DVWJoqkEPp9kXuw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@krstne?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯汀·图曼扬</a>在<a class="ae ky" href="https://unsplash.com/s/photos/lego?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure><p id="7e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析器组合子是最有用的解析工具之一。与正则表达式相比，它们更具可读性和可维护性，这使它们成为更复杂任务的绝佳选择。</p><p id="0545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释解析器组合子是如何工作的，以及它们是由什么组成的。我们将尝试从头开始构建函数解析器组合子。我们要做的组合子将是低级的，比用简单的正则表达式得到的还要差。他们只是为了说明这一点。</p><p id="125f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想看看解析器组合子的运行，我写了一篇关于用<a class="ae ky" href="https://serokell.io/blog/parser-combinators-in-elixir#create-your-own-csv-parser-with-nimbleparsec" rel="noopener ugc nofollow" target="_blank"> NimbleParsec </a>构建CSV解析器的教程。我强烈建议去看看。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebe7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是解析器组合子？</h1><p id="5aae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在编程时，我们经常需要将输入(如字符串)解析成一种更便于计算机使用的数据结构(如树或列表)。</p><p id="1846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种快速的方法是编写一个regex表达式来捕获我们需要的一切。但是这些可能会变得非常冗长和复杂，从而导致难看的代码。</p><p id="cd33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们可以编写将输入中的语义单元一一映射的解析器，并将它们组合成一个用于该输入的解析器，会怎么样呢？</p><p id="2b5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">归根结底，解析器组合子就是这样:一种组合简单解析器来创建更复杂解析器的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="091e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分析器</h1><p id="3922" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">那么解析器到底是做什么的呢？解析器的主要目标是将一串文本解析成一个不同的、更结构化的对象——比如一个列表或一棵树。</p><p id="d2a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以接受一个整数列表作为一个字符串(<code class="fe mz na nb nc b">"3, 1, 4, 1"</code>)，并将该字符串转换成一个列表，以更好地表示该字符串(<code class="fe mz na nb nc b">[3, 1, 4, 1]</code>)中固有的结构。</p><p id="be68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们遇到类似<code class="fe mz na nb nc b">"3, 1, 4, 1 -- Monday, December 28th"</code>或<code class="fe mz na nb nc b">"oops, I'm sorry"</code>的字符串呢？为了与其他解析器组合并处理可能的失败，我们还需要在解析器成功时返回输入的其余部分，如果解析器失败则返回一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/b61f9398916778fead307734d2c65ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1I3VGaV0GzfqtDz0.png"/></div></div></figure><p id="c0c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个低级解析器的例子，它解析Elixir中的一个十进制数字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="84dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你问我们能用它做什么，答案是“不太多”为了释放解析器组合子的威力，我们需要找到一种方法将不同的解析器组合在一起。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="41f0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">组合子</h1><p id="6fab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">解析器组合器是将两个或更多解析器组合成另一个解析器的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/52b6146f26ae4a48c9d3d823428a6720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ceTvZCXXxrv1PzkD.png"/></div></div></figure><p id="172e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一下组合解析器的方法。最直接的组合是将两者联系在一起——让解析器一个接一个地解析两个十进制数字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="771b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，结果解析器将第一个函数应用于输入，然后将第二个函数应用于第一个函数返回的输入的其余部分。我们将解析后的条目作为一个列表返回，并返回第二个函数没有使用的输入。如果有错误，它只是被进一步传递。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/a000c46e64bf36fa578f67c2ef9128f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qn1QC3BPYBgjjDGC.png"/></div></div></figure><p id="cccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以重复使用组合子来创建一个解析器，它可以连续解析两个、三个、甚至四个或更多的整数！但这只是开始。</p><p id="a27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他多种组合子的可能性。一个常见的例子是<code class="fe mz na nb nc b">choice</code>，它的一个简单版本可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f05c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，它将尝试逐个解析两个不同的解析器，并选择首先成功的解析器或返回错误。</p><p id="b779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们简单的组合子可以创建一个解析器，解析两个或三个数字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a50a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，通过组合不同的解析器，您可以构建大型、复杂的解析器来表示JSON或XML等语言的规则。</p><p id="e91d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真正的解析器组合子库通常提供各种不同的组合子，使得以可读的方式表示解析器成为可能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="201e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解析器组合子中的错误处理</h1><p id="ca09" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们的初步错误处理相当幼稚，我被告知有一种误解，认为解析器组合子处理错误很糟糕。让我们看看如何轻松地扩展我们的解析器来显示意外输入的位置。</p><p id="c0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们改变<code class="fe mz na nb nc b">parse_digit</code>处理错误的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e8b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了输入错误之外，EOS错误也很容易发生，所以我确保涵盖了这一点。</p><p id="e3e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以修改我们的<code class="fe mz na nb nc b">concat</code>组合子，以便在输入错误发生时跟踪它的位置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">choice</code>组合器已经很好地处理了这些错误。你可以在这个要点中看到最终的结果<a class="ae ky" href="https://gist.github.com/NaeosPsy/254f80bd730d139cfdf92c08cbd03060" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们尝试做<code class="fe mz na nb nc b">two_or_three_digits.("5a")</code>，我们会得到<code class="fe mz na nb nc b">{:error, {:unexpected_input, "a", 2}}</code>。如果我们将代码公开为一个库，我们可以很容易地生成漂亮的错误消息。</p><p id="dfb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这段代码只是为了演示，但是在<code class="fe mz na nb nc b">megaparsec</code>中使用了类似的方法，这是一个Haskell解析器组合子库，以其良好的错误报告而闻名。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb05" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">哪里可以使用解析器组合子？</h1><p id="4029" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为解析器组合子比regex强大得多，所以可以用它们来解析具有复杂递归结构的项。但是它们也可以用于简单的解析器，例如，一个项目可以有许多不同的选择。</p><p id="d1b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，它们不能取代正则表达式。每种工具都有其优势。对于简单的脚本，我会使用正则表达式；对于大多数其他解析需求，我会使用一行程序和解析器组合子。</p><p id="70ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看看解析器组合子如何在现实生活中使用的例子，你可以查看我的教程关于用Elixir编写CSV解析器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f47f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ng">最初发表于</em><a class="ae ky" href="https://serokell.io/blog/parser-combinators-in-elixir" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://sero Kell . io</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>