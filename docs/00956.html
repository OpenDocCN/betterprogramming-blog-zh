<html>
<head>
<title>The Costs of Optional Chaining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可选链接的成本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-costs-of-optional-chaining-eb21f357d6e2?source=collection_archive---------9-----------------------#2019-07-31">https://betterprogramming.pub/the-costs-of-optional-chaining-eb21f357d6e2?source=collection_archive---------9-----------------------#2019-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa0b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">可选链接有一些隐藏的成本</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4436763a62f537f25d83d253eed745fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNpk3yLpt9f4x_aEO5pa-w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sapegin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Artem Sapegin </a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="457f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可选链接已经到了第三阶段，是时候重新评估了。</p><p id="1536" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一年多前，我们决定开始使用<code class="fe ls lt lu lv b">@babel/plugin-proposal-optional-chaining</code>。和往常一样，babel插件的主要原因是开发者体验:“它会让我们的生活变得更容易”。</p><p id="e8f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确实如此。现在依然如此。我看到它在我们的代码库中到处被使用。</p><p id="b1a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在反应中<code class="fe ls lt lu lv b">componentDidUpdate</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在渲染函数中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b5b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它看起来很好，很容易理解是怎么回事。</p><p id="6033" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这是以牺牲性能和包大小为代价的。而我们，或者至少我，严重低估了这个成本。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="fdaf" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">表演</h1><p id="a75e" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">让我们把性能放在一边，因为这不是我最关心的。</p><p id="37cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果可选链接被过度使用，性能代价是存在的。不要保护你所有的财产，只保护未知的东西。如果你正在处理你自己的代码，假设存在是安全的。</p><p id="5719" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，我们没有每秒6500万次迭代我们自己的渲染函数。因此，即使性能损失高达45%，在生产环境中仍然可以忽略不计。</p><p id="6848" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们继续吧。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="fbe2" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">捆绑大小</h1><p id="4cce" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">上面贴的<code class="fe ls lt lu lv b">CommentButtons</code>组件包含了<code class="fe ls lt lu lv b">244</code>字节的写好的代码，被<a class="ae kv" href="https://babeljs.io/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=GYVwdgxgLglg9mABAYTgWzQUzFAQiKKBAZwAoBvREYzAJ0QF8BKRcgKEUVsyhFqVIdOiADwATGADcAfEOGj8hBIgnEAhgCMANpjEBectToB-AHQQ1YM7phQG0m1BEB6RUTCz5nEW-WrNOvqGNLRmFlamYpg6UJj2UTGYLr4ecsI-BO4qMOraugZGoeaWZtwADloAnvblVcmZCJ7pzhIyQkxsDEA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=true&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=true&amp;targets=&amp;version=7.5.5&amp;externalPlugins=%40babel%2Fplugin-proposal-optional-chaining%407.2.0" rel="noopener ugc nofollow" target="_blank">转换</a>成<code class="fe ls lt lu lv b">1.000</code>字节。大了四倍。</p><p id="1214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这是我们自己的代码，所以我们可以放心地假设，每当<code class="fe ls lt lu lv b">user</code>道具不是<code class="fe ls lt lu lv b">undefined</code>时，它也具有<code class="fe ls lt lu lv b">can</code>属性。如果后端不能强制执行，那么前端、父组件或者我们调用API的地方就可以强制执行。</p><p id="1e08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，我们可以通过重写组件移除<code class="fe ls lt lu lv b">optional chaining</code>来将传输的字节大小减少到<code class="fe ls lt lu lv b">477</code>字节。这里我们甚至没有假设<code class="fe ls lt lu lv b">can</code>的存在，而是默认为一个空对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="216b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我意识到这是一个极端的例子。但是我在野外看到了与此非常相似的代码。我们开发人员只是喜欢我们的生产力工具。如果有一个巴别塔插件可以让事情变得更简单，为什么不使用它呢？</p><p id="718f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我并不是说完全不使用可选的链接。我仍然喜欢使用它。我请你记住这是有代价的。例如，尽量不要在一个方法中对同一属性使用两次回退:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5a94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过只检查一次<code class="fe ls lt lu lv b">user.can</code>属性<a class="ae kv" href="https://babeljs.io/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=G4QwTgBAxiB2EF4IFcDOBTMB-AdDeAPgRAN4C-A3AFCiT4CiAJgJYAui0cO6Lr1tnWABF0AG3St0HfDkZiJ6CkA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=true&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=true&amp;targets=&amp;version=7.5.5&amp;externalPlugins=%40babel%2Fplugin-proposal-optional-chaining%407.2.0" rel="noopener ugc nofollow" target="_blank"/>来轻松减少<a class="ae kv" href="https://babeljs.io/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=G4QwTgBAxiB2CiATAlgFwgXggVwM4FMwB-AOhllPxVQG4AoUScgEXwBt9V9McDiy4pRO074aQA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=true&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=true&amp;targets=&amp;version=7.5.5&amp;externalPlugins=%40babel%2Fplugin-proposal-optional-chaining%407.2.0" rel="noopener ugc nofollow" target="_blank">和</a>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="89d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除非您的第一个可选操作符嵌套在某个地方，否则采取最后一步<a class="ae kv" href="https://babeljs.io/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=G4QwTgBAxiB2EF4IFcDOBTSAyLKNgDoZ4AfEiAbwF8BuAKFEmIFEATASwBdFo4D0Oneo16wAIugA26Tuh7ECrKTPQ0gA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=true&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=true&amp;targets=&amp;version=7.5.5&amp;externalPlugins=%40babel%2Fplugin-proposal-optional-chaining%407.2.0" rel="noopener ugc nofollow" target="_blank">可能是值得的，并且完全避免可选操作符:</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8cf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这能说明我的观点。我确实意识到gzip可以消除一些开销，因为它非常擅长压缩像<code class="fe ls lt lu lv b">=== void 0</code>和<code class="fe ls lt lu lv b">=== null</code>这样的重复模式。但是即使有了gzip，可选链接的成本也是存在的。请记住这一点，因为我们将在相当长的一段时间内无法使用通天塔。即使现在是第三阶段，它也不会在短期内登陆我们需要支持的所有浏览器。</p><p id="96dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将继续使用可选链接…尽管不那么狂热！</p></div></div>    
</body>
</html>