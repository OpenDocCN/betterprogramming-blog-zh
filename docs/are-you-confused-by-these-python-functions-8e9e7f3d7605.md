# 你被这些 Python 函数搞糊涂了吗？

> 原文：<https://betterprogramming.pub/are-you-confused-by-these-python-functions-8e9e7f3d7605>

## 排序对排序，反转对反转。理解它们的细微差别以避免意想不到的结果

![](img/951b517e71c7bd9deef4e949c24b2b08.png)

照片由[梅姆](https://unsplash.com/@picoftasty?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

人们常说，编程中最困难的事情之一是给变量命名，这也包括函数。当一些函数执行相似的工作时，自然应该有相似的名字，难免会给初学者带来一些困惑。在本文中，我想回顾一下名称相似但工作方式不同的函数。

# 1.sorted()与 sort()

这两个函数都可以用来对列表对象进行排序。然而，`sorted()`函数是一个内置函数，可以处理任何 iterable。`sort()`函数实际上是 list 的方法，这意味着它只能用于 list 对象。它们也有不同的语法。

sorted()与 sort()

*   两个函数都有参数`reverse`和`key`。`reverse`参数用于请求逆序排序，而`key`参数用于指定超出默认顺序的排序算法。它可以设置为 lambda 函数或常规函数。
*   `sorted()`函数可以处理任何 iterable。对于字典(第 4 行)，字典对象的 iterable 是键，因此`sorted()`函数返回键的列表对象。
*   以类似的方式，当您将一个字符串传递给`sorted()`函数时，它将返回一个字符列表，因为字符串被视为由单个字符组成的 iterable。
*   `sorted()`函数返回一个排序后的列表对象，而`sort()`函数不返回任何内容(确切地说，是返回`None`)。换句话说，调用`sort()`函数的列表对象将被就地排序。

# 2.反转()与反转()

这两者的使用场景类似于`sorted()` vs. `sort()`。`reversed()`函数可以处理任何序列数据，比如列表和字符串，而`reverse()`函数是列表的方法。

反转()与反转()

*   与返回列表的`sorted()`函数不同，`reversed()`函数返回一个反向迭代器，它本质上是一个可迭代的，但可以直接在`for`循环中使用。
*   要构造一个列表或元组，可以利用返回的迭代器以与原始顺序相反的顺序构造一个序列数据。
*   与列表中的`sort()`方法一样，`reverse()`方法是颠倒列表元素的顺序，因此它返回`None`。

# 3.append()与 extend()

这两个函数都是列表对象的方法。两者都用于向现有列表对象添加项目。下面的代码向您展示了如何使用它们，后面还有一些解释。

append()与 extend()

*   这两个函数就地修改列表对象并返回`None`。
*   `append()`功能是在列表末尾添加一个条目。如果要将一个项目添加到特定位置，应该使用`insert()`方法。
*   `extend()`功能是将 iterable 中的所有元素追加到 list 对象的末尾。在字符串的情况下(第 12 行)，字符被追加。对于 set 对象，您会注意到插入元素的顺序并不反映我们用来创建 set 对象的项目，这是保存无序项目的 set 对象的预期行为。

# 4.is vs. ==

这两个函数都用于比较对象。然而，它们有一些细微的差别，你应该知道。我们将`is`称为*同一性比较*，将`==`称为*值相等比较*。需要注意的一点是，当我们说一个对象的身份时，我们可以简单地用`id()`函数引用一个特定对象的内存地址。让我们看一些例子。

is vs. ==

*   当对象具有相同的内存地址时，它们就是相同的对象，具有相同的标识和值。因此，`is`和`==`产生相同的布尔值。
*   在大多数情况下，即使对象可以有相同的值，但它们可以是内存中不同的对象。
*   一些特殊的对象，比如`None`和小整数(比如 1，2)总是有相同的身份，因为它们用得太多了，而且在 Python 加载时就已经被实例化了。我们在不同的模块之间共享这些对象。
*   在大多数情况下，我们使用`==`来比较对象，因为我们最感兴趣的是使用对象的值。然而，当我们检查一个对象是否是`None`时，我们更喜欢使用`is`(即`if obj is None`)。

# 5.移除()，弹出()与清除()

这三个函数都是 list 对象的方法，比较混乱。先看它们的用法，接下来再讨论它们的细微差别。

移除()与弹出()与清除()

*   要删除特定项目，您可以在`remove()`功能中指定。但是要谨慎。如果要删除的项目不在列表中，您会遇到一个`ValueError`异常，如下所示。

```
>>> [1, 2, 3, 4].remove(5)
Traceback (most recent call last):
  File "<input>", line 1, in <module>
ValueError: list.remove(x): x not in list
```

*   默认情况下,`pop()`方法删除最后一项。如果您想删除特定索引处的元素，您可以在函数中指定它，如第 14 行所示。重要的是，这个方法将返回弹出的项，因此如果您想处理被移除的项，这个方法特别有用。需要注意的一点是，如果列表为空，这个方法将引发一个`IndexError`。

```
>>> [].pop()
Traceback (most recent call last):
  File "<input>", line 1, in <module>
IndexError: pop from empty list
```

*   `clear()`方法是删除列表中的所有项目，这应该很简单。

# 6.any()与 all()

这两个函数都用于使用 iterables 检查条件。两个函数的返回值都是布尔值— `True`或`False`。下面的代码向您展示了一些用法。

any()与 all()

*   当 iterable 中的任一项为`True`时，`any()`返回`True`。否则，返回`False`。
*   只有当 iterable 中的所有项目都是`True`时，`all()`才会返回`True`。否则，返回`False`。
*   当 iterable 为空时，需要特别考虑。可以看到，`any()`返回`False`，而`all()`返回`True`。很多人对这种行为感到困惑。你可以这样记住:默认情况下，`any()`返回`False`。只有找到一个非`False`项，它才会立即返回`True`——一个短路评估。相比之下，`all()`默认返回`True`。只有当它找到一个非`True`项时，它才会立即返回`False`——同样是一个短路评估。

# 7.issuperset()与 issubset()

我们已经讨论了与列表相关的几种方法。就 set 对象而言，我发现令人困惑的一对方法是`issuperset()`和`issubset()`。让我们先用一些琐碎的例子来看看它们是如何工作的。

issuperset()与 issubset()

*   这两种方法都用于检查两个 set 对象之间的关系。
*   理解这些方法的关键区别在于，要根据输入参数检查方法的调用方。例如，`set0.issuperset(set1)`是检查`set0`是否是`set1`的超集。

# 8.zip()与 zip_longest()

`zip()`函数是一个内置函数，用于创建一个可以在`for`循环中使用的 zip 对象。它接受多个 iterables 并创建一个生成器，每次生成一个 tuple 对象。每个元组对象由每个 iterable 中相应位置的元素组成。`zip_longest()`的工作方式类似，但也有一些不同。

zip()与 zip_longest()

*   要创建 zip 对象的列表，您将在 list 构造函数方法中包含 zip 对象，如第 6 行所示。
*   `zip()`函数将创建与最短可迭代长度相匹配的元组。在我们的例子中，它只创建了三个元组，因为较短的列表(即`list0`)只有三个条目。
*   相比之下，使用`zip_longest()`函数，创建的元组的数量将与最长的可重复项的长度相匹配。对于较短的可重复项，元组将使用`None`来代替。

# 结论

在本文中，我们回顾了八组功能相似的函数，这些函数可能会让一些 Python 初学者感到有些困惑。

感谢你阅读这篇文章。