<html>
<head>
<title>JavaScript Clean Code: Code and Coupling Heuristics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码:代码和耦合启发式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-clean-code-code-and-coupling-heuristics-bf3c70043b05?source=collection_archive---------19-----------------------#2020-03-17">https://betterprogramming.pub/javascript-clean-code-code-and-coupling-heuristics-bf3c70043b05?source=collection_archive---------19-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="357e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们看一般的代码气味</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c54bcd65a2f52803b6f46d3c4acca2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Z67L74AW5YanZ4LRExPQw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@srkraakmo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯蒂芬·克拉克莫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/magnifying-glass?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">糟糕的代码有许多独特的字符。在这篇文章中，我们将看看每一个和他们是什么。我们看更一般的代码味道。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="93f9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">信息太多</h1><p id="a31a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">定义良好的模块应该很小，允许我们用很少的代码做很多事情。它们没有提供很多可以依赖的功能，所以耦合是松散的。</p><p id="193b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个坏的模块有很多我们必须调用才能完成的函数，所以耦合度很高。</p><p id="bff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该尽量减少暴露在模块中的东西。数据和实现应该被隐藏，除非它们不能被隐藏。我们不应该创建大量被其他类继承的实例变量。</p><p id="998e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实用函数应该对其他模块隐藏。最后，我们应该可以参考一些事情来尽量减少耦合。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c207" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">死代码</h1><p id="5922" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">死代码绝对应该从我们的代码库中删除。</p><p id="0b8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它会被忽略，也不会根据最新的惯例进行更新。因此，它应该从我们的代码中删除。我们的测试应该检查它是否在没有死代码的情况下工作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e9c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">垂直间隔</h1><p id="139c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">变量和函数应该放在它们被使用的地方，这样我们就不必为了跟踪代码而进行大量的滚动。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a906" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不一致</h1><p id="8b6d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们应该保持命名的一致性。例如，在命名事物时，我们应该坚持JavaScript惯例。</p><p id="bd74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数和类都是大写字母。变量是骆驼大小写。常量是大写的。名称一致的东西更容易修改。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="62f2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">杂乱</h1><p id="65c4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们应该删除任何扰乱我们代码的东西。无用的代码应该被删除。不使用的实体应该消失。</p><p id="06a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都应该井井有条，干净整洁，没有杂乱。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="da5c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">人工耦合</h1><p id="a13b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">耦合应该总是最小化，这样不应该耦合在一起的东西就不会耦合。一个事物对另一个事物了解得越少越好。</p><p id="5f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们没有任何用途，并且进行更改更加困难，因为无论何时进行更改，我们都必须处理所有的耦合。当我们让一些东西工作时，我们应该清理我们的代码，这样我们就不会出现这些情况。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d734" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">特征羡慕</h1><p id="f8d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个类的方法应该对它们所在的类的变量和函数感兴趣，而不是其他类的变量和函数。</p><p id="bf1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该尽可能少地引用外部来源的代码。</p><p id="99f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子说明了什么是特征羡慕:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="89bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有大量引用了<code class="fe nb nc nd ne b">Rectangle</code>类的<code class="fe nb nc nd ne b">ShapeCalculator</code>类。我们称其为构造函数和实例变量。</p><p id="9d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不应该这样做，因为它引用了太多来自<code class="fe nb nc nd ne b">Rectangle</code>类的内容。我们可以删除对实例变量的引用，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="37d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们不需要接触内部来获得矩形的面积。如果没有必要，最好不要从<code class="fe nb nc nd ne b">Rectangle</code>实例中引用<code class="fe nb nc nd ne b">length</code>和<code class="fe nb nc nd ne b">width</code>。</p><p id="1bb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为当我们对<code class="fe nb nc nd ne b">Rectangle</code>类进行修改时，如果我们引用了这些实体，我们必须修改<code class="fe nb nc nd ne b">ShapeCalculator</code>类中的很多东西。</p><p id="8d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如我们把<code class="fe nb nc nd ne b">length</code>和<code class="fe nb nc nd ne b">width</code>的名字改成别的，那就要到处改。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b0c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">选择器参数</h1><p id="7d66" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在函数中选择功能的布尔参数是错误的。当我们选择它时，很难知道<code class="fe nb nc nd ne b">true</code>或<code class="fe nb nc nd ne b">false</code>是什么意思。如果我们确实需要一个选择器参数，我们应该把一个函数一分为二。这和其他争论一样糟糕。</p><p id="b40a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免布尔参数是将一个函数分成多个函数的明确标准之一。如果我们确实需要选择器，它们应该是更清晰的东西，比如字符串或整数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d8b8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模糊的意图</h1><p id="cee4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们希望我们的代码对我们的读者尽可能清晰。因此，命名应该揭示标识符的意图。</p><p id="2a62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，变量<code class="fe nb nc nd ne b">x</code>是一个坏名字，因为它没有告诉我们任何东西，但是<code class="fe nb nc nd ne b">numApples</code>是一个好名字，因为我们知道它的意思。我们知道它储存了许多苹果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5a89" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">错位的责任</h1><p id="58d1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">代码应该放在我们期望的地方。例如，<code class="fe nb nc nd ne b">PI</code>应该属于一个<code class="fe nb nc nd ne b">Math</code>类作为常量。我们不应该在把某些功能放在哪里的问题上耍小聪明。我们把它放在什么地方对读者来说应该是直观的。</p><p id="c537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数的名字应该告诉我们把代码放在哪里。例如，<code class="fe nb nc nd ne b">getHoursWorked</code>应该在<code class="fe nb nc nd ne b">Employee</code>类中，因为它属于一个雇员。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1559" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不适当的静电</h1><p id="237a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">静态方法应该只用于不对实例进行操作的函数。因此，<code class="fe nb nc nd ne b">getHoursWorked</code>不应该是<code class="fe nb nc nd ne b">Employee</code>类中的静态方法，因为工作小时数属于雇员。</p><p id="2582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">适合静态方法的是那些不关心它所操作的类的实例的方法。</p><p id="2173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe nb nc nd ne b">Math.min</code>方法应该是一个静态方法，因为我们不需要<code class="fe nb nc nd ne b">Math</code>实例做任何事情。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b070" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="d6de" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当编写干净的代码时，我们必须考虑许多事情。不过，大部分都是常识。我们应该编写清晰的代码，并尽可能少地暴露于外部，以减少耦合。</p><p id="0026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">名字应该清楚，这样每个人都知道我们的意思。最后，东西必须放在它们有意义的地方。</p></div></div>    
</body>
</html>