<html>
<head>
<title>My Visual Testing Toolbox</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的视觉测试工具箱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/visual-testing-toolbox-f742d35d62bd?source=collection_archive---------1-----------------------#2020-09-05">https://betterprogramming.pub/visual-testing-toolbox-f742d35d62bd?source=collection_archive---------1-----------------------#2020-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bced" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将OpenCV、Galen和Tesseract与Selenium集成</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/78bcbe68436d2320b2b09d965bf77822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdnM_lhoarOJmm0r3tt3tA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来源:<a class="ae ky" href="https://pixnio.com/science/medical-science/testing-her-visual-acuity-by-covering-her-left-eye" rel="noopener ugc nofollow" target="_blank">阿曼达·米尔斯</a></p></figure><p id="3ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视觉测试最常见的用例是使用基线图像的回归测试。然而，视觉测试的不同方面也值得讨论。我们将涵盖模板匹配(使用<a class="ae ky" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>)、布局测试(使用<a class="ae ky" href="http://galenframework.com/" rel="noopener ugc nofollow" target="_blank"> Galen </a>)和OCR(使用<a class="ae ky" href="https://opensource.google/projects/tesseract" rel="noopener ugc nofollow" target="_blank"> Tesseract </a>)，并展示如何将这些工具无缝集成到现有的Appium和Selenium测试中。我们使用Java(以及OpenCV和Tesseract的Java包装器),但是类似的解决方案也可以用其他技术栈来实现。</p><p id="228c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">这是</em> <a class="ae ky" href="https://github.com/martinschneider/presentations/blob/master/2020-09-05%20Visual%20testing%20toolbox.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="lv">的姊妹篇，2020年9月在新加坡Taqelah</em></a><em class="lv">和2020年</em>  <em class="lv">硒会议期间的一次闪电演讲。关于全功能演示和进一步的细节，请参考</em><a class="ae ky" href="http://www.justtestlah.qa" rel="noopener ugc nofollow" target="_blank"><em class="lv">www . just testlah . QA</em></a><em class="lv">。</em></p><p id="8e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">编辑:我在</em> <a class="ae ky" href="https://twchennai.github.io/VODQA-Chennai/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">第26版vodQA </em> </a> <em class="lv">期间也提出了题目，并在此过程中对本文做了一些编辑。</em></p><p id="755f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这个总结能够帮助您选择对您的用例最有影响力的工具，并为您提供一些如何将它们集成到您自己的工具箱中的想法。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4793" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">模板匹配</h1><p id="1dbc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Template_matching" rel="noopener ugc nofollow" target="_blank"> <em class="lv">模板匹配</em> </a>要完成的任务是在当前屏幕上找到给定的图像(模板)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/f0e06f3f105a22efa42084a66d074832.png" data-original-src="https://miro.medium.com/v2/resize:fit:24/format:webp/1*4a1lK3RhiMHxKsX1Vcl20Q.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">沃尔多在哪？</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/712a5f33a29ebbde8807528412999836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2yRHjeKPg20HD7dwwjfNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="http://appium.io/docs/en/writing-running-appium/image-comparison/" rel="noopener ugc nofollow" target="_blank"> Appium docs </a></p></figure><p id="336b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于移动测试，<a class="ae ky" href="http://appium.io/" rel="noopener ugc nofollow" target="_blank"> Appium </a>在其1.9版本中以<em class="lv">-图像</em>定位器策略的形式添加了这一功能。(更多信息可以在<a class="ae ky" href="http://appium.io/docs/en/writing-running-appium/image-comparison/" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae ky" href="https://appiumpro.com/editions/32-finding-elements-by-image-part-1" rel="noopener ugc nofollow" target="_blank">早期教程</a>中找到。)的想法是将图像的Base64编码的字符串表示传递给WebDriver。</p><p id="352b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nc nd ne nf b">image</code>定位器，您可以像其他<code class="fe nc nd ne nf b">WebElement</code>一样与结果元素交互。例如:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="d0ab" class="nk me it nf b gy nl nm l nn no">WebElement element = <strong class="nf iu">driver.findElementByImage</strong>(base64EncodedImageFile);<br/>element.click();</span></pre><p id="e151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="fee4" class="nk me it nf b gy nl nm l nn no">By image = <strong class="nf iu">MobileBy.image</strong>(base64EncodedImageFile);<br/>new WebDriverWait(driver, 10).until(ExpectedConditions.presenceOfElementLocated(image)).click();</span></pre><p id="a2e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员采用的方法是将该功能作为Appium服务器的一部分，并使用<a class="ae ky" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>(它成为运行Appium服务器的实例的依赖项)来支持实际的图像识别。</p><p id="23e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，客户端和服务器之间有一个额外的往返行程，其流程如下所示:</p><ol class=""><li id="bacd" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">从Appium服务器请求截图。</li><li id="e818" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">将<strong class="lb iu">截图和</strong>模板都发送到Appium服务器进行匹配。</li></ol><p id="3ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这感觉起来并不是100%优雅，尤其是如果我们想要在同一个屏幕上匹配多个模板。</p><p id="d76a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<a class="ae ky" href="https://www.youtube.com/watch?v=maJkvP_qk4A" rel="noopener ugc nofollow" target="_blank">我在2018年</a>第一次实现模板匹配时(当时并不知道，它已经由Appium团队开发)，我也选择了OpenCV，但却在客户端运行它。使用OpenCV Java包装器，我的代码要点如下所示:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="8055" class="nk me it nf b gy nl nm l nn no">Mat result = new Mat(resultRows, resultCols, CvType.CV_32FC1);<br/>Imgproc.matchTemplate(image, templ, result, Imgproc.TM_CCOEFF_NORMED);<br/>MinMaxLocResult match = Core.minMaxLoc(result);<br/>if (match.maxVal &gt;= threshold) {<br/>  // found<br/>}</span></pre><p id="9c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法不需要对上面提到的Appium服务器提出额外的请求。事实上，除了截屏功能，它不需要WebDriver的任何功能。它也适用于硒和钋。也就是说，它还增加了对OpenCV的依赖，这次是对运行测试执行的实例的依赖。</p><p id="c595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将上述两种方法(<a class="ae ky" href="https://github.com/martinschneider/justtestlah/blob/master/justtestlah-visual/src/main/java/qa/justtestlah/visual/OpenCVTemplateMatcher.java" rel="noopener ugc nofollow" target="_blank">客户机</a> -和<a class="ae ky" href="https://github.com/martinschneider/justtestlah/blob/master/justtestlah-visual/src/main/java/qa/justtestlah/visual/AppiumTemplateMatcher.java" rel="noopener ugc nofollow" target="_blank">服务器</a>-端执行)包装到一个<a class="ae ky" href="https://justtestlah.qa/apidocs/qa/justtestlah/stubs/TemplateMatcher.html" rel="noopener ugc nofollow" target="_blank">模板匹配器</a>接口中，以展示其用法(就当它是一个PoC)。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="7a80" class="nk me it nf b gy nl nm l nn no">private GooglePage google;<br/>WebElement logo = google.<strong class="nf iu">findImage("google.png")</strong>;<br/>assertThat(logo.isDisplayed()).as("Google logo is visible").isTrue();</span></pre><p id="ecde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://justtestlah.qa/#template-matching" rel="noopener ugc nofollow" target="_blank"> JustTestLah中找到更多的细节和例子！JTL测试框架</a>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c553" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">布局测试</h1><p id="05e5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">另一种类型的视觉测试包括验证页面或屏幕的布局。您可以通过图像比较来做到这一点，图像比较也隐含地检查布局。更简单的方法是使用专门的布局测试工具，如<a class="ae ky" href="http://galenframework.com/" rel="noopener ugc nofollow" target="_blank"> Galen </a>(在我看来，这是最被低估的UI测试框架之一)。</p><p id="39ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Galen为每个屏幕使用规范，这些规范定义了屏幕上的所有(重要)元素及其大小以及彼此之间的绝对或相对位置。</p><p id="2edd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以谷歌搜索页面为例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/aacadfeff36eb0b4fc4650861b96ec65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*wPrWqzdVF44h_CSoAvwYGA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谷歌搜索页面</p></figure><p id="d1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用以下规范来表示它:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="0f04" class="nk me it nf b gy nl nm l nn no">SEARCH_FIELD:<br/>   below LOGO<br/>   centered horizontally inside viewport<br/>   visible<br/><br/>LOGO:<br/>   above SEARCH_FIELD<br/>   centered horizontally inside viewport<br/>   width &lt; 100% of SEARCH_FIELD/width<br/>   visible<br/><br/>SEARCH_BUTTON:<br/>   near LUCKY_BUTTON 20px left<br/>   visible</span></pre><p id="eca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，上面用的是<a class="ae ky" href="http://www.justtestlah.qa" rel="noopener ugc nofollow" target="_blank"> JustTestLah！框架</a>的语法(通过页面对象的YAML文件中定义的唯一键引用UI元素)。在pure Galen中，这些需要在规范文件的顶部定义:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="ea07" class="nk me it nf b gy nl nm l nn no">@objects<br/>    LOGO          id        <!-- -->hplogo<br/>    <!-- -->SEARCH_FIELD<!-- -->  css       <!-- -->input[name=q]<br/>    ...</span></pre><p id="bdfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有不同的方法来执行这些检查。我更喜欢将<code class="fe nc nd ne nf b">verify</code>方法作为抽象<code class="fe nc nd ne nf b">BasePage</code>类的一部分:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="f5a5" class="nk me it nf b gy nl nm l nn no">private T verify() {<br/>  String baseName = this.getClass().getSimpleName();<br/>  String baseFolder = this.getClass().getPackage().getName().replaceAll("\\.", File.separator);<br/>  String specPath = baseFolder<br/>              + File.separator<br/>              + configuration.getPlatform()<br/>              + File.separator<br/>              + baseName<br/>              + ".spec";<br/>  <strong class="nf iu">galen.checkLayout(specPath, locators);</strong><br/>  return (T) this;<br/>}</span></pre><p id="e299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，每当我们第一次与屏幕交互时，我们可以很容易地从测试中调用验证(顺便说一句，我使用类似的方法来<a class="ae ky" href="https://justtestlah.qa/#applitools" rel="noopener ugc nofollow" target="_blank">集成Applitools进行可视化测试</a>):</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="6a1b" class="nk me it nf b gy nl nm l nn no">public class GoogleSteps extends BaseSteps {<br/>  private GooglePage google;<br/><br/>  @Given("I am on the homepage")<br/>  public void homepage() {<br/>    <strong class="nf iu">google.verify()</strong>.someAction().nextAction();<br/>  }<br/>}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f482" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">光学字符识别</h1><p id="2bfd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">视觉断言的另一种形式是光学字符识别，更广为人知的缩写是OCR。无论出于什么原因，当文本被呈现为图像并且不能用标准测试工具验证时，这都是有用的。</p><p id="2ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些使用Selenium进行网页抓取而不是测试的人来说，这可能也很有趣，因为这是网站开发人员为了让这变得更难而采取的对策之一。</p><p id="f294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<a class="ae ky" href="https://opensource.google/projects/tesseract" rel="noopener ugc nofollow" target="_blank"> Tesseract </a>，这是一款OCR工具，最初由惠普在20世纪80年代开发，目前由谷歌赞助。</p><p id="6f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的例子不是最真实的，但它旨在展示Tesseract在检测不同类型的字体方面的能力:我们将验证Google徽标实际上拼写为“Google”:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="dbc1" class="nk me it nf b gy nl nm l nn no">private GooglePage google;<br/>WebElement logo = google.findImage("google.png");<br/>assertThat(logo.<strong class="nf iu">getText()</strong>).as("Google logo spells Google").isEqualTo("Google");</span></pre><p id="8bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要在运行测试的实例上安装Tesseract。对于完整的源代码和演示，请查看<a class="ae ky" href="http://www.justtestlah.qa" rel="noopener ugc nofollow" target="_blank"> JustTestLah！测试框架。</a></p></div></div>    
</body>
</html>