<html>
<head>
<title>6 TypeScript Code Patterns To Make Your Code More Robust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6种类型脚本代码模式，使您的代码更加健壮</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-typescript-code-patterns-to-make-your-code-more-robust-bbe54354f39f?source=collection_archive---------0-----------------------#2021-10-06">https://betterprogramming.pub/6-typescript-code-patterns-to-make-your-code-more-robust-bbe54354f39f?source=collection_archive---------0-----------------------#2021-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="586a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您可以在日常工作中应用的简单实用的解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/76eb7b7e9aebfa084c5d2724816f81d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2kpjhBqkLBD-xF3p1fT-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lordarcadius?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Vipul Jha </a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现我在日常工作中重复使用了一些TypeScript代码模式。这些代码模式不重也不复杂，而且它们也不需要大量样板代码。它们只是解决一些常见问题的简单而实用的解决方案。</p><p id="3f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的几节中，我将分享我最喜欢的六种类型脚本代码模式。</p><p id="387c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">向前跳转:</em></p><ul class=""><li id="4518" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="#2ce1" rel="noopener ugc nofollow">使用Pick实现接口分离原则</a></li><li id="00a0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#eeab" rel="noopener ugc nofollow">从文字表达式中派生类型的常量断言</a></li><li id="be12" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#1058" rel="noopener ugc nofollow">使用“从不”类型进行彻底检查</a></li><li id="5410" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#d807" rel="noopener ugc nofollow">使用不透明类型模拟名义键入行为</a></li><li id="7b0f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#6021" rel="noopener ugc nofollow">从对象类型中查找属性类型</a></li><li id="2021" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#dd51" rel="noopener ugc nofollow">用析构赋值重构过多的函数参数</a></li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2ce1" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用Pick实现接口分离原则</h1><p id="f2a6" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">界面分离原理定义为:</p><blockquote class="no np nq"><p id="7dc8" class="kz la lv lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated">不应该强迫客户实现他们不使用的接口。</p></blockquote><p id="8693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个<code class="fe nu nv nw nx b">Client</code>类型，它被用在很多地方。有时只使用属性的子集。根据接口分离原则，类型为的函数参数应该是所需的最小类型。</p><p id="c655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nu nv nw nx b"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys" rel="noopener ugc nofollow" target="_blank">Pick</a></code>实用程序类型从<code class="fe nu nv nw nx b">Client </code>类型中排除未使用的属性。如下面的代码片段所示，只选择了<code class="fe nu nv nw nx b">name</code>和<code class="fe nu nv nw nx b">active </code>属性。因此，<code class="fe nu nv nw nx b">ClientSummary</code>类型代表一个更小、更具体的接口，只包含它需要的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择实用程序类型</p></figure><p id="785a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是使用如下<code class="fe nu nv nw nx b"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#excludetype-excludedunion" rel="noopener ugc nofollow" target="_blank">Exclude</a></code>实用程序类型:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="9bd5" class="oe ms it nx b gy of og l oh oi">type ClientSummary = Exclude&lt;Client, 'dateOfBirth'&gt;;</span></pre><p id="62b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe nu nv nw nx b">Pick</code>更健壮，因为当额外的属性被添加到<code class="fe nu nv nw nx b">Client</code>类型时，不需要任何改变。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="eeab" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">从文字表达式派生类型的Const断言</h1><p id="19e3" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe nu nv nw nx b">as const</code>是一个名为<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions" rel="noopener ugc nofollow" target="_blank"> const assertion </a>的文字值的类型化构造。当<code class="fe nu nv nw nx b">as const</code>被应用时，我们得到一个const对象，它的每个属性都是非加宽的文字类型。我们可以用它从带有const断言的声明常量中派生类型。</p><p id="f281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段是我在另一篇文章中讨论过的一个例子。简而言之，我们从<code class="fe nu nv nw nx b">payGrades</code>常数中推导出<code class="fe nu nv nw nx b">payGradeType</code>和<code class="fe nu nv nw nx b">payValueType</code>。这些类型形成了一个约束类型系统。当源常量被修改时，所有相关类型都将自动更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用const断言从文本表达式派生类型，您可以创建具有更具体和更准确类型的变量，这有助于提高类型的类型安全性和正确性。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1058" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">“从不”类型的详尽检查</h1><p id="a5fa" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe nu nv nw nx b">never</code>类型表示从不出现的值的类型。这对于执行详尽的检查非常有用，因为您可以使用<code class="fe nu nv nw nx b">never</code>类型来确保在switch语句或其他控制流结构中处理所有可能的情况。</p><p id="11bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型的一个很好的应用是作为不可能类型的类型保护。</p><p id="ad0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的示例显示了如何涵盖所有可能的文本类型值。由于<code class="fe nu nv nw nx b">DataTypes</code>只包括两种文字类型<code class="fe nu nv nw nx b">client</code>和<code class="fe nu nv nw nx b">order</code>，所以<code class="fe nu nv nw nx b">assertUnreachable</code>永远不会到达。</p><p id="c5f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果另一个开发人员在<code class="fe nu nv nw nx b">DataTypes</code>中添加了一个新的文字类型，并且忘记更新switch语句，将会抛出一个编译时错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fbbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了详尽的类型检查，我们可以在编译时而不是运行时检测缺失的情况。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d807" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用不透明类型来模拟名义类型行为</h1><p id="13d6" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">TypeScript是一种结构类型系统。在<a class="ae ky" href="https://www.typescriptlang.org/play#example/structural-typing" rel="noopener ugc nofollow" target="_blank">结构类型系统</a>中，两种相同形状的类型兼容。这使得TypeScript非常灵活，但也可能产生潜在的问题。</p><p id="28cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面这个虚构的例子中，我们有两个兼容的类型<code class="fe nu nv nw nx b">Customer</code>和<code class="fe nu nv nw nx b">VIPCustomer</code>。函数<code class="fe nu nv nw nx b">getVIPName</code>应该只接受<code class="fe nu nv nw nx b">VIPCustomer </code>类型的参数。但是，如果<code class="fe nu nv nw nx b">Customer</code>类型参数被错误地传入，由于结构类型的限制，它不会出错。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ef93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述问题可以通过不透明类型来解决。不透明类型允许您创建名义上是类型化的类型，但仍然与结构类型兼容。</p><p id="a6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管TypeScript不支持不透明类型开箱即用，但我们可以使用交集类型实现类似的行为。</p><p id="f752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下<code class="fe nu nv nw nx b">OpaqueType</code>利用<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">普通型</a>和交集型。现在<code class="fe nu nv nw nx b">Customer</code>型和<code class="fe nu nv nw nx b">VIPCustomer</code>型结构不同。因为内部的<code class="fe nu nv nw nx b">_brand</code>属性只存在于编译时，所以没有与之相关的运行时开销。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不透明类型实现可以使您的TypeScript代码在正确的地方使用时更干净、更强大。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="6021" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">从对象类型中查找属性类型</h1><p id="d309" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><a class="ae ky" href="https://blog.logrocket.com/type-flowing-rethinking-typescript-typing-system/" rel="noopener ugc nofollow" target="_blank">类型脚本是关于类型的</a>。通常，我们需要从复杂的对象类型中提取现有的对象属性类型。</p><p id="4775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用条件类型和<code class="fe nu nv nw nx b">never</code>来过滤出下面<code class="fe nu nv nw nx b">lookup </code>类型定义中所需的数据类型定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="cb5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">lookup </code>型乍一看可能会令人困惑。我们来分解一下。</p><p id="3a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，为了访问一个属性类型，我们将创建一个带有递归类型别名的新类型。</p><p id="0b11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe nu nv nw nx b">Path extends keyof T</code>为真时，表示完整路径匹配。因此，我们返回当前的属性类型。</p><p id="2036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe nu nv nw nx b">Path extends keyof T</code>为falsy时，我们使用<code class="fe nu nv nw nx b">infer</code>关键字构建一个模式来匹配<code class="fe nu nv nw nx b">Path</code>。如果匹配，我们递归调用下一级属性。否则，它将返回一个<code class="fe nu nv nw nx b">never </code>，这意味着<code class="fe nu nv nw nx b">Path</code>与类型不匹配。</p><p id="0271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不匹配，则以当前属性作为第一个参数继续递归。</p><p id="7a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的属性类型可以在其他函数中使用，以加强类型安全。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="dd51" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">用析构赋值重构过多的函数参数</h1><p id="43fb" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">TypeScript代码的一个常见问题是函数参数过多。我们可以使用析构赋值来重构过多的函数参数，让你的代码更加简洁易读。</p><p id="a4a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">析构赋值允许你将一个对象或数组的值解包到单独的变量中。当您的函数有多个相关的参数时，这可能会很有用，因为您可以使用析构赋值将值解包到单个变量中，并将它们作为单独的参数传递给函数。</p><p id="e603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子说明了参数过多的问题。例如，如果一个新的参数类型，比如说<code class="fe nu nv nw nx b">middleName</code>是必需的。我们需要非常小心地将参数添加到正确的位置。</p><p id="c547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，很难维持。读取调用函数以将参数与其名称匹配也很困难。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了重构它，我们使用对象析构和对象文字，如下所示。这是我最喜欢的方法之一，因为它很简单。简洁易读。</p><p id="455a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript是智能的。它不仅将值赋给相应的变量，还能正确地推断出类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重构之后，参数的顺序不再重要。您可以添加或删除属性，而不必担心其位置。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="4ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript打字系统太神奇了。开发人员面临的挑战是充分利用其强大的工具箱来开发干净和强类型的代码。</p><p id="6d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章对你有用。如果您有自己喜欢的类型脚本代码模式，请告诉我。</p><p id="2158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你也可以看看我的另一篇关于TypeScript最佳实践的文章。</p></div></div>    
</body>
</html>