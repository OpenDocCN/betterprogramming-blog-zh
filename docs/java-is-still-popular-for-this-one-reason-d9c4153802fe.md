# 因为这个原因，Java 仍然很受欢迎

> 原文：<https://betterprogramming.pub/java-is-still-popular-for-this-one-reason-d9c4153802fe>

## Java 的过去、现在和未来

![](img/78ee03f7a9c942795f839c48c49abeff.png)

这是发表这篇文章的好时机——正好在 Java 19 发布的时候。是的，又一篇《我的语言更好》的文章。不，我不想写。但是有时候人们的不良预测会让我好过一些。在这种情况下，文章开始是评论，我最终决定把它变成一篇文章。这个帖子加强了这一点，这个帖子主要抱怨 Quarkus(如果我可以补充的话，有点不公平)。

第一篇文章大多是废话和过时的 clickbait。我会在下面的权利要求中总结给你:

*   getter/setter
*   缺少专门针对集合上的`[]`和任何东西上的`+`的运算符重载
*   检查异常
*   依赖性管理

第二篇文章抱怨更多的是关于 Jakarta EE 和 JVM 中的一般程序员美学。特别是在验证和类似声明中使用注释。这是一篇消息灵通得多的文章，但有几个缺陷，我将在接近尾声时解决。

# Getters 和 Setters

现代 Java 不需要 Getters 和 setters。我们从 Java 14 开始就有记录了，尽管有些人声称相反，但 Lombok 仍然很好。我们唯一需要 getter/setter 的地方是在非常特殊的设置中(例如 JPA ), Lombok 完美地解决了这个问题。

这篇文章长篇大论地讨论了 Java 缺乏语法糖特性的问题。这是故意的。如果您对最新的语法细微差别感兴趣，可以看看 Kotlin。Java 讲究的是“慢而稳”。这是一件好事，也是 Java 长寿的主要原因。

# 语法糖和运算符重载

现代 Java 包括`switch`、`var`、多行字符串等模式。一些即将推出的功能包括字符串模板。字符串模板支持需要一段时间，因为 Java 希望“做对”在 API 层面上有一些支持(已经有一段时间了)。这不是表演。字符串模板的目标是创建一个激进的可重写语法，这样[将允许](https://openjdk.org/jeps/8273943)这样的东西:

```
ResultSet rs = DB."SELECT * FROM Person p WHERE p.last_name = \{name}";
```

更新:自本文发表以来，开发人员错误地认为上面的代码是一个 SQL 注入漏洞。它不是。这看起来像字符串替换，但它是使用该语法生成参数化 SQL 调用的代码。

注意`name`是一个变量，编译器将动态检查并从作用域中获取它！

可以由开发人员自定义实现，不需要“内置”,因此您可以就地构建复杂的模板。

但是，让我们谈谈我们今天拥有的 Java，而不是六个月后即将到来的 Java。使用`append`已经十多年没有推荐给`String`了。使用性能最好且更容易阅读的`+`。关于收藏，`get()`和`[]`的区别就是字面上的四个字。这些角色很重要。

我们可以很容易地忽略它。我们也能理解语义上的差异。Java 数组非常快；在许多情况下，本地速度很快。收藏不能那么快，这点我们看得出来是很有价值的。

操作符不能过载是一个巨大的好处。如果我看到`a + b`，我知道这要么是一个字符串，要么是一个数字，而不是一些隐藏的方法。这是 Java 最大的优势之一，也是它流行了近 30 年而其他语言被抛在一边的原因之一。Java 的语法是为大规模阅读而设计的。

当你有一个有 100 万行代码甚至 100k 行代码的项目时，问题就转移了。此时，当您调试问题时，很难发现程序员 X 在模块 Y 中错误地重写了一个运算符。在这一点上，语法应该是简单的，你最初节省的任何小成本都将获得 10 倍的利息。随着代码变得越来越复杂和老化，简单翻转的定义也发生了变化。再加上工具在大规模解析严格简单的代码的能力，这将成为一个更大的优势。

# 检查异常

选中的异常是可选的。但是它们是 Java 中最好的特性之一。这么多代码意外失败。当你把建造东西作为一种爱好时，这可能是好的。当你想构建一个专业的应用程序时，你需要处理每一个错误。检查异常有助于避免这种无意义的情况。人们讨厌检查异常是因为懒惰。Java 让你防备自己。

不应该出现我建立网络连接、数据库连接、打开文件等情况。，并且不需要处理潜在的错误。我可以踢它，但然后检查异常迫使我继续踢它在某个地方。这是一个惊人的功能。

# 属国

我对梅文和格雷尔有很多问题。但是当你把它和几乎所有其他的依赖系统进行比较的时候，你会发现他们做得很好。他们有问题，但你不能把他们比作年轻的东西，比如相比之下几乎没有包装的货物。Maven central 非常庞大，有 27tb 的 jar 和 4960 亿个请求。它运行良好，几乎没有停机时间。

像 NPM 这样的其他工具完美地展示了 maven 的优势。如果 maven 中的依赖性是一个问题，那么 NPM 有 100 倍的问题并且没有监督。随着这些东西的增长，情况变得复杂了。尤其是市场上有多个版本的 maven。然而，maven 和 gradle 的优势之一是工具。在许多情况下，ide 有助于解决问题并找到现成的修复方法。

# Java 中的文化问题

第二篇文章更有趣，在某种程度上，我同意。Java 开发人员倾向于把每个问题都变成更复杂的问题。在某些情况下，这是必要的，Java 是编程平台中 800 磅重的大猩猩，它的解决方案经常被过度设计。这往往比动力不足要好，但它也有代价。

# 为什么要对验证进行注释

这篇文章确实提出了一个有趣的例子，对于不经意的观察者来说，这似乎是“正确的事情”，但却是有问题的。

```
@NotNull @Email
String noReplyEmailAddress
```

作者声称这是不好的，应该实现自定义类型，例如:

这在 Java 中是完全可能的，因为上面的代码是有效的 Java 代码。但是它有几个问题，这就是为什么我们有 bean 验证。

*   这是无法优化的——Bean 验证可能会被框架移到验证链的上游。它甚至可以在客户端代码中无缝验证，因为它是一个声明式 API。这里我们需要实际执行构造函数来执行验证。
*   声明性注释可以沿着链向下移动，无缝地应用数据库约束，等等。
*   我们可以一次应用多个注释
*   语法更简洁

因此，注释可能会感觉奇怪，并且不强制输入。确实如此。但是它们提高了性能和功率。它们的用法背后有很多思考和常识。我理解作者的观点:我也不是国际奥委会的忠实粉丝，但在这个具体的例子中，他是不正确的。

# 最后的想法

这篇文章花了太多时间进行辩护。该换挡了。Java 已经存在了将近 30 年，并且仍然与 Java 1.0 兼容。太棒了，无与伦比！

它的保守方法的一个优点是，它可以进行惊人的“幕后”优化，而不会引起任何人的注意。Java 9 完全无缝地取代了字符串在内存中的表示方式，并显著减少了 RAM 的使用。类似地，Loom 将提高 Java 同步应用程序的吞吐量。Valhalla 将进一步提高收集性能，统一对象/图元划分。Panama 将最终使我们摆脱 JNI，并使与本地代码集成的过程变得更加愉快。

好的一面是 JVM 是一个大帐篷。如果你不是 Java 迷，Kotlin 或 Scala 可能适合你的口味。JVM 的好处是普遍适用的，我在这里提到的大多数特性都将有益于我们整个联合生态系统。