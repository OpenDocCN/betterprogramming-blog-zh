<html>
<head>
<title>How To Do Twice as Much With Half the Keystrokes Using .bashrc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何做到事半功倍的击键使用？bashrc</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-do-twice-as-much-with-half-the-keystrokes-using-bashrc-e68622825c2e?source=collection_archive---------11-----------------------#2019-08-29">https://betterprogramming.pub/how-to-do-twice-as-much-with-half-the-keystrokes-using-bashrc-e68622825c2e?source=collection_archive---------11-----------------------#2019-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7745" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">概述了节省时间的别名和函数，它们使创建有用的Bash提示符变得容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1512964d486f1834f7e6b2f029e691de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uaM8mkJR7ky8A9jB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@goran_ivos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Goran Ivos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我最近的一篇关于用Bash脚本设置Ubuntu的文章中，我简单提到了<code class="fe lv lw lx ly b">.bashrc</code>的魔力。这并没有真正做到公平，所以这里有一个快速的帖子，提供了更多关于Bash配置文件可以做什么的细节。</p><p id="eac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我目前的配置极大地改善了我的工作流程，节省了超过50%的按键次数。让我们看一些别名、函数和提示配置的例子，它们可以通过帮助我们更有效地减少按键次数来改进我们的工作流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/ee8b6151a6580f4eec20c0d07f51e187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*1wcRA2iHfVido1mL.png"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="4d41" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Bash别名</h1><p id="f3bf" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">一个写得漂亮的<code class="fe lv lw lx ly b">.bashrc</code>可以省去一大堆按键。我们可以通过使用<a class="ae ky" href="https://www.gnu.org/software/bash/manual/html_node/Aliases.html" rel="noopener ugc nofollow" target="_blank"> bash别名</a>，或者扩展为更大命令的字符串，从字面意义上利用这一点。举个说明性的例子，下面是一个在终端中复制文件的Bash别名:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f96f" class="ni mi it ly b gy nj nk l nl nm"># Always copy contents of directories (r)ecursively and explain (v) what was done<br/>alias cp='cp -rv'</span></pre><p id="f697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">alias</code>命令定义了我们将要输入的字符串，以及该字符串将要扩展到的内容。我们可以像上面的<code class="fe lv lw lx ly b">cp</code>一样覆盖现有的命令。就其本身而言，<code class="fe lv lw lx ly b">cp</code>命令只会复制文件，而不会复制目录，并且会悄无声息地成功。有了这个别名，我们不需要记住传递这两个标志，也不需要记住<code class="fe lv lw lx ly b">cd</code>或<code class="fe lv lw lx ly b">ls</code>作为我们复制的文件的位置来确认它在那里。现在，只需按下这两个键(代表<code class="fe lv lw lx ly b">c</code>和<code class="fe lv lw lx ly b">d</code>)就能为我们完成所有的工作。</p><p id="65b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面再来几个<code class="fe lv lw lx ly b">.bashrc</code>别名，用常用函数传递标志。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="7d8b" class="ni mi it ly b gy nj nk l nl nm"># List contents with colors for file types, (A)lmost all hidden files (without . and ..), in (C)olumns, with class indicators (F)<br/>alias ls='ls --color=auto -ACF'</span><span id="28d9" class="ni mi it ly b gy nn nk l nl nm"># List contents with colors for file types, (a)ll hidden entries (including . and ..), use (l)ong listing format, with class indicators (F)<br/>alias ll='ls --color=auto -alF'</span><span id="887e" class="ni mi it ly b gy nn nk l nl nm"># Explain (v) what was done when moving a file<br/>alias mv='mv -v'</span><span id="e362" class="ni mi it ly b gy nn nk l nl nm"># Create any non-existent (p)arent directories and explain (v) what was done<br/>alias mkdir='mkdir -pv'</span><span id="7972" class="ni mi it ly b gy nn nk l nl nm"># Always try to (c)ontinue getting a partially-downloaded file<br/>alias wget='wget -c'</span></pre><p id="f1e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想避免输入长命令时，别名也很方便。以下是我在Python环境中使用的一些例子:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="495f" class="ni mi it ly b gy nj nk l nl nm">alias pym='python3 manage.py'<br/>alias mkenv='python3 -m venv env'<br/>alias startenv='source env/bin/activate &amp;&amp; which python3'<br/>alias stopenv='deactivate'</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="8fbb" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Bash函数</h1><p id="7de8" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">上述别名的一个缺点是它们相当静态——它们总是扩展到声明的文本。对于接受参数的Bash别名，我们需要创建一个函数。我们可以这样做:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f74c" class="ni mi it ly b gy nj nk l nl nm"># Show contents of the directory after changing to it<br/>function cd () {<br/>  builtin cd "$1"<br/>  ls -ACF<br/>}</span></pre><p id="90e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经数不清我输入了多少次<code class="fe lv lw lx ly b">cd</code>然后再输入<code class="fe lv lw lx ly b">ls</code>来查看我现在所在的目录的内容。设置好这个函数后，只需这两个字母就能完成所有操作。该函数将第一个参数<code class="fe lv lw lx ly b">$1</code>作为目录更改的位置，然后将该目录的内容打印到带有文件类型指示符的格式良好的列中。为了让Bash允许我们覆盖这个默认命令，<code class="fe lv lw lx ly b">builtin</code>部分是必需的。</p><p id="e8a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash函数在下载或升级软件时也非常有用。我以前每隔几周至少花几分钟下载新的静态站点生成器Hugo 的扩展版本，这要感谢它们出色的发货频率。有了一个函数，我只需要传入版本，几秒钟就升级了。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e61f" class="ni mi it ly b gy nj nk l nl nm"># Hugo install or upgrade<br/>function gethugo () {<br/>  wget -q -P tmp/ https://github.com/gohugoio/hugo/releases/download/v"$@"/hugo_extended_"$@"_Linux-64bit.tar.gz<br/>  tar xf tmp/hugo_extended_"$@"_Linux-64bit.tar.gz -C tmp/<br/>  sudo mv -f tmp/hugo /usr/local/bin/<br/>  rm -rf tmp/<br/>  hugo version<br/>}</span></pre><p id="3d87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">$@</code>符号简单地接受所有给定的参数，替换它在函数中的位置。要运行上述函数并下载Hugo版本0.57.2，我们使用命令<code class="fe lv lw lx ly b">gethugo 0.57.2</code>。</p><p id="3130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也有一个给Golang的:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="5c7d" class="ni mi it ly b gy nj nk l nl nm">function getgolang () {<br/>  sudo rm -rf /usr/local/go<br/>  wget -q -P tmp/ https://dl.google.com/go/go"$@".linux-amd64.tar.gz<br/>  sudo tar -C /usr/local -xzf tmp/go"$@".linux-amd64.tar.gz<br/>  rm -rf tmp/<br/>  go version<br/>}</span></pre><p id="b59f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者一个将GitLab的远程源URL添加到当前存储库的函数怎么样？</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="d233" class="ni mi it ly b gy nj nk l nl nm">function glab () {<br/>  git remote set-url origin --add git@gitlab.com:"$@"/"${PWD##*/}".git<br/>  git remote -v<br/>}</span></pre><p id="bc04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">glab username</code>，我们可以用GitLab.com上的<code class="fe lv lw lx ly b">username</code>为当前的Git库创建一个新的<code class="fe lv lw lx ly b">origin</code> URL。推到一个新的远程URL <a class="ae ky" href="https://victoria.dev/verbose/how-to-write-bash-one-liners-for-cloning-and-managing-github-and-gitlab-repositories/#a-bash-one-liner-to-create-and-push-many-repositories-on-gitlab" rel="noopener ugc nofollow" target="_blank">会自动创建一个新的私有GitLab存储库</a>，因此这是一个创建备份的有用快捷方式！</p><p id="f268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash函数实际上只受限于脚本编写的可能性，实际上这种可能性很少。如果我们经常需要在终端中输入几行代码，我们可以为它创建一个Bash函数！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2673" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Bash提示符</h1><p id="0b53" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">除了目录内容，查看我们所在目录的完整路径也很有用。Bash提示符可以向我们显示这个路径，以及其他有用的信息，比如我们当前的Git分支。为了提高可读性，我们可以为提示的每个部分定义颜色。下面是我们如何在<code class="fe lv lw lx ly b">.bashrc</code>中设置提示来实现这一点:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="91e4" class="ni mi it ly b gy nj nk l nl nm"># Colour codes are cumbersome, so let's name them<br/>txtcyn='\[\e[0;96m\]' # Cyan<br/>txtpur='\[\e[0;35m\]' # Purple<br/>txtwht='\[\e[0;37m\]' # White<br/>txtrst='\[\e[0m\]' # Text Reset</span><span id="6f49" class="ni mi it ly b gy nn nk l nl nm"># Which (C)olour for what part of the prompt?<br/>pathC="${txtcyn}"<br/>gitC="${txtpur}"<br/>pointerC="${txtwht}"<br/>normalC="${txtrst}"</span><span id="f814" class="ni mi it ly b gy nn nk l nl nm"># Get the name of our branch and put parenthesis around it<br/>gitBranch() {<br/>  git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'<br/>}</span><span id="4828" class="ni mi it ly b gy nn nk l nl nm"># Build the prompt<br/>export PS1="${pathC}\w ${gitC}\$(gitBranch) ${pointerC}\$${normalC} "</span></pre><p id="536e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="2a44" class="ni mi it ly b gy nj nk l nl nm">~/github/myrepo (master) $</span></pre><p id="fa3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名颜色有助于轻松识别一种颜色的开始和结束位置以及下一种颜色的开始位置。我们在终端中看到的提示是由跟在<code class="fe lv lw lx ly b">export PS1</code>后面的字符串定义的，提示的每个组成部分都设置了一个<a class="ae ky" href="https://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/bash-prompt-escape-sequences.html" rel="noopener ugc nofollow" target="_blank">转义序列</a>。让我们来分解一下:</p><ul class=""><li id="d563" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">\w</code>显示当前工作目录</li><li id="d801" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">\$(gitBranch)</code>调用上面定义的<code class="fe lv lw lx ly b">gitBranch</code>函数，显示当前Git分支，</li><li id="634d" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">如果您是普通用户或在普通用户模式下，<code class="fe lv lw lx ly b">\$</code>将显示“$ ”,如果您是根用户，将显示“#”</li></ul><p id="ff30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash转义序列的完整列表可以帮助我们显示更多的信息，甚至包括时间和日期。Bash提示是高度可定制和个性化的，所以可以随意设置。</p><p id="ced5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几个选项将信息放在前面和中心，可以帮助我们更有效地工作。</p><h2 id="87fd" class="ni mi it bd mj oc od dn mn oe of dp mr li og oh mt lm oi oj mv lq ok ol mx om bi translated">对于厌恶拖延的人来说</h2><p id="d23b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">用户名和当前时间(秒)，24小时制HH:MM:SS格式:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="0fe5" class="ni mi it ly b gy nj nk l nl nm">export PS1="${userC}\u ${normalC}at \t &gt;"</span><span id="f981" class="ni mi it ly b gy nn nk l nl nm">user at 09:35:55 &gt;</span></pre><h2 id="c28a" class="ni mi it bd mj oc od dn mn oe of dp mr li og oh mt lm oi oj mv lq ok ol mx om bi translated">对于那些总是想知道自己立场的人</h2><p id="9a2d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">单独一行的完整文件路径和用户名:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f23c" class="ni mi it ly b gy nj nk l nl nm">export PS1="${pathC}\w${normalC}\n\u:"</span><span id="29e7" class="ni mi it ly b gy nn nk l nl nm">~/github/myrepo<br/>user:</span></pre><h2 id="b30d" class="ni mi it bd mj oc od dn mn oe of dp mr li og oh mt lm oi oj mv lq ok ol mx om bi translated">对于极简主义者</h2><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="23f1" class="ni mi it ly b gy nj nk l nl nm">export PS1="&gt;"</span><span id="175b" class="ni mi it ly b gy nn nk l nl nm">&gt;</span></pre><p id="7315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用基本的转义序列构建许多实用的提示；一旦我们开始集成函数和提示，就像在Git分支示例中一样，事情就会变得非常复杂。这种复杂程度对你的工作效率是一种增加还是一种损害，只有你自己才能确定。</p><p id="20f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多花哨的Bash提示都可以通过快速搜索获得。我故意没有在这里提供样本，因为，嗯，如果你能像我一样对这些东西感到兴奋，可能需要几个小时才能回到你开始阅读这篇文章之前所做的事情，我只是不能让我的良心不安。</p><p id="26d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们很有希望在投入的时间和从Bash配置文件中获得的有用性之间取得一个很好的平衡。我希望你能善用你刚刚恢复的击键能力。</p></div></div>    
</body>
</html>