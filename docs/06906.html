<html>
<head>
<title>An Overview of Ethereum and Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊和固体概述</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/overview-of-ethereum-solidity-d7a0ea5fbf00?source=collection_archive---------7-----------------------#2020-11-16">https://betterprogramming.pub/overview-of-ethereum-solidity-d7a0ea5fbf00?source=collection_archive---------7-----------------------#2020-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2e05" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一本关于以太坊区块链、Solidity编程语言和智能合约的有用入门书</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4c25ee7412d81a0c7c3afc655c9d188a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PyBsw_sP7tP_ff_I-Ie6g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="5e52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将了解以太坊的基础知识，并了解区块链的与众不同之处以及以太坊带来的好处。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="3097" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">以太坊</h1><p id="0c89" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">以太坊由Vitalik Buterin于2013年首次提出。在比特币之后，在区块链的项目中，以太坊是最有特色的项目，因为它提出了智能合约的概念。以太坊为开发去中心化的应用和智能合约提供了一个平台。(这是一个分布式计算平台，旨在运行智能合同。)</p><p id="6db1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mv">以太</em>是以太坊区块链的价值令牌。它在加密货币交易所被列为ETH。</p><h2 id="f3b8" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">智能合同</h2><p id="5ee5" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated"><em class="mv">智能合同</em>是一种计算机程序或交易协议，旨在根据合同或协议的条款自动执行、控制或记录法律相关的事件和行为。</p><p id="ce74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">智能合约的主要贡献是使区块链应用程序可编程，它使区块链应用程序不仅仅是转移货币。它使得任何协议条款的验证都是自动的。因此，所有依赖于某个条件的操作都可以在没有任何中间人或第三方介入的情况下被计算出来。</p><p id="c29f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">智能合同提供了以下好处:</p><ul class=""><li id="bc0f" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><strong class="kx ir">透明性:</strong>由于智能合约在编译后像交易一样被部署到以太网，这些合约对所有相关方都是完全可访问和可见的。</li><li id="2960" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">安全:保存智能合约的条件和环境是一个安全的地方，就像加密货币一样。</li><li id="9d1b" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">信任:</strong>通过将智能合约保存在一个像加密货币一样安全的地方，区块链的安全、自治和透明特性也可以提供给智能合约。知道对放置在块中的信息进行操作的可能性非常低有助于我们信任。</li><li id="efdd" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">速度:</strong>智能合约生活在互联网上，运行在软件代码上。因此，它可以非常快速地验证交易。这样的速度可以节省很多人为造成的时间浪费。</li><li id="8e40" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">节省:</strong>智能合约消除了中间人或第三方权威机构根据协议条款决定该做什么的需要。因此，除了浪费时间之外，他们还节省了浪费的金钱。这意味着不需要律师、银行、证人和任何其他中介。</li></ul></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="7997" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">以太坊虚拟机(EVM)</h1><p id="3dd9" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">以太坊虚拟机(EVM)是一个强大的沙盒虚拟堆栈，嵌入在每个完整的以太坊节点中，负责执行合同字节码。EVM规定机器代码与网络、文件系统或主机的任何进程完全隔离。它强制以太坊网络中的所有节点运行相同的指令或操作，尽管它们彼此独立(以太坊网络在EVM上使用沙箱)。</p><p id="5097" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">EVM主要处理智能合同部署和执行，此外还防止非我们造成的无限循环和网络上的各种恶意攻击。以太坊网络中的每个节点都运行一个EVM实例，这允许它们同意执行相同的指令。</p><p id="79c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">EVM是图灵完备的，指的是能够执行计算功能的任何逻辑步骤的系统。</p><p id="8b19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">出于安全考虑，智能合约不会立即发布。智能合同通常用更高级的语言编写，比如<a class="ae nw" href="https://docs.soliditylang.org/en/v0.7.5/" rel="noopener ugc nofollow" target="_blank"> Solidity </a>。然后我们编写的Solidity代码被以太坊编译器编译成EVM字节码。之后，Solidity代码就可以以EVM字节码格式部署到网络中，然后就可以执行了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/48a650568a9c8c304c36af59d6c3b412.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*ga3ESGKsb9y3jONQaw98xg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">智能合同的编译和部署流程</p></figure><p id="9ed5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">智能合约部署到以太坊网络后，无论任何节点何时运行，都必须由以太坊生态系统中的所有节点运行。在这一点上，如果一个契约有一个无限循环，网络上的每个节点都将永远执行这个循环。(可能是偶然发生的，也可能是故意的。)如果意外发生，这种情况会给交易的发送方带来问题。这可能是通过拒绝服务攻击(DDoS)故意造成的。在这一点上，EVM有助于保护以太坊网络免受这两种问题的影响。</p><p id="988f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">拒绝服务攻击(DDoS) </strong>:由于每个节点都工作在EVM上，如果一个契约出现无限循环，网络上的每个节点都将永远陷入执行循环。因此，通过暂停问题，不可能提前确定合同是否会终止。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="8fe6" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">气体</h1><p id="45f8" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在以太坊中，气体<strong class="kx ir">T5被用来保护以太坊网络免受这类问题的影响。为了在以太网上执行交易，发送交易的发送者需要通过一个名为<em class="mv"> gas </em>的中间令牌向miner ether付款(这是我们执行合同所需的)。它是一个允许您测量运行智能合约或其他交易所需的计算工作量的单位。</strong></p><p id="008c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下表显示了哪项操作需要多少气体。Solidity中的每一行代码都需要一定的gas来执行。因此，完成任何操作所需的气体量取决于将在智能合同中执行的操作，并且在执行智能合同之前根据下表进行计算。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5c7683803619e22c755d4bde9244334e.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*7OvazlfL_lxuuDGnU9crVw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">气体数量表</p></figure><p id="04ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以太和气体<strong class="kx ir"> </strong>是不同的东西。汽油是交易中所需的计算能力，乙醚是用来支付汽油的货币。汽油价格(以乙醚计)是对应于一单位汽油的价格。在计算出所需的气体量之后，通过将气体量和气体价格相乘来计算从发送者的账户中取出的量。一般来说，该金额以<em class="mv"> gwei </em>为单位支付。</p><p id="6f80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Gwei是一小块以太，就像欧元和美分。(以太对应欧元，gwei对应美分)。</p><p id="0341" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1 gwei等于0.000000001 ETH，1 ETH等于10亿gwei。</p><p id="789c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除gwei之外，还有几个单位，如wei、kwei、mwei等。</p><p id="d44a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">天然气价格可以根据网络中的交易数量而提高/降低。</p><ul class=""><li id="8283" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">随着网络流量的增加，气价也会提高。</li><li id="b3d5" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">随着网络流量的减少，天然气价格将会降低。</li></ul><p id="7663" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管天然气价格是可变的，但是进行特定交易所需的天然气数量是固定的。(这确保了复杂操作总是比简单操作需要更多的气体)。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="ebbe" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">气体极限</h1><p id="6822" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在操作视图中，所有发送者必须指定一个称为<em class="mv">气体限制</em>的数量，这是发送者在将交易提交给网络之前愿意为该交易支付的气体的最大数量，然后该数量与相关交易一起发送。因此，矿商能够负担它的花费。</p><p id="eba9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果他们想要对他们自己的交易进行验证，发送者应该注意的主要问题是指定尽可能接近与交易相关的天然气价格的天然气限制。以下步骤描述了气体限制的主要原理。(以下使用的气体量不正确，只是为了帮助您理解一般概念。)</p><ul class=""><li id="ef1e" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">在变量= 45气体中储存11</li><li id="0a53" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">添加两个变量= 10气体</li><li id="f560" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">存储结果成本= 45汽油</li><li id="c1b8" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">该操作将需要的总气体= 100气体</li><li id="41b7" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">发送方必须指定气体限值= 120气体</li><li id="7cf2" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">120–100 = 20气体未被使用，它被发送回发送者帐户</li></ul><p id="5921" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，将气体限制指定得太低或太高会导致我们应该避免的以下问题:</p><ul class=""><li id="9f03" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">如果气体限制被指定得太低，则发生“气体耗尽”的情况，并且合同恢复到原始状态。然而，这种恢复操作仍然需要运营成本，并且它通过从发送者之前支付的气体中扣除来提供这些成本。让我们假设操作需要的总气体= 100气体。发送方必须指定气体限值= 90气体。结果，发生了“汽油用完”的情况，然后发送者将被收取发送者费用，只要恢复操作是值得的。</li><li id="c1d6" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">如果气体限制被指定得太高，那么，一般来说，矿工会避免它们，并且更喜欢具有小气体限制的交易，因为他们知道气体限制可能会膨胀。</li></ul></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="df40" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">为什么天然气很重要？</h1><p id="967e" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">不管是什么原因(无意还是有意)，gas都是用来保护网络不会因为任何回路的无限运行而被卡住。</p><ul class=""><li id="a166" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">如果事务进入无限循环或操作继续超过预期，它会保护发送方支付额外的费用——当意外发生时，事务会进行不必要的操作，并浪费网络上的计算能力和资源。支付所有这些浪费的计算能力和资源的人将是相关交易的发送者，这意味着发送者将遭受这种情况。</li><li id="63d4" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">它保护以太坊网络免受拒绝服务攻击(DDoS)——当它故意发生时，这意味着它是一种DDoS攻击。如果攻击者想要发起DDoS攻击，他们应该提供足够的攻击资金。因此，它允许攻击者避免执行任何DDoS攻击。</li></ul></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/85797a10837cff17cd45e18439af1aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*_EOixYIwYcQ6K15InJF-5w.png"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="436d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">固态</h1><p id="6b35" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">Solidity是一种面向对象的高级语言，用于实现智能合约，它的设计目标是以太坊虚拟机(EVM)，管理以太坊状态下的账户行为。</p><p id="ba31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它是一种面向契约的语言，这意味着智能契约负责存储与区块链进行交易的所有编程逻辑。</p><p id="420e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了Solidity，任何契约都可以开发用于投票、众筹、盲拍、多签名钱包等用途。</p><p id="37cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在编译Solidity代码的几种方法(即，<a class="ae nw" href="https://github.com/ethereum/solc-js" rel="noopener ugc nofollow" target="_blank"> solc-js </a> <strong class="kx ir">，</strong>node . js框架，或最新的Docker构建)中，<a class="ae nw" href="https://remix-ide.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Remix IDE </a> <strong class="kx ir"> </strong>是一个强大的开源工具，它可以帮助您直接从浏览器编写Solidity契约，而无需安装任何东西。Remix用JavaScript编写，支持在浏览器和本地使用。Remix还支持测试、调试和部署智能合约，等等。</p><p id="ebe4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">智能合约的以下元素有助于理解智能合约的一般结构。</p><h2 id="085c" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">声明合同</h2><p id="dbec" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">实体版本和合同名称必须由以下内容声明。</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="1134" class="mw lz iq ob b gy of og l oh oi">pragma solidity ^0.4.24;</span><span id="aba5" class="mw lz iq ob b gy oj og l oh oi">contract MyContract {<br/>    // do something<br/>}</span></pre><h2 id="f1d6" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">导入其他源文件</h2><p id="47eb" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">Ethereum Solidity支持的导入语句与JavaScript中的非常相似，尽管Solidity不知道“默认导出”的概念。</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="1939" class="mw lz iq ob b gy of og l oh oi">import "filename";</span><span id="e248" class="mw lz iq ob b gy oj og l oh oi">----- OR -----</span><span id="fcdd" class="mw lz iq ob b gy oj og l oh oi">import * as symbolName from "filename";</span></pre><h2 id="e88e" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">评论</h2><p id="13c7" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">就像任何其他语言一样，单行和多行注释在Solidity中都是可能的。</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="73ea" class="mw lz iq ob b gy of og l oh oi">// This is a single-line comment.</span><span id="b8b5" class="mw lz iq ob b gy oj og l oh oi">----- OR -----</span><span id="73e8" class="mw lz iq ob b gy oj og l oh oi">/*<br/>   This is a<br/>   multi-line comment<br/>*/</span></pre><h2 id="8df0" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">变量</h2><p id="d01e" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">坚实度支持以下变量:</p><ul class=""><li id="db9b" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><strong class="kx ir">状态变量</strong> — <strong class="kx ir"> </strong>永久保存在契约存储器中</li><li id="e6d1" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">局部变量</strong> —直到函数执行时才出现</li><li id="778d" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">全局变量</strong> — <strong class="kx ir"> </strong>存在于全局名称空间中的特殊变量，用于获取有关区块链的信息</li></ul><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="49e4" class="mw lz iq ob b gy of og l oh oi">pragma solidity …</span><span id="77ed" class="mw lz iq ob b gy oj og l oh oi">contract HelloWorld{<br/>   uint storedData;     <strong class="ob ir">// state variable<br/>   <br/>   </strong>function getResult() public view returns(uint){<br/>      uint a = 1;     <strong class="ob ir">// local variable<br/>   </strong>}<br/>}</span></pre><h2 id="7cf9" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">变量作用域</h2><p id="a003" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">坚固性支持以下类型的可见性，这些可见性对于函数和变量都是常见的</p><ul class=""><li id="6a8a" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><strong class="kx ir">公共</strong> — <strong class="kx ir"> </strong>可以内部调用或通过消息调用的公共函数或变量</li><li id="895b" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">内部</strong> —只对当前合约和衍生合约有效的函数和变量</li><li id="3a74" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">私有</strong> —仅适用于当前合同，不适用于衍生合同</li><li id="34b1" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">外部</strong> —只能用于从其他合同和交易中调用的函数</li></ul><h2 id="0f0e" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">数据类型</h2><p id="df6a" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">以下类型也被称为<em class="mv">值类型</em>，因为这些类型的变量总是通过值传递。</p><ul class=""><li id="b601" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><strong class="kx ir">布尔型</strong>—<code class="fe ok ol om ob b">bool</code>；可能的值是常数，即真或假</li><li id="4345" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">整数</strong>—<strong class="kx ir"/><code class="fe ok ol om ob b">int/uint</code>；各种大小的有符号和无符号整数</li><li id="6cc6" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">弦</strong>——<strong class="kx ir"/><code class="fe ok ol om ob b">string</code>；字符串文字用双引号或单引号“foo”或“bar”来表示</li><li id="624b" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">地址</strong> — <code class="fe ok ol om ob b">address/address payable</code>保存一个20字节的值，以太坊地址的大小等。</li></ul><h2 id="fa9f" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">地址类型</h2><p id="1093" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">地址类型也有成员，并作为所有协定的基础。有两种类型的地址:<code class="fe ok ol om ob b">address</code>保存一个20字节的值，<code class="fe ok ol om ob b">address payable</code>与上面的<code class="fe ok ol om ob b">address</code>相同，只是有<code class="fe ok ol om ob b">transfer</code>和<code class="fe ok ol om ob b">send</code>成员。<code class="fe ok ol om ob b">address</code> / <code class="fe ok ol om ob b">address payable</code>的区别在于<code class="fe ok ol om ob b">address payable</code> <strong class="kx ir"> </strong>是可以发以太的地址，而普通的<code class="fe ok ol om ob b">address</code> <strong class="kx ir"> </strong>是不能发以太的。</p><p id="9cac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">允许从<code class="fe ok ol om ob b">address payable</code>到<code class="fe ok ol om ob b">address</code>的隐式转换，而不允许从<code class="fe ok ol om ob b">address</code>到<code class="fe ok ol om ob b">address payable</code>的转换。地址类型有几个成员:</p><ul class=""><li id="3e7c" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><code class="fe ok ol om ob b">balance</code>返回给定地址的余额(单位为魏)</li><li id="7097" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><code class="fe ok ol om ob b">transfer</code>给定地址发送给定金额(单位为威)</li><li id="9326" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><code class="fe ok ol om ob b">send</code>向给定的地址发送给定数量的wei(不是安全的转移替代方案)</li></ul><h2 id="0ed9" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">数据结构</h2><p id="fa76" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">以下类型专门用于坚固性:</p><ul class=""><li id="4a73" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><strong class="kx ir"> Struct </strong> — <code class="fe ok ol om ob b">struct</code> Solidity提供了一种以Struct的形式定义新类型的方法。结构是自定义类型，可以将几个变量组合在一起。</li><li id="921c" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">数组</strong> — <code class="fe ok ol om ob b">[]</code>数组可以有一个编译时固定的大小，也可以有一个动态的大小。</li><li id="dab3" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">映射</strong> — <code class="fe ok ol om ob b">mapping(k =&gt; v)</code>映射可以被视为哈希表，这些哈希表被虚拟地初始化，使得每个可能的键都存在，并且被映射到一个字节表示全为零的值:一个类型的默认值，等等。</li></ul><h2 id="be9f" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">数据位置</h2><p id="7415" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">所有引用类型都包含关于它们存储位置的信息，有三个区域来存储它们:</p><ul class=""><li id="fda3" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><strong class="kx ir">存储</strong> — <strong class="kx ir"> </strong>状态变量、结构、数组、映射的局部变量:每个账户都有自己的存储，在函数调用和事务之间是持久的。</li><li id="ea02" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">内存</strong> — <strong class="kx ir"> </strong>函数参数，其中一个契约为每个消息调用获取一个新清除的实例。它保存临时值，并在(外部)函数调用之间被擦除，使用起来更便宜。</li><li id="0406" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">堆栈</strong> —小局部变量。EVM不是寄存器机器，而是堆栈机器，因此所有计算都在称为<em class="mv">堆栈</em>的数据区上执行。它保存小的局部变量，几乎可以免费使用，但只能保存有限的值。</li></ul><h2 id="d906" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated"><strong class="ak">功能</strong></h2><p id="a421" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在一个函数中，<code class="fe ok ol om ob b">&lt;parameter types&gt;</code>可以为空，但<code class="fe ok ol om ob b">&lt;return types&gt;</code>必须填充。</p><ul class=""><li id="fc5c" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><strong class="kx ir">内部函数</strong>只能在当前合同内部调用。</li><li id="4032" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx ir">外部函数</strong>由地址和函数签名组成，可以从外部函数传递和返回。</li></ul><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="9bb4" class="mw lz iq ob b gy of og l oh oi">function (&lt;parameter types&gt;) {internal|external} [pure|view|payable] [returns (&lt;return types&gt;)]</span></pre><h2 id="d7dd" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">功能类型</h2><p id="03a3" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated"><code class="fe ok ol om ob b">pure</code>确保它们不改变状态(可以转换为视图)。</p><p id="bbd2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ok ol om ob b">view</code>不读取状态或修改状态。</p><p id="d2e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ok ol om ob b">payable</code>使得以太能在函数中被发送。</p><p id="380e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ok ol om ob b">fallback</code>没有任何参数，不返回任何东西，但特别用于发送以太，写入存储，创建契约。</p><p id="4f2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">功能可以设置为<code class="fe ok ol om ob b">view</code>和<code class="fe ok ol om ob b">pure</code>来限制状态的读取和修改。</p><h2 id="5f34" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">方法重载</h2><p id="fc85" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">当协定中的几个函数名称相同但参数不同时，就会发生函数重载。</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="479e" class="mw lz iq ob b gy of og l oh oi">function sayHi(string n1) public pure returns (string out) {<br/>   out = "Hi " + n1 + " !" ;<br/>}</span><span id="24c0" class="mw lz iq ob b gy oj og l oh oi">function sayHi(string n1, string n2) public pure returns (string out) {<br/>   out = "Hi " + n1 + " and " + n2 + " !" ;<br/>}</span></pre><h2 id="56b2" class="mw lz iq bd ma mx my dn me mz na dp mi le nb nc mk li nd ne mm lm nf ng mo nh bi translated">修饰语</h2><p id="7148" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">定义修改器是为了改变函数在Solidity中的工作方式。通过使用修饰符，可以设置在函数执行前检查的条件。</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="9ce2" class="mw lz iq ob b gy of og l oh oi">pragma solidity ^0.4.24;</span><span id="9434" class="mw lz iq ob b gy oj og l oh oi">contract MyContract {<br/>   constructor() public { owner = msg.sender; }<br/>   address payable owner;</span><span id="ff43" class="mw lz iq ob b gy oj og l oh oi">   modifier onlyOwner {<br/>      require(msg.sender == owner, "Only owner can call this function.");<br/>      _;    <strong class="ob ir">// When the owner calls this function, it executes. Otherwise, it throws an exception.<br/>   </strong>}</span><span id="a0e5" class="mw lz iq ob b gy oj og l oh oi">   function close() public onlyOwner {<br/>      // do something<br/>   }<br/>}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="8d02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这篇文章对那些不熟悉以太坊和智能合约技术，并且希望熟悉区块链提出的概念的人有所帮助。</p></div></div>    
</body>
</html>