<html>
<head>
<title>A Deep Dive Into the Android Jetpack Library, WorkManager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究Android Jetpack库，WorkManager</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-the-android-jetpack-library-workmanager-5aee2f57e07b?source=collection_archive---------8-----------------------#2020-04-07">https://betterprogramming.pub/a-deep-dive-into-the-android-jetpack-library-workmanager-5aee2f57e07b?source=collection_archive---------8-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4bae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用高级功能处理实时工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c49fd692b2b45ef8d7c8aa68fb212a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v8gT7P62Vr0YbxPa"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="c40e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">目录</h1><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c800" class="lw la it ls b gy lx ly l lz ma">1. <a class="ae ky" href="https://medium.com/p/5aee2f57e07b#10bb" rel="noopener">Overview</a><br/>2. <a class="ae ky" href="https://medium.com/p/5aee2f57e07b#8435" rel="noopener">Integration</a><br/>3. <a class="ae ky" href="https://medium.com/p/5aee2f57e07b#785f" rel="noopener">Things to Know Before Using WorkManager</a><br/>4. <a class="ae ky" href="https://medium.com/p/5aee2f57e07b#3243" rel="noopener">Creating Workers</a><br/>5. <a class="ae ky" href="https://medium.com/p/5aee2f57e07b#3815" rel="noopener">Observing Your Status</a><br/>6. <a class="ae ky" href="https://medium.com/p/5aee2f57e07b#9261" rel="noopener">Observing Your Progress</a><br/>7. <a class="ae ky" href="https://medium.com/p/5aee2f57e07b#bf73" rel="noopener">Chaining Requests</a><br/>8. <a class="ae ky" href="https://medium.com/p/5aee2f57e07b#05df" rel="noopener">Canceling Work</a></span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="10bb" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">概观</h1><p id="fb06" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">Android环境中不断变化的一件事是我们如何处理后台任务。这是因为当手机上的应用数量增加时，后台运行的任务数量也会增加。大多数应用程序开发人员在开始工作之前不会检查电池的健康状况，这导致电池在短时间内耗尽。</p><p id="6250" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">我们有许多解决方案来处理后台任务，但是对于开发者和用户来说,<a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank"> WorkManager </a>都是更好的。WorkManager有权控制在什么情况下应该执行哪些任务。</p><p id="917d" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果你的电池电量低，那么它会停止所有在后台运行的任务，并在手机充电后重新启动它们。有了WorkManager，开发人员也可以轻松地维护周期性请求，而不必麻烦地维护时间戳。</p><h2 id="30a6" class="lw la it bd lb no np dn lf nq nr dp lj mw ns nt ll na nu nv ln ne nw nx lp ny bi translated"><strong class="ak">工作管理器是:</strong></h2><ul class=""><li id="45ef" class="nz oa it mp b mq mr mt mu mw ob na oc ne od ni oe of og oh bi translated">与API级兼容</li><li id="f8fa" class="nz oa it mp b mq oi mt oj mw ok na ol ne om ni oe of og oh bi translated">带/不带Google Play服务运行</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="8435" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">综合</h1><p id="dad2" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">WorkManager是一个Jetpack库，它一直在不断更新新特性。WorkManager开箱即可与协程和RxJava兼容。根据您的喜好集成以下工作管理器库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="785f" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">使用工作管理器之前需要了解的事项</h1><p id="8007" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">在使用WorkManager之前，您应该知道两件事情:<em class="op">约束</em>和<em class="op">工作请求的类型。</em></p><h2 id="b27f" class="lw la it bd lb no np dn lf nq nr dp lj mw ns nt ll na nu nv ln ne nw nx lp ny bi translated"><strong class="ak">约束</strong></h2><p id="07a2" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">约束只不过是一种向工作管理器传达系统应该满足某些条件来执行工作请求的方式。这些情况可能是系统需要互联网连接，也可能是系统处于节电模式而无法工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">限制</p></figure><h2 id="4c4c" class="lw la it bd lb no np dn lf nq nr dp lj mw ns nt ll na nu nv ln ne nw nx lp ny bi translated"><strong class="ak">工作请求</strong></h2><p id="417b" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">工作请求有两种类型:<code class="fe oq or os ls b">OneTime</code>和<code class="fe oq or os ls b">Periodic</code>。</p><h2 id="de2f" class="lw la it bd lb no np dn lf nq nr dp lj mw ns nt ll na nu nv ln ne nw nx lp ny bi translated"><strong class="ak">一次性工作请求</strong></h2><p id="d760" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">从名字本身，我们可以确定这个请求只执行一次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一次性工作请求</p></figure><h2 id="f189" class="lw la it bd lb no np dn lf nq nr dp lj mw ns nt ll na nu nv ln ne nw nx lp ny bi translated"><strong class="ak">阶段性工作要求</strong></h2><p id="a4e2" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">一旦我们启动了worker，这个请求就会定期执行。在构建一个worker对象时，我们必须提到执行之间的特定时间间隔。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">定期工作请求</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3243" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">创建工人</h1><p id="52f3" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">Kotlin是Android开发的一等公民，协程是处理后台任务的推荐方式。所以这里我们在例子中使用协程工作器。</p><p id="e3dd" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">为了创建一个worker类，我们需要用<code class="fe oq or os ls b">CoroutineWorker</code>扩展这个类，并实现覆盖函数<code class="fe oq or os ls b">doWork()</code>(我们将在其中执行任务)。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="61bf" class="lw la it bd lb no np dn lf nq nr dp lj mw ns nt ll na nu nv ln ne nw nx lp ny bi translated">构建请求</h2><p id="2ce3" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">现在我们有了一个工人类，让我们开始后台工作。为此，首先，我们需要创建一个约束集，并使用它来构建一个工作请求，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3815" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">观察你的状态</h1><p id="2638" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">既然我们开始了请求，在某些情况下，我们想知道工作的状态——比如它是成功还是失败。在某些情况下，当约束没有得到满足时，请求甚至不会开始，因此了解请求的当前状态是至关重要的。</p><p id="e48b" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">WorkManager有办法做到这一点。它有各种状态，每种状态代表请求的各个阶段。以下是WorkManager的一些重要状态。</p><ul class=""><li id="50b7" class="nz oa it mp b mq nj mt nk mw ot na ou ne ov ni oe of og oh bi translated"><code class="fe oq or os ls b">ENQUEUED</code>:这个状态表示请求已经排队，一旦满足约束就可以运行</li><li id="f631" class="nz oa it mp b mq oi mt oj mw ok na ol ne om ni oe of og oh bi translated"><code class="fe oq or os ls b">RUNNING</code>:该状态表示请求已经开始执行</li><li id="2dbd" class="nz oa it mp b mq oi mt oj mw ok na ol ne om ni oe of og oh bi translated"><code class="fe oq or os ls b">SUCCEEDED</code>:该状态表示请求执行成功</li><li id="43f5" class="nz oa it mp b mq oi mt oj mw ok na ol ne om ni oe of og oh bi translated"><code class="fe oq or os ls b">FAILED</code>:该状态表示请求由于某种原因失败</li></ul><p id="ec03" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">你可以在这里找到完整的状态列表<a class="ae ky" href="https://developer.android.com/reference/androidx/work/WorkInfo.State#ENQUEUED" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="23eb" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">WorkManager使用其<code class="fe oq or os ls b">id</code>提供实时数据来监控请求的状态变化。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">观察工作请求状态</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9261" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">观察你的进步</h1><p id="05dc" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">在某些情况下，观察状态变化是不够的——例如，如果应用程序在前台，您想向用户显示请求的进度。</p><p id="99b2" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">自从2.3.1稳定版发布以来，工作管理器已经有了一种方法来做到这一点。我们可以使用<code class="fe oq or os ls b">setProgress()</code>函数异步设置worker类中的进度。我们可以设置一个可以被用户界面观察到的中间进度。</p><p id="0729" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">观察进度信息和观察你的状态是一样的。您可以使用<code class="fe oq or os ls b"> <a class="ae ky" href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoById(java.util.UUID)" rel="noopener ugc nofollow" target="_blank">getWorkInfoById()</a></code>或<code class="fe oq or os ls b"><a class="ae ky" href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoByIdLiveData(java.util.UUID)" rel="noopener ugc nofollow" target="_blank">getWorkInfoByIdLiveData </a></code>方法并获得对<code class="fe oq or os ls b"><a class="ae ky" href="https://developer.android.com/reference/androidx/work/WorkInfo" rel="noopener ugc nofollow" target="_blank">WorkInfo</a></code>的引用。这里我们使用<code class="fe oq or os ls b"><a class="ae ky" href="https://developer.android.com/reference/androidx/work/WorkInfo" rel="noopener ugc nofollow" target="_blank">WorkInfo</a></code>类中的进度变量，而不是状态。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">观察工作请求进度</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="bf73" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">链接请求</h1><p id="a118" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">在一些用例中，我们希望并行地发出一组请求，或者在某些情况下，顺序地发出请求。例如，我们可能有一个图像要上传，但在此之前，我们需要应用过滤器。在这种情况下，一系列动作应该是连续的；首先，我们应该应用所有的过滤器，然后应该执行上传任务。</p><p id="8480" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">WorkManager涵盖了这种现成的场景。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链接请求</p></figure><p id="ad85" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">首先，我们通过调用<code class="fe oq or os ls b">getInstance</code>函数获得工作管理器的实例。然后我们调用<code class="fe oq or os ls b">beginWith </code>函数以及一系列可以并行执行的工作请求(过滤器)。之后，我们使用<code class="fe oq or os ls b">then </code>函数调用顺序工作器(上传)。我们可以添加多个<code class="fe oq or os ls b">then </code>函数来调用多个顺序工作器。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="05df" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">取消工作</h1><p id="f043" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">如果先前已经开始的工作没有用，那么我们可以取消请求以节省资源。我们可以使用<code class="fe oq or os ls b">cancelWorkById</code>取消请求，它将请求<code class="fe oq or os ls b">id</code>作为参数。看一看:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="49de" class="lw la it ls b gy lx ly l lz ma">WorkManager.<strong class="ls iu">cancelWorkById</strong>(downloadWork.id)</span></pre><p id="f0f7" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">这里我们需要记住的重要事情是取消一个请求也会导致取消依赖它的请求。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b067" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">奖金</h1><p id="89b5" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">要了解更多关于WorkManager的信息——比如如何将WorkManager与RxJava一起使用、worker的输入和输出机制，以及如何标记请求——请阅读本文。</p><p id="1fcd" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>