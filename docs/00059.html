<html>
<head>
<title>MVVM in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中的MVVM</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mvvm-in-ios-from-net-perspective-580eb7f4f129?source=collection_archive---------2-----------------------#2017-10-23">https://betterprogramming.pub/mvvm-in-ios-from-net-perspective-580eb7f4f129?source=collection_archive---------2-----------------------#2017-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4fc0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过将逻辑转移到视图模型中来减小庞大的视图控制器的大小</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14ee4f14587e5015cd68441561a7634b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tSduBTL840HnGUnyvKIkUQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.google.com/url?sa=i&amp;rct=j&amp;q=&amp;esrc=s&amp;source=images&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwi05eCOh4fXAhXKzlQKHTpLA8QQjhwIBQ&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DiQsnObyii4Q&amp;psig=AOvVaw1NG_SNK-lTLIC4TEenM-V3&amp;ust=1508858659679924" rel="noopener ugc nofollow" target="_blank">为什么伟大的建筑应该讲述一个故事|奥雷·舍人— YouTube </a></p></figure><p id="4d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文有更新:<strong class="lb iu"/><a class="ae ky" href="https://medium.com/@azamsharp/mvvm-in-ios-revisited-1e2de1419ba6" rel="noopener"><em class="lv">iOS中的MVVM(重访)</em> </a> <em class="lv">。</em></p><p id="445a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他相关文章:<a class="ae ky" href="https://medium.com/@azamsharp/validation-in-mvvm-for-ios-5a819be221c8" rel="noopener"> <em class="lv">在iOS中查看模型验证</em> </a>和<a class="ae ky" href="https://medium.com/@azamsharp/mvvm-in-ios-viewmodel-and-networking-5bbe1d768c7f" rel="noopener"> <em class="lv">查看模型和联网</em> </a> <em class="lv">。</em></p><p id="cb5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，有很多关于iOS应用中的MVVM以及它如何帮助驯服大规模视图控制器的症状的讨论。</p><p id="ace0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建iOS应用的默认架构模式是MVC(模型视图控制器)，虽然MVC模式没什么问题，但大多数时候，视图控制器成了代码垃圾场。</p><p id="84f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MVVM不是突然冒出来的新东西，它已经被使用了好几年，尤其是在。网络社区。我曾在许多大规模的WPF(Windows Presentation Foundation)应用程序中成功使用过MVVM。</p><p id="d2e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到这里，比较一下。NET WPF框架对iOS框架是不公平的，因为WPF使用XAML和<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/dependency-properties-overview" rel="noopener ugc nofollow" target="_blank"> <em class="lv">依赖属性</em> </a>的力量来进行双向无缝绑定。</p><p id="c686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS中，我们没有任何类似于依赖属性的东西，即使有，我们也没有像XAML那样的声明式UI代码。</p><p id="ee50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MVVM模式背后的思想是，屏幕上的每个<em class="lv">视图</em> <strong class="lb iu"> </strong>将由一个表示视图数据的<em class="lv">视图模型</em> <strong class="lb iu"> </strong>支持。</p><p id="22f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，如果我们正在构建一个新闻应用程序，那么视图可能由一个允许您显示新闻条目的<code class="fe lw lx ly lz b">UITableView</code>组成，视图模型将由表示新闻条目的数据组成，如标题、描述、<code class="fe lw lx ly lz b">publishedDate</code>、作者、来源等。</p><p id="cd3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面显示了一个示例视图。它由一个简单的<code class="fe lw lx ly lz b">UITableView</code>控件组成，该控件使用默认的<code class="fe lw lx ly lz b">UITableView</code>单元格进行显示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/63bf9cf704cbb6d7c6bc869862841d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*ZywEyTPYcrKEPyS8pkO-hg.png"/></div></figure><p id="28e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，考虑您想要在视图中显示什么数据。为了简单起见，我们将显示一个标题和描述。因此，视图模型将由能够提供标题和描述的属性组成。</p><p id="9b86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一个实现可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然代表了我们想要在<code class="fe lw lx ly lz b">UITableView</code>中显示的数据，但是它确实有一些缺点。</p><p id="e972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它只表示视图中可以被填充的部分。视图模型应该能够容纳完整的视图。查看下面的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过添加父视图模型<code class="fe lw lx ly lz b">ArticleListViewModel</code>，我们可以更加灵活地控制屏幕上的项目。</p><p id="c57f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果将来我们需要添加一个搜索栏，那么我们可以简单地在我们的<code class="fe lw lx ly lz b">ArticleListViewModel</code>中添加一个对<code class="fe lw lx ly lz b">SearchViewModel</code>的引用。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="d26e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">查看型号+联网=？</h1><p id="91c3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在研究iOS中的MVVM实现时，我遇到了许多资源，其中开发人员在视图模型中实现了网络代码和数据访问代码。</p><p id="5819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面显示了一种可能的实现方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="eef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的视图模型应该尽可能的简单。它不应包含网络代码或数据访问代码。</p><p id="cfb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您开始在视图模型中执行网络操作时，您正在视图模型层和web服务层之间添加紧密耦合。</p><p id="9dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新:正如少数读者指出的，我认为您的视图模型不应该调用web服务是不公平的，因为长期以来一直使用MVVM架构的微软似乎确实提倡从视图模型内部调用web服务的想法。</p><p id="ded6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在iOS社区，我也看到开发人员使用不同风格的MVVM架构。我鼓励你选择最符合你需求的MVVM建筑。</p><p id="c17a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络和数据访问操作应该从视图模型中分离出来，并且应该是单独的类或者甚至是单独的框架/库的一部分。</p><p id="0001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的应用程序，网络和数据访问操作可以作为依赖注入传递到视图控制器构造函数中。</p><p id="e3c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个web服务调用的实现，它发生在视图控制器内部，但是由一个单独的web服务类控制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="94c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">web服务返回域对象，然后这些域对象被映射到视图模型对象。这种映射可以手动执行，或者使用任何类似于. NET中的<a class="ae ky" href="http://automapper.org/" rel="noopener ugc nofollow" target="_blank">自动映射器</a>的iOS自动映射工具来执行。</p><p id="a8c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当映射完成时，我们设置触发<code class="fe lw lx ly lz b">UITableView</code>重载的视图模型。由于<code class="fe lw lx ly lz b">didSet</code>属性的行为，这个触发会自动发生。</p><p id="9ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，当属性设置在类的构造函数中时，<code class="fe lw lx ly lz b">didSet</code>不会被触发。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="8fa3" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">MVVM绑定</h1><p id="0019" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">绑定指的是视图和视图模型之间的信息流。</p><p id="9ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一个场景，您必须创建一个注册屏幕。当您在文本字段中键入信息时，它也会立即被填充到<code class="fe lw lx ly lz b">RegistrationViewModel</code>对象上。</p><p id="811b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，您不必键入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="7680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绑定是双向的！这意味着，如果修改视图模型属性，它会反映在视图中。这也称为双向绑定。</p><p id="4310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我前面提到的，在WPF框架中，绑定是由依赖属性处理的。不幸的是，Swift没有任何依赖属性，因此我们必须做一些工作来实现这一点。</p><p id="0b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能在字符串类型上放置一个观察者，这意味着我们将创建我们的自定义类并允许它被观察。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="41a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b"><a class="ae ky" href="http://rasic.info/bindings-generics-swift-and-mvvm/" rel="noopener ugc nofollow" target="_blank">Dynamic&lt;T&gt;</a></code>是一个自定义类，可以保存类型<code class="fe lw lx ly lz b">T</code>的值。如果值改变了，那么我们触发<code class="fe lw lx ly lz b">didSet</code>，它调用绑定函数，将值传递回调用者。实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="afad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将建立从视图模型到用户界面元素的单向绑定。这意味着如果视图模型的属性发生变化，那么用户界面元素会得到通知。</p><p id="1d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建一个双向绑定，您需要实现一个定制的<code class="fe lw lx ly lz b">UITextField</code>控件。这在下面实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="914a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe lw lx ly lz b">editingChanged</code>事件附加到<code class="fe lw lx ly lz b">UITextField</code>上，然后触发一个自定义回调函数。现在，您可以更新<code class="fe lw lx ly lz b">IBOutlets</code>来使用这个新的绑定函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不漂亮，但它的工作！</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="e9bf" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="da02" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这只是对MVVM模型的一个非常初步的了解。我相信，如果Swift允许定制属性的功能，iOS中的MVVM方法将会大大改进。</p><p id="8ec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将允许我们创建动态验证框架，其中每个视图模型都可以轻松地验证和返回与视图相关联的不规则。</p><p id="b136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如Michael Long在评论中指出的，MVVM让测试观点背后的逻辑变得很容易。</p><blockquote class="nh ni nj"><p id="cdca" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">将<code class="fe lw lx ly lz b">ViewController</code>的业务逻辑移入<code class="fe lw lx ly lz b">ViewModel</code>的另一个好处是，<code class="fe lw lx ly lz b">viewModel</code>为应用程序的这些组件创建单元测试变得容易多了。</p></blockquote><p id="2f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从这里下载代码:</p><div class="nn no gp gr np nq"><a href="https://github.com/azamsharp/HeadlinesMVVM" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">azamsharp/HeadlinesMVVM</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">在GitHub上创建一个帐户，为HeadlinesMVVM的开发做出贡献。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div></div></div>    
</body>
</html>