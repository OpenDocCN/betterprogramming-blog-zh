<html>
<head>
<title>Should You Stop Using .forEach() in Your JavaScript Code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该停止使用。JavaScript代码中的forEach()。</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-stop-using-foreach-in-your-javascript-code-efe1e86c78e5?source=collection_archive---------1-----------------------#2020-04-14">https://betterprogramming.pub/should-you-stop-using-foreach-in-your-javascript-code-efe1e86c78e5?source=collection_archive---------1-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad63" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探讨流行的ES5数组方法背后的警告</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/71a6cd30a03761389c179b4981e68972.png" data-original-src="https://miro.medium.com/v2/format:webp/1*xx8z3FF940mMWMTyNSPGDA.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源:作者</p></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="cc80" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">介绍</h1><p id="7275" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我来自PHP背景，当我第一次看到人们利用<code class="fe mp mq mr ms b">.forEach()</code>方法遍历他们的数组时，我的nooby self认为这没什么——这和标准<code class="fe mp mq mr ms b">for</code>循环的实现完全一样，我告诉自己。写了一些JavaScript代码后，我很快意识到这两者有其不同之处。</p><p id="c350" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mv me mf mg mw mi mj mk mx mm mn mo im bi translated">在这篇文章中，我想概述标准的<code class="fe mp mq mr ms b">for</code>循环和<code class="fe mp mq mr ms b">.forEach()</code>方法背后的区别，并评论它们各自带来的好处。</p><p id="8ec2" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mv me mf mg mw mi mj mk mx mm mn mo im bi translated">作为免责声明，请不要照字面理解标题。我写这篇文章的目的是告诉读者瓶颈，并提供关于何时你可能想或不想使用<code class="fe mp mq mr ms b">.forEach()</code>的见解——仅此而已。我们开始吧！</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="3e74" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">forEach如何工作</h1><p id="7417" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated"><code class="fe mp mq mr ms b">forEach</code>方法接受一个回调函数作为输入，对于你正在迭代的数组中的每个元素，这个回调函数将被执行。应该注意，回调函数可以接受一些可选参数。它们包括传递给函数的当前值，当前值各自的索引。<code class="fe mp mq mr ms b">forEach</code>函数还为在回调函数中定义<code class="fe mp mq mr ms b">this</code>提供了一个可选参数。</p><p id="af95" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mv me mf mg mw mi mj mk mx mm mn mo im bi translated">请考虑以下情况:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/a0c483db2067e976382e42fb96db1e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QwwmTTyEyoxYUfuH.png"/></div></div></figure><p id="aca7" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mv me mf mg mw mi mj mk mx mm mn mo im bi translated">相应的输出将是:</p><pre class="ki kj kk kl gt nd ms ne nf aw ng bi"><span id="5081" class="nh lc it ms b gy ni nj l nk nl">corgis - 0<br/>are - 1<br/>cool - 2</span></pre></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="d5d5" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">短路</h1><p id="bbac" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果你不知道短路是什么，它指的是我们提前终止和/或跳过一个循环的迭代。当我们使用<code class="fe mp mq mr ms b">forEach()</code>时，没有办法利用短路，在我们循环的所有情况下，我们将忍受相对于数组大小的线性运行时间。</p><p id="7e45" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mv me mf mg mw mi mj mk mx mm mn mo im bi translated">我为什么要关心这个？假设我们有一个由10亿个元素组成的未排序数组，我们想要找到某个元素。假设我们非常幸运，在循环的第一次迭代中找到了这个元素。实际上，我们想要提前返回，因为我们找到了我们要找的东西，但是按照<code class="fe mp mq mr ms b">forEach()</code>的实现方式，我们将总是遍历剩余的元素。对于这类问题，我们可能会使用<code class="fe mp mq mr ms b">.findIndex()</code>方法。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="f90b" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">表演</h1><p id="b7b3" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在<code class="fe mp mq mr ms b">forEach()</code>方法中，由于我们在每次迭代时都调用回调函数，所以我们创建了一个额外的作用域开销，这导致了比本机<code class="fe mp mq mr ms b">for</code>循环更慢的速度。与传统的<code class="fe mp mq mr ms b">for</code>循环相比，我们有一个初始化语句，一个在每次迭代中评估的条件，以及一个在循环体递增后的执行阶段。相对于<code class="fe mp mq mr ms b">forEach()</code>方法，我们必须在每次迭代中创建额外的函数调用，这是一个更低的成本。</p><p id="8c07" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mv me mf mg mw mi mj mk mx mm mn mo im bi translated">为了测试性能，我创建了一个计时器脚本，它在初始化数组后跟踪执行时间。两个循环都在它们的体内执行一个简单的O(1)运算:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7142a80c76a8345079131ba8b1073ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*6nliuX3pkAVE7YCZtC_5Ig.png"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="8320" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">可读性</h1><p id="ceba" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">开发软件时，创建可维护和可读的代码应该是重中之重。我认为在你的代码中继续使用<code class="fe mp mq mr ms b">forEach()</code>的一个非常有效的理由是为了可读性。随着方法链接几乎成为JavaScript中数组的第二天性，使用<code class="fe mp mq mr ms b">forEach()</code>循环而不是<code class="fe mp mq mr ms b">for</code>循环遍历数组读起来会更好。</p><p id="ff2a" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mv me mf mg mw mi mj mk mx mm mn mo im bi translated">还应该注意的是，输入量非常大的情况(如上例所示)不太可能出现。在合理的输入大小时，这两个环路的性能相对相同。你愿意牺牲可读性，让函数的执行速度快几毫秒吗？</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="16bc" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">结论</h1><p id="444f" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">ECMAScript最新版本中发布的方法从整体上提高了JavaScript的标准。我最相信在工作中使用正确的工具。如果你需要读取一个数组中的大量元素，那么一个本地的<code class="fe mp mq mr ms b">for</code>循环可能是你问题的解决方案。否则，当使用<code class="fe mp mq mr ms b">.forEach()</code>或任何后来发布的ES数组方法时，除了轻微的性能损失之外，我看不到任何问题。在大多数情况下，我倾向于在可读性和性能之间进行权衡。</p></div></div>    
</body>
</html>