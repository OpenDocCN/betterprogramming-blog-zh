<html>
<head>
<title>How to Use Static Analysis Tools on Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对Python代码使用静态分析工具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-add-a-static-scanner-to-your-ide-for-python-e3a7e287f214?source=collection_archive---------9-----------------------#2022-11-29">https://betterprogramming.pub/how-to-add-a-static-scanner-to-your-ide-for-python-e3a7e287f214?source=collection_archive---------9-----------------------#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2e0f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在您的IDE中添加静态扫描器来检查漏洞</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1428e466239fda7c2937781b7f73be9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xBt2Q4weXuyx6HrE"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@cdr6934" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>通过<a class="ae kv" href="https://unsplash.com/photos/ieic5Tq8YMk" rel="noopener ugc nofollow" target="_blank"> unsplash </a>拍摄</p></figure><p id="62e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的几年中，静态代码分析器极大地促进了应用程序的开发。静态分析不是发现生产系统或部署中的代码问题或漏洞，而是根据类型和其他代码提示告诉我们代码将在哪里失败。</p><p id="9ad3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们将深入探讨Python开源静态分析工具的几个选项，展示它们是如何工作的，以及您可以在编程之旅中获得哪些好处。</p><h1 id="9080" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">静态代码分析到底是什么？</h1><p id="4502" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">静态代码分析只是检查程序的源代码，而不是实际运行它。这使您可以在代码中的错误成为问题之前找到它。静态分析还可以发现代码中的漏洞，使代码更加安全。</p><h1 id="5146" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Python代码分析</h1><p id="2053" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了展示静态分析有多健壮，我将在一台甚至没有安装Python的计算机上构建这个应用程序。</p><p id="c490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我将设置一个分析器，并按照它产生的一些提示进行操作。现代扫描器超越了代码风格和格式，以解决<a class="ae kv" href="https://www.mend.io/resources/blog/sast-static-application-security-testing/" rel="noopener ugc nofollow" target="_blank"> SAST漏洞</a>、空检查和标准应用程序，我们将尝试用这个示例项目来演示。</p><p id="1adf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先从这个应用程序开始，它检查二叉树中的一个节点是否包含某些信息，并打印出它的路径。它接收一个被分解成一些<code class="fe mp mq mr ms b">node</code>和<code class="fe mp mq mr ms b">relationship</code>定义的文件。它将这些定义解析成树，然后在树中搜索特定的节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="60c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了核心应用程序代码，我们还会有一个<code class="fe mp mq mr ms b">dockerfile</code>:</p><pre class="kg kh ki kj gt mv ms mw bn mx my bi"><span id="bbe7" class="mz lt iq ms b be na nb l nc nd">FROM python:3<br/>WORKDIR /app<br/><br/>COPY requirements.txt ./<br/><br/>RUN pip install — no-cache-dir -r requirements.txt<br/><br/>COPY . .<br/><br/>CMD [“python”, “./main.py”]</span></pre><p id="9b72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和<code class="fe mp mq mr ms b">docker-compose</code>运行应用程序:</p><pre class="kg kh ki kj gt mv ms mw bn mx my bi"><span id="a155" class="mz lt iq ms b be na nb l nc nd">services:<br/>  python:<br/>    build: .<br/>    volumes:<br/>      - ./tmp:/tmp</span></pre><p id="d94c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们先了解一些基础知识——我们将为VS代码安装<a class="ae kv" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank"> MyPy </a>扩展。这将使我们进行静态类型检查。安装后，我们立即得到一些反馈，L74上的<code class="fe mp mq mr ms b">findNode</code>方法调用用红色下划线标出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f38f9cfaf96816d5a972ebc550bc8a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*38yCXPgDW7KMP6_1"/></div></div></figure><p id="8688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一些很好的信息！<code class="fe mp mq mr ms b">MyPy</code>能够立即检测到我们在路径的<code class="fe mp mq mr ms b">findNode</code>方法调用中缺少位置参数——我们可以通过将该行改为:</p><pre class="kg kh ki kj gt mv ms mw bn mx my bi"><span id="bf8e" class="mz lt iq ms b be na nb l nc nd">target_node, path = findNode(root, ‘’, search)</span></pre><p id="98c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">啊，但是等等——路径不应该是字符串。</p><p id="0327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而似乎并不明白这一点。这是因为我们缺少我们所期望的这个值的类型注释。让我们更新该方法，使其具有一些类型注释:</p><pre class="kg kh ki kj gt mv ms mw bn mx my bi"><span id="c654" class="mz lt iq ms b be na nb l nc nd">def findNode(node: node, path: list[str], search: str):</span></pre><p id="67cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们把它保存为一个字符串，我们几乎马上就会得到错误类型的反馈:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/68a14183908a43efe6eeaea9651b90bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OfOUA6YW55lwJv2N"/></div></div></figure><p id="390d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将把它转换为数组声明，将调用更新为:</p><pre class="kg kh ki kj gt mv ms mw bn mx my bi"><span id="88e6" class="mz lt iq ms b be na nb l nc nd">target_node, path = findNode(root, [], search)</span></pre><p id="6471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们现在有一个问题，几个参数有不正确的注释，并且<code class="fe mp mq mr ms b">findNode</code>方法体被红色下划线覆盖。</p><p id="74dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们已经在文件中定义了<code class="fe mp mq mr ms b">node</code>类，但是它没有注释，并且<code class="fe mp mq mr ms b">MyPy</code>已经根据编写的代码尽最大能力假设了那些参数的类型。需要更多的帮助来解决这些问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/901ae5c5d138c6cdc9457b43c47ac7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_7YxY0fjsn0rVIBJ"/></div></div></figure><p id="8150" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过用所需的注释设置节点类来修复这些注释。我们将需要从类型库中导入<code class="fe mp mq mr ms b">Optional</code>注释，然后我们将能够使用它来纠正一些静态类型错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们看到MyPy在<code class="fe mp mq mr ms b">findNode</code>方法中的一些更有趣的输出——内部<code class="fe mp mq mr ms b">findNode</code>调用和<code class="fe mp mq mr ms b">path.copy().append</code>都用红色下划线标出。</p><p id="e5d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们将鼠标悬停在调用<code class="fe mp mq mr ms b">findNode</code>的红色下划线上时，我们会看到错误:</p><blockquote class="nf ng nh"><p id="c1c5" class="kw kx ni ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated">“findNode”的参数1具有不兼容的类型“可选[节点]”；应为" node" [arg-type]mypy(错误)</p></blockquote><p id="22eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们将左右节点属性设为可选属性，因为我们希望从根到叶加载树定义，所以在创建左右节点并实施关系之前，我们不会有左右节点。</p><p id="687e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，MyPy警告我们，我们正试图访问一个可能为null的属性，这将是一个运行时错误。让我们添加一些快速保护代码来清除分析错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bcc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这清除了第一个错误，但是当我们将鼠标悬停在调用<code class="fe mp mq mr ms b">path.copy().append</code>的红色下划线上时，我们会看到另一个错误:</p><blockquote class="nf ng nh"><p id="49f0" class="kw kx ni ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated">“列表”的“追加”不返回值[func-returns-value]mypy(错误)</p></blockquote><p id="a119" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来我们在这里放了一些代码，做了我们想做的事情，但是因为它没有返回变异列表，所以在运行时会有一个错误。</p><p id="90b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，静态分析给了我们一个提示，所以我们没有浪费宝贵的时间来调试为什么应用程序会崩溃或以意想不到的方式运行。让我们快速写出一组正确的命令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="644d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些是我们在实际运行代码之前就发现的应用程序代码的主要问题。这节省了我们大量的时间来找出为什么代码的输出是不正确的。</p><h2 id="5363" class="nm lt iq bd lu nn no dn ly np nq dp mc lf nr ns me lj nt nu mg ln nv nw mi nx bi translated">强盗</h2><p id="e846" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们来看看另一个清除代码安全问题的解决方案— <a class="ae kv" href="https://bandit.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Bandit </a>，它是一个很棒的SAST漏洞扫描工具。遵循<a class="ae kv" href="https://bandit.readthedocs.io/en/latest/start.html" rel="noopener ugc nofollow" target="_blank">文档</a>链接，Bandit<em class="ni">真的</em>容易设置。一旦它被安装在本地系统上，我们就可以将linter切换到Bandit，并对当前的main.py文件执行它。</p><p id="d17a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">啊哦！Bandit已经发现了另一个问题！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/9090dc5ae778114b8e089247b50d7423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SClX30OC1cWHGyz1"/></div></div></figure><p id="4ac6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">班迪特是正确的。我们的应用程序代码目前引用了来自<code class="fe mp mq mr ms b">/tmp</code>——Linux发行版中的顶级目录和可能的攻击媒介。</p><p id="6a50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该引用与应用程序代码相关的本地文件夹中的数据，或者在代码入口点允许参数化的条目。</p><p id="9f9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这是我们唯一的警告，我们将切换到<code class="fe mp mq mr ms b">./data</code>下的本地文件夹，并修改docker-compose以将数据文件夹内容放入新的本地文件夹。</p><p id="c317" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您查看了Bandit的开源存储库，您也可以将许多示例文件导入到项目中，以查看Bandit可能在您自己的代码中暴露的其他漏洞。</p><p id="fcb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们得到一些关于代码的启发。</p><h2 id="0591" class="nm lt iq bd lu nn no dn ly np nq dp mc lf nr ns me lj nt nu mg ln nv nw mi nx bi translated">氡</h2><p id="0d5b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为此，我们可以使用Radon，它是一个开源包，可以生成各种有趣的代码度量。在快速简单的安装之后，我们可以用<code class="fe mp mq mr ms b">cc</code>命令(圈复杂度)将radon指向我们的代码文件，以获得一些很酷的指标:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8ce3a61f903b29f919831d375f56b3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/0*3dkrqXfZwjNQpXgc"/></div></figure><p id="cc2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于圈复杂度(这可能是可维护性的一个主要指标)，看起来我们没有得到任何特别可怕的结果，所以这很好。</p><p id="9926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如此低的平均复杂度是成功的，但是在更大的代码库中，我们可能甚至不想看到低复杂度的结果。Radon还有一个标志<code class="fe mp mq mr ms b">--nc</code>，只显示“C”或更差的结果。</p><p id="25c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们也来看看关于raw命令代码的一些核心指标:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/1a39e5134c614f351465979d38c5ff3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mATZ8R64JafqFFRS"/></div></div></figure><p id="1b2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这打印出了一些关于代码行的重要信息，区分了逻辑代码行(LLOC)和源代码行(SLOC)、注释以及本质上的注释覆盖。让我们添加两个注释，看看有什么不同:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/7c3831418576ee784531c6d6d590fa64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bZCBhmW-OEihUBSO"/></div></div></figure><p id="f54d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">啊，现在我们也有了一些评论指标。太棒了。</p><p id="667e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">halstead</code>复杂性度量是我们可以借助Radon收集的另一组非常有趣的度量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/3ff933244d0bbe66dbdb467072c28678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3GSQ_Zl7ZIrSb5g0"/></div></div></figure><p id="4e8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，该命令可以使用<code class="fe mp mq mr ms b">-f</code>标志为代码文件中的每个函数单独运行。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="153d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个有趣的命令是<code class="fe mp mq mr ms b">mi</code>。它打印出一个可维护性指数，该指数从其他几个命令中收集信息，对代码的易维护性进行总体评价:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/a9230736061770ad477efd0a1414cb03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J2l0HCJtkyxTFVhW"/></div></div></figure><p id="5533" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个应用程序正在顺利通过！Radon文档提供了关于如何计算的更多信息。</p><h1 id="020b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包扎</h1><p id="3b8f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这篇博文概述了各种可用于静态分析的工具，包括Bandit和Radon。</p><p id="65af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bandit发现了代码中的一个漏洞，Radon生成了关于代码复杂性和可维护性的指标。根据Radon可维护性指数，该应用程序被视为“成功通过”。</p><p id="07b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望静态代码分析空间中几个选项的分解对您有所帮助！感谢您的阅读。</p></div></div>    
</body>
</html>