<html>
<head>
<title>Avoiding Unnecessary Renders in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免React中不必要的渲染</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/avoid-unnecessary-renders-in-react-14e9dfeaf090?source=collection_archive---------2-----------------------#2022-01-30">https://betterprogramming.pub/avoid-unnecessary-renders-in-react-14e9dfeaf090?source=collection_archive---------2-----------------------#2022-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3aa7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">优化您的React前端</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/59071fa7293865248854187664981b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q-rM-FUo1EoehnDT"/></div></div></figure><p id="d63f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React的承诺是，当一个组件的道具或状态改变时，它将呈现这个组件。</p><p id="7eec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这很好，但我们可能不希望所有的更改都触发重新渲染。因此，我们需要处理好这些。我们将讨论一些我们能够并且应该防止重新渲染发生的情况。</p><h1 id="4dd2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">只传递需要的道具</strong></h1><p id="3b70" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">不要把不必要的道具传递给组件，只传递需要的。<br/>取两个兄弟组件，一个圆形组件，它在屏幕上显示动画，一个文本组件，它只输出圆形的半径，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="649a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">问题是，即使<code class="fe mm mn mo mp b">Info</code>不依赖于<code class="fe mm mn mo mp b">xCenter</code>和<code class="fe mm mn mo mp b">yCenter</code>，当圆圈在屏幕上移动时，对它的改变将再次被重新渲染，从而导致它被重新渲染。</p><p id="dc11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们应该显式地只将需要的组件传递给子组件。<code class="fe mm mn mo mp b">Screen</code>组件应修改如下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b120" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们可以确保只将需要的道具传递给组件。这就是我喜欢TypeScript的原因，它会毫不犹豫地标记初始代码。</p><h1 id="ae4e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">使用React。避免重新渲染的备忘录</strong></h1><p id="1480" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">无论如何，即使有了这些改进，我们仍然没有完成。</p><p id="06ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">问题是，如果父组件由于属性或状态的改变而被重新渲染，子组件也可能被重新渲染，即使它不依赖于属性。</p><p id="3720" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用记忆化来解决这个问题，这样可以确保组件只有在属性和状态改变时才被重新渲染。遵循<a class="ae mq" href="https://dmitripavlutin.com/use-react-memo-wisely/" rel="noopener ugc nofollow" target="_blank">这个</a>模式来明智地使用<code class="fe mm mn mo mp b">React.memo</code>。</p><p id="3eb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记忆的组件将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="5763" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在要使用它，我们导入记忆版本。我们甚至应该记住父对象，以避免任何重新绘制，这样，如果父对象的父对象改变了，那么<code class="fe mm mn mo mp b">Screen</code>将不会被重新绘制。尽管这取决于您的用例，但可能不会发生。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="1774" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">使用回调防止多次传递函数</strong></h1><p id="c24b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">让我们介绍另一个组件，屏幕上的一个按钮，它只是用来处理一些点击来做一些非常酷的事情。我们也不要忘记记住它，这样我们就可以得到我们刚刚讨论过的很酷的特性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="96ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，这里有一个陷阱。用于组件的变化检测是浅层的，它通常只比较参考变化。</p><p id="3290" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，考虑:</p><pre class="kg kh ki kj gt mr mp ms mt aw mu bi"><span id="d9fd" class="mv lo iq mp b gy mw mx l my mz">const object1 = {a:1}<br/>const object2 = {a:1}<br/>object1 == object2</span></pre><p id="aa8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这会给你假的。这是因为这两个对象指向不同的引用，因此即使作为道具传递，它们也是不同的。</p><pre class="kg kh ki kj gt mr mp ms mt aw mu bi"><span id="ca1e" class="mv lo iq mp b gy mw mx l my mz">&lt;MemoizedButton handleClick={() =&gt; {superClick(radius)}}/&gt;</span></pre><p id="6891" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里发生的事情是，无论何时呈现<code class="fe mm mn mo mp b">Screen</code>组件，按钮仍将被重新呈现，只是因为新的<code class="fe mm mn mo mp b">handleClick</code>将被重新分配。</p><p id="8239" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们需要将函数封装在一个<code class="fe mm mn mo mp b">useCallback</code>钩子中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><blockquote class="na nb nc"><p id="13ed" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated">官方的React文档很好地解释了这一点:</p><p id="e69f" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated">useCallback将返回回调的记忆化版本，该版本仅在其中一个依赖关系发生变化时才会发生变化。这在向依赖引用相等的优化子组件传递回调以防止不必要的渲染时很有用<br/>【https://reactjs.org/docs/hooks-reference.html#usecallback T4】</p></blockquote><h1 id="29ea" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">现在让我们继续看列表</strong></h1><p id="475f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">总是使用唯一的键来避免重新呈现大的列表。没有一个键是不好的，但是使用一个有可能在渲染周期之间改变的键也是不好的，如果不是“更坏”的话。这里的目标是使用一个即使组件被重新呈现也不会改变的键。</p><p id="a1b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，呈现文章卡片的列表，这可以是文章的slug、文章的URL、文章的数据库ID(如果可用的话)。如果它是一个字符串列表，如果它们是唯一的，字符串本身可以被认为是键。</p><p id="70b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦键是惟一的，React将知道只呈现列表中发生变化的项目，而不是在列表中发生变化时呈现整个列表。现在我知道这是很多，我将在另一篇文章中进一步解释。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="887b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用户资源来之不易，不使用是没有必要的。这是我关于优化React前端的系列文章的第一部分。感谢阅读。</p></div></div>    
</body>
</html>