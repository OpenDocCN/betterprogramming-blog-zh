<html>
<head>
<title>How To Use MVVM in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在颤振中使用MVVM</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-mvvm-in-flutter-4b28b63da2ca?source=collection_archive---------0-----------------------#2022-09-07">https://betterprogramming.pub/how-to-use-mvvm-in-flutter-4b28b63da2ca?source=collection_archive---------0-----------------------#2022-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3e29" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">颤振开发人员的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/26d3c0a2fedca390a716911df52cadcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mos0ApyqZ9TjunDu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@rayhennessy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷·轩尼诗</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="2d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本指南中，我们将简要介绍以下内容:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9ba1" class="ma mb it lw b gy mc md l me mf"><a class="ae ky" href="#9fcb" rel="noopener ugc nofollow">What is MVVM</a><br/><a class="ae ky" href="#d20e" rel="noopener ugc nofollow">Using MVVM in Flutter</a><br/><a class="ae ky" href="#28b7" rel="noopener ugc nofollow">Extending MVVM with Repository and Services</a></span></pre><blockquote class="mg mh mi"><p id="4a81" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:本文假设读者知道<a class="ae ky" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank">提供者</a>。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="9fcb" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">什么是MVVM</h1><p id="fc71" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">模型-视图-视图模型(MVVM)是一种软件架构模式，支持UI(视图)与业务逻辑或后端逻辑(模型)的开发分离。MVVM内部的视图模型是负责数据转换的桥梁，它通过UI上发生的变化来表现。</p><p id="c378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，要了解这三个组件的职责，了解它们如何交互也很重要。在最高级别，视图“知道”视图模型，视图模型“知道”模型，但是模型不知道视图模型，视图模型不知道视图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/11c84578fc756e89a66d096b16de58b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*Plj_xKz_2EwTrXQz.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MVVM建筑</p></figure><p id="af8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用MVVM有几个优点:</p><ul class=""><li id="9862" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">关注点分离:这是一个将计算机程序分成不同部分的设计原则，这样每个部分处理一个单独的关注点。关注点是为问题提供解决方案的任何事情。</li><li id="4703" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">改进的可测试性</li><li id="f306" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">定义的项目结构</li><li id="6e9c" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">UI的并行开发</li><li id="a122" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">抽象出<code class="fe oa ob oc lw b">View</code>，从而减少其背后代码中所需的业务逻辑数量</li></ul><p id="b733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用MVVM的一些缺点:</p><ul class=""><li id="2f7d" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">它的学习曲线有点陡峭。理解所有层如何协同工作可能需要一些时间。</li><li id="19b6" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">它增加了很多额外的类，所以对于低复杂度的项目来说并不理想。</li></ul><p id="60a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于架构或设计模式是平台无关的，它们可以用于任何框架，在我们的例子中，就是Flutter。</p><div class="od oe gp gr of og"><a href="https://youtube.com/shorts/naOmmUHJMsQ" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">在颤振中使用MVVM🤩👨‍💻#建筑#颤动#短裤</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">模型-视图-视图模型(MVVM)是一种软件架构模式，支持用户界面(即视图)的分离</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">youtube.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><h1 id="9c9f" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">成分</h1><p id="30ac" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">模型:这是域模型或者代表来自后端的数据的模型(也称为数据访问层)。模型保存信息，但通常不处理行为。它们不格式化信息，也不影响数据的显示方式。MVVM设计模式中的模型代表了将在应用程序开发中使用的实际数据</p><p id="9653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图:这是用户真正与之交互的应用程序的唯一部分。例如，用户按下按钮、滚动列表、编辑设置等。，然后这些事件被转发给视图模型，视图模型进行处理并返回预期的用户响应(某种形式的UI)。重要的是要记住视图不负责处理状态。</p><blockquote class="mg mh mi"><p id="9084" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">一个<code class="fe oa ob oc lw b"><em class="it">View</em></code>应该尽可能的哑。千万不要把你的业务逻辑放在<code class="fe oa ob oc lw b"><em class="it">Views</em></code>里。</p></blockquote><p id="f18a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图模型:<code class="fe oa ob oc lw b">ViewModel</code>作为视图和模型之间的媒介，为UI提供数据。<code class="fe oa ob oc lw b">ViewModel</code>还可以公开帮助维护视图状态的方法，根据视图上的动作更新模型，并触发视图上的事件。对于Flutter，我们有一个名为<code class="fe oa ob oc lw b"><a class="ae ky" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" rel="noopener ugc nofollow" target="_blank">ChangeNotifier</a></code>的侦听器，它允许ViewModel在数据更新时通知或更新视图。</p><p id="80de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc lw b">ViewModel</code>有两个职责:</p><ul class=""><li id="b726" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">它对用户输入作出反应(例如，通过改变模型、发起网络请求或路由到不同的屏幕)</li><li id="f223" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">它提供了<code class="fe oa ob oc lw b">View</code>可以订阅的输出数据</li></ul><blockquote class="mg mh mi"><p id="6f00" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">总之，<code class="fe oa ob oc lw b"><em class="it">ViewModel</em></code>位于UI层之后。它公开了视图所需的数据，并且可以被看作是视图获取数据和动作的来源。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/e1734074bfb1db6eac7629f8a1acc9a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anR0IAe6b0XTeCLAxs5XrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动荡中的MVVM</p></figure><h1 id="f24c" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">什么是ChangeNotifier？</h1><p id="d8db" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><a class="ae ky" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" rel="noopener ugc nofollow" target="_blank"> ChangeNotifier </a>是一个向其监听器提供变更通知的类。</p><p id="3270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据官方<a class="ae ky" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="mg mh mi"><p id="f538" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">一个可以扩展或混合的类，它使用<a class="ae ky" href="https://api.flutter.dev/flutter/dart-ui/VoidCallback.html" rel="noopener ugc nofollow" target="_blank"> VoidCallback </a>来提供变更通知API。</p><p id="c39f" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">对于添加侦听器，它是O(1 ),对于删除侦听器和调度通知，它是O(N )(其中N是侦听器的数量)。</p></blockquote><p id="87bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以在Flutter中使用更改通知程序。</p><ol class=""><li id="0fa0" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu ow ns nt nu bi translated">使用<code class="fe oa ob oc lw b">.addListener</code>方法，因为ChangeNotifier是<a class="ae ky" href="https://api.flutter.dev/flutter/foundation/Listenable-class.html" rel="noopener ugc nofollow" target="_blank"> Listenable </a>的一种类型。</li><li id="7a5e" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ow ns nt nu bi translated">使用<code class="fe oa ob oc lw b">ChangeNotifierProvider</code>、消费者和提供者的组合。所有这些功能都由<a class="ae ky" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank">提供者</a>包提供给我们。</li></ol><h2 id="6180" class="ma mb it bd mq ox oy dn mu oz pa dp my li pb pc na lm pd pe nc lq pf pg ne ph bi translated">我们将使用第二种方法</h2><p id="d567" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在现实世界中，其他类可以监听一个<code class="fe oa ob oc lw b">ChangeNotifier</code>对象。当变更通告程序获得更新的值时，它可以调用一个叫做<code class="fe oa ob oc lw b"><a class="ae ky" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" rel="noopener ugc nofollow" target="_blank">notifyListeners</a> </code>的方法，然后它的任何一个监听器都会收到更新的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更改通知程序</p></figure><p id="35b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用程序中，如果<code class="fe oa ob oc lw b">age</code>发生变化，任何监听这个<code class="fe oa ob oc lw b">Person</code>的类都会得到通知。在内部，<code class="fe oa ob oc lw b">notifyListeners</code>调用注册的监听器。</p><div class="od oe gp gr of og"><a href="https://medium.com/flutter-community/using-mockito-in-flutter-cd015d338277" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">在Flutter中使用Mockito</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">在Flutter中使用Mockito</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">在Fluttermedium.com使用Mockito</p></div></div><div class="op l"><div class="pj l or os ot op ou ks og"/></div></div></a></div><h1 id="d20e" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">在颤振中使用MVVM</h1><p id="3992" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">颤动是宣示性的。这意味着Flutter通过覆盖您的构建方法来构建UI，以反映应用程序的当前状态:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c819" class="ma mb it lw b gy mc md l me mf">UI = fn(state)</span></pre><p id="910a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://docs.flutter.dev/development/data-and-backend/state-mgmt/ephemeral-vs-app" rel="noopener ugc nofollow" target="_blank"> Flutter文档</a>，状态被描述为“在任何时间点重建用户界面所需的数据”</p><p id="0054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个状态可以包含在一个小部件中，称为本地状态。Flutter提供了内置的类和方法来处理像<code class="fe oa ob oc lw b">StatefulWidget</code>和<code class="fe oa ob oc lw b">setState</code>这样的自包含状态。</p><p id="ed41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，必须在不同小部件之间共享的状态被称为应用程序状态。正是在这一点上，我们引入了状态管理工具。</p><blockquote class="mg mh mi"><p id="307e" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank">提供者</a>进行状态管理。</p></blockquote><p id="18b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您要设计一个只包含下图的应用程序。你会怎么做？</p><p id="3ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:使用MVVM。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/fc18ff97b4dc2f8165767ce4fd558910.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*KG0NtOrb3RIKXR4HJ2Amfw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">样本屏幕</p></figure><ul class=""><li id="db22" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">每个屏幕都应该有自己的文件夹。创建一个名为<code class="fe oa ob oc lw b">home</code>的文件夹，其中包含一个名为<code class="fe oa ob oc lw b">home_view</code>的视图</li></ul><p id="68b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名约定:每个屏幕被称为视图，文件以<code class="fe oa ob oc lw b">_view</code>为后缀。视图将使用<code class="fe oa ob oc lw b"><a class="ae ky" href="https://pub.dev/documentation/provider/latest/provider/Consumer-class.html" rel="noopener ugc nofollow" target="_blank">Consumer</a></code>监听视图模型上发生的变化。</p><ul class=""><li id="cc5c" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">每个视图都应该有一个与之关联的视图模型。创建一个名为<code class="fe oa ob oc lw b">home_view_model</code>的文件，它将负责接受用户交互，通过运行一些业务逻辑来处理它们，并最终做出响应。</li></ul><p id="affb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名约定:每个屏幕都有一个与之关联的视图模型，文件以<code class="fe oa ob oc lw b">_view_model</code>为后缀。视图模型使用<code class="fe oa ob oc lw b"><a class="ae ky" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" rel="noopener ugc nofollow" target="_blank">notifyListeners</a></code>通知UI的变化(如果有的话)。</p><ul class=""><li id="750f" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">假设按钮调用某个API(稍后会详细介绍)并用某个响应进行响应。这个响应应该被转换为带有<code class="fe oa ob oc lw b">_model</code>后缀的模型，并从视图模型返回到视图。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/2456d4df5b4431eed00551c6710cda22.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*7kmY0bEok_LIUyU9Iv8akA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MVVM项目结构</p></figure><p id="9979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是MVVM的基本情况，如上面的截图所示。这可以在应用程序的所有屏幕上重复。现在，让我们看看在这个结构上的轻微添加。</p><h1 id="28b7" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">用存储库和服务扩展MVVM</h1><p id="f6a3" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在现实世界中，我们的应用程序需要与API或第三方集成服务进行交互。所以这里我们介绍一种叫做<code class="fe oa ob oc lw b">Repository</code>的东西。</p><p id="cb91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储库模式提供了数据的抽象，因此您的应用程序可以通过一个简单的抽象接口来工作。使用这种模式有助于实现松散耦合。如果实现正确，存储库模式可以很好地确保您遵循数据访问代码的单一责任原则</p><p id="4926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用存储库模式的一些好处:</p><ol class=""><li id="e83a" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu ow ns nt nu bi translated">分离访问外部服务的业务逻辑。</li><li id="cc8b" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ow ns nt nu bi translated">使模仿变得更容易，并允许我们进行单元测试。</li><li id="1ddc" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ow ns nt nu bi translated">我们可以轻松地切换数据源，而不需要进行耗时的代码更改</li></ol><p id="83fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用存储库模式的一些缺点:</p><ol class=""><li id="8964" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu ow ns nt nu bi translated">增加了另一个抽象层，这增加了一定程度的复杂性，使它对于小型应用程序来说是多余的。</li></ol><p id="33a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续前面的例子，假设我们的按钮需要调用一个API。让我们使用<code class="fe oa ob oc lw b">Repository</code>模式来实现它。</p><p id="876d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dart没有Java那样的接口，但是我们可以用抽象类来创建它。我们首先创建一个抽象类，为我们的<code class="fe oa ob oc lw b">home_repo</code>定义接口。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9c96" class="ma mb it lw b gy mc md l me mf">abstract class HomeRepository {<br/>  Future&lt;CarouselModel&gt; fetchData();<br/>}</span></pre><blockquote class="mg mh mi"><p id="0fb4" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">这个抽象类有助于创建一个边界，我们可以自由地在边界的任何一边工作。我们可以实现主存储库(<code class="fe oa ob oc lw b"><em class="it">recommended</em></code>)，或者我们可以直接在我们的应用程序中使用实现(<code class="fe oa ob oc lw b"><em class="it">not recommended</em></code>)。</p></blockquote><p id="0db5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe oa ob oc lw b">HomeRepository</code>只有一个方法，那就是<code class="fe oa ob oc lw b">fetchData</code>,这个方法将响应作为一个名为<code class="fe oa ob oc lw b">CarouselModel</code>的模型返回</p><p id="19ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们实现<code class="fe oa ob oc lw b">HomeRepository</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主存储库</p></figure><p id="8bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在方法<code class="fe oa ob oc lw b">fetchData</code>中，我们引入了一个延迟，然后从资产中加载数据，这是一个JSON文件。这种延迟是对调用API的替代，但我希望我能向读者传达我的想法。</p><p id="46f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着应用程序的增长，您可能会发现自己向给定的存储库中添加了越来越多的方法。在这种情况下，可以考虑创建多个存储库，并将相关的方法放在一起。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/4ffec8c3fb63c208dfab31e2e76b2f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*q1BNWS5-00kEkAVE3ob9qw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">知识库模式</p></figure><p id="efd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，到目前为止，我们有以下的:</p><ul class=""><li id="1e32" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe oa ob oc lw b">carousel_model</code>代表模特(M)</li><li id="1e1e" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oa ob oc lw b">home_view</code>代表视图(V)</li><li id="dd8c" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oa ob oc lw b">home_view_model</code>表示视图模型(VM)</li><li id="1ca8" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oa ob oc lw b">home_repo</code>代表存储库</li></ul><div class="od oe gp gr of og"><a href="https://levelup.gitconnected.com/how-to-add-flutter-to-android-app-4d80d9820686" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">如何给安卓App添加Flutter</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">如何给安卓App添加Flutter</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">如何给安卓Applevelup.gitconnected.com添加Flutter</p></div></div><div class="op l"><div class="pn l or os ot op ou ks og"/></div></div></a></div><h1 id="93ba" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">注册存储库</h1><p id="fe0c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">既然我们的存储库已经准备好了，我们需要弄清楚如何注册它，并使它在我们的应用程序中可用。这就是我们引入另一个叫做DI的概念的时候，也就是依赖注入。我们根据文档使用包<code class="fe oa ob oc lw b"><a class="ae ky" href="https://pub.dev/packages/get_it" rel="noopener ugc nofollow" target="_blank">get_it</a></code>:</p><blockquote class="mg mh mi"><p id="a3b8" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">这是一个用于Dart和Flutter项目的简单服务定位器，带有一些受到<a class="ae ky" href="https://github.com/reactiveui/splat" rel="noopener ugc nofollow" target="_blank"> Splat </a>高度启发的额外好东西。它可以用来代替<code class="fe oa ob oc lw b"><em class="it">InheritedWidget</em></code>或<code class="fe oa ob oc lw b"><em class="it">Provider</em></code>来访问对象，例如从您的用户界面。</p></blockquote><p id="c58f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GetIt非常快，因为它只使用了一个内部的<code class="fe oa ob oc lw b">Map&lt;Type&gt;</code>,使得对它的访问为O(1)。GetIt是一个singleton，所以您可以使用它的<code class="fe oa ob oc lw b">instance</code>属性从任何地方访问它(见下文)。</p><p id="6a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过将<code class="fe oa ob oc lw b">get_it</code>包含在<code class="fe oa ob oc lw b">pubspec.yaml</code>中来安装它，就像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="def4" class="ma mb it lw b gy mc md l me mf">dependencies:<br/>  get_it: ^7.2.0</span></pre><p id="1845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，在应用程序启动时，您会注册希望以后从应用程序中的任何位置访问的类型。之后，您可以通过再次调用<code class="fe oa ob oc lw b">locator</code>来访问已注册类型的实例。</p><p id="4fe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的一面是你可以注册一个接口或者抽象类和一个具体的实现。当访问实例时，您总是会询问接口/抽象类类型。这使得通过在注册时切换具体类型来切换实现变得容易。</p><p id="9416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个名为<code class="fe oa ob oc lw b">locator.dart</code>的文件，在这个文件中我们将实例化<code class="fe oa ob oc lw b">get_it</code>的对象。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">探测器</p></figure><p id="908a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Dart支持全局变量，我们将<code class="fe oa ob oc lw b">GetIt</code>实例分配给一个全局变量，以便尽可能容易地访问它。</p><p id="d77e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管GetIt是单例的，我们将把它的实例分配给一个全局变量<code class="fe oa ob oc lw b">locator</code>，以减少访问GetIt的代码。一个项目的任何包中对<code class="fe oa ob oc lw b">locator</code>的任何调用都将得到同一个<code class="fe oa ob oc lw b">GetIt</code>实例。</p><p id="a8fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用<code class="fe oa ob oc lw b">locator</code>并使用<code class="fe oa ob oc lw b">registerFactory</code>来注册我们的<code class="fe oa ob oc lw b">HomeRepository</code></p><h2 id="7b32" class="ma mb it bd mq ox oy dn mu oz pa dp my li pb pc na lm pd pe nc lq pf pg ne ph bi translated">作为GetIt替代方案的提供者</h2><p id="03f0" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">提供者是GetIt的一个强大的替代者。但是人们使用GetIt进行依赖注入有一些原因:</p><ul class=""><li id="141b" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">Provider需要一个<code class="fe oa ob oc lw b">BuildContext</code>来访问注册的对象，所以您不能在小部件树之外的业务对象中或者在一个纯dart包中使用它。</li><li id="e7ef" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">提供者将其自己的小部件类添加到小部件树中，而不需要访问提供者中注册的对象所需的GUI元素。</li></ul><h2 id="4de0" class="ma mb it bd mq ox oy dn mu oz pa dp my li pb pc na lm pd pe nc lq pf pg ne ph bi translated">测试存储库</h2><p id="e683" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">您可以为您的Flutter应用程序的不同元素实现单元测试，比如小部件、控制器、模型、服务和存储库。可以使用以下策略对基于存储库的颤振代码库进行单元测试:</p><ul class=""><li id="9019" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">实现一个模拟存储库类并测试逻辑</li><li id="1efa" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">您不需要自己实现模拟类——<a class="ae ky" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank">mock ITO包</a>帮助您快速生成它们，并且<a class="ae ky" href="https://medium.com/flutter-community/using-mockito-in-flutter-cd015d338277?source=your_stories_page-------------------------------------" rel="noopener">自动生成</a>。</li></ul><h2 id="1bd3" class="ma mb it bd mq ox oy dn mu oz pa dp my li pb pc na lm pd pe nc lq pf pg ne ph bi translated">在视图模型中集成存储库</h2><p id="2e18" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在是使用依赖注入的时候了。但在此之前，让我们看看它是什么。</p><blockquote class="mg mh mi"><p id="2ae8" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">当类A使用类B的一些功能时，那么就说类A依赖于类B。</p></blockquote><p id="7433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们可以使用其他类的方法之前，我们首先需要创建该类的对象(即，类A需要创建类B的一个实例)。</p><p id="784c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，将创建对象的任务转移给其他人并直接使用依赖项被称为依赖注入。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/21f5329d4aad02a95f2e93886064df9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0r7__ZZKUzZLQbt_.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">依赖注入</p></figure><h1 id="fb64" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用DI的好处</h1><ol class=""><li id="f2b5" class="nm nn it lb b lc ng lf nh li pp lm pq lq pr lu ow ns nt nu bi translated">支持单元测试。</li><li id="9d42" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ow ns nt nu bi translated">样板代码减少了，因为依赖项的初始化是由另一个组件完成的(在我们的例子中是<code class="fe oa ob oc lw b">locator</code>)</li><li id="1a7e" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ow ns nt nu bi translated">支持松耦合。</li></ol><h1 id="17f2" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用DI的缺点</h1><ol class=""><li id="ead9" class="nm nn it lb b lc ng lf nh li pp lm pq lq pr lu ow ns nt nu bi translated">学习起来很复杂，如果过度使用，会导致管理问题和其他问题。</li><li id="0617" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ow ns nt nu bi translated">许多编译时错误被推到运行时。</li></ol><p id="9223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的应用程序，让我们看看我们是如何集成的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9e5e" class="ma mb it lw b gy mc md l me mf">class HomeViewModel extends ChangeNotifier {<br/>  HomeViewModel({<br/>    required this.homeRepo,<br/>  });</span><span id="29cf" class="ma mb it lw b gy ps md l me mf">final HomeRepository homeRepo;<br/>}</span></pre><p id="2e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们在我们的<code class="fe oa ob oc lw b">HomeViewModel</code>中创建一个构造函数，并将<code class="fe oa ob oc lw b">homeRepo</code>指定为我们需要的参数。这样，我们指示任何需要访问我们的视图模型的人都必须首先通过<code class="fe oa ob oc lw b">homeRepo</code></p><h2 id="4354" class="ma mb it bd mq ox oy dn mu oz pa dp my li pb pc na lm pd pe nc lq pf pg ne ph bi translated">初始化服务定位器</h2><p id="e659" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">你需要在应用程序启动时注册服务，这样你就可以在<code class="fe oa ob oc lw b"><em class="mj">main.dart</em></code>进行注册</p><p id="e67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">替换标准</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f4ec" class="ma mb it lw b gy mc md l me mf">void main() =&gt; runApp(MyApp());</span></pre><p id="848c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包含以下内容:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a1bd" class="ma mb it lw b gy mc md l me mf">import 'locator.dart';</span><span id="f705" class="ma mb it lw b gy ps md l me mf">void main() {<br/>  // INIT SERVICE LOCATOR  <br/>  setupLocator();<br/>  <br/>  runApp(MyApp());<br/>}</span></pre><p id="6fd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在构建小部件树之前向GetIt注册您的服务。</p><p id="6731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们回忆一下，我们的<code class="fe oa ob oc lw b">homeRepo</code>是在<code class="fe oa ob oc lw b">locator</code>中注册的，那么为了声明我们的视图模型，我们遵循如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主要的。飞镖</p></figure><p id="d81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe oa ob oc lw b">main</code>中，我们调用了<code class="fe oa ob oc lw b">setupLocator</code>，它是包含了<code class="fe oa ob oc lw b">locator.dart</code>下所有注册的依赖项的方法</p><p id="cfe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在我们的<a class="ae ky" href="https://pub.dev/documentation/provider/latest/provider/MultiProvider-class.html" rel="noopener ugc nofollow" target="_blank"> MultiProvider </a>中，我们在<a class="ae ky" href="https://pub.dev/documentation/provider/latest/provider/ChangeNotifierProvider-class.html" rel="noopener ugc nofollow" target="_blank"> ChangeNotifierProvider </a>下指定<code class="fe oa ob oc lw b">HomeViewModel</code></p><blockquote class="mg mh mi"><p id="2499" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">ChangeNotifierProvider使用<code class="fe oa ob oc lw b"><em class="it">create</em></code>创建一个ChangeNotifier，并在它从小部件树中删除时自动处理它。</p></blockquote><h2 id="c0cb" class="ma mb it bd mq ox oy dn mu oz pa dp my li pb pc na lm pd pe nc lq pf pg ne ph bi translated">在视图中使用视图模型</h2><p id="1ca4" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们的存储库被注册并作为一个必需的参数传递给我们的视图模型。让我们看看如何在视图中使用视图模型。</p><p id="35a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以访问视图内部的视图模型:</p><ol class=""><li id="3673" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu ow ns nt nu bi translated">使用<code class="fe oa ob oc lw b">Consumer&lt;T&gt;</code>小部件。</li><li id="0226" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ow ns nt nu bi translated">使用<code class="fe oa ob oc lw b">Provider.of&lt;T&gt;(context)</code>。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">视图模型</p></figure><p id="76e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe oa ob oc lw b">home_view</code>中使用<code class="fe oa ob oc lw b">Provider.of</code>实例化<code class="fe oa ob oc lw b">viewModel</code>。</p><p id="62c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要访问依赖项，但不想对用户界面进行任何更改时，可以使用<code class="fe oa ob oc lw b">Provider.of&lt;T&gt;(context)</code>。我们简单地设置了<code class="fe oa ob oc lw b">listen: false</code>,表示我们不需要监听来自ChangeNotifier的更新。<code class="fe oa ob oc lw b">listen: false</code>参数用于指定何时使用Provider获取一个实例并调用该实例上的方法。</p><p id="b369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们也可以使用以下内容:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8164" class="ma mb it lw b gy mc md l me mf">viewModel = context.read&lt;HomeViewModel&gt;();</span></pre><p id="8af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了对发生在<code class="fe oa ob oc lw b">viewModel</code>上的变化做出反应，当一个值发生变化时，当我们想要重建小部件时，我们使用<code class="fe oa ob oc lw b">Consumer&lt;T&gt;</code>。提供类型<code class="fe oa ob oc lw b">&lt;T&gt;</code>是必须的，这样提供者就可以理解你指的是哪个依赖项。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5a22" class="ma mb it lw b gy mc md l me mf">Consumer&lt;HomeViewModel&gt;(<br/>    builder: (_, model, child) {<br/>     // YOUR WIDGET                     <br/>    },<br/>    child: // SOME EXPENSIVE WIDGET<br/>)</span></pre><p id="239a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消费者小部件不做任何花哨的工作。它只是调用<a class="ae ky" href="https://pub.dev/documentation/provider/latest/provider/Provider/of.html" rel="noopener ugc nofollow" target="_blank">提供者。并将其<code class="fe oa ob oc lw b">build</code>实现委托给</a><a class="ae ky" href="https://pub.dev/documentation/provider/latest/provider/Consumer/builder.html" rel="noopener ugc nofollow" target="_blank">构建器</a>。</p><p id="01c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消费者小部件有两个参数，参数<code class="fe oa ob oc lw b">builder</code>和参数<code class="fe oa ob oc lw b">child</code>(可选)。<code class="fe oa ob oc lw b">child</code>参数是一个昂贵的小部件，不会受到ChangeNotifier中任何变化的影响。</p><p id="d4c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个构建器可以被多次调用(比如当提供的值改变时)，这就是我们可以重新构建UI的地方。消费者小部件有两个主要用途:</p><ul class=""><li id="dcc6" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">当我们没有一个作为提供者后代的<code class="fe oa ob oc lw b"><a class="ae ky" href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html" rel="noopener ugc nofollow" target="_blank">BuildContext</a></code>，因此不能使用<code class="fe oa ob oc lw b"><a class="ae ky" href="https://pub.dev/documentation/provider/latest/provider/Provider/of.html" rel="noopener ugc nofollow" target="_blank">Provider. of</a></code>时，它允许从提供者获得一个值。</li><li id="8ed8" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">它通过提供更精细的重建来帮助优化性能。</li></ul><h2 id="2665" class="ma mb it bd mq ox oy dn mu oz pa dp my li pb pc na lm pd pe nc lq pf pg ne ph bi translated">视图模型的单元测试(可选)</h2><p id="95e1" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">您可以通过使用<a class="ae ky" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank"> Mockito包</a>作为快捷方式创建一个替代类实现来模仿依赖关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/8d3913d2c29349dc6af5dfad2a28190f.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/0*raBWlTIpC0H5EKFM.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MVVM建筑+仓库</p></figure><h1 id="558c" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">什么是服务</h1><p id="3f76" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">服务是普通的Dart类，用于在应用程序中完成一些专门的任务。服务的目的是隔离任务，尤其是易变的第三方包，并对应用程序的其余部分隐藏其实现细节。</p><p id="129a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以创建一个服务来处理一些常见的示例:</p><ul class=""><li id="da80" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">例如，使用第三方软件包，读取和写入本地存储(共享首选项)</li><li id="ae94" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">使用像Firebase或其他第三方软件包这样的云提供商。</li></ul><p id="abac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您正在使用<a class="ae ky" href="https://pub.dev/packages/package_info_plus" rel="noopener ugc nofollow" target="_blank"> package_info </a>来获取应用程序的软件包详细信息。</p><p id="fdbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以直接在应用程序中使用这个包，一段时间后，你会发现一个更棒的包。你遍历并用新的包<code class="fe oa ob oc lw b">some_great_package</code>替换掉<code class="fe oa ob oc lw b">package_info</code>的所有引用。这无疑是浪费你的时间和精力。</p><p id="d883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设产品负责人发现没有用户在使用这个特性。相反，他们要求新的功能。你浏览并删除所有关于<code class="fe oa ob oc lw b">some_great_package</code>的引用，这又是浪费你的时间和精力。</p><p id="2e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您与分散在代码中的一些函数紧密耦合时，这使得更改变得困难且容易出错。</p><p id="019b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干净的编码需要前期的时间和精力，但是从长远来看，会节省你更多的时间和精力。</p><p id="9e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe oa ob oc lw b">services</code>的用武之地。你创建了一个新类，把它叫做<code class="fe oa ob oc lw b">PackageInfoService</code>。应用程序中的其余类不知道它的内部工作原理。他们只是调用服务上的方法来获得结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包装信息</p></figure><ul class=""><li id="4608" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">这使得改变变得容易。如果您想将<code class="fe oa ob oc lw b">package_info</code>切换到<code class="fe oa ob oc lw b">some_great_package</code>，只需修改服务类中的代码。更新服务代码会自动影响应用程序中使用服务的所有地方。</li><li id="4763" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">支持交换实现。您可以创建一个“假”实现，在其他团队完成/开发服务实现时返回硬编码数据。</li><li id="479b" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">有时实现可能依赖于其他服务。例如，您<code class="fe oa ob oc lw b">xyzService</code>可能使用一个服务进行网络调用来获取其他类型的数据。</li></ul><h1 id="fc36" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">注册您的服务</h1><p id="5ba7" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">使用GetIt这样的服务定位器是在整个应用程序中提供服务的一种便捷方式</p><ul class=""><li id="c344" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">我们使用<code class="fe oa ob oc lw b">locator</code>来注册我们的<code class="fe oa ob oc lw b">PackageInfoService</code></li><li id="8aef" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">我们将把<code class="fe oa ob oc lw b">PackageInfoService</code>注册为懒惰的单身族。它只有在第一次被使用时才会被初始化。如果你想在应用程序启动时初始化它，那么使用<code class="fe oa ob oc lw b">registerSingleton()</code>代替它。因为它是单例的，所以你的服务总是有相同的实例。</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1bae" class="ma mb it lw b gy mc md l me mf">void setupLocator() {</span><span id="2295" class="ma mb it lw b gy ps md l me mf">locator.registerLazySingleton&lt;PackageInfoService&gt;(() =&gt;<br/>PackageInfoServiceImpl());</span><span id="9f79" class="ma mb it lw b gy ps md l me mf">}</span></pre><h1 id="ff84" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用服务</h1><p id="c789" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">因为我们使用GetIt注册了服务，所以我们可以从代码中的任何地方获得对服务的引用</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b74d" class="ma mb it lw b gy mc md l me mf">class MyClass {</span><span id="a024" class="ma mb it lw b gy ps md l me mf">PackageInfoService packageService = locator&lt;PackageInfoService&gt;();<br/>}</span></pre><p id="5e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以像这样在该类中使用它:</p><ul class=""><li id="a74a" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe oa ob oc lw b">packageService.getSomeValue()</code></li><li id="c04b" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oa ob oc lw b">packageService.doSomething(someValue)</code></li></ul><h1 id="e701" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">服务的单元测试(可选)</h1><p id="f074" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">您可以通过使用<a class="ae ky" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank"> Mockito包</a>创建一个替代的服务类实现来模仿依赖关系。</p><h2 id="6e45" class="ma mb it bd mq ox oy dn mu oz pa dp my li pb pc na lm pd pe nc lq pf pg ne ph bi translated">简介:</h2><ul class=""><li id="ccee" class="nm nn it lb b lc ng lf nh li pp lm pq lq pr lu nr ns nt nu bi translated">一个<code class="fe oa ob oc lw b">repository</code>用于以类似集合的方式访问对象。</li><li id="47c5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oa ob oc lw b">service</code>是一个具有用于执行业务逻辑的方法的类，这些方法可以协调各种其他服务(例如多个存储库)来执行单个动作或获得单个结果。</li></ul><p id="affa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">感谢阅读！敬请期待更多，比如这些……</em></p><p id="3b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">网址:</em><a class="ae ky" href="https://flatteredwithflutter.com/using-mvvm-in-flutter-2022/" rel="noopener ugc nofollow" target="_blank"><em class="mj">https://flattered with flutter . com/using-mvvm-in-flutter-2022/</em></a></p><div class="od oe gp gr of og"><a href="https://levelup.gitconnected.com/using-redis-for-caching-2023-42602603dc8a" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">使用Redis进行缓存(2023)</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">使用Redis进行缓存</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">(2023)为Cachinglevelup.gitconnected.com使用Redis</p></div></div><div class="op l"><div class="pu l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://levelup.gitconnected.com/google-pay-in-flutter-1d9a848cc11a" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">摇摆中的Google Pay</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">摇摆中的Google Pay</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">Flutterlevelup.gitconnected.com的Google Pay</p></div></div><div class="op l"><div class="pv l or os ot op ou ks og"/></div></div></a></div><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="49a1" class="ma mb it lw b gy mc md l me mf"><a class="ae ky" href="https://github.com/AseemWangoo/dynamism" rel="noopener ugc nofollow" target="_blank">Source Code</a></span></pre></div></div>    
</body>
</html>