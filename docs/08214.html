<html>
<head>
<title>Stop Using Switch in TypeScript — 3 Alternatives To Use Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在TypeScript中使用Switch改为使用3个替代选项</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-switch-in-typescript-3-alternatives-to-use-instead-aef014c9b31d?source=collection_archive---------0-----------------------#2021-04-07">https://betterprogramming.pub/stop-using-switch-in-typescript-3-alternatives-to-use-instead-aef014c9b31d?source=collection_archive---------0-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27c3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您可以避免switch语句，因为TypeScript有自己的版本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/519b0f6a47f750a0539e0ea96cbab0d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRB6-yRZbUuFHfsHVtbkuA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Victoriano Izquierdo 在<a class="ae ky" href="https://unsplash.com/s/photos/options?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="7ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码有什么问题？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你完全可以说“没什么”这将是一个有效的答案。但是，如果您发现这些代码是一个更大的代码库的一部分，其中有更多的逻辑，那么这些代码可以被认为是代码味道。说实话，声明并没有那么好。</p><p id="6ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lx ly lz ma b">switch</code>语句，您创建了一个巨大的代码块，它必须被连续执行，一个接一个地检查条件。它的语法考虑到了诸如忘记写一个<code class="fe lx ly lz ma b">break</code>子句和导致多个案例被意外执行的问题。如果可以避免的话，你不想使用一个<code class="fe lx ly lz ma b">switch</code>语句，但是有哪些替代方法呢？</p><p id="d253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您使用的语言，您将有不同的选择。鉴于我们正在处理的是TypeScript(因此也是JavaScript)，我们可以混合搭配。以下是我在编码时避免<code class="fe lx ly lz ma b">switch</code>语句的三种最喜欢的方法。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9d10" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用对象文字</h1><p id="0403" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这可能是三种方法中我最喜欢的一种，因为它非常简单，并且完全是JavaScript和TypeScript固有的。你不需要任何额外的知识，库，或者复杂的设计模式。您所需要的只是最基本的构造:一个对象文字(<code class="fe lx ly lz ma b">{}</code>)。</p><p id="c882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案的关键是将每个<code class="fe lx ly lz ma b">case</code>块中的逻辑封装到一个单独的函数中，然后在一个对象文字中索引它们。没错，“索引它们。”我们的对象文字将作为这些代码块的索引，查找时间将变成<em class="nf"> O(1) </em>，这是一个很大的额外好处。</p><p id="9cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的意思是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">诚然，这里的复杂性是微不足道的，但你得到了要点。我已经设法将每个<code class="fe lx ly lz ma b">case</code>语句的逻辑封装在每个语句的一个方法中。这已经是一个很好的实践了，但是我通过创建<code class="fe lx ly lz ma b">theIndex</code>消除了对整个<code class="fe lx ly lz ma b">switch</code>构造的需要，它只是一个对象文字。</p><p id="6c8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解这段代码所需的认知负荷比经历一大段<code class="fe lx ly lz ma b">switch</code>要小。找到要执行的正确代码所需的查找时间也更短，因为引擎不必验证每一个<code class="fe lx ly lz ma b">case</code>。相反，它可以准确地知道要寻找哪一个。</p><p id="bd16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道你在想什么:如果你需要一个<code class="fe lx ly lz ma b">default</code>案例来解释那些未知的价值呢？就像加个<code class="fe lx ly lz ma b">IF</code>一样简单。你甚至可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="f77c" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">利用多态性</h1><p id="d434" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如果你是OOP的忠实粉丝，这个可能更适合你。</p><p id="3452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的问题中，我们试图封装同一概念行为的不同版本:让我们的“动物”说话。它们可以发出“汪”、“喵”、“嘎嘎”或任何我们需要它们发出的声音，尽管这可能需要不同的代码，但它们在概念上做着同样的事情。</p><p id="eabc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可能对所有的方法都使用相同的方法，而不是对每一个都使用一种方法。唯一的区别是我们创建了不同的类。</p><p id="88ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们在每个不同的类中专门化我们的逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在的问题？我们需要区别对待每个对象。我们不能只有一个动物列表来决定调用哪种方法——当然，除非我们确定它们是同一类型。我们可以通过一个更高阶的类(即通过使用继承)或一个公共接口来实现。</p><p id="847e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的动物都有一些需要重复编码的共同行为，那么一个共同的父类就有意义了。然而，在我们的例子中，一个简单的公共接口就足够了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="be36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意一些事情:</p><ul class=""><li id="80bd" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">我们的接口为我们所有的类声明了一个公共的形状(必需的<code class="fe lx ly lz ma b">speak</code>方法)。</li><li id="5f37" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们所有的类现在都实现了相同的<code class="fe lx ly lz ma b">IAnimal</code>接口。</li><li id="0c06" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们现在可以忘记我们在和哪种动物打交道，只需要让它说话。</li></ul><p id="d430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个是这里的主要好处。我们不再关心寻找合适的动物。我们所要做的就是创建正确的动物类型，然后不再需要最初使用<code class="fe lx ly lz ma b">switch</code>语句来检查正确类型的逻辑。</p><p id="86bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种非常优雅的解决问题的方式——特别是如果OOP是你的代码库的一部分。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="5021" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">无商标消费品</h1><p id="73bd" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">想象一下，试图用工厂方法解决与你的<code class="fe lx ly lz ma b">switch</code>相关的问题，却发现你需要一个大的<code class="fe lx ly lz ma b">switch</code>语句来解决它。太讽刺了，不是吗？不是阿兰妮斯·莫利塞特式的。你知道，这个词的真正含义。</p><p id="00d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你已经编写了你的第一个解决方案，你已经把自己逼到了下面的情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="05da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了仿制药，我们可以做得更好。</p><p id="800e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">泛型是语言给你的一种表示类型的方式，而不需要实际指定它们。TypeScript甚至允许您使用它们来定义函数签名。解决我们的问题需要两步:</p><ol class=""><li id="e7e4" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nu nm nn no bi translated">将我们依赖于<code class="fe lx ly lz ma b">switch</code>的函数转换成一个通用函数，它实例化我们给它的任何类型的动物，而不需要一个<code class="fe lx ly lz ma b">switch</code>语句。</li><li id="94ab" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">找到一种方法来专门化这个通用工厂，这样我们就不需要费心添加逻辑来决定我们要构建哪种类型的动物。</li></ol><p id="5574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步实质上是<code class="fe lx ly lz ma b">switch</code>声明的全部要点，如果我们能废除它，那么我们就不再需要它了。</p><p id="48e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是通过将我们的<code class="fe lx ly lz ma b">animalCreator</code>变成这样来解决的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="e207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数将一个“类型”作为第一个参数——事实上，它是一个类(注意需要调用<code class="fe lx ly lz ma b">new</code>方法的能力)——然后是一堆通用属性(即<code class="fe lx ly lz ma b">...args</code>部分，也称为rest属性)。</p><p id="c17c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在这已经足够了，但是在使用它的时候，您必须做这样的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是有效的，但是在第二个例子中，我们创建了一只有九条命的狗(实际上，这个参数可以忽略，但是你明白了)。我们的代码不能“强制”正确的类型。</p><p id="539e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们可以更进一步，为我们的生成器函数创建一个泛型类型——一个我们可以应用和专门化的类型。例如，如果我们想创建一个只能创建狗的函数，但要重用相同的通用代码，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经成功地消除了对<code class="fe lx ly lz ma b">switch</code>语句的需求。你不需要有一大堆案例来决定实例化哪个类。我们现在直接传入我们想要的类。但是这还不够——当我们处理JavaScript和TypeScript时还不够——因为我们可以更进一步，从<code class="fe lx ly lz ma b">dogMaker</code>中删除多余的<code class="fe lx ly lz ma b">Dog</code>参数。我们已经很确定我们在造一只狗。我们不需要将它作为参数传递。它还从我们的代码中删除了对该类的直接依赖。</p><p id="074c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，我们可以使用currying，这是一种函数式编程技术，涉及到创建一个包装器函数，该函数将预设我们想要的参数，并允许将其余的参数传递给该函数。对于我们的例子，我们想要一个<code class="fe lx ly lz ma b">dogMaker</code>，这意味着将它作为参数传递不应该是开发人员的责任。以下是最终结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这可能看起来是三个选项中最复杂的，但是如果您试图实现工厂模式，这可能是一种使您的代码更加专门化并且更容易理解的方法。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3b2c" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="b737" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">事实:在许多情况下,<code class="fe lx ly lz ma b">switch</code>陈述并不是最佳解决方案。另一个事实:虽然在某些情况下，90%的情况下这样做是完全有意义的，但是有一种更声明性的方法可以做到这一点。</p><p id="0184" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我与您分享了三种方法。</p><p id="5e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你觉得怎么样？你还在考虑使用<code class="fe lx ly lz ma b">switch</code>还是我改变了你的想法？</p></div></div>    
</body>
</html>