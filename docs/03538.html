<html>
<head>
<title>Code Against Interfaces, Not Implementations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">针对接口而不是实现编码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/code-against-interfaces-not-implementations-37b30e7ab992?source=collection_archive---------3-----------------------#2020-02-17">https://betterprogramming.pub/code-against-interfaces-not-implementations-37b30e7ab992?source=collection_archive---------3-----------------------#2020-02-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="e98d" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如果你做的每件事都不使用界面，考虑开始吧</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/48eaab3658074dd00d2f449ee7048443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iKDWp8qyBrcDRLgd"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">克林特·帕特森在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a579" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我曾在推特上写道:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lw lx l"/></div></figure><p id="7975" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您使用接口时，您可以将自己与任何特定的实现分离。当一个代码模块没有直接连接到另一个代码模块时，该代码被称为“松散耦合”</p><p id="a8e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">而且，我可能会一直重复，直到我死的那一天，松耦合代码是一件非常好的事情。</p><p id="0e73" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我谈了很多关于代码解耦的问题，以及为什么这真的很好。但是这里的定义可能是个好主意。</p><p id="55c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你的类被设计成不依赖于其他类的具体实现时，可以说代码是<em class="ly">解耦的</em>。</p><p id="e58b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当两个类对彼此的了解尽可能少，它们之间的依赖尽可能薄，它们之间的通信线路尽可能简单时，它们就是松散耦合的。</p><p id="235b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">换句话说，解耦是将你的依赖尽可能限制到抽象的过程。如果你想写好的、干净的代码，你会试着只耦合抽象；接口是抽象的。正如我在上面的推文中所说，这对于编写易于维护的好代码至关重要。</p><p id="4121" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，要针对接口编程，您首先必须知道什么是接口。</p></div><div class="ab cl lz ma hy mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="in io ip iq ir"><h1 id="52b7" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">什么是接口？</h1><p id="1f28" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">大多数现代语言，如C#、TypeScript和Java，作为一种语言特性，包含了接口的概念。界面有点难以描述，但我还是要试试，嗯？</p><p id="526b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">字典将接口描述为:</p><blockquote class="nd"><p id="1738" class="ne nf iu bd ng nh ni nj nk nl nm lv dk translated">“界面——n:两个系统、主体、组织等的结合点。，见面互动。”</p></blockquote><p id="313f" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">在代码的一般情况下，接口是代码模块(通常是类)如何相互交互以执行指定的操作。你的代码需要做一些事情，接口是允许代码模块一起工作的定义。</p><p id="4753" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接口是功能的抽象定义。</p><p id="9ed2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好吧，这听起来很理智，不是吗，但这是真的。</p><p id="eafc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接口声明定义了一组可用于特定目的的属性和方法。接口声明并且不要求为此目的的特定实现。它们定义了一个类可以做什么，并且限制了一个类只能暴露给那些由接口定义的东西。</p><p id="3569" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，必须实现一个有用的接口。而当你使用一个接口时，你最终并不关心<em class="ly"/><strong class="lc iv"/>它是如何实现的；您只需要知道您可以调用接口上的方法和属性，并且会提供您需要的功能。</p><p id="4ab9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">实现隐藏(即抽象)是使用接口的主要目的之一。</p></div><div class="ab cl lz ma hy mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="in io ip iq ir"><h1 id="8088" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">到处都是接口</h1><p id="1dd3" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">我们每天都在生活中看到界面。电插头是一种接口。在美国，我们的电源插座有两个垂直的矩形插槽用于相线和零线节点，下面有一个圆孔用于接地节点。</p><p id="ae16" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这不就是功能的定义吗？要实现该接口，您只需提供一个与该接口匹配的插头，您的设备就可以工作了。</p><p id="aad3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以插上吹风机和电脑显示器——接口不管。结果，这些项目可以说是“有能力的”。</p><p id="fd87" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用接口的主要原因是上面讨论过的——解耦。如果你针对接口编程，你可以用这样一种方式编写你的代码，它永远不会被耦合或者“连接”到接口之外的任何东西。</p><p id="3650" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的代码耦合越松散，一个地方的更改影响另一个地方的代码的可能性就越小。</p><p id="96d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，通过对一个接口进行编码，您可以用一个更好的实现来替换它，而不会破坏任何东西。关键是接口对于代码的解耦至关重要，而解耦的代码是好的。</p><p id="6ab3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接口的代码非常简单:它是方法和属性的声明，没有实现。</p><p id="d54e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，这种简单性会使他们难以理解。当我第一次遇到接口的概念时，我清楚地记得当时的想法:“嗯？你到底为什么想要使用接口？”</p><p id="cbe8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，我当时并不知道，接口可能是你的武器库中唯一最有效的编码工具。一旦你真正理解了接口是用来做什么的，它们能做什么，编写干净的、非耦合的、可测试的代码就会变得容易得多。</p></div><div class="ab cl lz ma hy mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="in io ip iq ir"><h1 id="d50a" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">简单的例子</h1><p id="03ec" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">例如，下面是TypeScript中一个简单接口的声明:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns lx l"/></div></figure><p id="a2bc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将使用TypeScript示例。</p><p id="42a0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接口由一个名称(在本例中是<code class="fe nt nu nv nw b">IName</code>)和一个方法和属性声明组成。</p><p id="c2dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">按照惯例，接口以字母“<code class="fe nt nu nv nw b">I</code>”开始。您可以创建任何名称的接口，但是使用<code class="fe nt nu nv nw b">I</code>可以更容易地在代码中识别接口。</p><p id="33da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接口不包含实现功能的“真正”代码。接口不能声明字段、变量或常数。他们也不能定义私有、公共等范围。这纯粹是能力的宣言。因此，接口的每个成员本质上都是公共成员。</p><p id="762c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的例子中，接口说:“嘿，当我被实现时，我会给你关于某人名字的信息。”它会告诉您有哪些可用的功能。它没有告诉您该功能将如何实现。</p><p id="e9ae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">界面不关心，界面的用户也不应该关心。该接口的实现可能会做许多事情来获取名称信息——从列表中随机选取，从文件中获取，或者从数据库或其他数据存储中提取。</p><p id="adf8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接口本身并不关心，也不能决定名称的来源。该接口只知道它的实现者将返回一个字符串，仅此而已。它甚至不能保证字符串是一个人的名字，尽管这是它的意图。</p><p id="8108" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，这里的目的是创建一个实现类，当它进入“给我一个人的名字”模式时有一些意义。</p><p id="ff5c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，您可能有一个收集用户姓名的表单。您可能会迭代数据库中的记录，并使用接口在迭代时获取每个名称。</p><p id="6061" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">关键是实现对象是什么或者它们做什么并不重要——它们只是在被当作<code class="fe nt nu nv nw b">IName</code>时产生一个名称。</p></div><div class="ab cl lz ma hy mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="in io ip iq ir"><h1 id="e1c1" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">实现接口</h1><p id="c753" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">但是当然，正如你已经猜到的，没有实现类，接口什么也做不了。</p><p id="e349" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为此，您需要将一个类声明为实现一个接口，然后确保该类实现接口中所有必需的方法。</p><p id="98cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一些语言允许你实现一个只有部分接口声明的类，或者有可选的接口部分，但是为了本文的目的，我们假设需要实现整个接口。</p><p id="cab7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要实现<code class="fe nt nu nv nw b">IName</code>，您可以如下声明一个类:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns lx l"/></div></figure><p id="c00c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是一些需要注意的事项:</p><ul class=""><li id="5d9b" class="nx ny iu lc b ld le lg lh lj nz ln oa lr ob lv oc od oe of bi translated">类<code class="fe nt nu nv nw b">Name</code>被声明为实现了<code class="fe nt nu nv nw b">IName</code>接口。</li><li id="f811" class="nx ny iu lc b ld og lg oh lj oi ln oj lr ok lv oc od oe of bi translated">我们以一种迂回的方式实现了这个接口。我们的TypeScript类声明了一个<code class="fe nt nu nv nw b">public</code>构造函数，它将名字和姓氏作为参数。然后，它将该信息存储在作为只读公共属性公开的<code class="fe nt nu nv nw b">private</code>变量中。因此，该类是不可变的。</li><li id="ef44" class="nx ny iu lc b ld og lg oh lj oi ln oj lr ok lv oc od oe of bi translated">还要注意，该类不仅仅实现了接口，它还提供了一个名为<code class="fe nt nu nv nw b">fullName</code>的属性，该属性组合了名字和姓氏的值。这说明了一个类如何在接口的实现之外做任何你想做的事情。然而，当我们将类声明为接口变量时，我们不能使用该功能，因为它不是接口的一部分。</li></ul></div><div class="ab cl lz ma hy mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="in io ip iq ir"><h1 id="528b" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">使用界面</h1><p id="6ac7" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">当然，如果你不能使用接口，它就没有多大价值。这很简单。</p><p id="e870" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我能想到的几乎每一种语言中，你都要声明一个你想要创建的接口类型的变量，然后给它分配一个实现该接口的对象的实例。一个简单的例子是这样的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns lx l"/></div></figure><p id="efb8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接口可以在任何使用常规变量的地方使用。您可以将它们作为参数传递，并将其声明为字段、属性和局部变量。</p><p id="30d4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">事实上，你应该尽可能地利用接口。</p></div><div class="ab cl lz ma hy mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="in io ip iq ir"><h1 id="6d72" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">结论</h1><p id="af5c" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">所以，接口很容易声明和使用。当然，真正的问题是<em class="ly">为什么</em>你想使用它们，它们提供了什么优势。在我的下一篇文章中，我将讨论这个问题。</p></div></div>    
</body>
</html>