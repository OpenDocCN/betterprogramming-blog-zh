<html>
<head>
<title>Understanding TypeScript’s Type System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解TypeScript的类型系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-typescripts-type-system-a3cdec8e95ae?source=collection_archive---------1-----------------------#2019-05-31">https://betterprogramming.pub/understanding-typescripts-type-system-a3cdec8e95ae?source=collection_archive---------1-----------------------#2019-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eca7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TypeScript正在崛起——它的类型系统是一个重要原因</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbb05f58fe0f2e06389ddd6fc4dcaf26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dl2Twyg86r6m7lwU9sc6Tg.png"/></div></div></figure><p id="bf5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我想到TypeScript 的采用的<a class="ae lq" href="https://github.blog/2018-11-15-state-of-the-octoverse-top-programming-languages/" rel="noopener ugc nofollow" target="_blank">上升轨迹时，我看到越来越多的团队和开发者选择健壮性而不是灵活性。后者是像JavaScript这样的动态类型语言给你的，而</a><a class="ae lq" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>允许你在代码中利用静态<a class="ae lq" href="https://www.sitepoint.com/typing-versus-dynamic-typing/" rel="noopener ugc nofollow" target="_blank">类型检查</a>。</p><p id="4700" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript在用户中最受欢迎的一个属性是它的可靠性和不容易出错的代码，这两者都是它的类型系统的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/7de466ab94cb6d29f0a5e4349a55cda0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_bTNJQNQ-8H1VQ4Ih8R1Q.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated"><a class="ae lq" href="https://octoverse.github.com/projects" rel="noopener ugc nofollow" target="_blank"> Github Octoverse 2018 </a></p></figure><p id="5662" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您使用过TypeScript，您可能已经知道它是JavaScript的超集。这仅仅意味着它包含了整个JavaScript语言以及有用的附加特性。因此，您从JavaScript获得的所有标准控制结构，如数据类型、控制流、操作符和子程序，在TypeScript中都是可用的。简而言之，所有JavaScript在风格和行为上都是有效的TypeScript，TypeScript在某种程度上可以被视为一种扩展，旨在使大型JavaScript应用程序的开发更加容易。它为JavaScript开发提供了静态类型化的体验。</p><p id="9973" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两者最大的区别之一是它们的类型系统。JavaScript显然有类型。但是，它的变量类型可以在每次赋值时改变。以数字开始的变量可以以字符串、对象、数组或函数结束。这可能会很成问题，尤其是在大型应用程序中。</p><p id="e323" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就引出了这篇文章的主要目的，即探索TypeScript的类型系统。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e8e6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">理论类型</strong></h1><p id="645a" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">类型系统起源于伯特兰·罗素开发的<a class="ae lq" href="https://www.britannica.com/topic/theory-of-types-logic" rel="noopener ugc nofollow" target="_blank">类型理论</a>。在逻辑中，类型理论本质上是一个系统，其中每个术语都被赋予一个类型，并且基于类型来限制操作。听起来很熟悉，不是吗？</p><p id="8608" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">类型理论</strong></p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5055" class="nf me it nb b gy ng nh l ni nj">x: nat<br/>doubleUp: nat -&gt; nat</span></pre><p id="e1cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">打字稿</strong></p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0c08" class="nf me it nb b gy ng nh l ni nj">var x: number;<br/>doubleUp: (number) =&gt; number;</span></pre><p id="9b80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上所示，TypeScript和type theory有相似的类型注释，不同之处在于type theory使用了一个<code class="fe nk nl nm nb b">nat</code>类型(自然数)。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="52d1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak"> JavaScript vs TypeScript:类型系统比较</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3b805dc5d1e4a98e23f54697d1a84a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*7B4yUKj0rMb8pvjG1KM6yg.png"/></div></figure><p id="7a39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么什么是类型系统呢？类型系统是为系统中的每个变量、表达式、类、函数、对象或模块分配类型的一组规则。检查这些规则是为了暴露程序中的错误，可以在编译时(静态类型检查)或运行时(动态类型检查)执行。</p><h2 id="2d20" class="nf me it bd mf no np dn mj nq nr dp mn ld ns nt mp lh nu nv mr ll nw nx mt ny bi translated"><strong class="ak"> JavaScript类型系统</strong></h2><p id="edac" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">JavaScript是动态类型的，因此变量没有关联的类型。如上所述，您可以将一种类型的值赋给一个变量，然后将不同类型的值赋给同一个变量。</p><p id="15df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样做的问题是，不兼容类型的操作会在我们的软件中产生不可预测的结果。JavaScript的类型系统的好处是它的灵活性，这也可能导致其他问题，正如我已经说过的。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="56ee" class="nf me it nb b gy ng nh l ni nj">// Assignment of different types<br/>let date = '10/10/1991'; <br/>date = 10101991;</span></pre><h2 id="5e37" class="nf me it bd mf no np dn mj nq nr dp mn ld ns nt mp lh nu nv mr ll nw nx mt ny bi translated"><strong class="ak">打字系统</strong></h2><p id="37fe" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">TypeScript的系统提供指定和推断类型，以及将类型设置为可选。可选设置允许您选择何时强制类型以及何时允许动态类型。要退出类型检查，可以使用<code class="fe nk nl nm nb b">any</code>关键字。</p><p id="cf0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript是静态类型的，因此所有检查都在编译时执行。编译器检查所有变量和表达式的类型，并在将代码转换为有效的JavaScript时删除所有类型信息。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d043" class="nf me it nb b gy ng nh l ni nj">// Assignment of different types<br/>let date = '10/10/1991'; <br/>date = 10101991; // <strong class="nb iu">Results in a TypeScript compiler error</strong></span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8c3e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak"> TypeScript的结构类型系统</strong></h1><p id="02f7" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">一个类型系统或者是<em class="nz">结构的</em>或者是<em class="nz">名义的</em>，在某些情况下，它可能在一个类型系统中混合了两者(即<a class="ae lq" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">流</a>)。</p><p id="ebee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript是结构化类型的，不像大多数类C语言那样有一个主格类型系统。</p><p id="ac67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<em class="nz">结构</em>类型系统中，如果两种类型具有相同的结构，则认为它们是相同的。所以不需要明确的修饰。如果值的结构与所需类型的结构匹配，则该值是可接受的。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e88b" class="nf me it nb b gy ng nh l ni nj">class Foo { method(input: string) { <em class="nz">/* ... */</em> } }<br/>class Bar { method(input: string) { <em class="nz">/* ... */</em> } }<br/><br/>let foo: Foo = new Bar(); <em class="nz">// Works!</em></span></pre><p id="e183" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的例子是可行的，因为即使Foo和Bar有不同的名字，它们有完全相同的结构。如果这种形状/结构发生变化，将会导致错误。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="20b0" class="nf me it nb b gy ng nh l ni nj">class Foo { method(input: string) { <em class="nz">/* ... */</em> } }<br/>class Bar { method(input: number) { <em class="nz">/* ... */</em> } }<br/><br/>let foo: Foo = new Bar(); <em class="nz">// Error!</em></span></pre><p id="3833" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<em class="nz">标称</em>或<em class="nz">主格</em>类型系统中，如果两个类型具有相同的名称，则认为它们是相同的。它依赖显式注释来确定类型。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f9a9" class="nf me it nb b gy ng nh l ni nj">class Foo { method(input: string) { <em class="nz">/* ... */</em> } }<br/>class Bar { method(input: string) { <em class="nz">/* ... */</em> } }<br/><br/>let foo: Foo = new Bar(); <em class="nz">// Error!</em></span></pre><p id="04a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述示例会导致错误，因为它们具有不同的类型。</p><p id="2388" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">名义类型系统旨在防止意外的类型等价，这意味着仅仅因为某些东西具有相同的属性并不意味着它是有效的。另一方面，TypeScript在结构上是有类型的，偶然的类型等价是可能的。在名义类型系统中，可以使用命名类型来确保传递正确的参数。</p><p id="b24f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结构类型补充了TypeScript中的类型推理。由于这些特性，您可以将大部分工作留给编译器和语言服务，而不必在整个程序中显式地添加类型信息和类继承。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="85c9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">类型擦除</strong></h1><p id="de26" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">想知道运行<code class="fe nk nl nm nb b">tsc</code>命令时幕后会发生什么吗？您显然熟悉TypeScript将编译和生成普通JavaScript代码的部分，但是新生成的代码在以下方面有所不同:</p><p id="ed16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nz">代码转换</em> —代码转换将JavaScript中不可用的语言特性转换成可用且有效的表示。例如，如果您的目标是ECMAScript 5，其中的类不可用，那么所有的类都将被转换成JavaScript函数，这些函数使用ECMAScript 5中的原型继承创建适当的表示。</p><p id="4a67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nz">类型删除</em> —类型删除是指所有类型注释被移除或“删除”的过程，顾名思义，因为JavaScript不理解它们。静态类型检查在开发和编译时需要类型注释和接口，但在运行时不检查类型。</p><h2 id="8882" class="nf me it bd mf no np dn mj nq nr dp mn ld ns nt mp lh nu nv mr ll nw nx mt ny bi translated"><strong class="ak">打字稿代码</strong></h2><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6cdd" class="nf me it nb b gy ng nh l ni nj">class OrderedArray&lt;T&gt; {<br/>    private items: T[] = [];<br/>    constructor(private comparer?: (a: T, b: T) =&gt; number) {<br/>    }<br/>    add(item: T): void {<br/>        this.items.push(item);<br/>        this.items.sort(this.comparer);<br/>}<br/>    getItem(index: number) : T {<br/>        if (this.items.length &gt; index) {<br/>            return this.items[index];<br/>        }<br/>        return null;<br/>    }<br/>}<br/>var orderedArray: OrderedArray&lt;number&gt; = new OrderedArray&lt;number&gt;();<br/>orderedArray.add(5);<br/>orderedArray.add(1);<br/>orderedArray.add(3);<br/>var firstItem: number = orderedArray.getItem(0);<br/>alert(firstItem); // 1</span></pre><h2 id="7c21" class="nf me it bd mf no np dn mj nq nr dp mn ld ns nt mp lh nu nv mr ll nw nx mt ny bi translated"><strong class="ak">编译好的JavaScript代码</strong></h2><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d084" class="nf me it nb b gy ng nh l ni nj">var OrderedArray = (function () {<br/>    function OrderedArray(comparer) {<br/>        this.comparer = comparer;<br/>        this.items = [];<br/>    }<br/>    OrderedArray.prototype.add = function (item) {<br/>        this.items.push(item);<br/>        this.items.sort(this.comparer);<br/>};</span><span id="fba7" class="nf me it nb b gy oa nh l ni nj">OrderedArray.prototype.getItem = function (index) {<br/>        if (this.items.length &gt; index) {<br/>            return this.items[index];<br/>        }<br/>        return null;<br/>    };<br/>    return OrderedArray;<br/>})();<br/>var orderedArray = new OrderedArray();<br/>orderedArray.add(5);<br/>orderedArray.add(1);<br/>orderedArray.add(3);<br/>var firstItem = orderedArray.getItem(0);<br/>alert(firstItem); // 1</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7d77" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">类型推断</strong></h1><p id="0ade" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">你可能已经猜到了这个过程需要什么，因为这个名字泄露了它。有一点可以肯定，它与<strong class="kw iu">类型擦除</strong>中发生的事情无关。好吧，那是什么？这是在没有显式类型注释的情况下，在编译时确定类型的过程。</p><p id="8020" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">话虽如此… </strong></p><p id="cf58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">主要的收获是理解TypeScript的类型系统是结构化的。结构化类型化可以使一些设计变得非常复杂，但是这并不妨碍您使用任何您可能希望从名义上类型化的系统中转移的模式。</p><p id="a48b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，结构化类型允许您排除显式类型注释。因此，类型将被推断出来。最后，当编译TypeScript程序时，将根据显式和隐式类型检查类型，在编译时可以检测到任何错误。</p><p id="f063" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢这篇文章，请在这里给我买杯咖啡<a class="ae lq" href="https://www.buymeacoffee.com/lukemwila" rel="noopener ugc nofollow" target="_blank">☕️😃。</a></p><p id="e297" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nz">参考文献&amp;延伸阅读:</em></p><div class="ob oc gp gr od oe"><a href="https://www.apress.com/gp/book/9781430267904" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Pro TypeScript -应用规模的JavaScript开发| Steve Fenton | Apress</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">JavaScript无处不在，无论是作为一门纯语言还是在Angular、jQuery和Knockout等流行的库中，但是用户…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">www.apress.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://flow.org/en/docs/lang/nominal-structural/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">标称和结构类型|流量</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">名义类型和结构类型的区别</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">flow.org</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://medium.com/@thejameskyle/type-systems-structural-vs-nominal-typing-explained-56511dd969f4" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">类型系统:结构与名义类型解释</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">请不要在Reddit或黑客新闻上链接这篇文章。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://2018.stateofjs.com/javascript-flavors/typescript/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">JavaScript 2018的状态:JavaScript风味-类型脚本</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">发现今年最流行的JavaScript技术。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">2018.stateofjs.com</p></div></div><div class="on l"><div class="ou l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>