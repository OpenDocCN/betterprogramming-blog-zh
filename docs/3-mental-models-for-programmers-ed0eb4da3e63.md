# 程序员的 3 个心智模型

> 原文：<https://betterprogramming.pub/3-mental-models-for-programmers-ed0eb4da3e63>

## 用具体的例子来说明它们为什么有用

![](img/4164f0c505eb62c97ce241860819318a.png)

照片由[迈克尔·泽兹奇](https://unsplash.com/@lazycreekimages?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

想象一下，你有一部没有任何应用程序的智能手机。听起来没什么用，是吧？没有任何心智模型的大脑基本上就是一部没有任何应用程序的智能手机。安装正确的应用程序可以大大提高你的生活质量。学习正确的心智模式对你的大脑也有同样的作用。

你是一名程序员，我将提出三个心智模型供你考虑。你可能会怀疑我的可信度，你的怀疑是正确的。毕竟，我不是马丁·福勒。

然而，在我作为程序员的职业生涯中，我已经解决了很多有趣的问题。多年来，我已经:

*   通过[构建一个完整的模拟库](https://medium.com/tech-quizlet/unit-testing-redefined-c764fa0f6866)，在我的公司内建立一个新的单元测试标准。
*   针对高流量季节执行任务关键型缓存层优化。
*   为数千万用户使用的旗舰产品提供核心功能。
*   将实时机器学习服务部署到生产中。
*   将站点地图生成 ETL 扩展到数亿个 URL。
*   在众多黑客马拉松中名列第一。

我将要提出的心智模型在解决这些问题上起了不小的作用。所以，我相信你很有可能会发现它们也很有用。

一共三个，从最简单的开始。

# 1.负空间

![](img/651797559155312be2dba3c5a423c02a.png)

照片由[丹尼线](https://unsplash.com/@dannylines?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

不要总是关注*是什么*，关注*不是什么*通常会更有成效。

让我们从一个简单的例子开始。如果你做过选择题测验，我肯定你已经通过划掉所有错误答案回答了至少一个问题。这就是所谓的淘汰过程。

现在，考虑一下二分搜索法。它在排序后的数组中查找目标值的索引。它的主要卖点是速度惊人。二分搜索法通过每次迭代将搜索空间减半来达到速度。换句话说，它积极地划掉错误的答案。完成后，正确的答案就会出现。

二分搜索法就是利用*负空格*解决问题的例子。它通过填充负空间，勾勒出我们关心的答案的轮廓。

让我们再看几个例子。

# 更简单的模式匹配

负空间的一个我最喜欢的应用是在正则表达式中。您通常可以通过否定匹配标准将复杂的正则表达式转化为简单的表达式。假设我们想要匹配字符串中用花括号括起来的部分:

```
The {quick brown fox} jumps over the {lazy dog}.
```

在我熟悉这个心理模型之前，我的直觉是关注花括号中可能出现的每个字符。这意味着字母数字字符、空格、新行、引号、标点符号等。我的解决方案应该是类似于`\{[\!\-\w\s\'\"\,\.\/\?]+\}`的东西。

这种方法不仅不必要的复杂，而且甚至可能不匹配所有感兴趣的字符。因此，我们可以*否定*标准，尝试匹配*不是*右花括号的所有字符，而不是尝试匹配可能出现在花括号中的每个字符。结果是`\{[^\}]+\}`。

```
{quick brown fox}, {lazy dog}
```

否定的解决方案更完整，也更容易理解。

# 编写更干净的代码

正如 Joel Spolsky 所说，编程的一个基本法则是:读代码比写代码更难。嵌套的`if`语句是一种让查找一段代码变得特别困难的模式。

这里有一个例子:

上面代码中的主要逻辑对一组加起来是正数的整数进行操作。然而，为了到达主要逻辑，我们必须通过几个层次的`if`语句。这使得代码难以阅读。读者必须跟踪应用于每个代码路径的约束集，这是一个巨大的认知负担。

但是代码不一定要这样写。我们可以逐步填充负空间，这样只有主要逻辑的条件留在最后:

一个接一个地划掉例外情况，使得嵌套的`if`语句变平了。现在，主要的逻辑是突出的，并且更容易识别边缘情况。负空间心智模式再一次给了我们一个更容易理解的解决方案。

当你在解决某个特定问题时遇到困难，试着利用负空间找到一个优雅的解决方案。

# 2.帕累托原则

![](img/774af25fb7ce0baefe5ac43dd6509888.png)

paweczerwi ski 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

也被称为 80/20 法则。许多人已经知道了这个心智模型，但是它非常有用，我还是决定把它放在这里。该原理指出，大约 80%的结果来自 20%的原因。这听起来像一个神话，但它不是。

例如:

*   小客户群承担了大部分收入(对于有所谓“鲸鱼”用户的手游来说尤其如此)。
*   少数几个单元测试是造成速度下降的主要原因。
*   代码库的一小部分是大多数错误的原因。

至此，让我们来讨论一下帕累托法则对程序员的两大影响。

# 寻找高杠杆

帕累托原理的一个有趣性质是*标度不变性*，简单来说就是 20%的 20% (4%)要对 80%的 80% (64%)负责。推而广之，大约 1%的原因要对 50%的结果负责。如果你曾经在考试前一天晚上临时抱佛脚，但还是设法取得了及格分数，你就会明白这是真的。

生活中的很多事情都遵循这个一般模式。

您可以使用这些知识来找到导致测试套件 50%速度下降的两个设置调用(这是我在实践中实际看到的)，或者优先考虑并实现能够为用户提供最大价值的特性(而不是被您想要处理的其他特性分散注意力)。

但是帕累托原则最让我兴奋的是它对学习新事物的暗示。例如，您可以学习 Docker(容器化)、Kubernetes(服务部署)和 Terraform(基础设施即代码)等技术的入门课程，并获得巨大的好处，例如部署一个可扩展的服务，其中所需的状态和资源由声明性代码管理，只需要基本的知识。

了解更多显然会有所帮助，但当你刚刚起步时，许多想法在学习投资上有最大的回报。关键是集中精力寻找最有价值的知识。哦，注意不要成为催款-克鲁格效应的受害者。

# 高性能

也许更有争议的是，在一家特定的科技公司中，大约 20%的工程师做 80%的工作(其中 1%是“英雄”工程师)。这有许多可能的原因:

*   新工程师对系统不熟悉，因此无法做出有效的改变。另一方面，在公司工作了很长时间的工程师对系统有更深入的了解，并且能够利用他们的知识。
*   这是一种滚雪球效应，成功完成重大项目的工程师获得了公司的信任，并继续从事更大、更重要的项目，给没有良好记录的工程师留下的机会更少。
*   工程人才分布不均。

对于工程经理来说，这意味着他们必须关注表现最好的工程师，并努力让他们留在公司。然而，他们也必须对培养其他工程师真正感兴趣，这样他们也可以成为高绩效者。

对于我们程序员来说，我们需要理解高性能是基于许多因素的，比如团队、领域和经验。总的来说，我们必须找到合适的人选，并不断学习新的东西，才能表现出色。但是不要搞错——这两件事都需要不小的努力。

关于性能的一些思考是马尔科姆·格拉德威尔在他的书《大卫和歌利亚》中所说的:你可以是小缸里的大鱼，也可以是大缸里的小鱼。

# 3.时间平稳性

![](img/530fd90bd2fb4673201c88df2f3b4887.png)

照片由[斯特芬·冈德曼](https://unsplash.com/@stgu1610?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

有些事情变化很快，有些事情变化很慢。人类的生命最多持续一个世纪，而峡谷需要数百万年才能形成。每件事都发生在不同的时间尺度上。

*时间平稳性*心理模型基本上是问:相对于时间来说*如何平稳*(不变)？

思考是什么让一个东西时间静止是很有趣的。例如，讲故事是一项永恒的技能。这是一种建立在人类通过故事来理解世界的倾向上的技能。而且因为人性的变化速度受到进化(一个缓慢的过程)的限制，在可预见的未来，讲故事仍将是一项有价值的技能。

当我们能够以这种方式区分缓慢变化和快速变化的过程时，我们可以更好地优先考虑我们投资时间的地方。

# 基础代码

考虑软件工程。扩展和改变通常发生在代码库的边缘而不是核心，原因有二:

*   人们想从事新事物。
*   遗留系统很难改变。

再一次，思考为什么遗留系统可能很难改变是很有趣的:

*   代码很难阅读，因为编写时的约定可能不同。
*   唯一熟悉代码的人可能已经离开了公司。
*   也许最重要的是，如果我们改变代码，很多东西可能会被破坏。

在她的[关于可靠设计原则的演讲](https://youtu.be/v-2yFMzxqwU)中，Sandi Metz 解释了缓慢改变*的代码*和快速改变*的代码*的区别。一般来说，易变的、快速变化的代码(那些随着业务需求变化的代码)应该依赖于稳定的、缓慢变化的代码(一般的抽象，比如迭代器)。

一个有用的指导原则是通过*改变*的可能性来给每个模块打分(其中低意味着不太可能)，然后尝试按升序排列依赖关系。如果你发现自己做了很多霰弹枪手术，很有可能你弄错了顺序。使一个模块依赖于另一个经常变化的模块*会增加*依赖模块的可变性分数。

那么这一切意味着什么呢？

这意味着你必须把基础打好。如果你预见到一个系统是未来许多新开发的基础，那就努力去恰当地设计它。是的，理想情况下，我们希望每个系统都设计良好，但是良好的设计需要时间。

记住帕累托原则:把基础打好会有不成比例的回报。

> *“获得正确的[底层]抽象将极大地改善你的代码。”—桑迪·梅兹*

相反，当你不得不改变基础以及建立在基础上的一切时，不稳固的基础会让你损失一大笔钱。相信我——重构基础可能是有史以来最耗时的活动之一。花一个月的时间把基础打好，或者花四个月的时间以后再去修补，这往往是两者的区别。

稍后修复它最糟糕的部分是它总是比预期花费更长的时间。

# 永恒的知识

时间平稳心理模型的另一个应用是决定获得什么技能。例如，像 React 这样的流行软件库可能会在短时间内经历许多变化。几个月前有价值的知识现在可能完全过时了。

同样，机器学习领域正在进行如此多的研究，以至于几乎不可能跟上所有正在进行的新发展。

这些快速变化的过程的共同主题是它们是热门的。很多人对这个领域感兴趣，所以这个领域发展很快。我们有充分的理由被诱惑去关注热门话题。毕竟，我们不想错过重要的新闻。

但是不要让自己疲于应付所有的更新，回顾过去寻找永恒的知识可能会更有成效。

深度神经网络的教父之一杰弗里·辛顿(Geoffrey Hinton)并没有通过效仿他同时代人的做法来彻底改变机器学习领域。他从过去中寻找永恒的好主意。Hinton 采用了感知机(Perceptron)——一种所有人都认为已经过时的机器学习技术——并将其转化为我们今天所知的改变行业的想法，即深度学习。

那么有哪些识别永恒知识的策略呢？好吧，至少有三种方法可以让某样东西保持时间不变:

*   这取决于一个我们无法控制的缓慢的自然过程，比如人类进化。思考:讲故事、领导力和学习如何学习。
*   它是许多其他事情的基础。改变将是痛苦的，因为它会破坏许多建立在基础之上的东西(类似于地震)。想想:操作系统、计算机网络和密码学。
*   它来源于物理或抽象的真理。想想:图论，线性代数，以及纯数学的大多数其他分支。

在我自己的生活中，我发现自己一次又一次地受益于永恒的知识。在我的程序员生涯中，学习操作系统和并发性的课程帮助我调试了一些最棘手的错误。参加密码学课程让我能够识别和修补公司代码库中的漏洞。学习沟通技巧让我能够向我的同事发表引人入胜的演讲。

**无论如何，去学习让你兴奋的热门新技术。但也要确保通过学习一些永恒的技能来分散你的投资组合。**

# 结束语

总结一下:

1.  当一个问题看起来很难时，试着把注意力集中在*负空间*。
2.  记住*帕累托法则*，找到高杠杆。
3.  基于*时间平稳性*，投入工程努力并使你的技能多样化。

在我发表这篇文章之前，我想把它命名为“*程序员的三大心智模型”但这可能是一个谎言(和诱饵)。不同的人发现不同的心智模式是有用的。也就是说，我一直在寻找有用的心智模型。*

你最喜欢的心理模型有哪些？