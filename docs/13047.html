<html>
<head>
<title>Intel Arc GPUs and OneAPI — Do They SYCL?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">英特尔Arc GPUs和OneAPI——它们SYCL吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/intel-arc-gpus-and-oneapi-do-they-sycl-9b3ba7c888b8?source=collection_archive---------1-----------------------#2022-07-22">https://betterprogramming.pub/intel-arc-gpus-and-oneapi-do-they-sycl-9b3ba7c888b8?source=collection_archive---------1-----------------------#2022-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="933b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在英特尔Arc和Iris Xe GPUs上运行oneAPI C++和SYCL代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3a95c9a43c7d6cfb237b077669375fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w9oT5olhxy6uCRM3"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯蒂安·威迪格在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3e4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">oneAPI以C++和SYCL为特色，支持相同的加速器代码在各种GPU和CPU架构上运行。正如我在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/cuda-sycl-codeplay-and-oneapi-accelerators-for-everyone-4603fee0421">上一篇关于异构计算的帖子</a>中所承诺的，这次我们将使用新的英特尔Arc GPU和oneAPI来看看SYCL如何与英特尔Arc配合使用。</p><h1 id="a80d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">英特尔Arc，这里是GPU</h1><p id="4098" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将使用的英特尔Arc GPU以HP Envy 16英寸笔记本电脑的形式出现。它由32GB内存的英特尔i7–12700h提供支持，并配有运行驱动程序版本30.0.101.1743的英特尔Arc A370M。像往常一样，我自己购买了这个硬件(又名笔记本电脑，不是由英特尔提供的)，这篇文章中的一切都是你可以自己做的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/7818dd64c493d4b2f54bdead9fc18822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxBHAmV7O1UpfrT9llJF9A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者提供的惠普Envy图片</p></figure><p id="e269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随机注意，我还购买了华硕动画书，配有英特尔Arc GPU、16GB内存和漂亮的有机发光二极管屏幕！我强烈建议人们也去看看，因为屏幕实在是太棒了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/c5f8683b0680246a01efe851af67c233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lv4Y2WIWmy67zHA_fr2mkQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的华硕动画书图片</p></figure><h1 id="0e82" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">让我们运行一些代码！</h1><p id="f80c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于这是一台全新的笔记本电脑，今天我们将测试设置一个纯Windows开发环境，而不是我们过去使用的WSL2+Ubuntu环境。我们需要安装一些基本工具，如<a class="ae kv" href="https://git-scm.com/download/win" rel="noopener ugc nofollow" target="_blank"> Git </a>、<a class="ae kv" href="https://visualstudio.microsoft.com/vs/community/" rel="noopener ugc nofollow" target="_blank">微软Visual Studio 2022社区版</a>和<a class="ae kv" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/base-toolkit.html" rel="noopener ugc nofollow" target="_blank">英特尔oneAPI基础工具包</a>。我以前介绍过这些的安装，所以这里不再赘述。安装完这些工具后，我们就可以开始在Arc笔记本电脑上构建和运行一些代码了。</p><h2 id="0f1b" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">构建代码</h2><p id="c079" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于我们今天的测试，我们将使用来自<a class="ae kv" href="https://github.com/oneapi-src/oneAPI-samples" rel="noopener ugc nofollow" target="_blank"> oneAPI-samples库</a>的mandelbrot代码。我们为VS2022启动了一个x64原生工具命令提示符，只需运行:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="94e1" class="mr lt iq ne b gy ni nj l nk nl">&gt; git clone <a class="ae kv" href="https://github.com/oneapi-src/oneAPI-samples" rel="noopener ugc nofollow" target="_blank">https://github.com/oneapi-src/oneAPI-samples</a><br/>&gt; cd DirectProgramming\DPC++\CombinationalLogic\mandelbrot</span></pre><p id="0934" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使我们处于编译和运行示例的正确位置。在我们这样做之前，我们将调整src/mandel.hpp文件中的一些参数，使样本生成的图像稍大一些，并且样本的计算量更大。为此，我们将row_size和col_size变量从512更改为2048，并将max_iterations变量设置为10000。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/30f1847ee238014d6467524b8823e4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*XdBm0izPb9kfAGRYknmRoQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">src/mandel.hpp中更新的变量</p></figure><p id="0410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过这些小的改动后，我们初始化我们的oneAPI环境并编译示例代码:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="de3c" class="mr lt iq ne b gy ni nj l nk nl">&gt; c:\Program Files (x86)\Intel\oneAPI\setvars.bat<br/>&gt; MSBuild mandelbrot.sln /t:Rebuild /p:Configuration=”Release”</span></pre><p id="368a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成的二进制文件被写入x64/Release/mandelbrot.exe。现在开始有趣的部分…</p><h2 id="3b89" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">在英特尔Arc(和其他硬件)上运行</h2><p id="f9ee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当然，首先要做的是运行二进制文件，看看会发生什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/15ab860f1299a06e658b32d83e20b39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gk_t4oqCnaF00ZhpaXQ64Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">成功！我们的二进制运行在英特尔Arc GPU上</p></figure><p id="397a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">吼吼！正如我们所看到的，二进制文件选择并运行在我们的英特尔Arc A370M GPU上，生成了我们期望的图像:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/1b145c98de0b6ef37ea4177344503050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZeCgW-ymY8Mj_Lsbn64tw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">mandelbrot示例输出</p></figure><p id="c82d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这对于那些对英特尔Arc产品感兴趣的人来说非常酷，但有趣的是看看它是否能在这台笔记本电脑上的任何其他硬件上正常运行。通过运行oneAPI基本工具包中包含的sycl-ls命令，我们可以看到该系统上可以运行sycl代码的所有可用硬件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/5ee79a07e37200ff4f7fb9259a7bd718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5TUWvd04XkrBMQZ_g7JHg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">sycl-ls输出</p></figure><p id="b4a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在不同的设备上运行二进制文件，我们只需使用以下命令设置SYCL_DEVICE_FILTER环境变量:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2d59" class="mr lt iq ne b gy ni nj l nk nl">&gt; set SYCL_DEVICE_FILTER=opencl:cpu:1</span></pre><p id="b083" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中环境变量赋值与sycl-ls输出的一行中第一个大括号内的值相匹配。有趣的是，sycl-ls输出中有3个有趣的目标，即Alder Lake i7–12700h、英特尔Iris Xe集成GPU和英特尔Arc独立GPU。</p><p id="85bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了展示在多个硬件目标上测试运行是多么容易，我们可以快速使用环境变量在所有这三个目标上运行示例代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/fc326e9b1b99514e549049ab0dd82afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hwu3PFizKMu3ylmkVd5M8A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">HP Envy笔记本电脑上的英特尔CPU、iGPU和dGPU输出</p></figure><h2 id="e3cc" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">我们能打破它吗？</h2><p id="3e6e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">只是为了好玩，让我们看看如果我们禁用笔记本电脑上的GPU会发生什么。我们的SYCL二进制文件会足够智能来使用CPU吗？</p><p id="b54e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用远程桌面连接到笔记本电脑，这将允许我禁用GPU，同时仍然使用远程连接与笔记本电脑进行交互。连接到远程桌面后，我们进入设备管理器并禁用两个GPU。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/73d2e2ea27bf94cb2e96677bf42b327d.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*yUmmA6I0jBWhFVLhT1598A.png"/></div></figure><p id="8935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">远程桌面连接仍在运行，因此我们只需返回到我的命令提示符，取消设置SYCL_DEVICE_FILTER环境变量并运行示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/69b5aa32ea56f09eaf40430bbbf96f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gAoosAyNZ7ebFAEppf3qg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的SYCL运行时选择最佳的剩余选项</p></figure><h2 id="b895" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">健全性检查—另一种架构上的SYCL</h2><p id="2a1c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当然，仅仅运行在英特尔硬件上并不能真正向我们展示SYCL的全部价值。下面是在我的外星人R13 i9–12900 KF、NVIDIA Geforce 3080Ti卡上运行的同一个SYCL示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/94b0c03ba28a48526b1e45896e42ecdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6frglBxQ2_MvvRwoBepDLw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在NVIDIA 3080Ti GPU上运行WSL2</p></figure><p id="ca47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子是使用Codeplay <a class="ae kv" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/GetStartedGuide.md#build-dpc-toolchain-with-support-for-nvidia-cuda" rel="noopener ugc nofollow" target="_blank"> oneAPI for CUDA编译器</a>编译的，就像我在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/cuda-sycl-codeplay-and-oneapi-accelerators-for-everyone-4603fee0421">的上一篇文章</a>中一样。</p><p id="9775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我应该指出，HP Envy正在Windows中运行该示例，而采用NVIDIA GPU的外星人系统正在使用不同编译器的WSL2环境中运行。比较运行的时间是没有意义的，因为这是苹果和橘子的比较。真正的收获应该是带有SYCL代码的C++可以在各种硬件上运行，甚至可以在各种操作系统上运行，而无需修改代码。</p><h1 id="e978" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="0ebe" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们应该从中吸取什么？首先，基于英特尔Arc的系统已经上市，我们可以拿起它们玩游戏、创建内容，甚至可以在上面进行一些GPGPU计算！</p><p id="9634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样重要的是，对于我们这些需要进行基于加速器的编程的人来说，oneAPI以C++和SYCL为特色，通过允许我们编写在不断增长的各种加速器硬件上运行的软件，可以帮助减少我们代码库中的变动量，并提高可维护性。作为一名开发人员，生活已经够艰难了，在我们需要编写和维护的代码量中注入一点简单性是一件值得努力的事情…</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="e86a" class="mr lt iq ne b gy ni nj l nk nl"><strong class="ne ir">Want to Connect?</strong></span><span id="c179" class="mr lt iq ne b gy nu nj l nk nl">If you want to see what random tech news I’m reading, you can <a class="ae kv" href="https://twitter.com/tonymongkolsmai" rel="noopener ugc nofollow" target="_blank">follow me</a> on Twitter.</span><span id="75ac" class="mr lt iq ne b gy nu nj l nk nl">Tony is a Software Architect and Technical Evangelist at Intel. He has worked on several software developer tools and most recently led the software engineering team that built the data center platform which enabled Habana’s scalable MLPerf solution.</span><span id="14dd" class="mr lt iq ne b gy nu nj l nk nl">Intel, the Intel logo and other Intel marks are trademarks of Intel Corporation or its subsidiaries. SYCL is a trademark of the Khronos® Group. Other names and brands may be claimed as the property of others.</span></pre></div></div>    
</body>
</html>