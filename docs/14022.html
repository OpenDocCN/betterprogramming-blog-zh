<html>
<head>
<title>My Favourite Setup for REST Microservices in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中我最喜欢的REST微服务设置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-favourite-setup-for-rest-microservices-in-go-770ca18615ba?source=collection_archive---------1-----------------------#2022-10-27">https://betterprogramming.pub/my-favourite-setup-for-rest-microservices-in-go-770ca18615ba?source=collection_archive---------1-----------------------#2022-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4d5c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go中微服务的模板</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/24831e3f2c5b032df49c301ebc9fa117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zaVQgYpZO5yUjkR_uZflQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">摄影师</a>在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个故事中，我想分享一下我个人对于Go中服务REST APIs的微服务的模板。因为我已经开始从头开始编写一些服务，观察到特定的代码部分总是重复，所以我决定将它们导出到一个模板中并共享它。</p><p id="1119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然某些部分可能会在其他框架更受欢迎的情况下进行调整，但我希望整体结构能够以更简单、更快速的方式帮助您实现下一个项目。</p><p id="68ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个故事中，我展示了一个示例项目服务，它提供API端点来管理项目、里程碑和任务。</p><h1 id="71a3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">文件夹结构</h1><p id="29b0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我想分享我的首选文件夹结构，在这里您可以找到运行示例<code class="fe ms mt mu mv b">project-service</code>的所有文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="8fc7" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">api/</code>包含一个或多个版本的REST API</li><li id="9b71" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">dbs/</code>包含初始化数据库连接和执行迁移的代码</li><li id="d939" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">models/</code>包含所有模型定义和潜在的模型相关逻辑</li><li id="83e1" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">pkg/**/*</code>包含模型的服务逻辑</li><li id="96a2" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">seeds/</code>包含最初用一些数据播种数据库的代码</li></ul><h1 id="e12d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型</h1><p id="b022" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了简化数据库操作，ORM是一个非常好的选择。我个人比较喜欢<a class="ae ky" href="https://gorm.io/" rel="noopener ugc nofollow" target="_blank"> gorm </a>。Gorm通过标签反射工作，这意味着您向模型的字段添加标签，gorm将处理它们。gorm可以处理的简单模型如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管非常灵活，gorm还是提供了简单的用法和强大的缺省值。通过扩展<code class="fe ms mt mu mv b">gorm.Model</code>结构，您的模型将获得一个ID字段，用作标识符(默认情况下，它将是一个自动递增的整数)。</p><p id="82c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">未标记的字段被转换为snake case列名。通过字段标签，我们可以配置gorm的行为，在本例中，我们只需向name列添加一个索引。</p><p id="b736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他模型可以通过使用它们的结构作为字段，甚至作为切片来引用。我们的服务有三种模式:<code class="fe ms mt mu mv b">Project</code>、<code class="fe ms mt mu mv b">Milestone</code>、<code class="fe ms mt mu mv b">Task</code>。一个项目有一个或多个里程碑，每个里程碑可能有一个或多个任务。</p><p id="be6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议为每个模型创建一个单独的<code class="fe ms mt mu mv b">.go </code>文件，如果模型还实现了其他接口或者有特定的(反)序列化逻辑，那么这个文件会更容易维护。</p><p id="f8b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我总是在<code class="fe ms mt mu mv b">models</code>文件夹中添加一个<code class="fe ms mt mu mv b">migrate.go</code>文件，其中包含自动迁移代码。对于gorm，如果您遵循指南，这是一个显而易见的事情，您可以简单地将所有模型的引用放入<code class="fe ms mt mu mv b">gorm.AutoMigrate()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="45c3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据库初始化</h1><p id="5ed8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我的模板的下一部分是设置数据库连接和执行迁移等初始操作的逻辑。在<code class="fe ms mt mu mv b">dbs</code>文件夹中，我有一个名为<code class="fe ms mt mu mv b">setup.go</code>的文件，它运行初始化首选数据库连接的代码。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码很简单，有一个<code class="fe ms mt mu mv b">InitializeDatabaseLayer</code>函数传递<code class="fe ms mt mu mv b">DB</code>环境变量并检查应该使用哪个数据库驱动程序。在这个示例中，实现了用于开发的SQLite和用于生产设置的Postgres，但是它可以很容易地扩展到所有其他支持的gorm驱动程序。</p><p id="4cea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这两个驱动程序中的每一个，我都添加了一个从环境中加载所需信息并连接到数据库的方法。之后，调用给出的<code class="fe ms mt mu mv b">automigrate</code>方法来确保数据库与模型同步。最后是gorm的一个实例。DB将返回给应用程序。我喜欢将这个实例保存在一个变量中，并导出一个函数来获取它，在本例中，是<code class="fe ms mt mu mv b">GetDB</code>方法。</p><h1 id="a684" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">执行数据库逻辑的服务实例</h1><p id="59e5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">既然已经建立了数据库连接，接下来要考虑的是实际的数据库相关逻辑。在我的展示中，我有所有三个需要实现的模型的CRUD操作。在我的模板中，我喜欢为每个模型创建一个文件夹，并在那里找到所有相关的实现，从一个<code class="fe ms mt mu mv b">service.go</code>文件开始。以下代码显示了项目的该文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务实现从一个<code class="fe ms mt mu mv b">ProjectService</code>结构和它的单例实例开始，调用<code class="fe ms mt mu mv b">projects.GetService().</code>将返回该结构和单例实例。服务本身包含为项目模型执行数据库操作的逻辑。使用在<code class="fe ms mt mu mv b">setup.go</code>文件中初始化的gorm数据库实例，将基本CRUD操作实现为专用方法。因为gorm给了我们一个很好的特性集，所以实现这些CRUD操作很简单。TODO:可以在不同的API中重用</p><p id="f158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于其余的模型，服务实现看起来是相似的。虽然这对于我们的三个模型及其简单的逻辑来说看起来相当冗长，但我认为当您的代码库增长时，以这种方式分离和实现东西将会带来巨大的好处。</p><h1 id="f1c3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用Gin Gonic的休止端点</h1><p id="8b51" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在实现了与数据库相关的核心逻辑之后，我们需要通过REST API公开它。因此，我通常会创建一个包含版本化API的<code class="fe ms mt mu mv b">api</code>文件夹，例如在这个简单的例子中的<code class="fe ms mt mu mv b">v1.go</code>，在更复杂的API中，为每个版本创建专用的文件夹可能也是聪明的做法。</p><p id="6fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具有特定版本号的API总是有自己的URL上下文，例如版本1的<code class="fe ms mt mu mv b">/v1/*</code>。API代码相对简单，因为我们的核心逻辑是在服务中实现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通过使用一个结构来实现每个API版本，例如对于REST API版本1使用<code class="fe ms mt mu mv b">RESTAPIV1</code>。作为一个HTTP框架，我个人喜欢使用<a class="ae ky" href="https://gin-gonic.com/" rel="noopener ugc nofollow" target="_blank"> Gin Gonic </a>，因为它简单而强大。</p><p id="dbfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把gin路由器作为API struct中的一个字段，添加了<code class="fe ms mt mu mv b">Serve</code>方法，可以从主程序调用。</p><p id="ee29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构造函数<code class="fe ms mt mu mv b">NewRestApiV1</code>中，我通过<code class="fe ms mt mu mv b">router.POST</code>或<code class="fe ms mt mu mv b">router.GET</code>等实例化了这个路由器并注册了所有路由器。可通过路线中的<code class="fe ms mt mu mv b">:paramName</code>简单配置参数。正如我们在<code class="fe ms mt mu mv b">EditProject</code>方法中看到的(它获得对<code class="fe ms mt mu mv b">gin.Context</code>的引用作为唯一的参数)，param可以通过<code class="fe ms mt mu mv b">c.Param("paramName").</code> Gin Gonic通过<code class="fe ms mt mu mv b">ShouldBindJSON</code>方法为使用JSON提供了很好的开发人员体验。</p><p id="7324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，返回代码和JSON响应很容易通过<code class="fe ms mt mu mv b">c.JSON</code>和简写<code class="fe ms mt mu mv b">gin.H</code>实现，它们可以用作通用映射。</p><p id="fbea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然通过Gin Gonic的REST只是一个例子，但是许多其他组合也是可能的，例如GRPC或Websockets，或者如果喜欢的话，简单地使用另一个HTTP库。</p><h1 id="e3c4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">种子</h1><p id="17eb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虽然我们可以通过迁移将我们的模型表示与数据库同步，但是向数据库添加初始数据通常非常有帮助，例如，一个管理员用户。这避免了使用外部管理工具连接到数据库来手动添加这些数据。</p><p id="fe92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更喜欢将种子文件的路径作为命令行参数传递给服务，当该文件存在并且数据库为空时，服务将加载种子文件并插入所有包含的数据。</p><p id="4355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于编辑，我更喜欢对种子文件使用JSON。运行种子的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="322f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，获取所有服务实例。之后，代码检查数据库中是否有任何任务，如果有，则返回方法，因为我们希望种子数据只插入一次。</p><p id="ba56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数据库中没有任务，代码会打开种子，创建一个JSON编码器并解析文件，以防它是有效的JSON。JSON应该是一个<code class="fe ms mt mu mv b">Seeds</code>对象，它有项目、里程碑和任务片段作为字段。最后，这些切片将被迭代以插入数据。</p><p id="60e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的一点是，种子项目也可以有里程碑，这些里程碑也可以有任务。</p><h1 id="3a75" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">主程序</h1><p id="8f63" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在详细介绍了所有部分之后，最后缺少的部分就是主程序，它存储在<code class="fe ms mt mu mv b">main.go</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="58bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主程序非常短，因为这个模板为微服务的所有核心部分提供了专用文件夹。它从通过Go的内部标志包设置一些命令行标志开始。这些标志如下:HTTP端点监听的本地地址<code class="fe ms mt mu mv b">laddr</code>、<code class="fe ms mt mu mv b">loglevel</code>和初始种子文件的路径<code class="fe ms mt mu mv b">initialSeedFile</code>。我喜欢使用<a class="ae ky" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> logrus </a>进行日志记录，它接受不同<code class="fe ms mt mu mv b">loglevels</code>的列表。除了一些首选的格式设置外，<code class="fe ms mt mu mv b">configureLogging</code>方法从标志中解析<code class="fe ms mt mu mv b">loglevel</code>并相应地设置它。主函数调用<code class="fe ms mt mu mv b">configureLogging</code>，初始化数据库层(包括迁移)，然后运行种子(如果<code class="fe ms mt mu mv b">initialSeedFile</code>已设置)，然后创建REST API并在已配置的<code class="fe ms mt mu mv b">laddr</code>下服务它。</p><h1 id="00b9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Dockerfile文件</h1><p id="5315" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，我想简单介绍一下Dockerfile，我总是把它添加到我的Go服务中，把它们作为容器来部署。这是一个基于alpine的多阶段dockerfile文件，它创建了相对较小的容器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="89b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它开始使用1.18 Golang alpine容器，将当前文件夹复制到其中，并通过<code class="fe ms mt mu mv b">CGO_ENABLED=0 go build</code>进行构建。</p><p id="345f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这里可能不需要<code class="fe ms mt mu mv b">CGO_ENABLED=0</code>部分，但如果所有阶段都基于类似的alpine版本，这有助于避免在更改第一或第二阶段基本容器时出现问题。</p><p id="d414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建完成后，我使用默认的alpine映像作为第二阶段，安装<code class="fe ms mt mu mv b">ca-certificates</code>(如果您想与通过TLS保护的外部端点通信，这是必须的)，然后复制第一阶段构建的二进制文件。最后一步是简单地设置docker <code class="fe ms mt mu mv b">ENTRYPOINT</code>。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="49b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个故事中，我分享了我在Go中首选的微服务模板。我认为它提供了一个很好的起点，也可以扩展到更大的服务。我很高兴得到任何反馈或建议来改进这个故事。</p><p id="c317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的代码可以在<a class="ae ky" href="https://github.com/martenwallewein/go-sample-microservice" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>