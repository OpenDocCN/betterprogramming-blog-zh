<html>
<head>
<title>Use pywinauto to Automate Programs in Windows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用pywinauto自动化Windows中的程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-pywinauto-to-automate-programs-in-windows-7d4a7eb082a5?source=collection_archive---------0-----------------------#2020-03-11">https://betterprogramming.pub/use-pywinauto-to-automate-programs-in-windows-7d4a7eb082a5?source=collection_archive---------0-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e65" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让您的操作系统为您服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a22cb6f910ac580e881715bcd03b7737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgjQznBtz8gD1pyQ18zmEg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@agto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Agto Nugroho </a>在<a class="ae ky" href="https://unsplash.com/s/photos/factory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将教你在Windows中使用一个叫做<code class="fe lv lw lx ly b">pywinauto</code>的Python模块来自动化一个程序。根据官方文档，<a class="ae ky" href="https://pywinauto.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> pywinauto </a>是:</p><blockquote class="lz ma mb"><p id="3ced" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated"><em class="it"> …一组用于自动化Microsoft Windows GUI的python模块。最简单的是，它允许你发送鼠标和键盘动作到窗口对话框和控件，但是它支持更复杂的动作，比如获取文本数据。</em></p><p id="7a5e" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated"><em class="it">幕后支持的技术:Win32 API(</em><code class="fe lv lw lx ly b"><em class="it">backend="win32"</em></code><em class="it">)；默认使用)，MS UI自动化(</em> <code class="fe lv lw lx ly b"><em class="it">backend="uia"</em></code> <em class="it">)。用户输入仿真模块</em> <code class="fe lv lw lx ly b"><em class="it">mouse</em></code> <em class="it">和</em> <code class="fe lv lw lx ly b"><em class="it">keyboard</em></code> <em class="it">在Windows和Linux上都可以工作。</em></p></blockquote><p id="0879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文分为五个部分:</p><ol class=""><li id="cde2" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">设置</li><li id="c3ec" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">基本用法</li><li id="7c70" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">键盘和鼠标</li><li id="61ac" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">捕捉图像</li><li id="efc6" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">结论</li></ol></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="5ff6" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">1.设置</h1><p id="64ed" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我们可以通过<code class="fe lv lw lx ly b">pip install</code>轻松安装这个模块。它将自动安装模块和所需的依赖项。强烈建议您在继续之前创建一个新的虚拟环境。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="38d9" class="oc nc it ly b gy od oe l of og">pip install -U pywinauto</span></pre><p id="06b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，通过以下命令检查是否安装了以下模块和依赖项:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="41e7" class="oc nc it ly b gy od oe l of og">pip list</span></pre><p id="da07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该具有以下依赖关系:</p><ul class=""><li id="21d1" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu oh mm mn mo bi translated">pywinauto</li><li id="adc5" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu oh mm mn mo bi translated">pyWin32</li><li id="62cf" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu oh mm mn mo bi translated">comtypes</li><li id="4dfc" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu oh mm mn mo bi translated">六</li><li id="31af" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu oh mm mn mo bi translated">枕头(此模块是可选的，只有在您打算截图时才需要)</li></ul><p id="2768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续下一节，开始写一些Python代码。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="e1cd" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">2.基本用法</h1><h2 id="4d91" class="oc nc it bd nd oi oj dn nh ok ol dp nl li om on nn lm oo op np lq oq or nr os bi translated">术语和定义</h2><p id="bf19" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在我们继续之前，让我们看一下本模块的一些术语和定义。</p><ul class=""><li id="d5cb" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu oh mm mn mo bi translated">包含按钮、编辑框等其他GUI元素/控件的窗口。对话框不一定是主窗口。主窗体顶部的消息框也是一个对话框。pywinauto也认为主窗体是一个对话框。</li><li id="c589" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu oh mm mn mo bi translated"><code class="fe lv lw lx ly b">Control</code> —层次结构中任何级别的GUI元素。这个定义包括窗口、按钮、编辑框、网格、网格单元、栏等。</li></ul><h2 id="6045" class="oc nc it bd nd oi oj dn nh ok ol dp nl li om on nn lm oo op np lq oq or nr os bi translated">后端</h2><p id="c8b2" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">后端是指应用程序或程序背后的可访问性技术。在撰写本文时，该模块仅向我们提供了以下后端:</p><ul class=""><li id="27b3" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu oh mm mn mo bi translated">nowMFC、VB6、VCL、简单的WinForms控件和大多数旧的遗留应用程序的默认后端。</li><li id="1f7d" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu oh mm mn mo bi translated"><code class="fe lv lw lx ly b">MS UI Automation (backend=”uia”)</code> — WinForms、WPF、商店应用、Qt5、浏览器。Chrome启动前需要<code class="fe lv lw lx ly b">force-renderer-accessibility</code> cmd标志。由于comtypes Python库的限制，不支持自定义属性和控件。</li></ul><h2 id="75a8" class="oc nc it bd nd oi oj dn nh ok ol dp nl li om on nn lm oo op np lq oq or nr os bi translated">导入</h2><p id="e145" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">第一部分是在脚本中导入必要的模块。让我们从导入<code class="fe lv lw lx ly b">pywinauto</code>模块的<code class="fe lv lw lx ly b">Application</code>类开始。<code class="fe lv lw lx ly b">Application</code>是你每个自动化过程的起点。我将使用记事本作为这篇文章的用例。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="e05b" class="oc nc it ly b gy od oe l of og">from pywinauto.application import Application</span></pre><p id="5387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您打算调用基本的用户输入功能，如鼠标和键盘，您还需要导入以下代码:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="4070" class="oc nc it ly b gy od oe l of og">import pywinauto.mouse as mouse<br/>import pywinauto.keyboard as keyboard</span></pre><h2 id="8be7" class="oc nc it bd nd oi oj dn nh ok ol dp nl li om on nn lm oo op np lq oq or nr os bi translated">启动并连接</h2><p id="ae79" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">您需要将<code class="fe lv lw lx ly b">Application</code>实例连接到一个流程，以便自动化它。有两种方法可以做到:</p><ul class=""><li id="59ed" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu oh mm mn mo bi translated"><code class="fe lv lw lx ly b">start()</code> —当应用程序没有运行而您需要启动它时使用。它接受一个字符串，可以包含命令行参数和一个<code class="fe lv lw lx ly b">timeout</code>参数。只有当程序启动时间过长时，才需要<code class="fe lv lw lx ly b">timeout</code>参数。以下是启动记事本的示例:</li></ul><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="22aa" class="oc nc it ly b gy od oe l of og">app = Application().start(r"c:\windows\system32\notepad.exe")</span></pre><ul class=""><li id="390d" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu oh mm mn mo bi translated"><code class="fe lv lw lx ly b">connect() </code> —当您试图自动化正在运行的过程时使用。您可以传入程序的进程id、句柄或路径。强烈建议使用绝对路径，当您重新启动程序时，进程id和句柄可能会改变。你必须确保程序完全启动并运行，否则就会出错。</li></ul><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="e939" class="oc nc it ly b gy od oe l of og">app = Application().connect(path=r"c:\windows\system32\notepad.exe")</span></pre><h2 id="2d8b" class="oc nc it bd nd oi oj dn nh ok ol dp nl li om on nn lm oo op np lq oq or nr os bi translated">对话</h2><p id="6588" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">您可以通过项目或属性访问来访问该对话框。您需要确定流程的可用窗口:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="c80d" class="oc nc it ly b gy od oe l of og">app.windows()</span></pre><p id="fa8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到以下结果。这意味着此流程有一个活动窗口:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="6680" class="oc nc it ly b gy od oe l of og">[&lt;uiawrapper.UIAWrapper - 'Untitled - Notepad', Dialog, 3713031533299862531&gt;]</span></pre><p id="15a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过以下方法分配它:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="6a53" class="oc nc it ly b gy od oe l of og">dlg = app['Untitled - Notepad']</span></pre><p id="eec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密钥必须与窗口的名称匹配。在这种情况下，名称为<code class="fe lv lw lx ly b">Untitled — Notepad</code>。</p><p id="f66a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果窗口的名称太长，您可以使用regex来捕获它:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="37db" class="oc nc it ly b gy od oe l of og">app.window(title_re=".*Notepad.*")</span></pre><h2 id="df93" class="oc nc it bd nd oi oj dn nh ok ol dp nl li om on nn lm oo op np lq oq or nr os bi translated">控制</h2><p id="e0c9" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">下一步是通过运行以下代码来识别所有可用的控件。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="8a8d" class="oc nc it ly b gy od oe l of og">dlg.print_control_identifiers()</span></pre><p id="cc10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我得到了以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/5e0cbdd124d1b6b4df074ff7a9880cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwfgECd_IvbfIIi3jmDNKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下使用的是<code class="fe lv lw lx ly b">win32</code>后端，如果你在获取控件时遇到困难，可以考虑将后端改为<code class="fe lv lw lx ly b">uia</code>。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="0480" class="oc nc it ly b gy od oe l of og">app = Application(backend="uia").start(r"c:\windows\system32\notepad.exe")</span></pre><p id="1f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的程序非常复杂，你可能无法加载所有的控件。可以通过以下方法捕获控件:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="f50b" class="oc nc it ly b gy od oe l of og">app.dlg.control #first method</span><span id="8f35" class="oc nc it ly b gy ou oe l of og">app['dlg']['control'] #second method is preferred as it is more robust for unicode strings</span></pre><p id="d245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有不同类型控制可以自动化。最常用的控件有<code class="fe lv lw lx ly b">Button</code>、<code class="fe lv lw lx ly b">Edit</code>和<code class="fe lv lw lx ly b">MenuItem</code>。每一个控件都有它们各自的函数调用。更多信息请参考<a class="ae ky" href="https://pywinauto.readthedocs.io/en/latest/controls_overview.html" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><p id="cd41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们自动选择菜单。我将切换位于<code class="fe lv lw lx ly b">View</code>菜单下的状态栏。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="198e" class="oc nc it ly b gy od oe l of og">dlg.menu_select("View -&gt; Status Bar")</span></pre><p id="1020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行上面的代码时，您将会看到状态栏的状态将会改变，这取决于初始状态。您可以对其他功能执行相同的操作，例如保存文件。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="cf68" class="oc nc it ly b gy od oe l of og">dlg.menu_select("File -&gt; Save as")</span></pre><p id="0fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以继续链接自动化过程。以下示例打开并关闭“替换”窗口。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="d4bd" class="oc nc it ly b gy od oe l of og">dlg.menu_select("Edit -&gt; Replace")<br/>dlg.Replace.Cancel.click()</span></pre><p id="84e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在编辑控件中键入一些文本。下面的例子说明了这样做的方法。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="5c46" class="oc nc it ly b gy od oe l of og">dlg.Edit.type_keys('Welcome to Medium')</span></pre><p id="005c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行它时，您会注意到出现在记事本上的最终文本是<code class="fe lv lw lx ly b">WelcometoMedium</code>，两个空格都从原始文本中消失了。这是正常的，因为这个模块是基于键盘输入的。您可以通过在字符串中添加适当的键码来轻松解决这个问题。查看此<a class="ae ky" href="https://pywinauto.readthedocs.io/en/latest/code/pywinauto.keyboard.html" rel="noopener ugc nofollow" target="_blank">页面</a>了解更多信息。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="ec08" class="oc nc it ly b gy od oe l of og">dlg.Edit.type_keys('Welcome{SPACE}to{SPACE}Medium')</span></pre><p id="f9c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在构建一个自动化解决方案，您可能希望在将输入字符串传递给函数之前对其进行预处理。让我们创建一个简单的函数来实现这一点:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="386b" class="oc nc it ly b gy od oe l of og">def replace_space(text):<br/>    return text.replace(' ', '{SPACE}')</span></pre><p id="c98e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最新版本还带有内置参数来为您映射字符串。您可以简单地将<code class="fe lv lw lx ly b">with_spaces</code>参数设置为<code class="fe lv lw lx ly b">True</code>。参数的完整列表如下:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="c473" class="oc nc it ly b gy od oe l of og">type_keys<!-- -->(<em class="mc">keys</em>, <em class="mc">pause=None</em>, <em class="mc">with_spaces=False</em>, <em class="mc">with_tabs=False</em>, <em class="mc">with_newlines=False</em>, <em class="mc">turn_off_numlock=True</em>, <em class="mc">set_foreground=True</em>, <em class="mc">vk_packet=True</em>)</span></pre><p id="8ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，如果您的字符串中存在不属于键码的花括号，您很可能会遇到错误。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="55d3" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">3.键盘和鼠标</h1><p id="8e18" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果您无法捕获控件，您可以使用键盘和鼠标模块来实现自动化。在继续之前，您需要将焦点设置到应用程序上。使用内置的<code class="fe lv lw lx ly b">send_keys</code>开始向你的程序写文本。请不要把这个功能和我上面提到的<code class="fe lv lw lx ly b">type_keys</code>混淆。<code class="fe lv lw lx ly b">Type_keys</code>只是一个调用底层<code class="fe lv lw lx ly b">send_keys</code>函数的包装器。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="f3b6" class="oc nc it ly b gy od oe l of og">dlg.set_focus()<br/>keyboard.send_keys('Hello')</span></pre><p id="9de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您在通过点击应用程序右上角的关闭按钮来自动关闭程序时遇到了问题。您可以通过手动自动化鼠标点击来轻松解决这个问题。在此之前，让我们看看之前使用<code class="fe lv lw lx ly b">print_control_identifiers</code>打印出来的控件。你会注意到这样的东西:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="e68c" class="oc nc it ly b gy od oe l of og">TitleBar - ''    (L157, T45, R1872, B87)</span></pre><p id="5949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一部分指的是窗口左、上、右、下的坐标。你可以用它来定位和移动鼠标到特定的位置。既然关闭按钮和标题栏在一条线上，那我们就在右上角位置点击鼠标吧。我把位置移动了一点来补偿偏移。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="0cbf" class="oc nc it ly b gy od oe l of og">dlg.set_focus()<br/>mouse.click(coords=(1850, 60))</span></pre><p id="4d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到一个提示，要求您保存或不保存就退出。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="16f0" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">4.捕捉图像</h1><p id="03ef" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">capture_as_image</code>功能捕捉窗口或程序的图像。您可以将它用于调试目的。在出现异常的情况下，您可以触发这个函数，并将生成的PIL图像保存到一个目录中。让我们来看看您是如何做到这一点的。确保您已经在脚本所在的目录中创建了一个<code class="fe lv lw lx ly b">log</code>文件夹:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="c7e6" class="oc nc it ly b gy od oe l of og">import datetime;</span><span id="34f4" class="oc nc it ly b gy ou oe l of og">dlg.set_focus()<br/>debug_image = dlg.capture_as_image()<br/>debug_image.save('log/' + str(int(datetime.datetime.now().timestamp())) + '.png')</span></pre><p id="d425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，这段代码将把应用程序带到前台，并根据进度的位置和矩形捕获图像。它可能包含其他不需要的部分，并且前面的任何其他程序也将被捕获。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="e671" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">5.结论</h1><p id="7b62" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">让我们回顾一下今天所学的内容。我们开始通过<code class="fe lv lw lx ly b">pip install</code>安装<code class="fe lv lw lx ly b">pywinauto</code>模块。</p><p id="4b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们深入探讨了该模块的基本用法。我们了解了可用的后端，以及其中使用的术语。我们还编写了一些代码来自动化简单的操作，比如菜单选择和按钮点击。</p><p id="e691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用内置的键盘和鼠标模块尝试了手动自动化，与通常的方法相比，它提供了更多的灵活性。为了调试的目的，我们甚至捕获了程序的图像。</p><p id="3434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章，我希望再次见到你！</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="a1d2" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">参考</h1><ol class=""><li id="9d1c" class="mg mh it lb b lc nt lf nu li ov lm ow lq ox lu ml mm mn mo bi translated">pywinauto 的文档</li><li id="5ab2" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><a class="ae ky" href="https://github.com/pywinauto/pywinauto" rel="noopener ugc nofollow" target="_blank"> pywinauto的Github页面</a></li></ol></div></div>    
</body>
</html>