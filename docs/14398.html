<html>
<head>
<title>Object-Oriented Inheritance in Elixir With Macros? No, Seriously</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用宏实现Elixir中的面向对象继承？不，说真的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/object-oriented-inheritance-in-elixir-with-macros-no-seriously-2af0878dc10c?source=collection_archive---------6-----------------------#2022-12-08">https://betterprogramming.pub/object-oriented-inheritance-in-elixir-with-macros-no-seriously-2af0878dc10c?source=collection_archive---------6-----------------------#2022-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Elixir的宏系统让开发者可以做一些不可思议的事情——包括一些你可能不应该做的事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/827e2c60217fe1ac68154d6c10079ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rdemsi8M5238zcfh"/></div></div></figure><p id="c816" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Reddit <a class="ae lq" href="https://www.reddit.com/r/elixir/comments/yy6k69/how_does_a_functional_language_based_framework/" rel="noopener ugc nofollow" target="_blank">的Elixir论坛上最近的一篇帖子询问了Elixir如何在没有继承的情况下实现代码重用</a>。来自面向对象的背景，OP习惯于通过用类继承行为来解决这个问题，但不确定如何用像<a class="ae lq" href="http://elixir-lang.org" rel="noopener ugc nofollow" target="_blank"> Elixir </a>这样的<a class="ae lq" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式语言</a>来解决这个问题。</p><p id="6553" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般的答案是，Elixir倾向于一种<a class="ae lq" href="https://en.wikipedia.org/wiki/Object_composition" rel="noopener ugc nofollow" target="_blank">组合</a>方法，通过从其他模块导入功能来构造复杂的行为。但是这篇文章让我思考:尽管这可能是一件可怕的事情，但在Elixir中实现经典的面向对象风格继承有可能吗？</p><p id="a0f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实证明，<em class="lr">是的</em> : Elixir的宏系统足够强大，可以用模块实现面向对象的风格继承。在这篇文章中，我们将学习Elixir宏系统以及如何使用它来实现继承。我们还将谈一谈为什么这样做可能不是一个好主意。</p><p id="d437" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://en.wikipedia.org/wiki/Metaprogramming" rel="noopener ugc nofollow" target="_blank"> <em class="lr">元编程</em> </a> <em class="lr">，</em>广义来说，就是将代码作为数据来操作的能力。这意味着编程语言可以读取、修改和生成自己的代码，它就像听起来一样强大和危险。</p><p id="767e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://amzn.to/3Y65r2I" rel="noopener ugc nofollow" target="_blank"> Elixir通过</a> <a class="ae lq" href="https://elixir-lang.org/getting-started/meta/macros.html" rel="noopener ugc nofollow" target="_blank">其<em class="lr">宏</em>系统</a>启用元编程。宏系统让我们<em class="lr">编写并执行生成代码的代码，</em>这为各种语言扩展和代码重用机制打开了大门。让我们看一个简单的例子，我们有一些“mixin”函数想要注入到一个模块中:</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="951b" class="lx ly it lt b be lz ma l mb mc">defmodule Mixin do <br/>  defmacro __using__(_) do <br/>    quote do <br/>      def mixin_func1(value), do: IO.inspect(value) <br/>      def mixin_func2(value), do: IO.inspect(value * 2) <br/>    end <br/>  end <br/>end <br/><br/># add the "use" macro to inject functions into MyModule <br/>defmodule MyModule do <br/>  use Mixin <br/>end <br/><br/>MyModule.mixin_func2(5) <br/>&gt; 10</span></pre><p id="1b65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不是简单地<em class="lr">执行代码，</em>宏可以<em class="lr">返回调用者可以执行的代码- </em>包括动态生成的代码<em class="lr">。</em>这是通过使用<code class="fe md me mf lt b">quote do ... end</code>块引用<a class="ae lq" href="https://elixir-lang.org/getting-started/meta/quote-and-unquote.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr">代码并返回其数据表示</em></a>而不是执行它<em class="lr">来完成的。</em>在这个简单的用例中，<a class="ae lq" href="https://elixir-lang.org/getting-started/alias-require-and-import.html#use" rel="noopener ugc nofollow" target="_blank"/><code class="fe md me mf lt b"><a class="ae lq" href="https://elixir-lang.org/getting-started/alias-require-and-import.html#use" rel="noopener ugc nofollow" target="_blank">__using__</a></code><a class="ae lq" href="https://elixir-lang.org/getting-started/alias-require-and-import.html#use" rel="noopener ugc nofollow" target="_blank">宏</a>让我们有效地用<code class="fe md me mf lt b">use Mixin</code>将我们的函数定义代码注入到<code class="fe md me mf lt b">MyModule</code>中。</p><p id="04da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于一个更真实的例子，考虑在<a class="ae lq" href="http://phoenixframework.org" rel="noopener ugc nofollow" target="_blank"> Phoenix Framework </a>的默认项目中生成的这段代码(有一些修改)。在这个例子中，像<code class="fe md me mf lt b">MyAppWeb.UserController</code>这样的控制器模块需要访问某些功能。代替<em class="lr">子类化</em>一些基本控制器类，我们使用一个宏来注入期望的代码:</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="8437" class="lx ly it lt b be lz ma l mb mc">defmodule MyAppWeb do <br/>  def controller do<br/>    quote do <br/>      use Phoenix.Controller, namespace: MyAppWeb <br/>      import Phoenix.LiveView.Controller <br/>      import Plug.Conn import MyAppWeb.Gettext <br/>      alias MyAppWeb.Router.Helpers, as: Routes <br/>    end <br/>  end <br/>  <br/>  defmacro __using__(which) when is_atom(which) do <br/>    apply(__MODULE__, which, []) <br/>  end <br/>end <br/><br/>defmodule MyAppWeb.UserController do <br/>  use MyAppWeb, :controller <br/>end</span></pre><p id="861c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从代码重用的角度来看，元编程让我们完成与继承相同的事情——以及不完全符合继承模型的其他形式的代码重用。注意，这个例子不仅导入了一些功能，它还调用了<em class="lr">的另一个</em>用途。</p><p id="7f43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是宏远远超出了简单的代码重用:除了使用<em class="lr">注入代码之外，</em>宏还可以用来构造控制结构或者<a class="ae lq" href="https://en.wikipedia.org/wiki/Domain-specific_language" rel="noopener ugc nofollow" target="_blank">特定领域语言</a>API(DSL)。这里有一个来自流行的<a class="ae lq" href="https://hexdocs.pm/ecto/Ecto.html" rel="noopener ugc nofollow" target="_blank"> Ecto数据库映射器库</a>的API示例:</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="2da0" class="lx ly it lt b be lz ma l mg mc">import Ecto.Query, only: [from: 2] query = from u in "users", where: u.age &gt; 18, select: u.name Repo.all(query</span></pre><p id="7f48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Ecto为<code class="fe md me mf lt b">from</code>使用了一个宏定义，而不是一个函数，这样API用户就可以编写类似<code class="fe md me mf lt b">u.age &gt; 18</code>的表达式，这些表达式可以被转换成数据库查询，而不是被直接求值。</p><p id="176f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在函数调用中，表达式照常计算，函数接收<em class="lr">值。</em></p><p id="87bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在宏中，表达式以代码的形式提供<em class="lr">，可以根据宏作者的选择进行读取、操作或执行。在这种情况下，表达式被转换成SQL数据库查询片段，而不是在Elixir中执行。</em></p><p id="69c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更深入地了解这一点，让我们来看一个来自<a class="ae lq" href="https://elixir-lang.org/getting-started/meta/macros.html" rel="noopener ugc nofollow" target="_blank">酏剂文档</a>的例子。</p><p id="6ae8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的例子中，一个宏被用来生成一个名为<code class="fe md me mf lt b">Unless</code>的新控制结构。</p><p id="dfd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该示例显示了一个使用函数的实现和一个使用宏的实现，以说明不同之处:</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="abef" class="lx ly it lt b be lz ma l mb mc">defmodule Unless do <br/>  def fun_unless(clause, do: expression) do <br/>    if(!clause, do: expression) <br/>  end <br/><br/>  defmacro macro_unless(clause, do: expression) do <br/>    quote do <br/>      if(!unquote(clause), do: unquote(expression)) <br/>    end <br/>  end  <br/>end</span></pre><p id="2632" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在函数示例中，<code class="fe md me mf lt b">expression</code>作为正常程序执行的一部分被立即评估。但是通过使用<em class="lr">宏，</em>表达式被注入到一个控制结构中，并且只有当<code class="fe md me mf lt b">clause</code>为假时才被执行——这是我们期望从一个流控制结构中得到的行为！</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="d841" class="lx ly it lt b be lz ma l mg mc">iex&gt; require Unless <br/>iex&gt; Unless.macro_unless true, do: IO.puts "this should never be printed" <br/>nil <br/>iex&gt; Unless.fun_unless true, do: IO.puts "this should never be printed" <br/>"this should never be printed" <br/>nil</span></pre><p id="2721" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe md me mf lt b">Unless</code>宏使用了一个<code class="fe md me mf lt b">quote do ... end</code>块，就像我们之前的例子一样，但是也使用了<code class="fe md me mf lt b">unquote</code>将传入的表达式注入到引用的代码块中。</p><p id="8e21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然元编程非常强大，但它也是“危险的”,因为它可以修改预期的代码行为，如果使用不当，会使代码非常难以理解。正如酏剂文献所述:</p><blockquote class="mh mi mj"><p id="06f9" class="ku kv lr kw b kx ky ju kz la lb jx lc mk le lf lg ml li lj lk mm lm ln lo lp im bi translated"><em class="it">宏只能作为最后的手段使用。记住</em> <strong class="kw iu"> <em class="it">显性比隐性</em> </strong> <em class="it">。</em> <strong class="kw iu"> <em class="it">清晰的代码胜过简洁的代码</em> </strong></p></blockquote><p id="09f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编写宏对于日常的Elixir开发来说有些不常见，除了一些常见的和已经建立的用例，比如上面的<code class="fe md me mf lt b">__using__</code>例子。</p><h2 id="d9bb" class="mn ly it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated">为面向对象的样式继承构建宏</h2><p id="e17d" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现在我们已经看到了如何在Elixir中使用宏来扩展模块行为，让我们回到最初的问题:我们可以使用Elixir宏来实现OO风格的继承吗？我们可以，但是需要一个更复杂的宏！</p><p id="0794" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们陈述我们的继承宏的目标:</p><ul class=""><li id="4415" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">我们希望实现一个“继承”宏，它将接受一个父模块，并将父模块中的所有函数注入到当前模块中。</li><li id="4621" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">它应该与多级继承一起工作，这样如果C从B继承，B从A继承，那么C也应该能够调用A函数。</li><li id="6e88" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">像大多数面向对象语言一样，函数应该是可重写的:我们应该允许继承的函数被重写和重新实现</li><li id="2c8d" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">最后，我们应该支持多重继承:从单独的基类继承并从两者获得函数的能力。</li></ul><p id="ecb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们正确地实现了inherit宏，我们应该能够编写如下代码:</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="0201" class="lx ly it lt b be lz ma l mb mc">defmodule Base do <br/>  def f1(a), do: a * 1 <br/>  def f2(a), do: a * 2 <br/>end <br/><br/>defmodule Base2 do <br/>  def f3(a), do: a * 3 <br/>end <br/><br/>defmodule Derived do <br/>  use Inherit, Base <br/>end <br/><br/>defmodule MyModule do <br/>  use Inherit, Derived <br/>  use Inherit, Base2 <br/><br/>  def f2(a), do: a * 10 <br/>end <br/><br/># Call an inherited function <br/>MyModule.f1(a) |&gt; IO.inspect() <br/>&gt; 5 <br/><br/># Call an overridden function <br/>MyModule.f2(a) |&gt; IO.inspect() <br/>&gt; 50 <br/><br/># Call a function inherited with multiple-inheritance <br/>MyModule.f3(5) |&gt; IO.inspect() <br/>&gt; 15</span></pre><p id="a26a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">经过一些尝试和错误来解决下面描述的一些棘手的问题，我能够设计出一个通过所有测试的宏:</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="f00c" class="lx ly it lt b be lz ma l mb mc">defmodule Inherit do <br/>  defmacro __using__(quoted_module) do <br/>    module = Macro.expand(quoted_module, __ENV__) <br/><br/>    module.__info__(:functions) |&gt; Enum.map(fn {name, arity} -&gt; <br/>      # Generate an argument list of length `arity` <br/>      args = arity== 0 &amp;&amp; [] || 1..arity |&gt; Enum.map(&amp;Macro.var(:"arg#{&amp;1}", nil)) <br/><br/>      quote do <br/>        defdelegate unquote(name)(unquote_splicing(args)), to: unquote(module) <br/>        defoverridable [{unquote(name), unquote(arity)}] <br/>      end <br/>    end) <br/>  end <br/>end</span></pre><p id="6b06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这个宏中所做的是</p><ul class=""><li id="30f0" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">用<code class="fe md me mf lt b">defmacro</code>实现一个宏，它接受一个基本模块来继承——注意，我们需要用<a class="ae lq" href="https://hexdocs.pm/elixir/1.12/Macro.html#expand/2" rel="noopener ugc nofollow" target="_blank">宏来获取未引用的模块</a></li><li id="28ba" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">使用<code class="fe md me mf lt b"><a class="ae lq" href="https://hexdocs.pm/elixir/1.12/Module.html#c:__info__/1" rel="noopener ugc nofollow" target="_blank">module.__info__</a>(:functions)</code>遍历模块公开的所有函数</li><li id="8db8" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">使用<code class="fe md me mf lt b"><a class="ae lq" href="https://hexdocs.pm/elixir/1.12/Kernel.html#defdelegate/2" rel="noopener ugc nofollow" target="_blank">defdelegate</a></code>来定义一个指向基本实现的函数——这是最棘手的部分，下面会有更详细的描述。</li><li id="fded" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">如果需要，使用<code class="fe md me mf lt b"><a class="ae lq" href="https://hexdocs.pm/elixir/1.12/Kernel.html#defoverridable/1" rel="noopener ugc nofollow" target="_blank">defoverridable</a></code>允许函数在派生类中被覆盖</li></ul><p id="3212" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上所述，这个宏的棘手部分是构造<code class="fe md me mf lt b">defdelegate</code>调用，特别是用<em class="lr">正确数量的参数</em>生成一个委托定义。</p><p id="9f3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我们需要定义一个有3个参数的方法<code class="fe md me mf lt b">do_stuff</code>，我们需要生成如下代码:</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="565a" class="lx ly it lt b be lz ma l mb mc">defdelegate do_stuff(a1, a2, a3), to: unquote(module)</span></pre><p id="2024" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">构造一个参数变量列表很简单，但是我们如何把它放到函数定义中呢？事实证明，一个简单的<code class="fe md me mf lt b">unquote</code>并不能解决我们这里的问题——它本质上是一个只有一个列表参数的函数定义。相反，我们使用一个名为<code class="fe md me mf lt b"><a class="ae lq" href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#unquote_splicing/1" rel="noopener ugc nofollow" target="_blank">unquote_splicing</a></code>的函数:它取消对列表的引用，就地展开元素。让我们快速看一个简单的<code class="fe md me mf lt b">unquote</code>对<code class="fe md me mf lt b">unquote_splicing</code>的例子:</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="f413" class="lx ly it lt b be lz ma l mb mc">iex(1)&gt; quote do [1, unquote(list), 2] end <br/>[1, [2, 3], 2] <br/>iex(2)&gt; quote do [1, unquote_splicing(list), 2] end <br/>[1, 2, 3, 2]</span></pre><p id="0fe4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这个扩展参数的技巧，我们实现函数定义块如下:</p><pre class="kj kk kl km gt ls lt lu bn lv lw bi"><span id="d5b8" class="lx ly it lt b be lz ma l mb mc">quote do <br/>  defdelegate unquote(name)(unquote_splicing(args)), to: unquote(module) <br/>  defoverridable [{unquote(name), unquote(arity)}] <br/>end</span></pre><p id="fe4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧啊。只用几行代码，我们就在Elixir中实现了OO风格的继承。</p><h1 id="16f3" class="ny ly it bd mo nz oa ob mr oc od oe mu jz of ka mx kc og kd na kf oh kg nd oi bi translated">结论:说真的，不要这样做</h1><p id="202a" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">在Elixir中实现面向对象的风格继承是学习更多关于宏系统的一个很好的小练习，但是在Elixir应用程序中使用它可能不是一个好主意。虽然继承在其他语言中是一种常见的工具，但它不是一种常见的灵丹妙药习语，如果在灵丹妙药代码库中使用，很可能会引起混淆(甚至是理所当然的嘲笑)。</p><p id="5d93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说，宏系统的强大之处在于，我们<em class="lr">可以在必要时</em>实现这些种类的专门结构。虽然我无法想象在日常应用程序开发中使用这样的宏，但是像这样的功能肯定可以用于专门的库或DSL，类似于Ecto对宏的专门使用。</p><p id="c77a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要了解更多关于Elixir中的元编程，我推荐书<a class="ae lq" href="https://amzn.to/3VFsY8R" rel="noopener ugc nofollow" target="_blank">元编程Elixir:编写更少的代码，完成更多的工作(并从中获得乐趣！)</a>作者Phoenix Framework作者Chris McCord。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="2d44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr">原载于</em><a class="ae lq" href="https://blixtdev.com/dont-do-this-object-oriented-inheritance-in-elixir-with-macros/" rel="noopener ugc nofollow" target="_blank"><em class="lr">https://blixtdev.com</em></a></p></div></div>    
</body>
</html>