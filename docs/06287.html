<html>
<head>
<title>Why and How to Lazy Load Components in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么以及如何在Angular中延迟加载组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-and-how-to-lazy-load-components-in-angular-b4aff3797c6d?source=collection_archive---------5-----------------------#2020-09-17">https://betterprogramming.pub/why-and-how-to-lazy-load-components-in-angular-b4aff3797c6d?source=collection_archive---------5-----------------------#2020-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7945" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建一个可重用的Angular accordion组件并延迟加载其内容</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/363c4773653f81542cd6b9e6a24718ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJZvHF0fpvkiqx9sxeEOIw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><blockquote class="kv"><p id="550d" class="kw kx iq bd ky kz la lb lc ld le lf dk translated"><em class="lg">“在软件可以重用之前，它首先必须是可用的。”</em></p><p id="f17d" class="kw kx iq bd ky kz lh li lj lk ll lf dk translated"><em class="lg"> —拉尔夫·约翰逊</em></p></blockquote><p id="7c19" class="pw-post-body-paragraph lm ln iq lo b lp lq jr lr ls lt ju lu lv lw lx ly lz ma mb mc md me mf mg lf ij bi translated"><em class="mh"/>根据定义，延迟加载是一种按需加载的技术。</p><p id="5fb6" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">惰性加载可以应用于应用程序开发过程的不同层次，从模块到组件。模块级的延迟加载在Angular世界中非常有名，但是组件级的延迟加载却很少被提及。在本文中，我们将创建一个accordion组件并延迟加载内容。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="a624" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">为什么要使用Lazyload组件？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/162cc8b6b247ec590f41001f9b167551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZOqfwMugEqpsCUwL"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">戴夫·威尔海特在<a class="ae nn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3b4f" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">所以你已经发布了你的生产就绪的角度应用！</p><p id="421f" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">您确保在编写代码、重用组件、lazyloading模块等等时使用最佳实践。经过几周的实际使用，用户已经开始抱怨应用程序的性能，特别是一些页面的初始加载时间。由于这个原因，你开始失去用户，并且统计数据持续下降。</p><p id="d34b" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">您进行了一轮分析，发现有一个组件正在进行多个API调用，而这些调用对于最初的用户体验来说是不必要的(或不太重要的)。它可以是调式的，手风琴式的，甚至是滑块式的。这个特殊的API调用降低了应用程序的速度，并使用户体验变得迟缓。</p><p id="5103" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">这里更好的方法(以accordion为例)显然是只有当用户打开特定的accordion时才在accordion中加载内容。</p><p id="2b80" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">以上是实现延迟加载的完美用例。</p><p id="3086" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">我们开始吧。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="7abd" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">最初的版本</h1><p id="bb30" class="pw-post-body-paragraph lm ln iq lo b lp no jr lr ls np ju lu lv nq lx ly lz nr mb mc md ns mf mg lf ij bi translated">为了实用起见，让我们假设一个应用程序场景，其中我们有一个博客文章列表，我们希望在一个手风琴下面显示。</p><p id="455f" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">在我们重构和实现延迟加载之前，下面是我们的典型应用程序设置。</p><p id="8fbc" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">我们有两个组件:</p><ol class=""><li id="3a9f" class="nt nu iq lo b lp mi ls mj lv nv lz nw md nx lf ny nz oa ob bi translated">博客帖子的帖子组件加载数据)</li><li id="5e05" class="nt nu iq lo b lp oc ls od lv oe lz of md og lf ny nz oa ob bi translated">手风琴部件</li></ol><p id="146d" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">我们使用这两个组件在我们的<code class="fe oh oi oj ok b">app-component</code>中向用户呈现博客文章。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="49bc" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">我们使用了<code class="fe oh oi oj ok b">app-accordion</code>组件，并将<code class="fe oh oi oj ok b">app-post</code>组件传递给它进行内容投影。</p><p id="1218" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">对于手风琴的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="654f" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">在我们的<code class="fe oh oi oj ok b">post</code>组件中，我们对<code class="fe oh oi oj ok b"><a class="ae nn" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank">jsonplaceholder</a></code>进行HTTP调用，获取一个假的博客帖子，并将其显示在模板上。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e4e6" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">这将导致如下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/cd6f357fb12f5a3c5c792423a5a11d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*A_bgU-kIUaONQqbWej1hXA.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">惰性加载前的初始应用</p></figure><p id="a052" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">正如您可以清楚地看到的，数据现在是在页面的初始加载时加载的，这在某些情况下并不理想，比如我们上面讨论的情况。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="1483" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">实现延迟加载</h1><p id="6e10" class="pw-post-body-paragraph lm ln iq lo b lp no jr lr ls np ju lu lv nq lx ly lz nr mb mc md ns mf mg lf ij bi translated">这是我们让内容延迟加载的计划。</p><p id="a1de" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">我们将使用@angular/core中的<code class="fe oh oi oj ok b">@<a class="ae nn" href="https://angular.io/api/core/ContentChild" rel="noopener ugc nofollow" target="_blank">ContentChild</a></code>来抓取accordion主体，使用的是<code class="fe oh oi oj ok b">&lt;ng-template&gt;</code>上的指令语法(我们正在替换早期版本中的内容投影技术)。我们使用<code class="fe oh oi oj ok b">&lt;ng-template&gt;</code>而不是<code class="fe oh oi oj ok b">&lt;div&gt;</code>是因为它的特殊性质，我们可以利用它。</p><p id="74da" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">来自<a class="ae nn" href="https://angular.io/guide/structural-directives#the-ng-template" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="oo op oq"><p id="dfa4" class="lm ln mh lo b lp mi jr lr ls mj ju lu or mk lx ly os ml mb mc ot mm mf mg lf ij bi translated">“<code class="fe oh oi oj ok b">&lt;ng-template&gt;</code>是一个用于呈现HTML的有角元素。它从不直接显示。事实上，在渲染视图之前，Angular <em class="iq">用一个注释替换了<code class="fe oh oi oj ok b">&lt;ng-template&gt;</code>和它的内容</em>。<br/>如果没有结构指令，你只是将一些元素包装在一个<code class="fe oh oi oj ok b">&lt;ng-template&gt;</code>中，这些元素就会消失。</p></blockquote><p id="0fc6" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">首先，让我们为accordion主体创建一个新的指令。</p><pre class="kg kh ki kj gt ou ok ov ow aw ox bi"><span id="36ca" class="oy mv iq ok b gy oz pa l pb pc">ng generate directive accordion</span></pre><p id="ae66" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">让我们将选择器重命名为<code class="fe oh oi oj ok b">[accordion-body]</code>。该指令的目的是仅作为我们的<code class="fe oh oi oj ok b">&lt;ng-template&gt;</code>的选择器，它支撑着我们的手风琴身体。我们对该指令所做的唯一更改是将其重命名。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="6166" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">现在让我们将<code class="fe oh oi oj ok b">[accordion-body]</code>指令添加到我们的<code class="fe oh oi oj ok b">app-component</code>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="fc3b" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">如果您现在导航到我们的应用程序，您将看到<code class="fe oh oi oj ok b">app-post</code>组件根本没有显示——因此，我们的API也没有被触发。</p><p id="c47f" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">太好了！</p><p id="7cd1" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">现在剩下的唯一部分是重构<code class="fe oh oi oj ok b">app-accordion</code>组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="cb20" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">我们正在扩展现有的手风琴组件。我们已经使用了<code class="fe oh oi oj ok b">@ContentChild</code>来访问<code class="fe oh oi oj ok b">app-accordion</code>中包含<code class="fe oh oi oj ok b">AccordionDirective</code>(即<code class="fe oh oi oj ok b">[accordion-body]</code>)的第一个子节点。注意，我们使用了<code class="fe oh oi oj ok b">read: TemplateRef</code>，因为我们正在访问一个模板引用。您可以在<a class="ae nn" href="https://angular.io/api/core/ViewChild" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多选项。</p><p id="6170" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">现在我们可以简单地在我们的<code class="fe oh oi oj ok b">app-accordion</code>组件模板中使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7880" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">就这么简单！</p><p id="022a" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">注意<code class="fe oh oi oj ok b">*<a class="ae nn" href="https://angular.io/api/common/NgTemplateOutlet" rel="noopener ugc nofollow" target="_blank">ngTemplateOutlet</a></code> <a class="ae nn" href="https://angular.io/api/common/NgTemplateOutlet" rel="noopener ugc nofollow" target="_blank">、</a>的用法，用于从准备好的<code class="fe oh oi oj ok b"><a class="ae nn" href="https://angular.io/api/core/TemplateRef" rel="noopener ugc nofollow" target="_blank">TemplateRef</a>(accordionBodyRef)</code>中插入一个嵌入视图。</p><p id="e5d0" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">就这些了！现在，您拥有了一个延迟加载的accordion组件和一个加载速度更快的应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/099cfea42438d6ef78e4f6dee03993b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*cEPn3BiPSc5xGgCNEJhfOw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在延迟加载实现之后</p></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="0f4d" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">扩展解决方案以支持快速加载</h1><p id="decf" class="pw-post-body-paragraph lm ln iq lo b lp no jr lr ls np ju lu lv nq lx ly lz nr mb mc md ns mf mg lf ij bi translated">我们的accordion的当前实现只支持延迟加载。您不可能急切地加载(在应用程序内容的初始加载时)当前的实现。但是有时，您可能需要accordion来支持急切地加载内容。在这种情况下，您可能需要创建另一个组件来实现这一点。</p><p id="0c30" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">让我们通过添加延迟加载和急切加载功能，使现有的accordion组件真正可重用。</p><p id="9fd8" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">这可以通过在我们的accordion模板中添加另一个<code class="fe oh oi oj ok b">*ngIf</code>条件来轻松完成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4888" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">我们正在检查<code class="fe oh oi oj ok b">accordionBodyRef</code>模板是否存在。如果是的话，我们就显示组件，内容会延迟加载。如果没有，我们只需使用内容投影选择<code class="fe oh oi oj ok b">accordionBody</code>。</p><p id="fdfc" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">现在在<code class="fe oh oi oj ok b">app-component</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="72c1" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">这就对了。您现在可以使用相同的<code class="fe oh oi oj ok b">app-accordion</code>组件根据需要延迟或急切地呈现内容。</p><p id="9c2e" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">你可以在GitHub 上找到已经完成的项目<a class="ae nn" href="https://github.com/BharathRavi27/lazy-loaded-accordion" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="94c6" class="pw-post-body-paragraph lm ln iq lo b lp mi jr lr ls mj ju lu lv mk lx ly lz ml mb mc md mm mf mg lf ij bi translated">黑客快乐！</p></div></div>    
</body>
</html>