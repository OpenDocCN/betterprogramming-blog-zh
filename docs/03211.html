<html>
<head>
<title>Create Your Own Custom UIRefreshControl in Swift for iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift for iOS中创建您自己的自定义UIRefreshControl</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-your-own-custom-uirefreshcontrol-in-swift-for-ios-78a34f525d9d?source=collection_archive---------12-----------------------#2020-01-28">https://betterprogramming.pub/creating-your-own-custom-uirefreshcontrol-in-swift-for-ios-78a34f525d9d?source=collection_archive---------12-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4382" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的应用的更新功能增添一些活力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0bc5c995fc8ea1c55f9636f2c003e580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCWcFDRNFncwjUP7dzr4ag.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@ravi_roshan_inc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ravi Roshan </a>在<a class="ae ky" href="https://unsplash.com/s/photos/life?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="771c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和其他人一样，当谈到在Swift中使用默认的<code class="fe lv lw lx ly b">UIRefreshControl</code>时，我发现这很无聊。不能定制太多。所以，我想用一些很酷的动画创建一个自定义的<code class="fe lv lw lx ly b">UIRefreshControl</code>(至少比我默认的要好)。</p><p id="6469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在看了很多关于创建自定义<code class="fe lv lw lx ly b">UIRefreshControl</code>的文章后，我做了一个非常容易实现的，这样每个人都能很容易理解。我不想走极端。</p><p id="a98c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果你知道RxSwift和核心显卡的基础知识，我想你实现这个方法不会有任何问题。如果你想得到更酷的动画，你可以用<code class="fe lv lw lx ly b">CGPaths</code>来做得更花哨一些。</p><p id="b7e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它最终的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/b8598815dc51a04e3414a8eb527c45ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*aKTW6NbSyTgClwuTZueZJg.gif"/></div></figure><p id="47bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法来自<a class="ae ky" href="https://medium.com/@topLayoutGuide/so-i-wanted-to-animate-a-uirefreshcontrol-34bd8ff65d8f" rel="noopener">这个帖子</a>。也看看吧。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="94a8" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">我们开始吧</h1><h2 id="cafd" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated">1.创建一个包含所有必需属性的UIView子类</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，我说过我不会走极端，但相信我，所有这些属性都将是有用的。所有的<code class="fe lv lw lx ly b">CGPoints</code>都在评论中有据可查。</p><ul class=""><li id="fa8e" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">shapeLayer</code>我们将在这里绘制刷新控件的主路径，结合所有的点。</li><li id="861d" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">circleLayer</code>是我们画刷新圈的地方。</li><li id="1bc4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">enum RefreshCircleSize</code>将在以后使用，以便我们可以动态提供刷新周期的大小。</li><li id="e30a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">thresholdDrag</code>是用户拖动内容视图或滚动视图触发刷新所需的y偏移量。</li><li id="0553" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">我们不希望我们的刷新控件一直被拖到底部，因此我们使用了<code class="fe lv lw lx ly b">maxHeightOfRefreshControl</code>。</li><li id="4752" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">最后，对于我们根据<code class="fe lv lw lx ly b">Scroll</code>视图上<code class="fe lv lw lx ly b">panGesture</code>的移动来移动中间底部点的动画，我们将在<code class="fe lv lw lx ly b">xPositionOfPan</code> <em class="ob">中存储触摸的x位置。</em></li><li id="64bc" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">而你最后想知道的是，刷新状态为假时，中底点的y偏移略大于<code class="fe lv lw lx ly b">edgeBottom</code>点。即刷新尚未被触发，因此<code class="fe lv lw lx ly b">middleBottomPointYOffset</code>和<code class="fe lv lw lx ly b">edgeBottomPointYOffset</code>。</li></ul><h2 id="74d5" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated">2.是我们使用Rx的时候了</h2><p id="343a" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">覆盖<code class="fe lv lw lx ly b">didMoveToSuperView</code>并将下面的函数粘贴到您的类中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇哦。这是怎么回事？</p><ul class=""><li id="59ba" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">我们正在覆盖<code class="fe lv lw lx ly b">didMoveToSuperView</code>，因为我们将创建这个类的一个实例，并将其添加到滚动视图的<code class="fe lv lw lx ly b">backgroundView</code>中。(这就是我们如何实现我们的刷新控制。)</li><li id="eb26" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">在<code class="fe lv lw lx ly b">addObserver</code>函数中，我们使用<a class="ae ky" href="https://github.com/ReactiveX/RxSwift/tree/master/RxCocoa" rel="noopener ugc nofollow" target="_blank"> RxCocoa </a>来监听滚动视图的y内容偏移量和<code class="fe lv lw lx ly b">scrollView</code>的<code class="fe lv lw lx ly b">panGesture</code>的变化，我们得到的值存储在我们之前声明的属性中。</li><li id="6da3" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当用户在<code class="fe lv lw lx ly b">panGesture</code>之后将手指抬离屏幕时，任何<code class="fe lv lw lx ly b">.cancelled</code>、<code class="fe lv lw lx ly b">.failed</code>、<code class="fe lv lw lx ly b">.ended</code>状态都可能被触发，因此我们切换这些情况，并检查用户是否已经拖动到我们在属性中指定的<code class="fe lv lw lx ly b">thresholdDrag</code>之上。</li><li id="e50a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果它大于阈值，那么我们将制作圆形旋转的动画，将<code class="fe lv lw lx ly b">refreshingStatus</code>设置为<code class="fe lv lw lx ly b">true</code>并调用<code class="fe lv lw lx ly b">onRefreshing</code>函数。</li></ul><h2 id="9913" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated">3.核心图形时间——画线和制作动画</h2><p id="68dc" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">在您的类中添加以下函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道要看的东西很多。但是让我再解释一次。</p><p id="5c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">commonInit</code>里面，我们将一劳永逸地设置<code class="fe lv lw lx ly b">shapeLayer</code>和<code class="fe lv lw lx ly b">circleLayer</code>。我们不需要每次重画都做<code class="fe lv lw lx ly b">layer.addSublayer</code>。因此，不在<code class="fe lv lw lx ly b">draw( _ rect:)</code>中。</p><p id="eb89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内部<code class="fe lv lw lx ly b">draw(_ rect: )</code>:</p><ol class=""><li id="2658" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu oh nt nu nv bi translated">向所有点分配新的CGPoint。</li><li id="bbf9" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oh nt nu nv bi translated">为<code class="fe lv lw lx ly b">shapeLayer</code>绘制路径。</li><li id="7902" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oh nt nu nv bi translated">使用<code class="fe lv lw lx ly b">bezierPath</code>画圆。</li><li id="6bd4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oh nt nu nv bi translated">我们不想要一个完整的圆形，因此它在贝塞尔路径参数中。</li></ol><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="f59c" class="mz mi it ly b gy om on l oo op">startAngle: getStartAngle(draggedFractionCompleted), endAngle: getStartAngle(draggedFractionCompleted + 0.85)</span></pre><p id="5abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只画圆周的0.85部分，改变<code class="fe lv lw lx ly b">startAngle</code>开始根据<code class="fe lv lw lx ly b">draggedFractionComplete</code>画圆。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e64a" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">有用的东西，如果你喜欢使用核心图形旋转的东西</h1><p id="f5e2" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">你想知道为什么我们提供一个高度和宽度为零，原点在圆心的框架吗？</p><p id="535e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为默认情况下围绕z轴设置层动画会围绕其锚点旋转该层的整个帧。</p><p id="a9a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，设置圆圈层的框架的原点为圆心，高度和宽度为零(基本上是一个大头针点，然后应用绕z轴旋转将按照所需的方式旋转我们的圆圈。如果你被困在这些旋转的东西里，你想要使用的那种黑客。</p><p id="d024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe lv lw lx ly b">animateRefreshCircle</code>函数被用来使我们的刷新圈一圈又一圈地活动起来。</p><p id="a828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:不要忘记在你的初始化器中调用<code class="fe lv lw lx ly b">commonInit</code>函数。</p><h2 id="23e1" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated">4.终于，它要结束了</h2><p id="6255" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">将此函数粘贴到您的类中。在完成了触发刷新时启动的任务之后，您可以调用这个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以根据需要调整该功能，使动画中的<code class="fe lv lw lx ly b">shapeLayer</code>和<code class="fe lv lw lx ly b">circleLayer</code>消失，并将滚动视图中的<code class="fe lv lw lx ly b">contentInset.top</code>重置为0。</p><p id="a34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在哪里设置内容插页？</p><p id="a2b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">calculate</code>功能内部。</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="858a" class="mz mi it ly b gy om on l oo op">containerScrollView?.contentInset.top = middleBottomPointYOffset</span></pre><p id="6122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？</p><p id="d0e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以便当刷新被触发时<code class="fe lv lw lx ly b">refreshControl</code>停留在滚动视图的顶部。</p><p id="84be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，结束…</p><p id="5256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是完整的代码组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="afed" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated"><strong class="ak"> 5。现在为了使用这个类</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">触发刷新时调用函数。</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="751b" class="mz mi it ly b gy om on l oo op">refreshControl.setOnRefreshing = {[<strong class="ly iu">weak</strong> <strong class="ly iu">self</strong>] <strong class="ly iu">in</strong></span><span id="c58a" class="mz mi it ly b gy oq on l oo op">//call your function here</span><span id="e231" class="mz mi it ly b gy oq on l oo op">//and don’ forget to call “<strong class="ly iu"><em class="ob">refreshControl.endRefreshing()” </em></strong>at end of that task you perform inside that function</span><span id="ca0f" class="mz mi it ly b gy oq on l oo op">}</span></pre><p id="2015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！</p><p id="1e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你一直跟到最后。这是我在媒体上的第一篇文章。评论和补充将不胜感激。谢谢大家！</p></div></div>    
</body>
</html>