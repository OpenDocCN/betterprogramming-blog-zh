# Python 中的指针、字符串和(不)可变性

> 原文：<https://betterprogramming.pub/pointers-strings-and-im-mutability-680b15dd4a70>

## Python 中不可思议的功能的故事

![](img/11b696120ac6ca7588d003087a84c16e.png)

来自 [Unsplash](https://unsplash.com/photos/vpOeXr5wmR4)

我最近有一次有趣的经历，结果证明这是对 Python 中对象可变性的一次很好的教育，尤其是字符串。这种经历是由于搞砸了两个 Python 脑筋急转弯，对语言功能中看似矛盾的地方感到恼火，然后掉进了一个迷人的兔子洞。

第一个[脑筋急转弯](https://twitter.com/driscollis/status/1529014651186454528/)，由 [Mike Driscoll](https://twitter.com/driscollis) 在 Twitter 上提供:

```
i = j = [3]i += jprint(i, j)
```

> 程序会输出什么？

这看起来很简单。变量和`i`和`j`都被赋值指向一个包含数字`3`的列表。接下来，通过将变量`j`添加到变量`i`中，对变量`i`进行适当的修改。

对于列表，Python 中的加法运算符将第二个列表的新内容追加到第一个列表的内容上，所以现在是`i == [3, 3]`，而`j`因为没有被修改所以还是`[3]`，所以打印`i`、`j`应该打印`i` ( `[3, 3]`)和`j` ( `[3]`)。因此，最终答案应该是`[3, 3], [3]`。

熟悉 Python 如何实现变量作为指针的人会认识到我的错误。`i`和`j`都指向内存中的同一个对象，所以即使`i`是唯一被显式修改的对象，当内存中的对象改变时，`j`的值也会改变。因此，正确答案是`[3, 3], [3, 3]`。

好吧，吸取教训。因此，当另一个看起来非常相似的[脑筋急转弯](https://twitter.com/driscollis/status/1530112710146416641)出现在我的新闻供稿中时(再次感谢迈克·德里斯科尔)，我想我会做对的。

```
x = y = “Python”x += “rocks!”print(x, y)
```

> 程序会输出什么？'''

看起来和前面的问题几乎一样，对吗？Python 将字符串实现为类似列表的对象，因此添加两个字符串只是将第二个字符串附加到第一个字符串的末尾。于是，`x`应该变成了`“Pythonrocks!”`。而且，正如我从之前的脑筋急转弯中了解到的，既然`x`和`y`在内存中指向同一个对象，`y`也应该变异成`“Pythonrocks!”`对吧？

不对！任何 Python 爱好者都会告诉你 Python 字符串是“不可变的”，这意味着它们不能被直接修改。相反，当您试图修改一个字符串时，Python 会根据您想要应用于原始对象的变化，在内存中创建一个新对象。因此，当`x`变成`“Pythonrocks!”`时，`y`仍然是`“Python”`，所以并排打印它们会得到`“Pythonrocks!”, “Python”`。

好吧。烦人，但够直白。然而，在我对 Python 中字符串可变性的研究中，我发现了另一个例子(为了可读性做了修改，这次来自 [Austin Henley](https://twitter.com/austinzhenley) ),它似乎与我刚刚学到的相矛盾:

```
a = “Hello”id(a)140214243255728a += “!”id(a)
```

现在，由于我们刚刚试图改变一个不可变的字符串，内存中应该有一个新的对象在内存中的新位置编码`“Hello!”`。因此，调用变量`a`的`id`应该打印一个与我们之前看到的不同的内存地址，对吗？

又错了！这个真的让我大吃一惊。我已经在努力处理字符串的不变性了，所以现在知道它们显然是可变的让我对计算的确定性失去了信心。这个例子和前一个例子怎么可能都是真的呢？字符串怎么可能前一分钟是不可变的，后一分钟又是可变的呢？

非常关注细节或者特别精通 Python 的读者可能会注意到第二个例子和第三个例子之间的区别。在第二个例子中，两个变量指向内存中的同一个对象，而在第三个例子中，只有一个变量指向该对象。为什么重要？有什么区别？因为，正如奥斯汀·亨利解释的那样，“CPython 很聪明。如果没有其他对字符串的引用，那么它将尝试改变字符串，而不是分配一个新的”(强调我的)。在脑筋急转弯二的情况下，`x`和`y`都指向内存中的同一个对象，因此，不变性得以保留。

确实聪明。或者只是极度沮丧。因为，正如亨利继续指出的那样，即使这种解释也有点过于简单化。如果原始字符串上的突变变得太大，CPython 有时会调整缓冲区的大小，在内存中创建一个新的对象，从而保留“不变性”的映像。当他运行基准测试时，他发现调整缓冲区大小会导致内存中的地址在 10，000 次中改变 46 次。

我的朋友争辩说，即使我们忽略缓冲区大小调整的情况，这难道不是危险的行为吗？对于程序员来说，跟踪两个变量是否都指向同一个对象似乎是不必要的精神负担。

经过进一步思考，我们意识到，尽管奇怪，这种行为实际上并不危险。毕竟，程序员可以避免假设一个变异的对象会在内存中保留它的地址。如果两个或两个以上的变量指向同一个对象，那么这种变异肯定会为被修改的变量所指向的对象产生一个新的地址。如果未知数量的变量指向同一个对象，您可以假设它将在内存中获得一个新地址，但是如果这个“新地址”恰好与旧地址相同，那就不是问题。

总的来说，这是一种令人头疼的困难方式，难以将 Python 中的指针处理和可变性深入灌输到我的头脑中。希望它能坚持下去。