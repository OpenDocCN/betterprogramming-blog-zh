<html>
<head>
<title>Build UITableView Sections With Nested Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用嵌套类型生成UITableView节</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/uitableview-sections-with-nested-types-27eabb833ad9?source=collection_archive---------5-----------------------#2022-01-05">https://betterprogramming.pub/uitableview-sections-with-nested-types-27eabb833ad9?source=collection_archive---------5-----------------------#2022-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc94" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习使用嵌套对象编写包含不同部分的动态UITableview</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/381b3e10a59e8c7da7b7187443752e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYr4ezEknVzbRTnZUsryKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://undraw.co/search" rel="noopener ugc nofollow" target="_blank">未绘制</a></p></figure><p id="3ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" href="https://medium.com/@alessandromanilii/nested-object-in-swift-4cda290bfa18" rel="noopener">上一篇文章</a>中，我已经向您展示了Swift中的嵌套类型，并向您暗示了它们的威力。在今天的文章中，我将向您展示这种技术的一个实际例子，用多个部分编码一个<code class="fe lv lw lx ly b">UITableView</code>。</p><p id="b75c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我打算写一个假的哈利波特维基，向用户展示一些关于人物、地点和霍格沃茨班级的基本信息。因此，我们的列表将由三个部分组成，每个部分包含一个项目列表。</p><p id="c099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是最终结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/d7033babb260eac9a66311d917febd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T79oLMZdbWkHneBMJBrGjQ.png"/></div></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="1e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个非常简单的方法是创建三个对象，每个对象都有一个数组。</p><p id="32ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当实现<code class="fe lv lw lx ly b">UITableViewDataSource</code>的核心函数时，你需要计算<code class="fe lv lw lx ly b">IndexPath</code>的索引，编码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法有一个很大的缺点。如果您决定更改这些部分的顺序，会发生什么情况？</p><p id="efec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您将被迫更改所有代码，从而几乎不可能创建一个动态表，比如一个可以由后端驱动的表。</p><p id="6ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更聪明的解决方案是使用枚举来描述所有可能的部分。更好的是，我们可以在案例中使用相关的值。但是枚举中的关联值是什么呢？Swift官方文档称:</p><blockquote class="mj mk ml"><p id="8009" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">…将其他类型的值与这些事例值一起存储有时会很有用。这个额外的信息被称为一个<em class="it">关联值</em>，并且它会随着您每次在代码中使用那个case作为值而变化。</p><p id="e0c3" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">您可以定义Swift枚举来存储任何给定类型的关联值，如果需要，对于枚举的每种情况，值类型可以不同。类似的枚举在其他编程语言中被称为<em class="it">区分联合</em>、<em class="it">标记联合</em>或<em class="it">变体</em>。</p></blockquote><p id="7053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，你可以添加任何类型的对象到一个枚举案例中……这在<code class="fe lv lw lx ly b">TableView</code>部分非常有用。让我们看看如何创建一个<code class="fe lv lw lx ly b">Section</code>枚举:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我已经创建了一个枚举，将我们的部分作为案例。</p><p id="f5d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个事例都有一个关联值，该值是该部分中对象的数组。</p><p id="87bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还为部分本身的标题添加了一个计算变量。对于这种事情，我通常更喜欢添加一个计算过的var，而不是添加一个原始值。只是更清楚了。</p><p id="57c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到enum是类<code class="fe lv lw lx ly b">ViewController</code>的嵌套类型。我这样编码是因为这些部分只属于这个类。我们不会在应用程序的其他控制器中使用它们——所以嵌套类型更好地代表了这种关系。</p><p id="bdcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完美。</p><p id="bce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步是为我们的<code class="fe lv lw lx ly b">UITableView</code>创建数据源。</p><p id="3ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这个东西，我们将使用一个<code class="fe lv lw lx ly b">Section</code>数组！是的，枚举数组。</p><p id="12d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个能够做到这一点的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe lv lw lx ly b">characters</code>、<code class="fe lv lw lx ly b">locations</code>和<code class="fe lv lw lx ly b">courses</code>是之前创建的数组。它们也可以从服务器获取…但是为了简单起见，我在代码中把它们删除了:</p><pre class="kj kk kl km gt mq ly mr ms aw mt bi"><span id="6e74" class="mu mv it ly b gy mw mx l my mz">privare var characters = Character.exampleList</span></pre><p id="1b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中我们的<code class="fe lv lw lx ly b">Character</code>是如下结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在结构中看到的，出于同样的原因，我使用了嵌套类型。</p><p id="5156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，有了我们的区段数组，是时候实现<code class="fe lv lw lx ly b">UITableViewDataSource</code>函数了，我们将看到，有了enum，一切都将变得超级干净和超级清晰:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="6cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们来逐一分析方法。</p><ul class=""><li id="bb81" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">函数<code class="fe lv lw lx ly b">numberOfSections</code>简单地返回数组的大小。如果我们添加或删除列表中的项目，这些部分将总是同步的。超级爽！</li><li id="a9a0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">函数<code class="fe lv lw lx ly b">numberOfRowsInSection</code>有一个用于枚举的开关，覆盖所有情况，并简单地返回相关数组的计数。正如您所看到的，即使在这里您修改了部分的数量或顺序，您也不需要做任何更改。</li><li id="4efd" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">类似的方法在函数<code class="fe lv lw lx ly b">cellForRowAt</code>中完成。开关盒覆盖所有盒并创建单元。请注意<code class="fe lv lw lx ly b">cellIdentifier</code>…我们稍后回来。</li><li id="721c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">最后一个方法，<code class="fe lv lw lx ly b">titleForHeaderInSection</code>使用枚举的计算var创建部分的标题。</li></ul><p id="1acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超级简单！</p><p id="1706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们所有的部分都是动态的，我们可以简单地在函数<code class="fe lv lw lx ly b">createDatasource</code>中改变它们，而不需要在其他地方修改代码！这真是太棒了！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="b5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前我让你注意到了单元格标识符…你知道它是一个常量字符串，所以我们也可以使用嵌套类型，创建一个这样的结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="17b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这种结构，我们将把所有的常量字符串放在一个地方，维护整个代码将会容易得多。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="fbfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述技术允许我们为整个数据源建立动态逻辑。</p><p id="5da5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们的用户应该被允许查看或不查看某个部分。也许后端可以排除这种情况。或者用户需要特殊权限。</p><p id="f4ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过对<code class="fe lv lw lx ly b">createDatasource</code>函数的简单修改，我们可以创建这个逻辑。让我们重写我们的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样搞定了！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="8867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我可以向您展示完整的控制器类代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="559b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。编码愉快，感谢阅读。</p></div></div>    
</body>
</html>