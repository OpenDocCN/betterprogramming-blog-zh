# 用依赖注入、存储库模式、React 和 TypeScript 来消除您的顾虑

> 原文：<https://betterprogramming.pub/decoupling-your-concerns-with-dependency-injection-the-repository-pattern-react-and-typescript-6b455788a374>

## 构建松散耦合的可伸缩应用程序

![](img/2cd5389e98fae53a54bf65dc4175097f.png)

Igor bispo 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

你有没有被固化的应用程序逻辑所困扰？当供应商发生变化时，必须重写整个组件或项目？希望您的前端代码不依赖于特定的数据实现？被文章开头无情的问题所困扰？

在这篇文章中，我将通过一个例子来说明如何构建能够伸缩并适应未来变化的松耦合应用程序。我们将使用 Typescript 实现一种称为存储库模式的技术设计模式，并使用依赖注入来构建一个与实现无关的 React 前端。

让我们从谈论存储库开始。

> 存储库是封装了访问数据源所需的逻辑的类或组件。

您可以将他们视为您的数据存储和前端之间的中间人。它们是数据操作的表示，充当前端和数据存储之间的契约。通常每个应用程序实体都有一个存储库*，并定义一组公共方法及其约定的返回值。这提供了与数据存储交互的通用接口，而无需指定任何关于*如何与该数据存储交互的具体信息。**

我们可以使用依赖注入工具将我们创建的存储库注入到我们的前端代码中。

> 在[软件工程](https://en.wikipedia.org/wiki/Software_engineering)中，依赖注入是一种技术，其中一个对象(或静态方法)提供另一个对象的依赖。依赖是可以使用的对象(一个[服务](https://en.wikipedia.org/wiki/Service_(systems_architecture)))。

用例子更容易理解依赖注入。

想象💭您有一个 React 组件，它从一些 API 获取一些数据。您进行调用，然后如果调用成功，您解析它并将其存储在 React 状态中。您取出需要在前端显示的相关部分，也许您将整个嵌套对象传递给其他 React 组件，让它们在内部处理数据。

现在想象一下💭您需要调用一个完全不同的 API(假设您工作的公司更换了提供商，他们现在将这些信息存储在不同的数据存储中)，并且数据结构已经完全改变。当你的前端向内破裂时，你对着所有的`TypeErrors`流泪。你谷歌一下怎么写辞职信。

现在想象(这是我最后一次保证)你的前端完全不知道这个逻辑。

你同意需要打电话，但你不关心打给谁。

您同意您正在处理的实体的结构，并使用依赖注入来注入一个通用的*库*，该库公开了一个通用的 *getter。*

看不到具体的逻辑，这意味着当某些东西必须改变时，我们只需要编写另一个遵循相同规则的具体服务，并且前端已经构建好可以处理。

你合上谷歌标签，松了一口气。

让我们深入一些代码，看看它在一个实际的例子中是如何工作的。

假设我们有一个面向用户的应用程序，我们需要构建一个用户登录后将会看到的个人资料页面。我们还假设我们关注一个实体，一个`User`，我们需要显示他们的全名、性别和出生日期(为了简单起见，这些都是可用的)。

对于一个数据存储，我们将假设我们有一个用户服务，我们可以通过查询来获取用户 ID。我将使用[这个](https://randomuser.me/)免费的 API 作为我们的第一个虚拟的具体用户服务，然后演示我们如何简单地将其转换为第二个。

我已经用 TypeScript 建立了一个 [create react app 项目，安装了`inversify`和`reflect-metadata`，并在我的 tsconfig 中启用了实验装饰器和装饰器元数据属性:](https://create-react-app.dev/docs/adding-typescript/)

```
{
"compilerOptions": {
  ...,
  "lib": ["dom", "dom.iterable", "es6", "esnext"],
  "types": ["reflect-metadata", "node"],
  "experimentalDecorators": true,
  "emitDecoratorMetadata": true
},
...
}
```

首先要做的是定义一些类型。我们知道我们需要用户提供什么数据，因此我们定义:

现在让我们定义一个非常简单的带有 get by id 的存储库泛型:

请注意，这个存储库与我们的实体`User`没有任何联系——这就是泛型的美妙之处！当实现并传递了`User`类型时，它将绘制出一个数据访问模式，看起来有点像:

如果我们在应用程序中需要另一个实体类型，比如订单，我们可以这样定义另一个实现:

```
interface OrderRepository implements IRepository<Order> {
  get(id: string): Promise<Order | null>;
}
```

现在我们有了一个跨所有实体的通用的、一致同意的数据访问模式，我们可以围绕它而不是围绕任何具体的东西来构建前端。在我们开始构建存储库之前，我们还需要一种类型来帮助我们——一种表示数据存储中数据形状的类型。

回到我们从`randomuser.me`开始的模拟 API，我们可以概括如下:

请注意，这是一个不同于我们之前定义的`User`类型的形状，这完全没问题，因为我们将构建一个简单的*解析器*，它将数据从具体的形状映射到所需的形状。

现在我们已经设计好了我们的类型，我们可以实现`IRepository`泛型并构建一个具体的用户服务！

存储库公开了一个 get 方法，该方法对我们的 API 进行简单的获取，如果成功，解析数据，将其映射到我们期望的`User`类型。

在真实的应用程序中，这将包含我们所有的其他数据访问方法！我们已经用 inversify 的 decorator 标记了我们的存储库，这允许我们立刻将我们的存储库注入到前端！

我们首先还需要一样东西:我们的存储库的唯一标识符:

InversifyJS 支持将符号作为服务标识符——这有助于避免命名冲突，因为符号是唯一且不可变的。

我们现在可以用 inversify 设置控制容器的反转了！

拆开上面的；我们首先实例化一个从 inversify 导入的新容器。然后，我们将唯一的服务密钥绑定到我们的具体实现。因为我们想定义这个服务的实例，所以我们使用了`inSingletonScope`方法(如果没有这个方法，每次请求这个依赖项时都会创建一个新的服务)。

好了，现在我们有了一个可以使用的容器，让我们制作一个简单的 react 应用程序。我们将呈现一个按钮，上面写着 *GET USER* ，当点击该按钮时，就会向 API 发出请求，并将其显示在屏幕上。

![](img/4cdfff8713d6d55c25c4a6e7851977af.png)

我保证我实际上是一个专业的前端开发

根据之前的文档，我们需要将 reflect-metadata polyfill 导入到我们的`index.tsx`文件中，以便使用 inversify。然后我们有了一个类似这样的应用程序:

我们现在可以导入我们的容器并使用我们之前构建的存储库:

我们使用我们的服务标识符向我们的容器请求*一个*用户存储库，但是我们的应用程序不需要知道具体的实现，这些都是在容器级别注入的。一旦我们获得了我们的服务，我们知道每个存储库都公开了一个异步的 get 方法，我们可以用它从 API 中拉出一个用户！这种设计使得定义业务逻辑不可知的前端成为可能——很酷吧？

为了演示我们适应变化有多容易，让我们将具体的实现换成另一个，并将我们的假数据存储转移到不同的提供商[https://random-data-api.com](https://random-data-api.com/)。

我们首先来看看新数据存储中实体的形状:

并定义一个新的解析器:

我们现在可以实现 IRepository 并创建一个新的具体服务，如下所示:

现在转向我们的容器，我们可以注入这个实现:

而前端却一无所知！

有希望的是，依赖注入和存储库模式的有用性已经变得清晰——它可以帮助消除任何未来的麻烦，并且通常使您的前端应用程序更容易维护和响应变化。

感谢阅读！