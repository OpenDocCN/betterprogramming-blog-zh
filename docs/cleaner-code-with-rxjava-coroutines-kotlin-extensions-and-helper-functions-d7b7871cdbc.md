# 带有 RxJava、协同程序 Kotlin 扩展和帮助函数的更简洁的代码

> 原文：<https://betterprogramming.pub/cleaner-code-with-rxjava-coroutines-kotlin-extensions-and-helper-functions-d7b7871cdbc>

## 用于 Android 开发的 Kotlinizing RxJava 和协程

![](img/87ff567d3cc2545e3ebba0c7feb1ab66.png)

莎拉·多维勒在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在本文中，我将解释我为 [RxJava](https://github.com/ReactiveX/RxJava) 和[协程](https://kotlinlang.org/docs/reference/coroutines-overview.html)编写的一些 Kotlin 扩展和助手函数，同时将反应模式引入我的 Android 应用程序。我将假设您对这些库有些熟悉。

对于每个扩展，我将描述用例，如何在没有扩展的情况下实现它，如何使用它，以及将实现首选使用方式的扩展。所以事不宜迟，让我们开始吧。

# 场景 1。带 RxJava 的房间

假设您有一个返回`Flowable`的房间查询；这是一个典型的用例，使我们能够观察数据库，并在发生更新时采取相应的行动。如果我们只想调用一次房间查询而不观察它，会发生什么呢？当然，我们总是可以用不同的返回类型创建另一个查询，这在某些情况下肯定是可行的，但是如果我们仍然想在这种情况下利用 RxJava，我们可以为此编写一个简单的扩展。

理想情况下，扩展将在成功时返回单个调用结果，并允许失败处理。该扩展的签名如下所示:

数据库单次调用签名

如果我们看一下`Flowable`类，您会注意到有一个名为`blockingFirst()`的函数，它返回发出的第一个项目。如果它没有发出任何项目，它将抛出一个`NoSuchElementException` ，如果源发出错误信号，它将抛出一个`RuntimeException` 。

我们可以利用这些信息来编写下面的扩展函数:

数据库单次调用扩展功能

我将这两种类型的异常分开只是为了强调一个事实，即您可以明确地捕捉到`NoSuchElementException` 。要使用该扩展，我们假设您有一个如下所示的数据库查询:

从房间数据库查询中获取所有任务

要调用这个查询一次而不必观察它，可以像这样使用扩展函数:

从房间数据库查询使用情况获取所有任务

值得一提的是，RxJava 在嵌套的本质上有一种固有的丑陋；可以想象，如果逻辑更加复杂，嵌套可能会失控。这个问题可以用协程解决；但是现在，这个扩展将使它比它的直接实现更加简洁。

# 场景 2。使用 RxJava 进行改造

如果您曾经将 RxJava 用于改造网络调用，那么您应该知道 RxJava 处理 HTTP 错误(比如 404)的方式与处理其他网络错误(比如没有互联网连接)的方式不同，这给您进行的每个网络调用添加了许多样板代码。

理想情况下，我们应该能够拥有一个接受成功处理程序、失败处理程序和完成处理程序的扩展，这就是我们所关心的。扩展的签名如下所示:

RxJava 改型扩展签名

请注意，可观察对象拥有一个改进的`Response`对象，这将是我们包装网络响应对象的对象；这样我们可以识别 HTTP 错误。我们希望在任何失败(HTTP 或网络)发生时调用`onFailure`，在网络调用后调用`onComplete`，无论成功与否，如果网络调用成功，则调用`onSuccess`。

有了这些信息，下面是扩展的样子:

RxJava 改型扩展实现

注意，我们必须在两个地方调用`onComplete`;那是因为如果发生网络错误的话`doOnComplete`不会被调用。如果我们得到一个 HTTP 错误，那么我们可以将响应封装在一个`HttpException`中，并在`onFailure`处理程序中使用它。

在我们作为参数传递的`onFailure`处理程序之上，我们也可以有一个通用的错误处理程序，看起来像这样:

具有通用错误处理器的 RxJava 改进扩展实现

要使用这个扩展，让我们假设您有一个`getTasks` GET 请求，比如这个:

用 RxJava 改进 GET 请求

现在，要调用这个 GET 请求，您只需编写以下代码:

RxJava 改型扩展用法

请注意，如果您选择不关心特定用例的`onFailure`和`onComplete`，您可以选择不传递它们。

# 场景 3。用协程程序翻新

如果你想做我们在场景 2 中做的同样的事情，但是使用协程，我们可以写一个快速助手函数来代替扩展。该函数的签名如下所示:

协程改进助手函数签名

随着`suspend` 函数的使用，使用协程会干净很多。如您所见，我们不需要传递一个`onSuccess`处理程序，因为我们可以通过返回值来识别成功；否则我们可以返回`null`。我们也不需要`onComplete`处理程序，因为我们在调用之后做的任何事情都是在完成之后。

这个帮助器函数的实现可能如下所示:

协程改进助手函数实现

使用这种类型的实现，您可以很容易地在此方法中传递的可选错误处理程序之上添加一个通用错误处理程序；也许您想添加一些通用分析，或者您想显示整个应用程序中所有网络错误的 Snackbar。添加后，它看起来更像这样:

具有通用错误处理器的协程改进助手函数实现

为了使用这个帮助器函数，让我们假设您有一个`getTasks`改进函数，如下所示:

用协程改进 GET 请求

然后你可以在`CoroutineScope`中使用它，比如说在`ViewModel`中，就像这样:

在视图模型中使用协程改进 GET 请求

作为最后一个想法，我确实意识到 RxJava 仍然有用，但是我发现在这里使用协程要干净得多，而且也不会受到 RxJava 的嵌套效应的影响。

本文到此为止。我希望你能从中得到一些用处，并帮助你写出更干净的代码。直到下一次，开发咬签出！