<html>
<head>
<title>5 Python Commands To Ditch a Complete Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抛弃完整库的5个Python命令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-python-commands-to-ditch-a-complete-library-4af45938bfce?source=collection_archive---------5-----------------------#2021-12-01">https://betterprogramming.pub/5-python-commands-to-ditch-a-complete-library-4af45938bfce?source=collection_archive---------5-----------------------#2021-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="28d3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">其中四个出现在每一个Python基础训练中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7b0437eab27cdfdfedce7d65850c7539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kAH5PUnYXq8CqbMU"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@mullyadii?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆利亚迪</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2c0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从源代码中分离敏感信息的最佳方式是利用环境变量(EVs)。难道你从来没有把这些硬编码到你的文件里吗:</p><ul class=""><li id="3e17" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">秘密密钥和API密钥</li><li id="97e0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">电子邮件和允许的Web主机地址</li><li id="fa21" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">数据库和SMTP凭据</li></ul><p id="fc55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些变量有些是字符串类型，有些是整数，有些是布尔型，列表等。但是，EVs总是存储为字符串。这肯定会造成一片混乱，因为:</p><ul class=""><li id="e0bc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">“假”并不等同于假</li><li id="e9ee" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">128不能用“128”代替</li><li id="0020" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">"('用户'，'主机'，'地址')"是单个值，而不是三项列表</li></ul><p id="9c02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，如何将这些字符串值转换成应用程序可以识别和理解它们真正代表的变量:布尔值、整数、列表或字典？</p><p id="7837" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单的解决方案:安装<a class="ae kv" href="https://github.com/henriquebastos/python-decouple" rel="noopener ugc nofollow" target="_blank"> Python-decouple </a>，学习它并在您的代码中使用。</p><p id="94b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个简单的解决方案是:继续阅读，并使用Python内置函数。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="df86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这可能与代码重用的原则背道而驰，但我更喜欢在学习特定的库之前深入研究Python本身。我意识到自己找到解决方案是一次很有价值的学习经历。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="620f" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">声明环境变量</h1><p id="91f4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在开发阶段，您可能会使用一个虚拟环境(<em class="nk"> pipenv </em>)来包装您的项目并管理依赖关系。创建一个名为“”的文件。env ",并声明所有变量。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="9df0" class="nq mo iq nm b gy nr ns l nt nu">#Folders Tree<br/>Root-Folder\<br/>   .git\<br/>   .venv\<br/>   app1\<br/>   app2<br/>   projectfolder\<br/>   static\<br/>   <strong class="nm ir">.env </strong>  </span></pre><p id="3b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">”的例子。env "文件:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="18ba" class="nq mo iq nm b gy nr ns l nt nu">SECRET_EV = 'pass'<br/>PORT_EV = '5432'<br/>DEBUG_EV = 'True'<br/>ALLHOSTS_EV = '.localhost,*'<br/>DB_EV = '{"ENGINE": "django.db.backends.sqlite3", "NAME": "db.sqlite3"}'</span></pre><p id="de8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当虚拟环境启动(<code class="fe nv nw nx nm b">pipenv shell</code>)时。env”文件，并使这些值可用，以便应用程序可以检索它们。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="87ef" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">检索变量</h1><p id="e8a6" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">环境变量加载到操作系统中，所以需要用<code class="fe nv nw nx nm b">import os</code>导入OS模块。</p><p id="cb8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您可以访问这些值，并将它们分配给<em class="nk"> settings.py </em>文件中的可用变量，或者代码中任何您需要的地方。</p><h2 id="1c46" class="nq mo iq bd mp ny nz dn mt oa ob dp mx lf oc od mz lj oe of nb ln og oh nd oi bi translated">#1 —字符串变量</h2><p id="aac7" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">对于字符串变量，不需要转换，因为ev已经是字符串了。因此，使用一个简单的命令来检索变量，有一个改进:用<em class="nk">删除前导/尾随空格。strip() </em>命令。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="f505" class="nq mo iq nm b gy nr ns l nt nu">#.env<br/>SECRET_EV = 'pass'</span><span id="0184" class="nq mo iq nm b gy oj ns l nt nu">#settings.py<br/>import os</span><span id="78b8" class="nq mo iq nm b gy oj ns l nt nu">SECRET_KEY = os.environ.get('SECRET_EV') #basic<br/>SECRET_KEY = os.environ.get('SECRET_EV')<strong class="nm ir">.strip()</strong> #improved</span></pre><h2 id="41eb" class="nq mo iq bd mp ny nz dn mt oa ob dp mx lf oc od mz lj oe of nb ln og oh nd oi bi translated">#2 —整数变量</h2><p id="aa30" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">连接端口需要整数值，字符串“5432”不同于整数5432 …是吗？</p><p id="6cc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Heroku PostgreSQL数据库(托管在AWS中)，无论您是将整数格式还是字符串格式解析为端口值，它都会接受。</p><p id="1f61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这并不一定适用于网络上的所有服务，所以最好使用内置函数<em class="nk"> int() </em>将字符串转换为整数。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="4a2a" class="nq mo iq nm b gy nr ns l nt nu">#.env<br/>PORT_EV = '5432'</span><span id="98a8" class="nq mo iq nm b gy oj ns l nt nu">#settings.py<br/>import os</span><span id="fd49" class="nq mo iq nm b gy oj ns l nt nu">DB_PORT = <strong class="nm ir">int(</strong>os.environ.get('PORT_EV')<strong class="nm ir">)</strong></span></pre><h2 id="476d" class="nq mo iq bd mp ny nz dn mt oa ob dp mx lf oc od mz lj oe of nb ln og oh nd oi bi translated">#3 —布尔变量</h2><p id="fc70" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">调试需要一个布尔类型值(真或假)，由于<a class="ae kv" href="https://medium.com/@renan.carlos/the-false-positive-trap-in-python-df804bd01b70" rel="noopener">假阳性陷阱</a>，字符串不能替换布尔类型变量。</p><p id="8a67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这个陷阱，也不要使用<code class="fe nv nw nx nm b">bool()</code>功能。见下文:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="d60d" class="nq mo iq nm b gy nr ns l nt nu">&gt;&gt;&gt; a = 'True'<br/>&gt;&gt;&gt; bool(a)<br/>True<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; b = 'False'<br/>&gt;&gt;&gt; bool(b)<br/>True</span></pre><p id="081b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要正确地将字符串转换为布尔值，有两种方法:</p><p id="de62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当“false”是标准时(如Django中的DEBUG)，我将字符串与“true”进行比较。如果它们匹配，比较返回True。如果不是，则返回False。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="51f8" class="nq mo iq nm b gy nr ns l nt nu">#.env<br/>DEBUG_EV = 'True'</span><span id="3c62" class="nq mo iq nm b gy oj ns l nt nu">#settings.py<br/>import os</span><span id="0601" class="nq mo iq nm b gy oj ns l nt nu">DEBUG = os.environ.get('DEBUG_EV').strip().lower() == 'true'</span></pre><p id="c0be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而是，如果标准是‘真’，我就和‘假’比较，取反答案——<code class="fe nv nw nx nm b">not</code>再比较。如果它们匹配，返回将是假的(反真)。如果不是，其他的都将返回True(反False)。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="9659" class="nq mo iq nm b gy nr ns l nt nu">DEBUG = <strong class="nm ir">not</strong> os.environ.get('DEBUG').strip().lower() == 'false'</span></pre><h2 id="5087" class="nq mo iq bd mp ny nz dn mt oa ob dp mx lf oc od mz lj oe of nb ln og oh nd oi bi translated">#4 —列表和元组</h2><p id="a5f9" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">允许的主机是需要列表的设置之一。内置的<em class="nk"> split() </em>函数从一个字符串中创建一个列表，使用一个分隔符参数来识别一个项目的结束和另一个项目的开始。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="6a6e" class="nq mo iq nm b gy nr ns l nt nu">#.env<br/>ALLHOSTS_EV = '.localhost,*'</span><span id="3202" class="nq mo iq nm b gy oj ns l nt nu">#settings.py<br/>import os</span><span id="9deb" class="nq mo iq nm b gy oj ns l nt nu">ALLOWED_HOSTS = os.environ.get('ALLHOSTS_EV').split(sep=",")</span></pre><p id="0ebb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果需要一个Tuple来代替，将环境变量string值转换成一个List，然后将其包装在Python内置的<em class="nk"> tuple() </em>函数中。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="71be" class="nq mo iq nm b gy nr ns l nt nu">ALLOWED_HOSTS = <strong class="nm ir">tuple(</strong>os.environ.get('ALLHOSTS_EV').split(sep=",")<strong class="nm ir">)</strong></span></pre><h2 id="3a14" class="nq mo iq bd mp ny nz dn mt oa ob dp mx lf oc od mz lj oe of nb ln og oh nd oi bi translated">#5 —字典变量</h2><p id="4cf4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">最后，如果需要一个包含一组可变参数的字典，那么基本级别的toolbelt解决方案就不再有帮助了。例如，用于SQLite3的Django SQL数据库声明。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="d2a0" class="nq mo iq nm b gy nr ns l nt nu">#settings.py (SQLite3)<br/>DATABASES = {<br/>   'default': {<br/>      'ENGINE': 'django.db.backends.sqlite3',<br/>      'NAME': 'db.sqlite3'<br/>   }<br/>}</span><span id="0d6b" class="nq mo iq nm b gy oj ns l nt nu">#DICT = {'key1': 'value1', 'key2': 'value2'}</span></pre><p id="0033" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，Python字典只不过是一系列的键和值。如果用一个字符串表示，它就是<strong class="ky ir">和</strong>一样的JSON值。正因为如此，内置的Python JSON模块将非常有帮助。</p><p id="7f8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JSON模块有<em class="nk"> loads() </em>方法。它理解JSON字符串的模式，提取带有相应值的键，并将它们解析到Python字典中——这正是我们所需要的。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="b0f1" class="nq mo iq nm b gy nr ns l nt nu">#.env (SQLite3)<br/>DB_EV = '{"ENGINE": "django.db.backends.sqlite3", "NAME": "db.sqlite3"}'</span><span id="7d7c" class="nq mo iq nm b gy oj ns l nt nu">#settings.py<br/>import os<br/>import json</span><span id="d598" class="nq mo iq nm b gy oj ns l nt nu">DATABASES = {'default': json.loads(os.environ.get('DB_EV').strip())}</span></pre><p id="907b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一开始看起来很难，但这是一个简单而灵活的解决方案。上面的例子适用于我用于开发的SQLite3。然而，对于生产，我使用PostgreSQL，它需要额外的键/值对。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="58b0" class="nq mo iq nm b gy nr ns l nt nu">#.env (PostgreSQL)<br/>DB_EV = '{"ENGINE": "django.db.backends.postgresql_psycopg2", "NAME": "database-name", "USER": "user-name", "PASSWORD": "user-password", "HOST": "host-address", "PORT": "port-number"}'</span><span id="a832" class="nq mo iq nm b gy oj ns l nt nu">#settings.py<br/>import os<br/>import json</span><span id="7bf9" class="nq mo iq nm b gy oj ns l nt nu">DATABASES = {'default': json.loads(os.environ.get('DB_EV').strip())}</span></pre><p id="e0cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码(<em class="nk"> settings.py </em>)里写的东西对于开发(SQLite3)和生产(PostgreSQL)是一样的。只有环境变量会根据每个工作环境而不同。</p><p id="4399" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这确保了在这两种情况下，所有数据库参数都将被相应地声明，并建立正确的连接。</p></div></div>    
</body>
</html>