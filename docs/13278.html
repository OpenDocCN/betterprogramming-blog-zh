<html>
<head>
<title>Service Discovery With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go进行服务发现</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/service-discovery-with-go-17b44011bcb2?source=collection_archive---------0-----------------------#2022-08-14">https://betterprogramming.pub/service-discovery-with-go-17b44011bcb2?source=collection_archive---------0-----------------------#2022-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0357" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用<code class="fe kf kg kh ki b">avahi</code>工具集实现服务发现</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f023c21141e5b5d00682a9ea6e151c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IdILfU2KZx7InG_6"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图片由<a class="ae kz" href="https://unsplash.com/@thomasjsn" rel="noopener ugc nofollow" target="_blank"> Thomas Jensen </a>通过unsplash提供</p></figure><p id="bbd6" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">“微服务服务发现是应用程序和微服务在网络上相互定位的一种方式。”这可以通过具有地址和服务名称列表的中央服务器或者连接到中央服务器以检索和更新地址的客户端来实现。当我第一次看到服务发现时，乐观的我认为它是通过“mDNS/DNS-SD协议套件”运行的<code class="fe kf kg kh ki b">mDNS</code>是AirPlay使用的协议。这是一个ZeroConfig接口，用户只需将设备连接到同一个网络就可以与之交互。ZeroConfig，顾名思义，是一个即插即用的解决方案。如果这种技术可以用于微服务服务发现呢？这肯定会消除对中央服务器的需求。" Avahi是一个通过mDNS/DNS-SD协议组在本地网络上促进服务发现的系统."在这篇文章中，我将尝试实现一个可以通过<code class="fe kf kg kh ki b">mDNS</code>发现的web服务器。</p><h1 id="f97f" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">服务器</strong></h1><p id="fadf" class="pw-post-body-paragraph la lb iq lc b ld mo jr lf lg mp ju li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">我将从在Go中实现一个基本的web服务器开始。下面是它的代码:</p><pre class="kk kl km kn gt mt ki mu mv aw mw bi"><span id="6701" class="mx lx iq ki b gy my mz l na nb">func main() {</span><span id="ce54" class="mx lx iq ki b gy nc mz l na nb">  fmt.Println("listenning")<br/>  log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="1b23" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">接下来，我将编写一个通过<code class="fe kf kg kh ki b">mDNS</code>广播我的服务的函数。这将通过命令<code class="fe kf kg kh ki b">avahi-publish</code>来执行。这个命令的好处是一旦它退出，服务将停止广播。我将使用Go的<code class="fe kf kg kh ki b">exec</code>包调用该命令。下面是该函数的代码:</p><pre class="kk kl km kn gt mt ki mu mv aw mw bi"><span id="4287" class="mx lx iq ki b gy my mz l na nb">func BroadCastMe(port, service string) {</span><span id="0e24" class="mx lx iq ki b gy nc mz l na nb">  cmd := exec.Command(<br/>       "avahi-publish", <br/>       "-s", <br/>       service, <br/>       "_http._tcp", // publish as http service<br/>       port,<br/>  )</span><span id="a040" class="mx lx iq ki b gy nc mz l na nb">  if err := cmd.Run(); err != nil {<br/>   // close program if broadcast fails<br/>   log.Fatal(err)<br/>  }</span><span id="2f4e" class="mx lx iq ki b gy nc mz l na nb">}</span></pre><p id="9c0f" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">函数<code class="fe kf kg kh ki b">BroadCastMe</code>将作为Goroutine调用。下面是main函数的最终版本:</p><pre class="kk kl km kn gt mt ki mu mv aw mw bi"><span id="202c" class="mx lx iq ki b gy my mz l na nb">func main() {</span><span id="3c24" class="mx lx iq ki b gy nc mz l na nb">  fmt.Println("listening")</span><span id="c57b" class="mx lx iq ki b gy nc mz l na nb">  // broadcast will stop<br/>  // on program shutdown<br/>  go BroadCastMe("8080", "service-one")</span><span id="b5cc" class="mx lx iq ki b gy nc mz l na nb">  log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="e857" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这个服务器将在另一个线程上广播自己，而实际的服务器运行在主线程上。现在来发现服务。</p><h1 id="89e3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">发现</h1><p id="aca6" class="pw-post-body-paragraph la lb iq lc b ld mo jr lf lg mp ju li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">发现服务将遵循与发布服务相同的方法。将运行avahi工具集中的一个命令来列出可用的服务。我将首先声明一个自定义类型来定义服务，它将被称为<code class="fe kf kg kh ki b">Service</code>。下面是该结构的定义:</p><pre class="kk kl km kn gt mt ki mu mv aw mw bi"><span id="cbb7" class="mx lx iq ki b gy my mz l na nb">type Service struct {<br/> Name        string<br/> Address     string<br/> Port        string<br/> AddressType string<br/>}</span></pre><p id="e9e7" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">接下来，我将实现一个函数来运行命令<code class="fe kf kg kh ki b">avahi-browse</code>，这将寻找<code class="fe kf kg kh ki b">http</code>服务。该命令将提供标志<code class="fe kf kg kh ki b">p</code>，以返回可解析的日期。标志<code class="fe kf kg kh ki b">t</code>将确保程序在搜索完成后关闭。一旦命令返回了服务列表，我将使用一些hacky方法来提取填充上面定义的结构类型所需的数据。返回一个<code class="fe kf kg kh ki b">Service</code>数组。以下是该函数的代码:</p><pre class="kk kl km kn gt mt ki mu mv aw mw bi"><span id="7ee9" class="mx lx iq ki b gy my mz l na nb">func GetServices() ([]Service, error) {</span><span id="1255" class="mx lx iq ki b gy nc mz l na nb"> cmd := exec.Command(<br/>     "avahi-browse", <br/>     "-t",  // type of protocol to look for<br/>     "_http._tcp", // http protocol<br/>     "-v",<br/>     "-r", <br/>     "-p", // prints parseable format<br/> )</span><span id="1131" class="mx lx iq ki b gy nc mz l na nb"> stdout, err := cmd.Output()<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="5248" class="mx lx iq ki b gy nc mz l na nb"> strOutput := string(stdout)<br/> rows := strings.Split(strOutput, "=")</span><span id="3d4b" class="mx lx iq ki b gy nc mz l na nb"> result := []Service{}</span><span id="aeca" class="mx lx iq ki b gy nc mz l na nb"> for i,v := range rows {</span><span id="b14e" class="mx lx iq ki b gy nc mz l na nb">  if i == 0 {<br/>    continue<br/>  }</span><span id="4155" class="mx lx iq ki b gy nc mz l na nb">  row := strings.Split(v, ";")<br/>  service := Service{<br/>    AddressType : row[2],<br/>    Name : row[3],<br/>    Address : row[7],<br/>    Port : row[8],<br/>  }<br/>  <br/>  result = append(result, service)</span><span id="727e" class="mx lx iq ki b gy nc mz l na nb"> }</span><span id="2a80" class="mx lx iq ki b gy nc mz l na nb"> return  result, nil</span><span id="402b" class="mx lx iq ki b gy nc mz l na nb">}</span></pre><p id="47aa" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面是上面定义的发现代码的基本实现:</p><pre class="kk kl km kn gt mt ki mu mv aw mw bi"><span id="7577" class="mx lx iq ki b gy my mz l na nb">func main() {</span><span id="8422" class="mx lx iq ki b gy nc mz l na nb"> services, err := GetServices()</span><span id="1391" class="mx lx iq ki b gy nc mz l na nb"> if err != nil {<br/>   log.Fatal(err)<br/> }</span><span id="17f9" class="mx lx iq ki b gy nc mz l na nb"> fmt.Println(services)</span><span id="83b2" class="mx lx iq ki b gy nc mz l na nb">}</span></pre><p id="12e7" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">以下是这一理论的应用:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e74f8e883d57280f2d1d4db1738a18c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*qMt8GCnKnKhpvTd3.gif"/></div></figure><h1 id="1f2d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="02dc" class="pw-post-body-paragraph la lb iq lc b ld mo jr lf lg mp ju li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated"><code class="fe kf kg kh ki b">mDNS</code>旨在让消费者“将你的笔记本电脑或计算机接入网络，就能立即看到你可以与之聊天的其他人，找到要打印的打印机或找到正在共享的文件。”在我看来，这项技术应该是云原生栈的一部分。我错误地假设微服务服务发现以这种方式运行，但也许它应该以这种方式运行。我看不出服务发现目前是如何实现的(中央服务器)有什么缺陷。但是我的方法意味着少管理一个微服务，因为这些服务可以在网络上发布它们自己。我只在我的电脑上测试过这个，所以这个理论在其他环境中的行为是未知的。同样重要的是要考虑到这与avahi工具链一起工作。部署时，由于avahi工具链与应用程序的映像一起出现，可能会导致更大的有效负载。但也许我错了，它没有显著增加。</p><p id="7d1d" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在我当众听起来像个白痴之前，“avahi”是怎么发音的？是“阿瓦喜”还是“阿瓦喜”？</p><h1 id="1294" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">其他来源</h1><p id="da72" class="pw-post-body-paragraph la lb iq lc b ld mo jr lf lg mp ju li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">什么是服务发现？定义和相关常见问题| Avi网络</p><p id="cd1a" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kz" href="https://github.com/cheikhshift/medium_examples/tree/main/service-discovery" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></p><p id="e810" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kz" href="https://linux.die.net/man/1/avahi-browse" rel="noopener ugc nofollow" target="_blank"> avahi-browse(1) — Linux手册页</a></p><p id="a0fb" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kz" href="https://avahi.org/" rel="noopener ugc nofollow" target="_blank">阿瓦希— mDNS/DNS-SD </a></p></div></div>    
</body>
</html>