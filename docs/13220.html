<html>
<head>
<title>Building a Cloud Shell Experience With Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用药剂构建云壳体验</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-we-created-an-in-browser-kubernetes-experience-58c065cda803?source=collection_archive---------13-----------------------#2022-08-08">https://betterprogramming.pub/how-we-created-an-in-browser-kubernetes-experience-58c065cda803?source=collection_archive---------13-----------------------#2022-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a346" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以创纪录的速度在Kubernetes上部署开源软件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0e0205384afe4cf10f5d91d87ad89bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiQyoi6F5oC8g7BYeLx4NA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由Plural.sh提供。</p></figure><p id="061a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们深入研究我们的云壳如何取得成果的技术杂草之前，首先有必要解释一下我们为什么要构建云壳(我们的免费开源浏览器内Kubernetes体验)。毕竟，这是一个相当不寻常的产品决策。</p><div class="lr ls gp gr lt lu"><a href="https://github.com/pluralsh/plural" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">GitHub - pluralsh/plural:以创纪录的时间在kubernetes上部署开源软件。🚀</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">Plural使您能够在Kubernetes上构建和维护云原生和生产就绪的开源基础设施…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">github.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi kp lu"/></div></div></a></div><p id="bcaa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使你不是Kubernetes的超级用户，你也可能熟悉或认识一个提到Kubernetes学习曲线有多陡的开发人员。首先，您需要利用大量工具来正确地部署和管理Kubernetes集群。</p><p id="b4ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的案例中，我们依赖于以下工具:</p><ul class=""><li id="5100" class="mj mk iq kx b ky kz lb lc le ml li mm lm mn lq mo mp mq mr bi translated">舵</li><li id="8264" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">将（行星）地球化（以适合人类居住）</li><li id="def5" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">库贝特尔</li><li id="0b05" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">饭桶</li><li id="4d24" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">任何云CLI(例如，AWS、GCP、AZURE)</li><li id="f3bb" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">以及免费和开源的复数CLI</li></ul><p id="2bc4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了安装上述所有软件之外，您还需要正确配置他们的所有证书，确保他们在正确的版本上运行，并解决在本地运行软件的所有其他细节问题。</p><p id="c4c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，这绝对是一项耗时的任务，并且至少需要一些Helm和Terraform的基础知识，以便正确地部署和管理应用程序。</p><h1 id="01a1" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">我们从早期采用者那里学到了什么</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/68cf1bcab43a36aa500fac94d87fb5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M9f6lfHriNJiGed-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由帕特里克·托马索 / <a class="ae nq" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b24d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们最初构建Plural时，我们是在这样的假设下设计我们的应用程序的，即我们的大多数产品用户已经对部署基础设施有了一些熟悉，并且开发环境对他们来说是非常熟悉的，如果不是已经预先安装在他们的系统上的话。</p><p id="c1cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为一个团队，我们很快认识到我们最初的假设是不正确的，我们的大部分高级用户实际上对在Kubernetes上部署基础设施知之甚少。</p><p id="0fbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在大多数情况下，我们发现用户来自数据科学和工程背景，并且没有安装标准的DevOps工具链。结果，他们遇到了大多数依赖的障碍，从而限制了我们的自由和开源工具的能力。</p><p id="d0c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然我们平台的底层技术不是问题，并且来自我们早期采用者的反馈很有启发性，但我们知道我们必须快速解决用户面临的这个常见障碍。当我们的工程团队坐下来解决这个问题时，他们最初想出了两种方法来解决用户DevOps知识缺口。</p><p id="a2b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一个解决方案是简单地给用户一个预装的Docker映像，并随时可用。然而，让Docker容器与本地git存储库和本地云凭证一起工作本身就是一个不小的挑战。我们又回到了起点。</p><p id="005b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一个自然的途径是弄清楚如何在我们自己的基础设施上运行和配置Docker映像，从用户体验中去掉这一步。最初，将我们的Docker映像转换为云外壳类型的体验似乎并不具有挑战性。Kubernetes有一个远程执行API，我们认为我们可以利用这个API来使它工作。</p><p id="4a52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来很简单，对吗？算是吧，但也不尽然。</p><h1 id="bfc2" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">复数云壳的基本架构</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/d44c1ad46146cd0ff72cacb43504b1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u0bFG8vcG_zt-mPJ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由Plural首席技术官兼联合创始人Michael Guarino提供。</p></figure><p id="06ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">利用Kubernetes API比我们最初想象的更具挑战性。我们能够通过遵循这个通用系统设计来克服这个问题。</p><ul class=""><li id="9779" class="mj mk iq kx b ky kz lb lc le ml li mm lm mn lq mo mp mq mr bi translated">我们有一组graphql APIs来管理云外壳实例的创建、轮询和重启。API在我们的数据库中创建对shell pod的引用，并在k8s集群中创建pod。</li><li id="d537" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">我们将所有shell pods放在一个专用的k8s节点组中，这些节点组是网络隔离的，并在现场运行实例，以尽可能降低成本。</li><li id="d6b8" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">我们有一个操作员跟踪一个声明过期的pod标签，它会在六个小时后删除shell实例。然后，我们有一个优雅的关闭机制，它将确保未提交的git更改被推送到上游，以确保我们不会鲁莽地破坏状态。</li><li id="82ad" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">我们的前端提供了一个WebSocket API，允许我们推送和接收相当于stdin和stdout的浏览器，所有的b64编码和呈现在react应用程序中的xterm.js中。</li></ul><p id="ce91" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这并不复杂，但魔鬼总是在细节中。</p><h1 id="4807" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">使用酏剂处理Kubernetes pods/exec API</h1><p id="27cc" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">我们必须克服的第一个问题是弄清楚Kubernetes pod exec API是如何操作的。总的来说，我们的服务器将位于浏览器客户端和Kubernetes pod之间，提供auth+authz并处理pod娱乐逻辑。这意味着我们需要代理API公开的格式，并将其转换为elixir phoenix channel WebSocket响应。</p><p id="ce08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实证明，该API的文档记录很差，但实际上使用起来非常简单。虽然Kubernetes文档中没有关于它的细节，但我们能够通过深入官方<a class="ae nq" href="https://github.com/kubernetes/dashboard" rel="noopener ugc nofollow" target="_blank"> Kubernetes仪表板</a>的代码来逆向工程如何使用它。</p><p id="193b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您只需通过wss连接到如下路径:</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="311a" class="oc my iq ny b gy od oe l of og">/api/v1/namespaces/{namespace}/pods/{name}/exec</span></pre><p id="c6ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">并且，提供任何参数作为查询参数。然后，API公开五个通道，所有通道都是以整数0到4为前缀的二进制消息。</p><ul class=""><li id="b014" class="mj mk iq kx b ky kz lb lc le ml li mm lm mn lq mo mp mq mr bi translated">0是stdin的通道。</li><li id="0a82" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">1–3是对应于stdout、stderr等的输出通道。</li><li id="db72" class="mj mk iq kx b ky ms lb mt le mu li mv lm mw lq mo mp mq mr bi translated">4专用于调整终端屏幕大小的JSON消息。</li></ul><p id="7148" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们能够用elixir二进制模式匹配非常优雅地处理这个问题，例如:</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="1e78" class="oc my iq ny b gy od oe l of og"><strong class="ny ir">def</strong> <strong class="ny ir">command</strong>(client, message) <strong class="ny ir">do</strong><br/>  WebSockex.send_frame(client, {:binary, &lt;&lt;0&gt;&gt; &lt;&gt; message})<br/><strong class="ny ir">end</strong><br/><br/><strong class="ny ir">def</strong> <strong class="ny ir">resize</strong>(client, cols, rows) <strong class="ny ir">do</strong><br/>  resize = Jason.encode!(%{Width: cols, Height: rows})<br/>  WebSockex.send_frame(client, {:binary, &lt;&lt;4&gt;&gt; &lt;&gt; resize})<br/><strong class="ny ir">end</strong><br/><br/>defp deliver_frame(&lt;&lt;1, frame::binary&gt;&gt;, pid),<br/>  do: send_frame(pid, frame)<br/>defp deliver_frame(&lt;&lt;2, frame::binary&gt;&gt;, pid),<br/>  do: send_frame(pid, frame)<br/>defp deliver_frame(&lt;&lt;3, frame::binary&gt;&gt;, pid),<br/>  do: send_frame(pid, frame)<br/>defp deliver_frame(frame, pid), do: send_frame(pid, frame)</span></pre><p id="dc11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae nq" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elixir </a>也有一个相当简单的<a class="ae nq" href="https://elixirforum.com/t/how-to-implement-extension-of-functionality-as-inheritance-in-object-oriented-language/37263" rel="noopener ugc nofollow" target="_blank">基于GenServer的WebSocket </a>客户端，我们利用它来建立到k8s API的弹性连接。我们将WebSocket genserver链接到我们的通道进程，以确保在我们失去与k8s的连接时，一切都可以正确重启。</p><p id="716c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">管理pod exec WebSocket的所有代码都可以在<a class="ae nq" href="https://github.com/pluralsh/plural/blob/master/apps/core/lib/core/services/shell/pods/pod_exec.ex" rel="noopener ugc nofollow" target="_blank">这里</a>找到，将这些代码封装到genserver中使我们能够创建一个非常薄的通道来管理往返于浏览器的stdout和stdin:</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="c483" class="oc my iq ny b gy od oe l of og"><strong class="ny ir">defmodule</strong> <strong class="ny ir">RtcWeb</strong>.ShellChannel <strong class="ny ir">do</strong><br/> <strong class="ny ir">use</strong> RtcWeb, :channel<br/> <strong class="ny ir">alias</strong> Core.Services.{Shell.Pods, Shell}<br/> <strong class="ny ir">alias</strong> Core.Shell.Client<br/> <strong class="ny ir">alias</strong> Core.Schema.CloudShell</span><span id="0c2c" class="oc my iq ny b gy oh oe l of og">require Logger</span><span id="0a07" class="oc my iq ny b gy oh oe l of og"><strong class="ny ir">def</strong> <strong class="ny ir">join</strong>(“shells:me”, _, socket) <strong class="ny ir">do</strong><br/> send(<strong class="ny ir">self</strong>(), :connect)<br/> {:ok, socket}<br/> <strong class="ny ir">end</strong></span><span id="468b" class="oc my iq ny b gy oh oe l of og"><strong class="ny ir">def</strong> <strong class="ny ir">handle_info</strong>(:connect, socket) <strong class="ny ir">do</strong><br/> with %CloudShell{pod_name: name} = shell &lt;- Shell.get_shell(socket.assigns.user.id),<br/> {:ok, _} &lt;- Client.setup(shell),<br/> url &lt;- Pods.PodExec.exec_url(name),<br/> {:ok, pid} &lt;- Pods.PodExec.start_link(url, <strong class="ny ir">self</strong>()) <strong class="ny ir">do</strong><br/> {:noreply, assign(socket, :wss_pid, pid)}<br/> else<br/> err -&gt;<br/> Logger.info “failed to exec pod with #{inspect(err)}”<br/> {:stop, {:shutdown, :failed_exec}, socket}<br/> <strong class="ny ir">end</strong><br/> <strong class="ny ir">end</strong></span><span id="89bc" class="oc my iq ny b gy oh oe l of og"><strong class="ny ir">def</strong> <strong class="ny ir">handle_info</strong>({:stdo, data}, socket) <strong class="ny ir">do</strong><br/> push(socket, “stdo”, %{message: Base.encode64(data)})<br/> {:noreply, socket}<br/> <strong class="ny ir">end</strong></span><span id="8ceb" class="oc my iq ny b gy oh oe l of og"><strong class="ny ir">def</strong> <strong class="ny ir">handle_in</strong>(“command”, %{“cmd” =&gt; cmd}, socket) <strong class="ny ir">do</strong><br/> Pods.PodExec.command(socket.assigns.wss_pid, fmt_cmd(cmd))<br/> {:reply, :ok, socket}<br/> <strong class="ny ir">end</strong></span><span id="a986" class="oc my iq ny b gy oh oe l of og"><strong class="ny ir">def</strong> <strong class="ny ir">handle_in</strong>(“resize”, %{“width” =&gt; w, “height” =&gt; h}, socket) <strong class="ny ir">do</strong><br/> Pods.PodExec.resize(socket.assigns.wss_pid, w, h)<br/> {:reply, :ok, socket}<br/> <strong class="ny ir">end</strong></span><span id="215d" class="oc my iq ny b gy oh oe l of og"><strong class="ny ir">defp</strong> <strong class="ny ir">fmt_cmd</strong>(cmd) <strong class="ny ir">when</strong> is_binary(cmd), do: cmd<br/> <strong class="ny ir">defp</strong> <strong class="ny ir">fmt_cmd</strong>(cmd) <strong class="ny ir">when</strong> is_list(cmd), do: Enum.join(cmd, “ “)<br/><strong class="ny ir">end</strong></span></pre><p id="3556" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这类产品来说，Elixir是一个很棒的解决方案，原因有二。这使得创建一个专门构建的WebSocket API成为一种快乐的体验。它还允许我们利用其独特的二进制处理能力来轻松处理一个愚蠢的协议，并以Javascript可理解的格式呈现给我们的浏览器客户端。</p><h1 id="660c" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">外壳弹性</h1><p id="87dc" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">使用Kubernetes pod execs的一个缺点是，如果WebSocket由于某种原因被终止，那么您执行到该pod的shell进程将在pod端终止。这意味着，每当有人刷新页面或在浏览器中导航时，他们的会话就会被完全破坏。</p><p id="e9f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在常见的k8s dashboard用例中，这完全没问题，因为您可能正在运行非常短暂的任务，如检查文件或一次性调用小python脚本。</p><p id="91c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，在我们的例子中，我们的shell正在执行长时间运行的terraform和helm命令，如果过早终止，可能会导致状态损坏和资源悬空。这是一个巨大的阻碍，几乎扼杀了这个项目。</p><p id="92e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是很多其他终端任务的常见问题，比如长时间运行的ssh会话。老派的解决方案是使用screen或tmux之类的工具来处理这个问题，但是这个选项对我们不适用。</p><p id="c97d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢天谢地，我们找到了解决办法；<em class="oi">终端复用</em>。</p><p id="8aea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您不熟悉终端多路复用器，它本质上是一种在小型本地服务器上运行终端会话的方法，即使调用它的shell进程终止，它也不会终止。正因为如此，你可以继续你正在做的任何工作，而不会被打断。</p><p id="fc4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了管理shell pods中的单个tmux会话，我们编写了一个简单的bash脚本:</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="52c3" class="oc my iq ny b gy od oe l of og">#!/bin/sh</span><span id="eed4" class="oc my iq ny b gy oh oe l of og">session=”workspace”<br/>tmux start<br/>tmux has-session -t $session 2&gt;/dev/null</span><span id="e27a" class="oc my iq ny b gy oh oe l of og"><strong class="ny ir">if</strong> [ $? != 0 ]; <strong class="ny ir">then</strong><br/> tmux new-session -c ~/workspace -s $session zsh<br/><strong class="ny ir">fi</strong></span><span id="171d" class="oc my iq ny b gy oh oe l of og"># Attach to created session<br/>tmux attach-session -d -t $session</span></pre><p id="da70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这确保了有一个持久的tmux会话，浏览器总是在WebSocket connect上安装到这个会话，这也使我们的shell在许多方面比在本地运行更可取，因为笔记本电脑的网络远不如我们的shell pods在其中运行的AWS数据中心可靠。对于长期运行的terraform设置，尤其是k8s集群创建过程，它还允许您拥有一个“运行并忘记”的工作流。</p><p id="31f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我参加这个项目时并没有期望必须重新学习我的tmux技能，但是能够将它融入到我们的最终解决方案中是很有趣的。</p><h1 id="efc7" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">React实现</h1><p id="2bd0" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">我们要解决的最后一个难题是如何在浏览器中呈现终端。</p><p id="17df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">显然，在野外有相当数量的工具可以做到这一点。GCP和Azure都有一个云外壳，Kubernetes dashboard OSS项目也在其pod viewer中嵌入了一个。所以很明显有现有技术</p><p id="85b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经过一番挖掘，我们的团队发现了<a class="ae nq" href="https://xtermjs.org/" rel="noopener ugc nofollow" target="_blank"> xtermjs项目</a>，这是一个完整的POSIX终端实现，采用浏览器兼容的javascript。还有一个用于<a class="ae nq" href="https://www.npmjs.com/package/xterm-for-react" rel="noopener ugc nofollow" target="_blank"> xterm-for-react </a>的react包装器，它基本上只是将xterm挂载到一个父HTML节点中，并以一种react兼容的方式管理一些设置状态。</p><p id="2425" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要欺骗phoenix通道从xtermjs中读取和写入数据需要做一些工作，但最终还是相当简单的。如果有人对它如何在前端组合在一起感到好奇，你可以在这里查看我们终端组件<a class="ae nq" href="https://github.com/pluralsh/plural/blob/master/www/src/components/shell/Terminal.js" rel="noopener ugc nofollow" target="_blank">的源代码</a>。</p><h1 id="daea" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">包扎</h1><p id="fe0b" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">总的来说，我们在构建这个特性的过程中得到了很多乐趣。它让我们能够深入到Kubernetes API中一个经常未被探索的领域，我真的很高兴我们能够探索这个领域。这个项目在使用<code class="fe oj ok ol ny b">tmux</code>时也发生了意想不到的变化，并在<code class="fe oj ok ol ny b">xtermjs</code>中向我们展示了一个真正令人兴奋的项目(我很惊讶社区有耐心用javascript编写完整的shell！).</p><p id="e7ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们也很高兴看到它为我们的用户解决了多少真正的痛点。它允许开发人员很快看到复数的价值，而没有设置开发环境的麻烦，否则他们将不会经历。</p><p id="b2fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望您能从中学到一些东西，尤其是如果基于浏览器的shell在您正在构建的任何项目中都有用的话。</p><p id="3c26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你喜欢我们正在做的事情，并希望为我们的项目做出贡献，请前往<a class="ae nq" href="https://github.com/pluralsh/plural" rel="noopener ugc nofollow" target="_blank">我们的GitHub </a>查看我们的项目。</p></div></div>    
</body>
</html>