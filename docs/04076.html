<html>
<head>
<title>Master Different Types of Observables in RxJava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握RxJava中不同类型的可观测量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjava-mastering-different-types-of-observables-154ca9849146?source=collection_archive---------5-----------------------#2020-03-22">https://betterprogramming.pub/rxjava-mastering-different-types-of-observables-154ca9849146?source=collection_archive---------5-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="95d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的需求选择正确的可观察对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aad75dfa9c089316d859fa00c1b8eea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTeNhAxoqCMvp-ou4N0D4A.png"/></div></div></figure><p id="0424" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你对RxJava没有一点基本的了解，请浏览<a class="ae lq" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf?source=your_stories_page---------------------------" rel="noopener">rx Java:Android中的多线程</a>这篇帖子。如果你对RxJava有一个基本的概念，你就会知道Observable是一个向观察者发出值的组件。这篇文章是关于探索RxJava中不同类型的可观察对象。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6ae8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">不同类型的可观测量</h1><p id="5086" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一个可观察对象可以传递任意类型的多个值——文字、消息或事件，这取决于上下文。根据可观察对象发出数据的方式，它们被分类如下:</p><ol class=""><li id="6102" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">可观察量</li><li id="b59e" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">单一的</li><li id="72df" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">可完成的</li><li id="0030" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">可能</li><li id="4ce4" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">易流动的</li></ol><p id="1099" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于每个可观察值，我们有以下观察者。</p><ul class=""><li id="97bd" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp nj nb nc nd bi translated">观察者</li><li id="1b7d" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nj nb nc nd bi translated">单一可观察的</li><li id="5f7d" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nj nb nc nd bi translated">CompletableObserver</li><li id="21a9" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nj nb nc nd bi translated">也许可以观察到</li></ul><p id="3ef0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在帖子<a class="ae lq" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf?source=your_stories_page---------------------------" rel="noopener">rx Java:Android中的多线程</a>中，我们已经探索了Observable。所以让我们详细了解一下其他类型。</p><h2 id="a48a" class="nk lz it bd ma nl nm dn me nn no dp mi ld np nq mk lh nr ns mm ll nt nu mo nv bi translated">单一的</h2><p id="519d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Single是只发出一个项目或抛出一个错误的可观察对象。换句话说，Single是一个可以发出单个onSuccess或onError的反应基类型。Android中Single最简单的用法就是我们进行网络调用消耗一些数据的时候。Single是使用最频繁的可观察值之一，因为我们在大多数应用程序中都有网络呼叫。它是接口<code class="fe nw nx ny nz b">io.reactivex.SingleObserver&lt;T&gt;</code>的一个实现，有三个方法。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="eac3" class="nk lz it nz b gy oe of l og oh">interface SingleObserver&lt;T&gt; {<br/>    void onSubscribe(Disposable d);<br/>    void onSuccess(T value);<br/>    void onError(Throwable error);<br/>}</span></pre><ul class=""><li id="bcf7" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp nj nb nc nd bi translated">订阅:只要订阅了观察器，就会调用</li><li id="dde2" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nj nb nc nd bi translated">onError:每当在流的某个点抛出一个错误时，将被调用</li><li id="417a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nj nb nc nd bi translated">onSuccess:如果我们从流中得到响应，将被调用，在这种情况下，我们可以处理响应</li></ul><p id="5219" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们假设有一个带有TvShowsRepo的TvShows应用程序，它是一个带有获取节目细节的方法的改进接口。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="9b23" class="nk lz it nz b gy oe of l og oh">interface TvShowsRepo {</span><span id="8578" class="nk lz it nz b gy oi of l og oh">@Get(Constants.BaseUrl +"/show-detaisl/")<br/>fun getShowDetails(showId: Int):Single&lt;SeriesResponse&gt;</span><span id="fb52" class="nk lz it nz b gy oi of l og oh">}</span></pre><p id="4827" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们使用Single，因为它是一次性任务。我们将把回购注入到<a class="ae lq" href="https://medium.com/better-programming/everything-to-understand-about-viewmodel-400e8e637a58" rel="noopener">视图模型</a>中，并消费数据，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="866d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个方法<code class="fe nw nx ny nz b">getShowDetails()</code>被执行并返回来自服务器的响应或错误。这就是我们通常一次性使用单个可观察值的方式。查看更多关于<a class="ae lq" href="http://reactivex.io/documentation/single.html" rel="noopener ugc nofollow" target="_blank">单曲</a>。</p><h2 id="32ea" class="nk lz it bd ma nl nm dn me nn no dp mi ld np nq mk lh nr ns mm ll nt nu mo nv bi translated">可完成的</h2><p id="7e1d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Completable只关心执行完成，而不发出值。Completable observable不会发出任何数据，而是通知任务的状态是成功还是失败。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="de6b" class="nk lz it nz b gy oe of l og oh">interface CompletableObserver&lt;T&gt; {<br/>    void onSubscribe(Disposable d);<br/>    void onComplete();    <br/>    void onError(Throwable error);<br/>}</span></pre><ul class=""><li id="550e" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp nj nb nc nd bi translated">Completable将调用一次<code class="fe nw nx ny nz b">onSubscribe</code>,以在此实例上设置一个Disposable，以后可以随时使用它来取消订阅</li><li id="d692" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nj nb nc nd bi translated">如果延迟计算抛出异常，将调用一次<code class="fe nw nx ny nz b">onError</code></li><li id="9a25" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nj nb nc nd bi translated">一旦延迟计算正常完成，没有任何错误，就会调用<code class="fe nw nx ny nz b">onComplete</code></li></ul><p id="3493" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们通常使用Completable将值存储在preferences或SQLite本地数据库等不需要响应的地方。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="8ad0" class="nk lz it nz b gy oe of l og oh">@Singleton<br/>class CachedRepoImpl @Inject constructor(private val cacheService: CacheService) : CacheRepo {</span><span id="547c" class="nk lz it nz b gy oi of l og oh">fun saveUserData(userModel: String): Completable {<br/>    return Completable.fromAction {<br/>        cacheService.saveProfile(userModel)<br/>    }<br/>}</span><span id="a8cb" class="nk lz it nz b gy oi of l og oh">}</span></pre><p id="9610" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的<code class="fe nw nx ny nz b">cacheService</code>中是一个类，它有一个共享参数的注入来保存和检索数据。</p><p id="3b24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将此作为休闲消费</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2633" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">方法<code class="fe nw nx ny nz b">saveUserDetails()</code>被执行，返回任务执行成功或失败的回调。这就是我们通常使用Completable Observable进行成功或失败回调的方式。查看更多关于<a class="ae lq" href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html" rel="noopener ugc nofollow" target="_blank"> Completable </a>的信息。</p><h2 id="4323" class="nk lz it bd ma nl nm dn me nn no dp mi ld np nq mk lh nr ns mm ll nt nu mo nv bi translated">可能</h2><p id="7b90" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">也许可观察可能会也可能不会发出一个值。这个可观察值可以用在你期望一个项目被可选地发出的情况下。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="0b64" class="nk lz it nz b gy oe of l og oh">interface MaybeObserver&lt;T&gt; {<br/>    void onSubscribe(Disposable d);<br/>    void onSuccess(T value);<br/>    void onError(Throwable error);<br/>    void onComplete();<br/>}</span></pre><p id="c594" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nw nx ny nz b">onSubscribe()</code>以同步和异步方式为<code class="fe nw nx ny nz b">MaybeObserver</code>提供取消或处理与<code class="fe nw nx ny nz b">Maybe</code>连接的手段。</p><p id="a9d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nw nx ny nz b">onSuccess()</code>用一个项目通知<code class="fe nw nx ny nz b">MaybeObserver</code>并且已经完成发送基于推送的通知。</p><p id="dc76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nw nx ny nz b">onError</code>通知经历了错误情况的<code class="fe nw nx ny nz b">MaybeObserver</code>。</p><p id="b032" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nw nx ny nz b">onComplete</code>延迟计算正常完成后调用。</p><p id="f752" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看下面的片段</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="26c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当它被执行时，输出将是:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="748e" class="nk lz it nz b gy oe of l og oh">Hello</span></pre><p id="7562" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们看看另一个片段</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="5daa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当执行上面的代码片段时，输出将是:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="e771" class="nk lz it nz b gy oe of l og oh">Completed. No items.</span></pre><p id="2404" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二个发出<code class="fe nw nx ny nz b">onComplete</code> <code class="fe nw nx ny nz b">Completed. No items</code>因为没有要发出的物品。第一个在<code class="fe nw nx ny nz b">onSuccess</code>内输出<code class="fe nw nx ny nz b">Hello</code>，并且在发射后不发射onComplete。也许在某种程度上是。类似于单个可观察值，除了它是一个可选的东西。探索更多关于<a class="ae lq" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Maybe.html" rel="noopener ugc nofollow" target="_blank">或者</a>的信息。</p><h2 id="31e1" class="nk lz it bd ma nl nm dn me nn no dp mi ld np nq mk lh nr ns mm ll nt nu mo nv bi translated">易流动的</h2><p id="2d14" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">“可流动”是一个可观察对象，当可观察对象生成大量数据，而观察者无法处理这些数据发射时，应使用该可观察对象。可观测源不支持背压。我们使用可流动的主要有两个方面:</p><ol class=""><li id="9ee2" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">UI无法处理大量数据流的复杂情况</li><li id="0e30" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">在已经观察到的数据发生变化时得到通知</li></ol><p id="b20f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二种用法常见于聊天应用中，用于频繁更新用户界面</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="52ca" class="nk lz it nz b gy oe of l og oh">public interface Publisher&lt;T&gt; {</span><span id="83ee" class="nk lz it nz b gy oi of l og oh">public void subscribe(Subscriber&lt;? super T&gt; s);</span><span id="ef1d" class="nk lz it nz b gy oi of l og oh">}</span></pre><p id="35f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Subscribe方法请求开始流数据。这是一个工厂方法，可以多次调用，每次都启动一个新的订阅。每个订阅仅适用于单个订户。订阅者应该只订阅一次单一发行者。如果发布者拒绝订阅尝试或以其他方式失败，它将通过<code class="fe nw nx ny nz b">onError</code>回调发出错误信号。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="fddb" class="nk lz it nz b gy oe of l og oh">Flowable.fromArray(1, 2, 3, 4).subscribe(<br/>        <strong class="nz iu">{ </strong>i: Int? <strong class="nz iu">-&gt; </strong>Timber.v("Entry %d\n", i) <strong class="nz iu">}</strong>,<br/>        <strong class="nz iu">{ </strong>e: Throwable? <strong class="nz iu">-&gt;</strong>Timber.v("Failed to process: %s\n", e) <strong class="nz iu">}<br/></strong>) <strong class="nz iu">{ </strong>Timber.v("Done") <strong class="nz iu">}</strong></span></pre><p id="7a12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上是从数组中打印数字的易流动的简单用法。</p><p id="e69f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用可流动时，必须使用称为背压的策略来处理溢流排放。如果不是，它抛出一个异常，比如MissingBackpressureException或<code class="fe nw nx ny nz b">OutOfMemoryError</code>。我们将在接下来的文章中详细讨论这个问题。</p><p id="4cae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">探索更多关于<a class="ae lq" href="https://www.baeldung.com/rxjava-2-flowable" rel="noopener ugc nofollow" target="_blank">的流动</a>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f27e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">奖金</h1><p id="364c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要了解关于RxJava的更多信息，请阅读本系列的前几部分:</p><ul class=""><li id="aead" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp nj nb nc nd bi translated"><a class="ae lq" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">rx Java:Android中的多线程</a></li><li id="ec24" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nj nb nc nd bi translated"><a class="ae lq" href="https://medium.com/better-programming/rxjava-different-ways-of-creating-observables-7ec3204f1e23" rel="noopener">在RxJava中创建可观测量的不同方法—第2部分</a></li><li id="cace" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nj nb nc nd bi translated"><a class="ae lq" href="https://levelup.gitconnected.com/rxjava-understanding-operators-with-the-marble-diagram-fc96addb0beb" rel="noopener ugc nofollow" target="_blank">用弹球图理解运算符—第3部分</a></li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="23e6" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">参考</h1><p id="6ab2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><a class="ae lq" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank">https://github.com/ReactiveX/RxJava</a></p></div></div>    
</body>
</html>