<html>
<head>
<title>Strings, Unicode, and Bytes in Python 3: Everything You Always Wanted to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3中的字符串、Unicode和字节:您一直想知道的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/strings-unicode-and-bytes-in-python-3-everything-you-always-wanted-to-know-27dc02ff2686?source=collection_archive---------0-----------------------#2019-01-13">https://betterprogramming.pub/strings-unicode-and-bytes-in-python-3-everything-you-always-wanted-to-know-27dc02ff2686?source=collection_archive---------0-----------------------#2019-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="05b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Python 3的重要新特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/979b198d6a859d04c7ca398a610503de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4-HMJomLlpkyez75"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hannes_wolf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汉尼斯狼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="4f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以说Python 3中引入的最重要的新特性是默认情况下将<code class="fe lv lw lx ly b">str</code>作为Unicode的新实现，以及文本和二进制数据之间的严格分离。</p><p id="9787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们两人都全心全意地欢迎变革。尤其是默认Unicode的决定，帮助我们消除了开发人员日常工作中的许多麻烦(<em class="lz">谁说的</em> <code class="fe lv lw lx ly b"><em class="lz">UnicodeError</em></code> <em class="lz">？</em>)。尽管如此，对于这一变化仍有一些困惑，所以让我们试着阐明这一全新的事物。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0e41" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">一点历史</h1><p id="326d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><strong class="lb iu">TL；计算机根据一种被普遍认可的称为Unicode的映射将字符转换成数字。Unicode是一个旧的但仍然实际存在的叫做ASCII的映射的超集。这些数字按照许多不同的编码标准保存在内存和文件中。这些编码中最流行的是UTF-8。</strong></p><p id="cb08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">互联网上有大量<a class="ae ky" href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/" rel="noopener ugc nofollow" target="_blank">有趣的</a><a class="ae ky" href="http://kunststube.net/encoding/" rel="noopener ugc nofollow" target="_blank">文章</a>和<a class="ae ky" href="https://betterexplained.com/articles/unicode/" rel="noopener ugc nofollow" target="_blank">文章</a>讲述ASCII和Unicode背后的基本原理，如果你想更深入地了解整个故事，你可能想看看它们。让我们快速回顾一下，以便更好地理解当前的问题。</p><p id="cb41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过去，在电脑上保存文本就像把每个字符转换成0到127之间的数字一样简单，也就是7位空间。这足以存储普通英语作者需要的所有数字、字母、标点符号和控制字符。这种映射是一种公认的标准，称为<a class="ae ky" href="https://en.wikipedia.org/wiki/ASCII#Character_set" rel="noopener ugc nofollow" target="_blank"> ASCII表</a>。</p><p id="59fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当时大多数计算机都是一个字节用8位，这意味着多出来的128个字符有多余的空间。问题是，高于标准ASCII的这个频谱范围是相当自由的，所以不同的组织开始将它用于不同的目的。这最终导致了不同字符表的巨大混乱，相同的数字代表不同字母表中的不同字母。文本文档共享变得一塌糊涂，更别说有几千个字母的亚洲字母表，根本装不下这个256个符号的空间。</p><p id="e728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Unicode的用武之地。一项巨大的努力开始将人类已知的每一个字符和符号映射成一组所谓的<strong class="lb iu">码点</strong>，即代表该符号的十六进制数。于是Unicode consortium决定英文字母' Q '是U+0055，拉丁文字母'è'是U+00E8，西里尔字母'й'是U+0439，数学符号'√'是U+221A，以此类推。你甚至可以为一堆便便<a class="ae ky" href="https://unicode-table.com/en/1F4A9/" rel="noopener ugc nofollow" target="_blank"><em class="lz"/></a>找个字形。出于兼容性原因，前128个数字映射的字符与ASCII完全相同。</p><p id="b43c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，既然我们都同意给每一个曾经设想过的字形分配一个唯一的数字，并且假定有成千上万个这样的符号被映射，我们如何在计算机中存储那些代码点呢？大端还是小端？每个代码点有多少字节？两个字节，也许空间不足？四个字节，也许会浪费一些？可变的字节数？</p><p id="44fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长话短说，人们发明了不同的编码来将码位转换成字节，但其中有一种编码无疑是最好的，也是使用最多的:<a class="ae ky" href="http://www.utf-8.com/" rel="noopener ugc nofollow" target="_blank"> UTF-8 </a>。这是当前Unicode编码的黄金标准。<strong class="lb iu"> </strong>除非你知道自己在做什么，否则很有可能你不想用别的。</p><h2 id="363c" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">没有编码就没有字符串</h2><p id="f629" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果你一直在关注这个讨论，你可能已经了解了在电脑上保存和阅读文本的一个关键点:</p><p id="3c76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">拥有一个不知道编码的字符串毫无意义。</em></p><p id="8eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非你知道它的编码，否则你根本无法解释和解码一个字符串。而且，尽管我们已经认定UTF-8是Unicode解码的黄金标准，但是作为程序员，您可能会在工作中遇到其他编码，并且需要相应地采取行动。</p><p id="521b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您曾经在电子邮件正文或网站上发现奇怪的字符，那是因为该电子邮件或网页没有声明编码，所以您的邮件客户端或浏览器试图猜测编码，但没有成功。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/045bd7d417f3ea53aed8dd3ae567c3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8kIGe2ulD7YGeaJ9i9zjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Google Chrome加载的关于Unicode的西班牙语维基百科页面故意使用了错误的编码。请注意，当Chrome试图以错误的方式解码127以上的代码点时，重音字符是如何被糟糕地解码和呈现的。</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5883" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">那么，Python 3上的Unicode呢？</h1><p id="a9c9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Python 2中的字符串相当混乱。字符串的默认类型是<code class="fe lv lw lx ly b">str</code>，但是它被存储为<code class="fe lv lw lx ly b">bytes</code>。如果您需要在Python 2中保存Unicode字符串，您必须使用一种叫做<code class="fe lv lw lx ly b">unicode</code>的不同类型，通常在创建时在字符串本身前面加上一个<code class="fe lv lw lx ly b">u</code>。在Python 2中，<code class="fe lv lw lx ly b">bytes</code>和<code class="fe lv lw lx ly b">unicode</code>的混合更加痛苦，因为Python允许在混合不同类型时进行强制和隐式转换。这很容易做到，显然也很棒，但大多数时候它只会在运行时引起麻烦。</p><p id="0e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 3彻底改变了这一切。我们这里有两种不同的严格分开的类型:</p><ol class=""><li id="0859" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">str</strong></code>对应Python 2上的前<code class="fe lv lw lx ly b">unicode</code>类型。它在内部表示为一系列Unicode码位。您可以声明一个<code class="fe lv lw lx ly b">str</code>变量，而不用在字符串前面加上<code class="fe lv lw lx ly b">u</code>，因为它现在是默认的。</li><li id="bac1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">bytes</strong></code>大致对应Python 2上以前的<code class="fe lv lw lx ly b">str</code>类型(用于<code class="fe lv lw lx ly b">bytes</code>部分)。它是一种二进制序列化格式，由一系列8位整数表示，适合在文件系统上存储数据或通过互联网发送数据。这就是为什么您只能创建包含ASCII文字字符的<code class="fe lv lw lx ly b">bytes</code>。要定义一个字节变量，只需在字符串前加上一个<code class="fe lv lw lx ly b">b</code>。</li></ol><p id="9b30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">str</code>和<code class="fe lv lw lx ly b">bytes</code>有一套完全不同的方法。你不能以任何方式连接或混合它们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/54f39811ca156bd76521b74457b831cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WO1k7vvQB2v1JtOENnSNNg.png"/></div></div></figure><p id="92c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你被迫把事情搞清楚，这是一件非常好的事情。在Python 3中，如果你做得不好，代码会立即失败，这样可以节省很多以后的调试时间。然而，<code class="fe lv lw lx ly b">str</code>和<code class="fe lv lw lx ly b">bytes</code>之间有着密切的关系，所以Python允许你用两个专用的方法来切换类型:</p><ol class=""><li id="940c" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">使用<strong class="lb iu"> encode() </strong>方法可以将<code class="fe lv lw lx ly b">str</code>编码成<code class="fe lv lw lx ly b">bytes</code>。</li><li id="247f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">使用<strong class="lb iu"> decode() </strong>方法可以将<code class="fe lv lw lx ly b">bytes</code>解码为<code class="fe lv lw lx ly b">str</code>。</li></ol><p id="6a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法都接受一个参数，该参数是用于编码或解码的编码。两者的默认值都是UTF-8。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/524ad6f8c97039e5c6c24050461e5751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*q473F9mgt9yA7CIX1xhCcQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注意在Python解释器上打印时,<code class="fe lv lw lx ly b">bytes</code>字符串是如何加上b的</p></figure><p id="0b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一张图胜过千言万语，所以:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/26590075d3c1d5830ab4c229dfd5c022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQnsjdUrGkRdxaFYBwz_SA.png"/></div></div></figure><p id="f030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">bytes</code>类型没有固有的编码，所以如果你想尝试解码它，你必须知道编码，正如我们在上面看到的几段。再说一遍:<strong class="lb iu">除非你知道某样东西的编码</strong>，否则你无法假装解码它。</p><p id="4efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，没有办法推断出一个<code class="fe lv lw lx ly b">bytes</code>有什么编码。当您处理来自互联网或非您创建的文件的数据时，必须考虑到这一点。事实上，当你解码一个<code class="fe lv lw lx ly b">bytes</code>时，奇怪的事情发生了，它的编码不同于你用来编码<code class="fe lv lw lx ly b">str</code>的编码，就像我们看到的西班牙语维基百科页面一样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/fa60806730f1c7105690f9bf196939d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*nsyhiGFTnasitgDxfNyUGQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果用不同的编码解码，UTF-8编码的€符号会被错误地转换回来</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="825f" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">在Python 3上访问文件</h1><p id="5951" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">正如您所想象的，这对Python 3上的文件读写过程(或其他形式的输入)有着巨大的影响。</p><p id="b0d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python 3中，以<code class="fe lv lw lx ly b">r</code>模式读取文件意味着将数据解码成Unicode并获得一个<code class="fe lv lw lx ly b">str</code>对象。在<code class="fe lv lw lx ly b">rb</code>模式下读取文件意味着按原样读取数据，没有隐式解码，并保存为<code class="fe lv lw lx ly b">bytes</code>。</p><p id="79da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于同样的原因，从Python 2开始，<code class="fe lv lw lx ly b">open()</code>方法接口发生了变化，现在它接受编码参数。如果您仔细阅读，您已经明白这个参数只有在使用<code class="fe lv lw lx ly b">r</code>模式时才有价值，在这种模式下Python将数据解码成Unicode，而在<code class="fe lv lw lx ly b">rb</code>中它是没有用的。</p><p id="7ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解Python不试图猜测编码是很重要的。相反，它使用从<code class="fe lv lw lx ly b">locale.getpreferredencoding()</code>返回的编码。如果您没有传递参数，只是依赖默认值并发现奇怪的事情，那么该方法很可能会返回错误的数据编码。再次:<strong class="lb iu">无编码，无当事人</strong>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5b88" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Python3上Unicode的最佳实践和修复问题</h1><h2 id="fe9c" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">Unicode三明治</h2><p id="bdca" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">伟大的Ned Batchhelder发表了一篇伟大的<a class="ae ky" href="https://nedbatchelder.com/text/unipain.html" rel="noopener ugc nofollow" target="_blank">演讲/文章</a>，如果你经常需要在Python 3中使用字符串，我衷心推荐你。在这个演讲中，他创造了术语<em class="lz"> Unicode三明治</em>来命名在Python中处理文本字符串的一个优秀实践。用他自己的话说，建议的方法是:</p><blockquote class="oj"><p id="01e4" class="ok ol it bd om on oo op oq or os lu dk translated">"字节在外面，unicode在里面，编码/解码在边缘."</p></blockquote><figure class="ou ov ow ox oy kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/92c5dfae2a28e29ef0950608d3d15676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyvQSXsxG7cZILqZ8H5-Wg.png"/></div></div></figure><p id="7b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法是在处理文本时使用一个<code class="fe lv lw lx ly b">str</code>对象，这样就可以访问Python为字符串处理提供的各种方法。但是，当你处理像API这样的外部事物时，就用<code class="fe lv lw lx ly b">bytes</code>吧。这种方法是如此的优秀，以至于一些库甚至可能从你那里抽象出整个过程，并允许输入/输出Unicode，在内部将其全部转换成<code class="fe lv lw lx ly b">str</code>。</p><h2 id="ec9a" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">2 * 3 = 6</h2><p id="71e0" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Python 2程序有一个很大的代码库，一些库仍然以不同的方式支持Py2和Py3，甚至在完全相同的版本中。</p><p id="e16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Benjamin Peterson开发了一个优秀的兼容性库，名为six ，它提供了封装两个主要Python版本之间差异的函数。正如你可能想象的那样，它也有很多字符串管理的东西。您可能想看看它如何帮助您开发交叉兼容的代码。</p><h2 id="d477" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">不要混淆字符串和字节</h2><p id="ddc1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">处理字符串时出现的大多数错误都是由于试图混淆<code class="fe lv lw lx ly b">str </code>和<code class="fe lv lw lx ly b">bytes</code>而导致的。如果您在2.x世界中成熟了自己的Python经验，这种情况可能更为典型，因为这两种类型之间的界限更加模糊。如果仍然出现类似以下的错误:</p><pre class="kj kk kl km gt oz ly pa pb aw pc bi"><span id="92cc" class="ne mi it ly b gy pd pe l pf pg">TypeError: a bytes-like object is required, not 'str'</span></pre><p id="8784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和类似的东西，检查您是否在正确的对象上使用了正确的方法。此外，检查您是否根据需要正确打开了文件。在Python 2上运行多年的包容测试很容易失败:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/4541b1d62f84312f09735889331955cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8jU_frvYje3sXBCPkxkJw.png"/></div></div></figure><p id="1a91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行的<code class="fe lv lw lx ly b">if &lt;string&gt; in &lt;object&gt;</code>条件失败，因为我们以二进制模式打开文件，然后让Python用<code class="fe lv lw lx ly b">bytes</code>对象处理字符串。以读取模式打开文件，或者甚至解码<code class="fe lv lw lx ly b">bytes</code>到<code class="fe lv lw lx ly b">str</code>，都可以正常工作。</p><h2 id="8502" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">了解您的编码</h2><p id="51f3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我再强调一下这个概念:不知道编码就不能假装解码<code class="fe lv lw lx ly b">bytes</code>。这些信息无法从字节本身可靠地推断出来，如果您正在对不受您控制的文件或API进行I/O操作，您需要获取或共享这些信息。正如我们之前看到的，如果你传递给它错误的编码，Python可能会解码你的<code class="fe lv lw lx ly b">bytes</code>,但是你可能会得到垃圾。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c225" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">加分段:io.stringIO和io.bytesIO</h1><p id="9c9f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">与我们刚刚看到的关于字符串的主要变化密切相关的是另一个变化，涉及以前的Python2 <code class="fe lv lw lx ly b">StringIO</code>和<code class="fe lv lw lx ly b">cStringIO</code>模块。</p><p id="99da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了两个模块在API和性能上的细微差别，<code class="fe lv lw lx ly b">StringIO</code>和<code class="fe lv lw lx ly b">cStringIO</code>都基于Py2的字符串管理方法，接受Unicode或bytes字符串。由于Py3有一个完全不同的方法，这两个模块已经被删除，并由<code class="fe lv lw lx ly b">io</code>模块中的两个新类代替。它们的用法很简单:</p><ol class=""><li id="9662" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">io.BytesIO()</code>接受一个字节字符串作为参数。</li><li id="dc13" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">io.StringIO()</code>接受Unicode字符串和编码作为参数。</li></ol><p id="b39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么简单。它们返回两个类似文件的对象，您可以根据三明治模型照常使用。你可以在<a class="ae ky" href="https://docs.python.org/3.0/library/io.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中读到更多关于这两者的内容。</p></div></div>    
</body>
</html>