# Python 中的上下文管理器—超越“以 open()作为文件”

> 原文：<https://betterprogramming.pub/context-managers-in-python-go-beyond-with-open-as-file-85a27e392114>

## 你在别处用过 with 语句吗？

![](img/433a964eb21b710b795a15dc3ad2b04b.png)

[天一马](https://unsplash.com/@tma?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

# 介绍

当我们在 Python 中处理文件时，最常见的操作可能就是使用内置的`open()`函数。这创建了一个文件对象，它允许我们根据需要读写数据。当我们使用`open()`函数时，我们几乎总是将该函数与`with`语句一起使用，因为我们要么从[官方参考](https://docs.python.org/3/library/functions.html#open)的 open 函数中，要么从一些在线教程中学到了它的用法。基本形式如下所示。

写文件

通过运行上面的代码，您会看到在您当前的工作目录中已经创建了一个名为`hello.txt`的文件。为了验证`Hello World!`字符串已经被写入文件，我们可以打开文件来读取数据:

读取文件

正如您在上面看到的，我们能够读取文件，通过指定读取模式使用`open()`函数打开它(`r`，与我们之前用于写入目的的`w`相反)。

# 自动关闭文件

我们中的许多人可能知道当我们在这里打开一个文件时为什么要使用`with`语句。对于不了解的人，请先看看下面这段代码:

关闭的文件

在上面的代码中，我们通过向文件追加额外的字符串来修改文件(注意，我们使用`a`模式进行追加)。当我们完成了`with`语句时，我们发现文件被关闭了，尽管我们没有显式地调用 file 对象上的`close()`方法。这正是`with`语句为我们做的——当我们退出`with`语句时，它自动关闭文件。

但你可能想知道为什么这是一件大事，它为我们关闭文件。考虑下面这个微不足道的例子:

无法关闭文件的问题

如图所示，我们首先通过添加一些新数据来修改文件。但是后来我们忘了在这个操作之后关闭文件。当我们再次读取该文件时，我们看不到我们认为已经做出的更改，这可能会导致我们的代码中出现意外的错误。如前所述，如果我们使用了 with 语句，Python 将清除所有文件操作，自动为我们关闭文件。更重要的是，想象一下我们可以对文件进行更复杂的操作，一些操作可能涉及到异常，使程序停止运行。在这些可能的场景中，由于使用了`with`语句，文件仍然有机会被安全地自动关闭。

# 上下文管理器

从更广泛的意义上来说，用于文件打开的`with`语句是使用上下文管理器的一个例子。

什么是上下文管理器？它是一个 Python 对象，当您使用特定资源时，它会为您做家务。具体来说，上下文管理器*为你建立一个临时上下文，并在所有操作完成后析构该上下文。*

在文件打开操作方面，上下文管理器做什么可以用`try` *、* `except` *、*、`finally`语句来演示。考虑下面的伪代码作为`with`语句的可能实现:

try…except…finally 语句

如上所示，上下文管理器为您打开文件并创建一个文件对象，它将被进一步操作。当我们完成操作以及操作过程中出现的任何异常时，上下文管理器将为我们关闭文件。如上所示，因为文件是共享资源，这是您的责任(当然，在上下文管理器的帮助下使事情变得更容易)，所以当您完成操作时释放它们以便其他进程可以访问它们是很关键的。

# 线程管理的使用

如前所述，当我们需要处理共享的东西时，最好使用`with`语句。其中一种用途是在多线程项目中处理数据。您可能知道，当多线程访问同一个数据池时，事情会变得很混乱。类似我展示的数据附加文件操作的情况会更容易发生。一个操作是追加数据，而另一个操作是在另一个文件操作中读取旧数据。

例如，一个线程试图向字典添加数据，而另一个线程试图迭代字典。很快一切都会脱离你的控制。为了解决这个问题，我们可以使用线程锁来帮助我们减少数据混乱。重要的是，因为我们希望以临时的方式完全控制资源，所以这是带有语句的*的最佳用例。让我们考虑下面的代码作为一个简单的例子。*

如您所见，使用`with`语句可以极大地提高代码的简洁性。更重要的是，它会在`with`语句中操作完成时自动释放锁。如果不使用上下文管理器(即 with 语句)，我们将不得不小心地手动管理这些资源。如果我们忘记释放锁，我们的程序将会遇到意想不到的问题。

# 上下文管理协议

为了自己管理一些资源，我们可以自己创建一个上下文管理器。一种方法是实现上下文管理协议的方法。你可以把它概念化为一个[鸭子打字](https://medium.com/better-programming/what-are-duck-typing-and-monkey-patching-in-python-2f8e3d6b864f)——我们将简单地定义`__enter__`和`__exit__`魔法方法，而不像你在其他编程语言中可能做的那样正式地符合协议或实现接口。以下代码向您展示了我们如何做到这一点的概念证明:

如上所示，我们简单地定义了一个类，它实现了`__enter__`和`__exit__`方法，这将使这个类的实例能够为我们管理上下文。从语法角度来看，我们可以在带有语句的*中使用这个类，如第 12 行所示。打印文本清晰地向我们展示了这些操作是如何很好地协调的。具体来说，创建的实例(如第 15 行所示)将调用`__enter__`方法(如第 16 行所示)来启动上下文，然后我们自己运行操作(如第 17 行所示)，最后，上下文管理器将通过调用`__exit__`方法来退出管理。*

## contextlib 模块

您可能会发现，实现特殊的方法`__enter__`和`__exit__`来创建我们自己的上下文管理器有点乏味。有了标准 Python 库中的 [contextlib 模块](https://docs.python.org/3/library/contextlib.html)，上下文管理就容易多了。对整个模块的全面回顾超出了本文的范围，我将只关注模块中创建上下文管理器的特定方法。但是在我们这样做之前，让我们后退一步，先回顾一下 decorator，因为 decorator 技术在这里是相关的。

装饰器是修改其他功能的行为而不影响其核心功能的功能。换句话说，被修饰的函数会做它应该做的任何事情，但是修饰者给它添加了一些味道。我们可以考虑下面的例子来快速更新装饰概念:

装饰者的基本形式

对于 decorators，您只需要创建一个接受另一个函数作为输入的函数。装饰是在装饰函数中定义的操作。在这种情况下，我们只是简单地在函数调用前后做记录。要使用装饰器，我们只需在装饰器函数名前面加上@符号。可以说，调用修饰函数(第 15 行)成功地导致了函数调用前后的额外日志记录。

有了对装饰者的基本理解，让我们看一个使用`contextlib`模块来帮助我们管理上下文的例子，代码如下:

我们使用装饰器函数`contextmanager`来装饰`context_manager_example`函数。在函数体中，您可能会注意到一些不寻常的东西——`yield`关键字。您可能在学习生成器时见过`yield`关键字，生成器是一种迭代器，当它们被要求这样做时会呈现元素(称为惰性求值)。在这些用例中，产出意味着生产。你可以在我之前的文章中了解更多关于生成器的知识(这里[这里](https://medium.com/swlh/generators-in-python-5-things-to-know-c76a1f60427a)那里[那里](https://medium.com/better-programming/python-7-advanced-features-that-you-may-not-know-about-generators-574a65fd6e45))。

除了产生的意思，让步也可以表示让步，这正是在上下文管理修饰期间发生的。具体来说，一旦上下文管理器(修饰函数`context_manager_example`)完成设置，它就会执行，从而允许 with 语句中的代码运行。操作完成后，它会重新获得控制权。重要的是，Python 中的 yield 在 Python 中进行了特殊处理，这样我们就可以控制它，它将从它被产生的地方运行。这就是为什么跟在`yield`关键字后面的`print`函数只在 with 语句中的操作完成后被调用一次。

# 外卖食品

在本文中，我们通过使用`with`语句的文件操作的例子回顾了上下文管理器的概念。我们知道是上下文管理器通过关闭文件来帮助我们做家务。

从更广泛的意义上来说，上下文管理器对于管理打算在您的程序或计算机中的其他程序内共享的资源非常有用。上下文管理器帮助我们负责任地管理这些共享资源的获取和释放。我们还回顾了如何覆盖`__enter__`和`__exit__`方法来创建定制的上下文管理器类。或者，我们可以利用`contextlib`模块使用 decorators 创建上下文管理器。

然而，正如你可能注意到的，有些事情我们没有涉及。例如，`__exit__`方法的函数签名有其他我们没有实现的参数，比如异常处理。这些参数的全面实施应该是逐案评估的。如果有兴趣，可以参考一些比较现实的例子来学习更高级的知识，比如 sqlite3 模块中的事务管理。这里有一些快速参考。

# 参考

*   [在 SQLite 数据库操作中使用上下文管理](https://docs.python.org/3/library/sqlite3.html#using-the-connection-as-a-context-manager)
*   [context lib 模块官方文档](https://docs.python.org/3/library/contextlib.html)
*   [穿线并锁紧](https://docs.python.org/3/library/threading.html#using-locks-conditions-and-semaphores-in-the-with-statement)
*   [PEP 343:【with】语句](https://www.python.org/dev/peps/pep-0343/)