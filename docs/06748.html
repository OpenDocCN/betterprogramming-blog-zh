<html>
<head>
<title>The Reason Behind if __name__ == ‘__main__’ in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中if __name__ == '__main__ '背后的原因</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-reason-behind-if-name-main-in-python-e633634f0dd0?source=collection_archive---------0-----------------------#2020-11-02">https://betterprogramming.pub/the-reason-behind-if-name-main-in-python-e633634f0dd0?source=collection_archive---------0-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3af8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么有必要？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36c6d0bcb88bd45041dbe0307bd5e9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_aBkfe7jph-QGs8BvQvGSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片由<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">碳</a>生成</p></figure><p id="c1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能以前见过这个:这个语法经常被忽略，因为它似乎不会妨碍代码的执行。这可能看起来没有必要，但只有在处理单个Python文件时才是这样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2d35" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">让我们开始吧！</h1><p id="36c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从从左到右解构这个陈述开始。我们已经知道什么是if语句<strong class="lb iu"> <em class="mz"> </em> </strong>了；然而，陈述中最重要的部分是被比较的两个事物。</p><p id="b8a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说<code class="fe na nb nc nd b">__name__</code>。这是用来表示当前正在运行的文件的名称，但是有一个技巧。当前正在运行的文件将始终具有值<code class="fe na nb nc nd b">__main__</code>。</p><p id="55ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初这听起来令人困惑，但让我们澄清一下。</p><p id="4918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建两个Python文件:</p><ul class=""><li id="8233" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">current_script.py</code></li><li id="322c" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">other_script.py</code></li></ul><p id="6219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请确保这些文件在同一目录/文件夹中。</p><p id="90f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe na nb nc nd b">other_script.py</code> <strong class="lb iu"> </strong>文件中，我们将添加一个双打印的语句，如下所示。</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="7b05" class="nw md it nd b gy nx ny l nz oa">print("****inside other script.py*****")</span><span id="21f4" class="nw md it nd b gy ob ny l nz oa">print("__name__ is ",__name__)</span></pre><p id="341d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这个<code class="fe na nb nc nd b">other_script.py</code> <strong class="lb iu"> </strong>文件。</p><p id="fc14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>我将在终端中使用Python运行这个文件，如下图所示。还要注意，我是在Windows操作系统上工作的。</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="cc1a" class="nw md it nd b gy nx ny l nz oa">python other_script.py</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2b55de3a3bcdace2f3b7300022083b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*vwW0SwCL1QfO0twTf6yLsA.gif"/></div></figure><p id="7d40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="9c11" class="nw md it nd b gy nx ny l nz oa">****inside other script.py*****<br/>__name__ is  __main__</span></pre><p id="097e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你意识到这正如我之前所说的。正在执行的文件将始终具有值<code class="fe na nb nc nd b">__main__</code>。这代表了我们应用程序的入口点。</p><p id="ad01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python和几乎所有编程语言中，我们可以将其他文件导入到我们的应用程序中。我们现在进入<code class="fe na nb nc nd b">current_script.py</code> <strong class="lb iu"> </strong>并输入以下代码:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="d969" class="nw md it nd b gy nx ny l nz oa">import other_script</span><span id="2f60" class="nw md it nd b gy ob ny l nz oa">print("")</span><span id="ef4a" class="nw md it nd b gy ob ny l nz oa">print("****inside current script.py*****")</span><span id="89dc" class="nw md it nd b gy ob ny l nz oa">print("__name__ is ",__name__)</span></pre><p id="e047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码导入了<code class="fe na nb nc nd b">other_script.py</code> <strong class="lb iu"> </strong>，顶部是<code class="fe na nb nc nd b">import</code>语句，后面是<code class="fe na nb nc nd b">print(“****inside current script.py*****”)</code>来验证我们在<code class="fe na nb nc nd b">current_script.py</code>文件中。</p><p id="755d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，因为我们在文件顶部导入了<code class="fe na nb nc nd b">other_script</code>，这意味着<code class="fe na nb nc nd b">other_script.py</code>的全部内容将被注入到<code class="fe na nb nc nd b">import other_script</code>所在的位置。</p><p id="942c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，请仔细记下我们运行<code class="fe na nb nc nd b">other_script.py</code>时的输入。现在观察当我们执行<code class="fe na nb nc nd b">current_script.py</code>时会发生什么。</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="d74d" class="nw md it nd b gy nx ny l nz oa">python <!-- -->current_script.py</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d7a18e6a53797f11bde9b90862211057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*xUf1RK0OnTA1TuiR3CqVQg.gif"/></div></figure><p id="ae2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="c218" class="nw md it nd b gy nx ny l nz oa">****inside other script.py*****<br/>__name__ is  other_script</span><span id="dd46" class="nw md it nd b gy ob ny l nz oa">****inside current script.py*****<br/>__name__ is  __main__</span></pre><p id="c6cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在会意识到，以前当我们运行<code class="fe na nb nc nd b">other_script.py</code>时，它给我们的<code class="fe na nb nc nd b">__name__</code>值是<code class="fe na nb nc nd b">__main__</code>。但是现在，因为我们在<code class="fe na nb nc nd b">current_script.py</code>中将其作为导入运行，所以<code class="fe na nb nc nd b">__name__</code>的值突然变成了导入脚本的名称<code class="fe na nb nc nd b">other_script</code>。</p><p id="4b8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<code class="fe na nb nc nd b">current_script.py</code>的<code class="fe na nb nc nd b">__name__</code>值为<code class="fe na nb nc nd b">__main__</code>。这又回到了我之前强调的:当前正在运行的文件将总是有值<code class="fe na nb nc nd b">__main__</code>。</p><p id="1fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们现在把这一切放在一起。</p><p id="2072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您当前正在运行的文件将始终是<code class="fe na nb nc nd b">__main__</code>，而任何其他导入的文件都不是。它们将具有各自文件的名称。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e50a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用例</h1><p id="6c73" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您的程序有多个Python文件时，这个语法就很方便了。</p><p id="1517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个有两个类的程序。一个<code class="fe na nb nc nd b">Name</code>级和一个<code class="fe na nb nc nd b">Person</code>级。这两个类将被放在两个独立的文件中，<code class="fe na nb nc nd b">name.py</code>和<code class="fe na nb nc nd b">person.py</code>。<code class="fe na nb nc nd b">Person</code>类在该系统中使用<code class="fe na nb nc nd b">Name</code>类。</p><p id="2bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从在<code class="fe na nb nc nd b">name.py</code>文件中构建<code class="fe na nb nc nd b">Name</code>类开始。这是一个简单的类，只有两个属性，<code class="fe na nb nc nd b">fname</code>(名字)和<code class="fe na nb nc nd b">lname</code>(姓氏)，以及它们对应的getters和setters。</p><p id="c9aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">__repr__</code>是打印对象时的默认输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="8776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了我们的语法<code class="fe na nb nc nd b">if__name__ == “__main__:”</code>。根据我们的理解，我们可以说，只有在主文件被执行的情况下，if语句的主体才会被执行——这意味着它不是导入。</p><p id="3512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们为什么要这样做呢？</p><p id="b39b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这样做是因为当我们希望只对当前运行的文件执行某些操作时，这是最重要的步骤之一。在这个场景中，我们编写了一个<code class="fe na nb nc nd b">Name</code>类，并且正在测试它的功能。</p><p id="73d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="190b" class="nw md it nd b gy nx ny l nz oa">fname=Jordan;lname=Williams</span></pre><p id="d322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的输出可以看出，我们能够测试<code class="fe na nb nc nd b">Name</code>类的功能。然而，在我们构建另一个类之前，这个概念不会被完全理解。</p><p id="ba0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建我们的<code class="fe na nb nc nd b">person.py</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="c8c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe na nb nc nd b">from name import Name</code>，我在文件中导入了<code class="fe na nb nc nd b">Name </code>类，它在第7行<code class="fe na nb nc nd b">self.name = <strong class="lb iu">Name</strong>(fname, lname)</code>中使用。</p><p id="3c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="f1ed" class="nw md it nd b gy nx ny l nz oa">201107<br/>John Brown<br/>Male</span></pre><p id="cefc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是测试我们的<code class="fe na nb nc nd b">Person</code>类的输出。请注意，<code class="fe na nb nc nd b">Name</code>类没有输出，因为它被包含在条件<code class="fe na nb nc nd b">__name__ == “__main__”</code>中，并且它当前不是主文件。</p><p id="1aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们将<code class="fe na nb nc nd b">__name__ == “__main__”</code>从<code class="fe na nb nc nd b">name.py</code>中移除，看看有什么不同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7e79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe na nb nc nd b">__name__ == “__main__”</code>没有被移除。我们现在将运行我们的<code class="fe na nb nc nd b">person.py</code>文件。</p><p id="fc1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="d8c0" class="nw md it nd b gy nx ny l nz oa"><strong class="nd iu">fname=Jordan;lname=Williams</strong><br/>201107<br/>John Brown<br/>Male</span></pre><p id="aa96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看，这里我们只想测试<code class="fe na nb nc nd b">Person</code>类的功能。然而，我们也从<code class="fe na nb nc nd b">Name</code>类获得输出。</p><p id="1838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经创建了一些Python库，并希望将该功能扩展到另一个类，但不希望该库在当前脚本中自动运行，这也可能是一个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="562f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">其他语言</h1><p id="1e43" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有些涉足其他编程语言的人可能已经注意到，这与其他语言中的main方法或函数是一样的。编程语言，如带有<code class="fe na nb nc nd b">public static void main(String[] args)</code>的Java、带有类似<code class="fe na nb nc nd b">public static void Main (string[] args)</code>的C#和带有<code class="fe na nb nc nd b">int main(void)</code>的C #都有某种主函数或方法来执行多个文件/代码脚本。</p><p id="da20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看另一种语言中的等价代码。</p><p id="c52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以Java为例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b64" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="d47d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，您希望只在当前正在执行的文件中运行一些逻辑。这在测试单个代码单元时很方便，不会妨碍其他文件的执行。这在构建依赖于其他库的库时会很方便。您不希望在您所在的代码中恶意执行另一个库。</p></div></div>    
</body>
</html>