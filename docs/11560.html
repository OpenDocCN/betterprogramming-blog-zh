<html>
<head>
<title>Still Stuck on Java 11? Here’s What You’re Missing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">还卡在Java 11上？这就是你错过的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/still-stuck-on-java-11-heres-what-you-re-missing-7b189e177e07?source=collection_archive---------9-----------------------#2022-03-30">https://betterprogramming.pub/still-stuck-on-java-11-heres-what-you-re-missing-7b189e177e07?source=collection_archive---------9-----------------------#2022-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cee6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">超过60%的开发者希望在未来12个月内升级到Java 17 LTS。了解最新最棒的功能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/373be10a261f1df5eb959c62819fbe80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PUfbKnaPAVv9vAyE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图为<a class="ae ky" href="https://unsplash.com/@rshunev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> RShunev </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="9a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java 11已经存在了惊人的时间。它已经是近四年来的长期支持版本(LTS)。尽管新的更新每半年发布一次，但对于许多公司来说，避免这些临时发布并不罕见。相反，他们更喜欢坚持使用更受支持的语言版本。</p><p id="d0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据JRebel最近发布的《2022年Java开发人员生产力报告》( Java Developer Productivity Report 2022,只有12%的开发人员在他们的应用程序中使用Java 12或更高版本，其中Java 8和11分别占37%和29%(其他JVM语言占其余部分)。</p><blockquote class="lw"><p id="15ac" class="lx ly it bd lz ma mb mc md me mf lu dk translated">“…只有12%的开发人员使用Java 12或更高版本…”—JRebel 2022</p></blockquote><p id="8372" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">不过，对我们程序员来说，未来看起来确实更光明。截至2021年9月，Java 17成为新的长期支持版本。这提供了更多的保证，并使规避风险的企业能够推进他们的技术堆栈。事实上，根据JRebel的说法，超过60%的开发者希望在未来12个月内升级到最新的Java LTS。</p><p id="97fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过去的几年感觉无穷无尽，很容易忘记Java在这段时间里发布了哪些特性。在这篇文章的其余部分，我们将简要地浏览不同的版本，从11到17，并提醒我们自己等待的款待。</p><p id="d135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，在我们开始之前，值得注意的是，我们将主要关注核心语言特性，而不是预览版或实验版。这里的重点是你可以放心地在日常工作中使用的工具，而不是对未来的一瞥。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="bf8a" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Java 11 (LTS)功能概述</h1><p id="716f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">与其直入主题——因为这么多开发人员都是从Java 8开始的——不如让我们快速回顾一下Java 11给了我们什么。</p><h2 id="41c8" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">用一个命令运行文件</h2><p id="a2c0" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">从Java 11开始，作为<code class="fe ob oc od oe b">java</code> <em class="lv"> </em>命令的一部分，可以直接从源文件运行代码，而不必通过写-编译-执行循环来加速代码。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="6bec" class="np mt it oe b gy oj ok l ol om">$ java RunMe.java<br/>Yoo hoo!</span></pre><p id="7b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于较大的项目来说不是特别有用，但是如果您想编写小的实用程序、脚本之类的东西，它会很有帮助。</p><p id="60b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以在文件中包含shebang头文件，并像运行任何其他脚本一样运行它。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="7b47" class="np mt it oe b gy oj ok l ol om">#!/usr/bin/java --source 11</span></pre><h2 id="1087" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">新的字符串方法</h2><p id="4914" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">String中增加了一些新的实用方法，包括:</p><ul class=""><li id="77c8" class="on oo it lb b lc ld lf lg li op lm oq lq or lu os ot ou ov bi translated"><code class="fe ob oc od oe b">.isBlank</code> —如果为空或仅包含空白，则返回true。</li><li id="db68" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><code class="fe ob oc od oe b">.lines</code> —将字符串转换为由行分隔符分隔的字符串流。</li><li id="86f1" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><code class="fe ob oc od oe b">.strip</code> —从字符串中删除所有前导和尾随空格。</li><li id="505f" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><code class="fe ob oc od oe b">.repeat</code> <strong class="lb iu"> </strong> —将一个字符串重复n次，生成一个新字符串。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="ec4e" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">新文件方法</h2><p id="7b77" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">引入了两种方便的方法——<code class="fe ob oc od oe b">readString</code>和<code class="fe ob oc od oe b">writeString</code>——直接从文件中读取和写入字符串。不再需要摆弄<code class="fe ob oc od oe b">InputStreams</code>或依赖第三方库来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="26f3" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">集合到数组</h2><p id="f6b3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">一个稍微方便一点的<em class="lv"> toArray </em>方法，它采用一个<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/IntFunction.html" rel="noopener ugc nofollow" target="_blank">IntFunction</a></code>而不是一个数组的实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="4f7b" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">非谓词</h2><p id="fea6" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">颠倒谓词的一种简便方法——<em class="lv">n</em>ot<em class="lv">——</em>。与<em class="lv">求反</em>功能相同，但在许多情况下可读性更好(<em class="lv">无效</em>比<em class="lv">求反(有效)</em>更容易阅读)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="e2e8" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">Lambda局部变量语法</h2><p id="959d" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">包括了在Lambda中使用<em class="lv"> var </em>的能力。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="116d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然可以忽略类型信息，为什么还要麻烦呢？它允许你对论点使用修饰语，比如<code class="fe ob oc od oe b">@NotNull</code> <em class="lv">，</em>，当你不使用任何声明时，这是不可能的。当然，您可以对完整类型使用注释，但这要简洁得多。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="e8f5" class="np mt it oe b gy oj ok l ol om">(@NotNull var b) -&gt; b</span></pre><h2 id="c28e" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">新建HTTP客户端</h2><p id="76b2" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在<em class="lv"> java.net.http </em>包中可以找到一个新的内置HTTP客户端。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="092a" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">飞行记录器</h2><p id="437a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在Java 11之前，Java飞行记录器曾经是Oracle JDK的商业部分。现在它已经开源了，是OpenJDK的一部分。</p><p id="18ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种分析应用程序的轻量级方法，并提供关于JVM行为的统计数据，包括内存使用、对象分配和垃圾收集。捕获之后，您可以将输出输入到Java Mission Control工具中，以可视化您的发现。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="ed7d" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Java 12</h1><h2 id="272a" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">新的字符串方法</h2><p id="abd9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Java 12首先引入了对String API的进一步增强。这些增加的内容似乎集中在即将到来的文本块上(参见Java 15)。</p><ul class=""><li id="99b2" class="on oo it lb b lc ld lf lg li op lm oq lq or lu os ot ou ov bi translated"><code class="fe ob oc od oe b">.indent</code> —根据给定的偏移量调整每行的缩进，偏移量可以是正的，也可以是负的。</li><li id="86c2" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><code class="fe ob oc od oe b">.transform</code> —将变换函数应用于产生任何类型的字符串。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="4314" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">文件不匹配</h2><p id="9760" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe ob oc od oe b">Files.mismatch</code>为我们提供了一个方便的函数，可以在两个文件的比较中找到第一个不匹配的字节。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="0d49" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">发球收集器</h2><p id="945e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">收集器是两个下游收集器的组合。传递给结果收集器的每个元素都由两个下游收集器处理，然后使用指定的合并函数将它们的结果合并到最终结果中。</p><p id="aa88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的经典用例是计算平均值。所有的值都被传递给两个下游收集器，一个是sum，一个是count，最后的结果汇总在一起(<code class="fe ob oc od oe b">sum</code> / <code class="fe ob oc od oe b">count</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="7550" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">新数字格式化程序</h2><p id="971e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">压缩数字格式化程序提供了一个本地化的、简短的数字表示形式，比如“10K”或“一万”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="a620" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Java 13</h1><p id="7654" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们跳过这个，好吗？Java 13没有引入任何新的语言特性。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="2629" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Java 14</h1><h2 id="cf0e" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">切换表达式</h2><p id="b886" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Switch表达式为我们提供了将switch语句的结果赋给变量的有用能力。这(希望)是更强大的模式匹配之旅的第一步，就像你在<a class="ae ky" href="https://docs.scala-lang.org/overviews/scala-book/match-expressions.html" rel="noopener ugc nofollow" target="_blank"> Scala </a>、<a class="ae ky" href="https://doc.rust-lang.org/rust-by-example/flow_control/match.html" rel="noopener ugc nofollow" target="_blank"> Rust </a>或其他函数式/函数式语言中发现的那样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="40ce" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">有用的空指针</h2><p id="5dd7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">生产日志中的NullPointerException甚至会让最顽强的开发人员感到恐惧。预防胜于治疗(空值可能是一个巨大的错误，但至少Java现在在NPE的情况下给了我们更详细的错误消息——例如<em class="lv">“不能调用“String.toLowerCase()”，因为“missing”是空值”。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="914b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Java 15</h1><h2 id="6a44" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">文本块</h2><p id="ecde" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">终于来了！通过支持文本块，Java已经赶上了几乎所有其他语言。没有更多的<em class="lv"> "…\n" + "…\n" </em>链，这些链可以简化构建DB查询、测试中的JSON块等工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="86bc" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">隐藏类</h2><p id="7e82" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这是一个有点神秘的问题。Java 15引入了使用不能被其他类链接或通过反射发现的类的能力。然而，它们非常高效，这就是吸引力所在。主要供使用动态字节码或JVM语言(Scala、Groovy、Clojure等)的人使用。</p><p id="f972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在Java 15中，lambda表达式使用隐藏类，这使得它们更有效。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="2205" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">谢南多厄河</h2><p id="6d6d" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Shenandoah是一个低暂停时间垃圾收集器，它通过在运行Java程序的同时执行更多的垃圾收集工作，以更高的CPU利用率为代价来减少GC暂停时间。</p><p id="d3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管它已经在许多版本中处于预览状态，但它终于为黄金时间做好了准备。</p><h2 id="cf5d" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">ZGC</h2><p id="5162" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">另一个生产就绪的垃圾收集器，目标与Shenandoah相似。Z垃圾收集器(ZGC)是一个非常可伸缩的低延迟垃圾收集器。ZGC可以同时执行所有高开销的工作，不会停止应用程序线程的执行超过10毫秒，这使得它非常适合要求低延迟和/或使用非常大的堆(高达数TB)的应用程序。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="300c" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Java 16</h1><h2 id="1434" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">白天</h2><p id="f46a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe ob oc od oe b">DateTimeFormatter</code> <em class="lv"> </em>支持新符号<em class="lv"> B </em>作为am/pm的替代日时段。比如<em class="lv">“上午”</em>或者<em class="lv">“下午”</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="7bd3" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">Stream.toList</h2><p id="c8cb" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">与其用<code class="fe ob oc od oe b">.collect(Collectors.toList())</code>把<code class="fe ob oc od oe b">Stream</code>变成<code class="fe ob oc od oe b">List</code> <em class="lv">，</em>流API引入了一个便利的方法<em class="lv">。为了达到同样的目的。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="9cca" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">记录</h2><p id="8858" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">记录是该语言的另一个重要补充，在某些方面类似于枚举，是一种更严格的类形式，专门促进不变性。</p><p id="e3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用Java创建不可变的数据对象总是有点麻烦。你必须确保所有的字段都被标记为最终的，并且适当的<code class="fe ob oc od oe b">equals</code> / <code class="fe ob oc od oe b">hashCode</code> / <code class="fe ob oc od oe b">toString</code>实现都存在并被检查。</p><p id="8d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记录为我们提供了一个开箱即用的不可变结构，从而使这变得容易得多。字段不能修改，另外<code class="fe ob oc od oe b">accessors</code>、<code class="fe ob oc od oe b">equals</code>、<code class="fe ob oc od oe b">hashCode</code>和<code class="fe ob oc od oe b">toString</code>都是免费提供给你的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="fd2d" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">实例的模式匹配</h2><p id="099a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这种简单形式的模式匹配为您提供了匹配的对象，正确地输入并准备好，而不是在<code class="fe ob oc od oe b">instanceof</code>检查后用强制转换来丢弃您的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="1472" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">本地枚举</h2><p id="7062" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Java 15允许我们创建作用于一个方法的枚举。尽管用途可能相当有限，但在函数的上下文中标记数据可能会被证明是有用的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="45b7" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">本地接口</h2><p id="d184" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">与前面的特性相似，我们也可以创建接口，并在方法的上下文中用匿名类实现它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="a05d" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Java 17 (LTS)</h1><h2 id="0d37" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">密封类/接口</h2><p id="3399" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Java 17最大的特点是<em class="lv">密封类</em>。在某些方面类似于枚举，密封类限制了可以扩展或实现类/接口的类的集合。</p><p id="5eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举和密封类之间的主要区别在于，前者将您限制在一组固定的实例中。密封类更进了一步，它把你限制在可能有多个实例的值的种类上。</p><p id="a256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，一群狮子不能用一个枚举值来表示，因为只有一只狮子。或者，一个密封的接口将允许许多不同的lions存在，同时仍然遵守对类型的限制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="0b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有助于增强语言的类型安全性，并将再次增加Java即将推出的模式匹配特性。通过了解可以实现接口的完整类集，编译器可以更有力地保证您已经满足了每一种边缘情况，例如，switch语句。不再需要使用<em class="lv">默认</em>处理，因为编译器可以在编译时而不是运行时捕获错误。</p><h2 id="6a59" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">还原总是严格的浮点语义</h2><p id="ec91" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这主要是针对科学应用，并使浮点运算始终严格。在Java 1.2之前就已经是这种情况了，但是由于硬件架构的挑战，不得不被削弱。现在已经恢复了。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d0c8" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Java 18和LTS的未来</h1><p id="3e3d" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Java 18在撰写本文的一周前发布，即2022年3月22日。它提供了成千上万的性能、稳定性和安全性改进，尽管这次没有主要的语言特性(尽管默认情况下<em class="lv">UTF-8</em>和包含一个<em class="lv">简单网络服务器</em>)。这不是一个LTS版本，但是延续了Java快节奏的发布节奏。与往常一样，还包括了许多预览功能，请参见<a class="ae ky" href="https://www.oracle.com/news/announcement/oracle-releases-java-18-2022-03-22/" rel="noopener ugc nofollow" target="_blank">https://www . Oracle . com/news/announcement/Oracle-releases-Java-18-2022-03-22/</a>了解更多详细信息。</p><p id="f6bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于Java的长期支持版本，<a class="ae ky" href="https://blogs.oracle.com/java/post/moving-the-jdk-to-a-two-year-lts-cadence" rel="noopener ugc nofollow" target="_blank"> Oracle最近提议</a>将其从目前的3年周期加速到更短的2年周期。这将导致Java 21成为下一个LTS，而不是Java 23，并将加快采用的步伐，让我们更多的人比以前更早地开始使用这种语言的最新和最棒的特性。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="7645" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">资源</h1><ul class=""><li id="4a85" class="on oo it lb b lc nk lf nl li pd lm pe lq pf lu os ot ou ov bi translated"><a class="ae ky" href="https://www.jrebel.com/resources/java-developer-productivity-report-2022" rel="noopener ugc nofollow" target="_blank">https://www . JRE bel . com/resources/Java-developer-productivity-report-2022</a></li><li id="bbd4" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://www.baeldung.com/java-11-new-features" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-11-new-features</a></li><li id="53bb" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://mkyong.com/java/what-is-new-in-java-11/" rel="noopener ugc nofollow" target="_blank">https://mkyong.com/java/what-is-new-in-java-11/</a></li><li id="27a0" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://www.baeldung.com/java-12-new-features" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-12-new-features</a></li><li id="6fe9" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://www.infoworld.com/article/3301197/jdk-12-the-new-features-in-java-12.html" rel="noopener ugc nofollow" target="_blank">https://www . infoworld . com/article/3301197/JDK-12-the-new-features-in-Java-12 . html</a></li><li id="fcf9" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated">https://www.baeldung.com/java-13-new-features<a class="ae ky" href="https://www.baeldung.com/java-13-new-features" rel="noopener ugc nofollow" target="_blank"/></li><li id="78c2" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated">【https://mkyong.com/java/what-is-new-in-java-13/ T4】</li><li id="702c" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://www.baeldung.com/java-14-new-features" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-14-new-features</a></li><li id="af1a" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://www.techgeeknext.com/java/java14-features" rel="noopener ugc nofollow" target="_blank">https://www.techgeeknext.com/java/java14-features</a></li><li id="1df2" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://www.infoworld.com/article/3534133/jdk-15-the-new-features-in-java-15.html" rel="noopener ugc nofollow" target="_blank">https://www . infoworld . com/article/3534133/JDK-15-the-new-features-in-Java-15 . html</a></li><li id="f0e1" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://www.baeldung.com/java-16-new-features" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-16-new-features</a></li><li id="d679" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://www.infoworld.com/article/3569150/jdk-16-the-new-features-in-java-16.html" rel="noopener ugc nofollow" target="_blank">https://www . infoworld . com/article/3569150/JDK-16-the-new-features-in-Java-16 . html</a></li><li id="1ebd" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://www.baeldung.com/java-17-new-features" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-17-new-features</a></li><li id="7889" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://mkyong.com/java/what-is-new-in-java-17/" rel="noopener ugc nofollow" target="_blank">https://mkyong.com/java/what-is-new-in-java-17/</a></li><li id="d94e" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated">【https://www . Oracle . com/news/announcement/Oracle-releases-Java-18-2022-03-22/</li><li id="c2ab" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated"><a class="ae ky" href="https://blogs.oracle.com/java/post/moving-the-jdk-to-a-two-year-lts-cadence" rel="noopener ugc nofollow" target="_blank">https://blogs . Oracle . com/Java/post/moving-the-JDK-to-a-two-year-lts-cadence</a></li></ul></div></div>    
</body>
</html>