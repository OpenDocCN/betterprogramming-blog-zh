<html>
<head>
<title>How to Use Kotlin Symbol Processors on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Android上使用Kotlin符号处理器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-ksp-on-android-f7df3a87d05e?source=collection_archive---------0-----------------------#2022-07-30">https://betterprogramming.pub/how-to-use-ksp-on-android-f7df3a87d05e?source=collection_archive---------0-----------------------#2022-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f6ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们将深入探讨由KSP自动生成样板代码，并讨论挑战和解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c3f37cbe87d06254b582750df3f7e589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ad2y0jtd1uEIGLzh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/es/@theyshane?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shane </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="915f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我首先重申一个问题:</p><p id="edfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">什么是注释？</p><blockquote class="ls lt lu"><p id="c9e0" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">Java注释用于为Java代码提供元数据。Java注释不会直接影响代码的执行，尽管某些类型的注释可以用于此目的。<br/> — <a class="ae kv" href="https://jenkov.com/tutorials/java/annotations.html" rel="noopener ugc nofollow" target="_blank">参考</a>，<a class="ae kv" href="https://en.wikipedia.org/wiki/Java_annotation" rel="noopener ugc nofollow" target="_blank">更多</a></p></blockquote><p id="2c6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用什么平台不重要；只要使用Kotlin，就可以在项目中实现KSP。</p><p id="5fa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，注释处理是一个编译时操作，不涉及运行时开销。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="f77d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">例子</h1><p id="5344" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">通过一个例子，我们将更好地理解KSP。</p><p id="c065" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的数据类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="77f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我们希望基于<code class="fe nf ng nh ni b">Builder</code>模式生成一个构建器类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们生成的类有一个编译时错误！因为我们无法更新<strong class="ky ir">数据类</strong>属性。我们必须自动生成一个具有可变属性的对象来解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a07c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该将构建器类改为下面的代码！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="0ac2" class="mg mh iq bd mi mj nj ml mm mn nk mp mq jw nl jx ms jz nm ka mu kc nn kd mw mx bi translated">履行</h1><p id="a4cd" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们需要三个模块:</p><ol class=""><li id="e3fb" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">注释模块:定义注释。</li><li id="b3fd" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">处理器模块:生成代码。</li><li id="0f02" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">App模块:显然，要用标注。</li></ol></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="944a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">注释模块</h1><p id="0b2c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们应该创建一个<code class="fe nf ng nh ni b">Jave or Kotlin Library</code>模块，创建<code class="fe nf ng nh ni b">annotation class</code>，定义参数并指定哪些类型的对象可以被<code class="fe nf ng nh ni b">@Target</code>注释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/5b3356ebf7c64de238c0dbc24245b6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhwN5_HDnSK8Krexor26IQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">注释模块结构</p></figure><p id="ae32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nf ng nh ni b">AutoBuilder</code>指定了数据类。</p><p id="24c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nf ng nh ni b">BuilderProperty</code>指定了哪些对象应该有独立的方法。</p><p id="8338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe nf ng nh ni b">flexible</code>决定我们是否想要生成可变对象。</p><p id="ffe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些注释会将我们的数据类更改为以下对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="c4fa" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">处理器模块</strong></h1><p id="2f1d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们的项目需要以下类路径。</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="40ea" class="oh mh iq ni b gy oi oj l ok ol">classpath ‘org.jetbrains.kotlin:kotlin-gradle-plugin:1.7.0’</span></pre><p id="fb51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以及<code class="fe nf ng nh ni b"><strong class="ky ir">main gradle</strong></code>文件中的如下插件:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="4b67" class="oh mh iq ni b gy oi oj l ok ol">id 'com.google.devtools.ksp' version '1.7.0-1.0.6' apply false</span></pre><p id="4449" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们应该向<code class="fe nf ng nh ni b"><strong class="ky ir">Processor module</strong></code>添加以下依赖项。</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="2de1" class="oh mh iq ni b gy oi oj l ok ol">implementation project(path: ':annotations')<br/>implementation "com.google.devtools.ksp:symbol-processing-api:1.7.0-1.0.6"</span></pre><p id="81af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了处理注释，我们需要一个提供处理器的对象。因此，我们创建了一个类并实现了<code class="fe nf ng nh ni b"><strong class="ky ir">SymbolProcessorProvider</strong></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="da62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是注册提供者。因此，创建以下目录:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="6e21" class="oh mh iq ni b gy oi oj l ok ol">processor/src/main/resources/META-INF/services</span></pre><p id="aa6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并使用以下名称创建一个文件:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="f593" class="oh mh iq ni b gy oi oj l ok ol">com.google.devtools.ksp.processing.SymbolProcessorProvider</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/f2ce7f34145c0491b775b0c396627c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GbipXUhgPNoz3KIZkk7Dg.png"/></div></div></figure><p id="176e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文件中写入您的提供程序的完全限定名。<em class="lv">例如:</em></p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="dd50" class="oh mh iq ni b gy oi oj l ok ol">your.domain.processor.AutoBuilderProcessorProvider</span></pre><p id="bdd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的提供商必须有一个<code class="fe nf ng nh ni b"><strong class="ky ir">SymbolProcessor</strong></code>。因此，创建一个类并实现<code class="fe nf ng nh ni b"><strong class="ky ir">SymbolProcessor</strong></code> <strong class="ky ir"> </strong>接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cfdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在<code class="fe nf ng nh ni b"><strong class="ky ir">SymbolProcessorProvider</strong></code>中实现<code class="fe nf ng nh ni b"><strong class="ky ir">create</strong></code>功能。</p><blockquote class="ls lt lu"><p id="972f" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq">像a，b，c一样简单</em></p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="560c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们应该解决最后一个问题。再来看<code class="fe nf ng nh ni b"><strong class="ky ir">SymbolProcessor</strong></code>。</p><p id="56fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该在这个类中实现<code class="fe nf ng nh ni b"><strong class="ky ir">process</strong></code>函数。作为第一步，我们必须找到带有注释的对象。</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="6ffd" class="oh mh iq ni b gy oi oj l ok ol">val symbols: Sequence&lt;KSClassDeclaration&gt; = resolver<br/>    .getSymbolsWithAnnotation(AutoBuilder::class.java.name)<br/>    .filterIsInstance&lt;KSClassDeclaration&gt;()</span></pre><blockquote class="ls lt lu"><p id="2ba2" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">值得注意的是，<code class="fe nf ng nh ni b"><strong class="ky ir">process</strong></code>函数返回一个已处理注释的列表，以避免<strong class="ky ir">重新处理。</strong></p></blockquote><p id="7829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在开始处理对象之前，有必要检查是否有任何带有我们的注释的对象。由于我们的对象是一个<code class="fe nf ng nh ni b">Sequence</code>，我们将使用<code class="fe nf ng nh ni b">hasNext</code>。</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="eb3f" class="oh mh iq ni b gy oi oj l ok ol">if (symbols.iterator().hasNext().not()) return emptyList()</span></pre><p id="9237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:对象可以有多个注释，注释可以有各种参数，所以我们需要用它们的名字来得到一个特定的注释和一个特定的参数。</p><blockquote class="ls lt lu"><p id="302b" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">为了使代码更具可读性，我使用了以下扩展函数！</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7225" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以开始处理我们的对象了。很简单——使用<code class="fe nf ng nh ni b"><strong class="ky ir">forEach</strong></code></p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="0eb1" class="oh mh iq ni b gy oi oj l ok ol">symbols.forEach { symbol -&gt;<br/>   // …<br/>}</span></pre><p id="d98b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们必须检查对象是否是数据类:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="2d79" class="oh mh iq ni b gy oi oj l ok ol">if (symbol.modifiers.containsIgnoreCase("data").not()) {<br/>    logger.error("This object is not a data class", symbol)<br/>    return emptyList()<br/>}</span></pre><p id="3a11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用以下代码从特定的注释中检索参数值:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="5cd4" class="oh mh iq ni b gy oi oj l ok ol">val flexible = symbol.annotations<br/>   .getAnnotation(AutoBuilder::class.java.simpleName)<br/>   .arguments.getParameterValue&lt;Boolean&gt;("flexible")</span></pre><p id="4974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此代码有问题；我们使用了一个字符串，这增加了出错的可能性。将批注类更改为以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7c79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并将前面的代码更改为以下代码:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="602c" class="oh mh iq ni b gy oi oj l ok ol">val flexible = symbol.annotations<br/>   .getAnnotation(AutoBuilder::class.java.simpleName)<br/>   .arguments.getParameterValue&lt;Boolean&gt;(AutoBuilder.flexible)</span></pre><p id="10ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了处理对象，我们需要实现<code class="fe nf ng nh ni b">KSVisitor</code>接口，这个接口有两个通用类型:</p><p id="811f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">d:它是作为输入发送或在流程步骤中创建的对象。它是我们的类将要返回的一个对象。</p><p id="39b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nf ng nh ni b">KSVisitor</code>有一些实现。根据具体情况，我们可以使用它们来代替实现<code class="fe nf ng nh ni b">KSVisitor</code>。</p><blockquote class="ls lt lu"><p id="6dac" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">我们在本文中查看构建器访问者，源代码包含可变的构建器。</p></blockquote><p id="b614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这个例子中使用<code class="fe nf ng nh ni b">KSVisitorVoid</code>，因为我们的输入和输出是<code class="fe nf ng nh ni b">null</code>。</p><p id="69c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们的注释目标是类，所以我们必须覆盖<code class="fe nf ng nh ni b"><em class="lv">visitClassDeclaration</em></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e307" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一步，我们必须创建我们的文件:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="7654" class="oh mh iq ni b gy oi oj l ok ol">val file: OutputStream = codeGenerator.createNewFile(<br/>   dependencies = Dependencies(false), <br/>   packageName = [Package Name],<br/>   fileName = [File Name]<br/>)</span></pre><p id="7d76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这段代码中，除了<code class="fe nf ng nh ni b">dependencies</code>，一切都很清楚。</p><p id="0a43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止重新处理和重新生成不必要的文件，KSP使用了增量处理技术。为了简洁起见，我将跳过这项技术的工作。然而，如果你愿意，你可以<a class="ae kv" href="https://kotlinlang.org/docs/ksp-incremental.html" rel="noopener ugc nofollow" target="_blank">在文档</a>中读到它。</p><p id="76e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的<code class="fe nf ng nh ni b"><strong class="ky ir">operation function</strong></code>帮助我们拥有更多可读的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8cba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住在<code class="fe nf ng nh ni b">END</code>处<code class="fe nf ng nh ni b">CLOSE</code>到<code class="fe nf ng nh ni b">OutputStream</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4142" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文件中写入很容易；你需要一行一行地写。</p><p id="0b40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们应该读取属性三次。</p><p id="4ee2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先是创建承包商:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="9e30" class="oh mh iq ni b gy oi oj l ok ol">class PersonBuilder(name: kotlin.String)</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4fa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二步是创建私有对象:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="5239" class="oh mh iq ni b gy oi oj l ok ol">private val mutablePerson: MutablePerson = MutablePerson(<br/>   name = name,<br/>   age = null,<br/>   email = null,<br/>   contact = null,<br/>)</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3ee2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三是创建构建器函数:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="f0e0" class="oh mh iq ni b gy oi oj l ok ol">fun age(age: kotlin.Int): PersonBuilder {<br/>   mutablePerson.age = age<br/>   return this<br/>}</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="6c54" class="oh mh iq bd mi on oo dn mm op oq dp mq lf or os ms lj ot ou mu ln ov ow mw ox bi translated">注1:</h2><p id="29f1" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">找到所有的off类型并写在文件的顶部是复杂的。为了解决这个问题，我们应该使用类型的限定名，而不是简单名。</p><p id="eb5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">意思是写:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="94a8" class="oh mh iq ni b gy oi oj l ok ol">kotlin.collections.List&lt;kotlin.Boolean&gt;</span></pre><p id="edf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而不是:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="98e7" class="oh mh iq ni b gy oi oj l ok ol">List&lt;Boolean&gt;</span></pre><h2 id="db51" class="oh mh iq bd mi on oo dn mm op oq dp mq lf or os ms lj ot ou mu ln ov ow mw ox bi translated">注2:</h2><p id="ec03" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">获取泛型类型并不容易。为了处理它，我们应该使用下面的递归函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="b800" class="oh mh iq bd mi on oo dn mm op oq dp mq lf or os ms lj ot ou mu ln ov ow mw ox bi translated">注3:</h2><p id="7bd7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">调用<code class="fe nf ng nh ni b">resolve</code>操作在计算方面开销很大。所以，你必须小心使用它。</p><p id="2c94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的处理器模块生成以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/7fb8763d48824113a9d8b6b5c41b3d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-pv9lYAUuSIdIK3Fd6ovw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">处理器模块结构</p></figure><h1 id="21bd" class="mg mh iq bd mi mj nj ml mm mn nk mp mq jw nl jx ms jz nm ka mu kc nn kd mw mx bi translated"><strong class="ak"> App模块</strong></h1><p id="46e6" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">要将处理器模块添加到应用程序模块，我们应该将以下插件添加到主模块:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="f7df" class="oh mh iq ni b gy oi oj l ok ol">id 'com.google.devtools.ksp'</span></pre><p id="0a48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，将以下依赖项添加到主模块:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="f86d" class="oh mh iq ni b gy oi oj l ok ol">implementation project(path: ':annotations')<br/>ksp project(path: ':processor')</span></pre><p id="ff29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并同步项目，并创建以下类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/b4f492972528b90a079a1a81b469dd8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfCWnlMEQIbAJthVOryCtg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">项目结构</p></figure><p id="6123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次构建项目，并在以下地址找到您的文件:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="7d9d" class="oh mh iq ni b gy oi oj l ok ol">~/build/generated/ksp/debug/kotlin/...</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/f2e1e96bb919345bde2e9118a6a664e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1JGtf3ekeqwDfnmoku36Xw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自动生成的文件</p></figure><h1 id="b812" class="mg mh iq bd mi mj nj ml mm mn nk mp mq jw nl jx ms jz nm ka mu kc nn kd mw mx bi translated">挑战和解决方案</h1><p id="0b11" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">挑战1 —我想在Android模式下展示自动生成的对象。</p><p id="b022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在Android模式下显示自动生成的对象，我们应该将以下代码添加到<code class="fe nf ng nh ni b">.gradle</code>文件中。</p><p id="f4c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用模块:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="d434" class="oh mh iq ni b gy oi oj l ok ol">applicationVariants.all { variant -&gt;<br/>    kotlin.sourceSets {<br/>        def name = variant.name<br/>        getByName(name) {<br/>            kotlin.srcDir("$buildDir/generated/ksp/$name/kotlin")<br/>        }<br/>    }<br/>}</span></pre><p id="6aa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">库模块:</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="8e42" class="oh mh iq ni b gy oi oj l ok ol">libraryVariants.all { variant -&gt;<br/>    kotlin.sourceSets {<br/>        def name = variant.name<br/>        getByName(name) {<br/>            kotlin.srcDir("$buildDir/generated/ksp/$name/kotlin")<br/>        }<br/>    }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/45834d9e9115746add4124b6e5fe0b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_ufC3zH0DJMZQWEYE2OkQ.png"/></div></div></figure><p id="42d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">挑战2 —我想要配置选项:</p><p id="2f69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在<code class="fe nf ng nh ni b"><strong class="ky ir">ksp</strong></code>块中编写我们的配置来拥有配置选项。</p><pre class="kg kh ki kj gt od ni oe of aw og bi"><span id="2a0e" class="oh mh iq ni b gy oi oj l ok ol">android {<br/>    ...<br/>    ksp {<br/>        arg("myConfig1", "true")<br/>        arg("myConfig2", "myText")<br/>        arg("myConfig3", "1")<br/>    }<br/>}</span></pre><p id="c018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用下面的代码来读取配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f2b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们无法访问默认值；如果有必要，你可以定义一些注释并通过它们发送默认值。检查这个<a class="ae kv" href="https://github.com/google/ksp/issues/268" rel="noopener ugc nofollow" target="_blank">问题</a>。</p><h1 id="17dc" class="mg mh iq bd mi mj nj ml mm mn nk mp mq jw nl jx ms jz nm ka mu kc nn kd mw mx bi translated">源代码</h1><div class="pa pb gp gr pc pd"><a href="https://github.com/Darvishiyan/KSP-Builder-Sample" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd ir gy z fp pi fr fs pj fu fw ip bi translated">GitHub-Darvishiyan/KSP-生成器-示例</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">github.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr kp pd"/></div></div></a></div><p id="e500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个例子:<a class="ae kv" href="https://github.com/Darvishiyan/KSP-DiffCallback-Sample" rel="noopener ugc nofollow" target="_blank">这个项目</a>自动为Android中的<code class="fe nf ng nh ni b">ListAdapter</code>生成<code class="fe nf ng nh ni b">DiffCallback</code>对象。</p><h1 id="6faa" class="mg mh iq bd mi mj nj ml mm mn nk mp mq jw nl jx ms jz nm ka mu kc nn kd mw mx bi translated">参考</h1><ul class=""><li id="e4f8" class="no np iq ky b kz my lc mz lf ps lj pt ln pu lr pv nu nv nw bi translated"><a class="ae kv" href="https://kotlinlang.org/docs/ksp-overview.html" rel="noopener ugc nofollow" target="_blank">科特林符号处理API |科特林</a></li><li id="c79b" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr pv nu nv nw bi translated"><a class="ae kv" href="https://github.com/google/ksp" rel="noopener ugc nofollow" target="_blank"> google/ksp: Kotlin符号处理API </a></li><li id="498d" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr pv nu nv nw bi translated"><a class="ae kv" href="https://proandroiddev.com/so-how-do-i-write-a-kotlin-symbol-processor-ksp-b9606e9e3818" rel="noopener ugc nofollow" target="_blank">那么，我如何编写一个Kotlin符号处理器(KSP)？</a></li></ul></div></div>    
</body>
</html>