<html>
<head>
<title>Dependency Management Done Manually in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中手动完成依赖性管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dependency-management-done-manually-in-swift-ee0f8f2dfbe3?source=collection_archive---------10-----------------------#2019-08-16">https://betterprogramming.pub/dependency-management-done-manually-in-swift-ee0f8f2dfbe3?source=collection_archive---------10-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/27550c8cad09cf756191beec45732c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyCFo-f2lKWWNYRhidv4Wg.jpeg"/></div></div></figure><h2 id="18c4" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">可扩展iOS应用架构的组成部分</h2><div class=""/><div class=""><h2 id="e0f9" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">通过编写自己的容器轻松解决依赖关系</h2></div><p id="90da" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果你依赖某样东西，你就失去了一些自由。但是如果你可以很容易地取代这种依赖，你至少可以自由地决定你所依赖的是什么！🙃</p><p id="a9d6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在代码中，这意味着通过协议只定义抽象的依赖关系，这样就可以很容易地交换具体的实现。然后在运行时从外部分配具体的依赖关系。这被称为依赖注入(DI ),或者从更广的意义上说，称为依赖管理(DM)。</p><p id="0951" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">Alexey Kuznetsov 在他的文章“<a class="ae ma" href="https://medium.com/ios-os-x-development/dependency-injection-in-swift-a959c6eee0ab" rel="noopener">swift中的依赖注入</a>”中非常清楚地解释了如何做到这一点。而<a class="ly lz ep" href="https://medium.com/u/27f1499af22d?source=post_page-----ee0f8f2dfbe3--------------------------------" rel="noopener" target="_blank"> Joe Masilotti </a>展示了为什么应该在“<a class="ae ma" href="https://medium.com/@joemasilotti/better-unit-testing-with-swift-b2d5746b5101" rel="noopener">使用Swift </a>进行更好的单元测试”中完成。</p><p id="3bae" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">Swift项目中的DI有框架解决方案，如<a class="ae ma" href="https://github.com/Swinject/Swinject" rel="noopener ugc nofollow" target="_blank"> Swinject </a>。您创建一个容器，并在其中注册所有可能的依赖项。创建对象时，会查询容器，通过返回这些对象来解析依赖关系。</p><p id="edad" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一个有趣的选择是Weaver。与Swinject不同，Weaver是一个命令行工具，因此不作为框架包含在项目中。在构建过程中，它会自动生成依赖代码。</p><p id="37ce" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">正如<a class="ly lz ep" href="https://medium.com/u/c7f0f9651ab7?source=post_page-----ee0f8f2dfbe3--------------------------------" rel="noopener" target="_blank"> Théophane Rupin </a>在他的文章“<a class="ae ma" href="https://medium.com/scribd-data-science-engineering/weaver-a-painless-dependency-injection-framework-for-swift-7c4afad5ef6a" rel="noopener">Weaver:Swift的无痛依赖注入框架</a>中解释的那样，Weaver比Swinject有几个优点，例如编译时解决方案，而Swinject可能会由于非可选选项而经历运行时崩溃。此外，使用注释定义依赖项是一种非常有趣的方法，但它也带来了一些问题，因为您突然在注释中编写了“代码”。😬</p><p id="88b0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，任何喜欢框架或命令行工具的人都应该使用它们。然而，为了解决依赖性而使自己依赖于新的事物，这具有一定的讽刺意味。😏</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="bf14" class="mi mj je bd mk ml mm mn mo mp mq mr ms kt mt ku mu kw mv kx mw kz mx la my mz bi translated">手动依赖注入</h1><p id="c62b" class="pw-post-body-paragraph lc ld je le b lf na ko lh li nb kr lk ll nc ln lo lp nd lr ls lt ne lv lw lx im bi translated">原则上，您需要一个容器来保存所有依赖项，并传递给需要依赖项的类。为了避免直接依赖于这个容器，您使用协议以及依赖关系本身。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="38a2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">第5行定义了依赖关系:这里是一个<em class="nl">服务器</em>类，它的典型任务是与服务器通信。</p><p id="aebc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为了不直接依赖于这个特定的类，在第1行定义了相关的协议。在这种情况下，协议在传统意义上被用作接口，因此也这样命名。回到使用头文件的好时光。😅</p><p id="da4d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">同样的情况发生在第9行和第13行，在那里定义了容器。<em class="nl"> DependencyContainer </em>表示保存变量<code class="fe nm nn no np b">server</code>中<em class="nl">服务器</em>依赖关系的容器。容器已经对具体的<em class="nl">服务器</em>类一无所知，因为它只引用了<em class="nl">服务器接口</em>。</p><p id="e78b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然后，一个虚构的<em class="nl"> ViewController </em>获取在<code class="fe nm nn no np b">init</code>方法中注入的容器。同样，<em class="nl"> ViewController </em>不知道具体的<em class="nl"> DependencyContainer </em>类，只知道它的协议。然而，这足以通过第29行中的从属<em class="nl">服务器</em>类启动一个服务器请求。</p><p id="26a3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">根对象，比如<em class="nl"> AppDelegate </em>，必须创建具体的实例。这里，这发生在第38行的例子中。创建了类型为<em class="nl"> DependencyContainer </em>和<em class="nl"> Server </em>的具体实例。</p><p id="1e63" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">第39行最后创建了具体的<em class="nl"> ViewController </em>并注入了依赖项。如果您没有手动实例化您的<em class="nl"> ViewController </em>，您也可以通过属性注入来传递容器，因此不是通过<code class="fe nm nn no np b">init</code>方法基于初始化式，而是将依赖关系直接分配给属性。</p><p id="4cb8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果一个<em class="nl">视图控制器</em>调用一个新的视图控制器，这将通过DI再次完成，这在第32行的<code class="fe nm nn no np b">navigate</code>方法中作为一个例子给出。</p><p id="b266" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果需要更多的依赖关系，你所要做的就是扩展<em class="nl"> DependencyContainer </em>并将具体的依赖关系传递给实例化。</p><p id="dbee" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在一个<em class="nl"> UnitTest </em>环境中，你不会给<em class="nl"> DependencyContainer </em>一个特定的<em class="nl">服务器</em>实例，而可能是一个<em class="nl">服务器模拟</em>实例。然后，mock简单地实现了<em class="nl"> ServerInterface </em>，并检查在测试期间是否调用了正确的方法，或者是否返回了测试数据。</p><p id="2fd7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因为<em class="nl"> DependencyContainer </em>有自己的接口协议，所以很容易用一个特殊的测试存根来替换它，这个测试存根可以创建所有的依赖模仿，如下例所示。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3d17" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">其实就这些了。很容易控制，对吧？但是阿迪框架实际上做了什么呢？🤔</p><blockquote class="nq"><p id="eccf" class="nr ns je bd nt nu nv nw nx ny nz lx dk translated">依赖注入框架仅仅提供了一个容器。剩下的还是要自己写。</p></blockquote><p id="ca97" class="pw-post-body-paragraph lc ld je le b lf oa ko lh li ob kr lk ll oc ln lo lp od lr ls lt oe lv lw lx im bi translated">那么，它真的需要一个框架吗？每个人都必须自己决定，但在我看来，没有一个也很好，如上所示，你甚至可以获得新的自由！😁</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b81f" class="mi mj je bd mk ml mm mn mo mp mq mr ms kt mt ku mu kw mv kx mw kz mx la my mz bi translated">短暂依赖</h1><p id="3105" class="pw-post-body-paragraph lc ld je le b lf na ko lh li nb kr lk ll nc ln lo lp nd lr ls lt ne lv lw lx im bi translated">等等，第33行创建了一个新的<em class="nl"> NextViewController </em>。那不也是一种依赖吗？🧐</p><p id="1f56" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">确实！</p><p id="0313" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这就是为什么它也属于<em class="nl"> DependencyContainer </em>的原因。然而，<em class="nl"> UIViewController </em>的依赖关系有些特殊，因为我们真的不想在容器中保存一个<em class="nl"> NextViewController </em>的实例。如果我们通过容器请求一个<em class="nl"> NextViewController </em>，那么每次都应该重新创建它。因此，这种依赖成分是暂时的。</p><p id="63a4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">此外，我们并不真的想知道它是什么特定的<em class="nl"> NextViewController </em>类。如果我们知道它是一个<em class="nl"> UIViewController </em>就足够导航了。这将防止<em class="nl"> ViewController </em>知道任何关于<em class="nl"> NextViewController </em>的信息。</p><p id="b387" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">工厂模式来拯救！🤠</p><blockquote class="nq"><p id="b285" class="nr ns je bd nt nu nv nw nx ny nz lx dk translated">工厂模式描述了一个对象如何通过一个接口创建新的对象，而不必知道这些对象的具体类。</p></blockquote><figure class="of og oh oi oj iv"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f5ef" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="nl">dependency容器</em>现在在第13行提供了一个工厂方法<code class="fe nm nn no np b">scene(_ scene: Scene) -&gt; UIViewController</code>。根据输入，我们得到想要的具体数据<em class="nl"> UIViewController </em>。</p><p id="8ec7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在第1行中定义，<em class="nl">场景</em>是一个简单的枚举，映射到具体的<em class="nl"> UIViewController </em>类。实例化发生在<em class="nl"> DependencyContainer </em>中，其中容器将自身作为对新<em class="nl"> NextViewController </em>实例的依赖引用注入。</p><p id="02cc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这允许第31行中的<em class="nl"> ViewController </em>从<em class="nl"> NextViewController </em>创建一个实例，而不直接依赖于该类。顺便说一下，<em class="nl"> AppDelegate </em>根对象对<em class="nl"> ViewController </em>的直接依赖现在也在第37行中以这种方式解决了。</p><p id="8b0b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">不再依赖于具体的<em class="nl"> UIViewController </em>类，而是依赖于<em class="nl">场景</em>枚举。然而，这是合理的，因为一个<em class="nl">逻辑</em>模块或者一个<em class="nl">视图控制器</em>必须最终决定导航到哪个新场景。这样，就是一个简单的，独立的类型。</p><p id="2436" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，如果添加更多的视图控制器，你必须扩展<em class="nl">场景</em>枚举和<em class="nl">依赖容器</em>。潜在的合并冲突应该很容易解决。通常情况下。😅</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7243" class="mi mj je bd mk ml mm mn mo mp mq mr ms kt mt ku mu kw mv kx mw kz mx la my mz bi translated">场景设置参数</h1><p id="c942" class="pw-post-body-paragraph lc ld je le b lf na ko lh li nb kr lk ll nc ln lo lp nd lr ls lt ne lv lw lx im bi translated">您通常希望用附加数据初始化场景，而不仅仅是全局依赖。例如，<em class="nl">视图控制器</em>中的用户可以进行输入，然后该输入将被传递给<em class="nl">下一个视图控制器</em>进行进一步处理。</p><p id="913d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，该值也是<em class="nl"> NextViewController </em>的依赖项，但仅适用于该控制器，不适用于所有其他控制器。这些参数也应该通过DI传递。这是怎么回事？🤔</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="16bc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">很简单，您可以定义一个结构，如第25行所示，它可以保存您想要传递给新控制器的任何数据。那么在第28行会出现这种依赖关系。</p><p id="bd28" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，<em class="nl"> ViewController </em>必须在第19行创建它并相应地填充它，然后将其作为关联值传递给第20行的<em class="nl">场景</em>枚举。</p><p id="cee7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然后，<em class="nl"> DependencyContainer </em>从第11行的enum中检索这个关联值，并在实例化期间将其作为额外参数传递给<em class="nl"> NextViewController </em>。</p><p id="290b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好了，其他人<em class="nl"> UIViewController </em>不需要知道这个参数。🤫</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="046f" class="mi mj je bd mk ml mm mn mo mp mq mr ms kt mt ku mu kw mv kx mw kz mx la my mz bi translated">嵌套依赖关系</h1><p id="0654" class="pw-post-body-paragraph lc ld je le b lf na ko lh li nb kr lk ll nc ln lo lp nd lr ls lt ne lv lw lx im bi translated">在第一个例子中，有一个服务器依赖，它可以传递给任意数量的<em class="nl"> UIViewControllers </em>。但是，如果在运行时，出现了新的依赖怎么办？例如，从某一点开始，我们有一个登录用户，他成为流程中所有后续<em class="nl"> UIViewControllers </em>的新依赖项？🤔</p><p id="f3c4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><a class="ly lz ep" href="https://medium.com/u/5486d7313999?source=post_page-----ee0f8f2dfbe3--------------------------------" rel="noopener" target="_blank"> John Sundell </a>在他的讲座<a class="ae ma" href="https://youtu.be/ujOc3a7Hav0" rel="noopener ugc nofollow" target="_blank">系统设计的失落艺术</a>中展示了这个用例，并将他的解决方案称为“锁定&amp;键”。</p><p id="02a8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">其思想是新的用户对象是打开锁的钥匙，这意味着创建一个新的依赖容器。当然，这是作为对旧容器的依赖来完成的，所以旧容器创建新容器。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1751" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这里对预登录应用状态和登录后应用状态进行了区分。因此，在第13行和第36行定义了两个容器。一开始，应用程序处于预登录状态，因此，只有<em class="nl">PreLoginDependencyContainer</em>存在。</p><p id="b0c1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在特定时间，通过线58进行登录。从那里开始，有了一个具体的用户对象，应用程序现在应该切换到登录后状态，并进行相应的转换。为此，在第60行创建带有所需用户参数的<em class="nl">PostLoginDependencyContainer</em>。</p><p id="8752" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="nl">PostLoginDependencyContainer</em>现在知道登录后状态的所有场景，这在第26行中定义。所以您也可以在第61行创建<em class="nl"> NextViewController </em>并呈现它。在任何情况下，<em class="nl"> NextViewController </em>和任何后续控制器都存在用户依赖性。</p><p id="066f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果还需要更多的依赖项，例如服务器对象，这也必须传递给<em class="nl">PostLoginDependencyContainer</em>。当然，通过注射。😊</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0c18" class="mi mj je bd mk ml mm mn mo mp mq mr ms kt mt ku mu kw mv kx mw kz mx la my mz bi translated">结论</h1><p id="667d" class="pw-post-body-paragraph lc ld je le b lf na ko lh li nb kr lk ll nc ln lo lp nd lr ls lt ne lv lw lx im bi translated">希望我已经能够展示依赖性管理并不复杂，并且可以手动很好地完成。你不必不断地重新发明轮子，但有时它比安装一个现有的更快。😉</p><p id="11a5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在我的<a class="ae ma" href="https://github.com/indieSoftware/DemoArchitecture" rel="noopener ugc nofollow" target="_blank"> DemoApp项目</a> (DAP)中，可以看到更复杂环境下DI的手动使用。在那里，工厂部分被外包到自己的<em class="nl">工厂</em>类中，该类由<em class="nl"> DependencyContainer </em>作为一个依赖项持有。但那只是糖衣。🤓</p><p id="43a4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">顺便说一句，这是一篇来自“<a class="ae ma" href="https://medium.com/@sven.korset/pieces-of-a-scalable-ios-app-architecture-7c182f9dcd2c" rel="noopener">可扩展的iOS应用架构</a>”系列的文章。</p></div></div>    
</body>
</html>