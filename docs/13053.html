<html>
<head>
<title>Algorithmically Solve Peg Solitaire Game Using Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rust算法求解Peg纸牌游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-algorithm-to-solve-peg-solitaire-and-an-implementation-in-rust-dbe69831125a?source=collection_archive---------7-----------------------#2022-07-22">https://betterprogramming.pub/an-algorithm-to-solve-peg-solitaire-and-an-implementation-in-rust-dbe69831125a?source=collection_archive---------7-----------------------#2022-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实际实施</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc0e3f78a1b86da948162caf06cb5241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gn0YQE9Ah-bz_b_tQXGZ0Q.png"/></div></div></figure><div class="ku kv gp gr kw kx"><a href="https://medium.com/@applied-math-coding/membership" rel="noopener follow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd iu gy z fp lc fr fs ld fu fw is bi translated">通过我的推荐链接加入Medium-applied . math . coding</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">获得我所有的故事，以及其他作家在媒体上发表的成千上万的故事。我坚信，媒介是…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ks kx"/></div></div></a></div><p id="3e27" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这个故事旨在提供一个基本算法来解决<a class="ae mi" href="https://en.wikipedia.org/wiki/Peg_solitaire" rel="noopener ugc nofollow" target="_blank"> Peg纸牌</a>游戏，并在Rust中给出一个实现。</p><p id="9091" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你尝试过，这个游戏很难用手解决。此外，当过于天真地实现递归求解器时，人们会被它的复杂性所打击，并且依赖于计算机，人们必须等待几个小时才能得到解决方案。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="506b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">算法</h1><p id="026d" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">最基本的方法是用归纳法解决问题。我们从初始状态开始，除了中心以外的每个位置都被一块石头占据。</p><ol class=""><li id="8ca3" class="nn no it lo b lp lq ls lt lv np lz nq md nr mh ns nt nu nv bi translated">验证是否已经解决，也就是说，只有在中心的一块石头被留下。如果是，我们就完成了。</li><li id="7d39" class="nn no it lo b lp nw ls nx lv ny lz nz md oa mh ns nt nu nv bi translated">确定所有可能的行动。这些是那些垂直或水平地让一个石头跳过另一个石头进入一个未被占据的位置并移走另一个的石头。如果没有可能的移动可用，停止沿此“路径”的搜索。</li><li id="7c1d" class="nn no it lo b lp nw ls nx lv ny lz nz md oa mh ns nt nu nv bi translated">一定要应用每一个这样的动作。每次有了新的职业状态，回到第一点。</li></ol><p id="d4fd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这种算法是一种典型的方法，可以尝试所有可能的一系列移动，直到找到解决方案。它的复杂性显然是指数级的，因为大多数时候会有不止一个可用的移动。但问题是，对于指数复杂性来说，指数已经有点太高了。我们的场地大约有50块石头。为了移除其中的49个，我们至少需要49次移动。如果我们估计在每一步棋之后还有两次可能的走法，那么这就等于<code class="fe ob oc od oe b">2^49</code>条可能的路径。这个数字可能有点高估，但它已经给人一种我们会遇到问题的印象。</p><p id="5eec" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">事实上，实现上述方法需要几个小时才能解决问题(在我的机器上)。我们能做的是使用一种非常有前途的修剪技术。</p><p id="f1f0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这个想法是利用游戏的对称性。</p><p id="d3a0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你观察石头的任何占据状态，并且你现在绕着它的中心顺时针旋转游戏90度，这个状态是否能导致任何解决方案的答案保持不变。类似地，如果你沿着垂直中心轴反映当前的占领状态，如果解决方案仍然可能保持不变，我们将再次期待答案:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="0757" class="oj mr it oe b gy ok ol l om on">      O O O<br/>      O O O<br/>  O <strong class="oe iu">X X</strong> O O O O<br/>  O O <strong class="oe iu">X</strong> O O O O<br/>  O O O O O O O<br/>      O O O<br/>      O O O</span><span id="97ea" class="oj mr it oe b gy oo ol l om on">mirrored:</span><span id="24dd" class="oj mr it oe b gy oo ol l om on">      O O O<br/>      O O O<br/>  O O O O <strong class="oe iu">X X</strong> O<br/>  O O O O <strong class="oe iu">X</strong> O O<br/>  O O O O O O O<br/>      O O O<br/>      O O O</span></pre><p id="05fd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了看到这一点，通过归纳，我们可以很容易地验证镜像移动在镜像游戏中提供了相同的状态，要么没有移动可用，要么没有解决方案(一个在中间)。</p><p id="0aed" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">所以，对于每一块石头，我们有八种状态，它们等价于可解性:旋转(0，90，180，270) +镜像(旋转(0，90，180，270))</p><p id="810d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，想法是存储算法已经确定不存在解的每个占用状态。然后在步骤#3，我们将递归调用限制在那些与循环响应不一致的状态。上述存储状态的镜像版本。</p><p id="1456" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这种修剪技术极大地减小了搜索树的大小，并且算法在几秒钟内运行(当然取决于机器)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="988a" class="oj mr it bd ms op oq dn mw or os dp na lv ot ou nc lz ov ow ne md ox oy ng oz bi translated">履行</h2><p id="e60d" class="pw-post-body-paragraph lm ln it lo b lp ni ju lr ls nj jx lu lv nk lx ly lz nl mb mc md nm mf mg mh im bi translated">像往常一样，我不想强制使用任何特定的编程语言。因此，请尝试用您最喜欢的语言实现上述内容。这里的实现是在Rust中完成的，如果你需要的话，你可以在这里找到它的介绍<a class="ae mi" href="https://medium.com/@applied-math-coding/list/an-introduction-into-rust-22c99777c5e5" rel="noopener">。</a></p><p id="fba5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，我们需要一个数据结构，允许我们存储职业状态并推断可用的移动。这将通过下面的struct <code class="fe ob oc od oe b">Field</code>来完成，我们同时实现所有需要的转换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="42b0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe ob oc od oe b">Field</code>的二维数据数组通过一个<code class="fe ob oc od oe b">true</code>值表示相应的位置被石头占据。</p><p id="9a1b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">占领状态(<code class="fe ob oc od oe b">Field</code>，我们知道不会导致解决方案，我们将存储在<code class="fe ob oc od oe b">HashSet</code>。为此，我们将提供<code class="fe ob oc od oe b">Field</code>的<code class="fe ob oc od oe b">hash</code>函数的自定义实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="69bc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">通过首先分别产生所有状态等价旋转来计算散列。然后选择这些w.r.t字典顺序中的最大值。后者数据的散列随后被用于改变散列状态。通过这种实现，在询问<code class="fe ob oc od oe b">HashSet</code>是否已知给定状态不会导致解决方案时，我们不必做太多工作。</p><p id="6126" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一个<code class="fe ob oc od oe b">Move</code>，即一个“跳转”，由以下存储相应坐标的结构表示:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="41fc" class="oj mr it oe b gy ok ol l om on">type Vertex = (usize, usize);</span><span id="9925" class="oj mr it oe b gy oo ol l om on">#[derive(Hash, PartialEq, Eq, Debug, Clone, Copy)]<br/>pub struct <strong class="oe iu">Move </strong>{<br/>    pub from: Vertex,<br/>    pub to: Vertex,<br/>}</span></pre><p id="39b8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们将使用<code class="fe ob oc od oe b">Field</code>结构来存储占领状态，并在<code class="fe ob oc od oe b">Field</code>的数据数组中存储石头可能占据的位置。为此，我们有两种相应的初始化方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="032c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此外，有两种方法，第一种用于确定一个给定的占用状态是一个解决方案，第二种用于将给定的<code class="fe ob oc od oe b">Move</code>应用到一个给定的占用状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="34a8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此外，我们需要一种方法来提取给定占领状态下所有可能的移动。这很简单，通过搜索所有未被占用的位置，并从那里分别垂直搜索。成对石头的水平方向:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="28d0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">最后，我们得出与上述描述完全相似的实际算法。注意，<code class="fe ob oc od oe b">pruning</code>是用于存储没有解的占用状态的<code class="fe ob oc od oe b">HashSet</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="1d51" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">根据您的机器，该代码会在几秒钟后返回。你可以在这个<a class="ae mi" href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=218537ede90965948a2a1ac262e07717" rel="noopener ugc nofollow" target="_blank">游乐场</a>找到全部代码。但是，由于它的运行时间，它可能无法在那里执行。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="4125" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">感谢阅读！</p></div></div>    
</body>
</html>