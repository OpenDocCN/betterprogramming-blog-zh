<html>
<head>
<title>What’s New in TypeScript 4.8?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.8有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-4-8-c4c4e59894c3?source=collection_archive---------3-----------------------#2022-08-22">https://betterprogramming.pub/whats-new-in-typescript-4-8-c4c4e59894c3?source=collection_archive---------3-----------------------#2022-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="570e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建改进，对模板字符串类型的更好推断，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/692abf99c3f5b1e889c62caca0de5728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dv0WrPBfuwP8uBg4xw8gPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="df65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打字稿<code class="fe lu lv lw lx b">4.8</code>版本计划在8月23日发布🎉。这一次我们不会看到令人兴奋的发布。尤其是如果我们将其与<code class="fe lu lv lw lx b">4.7.</code>进行比较的话。它更侧重于改进一些现有的功能和提高其构建时间。</p><p id="fd9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将重点介绍最相关的新特性。以下是摘要:</p><ul class=""><li id="d18b" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated">改进交集减少和CFA，以实现真实性、相等性和检查类型。</li><li id="1055" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">改进了模板字符串类型中<code class="fe lu lv lw lx b">infer</code>类型的推断</li><li id="e6fc" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">构建改进</li><li id="3bc4" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">与对象/数组文字进行比较时出现支持错误。</li></ul><p id="653a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和往常一样，您可以通过使用TypeScript web playground <a class="ae mm" href="https://www.typescriptlang.org/play/" rel="noopener ugc nofollow" target="_blank">这里的</a>来跟进这个例子。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6a4a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">改进交集减少和CFA，以实现真实性、相等性和检查类型。</h1><p id="7326" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">--strictNulChecks</code>时引入了一些变化，这将带来更多的一致性。其中许多都围绕着无约束类型变量。</p><p id="79df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">空对象<code class="fe lu lv lw lx b">{}</code>现在是除了<code class="fe lu lv lw lx b">null</code>和<code class="fe lu lv lw lx b">undefined</code>之外的所有类型的超类型。这意味着<code class="fe lu lv lw lx b">unknown</code>可以表示为<code class="fe lu lv lw lx b">{} | null | undefined</code>。</p><p id="6950" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果，我们现在得到了更准确的打字。让我们看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c48d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当<code class="fe lu lv lw lx b">4.8</code>开启时，有一个错误信号提示<code class="fe lu lv lw lx b">T</code>可能是<code class="fe lu lv lw lx b">null</code>或<code class="fe lu lv lw lx b">undefined</code>。同样的代码在<code class="fe lu lv lw lx b">4.7</code>和更低版本上也能很好地编译。</p><p id="2062" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于任意非空且非未定义的<code class="fe lu lv lw lx b">T</code>，其与<code class="fe lu lv lw lx b">{}</code>的交集将被视为<code class="fe lu lv lw lx b">T</code>。</p><p id="35a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一些其他的实际例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6f8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意<code class="fe lu lv lw lx b">T4, T6</code>在<code class="fe lu lv lw lx b">TS 4.7</code>和<code class="fe lu lv lw lx b">TS 4.8</code>之间没有改变，因为<code class="fe lu lv lw lx b">{}</code>已经是这些类型的超集。<code class="fe lu lv lw lx b">T8</code>和<code class="fe lu lv lw lx b">T9</code>保持不变，因为它们从未与<code class="fe lu lv lw lx b">{}</code>型相交。</p><p id="fa98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">NonNullable</code>映射类型已被简化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="02c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为现在<code class="fe lu lv lw lx b">{}</code>是不可空类型的超集，它的截取意味着如果它不同于<code class="fe lu lv lw lx b">never</code>它就不可空。正如我们在上面看到的，任何不可空的与<code class="fe lu lv lw lx b">{}</code>的交集都会返回相同的类型。</p><p id="96e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你现在可以做哪些很酷的事情？可以缩小<code class="fe lu lv lw lx b">unknown</code>类型。</p><p id="88f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看<code class="fe lu lv lw lx b">4.7</code>之前的现状。您永远无法将<code class="fe lu lv lw lx b">unknown</code>类型进一步缩小到一个不可为空的值。它将总是循环回到<code class="fe lu lv lw lx b">unknown</code>。为什么？因为<code class="fe lu lv lw lx b">{}</code>不是所有不可空的超集:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1a23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从<code class="fe lu lv lw lx b">4.8</code>我们可以:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f74a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击查看PR <a class="ae mm" href="https://github.com/microsoft/TypeScript/pull/49119" rel="noopener ugc nofollow" target="_blank">了解更多信息。</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="d2fe" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">改进了模板字符串类型中<code class="fe lu lv lw lx b">infer</code>类型的推理</h1><p id="1800" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Template String Types</code>是最新的特性之一，它倾向于在每个TypeScript版本中得到更新。</p><p id="4da6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为复习，我们可以使用带有占位符值的<code class="fe lu lv lw lx b">Template String Types</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3cc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当没有显式类型注释时，<code class="fe lu lv lw lx b">inference</code>用于提供类型信息。让我们先来看一个基本的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7bc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上是伟大的，但是，我们可以做一个更有力的推论。<code class="fe lu lv lw lx b">infer</code>关键字让我们在条件类型的条件中运行推理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="775c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以重写上面的例子，根据给定的先决条件有条件地运行<code class="fe lu lv lw lx b">infer</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7e3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上述代码在模板字符串类型中很有用，因为它们可能由不同的类型组成。<code class="fe lu lv lw lx b">Is&lt;Infer..&gt;</code>有条件地区别于那些。这种复杂逻辑的结果将在此版本中得到解决。让我们来看看不同之处:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c9e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，<code class="fe lu lv lw lx b">100</code>作为类型比<code class="fe lu lv lw lx b">number</code>更准确。</p><p id="2635" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击查看PR <a class="ae mm" href="https://github.com/microsoft/TypeScript/pull/48094" rel="noopener ugc nofollow" target="_blank">了解更多信息。</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5784" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">构建改进</h1><p id="ec22" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">众所周知，TypeScript的一个致命弱点一直是它的性能和构建时间。围绕<code class="fe lu lv lw lx b">--build</code>、<code class="fe lu lv lw lx b">--watch</code>、<code class="fe lu lv lw lx b">-incremental</code>做了一堆优化。简而言之，这一切都围绕着不重新计算被缓存的<code class="fe lu lv lw lx b">timestamps</code>。</p><p id="47e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那些变化有多大？最低的改善情景意味着<code class="fe lu lv lw lx b">10%</code>下降，而最佳情景意味着<code class="fe lu lv lw lx b">40%</code>。这些数字可以在<a class="ae mm" href="https://github.com/microsoft/TypeScript/pull/48784" rel="noopener ugc nofollow" target="_blank">这里</a>看到，是检查1994年大型项目的结果。</p><p id="a276" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击查看PR <a class="ae mm" href="https://github.com/microsoft/TypeScript/pull/48784" rel="noopener ugc nofollow" target="_blank">了解更多信息。</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ac0c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">与对象/数组文字进行比较时出现支持错误。</h1><p id="155b" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">这是一个很好的增强，可以在早期发现错误。在TypeScript中，您可以使用<code class="fe lu lv lw lx b">==</code>或<code class="fe lu lv lw lx b">===</code>操作符进行比较。当使用对象时，它将检查它们是否都指向同一个引用。不会比较它们的价值。</p><p id="f024" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为此版本的一部分，TypeScript将为我们排除这些场景:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="cb2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你懂这门语言，你就不太可能犯这个错误。然而，这将有助于学习JavaScript的复杂性。</p><p id="6d14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击查看PR <a class="ae mm" href="https://github.com/microsoft/TypeScript/pull/45978" rel="noopener ugc nofollow" target="_blank">了解更多信息。</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="59f9" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">包裹</h1><p id="0679" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">就是这样。我们有一个可靠的版本，可以帮助很多小地方。当我们看到一些核心问题得到解决时，这是令人敬畏的。这意味着在添加更多特性之前，语言变得越来越坚实。</p><p id="9751" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你需要更多的细节，请点击这里查看TypeScript 4.8发布计划<a class="ae mm" href="https://github.com/microsoft/TypeScript/issues/49074" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a7c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建时间的改进应该足以让每个人都非常兴奋，并立即安装这个新版本。</p><p id="0884" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯</p><h1 id="ed4f" class="mu mv it bd mw mx nt mz na nb nu nd ne jz nv ka ng kc nw kd ni kf nx kg nk nl bi translated">有关系的</h1><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/5-typescript-libraries-to-improve-your-codebase-d26f74a5c3"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">5个类型脚本库来改进您的代码库</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">增加你对静态打字的信心</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">better编程. pub</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/es2022-features-javascript-a9f8f5dcba5a"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">ES2022有什么新功能？4个最新的JavaScript特性</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">新ES13规格概述</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">better编程. pub</p></div></div><div class="ok l"><div class="oq l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>