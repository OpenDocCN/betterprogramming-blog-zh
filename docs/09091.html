<html>
<head>
<title>Save Development Time by Using Xcode Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Xcode模板节省开发时间</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/save-development-time-by-using-xcode-templates-92b8c620fff6?source=collection_archive---------8-----------------------#2021-07-14">https://betterprogramming.pub/save-development-time-by-using-xcode-templates-92b8c620fff6?source=collection_archive---------8-----------------------#2021-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8a11" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Xcode中为自己和团队创建自定模板</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06b2d4effe915ac8eb140abbdd3954ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KGXKBsGrokaHYDCA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@zanilic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Zan </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="1054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当一个团队成长时，它决定采用特定的架构和特定的模式。它可以使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank"> MVVM </a>或<a class="ae ky" href="https://www.objc.io/issues/13-architecture/viper/" rel="noopener ugc nofollow" target="_blank">蝰蛇</a>。它可以使用UIKit或SwiftUI。它可以使用<a class="ae ky" href="https://www.hackingwithswift.com/sixty/9/5/protocol-oriented-programming" rel="noopener ugc nofollow" target="_blank">面向协议的编程</a>或<a class="ae ky" href="https://riccardocipolleschi.medium.com/stop-using-protocols-cd63744a3261" rel="noopener">协议见证方法</a>。许多这些模式需要一些样板文件，我们从来不喜欢写。</p><p id="0ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何Xcode开发者都非常熟悉“新文件”屏幕，可以通过输入⌘+N.来调用它</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/2d1e4d2355c73f058deb224a00c7fd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdM3ndima1-WZ9tX8NnRzg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Xcode 13.0中的新文件屏幕</p></figure><p id="e0b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该对话框为某些文件类型提供了不同的模板。其中一些模板只是空文件。“Swfit文件”出现了一些标题，一个<code class="fe lw lx ly lz b">import Foundation</code>语句，就是这样。其他人已经有了几行可以进一步定制的代码。</p><p id="f990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多iOS开发者不知道我们可以自己创建模板。我们甚至可以用不同的文件创建文件夹。在MVVM应用程序中，我们可以自动创建整个<code class="fe lw lx ly lz b">View</code>、<code class="fe lw lx ly lz b">ViewController</code>、<code class="fe lw lx ly lz b">Model</code>和<code class="fe lw lx ly lz b">ViewModel</code>样板文件。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="59fe" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">模板在哪里？</h1><p id="7fd1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">模板是带有一些特定占位符、宏和配置的源文件，Xcode在启动时会读取这些文件。为了创建我们自己的模板，我们需要知道Xcode将从哪个文件夹中读取它们。</p><p id="f468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何Xcode安装都自带包含所有模板的<code class="fe lw lx ly lz b">Templates</code>文件夹。对于默认安装，文件夹是:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="ec5a" class="ni mi it lz b gy nj nk l nl nm">/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates</span></pre><p id="4e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在这个路径上运行<code class="fe lw lx ly lz b">open</code>,您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/5d01676d44026d2667df4e6f7a7882ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qeHl5XcJEFZXdztc_sgJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">默认Xcode模板。我深入到文件模板以获取更多信息。</p></figure><p id="e34b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果默认路径中没有安装Xcode，您可以通过导航到<code class="fe lw lx ly lz b">Xcode.app</code>包，然后沿着<code class="fe lw lx ly lz b">/Contents/Developer/Library/Xcode/Templates</code>路径找到相同的目录。</p><p id="16ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我安装了不同版本的Xcode，Xcode 13.0 <code class="fe lw lx ly lz b">Templates</code>文件夹的路径如下:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="f7c9" class="ni mi it lz b gy nj nk l nl nm">/Applications/<strong class="lz iu">Xcode-beta.app</strong>/Contents/Developer/Library/Xcode/Templates</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="cc59" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">模板是用什么做的？</h1><p id="6216" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">从这个位置，我们可以探索Xcode提供的所有标准模板。这是一个开始研究它们和学习我们能做什么的好地方。例如，我们可以深入到<code class="fe lw lx ly lz b">/File Templates/Multiplatform/User Interface/</code>路径，看看<code class="fe lw lx ly lz b">SwiftUI View</code>模板是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/75702e0281ec6c049755c0e12d47d7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0ooErc_DIduDwM6Afgpmg.png"/></div></div></figure><p id="860e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">甚至在打开Swift文件之前，我们就可以推断出一些规则:</p><ol class=""><li id="ac2f" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">模板的所有文件被分组到一个扩展名为<code class="fe lw lx ly lz b">.xctemplate</code>的文件夹中</li><li id="0bb5" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">Swift文件有一个古怪的名字:<code class="fe lw lx ly lz b">___FILEBASENAME___.swift</code>。</li><li id="cfb0" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">有一个配置文件叫<code class="fe lw lx ly lz b">TemplateInfo.plist</code>。</li></ol><p id="4b6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们打开Swift文件，我们可以看到它的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个文件中，有两种占位符。有以<code class="fe lw lx ly lz b">___</code>(三个下划线字符)开始和结束的占位符，也有用<code class="fe lw lx ly lz b">/*@</code>和<code class="fe lw lx ly lz b">@*/</code>包装的占位符。</p><p id="6b89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前者在创建文件时被Xcode替换，或者通过从对话框中请求用户输入，或者用一些预配置的值替换它们，就像<code class="fe lw lx ly lz b">___FILEHEADER___</code>占位符的情况一样。</p><p id="01ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后者以经典的自动完成外观出现在项目中:它们以浅灰色突出显示，我们可以使用<code class="fe lw lx ly lz b">TAB</code>按钮浏览它们。</p><p id="838e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以打开<code class="fe lw lx ly lz b">TemplateInfo.plist</code>文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/6ceee2412c178afb54bd29d08aabc470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jB7RXZh9XBD-nSMrilgMw.png"/></div></div></figure><p id="1c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件包含一些关于模板的元信息。它包含文件的<code class="fe lw lx ly lz b">Kind</code>，文件类型(在<code class="fe lw lx ly lz b">AllowedTypes</code>键中)，我们甚至可以在<code class="fe lw lx ly lz b">Image/FileTypeIcon</code>字段中提供一个自定义图标。</p><p id="549e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里最重要的属性是<code class="fe lw lx ly lz b">MainTemplateFile</code>:这个属性将<code class="fe lw lx ly lz b">TemplateInfo</code>映射到实际的模板。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="16d6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">我可以在哪里创建自己的模板？</h1><p id="d4d3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">既然我们知道Xcode将这些文件存储在哪里，我们可能会尝试直接在这些文件夹中创建自定义模板。然而，这并不是最聪明的事情:</p><ol class=""><li id="dc67" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">如果我们使用不同版本的Xcode，这些模板只能被我们保存它们的版本访问。</li><li id="a83a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">当我们用一个新的版本更新那个版本时，有一个不小的机会，文件夹将被删除并用新的版本重新创建，导致我们心爱的模板完全丢失。</li></ol><p id="c9a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这两个问题，我们可以利用系统中的另一个文件夹:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="f325" class="ni mi it lz b gy nj nk l nl nm">~/Library/Developer/Xcode</span></pre><p id="a28e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件夹被所有Xcode版本用来加载我们的偏好和自定义设置。它还包含许多其他文件夹:<code class="fe lw lx ly lz b">DerivedData</code>、<code class="fe lw lx ly lz b">Products</code>和<code class="fe lw lx ly lz b">UserData</code>、<strong class="lb iu">、</strong>(包含我们在Xcode中定制的所有代码片段和按键绑定)。</p><p id="8537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="og">注意:你这里可能还没有</em> <code class="fe lw lx ly lz b"><em class="og">Templates</em></code> <em class="og">文件夹。可以和第一个模板一起自己创建！</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6837" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">如何创建模板</h1><p id="5241" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">要创建一个模板，我的建议是使用向后的方法:</p><ol class=""><li id="6e15" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">找出什么可以作为有用的模板。一般来说，这是我们反复使用的东西，需要一些样板文件。</li><li id="118b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">编写它的非模板版本。用真实的类名、结构名和变量名创建文件。在操场或真实项目中创建它，这样您就可以测试它是否正常工作。</li><li id="80e1" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">将其转换为模板。应该是用适当的宏替换一些名称。</li><li id="3f80" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">将其移动到自定义子文件夹中的<code class="fe lw lx ly lz b">~/Library/Developer/Xcode/Templates</code>文件夹。</li><li id="3705" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">在同一个子文件夹中创建<code class="fe lw lx ly lz b">TemplateInfo.plist</code>。</li><li id="e284" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">测试一切正常。</li></ol><h2 id="fbf0" class="ni mi it bd mj oh oi dn mn oj ok dp mr li ol om mt lm on oo mv lq op oq mx or bi translated">确定模板的内容</h2><p id="2c6f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们已经列出了一些可能性:MVVM/毒蛇碎片，有<code class="fe lw lx ly lz b">live</code>和<code class="fe lw lx ly lz b">unimplemented</code>骨架的目击者，等等。</p><p id="b00d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于本文的考虑，我想为利用SwiftUI预览的UIKit <code class="fe lw lx ly lz b">View</code>创建一个模板。</p><h2 id="84a5" class="ni mi it bd mj oh oi dn mn oj ok dp mr li ol om mt lm on oo mv lq op oq mx or bi translated">编写非模板版本</h2><p id="9734" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我通常和MVVM一起工作，那里的<code class="fe lw lx ly lz b">ViewModel</code> (VM)和<code class="fe lw lx ly lz b">View</code>保存在同一个文件中。因此，第一步将是使用UIKit创建一个简单的View+VM文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个<code class="fe lw lx ly lz b">ViewModel</code>，它包含一个<code class="fe lw lx ly lz b">String</code>属性和一些默认代码来呈现它。我们可以立即看到有许多样板文件。每个视图都有相同的<code class="fe lw lx ly lz b">viewModel</code>属性及其属性观察者，相同的<code class="fe lw lx ly lz b">setup</code>、<code class="fe lw lx ly lz b">style</code>和<code class="fe lw lx ly lz b">update</code>方法签名，以及相同的初始化器。</p><p id="888e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="og">注意:这些东西中的一些可以在一个适当的基类中分解出来，而不是从</em> <code class="fe lw lx ly lz b"><em class="og">UIView</em></code> <em class="og">中子类化。如果可能的话，将它们分解出来并在更具体的父类中对它们进行子类化是更好的方法。</em></p><p id="c29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在视图控制器中测试这个视图，我们会得到下面的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/70f6dff664aea323348955a8e4c2fca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*1GzYLnW8lw5TuC-1OMoJmQ.png"/></div></figure><p id="c3da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步是实际添加SwiftUI预览功能。让我们将这段代码添加到文件的底部。为了简明起见，这是前一个文件末尾的扩展名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我就不细说这是如何工作的了。几个月前我已经写了一篇关于它的文章，我建议如果你感兴趣的话可以看看。</p><p id="0f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我们需要创建一个可以映射到UIKit组件的SwiftUI视图。这可以使用<code class="fe lw lx ly lz b">UIViewRepresentable</code>协议来完成。然后，我们可以利用SwiftUI <code class="fe lw lx ly lz b">PreviewProvider</code>创建一个预览。完成后，预览面板将在Xcode中弹出，外观如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/07251efd2d7925f29717355763f6ce15.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*o2uo-jBy5pBpJHqdhKmEww.png"/></div></figure><p id="5f0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们确信一切都如我们所愿。</p><h2 id="776e" class="ni mi it bd mj oh oi dn mn oj ok dp mr li ol om mt lm on oo mv lq op oq mx or bi translated">将其转换为模板</h2><p id="3172" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在修改代码之前，有几个细节值得讨论。正如我们预期的那样，Xcode的模板系统通过利用占位符来工作。让我们看看最常见的:</p><ul class=""><li id="c14c" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu ou nv nw nx bi translated"><code class="fe lw lx ly lz b">___FILEHEADER___</code>是创建文件时Xcode放入每个Swift文件的头的占位符。</li><li id="8b64" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu ou nv nw nx bi translated"><code class="fe lw lx ly lz b">___FILEBASENAME___</code>是一个占位符，触发Xcode“新建文件”对话框中的附加对话框。在我们选择使用自定义模板创建新文件后，Xcode会要求我们选择文件名。此名称取代了此标识符。</li><li id="84aa" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu ou nv nw nx bi translated"><code class="fe lw lx ly lz b">___FILEBASENAMEASIDENTIFIER___</code>是Xcode用来获取<code class="fe lw lx ly lz b">___FILEBASENAME___</code>值并将其用作标识符的占位符。然后我们可以添加一个后缀来描述不同的实体。例如，<code class="fe lw lx ly lz b">___FILEBASENAMEASIDENTIFIER___ViewModel</code>可以用来创建一个结构，它的名字和文件的名字一样，只是加了一个<code class="fe lw lx ly lz b">ViewModel</code>后缀。</li></ul><p id="2023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用这些占位符并删除当前特定于视图的部分，模板的最终代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="6be9" class="ni mi it bd mj oh oi dn mn oj ok dp mr li ol om mt lm on oo mv lq op oq mx or bi translated">将模板移动到自定义模板文件夹</h2><p id="b606" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这一步使文件对Xcode可用。让我们运行命令导航到正确的文件夹:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="56eb" class="ni mi it lz b gy nj nk l nl nm">cd ~/Library/Developer/Xcode/</span></pre><p id="8211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们没有<code class="fe lw lx ly lz b">Templates</code>文件夹，我们需要创建一个包含<code class="fe lw lx ly lz b">File Templates</code>文件夹的文件夹。之后，让我们进入其中:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="e43a" class="ni mi it lz b gy nj nk l nl nm">mkdir -p "Templates/File Templates"<br/>cd "Templates/File Templates"</span></pre><p id="e468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要创建一个文件夹来包含我们所有的定制模板。姑且称之为<code class="fe lw lx ly lz b">Custom Templates</code>。在Xcode对话框中，这是一个可以包含许多模板的部分。然后，我们在其中创建<code class="fe lw lx ly lz b">PreviewedUIKit.xctemplate</code>文件夹，并导航到<code class="fe lw lx ly lz b">xctemplate</code>文件夹。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="3577" class="ni mi it lz b gy nj nk l nl nm">mkdir -p "Custom Templates/PreviewedUIKit.xctemplate"<br/>cd "Custom Templates/PreviewedUIKit.xctemplate"<br/>touch ___FILEBASENAME___.swift<br/>touch TemplateInfo.plist</span></pre><p id="6768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后两行创建了一个空的<code class="fe lw lx ly lz b">Swift</code>文件和一个空的<code class="fe lw lx ly lz b">TemplateInfo.plist</code>。让我们打开<code class="fe lw lx ly lz b">___FILEBASENAME___.swift</code>,将上面创建的模板粘贴进去。</p><h2 id="0fab" class="ni mi it bd mj oh oi dn mn oj ok dp mr li ol om mt lm on oo mv lq op oq mx or bi translated">创建<code class="fe lw lx ly lz b">TemplateInfo.plist</code></h2><p id="1f9b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">最后一步是创建<code class="fe lw lx ly lz b">TemplateInfo.plist</code>文件。</p><p id="78b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的建议是从复制粘贴默认Xcode模板中的一个<code class="fe lw lx ly lz b">TemplateInfo.plist</code>文件开始，然后根据需要修改它。就我而言，我的<code class="fe lw lx ly lz b">plist</code>的最后一个方面如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/69897c9a5014012e9455a8a06664cb4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2rIrYTU7WroocnHAsIWHA.png"/></div></div></figure><p id="7044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有趣的属性是:</p><ul class=""><li id="fc93" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu ou nv nw nx bi translated"><code class="fe lw lx ly lz b">DefaultCompletionName</code>—Xcode使用它来建议文件的名称。</li><li id="8a64" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu ou nv nw nx bi translated"><code class="fe lw lx ly lz b">Platforms</code> —留空，我们将创建一个多平台模板。</li><li id="7703" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu ou nv nw nx bi translated"><code class="fe lw lx ly lz b">Image</code> —通过用<code class="fe lw lx ly lz b">swift</code>值指定<code class="fe lw lx ly lz b">FileTypeIcon</code>键，Xcode为我们的模板使用默认的Swift图标。</li></ul><p id="6c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="og">注意:还有许多其他属性可以用来进一步定制我们的模板。例如，我们可以在</em> <code class="fe lw lx ly lz b"><em class="og">TemplateInfo.plist </em></code> <em class="og">中定义一个</em> <code class="fe lw lx ly lz b"><em class="og">Options</em></code> <em class="og">键，这个键可以在模板中用</em> <code class="fe lw lx ly lz b"><em class="og">___VARIABLE_optionName___</em></code> <em class="og">占位符来访问。不幸的是，我没有找到任何关于Xcode模板的官方和详细的文档。</em></p><h2 id="4a74" class="ni mi it bd mj oh oi dn mn oj ok dp mr li ol om mt lm on oo mv lq op oq mx or bi translated">测试我们的模板</h2><p id="7cf2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">最后但同样重要的是，我们需要测试我们的模板。作为第一步，我们需要关闭并重新打开Xcode。IDE需要刷新可用的模板来允许我们使用它们。</p><p id="0859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们按下⌘+N打开“新文件”对话框，并向下滚动到列表的末尾。这就是我们闪亮的新模板！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/7eec2280be4b8380276a71863d763425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMV4alXWlhqLon85-5NgUQ.png"/></div></div></figure><p id="9f4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们选择它并给视图命名。我选了<code class="fe lw lx ly lz b">AppSetup</code>。这是Xcode使用我们的模板自动生成的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2187" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="00c9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">今天，我们学习了如何在Xcode中创建模板。我们看到了它们是如何工作的，以及它们需要什么文件才能正常工作。</p><p id="a842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们学习了使用哪些占位符和哪些配置来创建基本模板。</p><p id="d80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们没有涉及如何创建包含多个文件的文件夹，或者如何使用更高级的机制，比如变量。不幸的是，我找不到任何关于如何在Xcode中创建模板的官方文档。目前，最好的学习方法是花一些时间探索默认的Xcode模板，并在GitHub上搜索一些开源库。只需搜索其中一个占位符，它们就会弹出来。</p><p id="df54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模板可以为您节省大量时间，甚至防止一些错误。他们也很容易分享。把整个<code class="fe lw lx ly lz b">.xctemplate</code>文件夹压缩一下发给同事就行了。这样就可以解锁很多价值。你和你的团队的速度都会提高。</p></div></div>    
</body>
</html>