<html>
<head>
<title>Recursive Rendering With React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React组件进行递归渲染</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursive-rendering-with-react-components-10fa07c45456?source=collection_archive---------0-----------------------#2021-02-04">https://betterprogramming.pub/recursive-rendering-with-react-components-10fa07c45456?source=collection_archive---------0-----------------------#2021-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a4b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">呈现嵌套数据结构的快速指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/78d504a4c68196ffd36314b0fb0cc807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9EHVlnVNXAwa1ppDGnV1g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="3411" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Recursion" rel="noopener ugc nofollow" target="_blank">维基百科</a>这样描述递归:</p><blockquote class="lv"><p id="a0f4" class="lw lx it bd ly lz ma mb mc md me lt dk translated">"当过程的一个步骤涉及到调用过程本身时，递归就是过程所经历的过程。"</p></blockquote><p id="571f" class="pw-post-body-paragraph ky kz it la b lb mf ju ld le mg jx lg lh mh lj lk ll mi ln lo lp mj lr ls lt im bi translated">在编程术语中，它是一个调用自身的函数。我们可以用一个非常简单的例子来说明这个概念:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="ba1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你看到上面的片段时，你会意识到一些事情。首先，也许你没有意识到这是可能的。是的，尽管你能做到这一点有点违反直觉。我们在构造函数体的时候调用了一个函数。这确实有点奇怪。</p><p id="afa0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，您可能已经注意到了这个特定代码片段的一些特别之处:它永远不会停止运行。这是一个无限循环！你可能是正确的。我们的浏览器不喜欢这样，在迭代了几千次后，它被搁置了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/da0af17cdf222fcfb33a46090b5b9be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*Vn3jZMfyOQmR4Wm31OpYbw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">出错信息</p></figure><p id="e9b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为我们小小的说明性函数不包含任何阻止这种情况发生的逻辑。没有<em class="mn">终止条件</em>。但是很容易添加，我们很快就会看到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/6a89582f30ad99bdac5361b388ddcc86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6IeCtpSx57lMSsFU_2b5yA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这就是我们今天要创造的！</p></figure><p id="8779" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:你可以在GitLab 上的<a class="ae lu" href="https://gitlab.com/gvanderput/gerard-recursive-tree" rel="noopener ugc nofollow" target="_blank"> my repository中找到下面的所有代码。</a></p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="0128" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">React中的递归</h1><p id="29b5" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">我们刚刚解释了一个函数可以调用它自己。由于React组件也是一个函数，因此它也可以呈现自身:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="9488" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，渲染上述内容会导致无限循环，因为我们没有终止循环的条件。但是如果我们添加一些简单的逻辑(和一些简单的内联样式),确保我们的循环只迭代五次:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c042" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/728a1a293f62e75edfb81d31e48d1dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3eOuOsXW_wcoAU_Hy4h9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">React组件的递归呈现</p></figure><p id="18bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以看到，<code class="fe nu nv nw nx b">MyComponent</code>是在 <code class="fe nu nv nw nx b">MyComponent</code>里面渲染<em class="mn">的，这个过程自己重复了五次。很迷人，不是吗？</em></p><p id="9aba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将快速看一下如何在现实世界的例子中利用这一点。有许多用例，但传统的一个是呈现嵌套数据。嵌套数据的一个例子是文件系统中的目录结构。目录可以包含目录，目录也可以包含目录，等等。</p><p id="d169" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用一些虚拟数据，但效果是一样的。正如您已经看到的，这是我们将要创建的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/6a89582f30ad99bdac5361b388ddcc86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6IeCtpSx57lMSsFU_2b5yA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">嵌套行</p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="8b8a" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">数据源</h1><p id="ab11" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">我们从表示树中所有项目(行)的一些数据开始。文件<code class="fe nu nv nw nx b"><a class="ae lu" href="https://gitlab.com/gvanderput/gerard-recursive-tree/-/blob/master/components/Tree/nestedTreeData.json" rel="noopener ugc nofollow" target="_blank">nestedTreeData.json</a></code>看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/775d8ea53919cf7e87c13431dbb84af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*LBZENObIvF_juEl7uULQzg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的JSON文件中的前七条记录</p></figure><p id="efa8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们有一个平面数据结构—所有记录都存在于同一级别。记录里面没有记录，也不应该有(在我看来)。这会让你的生活轻松很多。我写了一篇关于这个概念的完整文章，我强烈推荐你在之后阅读。</p><p id="5fd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意这些记录是如何包含一个名为<code class="fe nu nv nw nx b">parentId</code>的属性的。这些指针指向同一列表中的另一条记录。他们定义哪个记录是他们的祖先。前三条记录没有<code class="fe nu nv nw nx b">parentId</code>(它等于零)。那些是最高级别的记录。我们可以看到，顶级记录<code class="fe nu nv nw nx b">Fruits</code>有三个后代(子代):<code class="fe nu nv nw nx b">Citrus</code>、<code class="fe nu nv nw nx b">Stone fruits</code>和<code class="fe nu nv nw nx b">Berries:</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2513480f53a70cc66c6cdc38cd8b2899.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/1*l1j59fGhiQGnE8xKmTKGpw.png"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="d21d" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">准备我们的数据</h1><p id="7ac7" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">我们创建一个实用函数来读取JSON文件并准备数据。在返回它之前，我们所做的唯一一件事就是为每条记录添加一个新的布尔属性(<code class="fe nu nv nw nx b">hasChildren</code>)，以表明是否有记录指向它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d0b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们没有将子记录添加到父记录中。我们希望保持我们的数据结构平坦，我们很快就会看到这是如何给我们带来好处的。</p><p id="2668" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面函数返回的数据被传递给我们的<code class="fe nu nv nw nx b">Tree</code>组件(见下一节)，名为<code class="fe nu nv nw nx b">treeData</code>。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="c2bf" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">树组件</h1><p id="ccff" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">组件是递归魔术发生的地方。我们将渲染树里面的树。这时你应该喝一口热饮，然后跟着喝。</p><p id="72bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从组件定义开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d809" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你知道<code class="fe nu nv nw nx b">treeData</code>参数是什么。第二个是<code class="fe nu nv nw nx b">parentId</code>，表示我们想要呈现哪些记录——将该值作为其<code class="fe nu nv nw nx b">parentId</code>的记录。在我们查看组件主体之前，让我们快速看一下如何在页面上呈现我们的<code class="fe nu nv nw nx b">Tree</code>:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="abb2" class="oe mx it nx b gy of og l oh oi">&lt;Tree treeData={treeData} /&gt;</span></pre><p id="99df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，我们只传递数据。这意味着对于呈现我们的<code class="fe nu nv nw nx b">Tree</code>组件的第一次迭代，我们将使用参数<code class="fe nu nv nw nx b">parentId</code>和<code class="fe nu nv nw nx b">level</code>(都是<code class="fe nu nv nw nx b">0</code>)的默认值。记住这一点。</p><p id="346e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到组件的主体。首先，我们将选择要呈现的记录:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e3ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也按字母顺序排列它们(第4行),因为我们可以。</p><p id="d7c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一行很有趣(也很重要):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d28e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们没有找到给定的<code class="fe nu nv nw nx b">parentId</code>的任何记录，我们通过返回<code class="fe nu nv nw nx b">null</code>来停止。我现在不会对此做任何进一步的评论，但请记住，因为我稍后会提到它(剧透警告:它防止了无限循环)。</p><p id="e3da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们返回我们的元素。我们迭代我们找到的项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="3d47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第8-11行，对于我们过滤掉的每一项，我们呈现一个<code class="fe nu nv nw nx b">Row</code>元素。每个<code class="fe nu nv nw nx b">Row</code>元素都有一个子元素:另一个<code class="fe nu nv nw nx b">Tree</code>元素！递归的极致。</p><p id="fd90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这一点上你可能会有疑问。让我们更深入地了解一下正在发生的事情。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ebea" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">进一步解释</h1><p id="7983" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">当我们呈现我们的<code class="fe nu nv nw nx b">Tree</code>组件时，除了数据之外，我们没有传递任何参数:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="56b7" class="oe mx it nx b gy of og l oh oi">&lt;Tree treeData={treeData} /&gt;</span></pre><p id="7fe1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着我们用值为<code class="fe nu nv nw nx b">0</code>的参数<code class="fe nu nv nw nx b">parentId</code>和<code class="fe nu nv nw nx b">level</code>来呈现我们的组件。因此，在我们的<code class="fe nu nv nw nx b">Tree</code>组件主体的顶部，当我们过滤数据时，我们将剩下三个顶级记录。</p><p id="2f90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，第2-4行的逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="0124" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将选择这些记录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9cbc0ec2acec209f7bb85415f5097c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*TWdrcgUGOipFEZSBl0OxMA.png"/></div></figure><p id="f552" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，对于这三条记录中的每一条，我们呈现一个<code class="fe nu nv nw nx b">Row</code>元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="ba62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会在本文中展示<code class="fe nu nv nw nx b">Row</code>组件(你可以在回购中找到<a class="ae lu" href="https://gitlab.com/gvanderput/gerard-recursive-tree/-/blob/master/components/Tree/Row.tsx" rel="noopener ugc nofollow" target="_blank">完整文件</a>)，但基本上，它所做的就是呈现这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d583ae6a46a93cdfe0809b9435bddcd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:194/format:webp/1*U5sQZACMltCRq4kasYXVPQ.png"/></div></figure><p id="8901" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它呈现一行。一张唱片。作为<code class="fe nu nv nw nx b">div</code>元素。带有一些漂亮的图标和一些跟踪行是扩展还是收缩的状态。在这个<code class="fe nu nv nw nx b">div</code>之下，它还做了一件事:它呈现传递的子元素。</p><p id="aea3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们向它传递了一个子元素:另一个<code class="fe nu nv nw nx b">Tree</code>元素！整个过程再次开始，<em class="mn">在最初的</em> <code class="fe nu nv nw nx b"><em class="mn">Tree</em></code> <em class="mn">元素里面，我们正在渲染</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a798" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">递归调用。</p><p id="57e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一不同的是，这次我们使用了其他属性值。<code class="fe nu nv nw nx b">treeData</code>保持不变，但是<code class="fe nu nv nw nx b">parentId</code>现在变成了我们当前正在呈现的记录的ID(比如说<code class="fe nu nv nw nx b">fruits</code>)。</p><h2 id="a16d" class="oe mx it bd my ol om dn nc on oo dp ng lh op oq ni ll or os nk lp ot ou nm ov bi translated">防止无限循环</h2><p id="e6f2" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">还记得我们的<code class="fe nu nv nw nx b">Tree</code>组件体内的这行代码吗？</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="6ba7" class="oe mx it nx b gy of og l oh oi">if (!items.length) return null;</span></pre><p id="d642" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将停止潜在的无限循环。什么时候？当我们遇到这样的情况，我们开始渲染<code class="fe nu nv nw nx b">Tree</code>组件，但是我们没有为给定的<code class="fe nu nv nw nx b">parentId</code>找到任何项目(记录)。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ecbd" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">一锤定音</h1><p id="60be" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">递归有时是一个很难理解的话题。我希望这篇文章通过一个简单的例子来引导您，从而驱散一些迷雾。这是我在<a class="ae lu" href="https://gerardvanderput.medium.com/" rel="noopener">我的媒体文章</a>中经常使用的格式。</p><p id="1ba6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我结束之前，你试过谷歌一下“递归”这个词吗？</p><p id="00e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当显示结果时，谷歌巧妙地回答:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/902a81ab7435eb5fd48c7c0645e90da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*ZMSbHv6SHRC1Jh-PBMNi6g.png"/></div></figure><p id="9436" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的宝贵时间！</p></div></div>    
</body>
</html>