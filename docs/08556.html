<html>
<head>
<title>5 Oddities of JavaScript That Might Cause Headaches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的5个奇怪之处可能会让人头疼</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-oddities-of-javascript-that-might-cause-headaches-99f011abae0f?source=collection_archive---------9-----------------------#2021-05-13">https://betterprogramming.pub/5-oddities-of-javascript-that-might-cause-headaches-99f011abae0f?source=collection_archive---------9-----------------------#2021-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1f8d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">欢迎来到JavaScript的疯狂世界</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e10a1f9648d86f9d963564fa1e34719a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l5_SFzOd_5DJBtn2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mittaluday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乌代·米塔尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您熟悉JavaScript，那么在使用它时，您很可能会遇到一些意想不到的奇怪行为。其中一些可能是开发人员之间的一个很好的笑话，但是了解它们可以为您节省大量时间和调试代码的麻烦。</p><p id="8c41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想向你介绍其中的一些怪癖。</p><h1 id="b7d5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.平等和相同</h1><p id="943c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在JavaScript如何定义相等性和相同性方面存在微妙而重要的差异。对于初学者来说，最令人困惑的可能是抽象的<code class="fe ms mt mu mv b">==</code>和严格的<code class="fe ms mt mu mv b">===</code>相等检查之间的区别。</p><p id="d9da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先来看几个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe ms mt mu mv b">null</code>相比如何？</p><p id="4972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你将<code class="fe ms mt mu mv b">null</code>转换成布尔值，它就是<code class="fe ms mt mu mv b">false</code>。<br/>然而，如果你试图比较<code class="fe ms mt mu mv b">null</code>和<code class="fe ms mt mu mv b">false</code>，结果仍然是<code class="fe ms mt mu mv b">false</code>！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ee2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们比较其他的伪值，比如<code class="fe ms mt mu mv b">0</code>或<code class="fe ms mt mu mv b">""</code>和<code class="fe ms mt mu mv b">false</code>，会怎么样呢？<br/>你可能会认为那也是<code class="fe ms mt mu mv b">false</code>。不过这只适用于严格的等式检查，抽象将导致<code class="fe ms mt mu mv b">true</code>！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们看到抽象的相等检查在某些情况下将两个不同类型的变量分类为相等。然而，如果您将一个空数组(真值)与<code class="fe ms mt mu mv b">true</code>进行比较，您可能会再次感到惊讶:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="56ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解JavaScript中抽象等式比较和严格等式比较的区别很重要。我强烈推荐阅读MDN的这篇文章，其中他们详细解释了平等和相同。</p><div class="my mz gp gr na nb"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">平等比较和相同</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">ES2015中有四种等式算法:抽象等式比较(==)严格等式比较(===):已用…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">developer.mozilla.org</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ks nb"/></div></div></a></div><h1 id="c0b4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.数学疯狂</h1><p id="9222" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们继续我们的数学之旅！JavaScript在这里为我们准备了一些美丽的怪癖:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="48d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么第一个例子是正确的，而第二个却不是？这样做的原因是，第一个只在这种特定情况下有效。如果您看一下JavaScript对这些表达式求值的顺序，就会明白为什么会得到这些结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="83f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中数学的另一个陷阱是这些“神奇地”增加的数字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于IEEE 754–2008标准的<a class="ae ky" href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener ugc nofollow" target="_blank">，JavaScript在这个尺度上舍入到下一个最接近的偶数。这对于许多其他编程语言都是一样的，不仅仅是JavaScript。该标准还对以下问题负责:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c2f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题在StackOverflow上的<a class="ae ky" href="https://stackoverflow.com/a/588014" rel="noopener ugc nofollow" target="_blank">这个回答</a>中有很多详细的解释。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="9e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解JavaScript如何决定加法和串联也很重要。一般来说，你可以说每次一个字符串被包含在加法中，它在操作中的某一点变成一个连接。</p><p id="7259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在一些令人惊讶的情况下，加法运算会变成完全不同的类型，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="4303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，我把最令人困惑的例子留到了最后。让我们比较函数<code class="fe ms mt mu mv b">Math.min()</code>和<code class="fe ms mt mu mv b">Math.max()</code>的结果</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ee8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这绝对不是我第一次使用这个功能时所期望的。查理·哈维在他的博客上解释了这种行为<a class="ae ky" href="https://charlieharvey.org.uk/page/why_math_max_is_less_than_math_min#" rel="noopener ugc nofollow" target="_blank">，所以如果你对细节感兴趣，可以去那里看看。</a></p><h1 id="1e67" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.数组的乐趣</h1><p id="6823" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在前面的章节中，我们已经看到了一些关于数组的例子，但是关于数组还有更多有趣的事实。</p><p id="4c96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您尝试将两个数组相加，会得到以下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这似乎令人困惑，但当您理解这种连接的执行顺序时，这是有意义的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="0ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript如何处理尾随逗号也很有趣。<br/>在数组中，尾随逗号将被忽略，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你有多个尾随逗号呢？这就是<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas#trailing_commas_in_literals" rel="noopener ugc nofollow" target="_blank"> MDN </a>在这个例子中描述JavaScript行为的方式:</p><blockquote class="nx ny nz"><p id="5c8e" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">如果使用了一个以上的结尾逗号，就会产生一个省略号(或孔)。一个有孔的数组叫做<em class="it">稀疏</em>(一个<em class="it">密集</em>数组没有孔)。当用<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">Array.prototype.forEach()</a></code>或<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">Array.prototype.map()</a></code>迭代数组时，数组空洞会被跳过。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="13e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到前两个逗号生成了前面描述的孔。但是，最后一个逗号将被忽略，因为它与普通数组项一样。这就是我们最终得到的最终长度<code class="fe ms mt mu mv b">5</code>。</p><h1 id="c0a5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.巧妙的箭头功能</h1><p id="2d4e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在ES6中引入的arrow函数很快变得流行起来，因为它们的最小语法和更直观的<code class="fe ms mt mu mv b">this</code>对象行为。</p><p id="bb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有使用箭头函数的人都遇到过的一个常见陷阱是，当您在函数中返回值时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="01d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是不要错过这里的括号；否则，你的函数将返回<code class="fe ms mt mu mv b">undefined</code>，因为你打开了函数却没有返回任何值。</p><p id="cb9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解JavaScript中箭头函数的更多信息，可以看看MDN文档。</p><div class="my mz gp gr na nb"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">箭头函数表达式</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">arrow函数表达式是传统函数表达式的一种紧凑替代形式，但它是有限的，不能…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">developer.mozilla.org</p></div></div><div class="nk l"><div class="oe l nm nn no nk np ks nb"/></div></div></a></div><h1 id="a77a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.弦不弦？</h1><p id="750d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">是的，你没看错。看一下下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="819d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到<code class="fe ms mt mu mv b">typeof</code>像预期的那样工作，但是<code class="fe ms mt mu mv b">instanceof</code>为一个<code class="fe ms mt mu mv b">String</code>返回<code class="fe ms mt mu mv b">false</code>，尽管我们知道<code class="fe ms mt mu mv b">"str"</code>确实是一个字符串。</p><p id="9bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您使用<code class="fe ms mt mu mv b">String()</code>构造函数，您将得到预期的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b1c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是什么原因呢？<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener ugc nofollow" target="_blank"> MDN </a>这样描述<code class="fe ms mt mu mv b">instanceof</code>:</p><blockquote class="nx ny nz"><p id="df09" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated"><code class="fe ms mt mu mv b"><strong class="lb iu">instanceof</strong></code> <strong class="lb iu">操作符</strong>测试一个构造函数的<code class="fe ms mt mu mv b">prototype</code>属性是否出现在一个对象的原型链中。返回值是一个布尔值。</p></blockquote><p id="695e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是字符串原语与字符串对象并不完全相同。如果你仍然想要类型检查原语，你应该使用<code class="fe ms mt mu mv b">typeof</code>而不是<code class="fe ms mt mu mv b">instanceof</code>。</p><h1 id="a325" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.额外收获:JavaScript中的HTML！</h1><p id="76a7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你知道你可以用JavaScript写一点HTML吗？正如您在下面的例子中看到的，JavaScript中的HTML注释完全有效。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="66c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是很久以前引入的，所以旧的浏览器——还不理解<code class="fe ms mt mu mv b">&lt;script&gt;</code>标签——不会崩溃。这些浏览器早已寿终正寝，但其功能依然存在。甚至在NodeJS！</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="9469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是JavaScript中许多怪癖的一小部分。如果你想深入了解，我可以推荐这个由<strong class="lb iu"> denysdovhan </strong>开发的名为<a class="ae ky" href="https://github.com/denysdovhan/wtfjs" rel="noopener ugc nofollow" target="_blank"> wtfjs </a>的令人敬畏的GitHub库。</p></div></div>    
</body>
</html>