# Python 异步编程入门

> 原文：<https://betterprogramming.pub/getting-started-with-asynchronous-programming-in-python-2797129dd0b3>

## 利用 asyncio 中的异步和等待特性

![](img/82123c465bf69401fdde6904baf7d7bd.png)

照片由 [Ash Edmonds](https://unsplash.com/@badashproducts?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 第一眼

在我们的许多应用程序中，我们只需要处理同步编程。这意味着代码将在单线程上线性执行。以下代码向您展示了一个简单的示例:

同步代码示例

*   `load_data_for_user`函数调用`authenticate_user`和`get_posts_remotely`。
*   这两个函数按顺序执行，需要五秒钟完成，与时间戳中显示的时间差相匹配。

显然，如果用户必须等待五秒钟才能显示数据，用户体验不会太好。这就是异步编程特别有用的地方。看看下面更新的代码:

异步代码示例

如果你现在还不明白，那也没关系，因为我们将在本文中学习异步编程。然而，要注意的一点是，相同功能(即不同的功能，但完成相同的工作)的总执行时间减少到三秒。

与前面显示的同步代码示例不同，在这个异步代码示例中，身份验证和后期获取功能有所重叠。更简单地说，异步编程可以启动下一个任务，而不必等待前面的任务返回结果。换句话说，同步代码按顺序运行任务(例如，函数)，直到当前任务完成，执行才会继续。相比之下，异步编程允许不同的任务同时运行。

## 为什么是异步编程

在最近的 Python 版本中，已经引入了`asyncio`模块，使得编写异步程序变得更加容易。您可能想知道为什么我们会费心使用异步编程技术，如果您同步运行它，会增加程序的复杂性。一个快速的经验法则是，如果你的程序涉及较慢的输入/输出(I/o——这就是`asyncio`所指的)通信(例如，上面讨论的互联网请求),你可以考虑用异步技术优化你的程序，这将极大地提高你的程序的整体效率。

用一个更专业的术语来说，异步编程允许代码中的任务并发运行。就处理 i/o 而言，并发性试图解决 i/o 相关的问题——那些由于输入/输出需求而具有速度限制的问题。并发性肯定比逐个运行这些任务要快，因为这些任务中的每一个都需要花费相当长的时间来等待特定的 i/o 事件完成。

然而，应该注意的是，使用基于`asyncio`的代码并不是编写并发代码的唯一方式。在 Python 中，还有一些实现并发的其他方法，比如*线程*和*多处理*。后者对于解决 CPU 受限的问题特别有用，比如解决计算量大的任务。关于这个主题的精彩概述，请参考博客文章[这里](https://realpython.com/python-concurrency/)。

# 用 Async/Await 创建协同例程

协程是一种编程技术，其中特定的进程在某一点开始，在稍后的某一点退出，这可以通过使用`yield`关键字的生成器函数来实现。我在以前的博客文章中提到过这个话题，如果你想了解更多，请随意参考。随着标准库中引入了`asyncio`模块，使用`async`关键字已经成为实现协程的首选方式。让我们来看看。

协程的创建

*   如前所示，我们在`def`关键字之前使用了`async`关键字来表示异步函数的声明。
*   在函数体中，我们使用`await`关键字来表示协程上的等待。在这种情况下，我们简单地模拟一个需要一秒钟来执行的虚拟流程。
*   您可能会觉得有趣的一点是，当您调用这个函数时，您不会看到预期的文本(例如，Hello)被打印出来。相反，您得到的是一个协程对象，如交互式控制台中的对象表示所示。如果您熟悉 Python 生成器，可以打个比方。以类似的方式，调用生成器函数将创建一个生成器，它本质上是一个协程功能。

要实际运行协程，有几个选项，将在下一节讨论。

# 执行协程

在第一节中，您已经看到了第一个选项— *使用* `*asyncio*` *模块*中的 `*run*` *函数。让我们看看它是否像预期的那样工作。*

使用 run 执行协程

我们将创建的协程对象发送给`asyncio.run`函数。如您所见，这两个字符串打印成功，这意味着协程已经执行。

需要注意的一点是，`run`函数总是会创建一个新的事件循环。因此，建议您使用该函数作为异步程序的起点。

第二种选择与第一种密切相关。考虑下面的例子:

使用 await 执行协程

*   我们创建了另一个名为`say_hello_caller`的异步函数。在函数中，我们从前面定义的函数(即`say_hello`)创建一个协程对象。我们只是使用`await`关键字等待协程对象。
*   当您使用`asyncio.run`函数调用`say_hello_caller`函数时，您会注意到协程`say_hello_coroutine`被执行了。本质上，协程上的`await`关键字能够调度协程运行。

因此，执行协程的第二个选择是等待协程。实际上，当我们使用`asyncio.sleep`创建虚拟延迟时，我们已经开始使用它了。如果您还不知道的话，`sleep`方法实际上创建了一个协程对象。见下文:

```
>>> asyncio.sleep(1)
<coroutine object sleep at 0x111075f40>
```

只是在我们运行函数的时候，`sleep`方法让我们等了一秒。在上面的代码片段中，`sleep`方法只是返回一个协程对象。

第三个选项是*运行包装成任务的协程*。在 Python 中，任务是类似未来的对象，在事件循环中运行协程。如果你熟悉 JavaScript，它们与 JavaScript 的未来有相似的概念。本质上，它们是用来处理将要发生的异步结果的。以下代码片段向您展示了如何将协程作为任务执行:

使用任务运行协程

*   我们简单地使用`create_task`将协程封装到一个任务中。
*   使用创建的任务，我们可以简单地在异步函数中等待任务。
*   如您所见，协程对象能够执行任务。

# 使用并发任务的结果

在本文的开始，您可能已经注意到使用了`gather`函数来并发运行协程。具体来说，我们只需在 gather 函数中列出协程，它会自动将它们包装成任务并并发执行。让我们看看下面的简化代码示例:

收集任务

上面的代码向您展示了我们使用 gather 函数并发运行任务的情况。然而，它确实有一个问题—我们不能使用这些任务返回的数据。

使用任务中的数据

实际上，获取数据就像使用任务返回值一样简单，如上面代码片段的第八行所示。

需要注意的一点是，聚集函数本身不会让任务立即运行。相反，它在您使用`await`关键字时运行。从打印输出中，您可以看到从聚合任务返回的结果。值得注意的是，结果的顺序与任务的顺序相匹配。

当然，我们可以从异步函数返回获取的结果，并使用这些数据相应地更新用户界面。

# 在你走之前

在本文中，我们已经通过利用`asyncio`模块触及了基于异步编程。请注意，这只是关于这个主题的介绍——本文中提供的例子对于您编写异步程序来说还不够。对于更高级的用例，参考[官方文档](https://docs.python.org/3/library/asyncio.html)来了解更多关于这个方便的模块总是一个好主意。

感谢您阅读这篇文章。