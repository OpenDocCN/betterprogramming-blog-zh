<html>
<head>
<title>BroadcastReceiver in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的广播接收器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/broadcastreceiver-in-android-adcfe2801a6b?source=collection_archive---------0-----------------------#2021-07-04">https://betterprogramming.pub/broadcastreceiver-in-android-adcfe2801a6b?source=collection_archive---------0-----------------------#2021-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="515d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理系统范围和自定义广播</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5ee757f8a0f581cfa513b70fa0409a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zWs-i6w17emY0qsU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@willfrancis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威尔弗朗西斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="5597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有四种不同类型的Android应用程序组件:</p><ul class=""><li id="1ead" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">活动</li><li id="8299" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">服务</li><li id="47b8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">广播接收机</li><li id="473a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">内容提供商</li></ul><p id="1b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">BroadcastReceiver</code>是Android组件的基本构建块之一。在本文中，让我们来探讨什么是广播，什么是广播接收机，以及我们如何使用它们。</p><p id="9aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想直接跳到代码库，查看一下<a class="ae ky" href="https://github.com/pavan5208/android_sample_broadcast_receiver" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4e95" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">什么是广播？</h1><p id="1cfb" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在Android中，广播是由于系统状态变化而发生的系统范围的事件，如<code class="fe mj mk ml mm b">LOW_BATTERY</code>、呼入或呼出、网络连接变化、设备重启等。这些是需要我们执行某些操作的一些系统事件。Android的系统在各种系统事件发生时发送广播。</p><p id="7605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们正在后台运行一项服务来完成某项任务，而系统由于电量不足而关闭。一段时间后，当用户重启或打开设备时，我们的服务将不会处于运行状态。我们可能需要一些可以强制重启服务的东西来完成任务。这就是广播发挥作用的地方。</p><p id="bc7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种情况是播放视频时网络发生变化。当网络断开时，我们会显示一条消息。当它回来时，不需要点击“重试”按钮，我们应该能够恢复视频，以获得更好的用户体验。这也可以通过听广播来实现。</p><blockquote class="nr"><p id="ab1c" class="ns nt it bd nu nv nw nx ny nz oa lu dk translated">“Android应用程序可以发送或接收来自Android系统和其他Android应用程序的广播消息，类似于<strong class="ak">发布-订阅</strong>设计模式。”— <a class="ae ky" href="https://developer.android.com/guide/components/fundamentals" rel="noopener ugc nofollow" target="_blank">安卓开发者</a></p></blockquote></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ddc2" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">什么是广播接收机？</h1><p id="c954" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">广播接收器是一个抽象类，它接收并处理由<code class="fe mj mk ml mm b">Context.sendBroadcast(Intent)</code>发送的广播意图。为了利用这一点，我们需要通过实现基本抽象类<code class="fe mj mk ml mm b">BroadcastReceiver</code>来创建一个类，并注册它。它没有任何用户界面。但是，我们可以触发通知来提醒用户。</p><pre class="kj kk kl km gt ob mm oc od aw oe bi"><span id="4d90" class="of mv it mm b gy og oh l oi oj"><strong class="mm iu">import android.content.BroadcastReceiver<br/></strong>//This class can be used to do tasks on restart of device<br/>class RestartReciever <strong class="mm iu">: BroadcastReceiver()</strong></span></pre><p id="f7ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以注册广播接收器:</p><ol class=""><li id="88d0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ok mb mc md bi translated">静态地使用清单文件中的<code class="fe mj mk ml mm b">&lt;receiver&gt;</code>标签。</li><li id="0b4e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ok mb mc md bi translated">通过调用<code class="fe mj mk ml mm b">registerReciever(receiverClassInstance)</code>在类级别动态地。</li></ol><blockquote class="ol om on"><p id="9956" class="kz la oo lb b lc ld ju le lf lg jx lh op lj lk ll oq ln lo lp or lr ls lt lu im bi translated">广播接收器是一个组件，它使系统能够在常规用户流之外向应用程序传送事件，从而允许应用程序响应系统范围的广播公告— <a class="ae ky" href="https://developer.android.com/guide/components/fundamentals" rel="noopener ugc nofollow" target="_blank">安卓开发者</a></p></blockquote><p id="c537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看实际情况。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f204" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">广播接收机的例子</h1><p id="f7fa" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们探索一下注册和收听广播的方法。</p><h2 id="1aa0" class="of mv it bd mw os ot dn na ou ov dp ne li ow ox ng lm oy oz ni lq pa pb nk pc bi translated">为启动完成静态注册BroadcastReceiver</h2><p id="bf34" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">首先，让我们创建一个在系统重启时被调用的<code class="fe mj mk ml mm b">RestartReceiver</code>类。我们需要覆盖<code class="fe mj mk ml mm b">onReceive</code>，在那里我们将接收回调。<code class="fe mj mk ml mm b">onReceive</code> <strong class="lb iu"> </strong>在系统中发生特定注册动作的广播时被调用。</p><p id="5ea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe mj mk ml mm b">RestartReceiver</code>班会这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="5511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">onReceive</code>、<strong class="lb iu">、</strong>内部，我们可以根据自己的需求做自定义动作。我们可以从首选项中获取值，如果条件得到满足，那么我们就可以导航。那样的话，我们的<code class="fe mj mk ml mm b">onReceive</code> <strong class="lb iu"> </strong>就会是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="235b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在<code class="fe mj mk ml mm b">AndroidManifest</code>文件中注册我们的接收器，以获得所需动作的广播(在我们的例子中是<code class="fe mj mk ml mm b">BOOT_COMPLETED</code><strong class="lb iu"/>)<strong class="lb iu"/>，如下所示:</p><pre class="kj kk kl km gt ob mm oc od aw oe bi"><span id="0cd3" class="of mv it mm b gy og oh l oi oj">&lt;receiver android:name=".RestartReceiver"&gt;<br/>    &lt;intent-filter&gt;<br/>     &lt;action android:name="android.intent.action.<strong class="mm iu">BOOT_COMPLETED</strong>" /&gt;<br/>    &lt;/intent-filter&gt;<br/>&lt;/receiver&gt;</span></pre><p id="b784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的示例<code class="fe mj mk ml mm b">MyService</code>看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="7095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在清单文件中注册服务:</p><pre class="kj kk kl km gt ob mm oc od aw oe bi"><span id="571b" class="of mv it mm b gy og oh l oi oj">&lt;service android:name=".MyService"/&gt;</span></pre><p id="ddb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行您的应用程序，重新启动设备，并检查日志以查看服务是否启动。你甚至可以在服务中尝试烤面包。</p><h2 id="6e70" class="of mv it bd mw os ot dn na ou ov dp ne li ow ox ng lm oy oz ni lq pa pb nk pc bi translated">为网络变化动态注册广播接收器</h2><p id="cea9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们创建<code class="fe mj mk ml mm b">NetworkChangeReceiver</code>，用<code class="fe mj mk ml mm b">BroadcastReceiver</code>扩展它，并实现我们的逻辑来检查连通性变化。</p><p id="5ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出来的<code class="fe mj mk ml mm b">NetworkChangeReceiver</code> <strong class="lb iu"> </strong>会是这个样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="f283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oo">注意:如果在清单文件中静态注册，以牛轧糖为目标的应用程序将不会接收到</em> <code class="fe mj mk ml mm b"><em class="oo">CONNECTIVITY_CHANGE</em></code> <em class="oo">广播。为了获得网络改变广播，动态注册接收器。</em></p><p id="aa53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个receiver实例，并在<code class="fe mj mk ml mm b">Activity</code>级别动态注册和取消注册它。</p><p id="1131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个<code class="fe mj mk ml mm b">NetworkChangeReceiver</code>的实例:</p><pre class="kj kk kl km gt ob mm oc od aw oe bi"><span id="248b" class="of mv it mm b gy og oh l oi oj">val mNetworkReceiver = NetworkChangeReceiver()</span></pre><p id="d1dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态注册它:</p><pre class="kj kk kl km gt ob mm oc od aw oe bi"><span id="9a05" class="of mv it mm b gy og oh l oi oj"><strong class="mm iu">registerReceiver(<br/>    mNetworkReceiver,<br/>    IntentFilter(ConnectivityManager.<em class="oo">CONNECTIVITY_ACTION</em>)<br/>)</strong></span></pre><p id="a174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态取消注册:</p><pre class="kj kk kl km gt ob mm oc od aw oe bi"><span id="a801" class="of mv it mm b gy og oh l oi oj">private fun unregisterNetworkChanges() {<br/>    try {<br/><strong class="mm iu">        unregisterReceiver(mNetworkReceiver)<br/></strong>    } catch (e: IllegalArgumentException) {<br/>        e.printStackTrace()<br/>    }<br/>}</span></pre><p id="f6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的整个<code class="fe mj mk ml mm b">Activity</code>看起来会是这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="aab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oo">注意:当生命周期被破坏时，取消注册任何动态注册的接收者，以避免内存泄漏。在</em> <code class="fe mj mk ml mm b"><em class="oo">Activity</em></code> <em class="oo">的情况下，在</em> <code class="fe mj mk ml mm b"><em class="oo">OnStop</em></code> <em class="oo">或者</em> <code class="fe mj mk ml mm b"><em class="oo">OnDestroy</em></code> <em class="oo">中注销。</em></p><p id="a660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们现在所做的，运行应用程序并通过打开/关闭移动数据或wifi来检查logcat。</p><p id="479d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，输出是:</p><pre class="kj kk kl km gt ob mm oc od aw oe bi"><span id="358a" class="of mv it mm b gy og oh l oi oj">2021–07–04 19:27:22 NetworkChangeReceiver: Connected to Internet <br/>2021–07–04 19:27:28.NetworkChangeReceiver: No Connectivity<br/>2021–07–04 19:27:32.NetworkChangeReceiver: Connected to Internet</span></pre><p id="01b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在执行代码片段时发现任何困难，请查看<a class="ae ky" href="https://github.com/pavan5208/android_sample_broadcast_receiver" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e3ad" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">奖金</h1><p id="6ef1" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们可以在单个接收器上注册多个操作。广播接收器作为<code class="fe mj mk ml mm b">BroadcastReceiver</code>的子类实现，每个广播作为<code class="fe mj mk ml mm b">Intent</code>对象交付，因此我们可以使用intent来检查指定的动作并执行所需的任务。</p><p id="6246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态注册多个动作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div></figure><p id="dcb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">onReceive()</code>的接收器内，我们可以检查动作:</p><pre class="kj kk kl km gt ob mm oc od aw oe bi"><span id="8f05" class="of mv it mm b gy og oh l oi oj"><strong class="mm iu">if (intent?.<em class="oo">action </em>== "android.intent.action.SCREEN_OFF") {<br/></strong>   Log.v("ScreenReceiver", "in ScreenOnOff turning off")</span><span id="e5bc" class="of mv it mm b gy pf oh l oi oj"><strong class="mm iu">} else if (intent?.<em class="oo">action </em>== "android.intent.action.SCREEN_ON") {<br/></strong>    Log.v("ScreenReceiver", "in ScreenOnOff turning on")<br/>}</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="31ab" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">摘要</h1><p id="3258" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">广播接收器有助于处理与系统和自定义事件相关的情况。Android系统触发广播事件，应用程序可以订阅这些广播来执行自定义操作。在Android 7.0(API 24级)及更高版本开始，不要发送以下系统广播:<code class="fe mj mk ml mm b">ACTION_NEW_PICTURE </code>和<code class="fe mj mk ml mm b">ACTION_NEW_VIDEO</code>。</p><p id="3114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章中，我们将探索跨应用程序通信和<code class="fe mj mk ml mm b">LocalBroadcast</code>管理器。感谢您的阅读。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7b38" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">参考</h1><ul class=""><li id="26a1" class="lv lw it lb b lc nm lf nn li pg lm ph lq pi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.android.com/guide/components/broadcasts" rel="noopener ugc nofollow" target="_blank">广播</a></li><li id="ab04" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/pavan5208/android_sample_broadcast_receiver" rel="noopener ugc nofollow" target="_blank">安卓_样本_广播_接收器</a></li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5fb4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">继续读Android的东西</h1><ul class=""><li id="7c80" class="lv lw it lb b lc nm lf nn li pg lm ph lq pi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/@pavan.careers5208" rel="noopener">了解视图在Android中的呈现方式</a></li><li id="b987" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://proandroiddev.com/the-life-cycle-of-a-view-in-android-6a2c4665b95e" rel="noopener ugc nofollow" target="_blank">Android中一个视图的生命周期</a></li><li id="7fde" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/kotlin-advanced-programming-89aef9b2ecb8" rel="noopener">科特林系列</a></li><li id="f15e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-implement-in-app-purchases-in-your-android-app-7cc1f80148a4">如何在您的Android应用中实现应用内购买</a></li><li id="df0a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/@pavan.careers5208" rel="noopener">多得多</a></li></ul></div></div>    
</body>
</html>