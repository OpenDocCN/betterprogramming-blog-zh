<html>
<head>
<title>PHP: A Simple Example Using JSON Web Tokens With jQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP:一个在jQuery中使用JSON Web令牌的简单例子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-example-using-json-web-tokens-with-php-and-jquery-c648a80854c?source=collection_archive---------0-----------------------#2018-10-15">https://betterprogramming.pub/simple-example-using-json-web-tokens-with-php-and-jquery-c648a80854c?source=collection_archive---------0-----------------------#2018-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c971" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何实现用于身份验证的JSON Web令牌</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7d965c63e221d07f3970acddda683026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_cRKzrmV1aShbfAfyWYM7A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure><p id="92ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近，我想学习更多关于JSON Web令牌(jwt)及其工作原理的知识。我找到了一些服务器端的例子和一些客户端的例子，但是真的没有找到一个地方展示了整个周期。所以我创造了我自己的，并在这里分享。</p><p id="453e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">历史上，我使用PHP会话变量来管理安全性，这是一种有一些缺点的方法。首先，如果您要对多个web服务器进行负载平衡，它需要一些服务器端管理。您可能需要实现一个缓存解决方案，如Redis或Memcache，并定义一个缓存服务器来存储会话。第二，在客户端，PHP存储了一个会话cookie，这可能会暴露您的身份验证方案中使用的会话变量信息。</p><p id="87c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">jwt通过使用一个在服务器上创建的令牌来解决这个问题，该令牌包含经过哈希和编码的身份验证客户端的特定信息。然后将这个令牌返回给客户机，客户机可以在以后的API请求中使用这个令牌，而不需要进一步的身份验证。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="45ba" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">JWT崩溃</h1><p id="ecc4" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">jwt由三部分组成:头部、有效负载和签名。</p><p id="9917" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">报头</strong>包含关于使用哪种算法来散列令牌的信息。在我们的例子中，我们将使用HMAC-SHA256，一种使用秘密密钥的算法。</p><p id="81a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">有效载荷</strong>(也称为令牌的<em class="my">声明</em>)包含存储在令牌内部的数据。在我们的示例中，我们将在有效载荷中存储经过身份验证的用户的用户id。尽管我们将只在有效负载中存储一项，但是您可以存储任意多的声明。请记住，在这样做时，您应该考虑性能，并记住令牌不是用来作为传输数据请求的工具，而仅仅是用于数据请求身份验证的工具。</p><p id="bebb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的示例中，令牌中的用户id可以在服务器上用作索引键，以在后续请求中查询特定于已通过身份验证的用户的信息，而不要求用户再次标识自己的身份—例如，将用户导航到显示其订单列表的页面。</p><p id="2daa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一些标准声明可以包含在有效负载中，例如<code class="fe mz na nb nc b">exp</code>(到期日期和时间)和<code class="fe mz na nb nc b">nbf</code>(不在日期和时间之前)，它们标识了开始接受JWT进行处理的时间。我们的例子将包括在您的测试中包含<code class="fe mz na nb nc b">exp</code>和<code class="fe mz na nb nc b">nbf</code>的能力。您可以查看jwt的维基百科页面，了解其他标准字段。</p><p id="3879" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">签名</strong>是报头和有效载荷的散列表示。头和负载分别进行base64url编码，然后用一个<code class="fe mz na nb nc b">period header.payload</code>连接在一起成为一个新变量。然后，该变量被散列到一个新的变量中，在我们的示例中，该变量使用带有密钥的HS256算法，然后该变量也被base64url编码到签名中。签名被附加到头部和有效载荷变量，另一个句点<code class="fe mz na nb nc b">header.payload.signature</code> <strong class="la iu"> </strong>成为最终变量，这是我们的令牌，它被传递回客户端。</p><p id="9cdb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是它的工作原理。有很多文章也解释了这一点，但至少我们已经为我们的例子搭建了舞台。让我们开始吧。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="1c23" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">例子</h1><p id="6897" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我的例子使用了三个文件，它们可以从我的存储库免费下载。</p><h2 id="5b95" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">index.html</h2><p id="605a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这是一个简单的登录页面，提供了演示与服务器上的<code class="fe mz na nb nc b">app_client.php</code>文件交互的不同示例的按钮。</p><ul class=""><li id="ef77" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><strong class="la iu">良好登录</strong> —提交帖子，用户名为<em class="my"> john.doe </em>，密码为<em class="my"> foobar </em>。如果认证成功，则返回一个令牌。客户端可以决定如何存储令牌以备将来使用。在我们的例子中，我们将把它存储在浏览器<code class="fe mz na nb nc b">localStorage</code>中。</li><li id="d4be" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la iu">错误登录</strong>——提交一篇帖子，用户名为<em class="my"> john.doe </em>和无效密码<em class="my"> foobarfoobar </em>。这将导致<code class="fe mz na nb nc b">app_client</code>拒绝认证尝试，并显示错误和无令牌。收到错误后，客户端将清除任何现有令牌，并要求用户使用Good Login按钮获得一个新令牌，然后才能进行任何进一步的测试。</li><li id="4f46" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la iu">测试是否登录</strong> —将使用<code class="fe mz na nb nc b">localStorage</code>中存储的令牌发出GET。如果成功，<code class="fe mz na nb nc b">app_client</code>将返回我们存储在令牌有效负载中的用户id。</li><li id="7a6b" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la iu">注销并清除令牌</strong> —简单地清除<code class="fe mz na nb nc b">localStorage</code>中的任何现有令牌，并在任何进一步的测试工作之前，强制用户使用“良好登录”按钮获得一个新令牌。</li></ul><h2 id="2732" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">app _客户端. php</h2><p id="ee15" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这个服务器端PHP文件接受来自<code class="fe mz na nb nc b">index</code>的方法请求，并相应地处理它们。</p><p id="9848" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">POST请求接受用户名和密码字段并验证它们，如果它们无效，则返回一个错误。如果它们是有效的，那么就包含了<code class="fe mz na nb nc b"> jwt.php</code>文件来处理所有的令牌函数。然后创建一些在JWT创建中使用的变量。</p><p id="dd2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个是用户id，它被用作有效负载中的第一个声明:</p><pre class="kj kk kl km gt oe nc of og aw oh bi"><span id="56ad" class="ne mc it nc b gy oi oj l ok ol">$userId = 'USER123456';</span></pre><p id="9158" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这简单地证明了我们可以将我们想要的任何数据放入索赔中。在本例中，我们包含了一些有用的信息，稍后我们可以在服务器上使用这些信息来查询特定于该用户的数据，而不需要进一步的身份验证或选择。</p><p id="36f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来的两个变量用于控制令牌的生命周期:</p><pre class="kj kk kl km gt oe nc of og aw oh bi"><span id="e22f" class="ne mc it nc b gy oi oj l ok ol">$nbf = strtotime('2021-01-01 00:00:01');<br/><br/>$exp = strtotime('2021-01-01 00:00:01');</span></pre><p id="779e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">$nbf</code>和<code class="fe mz na nb nc b">$exp</code>变量对应于它们在有效载荷中的标准字段对应项。在上面的示例中，将<code class="fe mz na nb nc b"><strong class="la iu">nbf </strong></code>(不是之前)日期设置为2021年1月1日上午12:01生成的令牌不允许在该日期之前进行验证。您可以在您的开发环境中对此进行测试，方法是取消对该行的注释，并将其设置为适当的测试日期和时间。</p><p id="0473" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的示例中，将<code class="fe mz na nb nc b">exp</code>(到期)日期设置为2021年1月1日上午12:01时生成的令牌将仅在该日期和时间之前有效，届时它将到期并不再有效。您可以在您的开发环境中对此进行测试，方法是取消对该行的注释，并将其设置为适当的日期和时间。</p><p id="de0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果违反了这两个日期/时间变量中的任何一个，<code class="fe mz na nb nc b">app_client</code>将向<code class="fe mz na nb nc b"><strong class="la iu">index</strong></code>返回异常错误。</p><p id="fd9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一个变量是一个服务器密钥(在本例中是一个GUID ),我们将在签名中使用它作为散列算法。在我们的例子中，只有服务器知道密钥；因此，创建的令牌只能由服务器解码:</p><pre class="kj kk kl km gt oe nc of og aw oh bi"><span id="bc3d" class="ne mc it nc b gy oi oj l ok ol">$serverKey = '5f2b5cdbe5194f10b3241568fe4e2b24';</span></pre><p id="13e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个代码块将我们的声明变量打包到一个有效载荷数组中，然后将它和服务器密钥一起传递给<code class="fe mz na nb nc b">jwt.php</code>以编码成一个令牌:</p><pre class="kj kk kl km gt oe nc of og aw oh bi"><span id="a001" class="ne mc it nc b gy oi oj l ok ol">// create a token<br/>$payloadArray = array();<br/>$payloadArray['userId'] = $userId;<br/>if (isset($nbf)) {$payloadArray['nbf'] = $nbf;}<br/>if (isset($exp)) {$payloadArray['exp'] = $exp;}<br/>$token = JWT::encode($payloadArray, $serverKey);<br/><br/>// return to caller<br/>$returnArray = array('token' =&amp;gt; $token);<br/>$jsonEncodedReturnArray = json_encode($returnArray, JSON_PRETTY_PRINT);<br/>echo $jsonEncodedReturnArray;</span></pre><p id="aaf0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后将生成的令牌打包成一个JSON编码的返回数组，并返回给<code class="fe mz na nb nc b">index</code>。</p><h2 id="b204" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">jwt.php</h2><p id="a222" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这个类库基于诺伊曼·冯和阿南特·纳拉亚南写的原始Firebase/JWT源代码，在这里找到:<a class="ae nd" href="https://github.com/firebase/php-jwt" rel="noopener ugc nofollow" target="_blank">https://github.com/firebase/php-jwt</a>。</p><p id="3c57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了简化这个简单的例子，我去掉了对编写器依赖、名称空间引用和特殊错误异常的需求。所有其他功能和界面保持不变。一旦你掌握了这些概念，我鼓励你安装他们的JWT类库，因为这将为你提供库的持续更新。</p><p id="0595" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">jwt.php</code>类库提供了编码和解码JSON Web令牌的所有功能，包括处理有效负载标准字段。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ea34" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">试试吧！</h1><p id="aeb7" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">你可以从GitHub下载这三个文件。将它们都放在开发环境中的同一个文件夹中，并进行试验。该代码是为了清晰和易于调试而特意编写的。</p><p id="fc04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这有助于您理解如何在您的身份验证堆栈中使用JSON Web令牌！</p></div></div>    
</body>
</html>