<html>
<head>
<title>How to Make Your First Circle Using Metal Shaders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用金属着色器创建第一个圆</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-your-first-circle-using-metal-shaders-1e5049ec8505?source=collection_archive---------0-----------------------#2019-04-17">https://betterprogramming.pub/making-your-first-circle-using-metal-shaders-1e5049ec8505?source=collection_archive---------0-----------------------#2019-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1abe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">苹果Metal简介</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/499a56904eb9d7202b89a8f45b665ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPvHfiEz-NhtxY46HcTpuA.png"/></div></div></figure><p id="6a2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">金属着色器？渲染管道？顶点着色器？碎片着色器？如果你像我一样，这些单词和短语是没有意义或令人困惑的。本教程旨在帮助您轻松了解它是如何工作的，并允许您从那里开始构建。</p><h1 id="718d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">设置</h1><p id="a280" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们将从一个macOS应用程序开始。这样做的原因是为了让我们可以在模拟器中使用Mac的GPU。如果你想为一个iOS应用程序这样做，你必须在一个物理设备上运行它，因为iOS模拟器不支持Metal。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/6b1402e80329f38759b1c0a73061fa9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOmIiGRw7TZxL6GE1lmxhA.png"/></div></div></figure><p id="dc35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在将添加名为“MetalCircleView”的NSView子类(本质上是Mac版UIView)。这就是我们要做的重活。应用程序的根视图控制器(称为view controller)将只显示这个NSView。</p><div class="kg kh ki kj gt ab cb"><figure class="ml kk mm mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/4f81d16d6140303b1a720455a863b101.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*vrNZpxzaPDUW-IFLdvDq9w.png"/></div></figure><figure class="ml kk mr mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/0d5521cf8237e9dc3983c82648ec4c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*ldQDpLOjlk4ZayjD7x9Ucg.png"/></div></figure></div><p id="57eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们要做的第一件事是设置我们的init函数。我们将忽略这个类初始化时使用的draw函数，而是使用我们自己的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="91d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们将使用自动布局约束将视图从ViewController显示到窗口中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e070" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们运行它，我们应该得到一个空窗口！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/4c7a97db667de19602e6b1afbf1fccab.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*nOtZY1Lc6UYE1Zh59ByouQ.png"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="28be" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">设置我们的MetalKit视图</h1><ol class=""><li id="134b" class="nh ni iq kt b ku mf kx mg la nj le nk li nl lm nm nn no np bi translated">将MetalKit导入MetalCircleView文件。</li><li id="02eb" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">将我们的MTKView (Metal-Kit-View)声明为一个类实例变量。</li><li id="ad04" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">把它限制在我们的视野之内。</li><li id="3a3d" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">将我们自己设置为符合MTKViewDelegate的委托。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7e3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在为MetalView设置了可选字段，在文档中的<a class="ae nv" href="https://developer.apple.com/documentation/metalkit/mtkview" rel="noopener ugc nofollow" target="_blank">这里</a>讨论了这些字段。</p><h2 id="882b" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">告诉MTKView如何/何时“更新”</strong></h2><p id="b1cf" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们需要告诉我们的视图应该如何以及何时重绘它自己。我们有三个选择:</p><ol class=""><li id="ec4a" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated">我们让它根据它的内部计时器(连续的)重画自己</li><li id="fe88" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">我们使用一个setter来告诉它什么时候重画自己，这将基于它的内部定时器(由我们发起)发生</li><li id="1cd5" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">我们直接告诉它画忽略其内部计时器(由我们发起)</li></ol><p id="7ffc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用第二种方法，因为我们只绘制一次，并且将依赖于使用视图的currentRenderPassDescriptor(稍后将详细介绍)。根据文档，我们需要使用<code class="fe ol om on oo b">metalView.isPaused = true</code>暂停它，并使用<code class="fe ol om on oo b">metalView.enableSetNeedsDisplay = true</code>启用它的设置需求显示。这告诉它应该暂停，应该等待我们告诉它什么时候需要显示什么。</p><h2 id="7f49" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">将其连接到设备的GPU </strong></h2><p id="4eec" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们的MTKView需要连接到一个设备，它的类型是<a class="ae nv" href="https://developer.apple.com/documentation/metal/mtldevice" rel="noopener ugc nofollow" target="_blank"> MTLDevice </a>。你可以把这个设备想象成GPU本身。</p><blockquote class="op oq or"><p id="146a" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><code class="fe ol om on oo b"><em class="iq">MTLDevice</em></code>协议定义了与GPU的<strong class="kt ir">接口</strong></p></blockquote><p id="c19e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以在iOS或tvOS以及macOS中使用<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/1433401-mtlcreatesystemdefaultdevice" rel="noopener ugc nofollow" target="_blank">MTLCreateSystemDefaultDevice()</a></code>在运行时获取GPU。还有另一个选项可用于获取特定的GPU(如果您想将Mac的专用GPU或集成GPU作为目标，这很有用)，但这超出了本教程的范围。</p><p id="5a42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们希望这个金属设备在全球范围内可用，所以我们将其声明为一个类实例变量，在我们的<code class="fe ol om on oo b">setupMetal()</code>函数中初始化它，并将其设置为我们的metalView的设备。</p><pre class="kg kh ki kj gt ow oo ox oy aw oz bi"><span id="ec75" class="nw lo iq oo b gy pa pb l pc pd">metalDevice = MTLCreateSystemDefaultDevice()</span><span id="79bf" class="nw lo iq oo b gy pe pb l pc pd">metalView.device = metalDevice</span></pre><p id="342c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的最终产品现在看起来像这样，我们准备好开始设置我们的渲染功能！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="1130" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">设置我们的渲染功能</h1><h2 id="e6b8" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">创建命令队列</strong></h2><p id="2e07" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们需要做的第一件事是制作一个命令队列，一个<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlcommandqueue" rel="noopener ugc nofollow" target="_blank">MTLCommandQueue</a></code>。这个队列需要对我们的设备(我们的GPU接口)是唯一的；我们用它向GPU传达指令。这些指令由一个<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" rel="noopener ugc nofollow" target="_blank">MTLCommandBuffer</a></code>表示，是为命令队列执行而创建的。</p><p id="3c5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在初始化时知道了这些信息，我们希望创建命令队列，并将对它的引用作为实例变量。然后每次我们想渲染什么的时候，就需要创建一个命令缓冲对象来保存我们的指令。</p><p id="6241" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为命令队列对于我们的设备是唯一的，所以我们使用我们的设备来创建它！我们希望将它添加为<code class="fe ol om on oo b">setupMetal()</code>功能的一部分。</p><pre class="kg kh ki kj gt ow oo ox oy aw oz bi"><span id="0f19" class="nw lo iq oo b gy pa pb l pc pd">metalCommandQueue = metalDevice.makeCommandQueue()!</span></pre><p id="4af3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(在这一点上，你应该想知道为什么我要强制解包。确保你正确处理你的选择！)在设置了命令队列之后。我们的代码应该是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="9dfd" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">发出我们的第一个GPU命令！</h1><p id="e90c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在我们已经有了发出第一个GPU命令的基本设置和知识，我们将为MTKView渲染一个RGBA颜色值。</p><p id="beaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在draw中要做的第一件事是创建我们的commandBuffer。这将包含我们执行命令所需的指令！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="f666" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">创建管道</strong></h2><p id="a397" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们的指挥缓冲区需要一条管道来输送。管道需要内部信息和接口信息。我们使用一个<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlrenderpassdescriptor" rel="noopener ugc nofollow" target="_blank">MTLRenderPassDescriptor</a></code>来配置接口信息。对于本教程，我们不需要创建自己的——我们可以使用<code class="fe ol om on oo b">.currentRenderPassDescriptor</code>从MTKView获取默认的。</p><p id="6257" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在访问我们的渲染过程描述符的colorAttachements数组属性，我们可以在它的(第0个条目)设置一个值。clearColor，描述分配给视图当前可绘制性的纹理的颜色数据。更简单地说，这可以被认为是我们的金属视图的“背景色”。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7c6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们需要一个<code class="fe ol om on oo b"><a class="ae nv" href="https://gist.github.com/barbulescualex/666ae6959f2f00ed15e261c916ddbc49" rel="noopener ugc nofollow" target="_blank">MTLRenderCommandEncoder</a></code>来配置管道的内部。它是使用renderDescriptor从我们的commandBuffer编译的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5ce3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从这里，我们可以开始输入要在GPU上绘制的顶点数据和绘制命令，或者更好地认为是GPU运行的“编码”命令。目前，我们还没有准备好编码任何真正的<em class="os">绘图命令，所以我们将把它留到以后(我在标题:p一节中骗了你)。我们希望在MTKView中看到美丽的蓝色背景！</em></p><p id="28e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要做四件事来结束编码并启动commandBuffer，以便在GPU上执行并显示给我们的视图！</p><ol class=""><li id="8bcc" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated">结束编码。</li></ol><p id="48f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">renderEncoder.endEncoding()</code></p><p id="3b4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.告诉GPU将渲染结果发送到哪里。</p><p id="02c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">commandBuffer.present(view.currentDrawable!)</code></p><p id="7883" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用MTKView的currentDrawable，一个表示当前帧的Drawable。<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtldrawable" rel="noopener ugc nofollow" target="_blank">MTLDrawable</a></code>是一个“<em class="os">可显示的资源，可以被渲染或写入。</em></p><p id="fda3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.将指令添加到我们的metalCommandQueue中</p><p id="2e17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">commandBuffer.commit()</code></p><p id="e010" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.告诉我们的金属视图draw触发draw方法，我们将把它添加到我们的<code class="fe ol om on oo b">setupMetal()</code>函数的末尾，但是你可以在任何你喜欢的地方调用它(当然，在你设置了金属组件之后)。</p><p id="18ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">metalView.needsDisplay = true</code></p><p id="22da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的绘图函数现在应该是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8487" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你点击运行，你应该会看到一个蓝屏！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/69c59613e6ecc9f9168b2adbf41e1182.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*C5kwD-GQfpFARe-C_JTrlw.png"/></div></figure><h2 id="ada5" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">注:</strong></h2><p id="9b71" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">早些时候，当我们选择如何更新我们的MTKView时，我提到过我们使用视图的内部定时器来手动设置它，因为我们依赖于currentRenderPassDescriptor。如果我们手动发出<code class="fe ol om on oo b">draw()</code>命令，忽略它的计时器，我们将不得不调用它两次，因为视图第一次不会有currentRenderDescriptor。</p><p id="05db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在需要将命令编码到renderEncoder中，让它知道从传入的顶点绘制什么。我们还需要一种方法来表示这些信息，这样我们就可以在我们的视图中创建它，并且金属着色器也可以正确地使用它。但是首先，我们需要从高层次上了解GPU实际上是如何绘制东西的。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="9f43" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">流水线阶段</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/b425bd847fee2c023229a1b4d62c8d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWOeaj3iBXwcf7U6W1PGPg.png"/></div></div><p class="ph pi gj gh gi pj pk bd b be z dk translated">管道阶段部分的全部功劳归于唐纳德·平克尼(<a class="ae nv" href="https://donaldpinckney.com/metal/2018/07/05/metal-intro-1.html" rel="noopener ugc nofollow" target="_blank">来源</a>)。</p></figure><blockquote class="op oq or"><p id="336c" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">编码绘图命令/顶点数据:</em></strong>GPU接收到的，必须在流水线中处理的数据。</p><p id="3b52" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">顶点着色器:</em> </strong>将3D顶点位置转换为2D屏幕坐标。它还通过管道向下传递顶点数据。</p><p id="a9e6" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">细分:</em> </strong>将三角形细分成更多的三角形，以提供更高质量的结果。</p><p id="3aa8" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">栅格化:</em> </strong>将2D几何数据离散成2D离散像素。这也将获取附加到每个顶点的数据，并将其插值到整个形状的每个栅格化像素上。</p><p id="5622" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">片段着色器:</em> </strong>给定来自光栅化器的插值像素数据，片段着色器确定每个像素的最终颜色。</p></blockquote></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="7a03" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">着色器</h1><p id="1bc4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Metal支持三种类型的着色器函数:顶点、片段和计算(内核)。这些描述了渲染管道的一部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/2c9252e7612a82325019fa4f87e2b7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mnQQN0iYy0OEmjNb3PcOw.png"/></div></div><p class="ph pi gj gh gi pj pk bd b be z dk translated">(<a class="ae nv" href="https://medium.com/@nithstong/2d-colored-triangle-in-elm-with-webgl-2a9b2734ce77" rel="noopener">来源</a>)</p></figure><p id="62af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">顶点着色器:</strong>用于操纵多边形顶点的函数。它运行在我们传入的每个顶点上。在这里，我们可以操纵顶点的位置和其他属性，如颜色。</p><p id="100d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">《出埃及记》在顶点着色器中，我可以操纵每个顶点的位置，所以如果我想的话，我可以传入点来制作一个圆，然后操纵它们成为一个正方形。我也可以为每个顶点传入一种颜色，然后在函数内部改变它。</p><p id="db51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">碎片着色器:</strong>一个用于操纵顶点间像素外观的函数。它在一组顶点之间的每个像素上运行。这里我们可以返回每个像素的颜色信息。</p><p id="789f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">统一标量:</strong>此时，您可能会想:传入标量呢？让我们说一个常量Float类型来表示我们对象的位置乘数；通过改变这个常数，我们可以使我们的多边形变大或变小。嗯，这被称为<strong class="kt ir">统一</strong>，因为它是一个统一应用于所有点的值，也就是说它不会改变。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="4e90" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">基元</h1><p id="2878" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在最底层，GPU被设计用来渲染三角形。三角形是最容易和最通用的对象，这也是今天的硬件专注于做的事情(StackOverflow解释<a class="ae nv" href="https://stackoverflow.com/questions/12495511/are-triangles-a-gpu-restriction-or-are-there-other-rendering-pathways" rel="noopener ugc nofollow" target="_blank">这里</a>)。这并不意味着我们只能告诉GPU画三角形。例如，如果你正在使用一个支持四边形(矩形)的框架，你可以给它传递四个点，告诉它画一个矩形。这对程序员来说更容易，但实际上，GPU仍然将该指令分解为两个三角形指令。</p><p id="981c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">把它想象成用高级语言写一行复杂的代码。当代码被编译成汇编时,“一条”指令被分解成一系列CPU可以实际执行的多条指令。</p><p id="e803" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlprimitivetype" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">MTLPrimitiveType</strong></a><strong class="kt ir">—</strong>绘图命令的几何图元类型。</p><ol class=""><li id="6375" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated"><strong class="kt ir">点</strong> —在每个顶点光栅化一个点</li><li id="b149" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated"><strong class="kt ir">线</strong> —栅格化每对独立顶点之间的线(形成不相连的线)</li><li id="0a47" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated"><strong class="kt ir"> lineStrip </strong> —栅格化每对顶点之间的一条线(形成一系列相连的线)</li><li id="d9dc" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated"><strong class="kt ir">三角形</strong>-为每个独立的三个一组的点光栅化一个三角形</li><li id="fa06" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated"><strong class="kt ir"> triangleStrip </strong> —为每三个相邻的三元组点栅格化一个三角形</li></ol><p id="182f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总结一下，我们需要三个高级步骤来形成一个圆。</p><ol class=""><li id="94b8" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated">在CPU上创建顶点。</li><li id="e6b0" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">将顶点发送到顶点着色器。</li><li id="6936" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">在片段着色器中应用颜色。</li></ol></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="e3b2" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">建立我们的金属档案</h1><p id="0670" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">有多种方法可以做到这一点。我们需要的是指定一个库供我们的渲染编码器使用。这个金属库是由。金属锉。在。金属文件，我们可以指定着色器功能。有趣的事实:您也可以在运行时从字符串构建库。</p><p id="951f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要做的第一件事是在项目文件夹中创建我们的金属文件。这就像添加一个新文件，除了我们选择“金属”而不是“可可级”或“雨燕”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/25560aeda1b4d8bbfd09e998a7fa2fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42IABMLHQWfxCe9nP_xBjw.png"/></div></div></figure><p id="2afa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将它命名为<em class="os"> CircleShader.metal. </em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7253" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开它，我们看到我们正在导入metal标准库并使用Metal名称空间。这里使用的语言叫做<a class="ae nv" href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf" rel="noopener ugc nofollow" target="_blank">金属规格语言</a>。如果你曾经使用过C++，你会注意到它看起来已经很相似了；这是因为MSL(金属着色语言)是基于C++的。</p><h2 id="20ae" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">创建一个数据结构，将我们的顶点传递给GPU </strong></h2><p id="14f0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们需要在顶点的swift文件和金属文件之间有一个共同的语言。我们需要能够在swift (CPU端)创建我们的顶点，然后在Metal (GPU端)读取它们。数据的容器类型需要一致。</p><p id="9f09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们看看我们需要什么来表示一个顶点:我们需要一个保存两个坐标的位置变量，我们需要一个保存该点颜色信息的颜色变量。</p><p id="885c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想为一个顶点携带两组信息，那么我们就用struct。</p><pre class="kg kh ki kj gt ow oo ox oy aw oz bi"><span id="f870" class="nw lo iq oo b gy pa pb l pc pd">struct VertexIn {<br/>    position : vector_float2 //&lt;x,y&gt;<br/>    color : vector_float4 //&lt;R,G,B,A&gt;<br/>}</span><span id="6754" class="nw lo iq oo b gy pe pb l pc pd">var verticesForCircle = [VertexIn]() //array of VertexIn</span></pre><p id="203a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们只想携带一组信息，那么我们不需要结构。</p><pre class="kg kh ki kj gt ow oo ox oy aw oz bi"><span id="bca5" class="nw lo iq oo b gy pa pb l pc pd">var verticesForCircle = [vector_float2]() //array of &lt;x,y&gt;</span></pre><p id="0cac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们希望我们的圆是纯色的。用顶点数据传递颜色是没有意义的，因为我们可以在着色器函数中硬编码它。出于这个原因，我们将只使用一个向量浮点，而不是一个结构。</p><p id="2690" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能还注意到上面的例子包含了vector_floats。在Accelerate框架下，苹果使用SIMD向量库。它是为c++构建的，也可以在Swift中使用，因此我们将使用它来表示我们的价值观。</p><p id="3d7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将simd导入我们的。金属和。swift文件:</p><p id="88ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nv" href="http://ermig1979.github.io/Simd/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">【SIMD c++</strong></a><strong class="kt ir">【金属】</strong></p><p id="9c70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">#include &lt;simd/simd.h&gt;</code></p><p id="a24e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">声明向量:</p><p id="240c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">vector_float2 varName;</code></p><p id="e568" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nv" href="https://developer.apple.com/documentation/accelerate/simd" rel="noopener ugc nofollow" target="_blank">T15】SIMD SwiftT17】</a></p><p id="6bf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">import simd</code></p><p id="3c5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">声明向量:</p><p id="3624" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">let varName : simd_float2</code></p><p id="fda0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过使用SIMD库，我们可以确保我们的数据在CPU和GPU的内存中保持一致。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="5ecb" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">为我们的圆创建顶点</h1><p id="b5ba" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们现在可以为我们的圆创建顶点了！我们的第一步是考虑GPU如何绘制图元。我们渲染的三角形越多，圆就越平滑。</p><p id="cbba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有两个选择。</p><p id="e9c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi">1.</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/3d97c707af58e27fcfc60f9dc1bb1d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*qvYaj_dlcmSJGjoeZHCBSw.png"/></div></figure><p id="5720" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">计算圆周上所有的点，并在每两点之间插入原点。当我们只有几个三角形时，你可以很容易地看到，我们真的只是试图制造足够的三角形来隐藏平坦的外部边缘。</p><p id="66b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi">2.</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/dd28eefe6eca62564adc356631f291a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*DInAR_PaL-TSF6ayP7YJ7g.png"/></div></figure><p id="3210" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要使用原点，而是让三角形的所有顶点都接触周长。</p><p id="b238" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里没有正确或错误的答案，所以我们将选择更简单的选项(选项1)。</p><p id="3851" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将创建一个名为<code class="fe ol om on oo b">circleVertices</code>的实例变量和一个名为<code class="fe ol om on oo b">createVertexPoints()</code>的函数。在<code class="fe ol om on oo b">createVertexPoints() </code>函数中，我们需要一个助手函数来计算弧度的度数，因为我们将使用Swift三角函数。</p><p id="62d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的MetalCircleView类现在应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2957" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于圆中有360度，我们可以用(n*360)/2个原点生成n*360个周长点(其中n代表非零正整数)。本质上，n越大，我们渲染的三角形就越多，圆形就越平滑。幸运的是，n=2对我们来说已经足够好了。</p><p id="d79f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我会跳过三角函数课，但这是我们如何得到720个周长点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c02f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实际上，是721个周界点。这是因为我们想做一个完整的圆(字面意思)。我们从0*开始，我们希望确保在360*结束。如果我们以0… &lt;720, we would have ended on 395.5*. This makes a noticeable difference as there would be a sliver of the circle unfilled if we left it this way. Now in between every two perimeter points, we need to form a triangle with the origin.</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a0c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">It’s worth noting that the points we’re creating are normalized to the screen. In Apple’s <a class="ae nv" href="https://developer.apple.com/documentation/metal/hello_triangle" rel="noopener ugc nofollow" target="_blank"> Hello Triangle </a>为例，它被定义为:</p><blockquote class="op oq or"><p id="298e" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">vertex函数将任意顶点坐标转换为标准化设备坐标，也称为<em class="iq">剪辑空间坐标</em>。剪辑空间是一个2D坐标系，它将视口区域沿x轴和y轴映射到[-1.0，1.0]范围。</p></blockquote><p id="f167" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着我们可以渲染点的区域在x轴和y轴上都从-1.0到1.0，并且这个坐标系映射到一个视口区域。在我们的例子中，我们没有接触过视口区域，所以视口区域就是我们的整个MTKView。</p><p id="0d8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在准备将这些数据发送到GPU并创建着色器函数:)</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="1cb9" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">设置着色器函数</h1><h2 id="f18f" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">指针和内存</strong></h2><p id="62f7" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在<a class="ae nv" href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf" rel="noopener ugc nofollow" target="_blank">金属着色语言规范第4章</a></p><blockquote class="op oq or"><p id="7a89" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">在程序中声明的作为指针的金属图形和内核函数的参数必须用金属设备、线程组、线程组_图像块或常量地址空间属性来声明。</p></blockquote><p id="b469" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些指定了数组应该存储在GPU中的哪个地址空间。<code class="fe ol om on oo b">device</code>属性指定一个读写地址空间，<code class="fe ol om on oo b">constant</code>指定一个只读地址空间。</p><h2 id="68c1" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">程序范围函数常数</strong></h2><blockquote class="op oq or"><p id="c992" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">用以下属性声明(或初始化)的程序范围变量是<em class="iq">函数常量</em>:[[function _ constant(index)]]</p></blockquote><p id="ee2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些属性通常用在参数上，让metal知道在哪里传入特定的数据。</p><p id="a29c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先我会给你看模板，然后解释这是怎么回事。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1aef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">顶点功能</strong></p><p id="16e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">const constant vector_float2 *vertexArray [[buffer(0)]]</code></p><p id="9a4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个参数是我们接受将要传入的顶点数组。分解语法，我们看到我们有一个指向向量浮点数组的指针。您很快就会看到，顶点数据需要作为“缓冲数据”传入。<code class="fe ol om on oo b">[[buffer(0)]]</code>指定我们希望第一个(也是唯一的)缓冲区数据被传递到这个参数中。<code class="fe ol om on oo b">constant</code>属性告诉metal将顶点数据存储在只读内存空间中。</p><p id="ea3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">unsigned int vid [[vertex_id]]</code></p><p id="4e57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个参数<code class="fe ol om on oo b">vid</code>代表“向量id”。这唯一地标识了我们当前所处的顶点；它将被用作我们的顶点数组的索引。正如在我们的vertexArray参数中我们需要让metal知道它需要传入一样，我们让metal知道使用<code class="fe ol om on oo b">[[vertex_id]]</code>将我们的顶点id传入<code class="fe ol om on oo b">vid</code>参数。</p><p id="e154" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">VertexOut</code></p><p id="0cf6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出的类型是VertexOut，它包含一个位置向量和一个颜色向量。输出首先经过镶嵌/光栅化，因此<code class="fe ol om on oo b">[[position]]</code>属性告诉metal使用该结构的<code class="fe ol om on oo b">position</code>字段作为标准化屏幕位置的。您现在可能已经注意到，这是一个4D字段，而不是我们为某个职位传递的2D字段。第三/第四坐标代表深度和同质空间——这是我们不必担心的。然后，这个VertexOut结构将被输入到我们的片段函数的输入中，我们将从该函数中使用<code class="fe ol om on oo b">color</code>字段。</p><p id="28d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">片段功能</strong></p><p id="924a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">VertexOut interpolated [[stage_in]]</code></p><p id="e37e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们只有一个名为<code class="fe ol om on oo b">interpolated</code>的<code class="fe ol om on oo b">VertexOut</code>类型的输入参数。<code class="fe ol om on oo b">[[stage_in]]</code>属性告诉金属，变量应输入光栅化器的插值结果。</p><p id="b924" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出只是一个从VertexOut结构中获取的<r g="" b="" a="">颜色，该结构由vertexShader函数传递。</r></p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="6a18" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">填充着色器函数</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><ol class=""><li id="eca2" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated">我们使用顶点id从缓冲区中获取当前顶点。</li><li id="b329" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">我们初始化VertexOut类型的输出。</li><li id="1349" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">我们将输出的4D位置信息设置为来自当前端点的2D位置。</li><li id="02ac" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">我们返回要光栅化的输出，然后传递给我们的片段着色器。</li><li id="c5c1" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">在我们的片段着色器中，我们只返回颜色。</li></ol><h2 id="6497" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">一些有趣的笔记:</strong></h2><ul class=""><li id="6273" class="nh ni iq kt b ku mf kx mg la nj le nk li nl lm po nn no np bi translated">如果您没有在结构中包含[[position]]属性，那么您将得到一个编译错误，告诉您VertexOut是一个无效的返回类型。</li><li id="0b11" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm po nn no np bi translated">如果你只是传递一个没有结构的vector_float4，metal会自动推断它是坐标。</li></ul><h2 id="5fbf" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">此处的优化:</strong></h2><p id="147a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您可能已经注意到，我们可以在fragmentShader本身中硬编码颜色的返回值，而不是传递颜色。这对我们来说是一个很好的优化(圆圈使用纯色)，但对于其他任何事情来说都不是一个可扩展的解决方案。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="e0fd" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">设置我们的渲染管道</h1><p id="24ad" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这是我们的最后一步！万岁。现在我们有了制作圆形的顶点和渲染圆形的金属着色器，我们所要做的就是使用金属着色器作为管道的一部分，并将它作为缓冲数据输入顶点！</p><p id="5e37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们上次在<code class="fe ol om on oo b">MetalCircelView</code>类的draw函数中停止的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f52a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们创建了一个命令缓冲区来添加到我们的commandQueue中，这是为我们的GPU接口创建的。我们设置了管道的输入和输出。现在剩下的就是将<code class="fe ol om on oo b">renderEncoder</code>(或“我们的管道内部”)与我们的着色器函数联系起来，并将其作为缓冲数据传入我们的顶点！</p><h2 id="1f7f" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">将我们的金属函数绑定到我们的renderEncoder </strong></h2><p id="9d1d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">第一步是创建一个<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlrenderpipelinestate" rel="noopener ugc nofollow" target="_blank">MTLRenderPipelineState</a></code>。</p><blockquote class="op oq or"><p id="287d" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">要使用<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" rel="noopener ugc nofollow" target="_blank"><em class="iq">MTLRenderCommandEncoder</em></a></code>为渲染过程编码命令，在发出任何绘制调用之前，指定一个定义<strong class="kt ir">图形状态的<code class="fe ol om on oo b"><em class="iq">MTLRenderPipelineState</em></code>对象，包括顶点和片段着色器函数</strong>。</p></blockquote><p id="5483" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了创建管道状态，我们需要一个<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlrenderpipelinedescriptor" rel="noopener ugc nofollow" target="_blank">MTLRenderPipelineDescripto</a>r</code>。</p><blockquote class="op oq or"><p id="b66a" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">传递给设备以获取呈现管道状态对象的选项参数。</p></blockquote><p id="0669" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们将为MTLRenderPipelineState创建一个新的类实例变量，并创建一个函数来创建MTLRenderPipelineState，我们将在绘制视图之前调用函数<code class="fe ol om on oo b">setupMetal()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="232e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要创建管道状态，我们需要:</p><ol class=""><li id="22bc" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated">创建管道描述符。</li><li id="fb5e" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">使用GPU界面查找我们的金属文件。</li><li id="e516" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">告诉管道描述符我们的顶点和片段函数叫什么。</li><li id="dd09" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">告诉管道描述符以什么格式存储像素数据。</li><li id="133f" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">从管道描述符创建管道状态。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="54f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像往常一样，确保正确处理投掷和选项(照我说的做，不要照我做的做)。</p><p id="d187" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，要将它连接到我们的渲染编码器，我们所要做的就是使用它的<code class="fe ol om on oo b">setRenderPipelineState</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ba5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在准备从顶点开始绘制图元了！</p><h2 id="c233" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak">将顶点转换成缓冲数据</strong></h2><p id="df50" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">首先，我们需要创建类型为<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlbuffer" rel="noopener ugc nofollow" target="_blank">MTLBuffer</a></code>的缓冲数据。这方面的文档值得一读，以了解发生了什么。</p><blockquote class="op oq or"><p id="fd1c" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">一个<code class="fe ol om on oo b"><em class="iq">MTLBuffer</em></code>对象只能和创建它的<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtldevice" rel="noopener ugc nofollow" target="_blank"><em class="iq">MTLDevice</em></a></code>一起使用。不要自己实现这个协议；相反，使用下面的<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtldevice" rel="noopener ugc nofollow" target="_blank"><em class="iq">MTLDevice</em></a></code>方法来创建<code class="fe ol om on oo b"><em class="iq">MTLBuffer</em></code>对象:</p></blockquote><ol class=""><li id="bd02" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated"><code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtldevice/1433375-makebuffer" rel="noopener ugc nofollow" target="_blank">makeBuffer(length:options:)</a></code></li></ol><blockquote class="op oq or"><p id="19f0" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">用新的存储分配创建一个<code class="fe ol om on oo b"><em class="iq">MTLBuffer</em></code>对象。</p></blockquote><p id="69ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtldevice/1433429-makebuffer" rel="noopener ugc nofollow" target="_blank">makeBuffer(bytes:length:options:)</a></code></p><blockquote class="op oq or"><p id="7d5e" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">通过将数据从现有的存储分配复制到新的分配来创建一个<code class="fe ol om on oo b"><em class="iq">MTLBuffer</em></code>对象。</p></blockquote><p id="7c86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtldevice/1433382-makebuffer" rel="noopener ugc nofollow" target="_blank">makeBuffer(bytesNoCopy:length:options:deallocator:)</a></code></p><blockquote class="op oq or"><p id="a2c8" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">创建一个<code class="fe ol om on oo b"><em class="iq">MTLBuffer</em></code>对象，该对象重用现有的存储分配，并且不分配任何新的存储。</p></blockquote><p id="9270" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们想选择第二种方法，因为我们已经在circleVertexes数组中存储了数据</p><p id="4c01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在顶部将顶点缓冲区声明为实例变量:</p><p id="b9a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">private var vertexBuffer : MTLBuffer!</code></p><p id="2b3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在我们的<code class="fe ol om on oo b">setupMetal()</code>函数中填充它:</p><pre class="kg kh ki kj gt ow oo ox oy aw oz bi"><span id="1cca" class="nw lo iq oo b gy pa pb l pc pd">vertexBuffer = metalDevice.makeBuffer(bytes: circleVertices, length: circleVertices.count * MemoryLayout&lt;simd_float2&gt;.stride, options: [])!</span></pre><p id="259d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">makeBuffer</code>函数从我们的circleVertices中取出“length”数量的字节，并将其存储到GPU/CPU可访问的内存中。对于长度，我们从数据类型(在我们的例子中是simd_float2)的<a class="ae nv" href="https://developer.apple.com/documentation/swift/memorylayout" rel="noopener ugc nofollow" target="_blank"> MemoryLayout </a>中获取步幅(当存储在连续内存或<code class="fe ol om on oo b">Array&lt;T&gt;</code>中时，从一个<code class="fe ol om on oo b">T</code>实例开始到下一个实例开始的字节数),并将其乘以数组中该类型的条目数。</p><p id="6ab9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">综合起来，我们只剩下这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="1cf4" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">绘制我们的第一个图元(圆！)</h1><p id="6b4d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们快到了！我们已经做好了在渲染编码器上发布draw命令的一切准备。这就是<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder" rel="noopener ugc nofollow" target="_blank">MTLRenderCommandEncoder</a></code>的文档真正变得重要的地方。有两个值得注意的部分:</p><h2 id="c679" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak"> 1。为顶点函数指定资源(缓冲数据)</strong></h2><blockquote class="op oq or"><p id="b8ed" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder/1515829-setvertexbuffer" rel="noopener ugc nofollow" target="_blank"><em class="iq">func setVertexBuffer(MTLBuffer?, offset: Int, index: Int)</em></a></code></p><p id="61a0" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">为顶点函数设置缓冲区。</p></blockquote><p id="ae63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还记得我们如何在顶点着色器函数中使用[[buffer(some index)]]属性作为vertexArray参数吗？在我们的draw函数中，我们可以将vertexBuffer设置为一个特定的索引，这样metal就知道将它传递给哪个输入参数。</p><p id="f7d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0)</code></p><p id="f1c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里将索引设置为0对应于[[buffer(0)]]属性。偏移量指定了我们要分配给该索引的缓冲区数据的起始点。因为我们关心所有的顶点，所以我们将偏移量设置为0。</p><h2 id="e6a8" class="nw lo iq bd lp nx ny dn lt nz oa dp lx la ob oc lz le od oe mb li of og md oh bi translated"><strong class="ak"> 2。绘制几何图元</strong></h2><blockquote class="op oq or"><p id="7cc6" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder/1516326-drawprimitives" rel="noopener ugc nofollow" target="_blank"><em class="iq">func drawPrimitives(type: MTLPrimitiveType, vertexStart: Int, vertexCount: Int)</em></a></code></p><p id="2fbd" class="kr ks os kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">对使用连续数组元素中的顶点数据呈现图元的一个实例的命令进行编码。</p></blockquote><p id="fcd0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是触发我们的vertexShader函数运行的原因。我们所做的一切都是为了这一刻。我们告诉我们的渲染编码器绘制一个特定的图元(还记得我们讨论MTLPrimitiveTypes的时候)，从哪个顶点开始，以及顶点计数。</p><p id="d514" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能想知道为什么我们需要指定vertexStart point和vertexCount point。当您想要在同一个渲染过程中创建不同的基本体类型时，这是必需的。如果您的前1000个顶点是三角形，接下来的1000个是直线，您将需要指定下一个图元类型从哪个顶点开始。</p><p id="c9b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on oo b">renderEncoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 1081)</code></p><p id="b57d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有1081个顶点，我们想从第一个点开始渲染三角形。</p><p id="e327" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们的绘图函数应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d13f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们所需要做的就是按下run，然后我们应该会看到我们的第一个圆圈！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/fdefc1ec8c82ed451da91113171c2c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*foq2qH4AlomXuLrBuaQhww.png"/></div></figure><p id="b787" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">等一下…现在，这看起来不像一个完整的圆。我们可以从原点清楚地看到三角形之间的区别。更不用说渲染出来的这些诡异的神器了。看起来我们最初对三角形的想法没有意义。</p><p id="39e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们回头看看三角形图元选项，我们有两个选项:</p><ol class=""><li id="062e" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated"><strong class="kt ir">三角形</strong> —为每个独立的三个一组的点栅格化一个三角形</li><li id="3cc0" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated"><strong class="kt ir"> triangleStrip </strong> —为每三个相邻的三连点光栅化一个三角形</li></ol><p id="41c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们把图元类型从三角形改成<strong class="kt ir"> triangleStrip </strong>会怎么样？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/88e50e12faff9dd9f27b923e23b32ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*RGaIFol61kCiY2Qre1KIbA.png"/></div></figure><p id="46b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在有一个完整的圆圈，万岁！我们已经用我们创建的点绘制了更多的三角形，基本上缩小了差距。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/0797899da82555e57048cdd47b3c437e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*dLkqRO72b2zN68jRsK6c_g.png"/></div><p class="ph pi gj gh gi pj pk bd b be z dk translated">如何使用另一种颜色用更多三角形填充间隙的直观表示</p></figure><p id="123e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了将所有这些联系在一起，我们的MetalCircleView类应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c6d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的Github上的完整源代码<a class="ae nv" href="https://github.com/barbulescualex/MetalCircle" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="2ba4" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">剩下的问题:视窗</h1><p id="72db" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">此时，您应该想知道为什么这个圆会随着窗口缩放和拉伸。请记住，我们已经将我们的金属视图限制在我们的窗口中，所以改变它会延伸我们的“标准化”2D坐标空间。如果你还记得在“创建我们的顶点”部分，我们看到标准化的坐标空间被映射到我们的<code class="fe ol om on oo b"><a class="ae nv" href="https://developer.apple.com/documentation/metal/mtlviewport" rel="noopener ugc nofollow" target="_blank">MTLViewPort</a></code>。</p><p id="d6d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有两种方法可以解决这个问题:</p><ol class=""><li id="24b3" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated">约束MTKView，使其width == height(比率或硬编码值)。</li><li id="9941" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">在draw函数中的renderEncoder上设置视口。</li></ol><p id="ef60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就引出了本教程的最后一部分:)</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="1164" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">从这里去哪里</h1><p id="0f15" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们刚刚创造了第一个金属圈！我们学习了如何使用金属的基础知识(设置我们的渲染管道)，使用着色语言(金属着色语言)，学习了GPU如何绘制，并绘制了我们的第一个图元来制作一个圆！</p><p id="d930" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我建议的下一步是:</p><ol class=""><li id="278d" class="nh ni iq kt b ku kv kx ky la oi le oj li ok lm nm nn no np bi translated">在metal函数中向vertexArray传递更多的字段。回想一下我们选择只用一个字段来表示顶点的时候。尝试将顶点作为带有颜色字段的结构传入。</li><li id="f800" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">将缓冲区数据传递给片段着色器函数。</li><li id="f093" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">在一个渲染过程中绘制更多的形状。</li><li id="246b" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">通过使视图重绘自身，在MTKView的drawableSizeWillChange委托方法上设置视区。</li></ol></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="3c9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你喜欢这个不那么简单的金属介绍:)。完整的项目可以在我的GitHub页面<a class="ae nv" href="https://github.com/barbulescualex/MetalCircle" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="3978" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，请查看本系列的下一篇教程！</p><div class="pq pr gp gr ps pt"><a href="https://medium.com/@barbulescualex/audio-visualization-in-swift-using-metal-accelerate-part-1-390965c095d7" rel="noopener follow" target="_blank"><div class="pu ab fo"><div class="pv ab pw cl cj px"><h2 class="bd ir gy z fp py fr fs pz fu fw ip bi translated">使用Metal &amp; Accelerate在Swift中实现音频可视化(第1部分)</h2><div class="qa l"><h3 class="bd b gy z fp py fr fs pz fu fw dk translated">我们都见过各种形式的音频可视化，但是我们如何在Cocoa应用程序中实现呢？</h3></div><div class="qb l"><p class="bd b dl z fp py fr fs pz fu fw dk translated">medium.com</p></div></div><div class="qc l"><div class="qd l qe qf qg qc qh kp pt"/></div></div></a></div></div></div>    
</body>
</html>