<html>
<head>
<title>5 Common Golang Coding Mistakes To Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要避免的5个常见Golang编码错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/top-5-common-golang-coding-mistakes-the-ugly-sides-of-a-great-programming-language-e0b64915707?source=collection_archive---------5-----------------------#2021-07-22">https://betterprogramming.pub/top-5-common-golang-coding-mistakes-the-ugly-sides-of-a-great-programming-language-e0b64915707?source=collection_archive---------5-----------------------#2021-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d0a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">伟大的编程语言丑陋的一面</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/64087e1f2afd9327127f293bc307400d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GUWLnncaSk2o19Vq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@rojekilian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sarah Kilian </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="68d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go是一种简单易学的编程语言。围棋程序也非常快，因为它们被编译成机器码，有一个静态类型系统。此外，Go具有内置的垃圾收集功能，并且仍然支持指针、按值传递和按引用传递的概念。这真的很强大，因为您不会受到语言的限制(像Java或其他高级编程语言)。</p><p id="6d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，它也带来了很多困惑，并导致许多开发人员犯错误。在本文中，我们将讨论其中的一些。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a65f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 1。对切片的操作可能会也可能不会创建新的底层数组</strong></h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Go中，切片是<em class="mw">引用类型</em>。它们引用基础数组。当您从现有切片创建新切片时，它们实际上引用相同的底层数组。在示例中，<code class="fe mx my mz na b">s1</code>、<code class="fe mx my mz na b">s2</code>和<code class="fe mx my mz na b">s3</code>都引用同一个底层数组，因此当<code class="fe mx my mz na b">s1[2]</code>被更新时，所有三个数据片都被更新。</p><p id="6c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果原始数组不能容纳更多的新数据，向片<a class="ae ky" href="https://blog.golang.org/slices" rel="noopener ugc nofollow" target="_blank">添加新元素可能会导致</a>进行新的数组分配。<code class="fe mx my mz na b">s4</code>就是这种情况。因此，我们在处理切片时需要非常小心，因为底层数据可能会以您意想不到的方式发生变化。</p><p id="e938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码可用于确保我们可以获得对新底层数组的引用(如果它已被分配):</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="a7d5" class="nf md it na b gy ng nh l ni nj">type Stack []interface{}<br/>func (stack *Stack) Push(x interface{}) { <br/>    *stack = append(*stack, x)<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="160a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 2。range子句中的数据是实际收集元素的副本</strong></h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="acf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与大多数编程语言中内置的垃圾收集不同，Go中的<code class="fe mx my mz na b">range</code>子句生成的数据值出人意料地不引用原始项。它们是实际集合元素的副本。因此，在上面的示例中，更新值不会更改原始数据。要更新原始值，需要索引操作符来访问它们:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="ee50" class="nf md it na b gy ng nh l ni nj">for i, _ : range s {<br/>    s[i].X = i<br/>    s[i].Y = i<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c207" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 3。可寻址值与不可寻址值</strong></h1><p id="f854" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">可寻址值在围棋中是一个棘手的概念。我们不会详细讨论这个概念(你应该阅读这篇文章)，但是我们会讨论它如何改变我们的编码行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码不能工作，因为map中的值是不可寻址的，也不能被赋值。函数的返回值也会出现类似的错误:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="eb7f" class="nf md it na b gy ng nh l ni nj">sfunc().field = .... // error when assigning struct field from func<br/>afunc()[0] = .... // error when assigning the array item from func</span></pre><p id="e17d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，可以使用临时变量作为解决方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="212b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者您可以使用指针映射，因为指针间接寻址是可寻址的:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="76df" class="nf md it na b gy ng nh l ni nj">m := make(map[string]*Point)<br/>m["p1"] = &amp;Point{1,1}<br/>m["p1"].X = 2<br/>fmt.Println(m["p1"])<br/>--------------<br/>&amp;{2 1}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="15f6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 4。返回指向局部结构的指针</strong></h1><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="5680" class="nf md it na b gy ng nh l ni nj">func test() *int {<br/>   var i int = 1<br/>   return &amp;i;<br/>}</span></pre><p id="f475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在C/C++中，上面的代码不能工作，因为局部变量是在堆栈中分配的，当函数返回时，它将消失。然而，在Go中，编译器决定将变量分配到哪里。编译器根据变量的大小和“转义分析”的结果来选择存储变量的位置在这种情况下，编译器看到返回了局部变量<code class="fe mx my mz na b">i</code>的地址，所以它只是将该变量放在堆上(而不是堆栈上)。</p><p id="1b74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多详情可以阅读<a class="ae ky" href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html" rel="noopener ugc nofollow" target="_blank">本文</a>。</p><p id="9f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过理解转义分析，您可以避免代码中的一些性能问题，因为在堆栈和堆中分配变量会产生性能差异。</p><p id="fb89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mx my mz na b">go build</code>或<code class="fe mx my mz na b">go run</code>中可以使用<code class="fe mx my mz na b">-m gcflag</code>来知道你的变量被分配到哪里(例如<code class="fe mx my mz na b">go run -gcflags -m test.go</code>)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cfd1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 5。指针的零检查可能会令人困惑</strong></h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本质上，Go中的接口可以被认为是一个值和一个具体类型的元组(一个接口保存一个特定底层具体类型的值)。持有<code class="fe mx my mz na b">nil</code>具体值的接口变量本身是非<code class="fe mx my mz na b">nil</code>。如果要检查底层类型的值是否为<code class="fe mx my mz na b">nil</code>，可以这样检查:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="a343" class="nf md it na b gy ng nh l ni nj">np == (*int)(nil) // return true</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7857" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ol class=""><li id="4635" class="np nq it lb b lc nk lf nl li nr lm ns lq nt lu nu nv nw nx bi translated"><a class="ae ky" href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html" rel="noopener ugc nofollow" target="_blank">https://www . ardan labs . com/blog/2017/05/language-mechanics-on-escape-analysis . html</a></li><li id="0927" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://golang.org/ref/spec#Address_operators" rel="noopener ugc nofollow" target="_blank">https://golang.org/ref/spec#Address_operators</a></li><li id="b0f1" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoAddressableValues" rel="noopener ugc nofollow" target="_blank">https://utcc . utoronto . ca/~ cks/space/blog/programming/goadressablevalues</a></li><li id="e060" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://golang.org/doc/effective_go" rel="noopener ugc nofollow" target="_blank">https://golang.org/doc/effective_go</a></li></ol></div></div>    
</body>
</html>