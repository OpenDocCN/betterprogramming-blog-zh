<html>
<head>
<title>Web Scraping with PHP: a Step-By-Step Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP网页抓取:一步一步的教程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-step-by-step-tutorial-to-web-scraping-in-php-fc57a926d468?source=collection_archive---------9-----------------------#2022-08-16">https://betterprogramming.pub/a-step-by-step-tutorial-to-web-scraping-in-php-fc57a926d468?source=collection_archive---------9-----------------------#2022-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过一个完整的例子从基本技术到高级技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/82a3c9732d335d236699434367c53dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P-yoLqWnDBJ0MhZk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗斯·斯奈登在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="30de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络抓取变得越来越流行，现在是IT社区的一个热门话题。因此，有几个库可以帮助你从网站上抓取数据。在这里，您将学习如何使用最流行的web scraper库之一用PHP构建web scraper。</p><p id="ce36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，你将学习PHP的网页抓取基础知识。然后是如何绕开最流行的反抓取系统，学习更高级的技术和概念，比如并行抓取和无头浏览器。</p><p id="025a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循这个教程，成为PHP网页抓取专家！让我们不要浪费更多的时间，用PHP构建我们的第一个scraper。</p><h1 id="304e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先决条件</h1><p id="4cc6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是简单铲运机工作所需的先决条件列表:</p><p id="34a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的系统上没有安装这些软件，您可以通过上面的链接下载它们。</p><p id="9379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您还需要以下Composer库，您可以使用以下命令将它添加到项目的依赖项中:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0787" class="mx lw it mt b gy my mz l na nb">composer require vokku/simple_html_dom</span></pre><p id="e8a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您还需要内置的<code class="fe nc nd ne mt b">cURL</code> PHP库。<code class="fe nc nd ne mt b">cURL</code>带有<code class="fe nc nd ne mt b">curl-ext</code> PHP扩展，它在大多数PHP包中自动存在并启用。如果你安装的PHP包不包含<code class="fe nc nd ne mt b">curl-ext</code>，你可以按照这里的<a class="ae ky" href="https://www.php.net/manual/en/curl.setup.php" rel="noopener ugc nofollow" target="_blank">来安装</a>。</p><p id="ad5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们了解一下这里提到的依赖关系。</p><h1 id="ab8e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">介绍</h1><p id="73f4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe nc nd ne mt b">vokku/simple_html_dom</code>是<a class="ae ky" href="https://simplehtmldom.sourceforge.io/docs/1.9/index.html" rel="noopener ugc nofollow" target="_blank">简单HTML DOM解析器</a>项目的一个分支，它用<a class="ae ky" href="https://www.php.net/manual/en/class.domdocument.php" rel="noopener ugc nofollow" target="_blank"> DOMDocument </a>和其他现代PHP类代替了字符串操作。拥有近200万次安装的，<code class="fe nc nd ne mt b">vokku/simple_html_dom</code>是一个快速、可靠和简单的库，用于解析HTML文档和在PHP中执行web抓取。</p><p id="ac35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne mt b">curl-ext</code>是一个PHP扩展，启用PHP中的<code class="fe nc nd ne mt b"><a class="ae ky" href="https://www.php.net/manual/en/book.curl" rel="noopener ugc nofollow" target="_blank">cURL</a></code> <a class="ae ky" href="https://www.php.net/manual/en/book.curl" rel="noopener ugc nofollow" target="_blank"> HTTP客户端</a>，允许你用PHP执行HTTP请求。</p><p id="30e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/Tonel/simple-scraper-php" rel="noopener ugc nofollow" target="_blank">这个GitHub repo </a>中找到演示web scraper的代码。使用以下命令克隆它并安装项目的依赖项:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9682" class="mx lw it mt b gy my mz l na nb">git clone <a class="ae ky" href="https://github.com/Tonel/simple-scraper-php" rel="noopener ugc nofollow" target="_blank">https://github.com/Tonel/simple-scraper-php</a></span><span id="5f60" class="mx lw it mt b gy nf mz l na nb">cd simple-scraper-php</span><span id="4d09" class="mx lw it mt b gy nf mz l na nb">composer update</span></pre><p id="91e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">跟随这个教程，学习如何用PHP构建一个web scraper应用程序！</p><h1 id="45bb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">PHP中的基本网页抓取</h1><p id="89be" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这里，您将看到如何在作为抓取目标的网站<code class="fe nc nd ne mt b"><a class="ae ky" href="https://scrapeme.live/shop/" rel="noopener ugc nofollow" target="_blank">https://scrapeme.live/shop/</a></code>上执行网页抓取。</p><p id="3db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，这是商店的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/4c4af55d357559bb606e3d49984c5cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f6lz13dMwES7sdvK.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe nc nd ne mt b">scrapeme.live/shop</code>概观</p></figure><p id="d85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，<code class="fe nc nd ne mt b">scrapeme.live</code>只不过是一个简单的受口袋妖怪启发的产品的分页列表。让我们用PHP构建一个简单的web scraper，抓取网站并从所有这些产品中抓取数据。</p><p id="bebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你必须下载你要抓取的页面的HTML。您可以使用<code class="fe nc nd ne mt b">cURL</code>轻松下载PHP中的HTML文档，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您已经将<code class="fe nc nd ne mt b">https://scrapeme.live/shop/</code>页面的HTML存储在了<code class="fe nc nd ne mt b">$html</code>变量中。用下面的<code class="fe nc nd ne mt b">str_get_html()</code>函数将它加载到一个<code class="fe nc nd ne mt b">HtmlDomParser</code>实例中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a09d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以使用<code class="fe nc nd ne mt b">HtmlDomParser</code>来浏览HTML页面的DOM并开始数据提取。</p><p id="e227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们检索所有分页链接的列表，以抓取整个网站部分。右键单击页码HTML元素并选择“检查”选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/65cb71e6a08063c81f43281d117c0d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5XR0gD4filXLLjb8.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择“Inspect”选项打开DevTools窗口</p></figure><p id="72df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，浏览器应该打开一个DevTools窗口或部分，突出显示DOM元素，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/2b5a35e3bf2a568206e7ca65be23680d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vZqV5nczBtNt2M2o.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择页码HTML元素后的DevTools窗口</p></figure><p id="2346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WebTools窗口中，您可以看到<code class="fe nc nd ne mt b">page-numbers</code> CSS类标识了分页HTML元素。请注意，CSS类并不唯一地标识HTML元素，许多节点可能有相同的类。这正是在<code class="fe nc nd ne mt b">scrapeme.live</code>页面中<code class="fe nc nd ne mt b">page-numbers</code>所发生的事情。</p><p id="9a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您想使用一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors" rel="noopener ugc nofollow" target="_blank"> CSS选择器</a>来挑选DOM中的元素，您应该使用CSS类和其他选择器。特别是，您可以使用带有<code class="fe nc nd ne mt b">.page-numbers a</code> CSS选择器的<code class="fe nc nd ne mt b">HtmlDomParser</code>来选择页面上所有的分页HTML元素。然后，遍历它们，从<code class="fe nc nd ne mt b">href</code>属性中提取所有需要的URL，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="dc49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，该函数允许您基于CSS选择器提取DOM元素。此外，考虑到pagination元素在web页面上放置了两次，您需要定义自定义逻辑来避免在<code class="fe nc nd ne mt b">$paginationLinks</code>数组中出现重复的元素。</p><p id="58bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果执行，该脚本将返回:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1d5f" class="mx lw it mt b gy my mz l na nb">Array (   <br/>   [0] =&gt; https://scrapeme.live/shop/page/2/<br/>   [1] =&gt; https://scrapeme.live/shop/page/3/<br/>   [2] =&gt; https://scrapeme.live/shop/page/4/<br/>   [3] =&gt; https://scrapeme.live/shop/page/46/<br/>   [4] =&gt; https://scrapeme.live/shop/page/47/<br/>   [5] =&gt; https://scrapeme.live/shop/page/48/  <br/>)</span></pre><p id="b93f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如图所示，所有的URL都遵循相同的结构，并以指定页码的最终数字为特征。如果想遍历所有页面，只需要最后一个页面的编号。按如下方式检索:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne mt b">$highestPaginationNumber</code>将包含“四十八”。</p><p id="ed12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们检索与单个产品相关的数据。同样，右键单击产品并打开带有“Inspect”选项的DevTools窗口。这是你应该得到的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/eda6c8a8fa66912adfa384f34251b4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aCmpweMFPindqGwd.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择产品HTML元素后的DevTools窗口</p></figure><p id="f079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，产品由一个包含URL、图像、名称和价格的<code class="fe nc nd ne mt b">li.product</code> HTML元素组成。这个产品信息分别放在一个<code class="fe nc nd ne mt b">a</code>、<code class="fe nc nd ne mt b">img</code>、<code class="fe nc nd ne mt b">h2</code>、<code class="fe nc nd ne mt b">span</code> HTML元素中。您可以使用<code class="fe nc nd ne mt b">HtmlDomParser</code>提取这些数据，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d6e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该逻辑提取一页上的所有产品数据，并将其保存在<code class="fe nc nd ne mt b">$productDataList</code>数组中。</p><p id="1f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您只需迭代每个页面，并应用上面定义的抓取逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5f26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊！您刚刚学习了如何用PHP构建一个简单的web scraper！</p><p id="54c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看这个脚本的全部代码，你可以在这里找到它。运行它，您将检索到以下数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ea02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！您刚刚自动提取了所有产品数据！</p><h1 id="1b9d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">避免被封锁</h1><p id="810d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">上面的例子使用了一个为抓取而设计的网站。提取所有数据是小菜一碟，但不要被这个愚弄！抓取网站并不总是那么容易，你的脚本可能会被拦截和阻止。找出如何防止这种情况发生！</p><p id="8579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种可能的防御机制来阻止脚本访问网站。这些技术试图根据非人类或恶意用户的行为来识别他们的请求，并阻止他们。</p><p id="9178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绕过所有这些防刮擦系统并不容易。然而，您通常可以通过两个简单的解决方案来避免其中的大部分:公共HTTP头和web代理。现在让我们仔细看看这两种方法。</p><h2 id="b468" class="mx lw it bd lx nk nl dn mb nm nn dp mf li no np mh lm nq nr mj lq ns nt ml nu bi translated">1.使用普通HTTP头模拟真实用户</h2><p id="1278" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">许多网站会屏蔽看起来不是来自真实用户的请求。另一方面，浏览器设置了一些HTTP头。确切的标题因供应商而异。因此，这些防刮擦系统希望这些头文件存在。因此，您可以通过设置适当的HTTP头来避免阻塞。</p><p id="444f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，您应该始终设置的最关键的头是<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent" rel="noopener ugc nofollow" target="_blank">用户代理</a>头(此后称为UA)。它是一个字符串，用于标识发起HTTP请求的应用程序、操作系统、供应商和/或应用程序版本。</p><p id="3d7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<code class="fe nc nd ne mt b">cURL</code>发送<code class="fe nc nd ne mt b">curl/XX.YY.ZZ</code> UA头，这使得请求很容易被识别为脚本。您可以使用<code class="fe nc nd ne mt b">cURL</code>手动设置UA报头，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="cfe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6b60" class="mx lw it mt b gy my mz l na nb">curl_setopt($curl, CURLOPT_USERAGENT, "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36")</span></pre><p id="1669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这行代码设置了谷歌Chrome最新版本目前使用的UA。这使得<code class="fe nc nd ne mt b">cURL</code>请求更难被识别为来自脚本。</p><p id="0830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以轻松地在线找到有效、最新和可信的UA头列表。大多数情况下，设置HTTP UA头就足以避免被阻塞。如果这还不够，您可以用<code class="fe nc nd ne mt b">cURL</code>发送其他HTTP头，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3e67" class="mx lw it mt b gy my mz l na nb">// set the Content-Language and Authorization HTTP headers <br/>curl_setopt($curl, CURLOPT_HTTPHEADER, <br/> array( <br/>   "Content-Language: es", <br/>   "Authorization: 32b108le1HBuSYHMuAcCrIjW72UTO3p5X78iIzq1CLuiHKgJ8fB2VdfmcS", <br/> ) <br/>);</span></pre><p id="d6f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解ZenRows在<a class="ae ky" href="https://www.zenrows.com/documentation#custom-params-php?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=web_scraping_php" rel="noopener ugc nofollow" target="_blank">设置自定义标题</a>方面提供了什么。</p><h2 id="708f" class="mx lw it bd lx nk nl dn mb nm nn dp mf li no np mh lm nq nr mj lq ns nt ml nu bi translated">2.使用网络代理隐藏你的IP</h2><p id="d065" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">防刮擦系统往往会阻止用户在短时间内访问许多页面。主要检查来自请求的IP。如果同一个IP在短时间内发出许多请求，就会被阻止。换句话说，要阻止IP上的块，您必须找到隐藏它的方法。</p><p id="9714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好的方法之一是通过代理服务器。web代理是您的机器和互联网上其他计算机之间的中间服务器。当通过代理执行请求时，目标网站将看到代理服务器的IP地址，而不是您的IP地址。</p><p id="055b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网上有几个免费的代理服务器，但是大多数都是短命的，不可靠的，并且经常不可用。你可以用它们来测试。然而，你不应该依赖他们来制作剧本。</p><p id="91f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，付费代理服务更可靠，通常伴随着IP轮换。这意味着代理服务器公开的IP将随着时间的推移或每个请求而频繁改变。这使得该服务提供的每个IP更难被禁止，即使发生这种情况，你也会很快获得一个新的IP。</p><p id="0634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ZenRows支持高级代理。了解如何使用它们来避免阻塞。</p><p id="b06e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe nc nd ne mt b">cURL</code>设置web代理，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1480" class="mx lw it mt b gy my mz l na nb">curl_setopt($curl, CURLOPT_PROXY, "102.68.128.214");  curl_setopt($curl, CURLOPT_PROXYPORT, "8080");  <br/>curl_setopt($curl, CURLOPT_PROXY, CURLPROXY_HTTP);</span></pre><p id="0fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大多数web代理，在第一行设置代理的URL就足够了。<code class="fe nc nd ne mt b">CURLOPT_PROXYTYPE</code>可以取以下值:<code class="fe nc nd ne mt b">CURLPROXY_HTTP</code>(默认)、<code class="fe nc nd ne mt b">CURLPROXY_SOCKS4</code>、<code class="fe nc nd ne mt b">CURLPROXY_SOCKS5</code>、<code class="fe nc nd ne mt b">CURLPROXY_SOCKS4A</code>或<code class="fe nc nd ne mt b">CURLPROXY_SOCKS5_HOSTNAME</code>。</p><p id="8b61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你刚刚学会如何避免被封锁。现在让我们深入研究如何让你的脚本更快！</p><h1 id="1f26" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">平行刮削</h1><p id="9c00" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在PHP中处理多线程是复杂的。有几个库可以支持你，但是在PHP中执行并行抓取的最简单有效的解决方案不需要任何库。</p><p id="da6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种并行抓取的方法是为了让抓取脚本可以在多个实例上运行。使用HTTP GET参数是可能的。</p><p id="8da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑前面给出的分页示例。您可以修改脚本来处理较小的块，然后并行启动脚本的几个实例，而不是让脚本遍历所有页面。</p><p id="2401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您所要做的就是向脚本传递一些参数来定义块的边界。</p><p id="e100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过引入如下两个GET参数轻松实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="79b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以通过在浏览器中打开以下链接来启动脚本的几个实例:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="356f" class="mx lw it mt b gy my mz l na nb">https://your-domain.com/scripts/scrapeme.live/scrape-products.php?from=1&amp;to=5</span><span id="11bc" class="mx lw it mt b gy nf mz l na nb">https://your-domain.com/scripts/scrapeme.live/scrape-products.php?from=6&amp;to=10</span><span id="ee25" class="mx lw it mt b gy nf mz l na nb">...</span><span id="7f5a" class="mx lw it mt b gy nf mz l na nb">https://your-domain.com/scripts/scrapeme.live/scrape-products.php?from=41&amp;to=45</span><span id="356e" class="mx lw it mt b gy nf mz l na nb">https://your-domain.com/scripts/scrapeme.live/scrape-products.php?from=46&amp;to=48</span></pre><p id="6934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些实例将并行运行，同时抓取网站。你可以在这里找到这个新版抓取脚本<a class="ae ky" href="https://github.com/Tonel/simple-scraper-php/blob/main/src/parallel.php" rel="noopener ugc nofollow" target="_blank">的全部代码。</a></p><p id="c77d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了！您刚刚学习了如何通过web抓取从网站并行提取数据。</p><p id="a55f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并行抓取网站已经是一个很大的改进，但是在PHP web scraper中还可以采用许多其他的高级技术。让我们来看看如何让你的网页抓取脚本更上一层楼。</p><h1 id="36b4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先进的技术</h1><p id="96e5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">请记住，并非网页上所有感兴趣的数据都直接显示在浏览器中。网页也由元数据和隐藏元素组成。要访问这些数据，右键单击网页的空白部分，然后单击“查看页面源代码”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/c8871b969663c40d21b6deaf00eab3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U3nbyR1e1azM0dot.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe nc nd ne mt b">scrapeme.live/shop</code>的源代码</p></figure><p id="4c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里你可以看到一个网页的完整DOM，包括隐藏的元素。详细地说，你可以在<code class="fe nc nd ne mt b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta" rel="noopener ugc nofollow" target="_blank">meta</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta" rel="noopener ugc nofollow" target="_blank"> HTML标签</a>中找到关于网页的元数据。此外，重要的隐藏数据可能存储在<code class="fe nc nd ne mt b"><a class="ae ky" href="https://www.zenrows.com/blog/mastering-web-scraping-in-python-from-zero-to-hero#explore-before-coding" rel="noopener ugc nofollow" target="_blank">&lt;input type="hidden"/&gt;</a></code> <a class="ae ky" href="https://www.zenrows.com/blog/mastering-web-scraping-in-python-from-zero-to-hero#explore-before-coding" rel="noopener ugc nofollow" target="_blank">元素</a>中。</p><p id="c8cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，一些数据可能已经通过<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/visibility" rel="noopener ugc nofollow" target="_blank">隐藏的HTML元素</a>出现在页面上。只有在特定事件发生时，JavaScript才会显示出来。尽管您看不到页面上的数据，但它仍然是DOM的一部分。因此，您可以使用<code class="fe nc nd ne mt b">HtmlDomParser</code>检索这些隐藏的HTML元素，就像处理可见节点一样。</p><p id="63ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，记住网页不仅仅是它的源代码。网页可以请求浏览器通过AJAX异步检索数据，并相应地更新它们的DOM。这些AJAX调用通常提供有价值的数据，您可能需要从web抓取脚本中调用它们。</p><p id="5c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要监听这些调用，您需要使用浏览器的DevTools窗口。右键单击网站的空白部分，选择“检查”，然后进入“网络”选项卡。在“获取/XHR”选项卡中，您可以看到由网页执行的AJAX调用列表，如下例所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/755f4f6502dd7e56835956ab875baad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kU2CllJwoBeQng0j.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.w3schools.com/jquery/tryit.asp?filename=tryjquery_ajax_post" rel="noopener ugc nofollow" target="_blank">演示页面</a>执行的POST AJAX调用</p></figure><p id="b8f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浏览所选AJAX请求的所有内部选项卡，了解如何执行AJAX调用。具体来说，可以复制这个POST AJAX调用<code class="fe nc nd ne mt b">cURL</code>,如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="536c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！您刚刚与<code class="fe nc nd ne mt b">cURL</code>进行了一次POST通话！</p><h1 id="4171" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">无头浏览器</h1><p id="97e6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">嗅探和复制AJAX调用有助于以编程方式从由于用户交互而加载的网站中检索数据。这些数据不是网页源代码的一部分，也不能在从标准GET <code class="fe nc nd ne mt b">cURL</code>请求获得的HTML元素中找到。</p><p id="3d28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，复制所有可能的交互、嗅探AJAX调用并在脚本中调用它们是一种麻烦的方法。有时，您需要定义一个脚本，像人类用户一样通过JavaScript与页面进行交互。你可以用<a class="ae ky" href="https://en.wikipedia.org/wiki/Headless_browser" rel="noopener ugc nofollow" target="_blank">无头浏览器</a>来实现。</p><p id="4b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉这个概念，无头浏览器是一种没有图形用户界面的网络浏览器，它通过代码提供对网页的自动控制。PHP中最流行的提供无头浏览器功能的库是<code class="fe nc nd ne mt b"><a class="ae ky" href="https://github.com/php-webdriver/php-webdriver" rel="noopener ugc nofollow" target="_blank">chrome-php</a></code>和<a class="ae ky" href="https://github.com/php-webdriver/php-webdriver" rel="noopener ugc nofollow" target="_blank"> Selenium WebDriver </a>。</p><p id="e7ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，ZenRows还提供网络浏览器功能。了解更多关于<a class="ae ky" href="https://www.zenrows.com/documentation#custom-params-php?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=web_scraping_php" rel="noopener ugc nofollow" target="_blank">如何提取动态加载的数据</a>。</p><h1 id="3096" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">其他图书馆</h1><p id="1559" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当涉及到web抓取时，您可以采用的其他有用的PHP库有:</p><ul class=""><li id="166f" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><a class="ae ky" href="https://docs.guzzlephp.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> Guzzle </a>:一个高级的HTTP客户端，它使得发送HTTP请求变得容易，并且易于与web服务集成。你可以用它来代替<code class="fe nc nd ne mt b">cURL</code>。</li><li id="f4bd" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">Goutte :一个网络抓取库，提供高级API来抓取网站并从它们的HTML网页中提取数据。因为它还包含一个HTTP客户端，所以您可以用它来替代<code class="fe nc nd ne mt b">vokku/simple_html_dom</code>和<code class="fe nc nd ne mt b">cURL</code>。</li></ul><h1 id="d557" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="ce09" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这里，您已经了解了在PHP中执行web抓取应该知道的一切，从基本的抓取到高级技术。如上所示，用PHP构建一个可以抓取网站并自动提取数据的web scraper并不困难。</p><p id="60df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你所需要的只是正确的库，这里我们已经看到了一些最流行的库。</p><p id="4158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这个，看一看<a class="ae ky" href="https://www.zenrows.com/blog/web-scraping-with-javascript-and-nodejs?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=web_scraping_php" rel="noopener ugc nofollow" target="_blank"> JavaScript网页抓取指南</a>。</p><p id="f6ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，你的网页抓取器应该能够绕过防抓取系统，并可能需要检索隐藏数据或像人类用户一样与网页进行交互。在本教程中，您也学习了如何完成所有这些工作。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="065f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oq">最初发表于</em><a class="ae ky" href="https://www.zenrows.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=web_scraping_php" rel="noopener ugc nofollow" target="_blank">T5【https://zenrows.com】</a><em class="oq">。</em></p></div></div>    
</body>
</html>