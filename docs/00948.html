<html>
<head>
<title>What Is a Singleton?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是独生子女？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-a-singleton-2dc38ca08e92?source=collection_archive---------1-----------------------#2019-07-31">https://betterprogramming.pub/what-is-a-singleton-2dc38ca08e92?source=collection_archive---------1-----------------------#2019-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0307" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">单体设计模式和常见实现的介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac4d0a0bb82efa599c9303eb320b5b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*isyJ4vtKm04UprlJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨法尔·萨法罗夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="8bd6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="c42d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">单例设计模式将类的实例化限制为单个实例。这样做是为了在整个软件系统中提供对特定资源的协调访问。通过这种设计模式，singleton类确保它只被实例化一次，并且可以提供对单个实例的简单访问。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2f36" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">用例</h1><p id="43a4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">单体设计模式的常见用例包括工厂、构建器和保存程序状态的对象。</p><p id="f5c7" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">单例有时被认为是全局变量或静态类的替代品。</p><p id="7a10" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated"><em class="ne">与全局变量相比，单例变量有以下好处:</em></p><ul class=""><li id="a090" class="nf ng it lt b lu mz lx na ma nh me ni mi nj mm nk nl nm nn bi translated">单例实例字段不占用全局名称空间</li><li id="57e9" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">单例可以被延迟初始化(将进一步讨论)</li></ul><p id="d7ce" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">主要是因为单例拥有实例化的对象，而静态类没有，<em class="ne">单例相对于静态类</em>有以下优势:</p><ul class=""><li id="bab9" class="nf ng it lt b lu mz lx na ma nh me ni mi nj mm nk nl nm nn bi translated">单件可以实现接口</li><li id="628a" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">单例可以作为参数传递</li><li id="57af" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">单例可以换出它们的实例(比如为了测试的目的)</li><li id="1037" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">单例可以被多态地处理，所以可能存在多种实现</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5a2e" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">履行</h1><p id="30e8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们看看Java中一个基本单例类的实现细节。单例通常用一个私有构造函数方法和一个公共静态方法来实现，以返回单例的实例——存储在私有静态最终变量中。</p><p id="e476" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">有两种类型的单例实现:急切初始化和懒惰初始化。它们的不同之处在于初始化singleton实例的方式。我们还必须考虑它们中的线程安全。</p><h2 id="70b3" class="nt la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">急切初始化</h2><p id="af1c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这个版本中，singleton实例是在初始化singleton变量时创建的，而不是在第一次使用它时。由于在程序执行的这一点上singleton没有用，它可能会不必要地消耗系统资源。如果单例实例的计算成本很高或者占用大量资源，这可能会降低系统性能。然而，这个版本是线程安全的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="5b75" class="nt la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">惰性初始化</h2><p id="afb9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这个版本中，singleton实例是在静态的<code class="fe oh oi oj ok b">getInstance</code>方法第一次被调用时创建的。这确保了单例实例仅在绝对必要时才消耗系统资源。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="45d7" class="nt la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">线程安全的惰性初始化</h2><p id="b8e6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上面显示的懒惰初始化版本是<em class="ne">而不是</em>线程安全的。单例实例可以在一个多线程程序中创建多次，所有都同时使用<code class="fe oh oi oj ok b">Singleton</code>类。如果创建单例对象的成本非常高，这可能会消耗大量可用的系统资源。此外，这可能导致线程接收到部分创建的singleton对象。</p><p id="9fa5" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">通过使用同步，下面的实现是线程安全的。<code class="fe oh oi oj ok b">instance</code>变量现在也被声明为<code class="fe oh oi oj ok b">volatile</code>，这确保了所有线程都有一个singleton实例的更新视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div></div>    
</body>
</html>