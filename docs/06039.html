<html>
<head>
<title>Accounts and Roles in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity中的客户和角色</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/accounts-and-roles-in-solidity-48da6845038d?source=collection_archive---------11-----------------------#2020-08-27">https://betterprogramming.pub/accounts-and-roles-in-solidity-48da6845038d?source=collection_archive---------11-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e30c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们需要智能合约来处理具有多种角色的客户。做那件事最有效的方法是什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/69dd984e76fd9ff079b7f04b3fce6b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hyrphz2FNrz2b0nhfFxMAA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="f188" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">客户和角色—背景</h1><p id="1906" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在开发和测试Datona Lab的<a class="ae ky" href="https://solidity.readthedocs.io/en/v0.7.0/" rel="noopener ugc nofollow" target="_blank">Solidity</a>smart data access contracts(S-DAC)的过程中，我们经常需要处理多个角色的帐户，例如合同所有者和数据所有者，或者数据审计员和数据监管员。</p><p id="b7fe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文的例子中，我们研究了使用动态值数组或集合是否比使用实性映射更有效。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="28f5" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">讨论</h1><p id="5e95" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">根据文章“<a class="ae ky" href="https://medium.com/coinmonks/state-machines-in-solidity-9e2d8a6d7a11" rel="noopener">Solidity</a>中的状态机”，我们的Solidity智能合约通常包含状态机每当用户试图将智能合约从一种状态转换到另一种状态时，它都会检查用户是否有权限这样做。该权限基于机器的当前状态和用户的角色。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="f86f" class="nj la it nf b gy nk nl l nm nn">    ...</span><span id="c1c1" class="nj la it nf b gy no nl l nm nn">    function startVerification() public {<br/>        require(currentState == State.READY_FOR_VERIFICATION);<br/>        require(<strong class="nf iu">accountHasRole</strong>(msg.sender, Role.VERIFIER));<br/>        currentState = State.VERIFYING;<br/>    }</span><span id="d6d2" class="nj la it nf b gy no nl l nm nn">    ...</span></pre><p id="8d13" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">本文的重点是智能合约提供的<code class="fe np nq nr nf b">accountHasRole</code> <strong class="lt iu"> </strong>的高效实现。</p><p id="6fa4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们考虑这些可能的实现:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="4237" class="nj la it nf b gy nk nl l nm nn"><strong class="nf iu">Name       Description</strong></span><span id="6666" class="nj la it nf b gy no nl l nm nn">map/map    account mapping and role mapping<br/>map/d31    account mapping and dynamic value-array of 31 bytes<br/>map/set    account mapping and set</span></pre><p id="03be" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">动态值数组在作者的文章<a class="ae ky" href="https://medium.com/better-programming/dynamic-value-arrays-in-solidity-8e9b44015833" rel="noopener">Solidity</a>中描述。</p><p id="099f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在下面的智能合约中，为了简化，我们使用常数而不是枚举。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="ee2a" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">智能合同实施</h1><p id="01bc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们在基类中有效地提供了功能。它被设计为可继承的，以便提供所需的功能。这实际上是劫持继承作为对象合成的替代品。</p><h2 id="bb87" class="nj la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">地图/地图</h2><p id="0814" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面是一个有用的导入文件，它提供了一个基础契约，该契约提供了添加和检查功能:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="93e4" class="nj la it nf b gy nk nl l nm nn">contract BaseAccountRoles { // an account has many roles<br/>    mapping(address =&gt; mapping(uint =&gt; bool)) accountRoles;<br/>    <br/>    function accountAddRole(address account, uint role) internal {<br/>        accountRoles[account][role] = true;<br/>    }</span><span id="5013" class="nj la it nf b gy no nl l nm nn">    function accountHasRole(address account, uint role) internal <br/>    view returns (bool) {<br/>        return accountRoles[account][role];<br/>    }<br/>}</span></pre><p id="6149" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个契约使用Solidity优秀的<a class="ae ky" href="https://solidity.readthedocs.io/en/latest/types.html#mapping-types" rel="noopener ugc nofollow" target="_blank">映射</a>特性，从给定的地址映射到每个给定的角色，进而映射到一个bool，指示帐户地址是否提供角色。</p><h2 id="de9a" class="nj la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">地图/d31</h2><p id="cca6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面是另一个有用的导入文件，它提供了一个基础契约，该契约提供了添加和检查功能:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="7dac" class="nj la it nf b gy nk nl l nm nn">import "Bytes31fun.sol"</span><span id="3207" class="nj la it nf b gy no nl l nm nn">contract BaseAccountRoles31 { // an account has many roles<br/>    using Bytes31fun for bytes32;<br/>    <br/>    mapping(address =&gt; bytes32) accountRoles;<br/>    <br/>    function addAccountRole(address account, uint role) internal {<br/>        accountRoles[account] = accountRoles[account].<strong class="nf iu">push</strong>(role);<br/>    }</span><span id="c3e5" class="nj la it nf b gy no nl l nm nn">    function confirmAccountRole(address account, uint role) internal <br/>    view returns (bool) {<br/>        return accountRoles[account].<strong class="nf iu">find</strong>(role);<br/>    }<br/>}</span></pre><p id="61f4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个契约使用一个库来扩展Solidity bytes32类型，以提供<strong class="lt iu"> push() </strong>和<strong class="lt iu"> find() </strong>。作者在文章《Solidity中的动态值数组<a class="ae ky" href="https://medium.com/better-programming/dynamic-value-arrays-in-solidity-8e9b44015833" rel="noopener">中描述了这种方法。</a></p><p id="800a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Solidity的映射特性用于从给定地址映射到bytes32变量，该变量保存地址提供的每个给定角色的复合。</p><p id="5cd2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果使用该实现的智能协定试图向任何一个帐户添加超过31个角色，该实现将引发异常。这在我们的特定实现中是不可能的，但是如果您使用这种技术，请注意它的局限性。</p><h2 id="b687" class="nj la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">地图/设置</h2><p id="5610" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面是最后一个有用的导入文件，它提供了一个提供添加和检查功能的基础契约:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="1d63" class="nj la it nf b gy nk nl l nm nn">contract BaseAccountRolesSet { // an account has many roles<br/>    mapping(address =&gt; uint) accountRoleSet;<br/>    <br/>    function addAccountRole(address account, uint role) internal {<br/>        accountRoleSet[account] |= 1 &lt;&lt; role;<br/>    }</span><span id="4266" class="nj la it nf b gy no nl l nm nn">    function confirmAccountRole(address account, uint role) internal <br/>    view returns (bool) {<br/>        return (accountRoleSet[account] &amp; (1 &lt;&lt; role)) != 0;<br/>    }<br/>}</span></pre><p id="e072" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Solidity的映射特性用于从给定的地址映射到一个变量，该变量用作一个集合来保存地址提供的每个给定的角色。</p><p id="8600" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果使用它的智能契约试图向任何一个帐户添加超过256个角色，这个实现将<em class="od">而不是</em>抛出异常。在这种情况下，我对这种可能性很放松。</p><p id="2c4e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">神秘的图片机会:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/4e538c40ab83557a510507405951a4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EyyHWnd6nRViDv92"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹姆斯·科尔曼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="2bde" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">测试</h1><p id="61d1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将测试中的所有功能<em class="od">公之于众</em>，以便测量构建成本，并创建了一个测试工具，用于测量以下各项的气体消耗:</p><ol class=""><li id="57cf" class="of og it lt b lu mn lx mo ma oh me oi mi oj mm ok ol om on bi translated">创建基础合同</li><li id="f313" class="of og it lt b lu oo lx op ma oq me or mi os mm ok ol om on bi translated">添加帐户1，角色1</li><li id="a3ef" class="of og it lt b lu oo lx op ma oq me or mi os mm ok ol om on bi translated">添加帐户1，角色2</li><li id="a93d" class="of og it lt b lu oo lx op ma oq me or mi os mm ok ol om on bi translated">添加帐户1，角色3</li><li id="2c5b" class="of og it lt b lu oo lx op ma oq me or mi os mm ok ol om on bi translated">添加帐户2，角色3</li><li id="fa3e" class="of og it lt b lu oo lx op ma oq me or mi os mm ok ol om on bi translated">添加帐户3，角色3</li></ol><p id="d562" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Solidity智能合同代码遵循以下原则:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="1fd7" class="nj la it nf b gy nk nl l nm nn">import "GasCost.sol"</span><span id="057f" class="nj la it nf b gy no nl l nm nn">contract GasAccountRolesSet is GasCost {<br/>    using StringLib for string;</span><span id="92d5" class="nj la it nf b gy no nl l nm nn">    uint constant ROLE1 = 0;<br/>    uint constant ROLE2 = 1;<br/>    uint constant ROLE3 = 2;</span><span id="a896" class="nj la it nf b gy no nl l nm nn">    address constant ACCOUNT1 = 0x1111111111...1111111111;<br/>    address constant ACCOUNT2 = 0x2222222222...2222222222;<br/>    address constant ACCOUNT3 = 0x3333333333...3333333333;</span><span id="8607" class="nj la it nf b gy no nl l nm nn">    BaseAccountRolesSet con;</span><span id="68e1" class="nj la it nf b gy no nl l nm nn">    function _create() private {<br/>        con = new BaseAccountRolesSet();<br/>    }<br/>    function create() public {<br/>        gasCostFun("constructor", _create);<br/>    }</span><span id="a3fd" class="nj la it nf b gy no nl l nm nn">    function gasCost(string memory name, address account, uint role)<br/>    internal {<br/>        uint u0 = gasleft();<br/>        con.addAccountRole(account, role);<br/>        uint u1 = gasleft();<br/>        name = name.concat(" add: ", (u0 - u1).niceDecimal());</span><span id="efda" class="nj la it nf b gy no nl l nm nn">        u0 = gasleft();<br/>        require(con.confirmAccountRole(account, role));<br/>        u1 = gasleft();<br/>        name = name.concat(" has: ", (u0 - u1).niceDecimal());<br/>        report(name);<br/>    }</span><span id="4249" class="nj la it nf b gy no nl l nm nn">    function add11() public {<br/>        gasCost("add11", ACCOUNT1, ROLE1);<br/>    }<br/>    <br/>    function add12() public {<br/>        gasCost("add12", ACCOUNT1, ROLE2);<br/>    }<br/>    <br/>    function add13() public {<br/>        gasCost("add13", ACCOUNT1, ROLE3);<br/>    }<br/>    <br/>    function add23() public {<br/>        gasCost("add23", ACCOUNT2, ROLE3);<br/>    }<br/>    <br/>    function add33() public {<br/>        gasCost("add33", ACCOUNT3, ROLE3);<br/>    }<br/>}</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="caad" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">燃气流量</h1><p id="50db" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在编写了智能合同解决方案和测试之后，我们使用作者在文章<a class="ae ky" href="https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678" rel="noopener">固体功能的气体成本</a>中描述的技术来测量气体消耗。</p><p id="24d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">编译器是伊斯坦布尔版本0.6.12。</p><h2 id="99d1" class="nj la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">创建合同和添加记录</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/fde971df7d0b7bd1859e81311f108049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xN6Y6UqDpP6jDkkvc46kyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用不同解决方案创建和添加帐户和角色的能耗</p></figure><p id="c9ea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从图中可以看出，特别是动态值数组，为了在处理动态值数组的库中创建额外的代码，消耗了大量的气体。</p><h2 id="ec6f" class="nj la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">添加记录</h2><p id="25ca" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设建造成本是不相关的(如果您的解决方案继续追加数据，它可能是不相关的)，示例操作的气体消耗为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/771e66a93ba1b64bf838de73fe689dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXPysQtj4PfnsCP-qfG9sg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用不同解决方案添加帐户和角色的气体消耗</p></figure><p id="2160" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">毫不奇怪，地图/地图解决方案消耗的汽油最多。这是因为新的存储槽用于为每个帐户添加每个角色。</p><p id="9656" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在为每个帐户分配第一个存储槽后，其他解决方案消耗的气体要少得多(蓝色、绿色和金色区块)。</p><h2 id="8b0b" class="nj la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">检查记录</h2><p id="8412" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">数据最可能的用途(在我们的解决方案中)是不断检查帐户是否有适当的角色来支持状态转换。</p><p id="c77e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是汽油消耗量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/c8dbb05487470f66ea618358ec8ca054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KdViQSX0drJRWU0OjW3zQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用不同解决方案的支票账户和角色的气体消耗</p></figure><p id="3e0e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">他们之间没什么可选择的。从map/map解决方案中读取比动态值数组消耗的气体少一些，检查机器字中的一个位比查找另一个存储槽消耗的气体少一些。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="0ff9" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">其他可能性</h1><p id="1fbc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以考虑使用userIDs和动态值数组来避免使用第一个映射，而不是使用帐户地址。但是这需要额外存储和检查帐户地址来确定用户标识。</p><p id="0daa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您的解决方案需要生成帐户地址，这是一种可行的可能性。</p><p id="25fe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者，您可以考虑折叠帐户地址，以便压缩它们，从而将几个帐户地址放入一个机器字中。这带来了账户冲突的极小可能性。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="a1ee" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">结论</h1><p id="a887" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Solidity出色的贴图功能非常高效。</p><p id="34df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是，如果关联数据包含的条目不超过256个，则可以通过使用映射到集合来改进映射到映射。</p></div></div>    
</body>
</html>