# 我们对设计模式的痴迷

> 原文：<https://betterprogramming.pub/our-over-obsession-with-patterns-1415437d75ec>

## 设计模式非常好用。然而，当过度使用时，它们会导致障碍

![](img/b7e4aa1b130e79383b6e3679baf611fe.png)

Andrew Ridley 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

学习模式已经成为许多人成为软件工程师过程中的一个核心方面。关于模式以及如何应用模式的文章不计其数。课程、YouTube 视频和 GitHub repos 都是为了帮助工程师掌握模式的力量而存在的。我自己甚至在之前写过关于模式的[。](https://bit.ly/3mzVuYW)

然而，作为一名高级工程师，我开始怀疑我们是否在模式上走错了方向。

我写的代码越多，我就越多地使用相同的模式，越少关心其他的模式。我没有记住它们，甚至没有一页书签来快速查找它们。我当然不会仅仅因为一本书或一篇文章中有某个模式就试图使用它。

我认为我们沉迷于软件模式——我不认为我们应该如此。

# 错误的方向

工程师痴迷于模式的原因之一是他们提供解决方案。这个想法是“如果我能学会每一种模式，那么我就能编写任何软件，解决任何问题。”这种想法有点像“如果我拥有世界上的一切，那么我会很快乐。”

可悲的是，两者都不是真的。

原因是方向不对。最好的软件工程师不会专注于记忆现有的解决方案。他们专注于尽可能以最好的方式解决新问题。世界上最幸福的人不是那些关注财富、金钱或财产的人。世界上最幸福的人是那些完全清楚自己喜欢什么，并且专注于此的人。

不要误解我，学习模式*是*有帮助的。了解它们会让你在众所周知的工具箱中有更多的工具，你可以在任何时候使用它们(稍后会有更多的工具)。但是仅仅因为你有一个强大的工具箱并不意味着你知道编写软件的技巧。

# 模式实际上很有局限性

模式可以在您的代码库中提供难以置信的灵活性和可发展性，但前提是您的代码库是正确的类型。当然，面向对象语言和静态类型语言在模式方面做得很好。函数式编程和动态类型语言往往不会从中受益太多。对于 Haskell、Lisp 甚至 Prolog 这样的语言来说尤其如此。

我提到这一点是因为大多数工程师可以用不止一种语言编程，项目中使用的语言类型是基于问题空间的。是的，您可以编写一个 Java 应用程序来发送一个简单的 HTTP 调用来设置测试数据。或者您可以编写一个 bash 脚本。在 bash 脚本中应用模式与在 Java 中不同。无论如何，你也不需要用模式来发送一个简单的 HTTP 请求。

如果你学习模式是因为你认为了解模式会神奇地帮助你用任何语言编写任何软件来解决任何问题，请三思。

# 模式是工具，而不是多重工具

虽然模式对于解决他们想要解决的问题是有用的，但是在问题实际存在之前应用它们*只会制造混乱。工程师们采用他们所学到的模式，并试图将它们应用到任何地方。他们把它们当作可以“解决任何问题”的多功能工具。*

你实际使用过多功能工具吗？它们体积庞大。它们真的很重。他们很少能完成当地户外商店服务员承诺的 2897 项功能。

另一方面，工具往往大不相同。他们有一个，也许两个他们设计用来解决的非常特殊的用例。你不会用螺丝刀钉钉子，也不会用打磨机把木板切成两半。即使使用套筒扳手这样的工具，也有不同的尺寸来满足不同的需求。

我们应该把模式看作工具。他们有专门设计来解决的特定使用案例。试图用它们来解决不同的问题不会解决任何问题。当正确使用时，它们会提高你实施你头脑中的解决方案的能力。如果不好好利用它们，你将会花费额外的时间与自己抗争。

# 模式会导致过度工程化——很快

你曾经在一个旧的，劣质的代码库中工作过吗？你知道我说的那些，类有 10，000 行长，函数有 7 个不同的布尔参数，一些评论说，“请不要碰这段代码！”

我有过，而且一点也不好玩。

但是你曾经在过度工程化的代码库中工作过吗？感觉真的很干净简洁。小类，小函数等。但这感觉像是一场障眼法游戏。劣质的代码库感觉就像试图解开一个巨大的电线结，过度设计的代码库感觉就像试图通过博览会上的一个有趣的房子——这都是烟雾和镜子，你不断地质疑什么是真实的。

模式的过度使用导致了这些过度工程化的代码库。即使正确的模式被用于正确的“问题”，更简单的代码也足够了。我非常喜欢先写简单的代码，因为我相信代码越简单，就越容易构建。

保持事情简单实际上并不容易。这需要不断的重构、思考和修补。如果使用不当，模式会很快变得复杂。

# 结论

我仍然是模式的忠实粉丝，并在适当的地方使用它们。这篇文章只是一个警告，模式不能解决你所有的编码问题——它们只能解决它们被设计来解决的问题。在应用它们之前要批判性地思考，并且总是从简单的开始。

编码快乐！

*原贴于*[*dango slen . me*](http://bit.ly/3q2w0DK)*。*