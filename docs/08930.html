<html>
<head>
<title>How Imports Work in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">导入如何在Python中工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-imports-work-in-python-59c2943d87dc?source=collection_archive---------1-----------------------#2021-06-28">https://betterprogramming.pub/how-imports-work-in-python-59c2943d87dc?source=collection_archive---------1-----------------------#2021-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cfb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于包裹</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aaa53ca7290efa4e36788d9ea0c5be54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rxVGJSt0aXc8CAZ0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@blancaplum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Blanca Paloma Sánchez </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python导入系统非常简单...在某种程度上。导入存在于您正在处理的同一目录中的代码与在存在于多个目录中的多个文件之间进行导入有很大不同。通过这篇文章，我分析了使用导入时经常遇到的一些场景，希望能让您更容易创建自己的包。</p><h1 id="9b0a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目录</h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c68e" class="ms lw it mo b gy mt mu l mv mw"><a class="ae ky" href="#36b9" rel="noopener ugc nofollow"><strong class="mo iu">An Example</strong></a><strong class="mo iu"><br/></strong><a class="ae ky" href="#d70d" rel="noopener ugc nofollow"><strong class="mo iu">What Happens When You Import a Python File?</strong></a><strong class="mo iu"><br/></strong><a class="ae ky" href="#037f" rel="noopener ugc nofollow"><strong class="mo iu">Terminology</strong></a><strong class="mo iu"><br/></strong><a class="ae ky" href="#3e54" rel="noopener ugc nofollow"><strong class="mo iu">Import Scenarios</strong></a><strong class="mo iu"><br/></strong><a class="ae ky" href="#d440" rel="noopener ugc nofollow"><strong class="mo iu">Analysis</strong></a><strong class="mo iu"><br/></strong><a class="ae ky" href="#2591" rel="noopener ugc nofollow"><strong class="mo iu">Building a Package</strong></a><strong class="mo iu"><br/></strong><a class="ae ky" href="#6939" rel="noopener ugc nofollow"><strong class="mo iu">The Syntax of Your Import Statement</strong></a><strong class="mo iu"><br/></strong><a class="ae ky" href="#94a3" rel="noopener ugc nofollow"><strong class="mo iu">Notes and Resources</strong></a></span></pre></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="36b9" class="lv lw it bd lx ly ne ma mb mc nf me mf jz ng ka mh kc nh kd mj kf ni kg ml mm bi translated">一个例子</h1><p id="4eec" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们将从一个简单的例子开始，并在整篇文章中建立起来。假设我们在一个名为<code class="fe no np nq mo b">PythonImportExample</code>的目录中有两个简单的Python文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/694239839b009b382e5a772e080fe6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtbSFaWWKRzobdAUy1WD9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的例子——作者使用<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a></p></figure><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="df7c" class="ms lw it mo b gy mt mu l mv mw">PythonImportExample/</span><span id="6ac9" class="ms lw it mo b gy ns mu l mv mw">    file1.py<br/>    file2.py</span></pre><p id="f200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<code class="fe no np nq mo b">file1.py</code>包含以下内容:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="346e" class="ms lw it mo b gy mt mu l mv mw">print("This is file1.py")</span></pre><p id="330c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq mo b">file2.py</code>进口<code class="fe no np nq mo b">file1.py</code>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2a5d" class="ms lw it mo b gy mt mu l mv mw">import file1</span><span id="322d" class="ms lw it mo b gy ns mu l mv mw">print("This is file2.py")</span></pre><p id="5c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入类似于以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/78fb18058d3992aa2c9112b82ebc6690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGEUIdbEWQpf5rLS8BWkVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件1.py导入到文件2 . py-作者使用<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a></p></figure><h1 id="d70d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">导入Python文件时会发生什么？</h1><p id="633c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">当Python文件被导入时，它被执行，然后被添加到导入它的文件的命名空间中。</p><p id="8fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:执行<code class="fe no np nq mo b">file2.py</code>时，得到如下输出:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="69fa" class="ms lw it mo b gy mt mu l mv mw">$ cd PythonImportExample<br/>$ python file2.py</span><span id="7f27" class="ms lw it mo b gy ns mu l mv mw">This is file1.py<br/>This is file2.py</span></pre><p id="111c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入的文件在其导入前立即执行。因此，如果我们将<code class="fe no np nq mo b">file2.py</code>中的导入语句放在打印语句下面，如下所示:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e353" class="ms lw it mo b gy mt mu l mv mw">print("This is file2.py")</span><span id="4f7b" class="ms lw it mo b gy ns mu l mv mw">import file1</span></pre><p id="4861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终得到了交换的输出:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="32d8" class="ms lw it mo b gy mt mu l mv mw">This is file2.py<br/>This is file1.py</span></pre><p id="21b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，导入Python模块(甚至是包，我们会用到)的整个过程要复杂一些。<strong class="lb iu">对模块的搜索如下:</strong></p><ol class=""><li id="b0d3" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">Python标准库中的内置模块。</li><li id="0c42" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe no np nq mo b">sys.path</code>目录和文件。</li></ol><p id="c5bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe no np nq mo b">PYTHONPATH</code>目录。</p><p id="a0d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.不属于标准库的模块和包</p><p id="9483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">一旦找到模块或包</strong>就执行。如果是一个模块，该模块将运行。如果是包，则运行该包的<code class="fe no np nq mo b">__init__.py</code>文件。</p><p id="5e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">然后，导入的项目被添加到该模块的名称空间中，</strong>允许您导入它并使用它的属性。</p><p id="86b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq mo b">sys.path</code>的第一个元素有微小的区别。如果我们交互式地启动解释器，第一个元素是<code class="fe no np nq mo b">''</code>。它表示解释器启动的当前目录。</p><p id="a7b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要运行一个脚本，<code class="fe no np nq mo b">sys.path</code>将包含脚本的目录作为它的第一个元素，而不是<code class="fe no np nq mo b">''</code>。</p><p id="036a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先来看一点术语。</p><h1 id="037f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">术语</h1><p id="02ac" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">一个基本的Python包可以包含子包、模块、初始化文件和一个<code class="fe no np nq mo b">setup.py</code>文件。基本的包结构可能如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/2de7aa65ce1e3b67bc7d35106aab1981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0F-jRxouP7Wwy7FUlIFXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个基本的包结构，展示了所有必要的组件——作者使用<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a></p></figure><h2 id="4135" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">组件</h2><p id="9504" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Python文档对模块做了如下描述:</p><blockquote class="ou ov ow"><p id="3bf5" class="kz la ox lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated">模块是包含Python定义和语句的文件。文件名是模块名加上后缀<code class="fe no np nq mo b">.py</code>。</p></blockquote><p id="9bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模块是鼓励模块化代码的对象。一个模块可以包含变量、函数和类，这些组件是该模块定义的命名空间的一部分。</p><p id="bee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个事实，命名问题不是一个问题，因为两个不同的模块可以有相同名称的变量、函数和类。</p><h2 id="91b5" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">包裹</h2><p id="fd50" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">包是模块和包的层次结构。就像一个模块如何定义一个名称空间以便变量、函数和类可以在两个不同的模块中有相同的名称一样，一个包对它的组成包和模块也是如此。</p><p id="3512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主包中的模块和包可以通过点符号来访问。</p><h2 id="7e28" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">__init__。巴拉圭</h2><p id="ffc4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe no np nq mo b">__init__.py</code>是放在包和子包中的文件。在Python 3.3之前，这个文件必须出现在每个包和子包中，尽管现在不再是这样了。</p><p id="c4a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个包被导入时，它的<code class="fe no np nq mo b">__init__.py</code>文件，如果存在的话，被执行。这个事实可以用于很多事情，比如导入特定的包。</p><h2 id="7709" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">setup.py</h2><p id="65c5" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">该文件位于您的包所在的主目录中。它包含配置信息，如所需的依赖项、脚本和子程序包。您还可以指定关于您的包的元数据，比如包的名称、作者、描述等等。</p><p id="c002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件是pip (Python的标准包管理器)用来安装包的。它位于项目的主目录中，与您的包代码放在一起。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="347c" class="ms lw it mo b gy mt mu l mv mw">ProjectDir<br/>   <strong class="mo iu">setup.py</strong><br/>   package/<br/>       ..<br/>       .</span></pre><h2 id="ff4b" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">sys.path</h2><p id="d016" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe no np nq mo b">sys.path</code>是字符串形式的路径列表。当解释器看到导入语句时，它会在<code class="fe no np nq mo b">sys.path</code>中的路径中寻找要导入的模块或包。</p><p id="0d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们已经讨论过的,<code class="fe no np nq mo b">sys.path</code>列表的第一个元素是:</p><ul class=""><li id="ca3d" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated"><code class="fe no np nq mo b">''</code>如果我们交互运行解释器</li><li id="34bc" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated">脚本的路径，如果我们运行它。</li></ul><p id="9787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件表明<code class="fe no np nq mo b">sys.path</code>是:</p><blockquote class="ou ov ow"><p id="1f18" class="kz la ox lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated">" I <!-- -->由环境变量<code class="fe no np nq mo b"><a class="ae ky" href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" rel="noopener ugc nofollow" target="_blank">PYTHONPATH</a></code>初始化，加上一个依赖于安装的默认值."</p></blockquote><p id="3687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">某些属性</strong></p><ul class=""><li id="c146" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated"><code class="fe no np nq mo b">sys.path</code>不依赖于我们当前的目录，只是我们正在运行的脚本的路径。</li><li id="ec0a" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated">它不会在导入的模块之间改变。如果一个模块导入另一个模块，后者又导入另一个模块，那么第一个模块的<code class="fe no np nq mo b">sys.path</code>就是解释器搜索第二个导入语句的地方。</li></ul><h1 id="3e54" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">导入方案</h1><p id="c0ed" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们考虑一下在构建目录中的导入时可能会遇到的一些场景。在每个场景中，我们将从一个基本的案例开始，如果它没有给我们预期的结果，就对它进行改进。</p><p id="c26a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将讨论:</p><ul class=""><li id="94c1" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated">在同一子包中导入</li><li id="8d09" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated">在同一包中但在不同的子包中导入</li><li id="41fc" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated">在项目层次结构的不同级别之间导入</li></ul><h2 id="7eae" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">在同一子包中导入</h2><p id="8285" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们在主目录中添加一个名为<code class="fe no np nq mo b">subpackage1</code>的子目录。请注意，我们没有调用这些包和子包，因为此时它们只是目录。</p><p id="215d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来添加两个子模块<code class="fe no np nq mo b">file3.py</code>和<code class="fe no np nq mo b">file4.py</code>。同样，<code class="fe no np nq mo b">file4.py</code> imports <code class="fe no np nq mo b">file3.py.</code>我们以下面的结构结束:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="70fb" class="ms lw it mo b gy mt mu l mv mw">PythonImportExample/</span><span id="e3a1" class="ms lw it mo b gy ns mu l mv mw">    file1.py<br/>    file2.py</span><span id="52c5" class="ms lw it mo b gy ns mu l mv mw">    subpackage1/<br/>        file3.py<br/>        file4.py</span></pre><p id="125c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个文件如下所示:</p><p id="4d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq mo b"><strong class="lb iu">file3.py</strong></code></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="0fdf" class="ms lw it mo b gy mt mu l mv mw">print("This is file3.py")</span></pre><p id="b999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq mo b"><strong class="lb iu">file4.py</strong></code></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="778b" class="ms lw it mo b gy mt mu l mv mw">import file3</span><span id="af4a" class="ms lw it mo b gy ns mu l mv mw">print("This is file4.py")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/b68faab5c477a17378b82e27a8e98d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vaZ2GxWFIZzeC7Dg9VjCcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">场景#1:在同一个子包中导入。将file3.py导入file4.py</p></figure><p id="6ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们运行<code class="fe no np nq mo b">file4.py</code>时，解释器寻找<code class="fe no np nq mo b">file3.py</code>。由于它们出现在同一个目录中，<code class="fe no np nq mo b">file3.py</code>很容易找到，因为模块的目录是<code class="fe no np nq mo b">sys.path</code>中的第一个条目。</p><p id="a3f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个包在这里不是必须的，但是我们将在后面看到如何做。</p><h2 id="a9ca" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">在同一包但不同的子包中导入</h2><p id="b986" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">假设我们向我们的项目添加了另一个子包。我们将它命名为<code class="fe no np nq mo b">subpackage2</code>，在它里面，我们将有<code class="fe no np nq mo b">file5.py</code>和<code class="fe no np nq mo b">file6.py</code>。现在，如果其中一个文件导入了另一个文件，我们在执行时不会有任何问题，因为这基本上就是前面的场景。</p><p id="8b36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们想要导入一个不同子包中的文件，比如说，<code class="fe no np nq mo b">file5.py</code>导入<code class="fe no np nq mo b">file3.py</code>，该怎么办呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/7f7067f6665f1bb2d56fe7716bac276c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIa1pMwiJh6ZImI2_PUBww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">场景#2:在同一个包但不同的子包中导入。file3.py被导入file 5 . py——作者使用<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a></p></figure><p id="6527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们项目的结构目前是这样的:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="7ae7" class="ms lw it mo b gy mt mu l mv mw">PythonImportExample/</span><span id="82eb" class="ms lw it mo b gy ns mu l mv mw">    file1.py<br/>    file2.py</span><span id="b82a" class="ms lw it mo b gy ns mu l mv mw">    subpackage1/<br/>        <strong class="mo iu">file3.py</strong><br/>        file4.py</span><span id="fbfd" class="ms lw it mo b gy ns mu l mv mw">    subpackage2/<br/>        <strong class="mo iu">file5.py</strong><br/>        file6.py</span></pre><p id="bc48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq mo b"><strong class="lb iu">file5.py</strong></code></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="ece6" class="ms lw it mo b gy mt mu l mv mw">import subpackage1.file3</span><span id="1c95" class="ms lw it mo b gy ns mu l mv mw">print("This is file5.py")</span></pre><p id="3dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe no np nq mo b">file5.py</code>直接导入<code class="fe no np nq mo b">file3.py</code>，我们最终会得到什么？很明显这将是一辆T8。<code class="fe no np nq mo b">file5.py</code>的sys.path将包含其目录——即<code class="fe no np nq mo b">subpackage2</code>——当导入时，将找不到<code class="fe no np nq mo b">subpackage1</code>,从而给出错误。</p><p id="5497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将我们所有的代码放入一个包中可以解决这个问题，但是还有其他方法吗？</p><p id="f4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您思考最初是什么导致了导入错误时，这是显而易见的:<code class="fe no np nq mo b">sys.path</code>。因此，如果我们可以动态地改变这一点，从技术上来说，从任何地方运行一个导入文件的脚本都是可能的。</p><p id="53f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq mo b"><strong class="lb iu">file5.py</strong></code></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="5be4" class="ms lw it mo b gy mt mu l mv mw">import sys</span><span id="d7e9" class="ms lw it mo b gy ns mu l mv mw">print(sys.path)</span><span id="2280" class="ms lw it mo b gy ns mu l mv mw">sys.path.insert(1, "/Users/test_user/Documents/PythonImportExample/subpackage1")</span><span id="e70a" class="ms lw it mo b gy ns mu l mv mw">print(sys.path)</span><span id="9832" class="ms lw it mo b gy ns mu l mv mw">import file3</span><span id="c496" class="ms lw it mo b gy ns mu l mv mw">print("This is file5.py")</span></pre><p id="3fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe no np nq mo b">file5.py</code>现在工作正常。输出如下所示:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="29e1" class="ms lw it mo b gy mt mu l mv mw">['/Users/test_user/Documents/PythonImportExample/subpackage2', ...</span><span id="3c65" class="ms lw it mo b gy ns mu l mv mw">['/Users/test_user/Documents/PythonImportExample/subpackage2', <strong class="mo iu">'/Users/test_user/Documents/PythonImportExample/subpackage1'</strong>,....</span><span id="f7f0" class="ms lw it mo b gy ns mu l mv mw">This is file3.py<br/>This is file5.py</span></pre><p id="7f08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看到上面<code class="fe no np nq mo b">sys.path</code>加了<code class="fe no np nq mo b">subpackage1</code>。</p><h2 id="f448" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">在项目层次结构的不同级别之间导入</h2><p id="07cd" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们再看看我们目前的结构。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="9ac4" class="ms lw it mo b gy mt mu l mv mw">PythonImportExample/</span><span id="d39d" class="ms lw it mo b gy ns mu l mv mw">    file1.py<br/>    <strong class="mo iu">file2.py</strong></span><span id="0a42" class="ms lw it mo b gy ns mu l mv mw">    subpackage1/<br/>        file3.py<br/>        file4.py</span><span id="e407" class="ms lw it mo b gy ns mu l mv mw">    subpackage2/<br/>        file5.py<br/>        <strong class="mo iu">file6.py</strong></span></pre><p id="8254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在这里看两个场景:</p><ul class=""><li id="c686" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated"><code class="fe no np nq mo b">file2.py</code>导入<code class="fe no np nq mo b">file6.py</code></li><li id="ba70" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated">反之亦然(<code class="fe no np nq mo b">file6.py</code>导入<code class="fe no np nq mo b">file2.py</code>)</li></ul><p id="f6b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">案例一:</strong> <code class="fe no np nq mo b"><strong class="lb iu">file2.py</strong></code> <strong class="lb iu">导入</strong> <code class="fe no np nq mo b"><strong class="lb iu">file6.py</strong></code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/ebacfaee584bdc94387756358cbfeee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8ycJEXgbomzZpY4A8NcAA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">场景3案例1:将更深的模块导入到更高的模块中。file6.py被导入到file2.py中</p></figure><p id="2a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们修改<code class="fe no np nq mo b">file2.py</code>以便它导入<code class="fe no np nq mo b">file6.py</code>。现在看起来是这样的。</p><p id="5084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq mo b"><strong class="lb iu">file2.py</strong></code></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c1a2" class="ms lw it mo b gy mt mu l mv mw">import file1</span><span id="fbbb" class="ms lw it mo b gy ns mu l mv mw">print("This is file2.py")</span><span id="9283" class="ms lw it mo b gy ns mu l mv mw"># added code<strong class="mo iu"><br/>import subpackage2.file6</strong></span></pre><p id="3fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="91bf" class="ms lw it mo b gy mt mu l mv mw">This is file1.py<br/>This is file2.py<br/><strong class="mo iu">This is file6.py</strong></span></pre><p id="4164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出符合预期。<code class="fe no np nq mo b">file1.py</code>和以前一样导入成功。到了第二个导入语句，解释器在<code class="fe no np nq mo b">sys.path</code>中寻找<code class="fe no np nq mo b">subpackage2</code>。它会被立即找到，因为<code class="fe no np nq mo b">subpackage2</code>与我们的脚本<code class="fe no np nq mo b">file2.py</code>位于同一个目录中，所以相应的条目已经存在于<code class="fe no np nq mo b">sys.path</code>中。很简单。</p><p id="1e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">案例二:</strong> <code class="fe no np nq mo b"><strong class="lb iu">file6.py</strong></code> <strong class="lb iu">导入</strong> <code class="fe no np nq mo b"><strong class="lb iu">file2.py</strong></code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/881cf26df7394aa38ed320f2948d5561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCui05YfLwuP3vV18dx0vw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">场景#3案例2:将较高级别的模块导入到较深的模块中。file2.py被导入到file6.py中</p></figure><p id="9bad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与前一种情况正好相反。像我们在<strong class="lb iu">案例1 </strong>中那样的直接导入是行不通的，因为<code class="fe no np nq mo b">file2.py</code>不在<code class="fe no np nq mo b">file6.py</code>的<code class="fe no np nq mo b">sys.path</code>上。我们要么为此创建一个包，要么在运行时自己修改<code class="fe no np nq mo b">sys.path</code>，就像我们在前面的场景中所做的那样。</p><p id="3add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:这是Python导入系统的一个问题。如果不修改<code class="fe no np nq mo b">sys.path</code>或<code class="fe no np nq mo b">PYTHONPATH</code>，就无法导入当前脚本父目录中的模块。</p><h1 id="d440" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">分析这些情景</h1><p id="3c44" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在尝试解决遇到的导入错误时，我们做了一些决定。我们的决定通常是关于动态修改<code class="fe no np nq mo b">sys.path</code>。创建一个包也是一个建议。</p><h2 id="9192" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">有必要建包吗？</h2><p id="700c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">难道仅仅创建一个目录和模块的层次结构不行吗？</p><p id="e1d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不完全是。</p><p id="2e9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些简单的情况可能不需要创建包就可以工作，但是更复杂的情况会很快遇到类似于我们在上面场景中讨论的问题。</p><p id="4b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建包有几个好处:</strong></p><ul class=""><li id="5713" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated">更好的结构和组织</li><li id="0576" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated">导入错误和命名冲突等问题减少</li><li id="175f" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated">更容易共享代码。</li></ul><h1 id="2591" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将我们的项目变成一个包</h1><p id="0bb4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们将按照下面的步骤来制作一个非常基本的包。</p><ol class=""><li id="26b9" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">将我们当前的项目移动到一个目录中，这个目录将作为我们的主包。</li><li id="5030" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">在每个包和子包中添加空白<code class="fe no np nq mo b">__init__.py</code>并修复导入</li><li id="bfa8" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">添加一个<code class="fe no np nq mo b">setup.py</code>文件。我们稍后会讨论这个问题。</li></ol><h2 id="7d18" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">修改我们的项目结构并添加__init__。py文件</h2><p id="4650" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这一步很简单。我们将我们的<code class="fe no np nq mo b">python_import_example</code>包移动到另一个目录<code class="fe no np nq mo b">PythonImportExampleProject</code>中，该目录将包含配置相关信息，如<code class="fe no np nq mo b">.gitignore</code>、<code class="fe no np nq mo b">LICENCE</code>、<code class="fe no np nq mo b">setup.py</code>等，以及我们的包。</p><p id="bc7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还在每个包和子包中添加了<code class="fe no np nq mo b">__init__.py</code>文件。因为我们有一个主包(<code class="fe no np nq mo b">python_import_example</code>)和两个子包，<strong class="lb iu">，我们最终有三个初始化文件</strong>。</p><p id="d0c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步，我们将讨论我们的包的安装文件。我将它包含在下面的树中，以了解<code class="fe no np nq mo b">setup.py</code>的确切走向。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8639" class="ms lw it mo b gy mt mu l mv mw">PythonImportExampleProject/<br/>    <strong class="mo iu">setup.py<br/>    <br/>    config related files (gitignore, LICENCE, etc.)</strong></span><span id="7993" class="ms lw it mo b gy ns mu l mv mw">    pythonimportexample/<br/>       <strong class="mo iu"> __init__.py</strong></span><span id="4f5d" class="ms lw it mo b gy ns mu l mv mw">        file1.py<br/>        file2.py</span><span id="31ee" class="ms lw it mo b gy ns mu l mv mw">        subpackage1/<br/>            <strong class="mo iu">__init__.py</strong></span><span id="b69a" class="ms lw it mo b gy ns mu l mv mw">            file3.py<br/>            file4.py</span><span id="fb1f" class="ms lw it mo b gy ns mu l mv mw">        subpackage2/<br/>            <strong class="mo iu">__init__.py</strong></span><span id="be7a" class="ms lw it mo b gy ns mu l mv mw">            file5.py<br/>            file6.py</span></pre><p id="783e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图表中会是这样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/0864f3e07a754b46ae4462004c0ab236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQOKj1SS5LK5w53d7Dnc8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的项目，被构造成一个包——作者使用<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a></p></figure><h2 id="0d77" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">添加安装文件</h2><p id="ae26" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们添加一个简单的安装文件。我们现在只设置名称，尽管您可以做更多的工作。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="f50b" class="ms lw it mo b gy mt mu l mv mw"><strong class="mo iu">from</strong> setuptools <strong class="mo iu">import</strong> find_packages, setup<br/></span><span id="6e9d" class="ms lw it mo b gy ns mu l mv mw">setup(</span><span id="5ae6" class="ms lw it mo b gy ns mu l mv mw">    name='pythonimportexample',<br/>    packages=find_packages(),</span><span id="6d06" class="ms lw it mo b gy ns mu l mv mw">)</span></pre><p id="e491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"/><code class="fe no np nq mo b"><strong class="lb iu">find_packages</strong></code><strong class="lb iu">函数返回我们项目中所有的包和子包。这很有用，因为我们不必自己列出它们。</strong></p><h1 id="6939" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">导入语句的语法</h1><p id="ee8a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">有几种不同的方法可以组织您的导入。一些例子:</p><ul class=""><li id="7491" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated"><code class="fe no np nq mo b">import abc.def.xyz</code></li><li id="6f53" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated"><code class="fe no np nq mo b">from abc.def import xyz</code></li><li id="034f" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated"><code class="fe no np nq mo b">from ..abc import pqr</code></li><li id="48e0" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated"><code class="fe no np nq mo b">import abc.def as mymodule</code></li></ul><p id="472c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到我们的例子。我们来看看<code class="fe no np nq mo b">file5.py</code>和<code class="fe no np nq mo b">file3.py</code>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6b71" class="ms lw it mo b gy mt mu l mv mw">PythonImportExample/</span><span id="1d23" class="ms lw it mo b gy ns mu l mv mw">    file1.py<br/>    file2.py</span><span id="5593" class="ms lw it mo b gy ns mu l mv mw">    subpackage1/<br/>        <strong class="mo iu">file3.py</strong><br/>        file4.py</span><span id="9cc6" class="ms lw it mo b gy ns mu l mv mw">    subpackage2/<br/>     <strong class="mo iu">   file5.py</strong><br/>        file6.py</span></pre><h2 id="59c1" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated"><strong class="ak">绝对进口</strong></h2><p id="6f08" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">绝对导入允许您指定要导入的包、模块或对象的完整路径。</p><p id="bdcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想将<code class="fe no np nq mo b">file5.py</code>导入到<code class="fe no np nq mo b">file3.py</code>中，您可以使用以下语句:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="ee4b" class="ms lw it mo b gy mt mu l mv mw">import PythonImportExample.subpackage2.file5</span></pre><p id="4baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6124" class="ms lw it mo b gy mt mu l mv mw">from PythonImportExample.subpackage2 import file5</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/f7e98f8220ae8a2eb88d6b0de78e5370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w846vcgXc8iSN6RmJvI0Zg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绝对导入明确地指定了模块的路径——由作者使用<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a></p></figure><p id="8761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优点</strong></p><ul class=""><li id="d57f" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated"><strong class="lb iu">绝对导入提高可读性。</strong>看上面的语句，很明显<code class="fe no np nq mo b">file5.py</code>驻留在<code class="fe no np nq mo b">PythonImportExample</code>的<code class="fe no np nq mo b">subpackage2</code>中。</li><li id="07d7" class="nu nv it lb b lc od lf oe li of lm og lq oh lu pb oa ob oc bi translated">不管你的脚本在哪里，它们都可以工作。即使上述导入语句被放入<code class="fe no np nq mo b">file1.py</code>，它位于主包中。</li></ul><p id="e455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">缺点</strong></p><ul class=""><li id="9336" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated"><strong class="lb iu">绝对进口变长，变快。</strong>想象一下从嵌套的四层子包系列中导入一个类。<code class="fe no np nq mo b">from package.subpackage1.subpackage2.subpackage3.... import TestClass</code></li></ul><h2 id="923b" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">相对进口</h2><p id="773b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">相对导入相对于您要导入的脚本起作用。它使用点“.”符号。</p><p id="0f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例中，使用相对方法的import语句看起来类似于:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c1ca" class="ms lw it mo b gy mt mu l mv mw">import ..subpackage2.file5</span></pre><p id="e5a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="39c8" class="ms lw it mo b gy mt mu l mv mw">from ..subpackage2 import file5</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/0dc5ba5a12596e6fd9fe64793cdf4e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UsErRoAGRsDGpBkwLEnUiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相对进口是..良好的..相对于您的脚本—作者使用<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a></p></figure><p id="5fd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优点</strong></p><ul class=""><li id="13af" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated"><strong class="lb iu">它们简洁，不像绝对进口那么长。由于我们不需要指定导入内容的完整路径，所以在我们的包层次结构中的文件之间获取内容更加简单。</strong></li></ul><p id="4034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">缺点</strong></p><ul class=""><li id="5352" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu pb oa ob oc bi translated">当执行脚本的位置改变时，它们将不起作用。由于该语句是关于我们的执行脚本的，所以我们文件位置的任何变化都会破坏我们的代码，因为它相对于我们想要导入的文件的位置发生了变化。</li></ul></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="94a3" class="lv lw it bd lx ly ne ma mb mc nf me mf jz ng ka mh kc nh kd mj kf ni kg ml mm bi translated">注释和资源</h1><h2 id="070a" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">注意#1:是一个__init__。py文件有必要吗？如果是的话，你在里面放了什么？</h2><p id="e4ed" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><strong class="lb iu">关于第一部分</strong>，嗯是……也不是。从Python3.3开始，有两种包:常规的和隐式的名称空间包。前一种需要<code class="fe no np nq mo b">__init__.py</code>文件，后一种不需要。</p><p id="a1dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于几乎所有的用例，只需要常规类型的包。名称空间包在真正特殊的情况下会很方便，比如当不同位置的多个包向您的包提供模块时。</p><p id="039f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，无论如何包含init文件是个好主意，因为测试像<code class="fe no np nq mo b">pytest</code>这样的库可能会产生意想不到的结果。</p><p id="1363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入问题的第二部分，让你的<code class="fe no np nq mo b">init</code>文件为空完全没问题。但是对于更高级的情况，您可以在那里指定import语句和代码，这样更容易使用您的包。</p><h2 id="1703" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">注意# 2:pip install-e做什么？</h2><p id="9e9d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这个命令让你在<code class="fe no np nq mo b">development mode.</code>中构建和安装你的包，这意味着如果你对你的包做了修改，你不需要重新构建你的包来反映这些修改。</p><p id="4932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用它，只需执行:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c49a" class="ms lw it mo b gy mt mu l mv mw">pip install -e &lt;path to your package&gt;</span></pre><h2 id="c2ab" class="ms lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">注意# 3:python file . py vs python-m file . py？</h2><p id="584e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">模块既可以作为脚本运行，也可以作为导入的模块运行。当我们指定一个模块的路径时，我们把它作为一个脚本来运行。</p><p id="4a2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="b2b4" class="ms lw it mo b gy mt mu l mv mw">PythonImportExample/</span><span id="3bed" class="ms lw it mo b gy ns mu l mv mw">    file1.py<br/>    <strong class="mo iu">file2.py</strong></span><span id="3f09" class="ms lw it mo b gy ns mu l mv mw">    subpackage1/<br/>        file3.py<br/>        file4.py</span><span id="1303" class="ms lw it mo b gy ns mu l mv mw">    subpackage2/<br/>        file5.py<br/>        <strong class="mo iu">file6.py</strong></span></pre><p id="d149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将<code class="fe no np nq mo b">file6.py</code>导入到<code class="fe no np nq mo b">file2.py</code>中，并将其执行为:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8c61" class="ms lw it mo b gy mt mu l mv mw">$ python subpackage2/file6.py</span></pre><p id="2287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe no np nq mo b">file6.py</code>作为脚本执行，将<code class="fe no np nq mo b">file2.py</code>作为导入的模块执行。简单地说，要将模块作为脚本执行，我们需要指定该模块的完整路径。如果我们想在包的深处执行一些东西，这可能会很棘手。</p><p id="5e1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们可以使用<code class="fe no np nq mo b">-m</code>标志运行一个模块。如果我们把我们的例子作为一个包，</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="473c" class="ms lw it mo b gy mt mu l mv mw">PythonImportExample/<br/>    python_import_example/</span><span id="c6ec" class="ms lw it mo b gy ns mu l mv mw">        file1.py<br/>        <strong class="mo iu">file2.py</strong></span><span id="4f9b" class="ms lw it mo b gy ns mu l mv mw">        subpackage1/<br/>            file3.py<br/>            file4.py</span><span id="8a80" class="ms lw it mo b gy ns mu l mv mw">        subpackage2/<br/>            file5.py<br/>            <strong class="mo iu">file6.py</strong></span></pre><p id="c66e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像这样运行<code class="fe no np nq mo b">file6.py</code>:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="9305" class="ms lw it mo b gy mt mu l mv mw">$ python -m python_import_example.subpackage2.file6</span></pre><p id="21b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，因为我们是将文件作为模块运行的，所以我们不会在最后指定<code class="fe no np nq mo b">.py</code>文件扩展名。</p><h1 id="2e47" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">代码</h1><p id="9257" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">你会发现我们在GitHub上创建的整个包。</p><div class="pj pk gp gr pl pm"><a href="https://github.com/Polaris000/BlogCode/tree/main/PythonImportExample" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">Polaris 000/blog code/python import示例</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">本文中创建的示例包可以在这里找到。</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">github.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa ks pm"/></div></div></a></div></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="044b" class="lv lw it bd lx ly ne ma mb mc nf me mf jz ng ka mh kc nh kd mj kf ni kg ml mm bi translated">结论</h1><p id="297d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">包是使用Python的重要组成部分。无论您是使用别人的代码还是共享自己的代码，理解导入和包是如何工作的都是关键。</p><p id="34f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能帮助你避免将来的导入错误</p><p id="89dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该帮助您避免那些烦人的导入错误，更重要的是，让您成为更好的Python开发人员。</p></div></div>    
</body>
</html>