<html>
<head>
<title>That Time I Optimized a Program by 5000x</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">那次我优化了一个程序5000倍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/that-time-i-optimized-a-program-by-5000x-155cb8cfd9f9?source=collection_archive---------7-----------------------#2022-01-11">https://betterprogramming.pub/that-time-i-optimized-a-program-by-5000x-155cb8cfd9f9?source=collection_archive---------7-----------------------#2022-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f0d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">TL；DR I使用我们的Scalene profiler和一些数学方法使一个示例程序运行速度提高了5000倍。</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/ec2e812134e1f6c0730d1ecedb887319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zHET74-MEOGHJ9Wt.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">不规则体:<a class="ae kw" href="https://github.com/emeryberger/scalene/" rel="noopener ugc nofollow" target="_blank">https://github.com/plasma-umass/scalene/</a>，<code class="fe kx ky kz la b">pip install scalene</code></p></figure><p id="f25a" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">我对Python性能非常感兴趣，所以我读了这篇文章——<a class="ae kw" href="https://martinheinz.dev/blog/64" rel="noopener ugc nofollow" target="_blank">https://martinheinz.dev/blog/64</a>，标题是<em class="lx">剖析和分析Python程序的性能</em>。它展示了一个示例程序(来自<a class="ae kw" href="https://docs.python.org/3/library/decimal.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/decimal.html</a>)并展示了如何使用几个过时的Python分析器来运行它。不幸的是，它没有带来多少可操作的信息，除了或多或少的“尝试<a class="ae kw" href="https://www.pypy.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lx"> PyPy </em> </a>”之外，这将代码速度提高了大约2倍。我想知道我是否能够从Scalene(一个我参与编写的分析器)那里获得更多有用的信息。</p><p id="5c81" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">我们开发的Scalene比现有的Python分析器有用得多:它提供<em class="lx">行级</em>信息，从本地时间中分离出Python，分析内存使用、GPU，甚至复制成本，所有这些都在一个行的粒度上。</p><p id="3512" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">无论如何，下面是在示例代码上运行Scalene(只是使用CPU配置)的结果。真是开门见山。</p><pre class="kh ki kj kk gt ly la lz ma aw mb bi"><span id="de88" class="mc md iq la b gy me mf l mg mh">% scalene --cpu-only --cli --reduced-profile test/test-martinheinz.py</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mi"><img src="../Images/60226ce84244d75a4f52c766a4463362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4W0EFWKKiGhfihXtU_Tqw.png"/></div></div></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="3d18" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">您可以看到，几乎所有的执行时间都花在了计算<code class="fe kx ky kz la b">num</code>和<code class="fe kx ky kz la b">fact</code>之间的比率上，所以这确实是唯一可以集中精力进行优化的地方。运行本机代码花费了大量时间，这意味着这一行正在幕后执行一些C库。</p><p id="adb8" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">原来是在分两个<code class="fe kx ky kz la b">Decimal</code>(又名<a class="ae kw" href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" rel="noopener ugc nofollow" target="_blank"> bignums </a>)。底层的bignum库是用C代码编写的，速度非常快，但是特别是阶乘变得越来越快。在其中一个输入示例中，<code class="fe kx ky kz la b">fact</code>的最终值有11000位长！毫不奇怪:对如此庞大的数字做数学运算是昂贵的。让我们看看我们能做些什么来减少这些数字。</p><p id="e3c9" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">我注意到我们可以不从头开始计算<code class="fe kx ky kz la b">num / fact</code>,而是递增地计算:通过对非常小的数字进行计算，在每次循环迭代中更新一个变量。为此，我添加了一个新的变量<code class="fe kx ky kz la b">nf</code>，它总是等于比率<code class="fe kx ky kz la b">num / fact</code>。然后，在每次循环迭代中，程序通过将<code class="fe kx ky kz la b">nf</code>乘以<code class="fe kx ky kz la b">x / i</code>来更新<code class="fe kx ky kz la b">nf</code>。您可以通过观察以下内容来验证这保持了不变量<code class="fe kx ky kz la b">nf == num/fact</code>(其中<code class="fe kx ky kz la b">_new</code>表示每次迭代中更新变量的计算)。</p><pre class="kh ki kj kk gt ly la lz ma aw mb bi"><span id="1fef" class="mc md iq la b gy me mf l mg mh">nf == num / fact                  <strong class="la ir"># true by induction</strong><br/>nf_new == nf * (x / i)            <strong class="la ir"># we multiply by x/i each time</strong><br/>nf_new == (num / fact) * (x / i)  <strong class="la ir"># definition of nf</strong><br/>nf_new == (num * x) / (fact * i)  <strong class="la ir"># re-arranging</strong><br/>nf_new == num_new / fact_new      <strong class="la ir"># simplifying</strong></span></pre><p id="fc46" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">将它合并到原始程序中需要修改三行代码，所有代码后面都跟有<code class="fe kx ky kz la b">###</code>:</p><pre class="kh ki kj kk gt ly la lz ma aw mb bi"><span id="1833" class="mc md iq la b gy me mf l mg mh">def exp_opt(x):<br/>  getcontext().prec += 2<br/>  i, lasts, s, fact, num = 0, 0, 1, 1, 1<br/>  nf = Decimal(1)   <strong class="la ir">### was: = num / fact</strong><br/>  while s != lasts:<br/>      lasts = s<br/>      i += 1<br/>      fact *= i<br/>      num *= x<br/>      nf *= (x / i) <strong class="la ir">### update nf to be num / fact</strong><br/>      s += nf       <strong class="la ir">### was: s += num / fact</strong><br/>  getcontext().prec -= 2<br/>  return +s</span></pre><p id="8e45" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">这个变化的结果就是，嗯，<em class="lx">戏剧性</em>。</p><p id="0f4c" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">在苹果迷你M1上，原始版本:</p><pre class="kh ki kj kk gt ly la lz ma aw mb bi"><span id="7d25" class="mc md iq la b gy me mf l mg mh">Original:</span><span id="ea89" class="mc md iq la b gy mq mf l mg mh">1.39370958066637969731834193711E+65<br/>5.22146968976414395058876300668E+173<br/>7.64620098905470488931072765993E+1302</span><span id="a95b" class="mc md iq la b gy mq mf l mg mh">Elapsed time, original (s):   33.231053829193115</span></pre><p id="eb9f" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">优化版本:</p><pre class="kh ki kj kk gt ly la lz ma aw mb bi"><span id="2bd8" class="mc md iq la b gy me mf l mg mh">Optimized:</span><span id="ec38" class="mc md iq la b gy mq mf l mg mh">1.39370958066637969731834193706E+65<br/>5.22146968976414395058876300659E+173<br/>7.64620098905470488931072766048E+1302</span><span id="5974" class="mc md iq la b gy mq mf l mg mh">Elapsed time, optimized (s):  0.006501913070678711</span></pre><p id="db24" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">超过一个<em class="lx"> 5000X </em>的加速比(准确的说是5096)。</p><p id="dd5c" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">这个故事的寓意是，使用更详细的分析器(如Scalene)可以通过可操作的方式定位低效，从而真正有助于优化工作。</p></div></div>    
</body>
</html>