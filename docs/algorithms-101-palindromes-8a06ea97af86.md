# 算法:用 4 种不同的方法检查一个字符串是否是回文

> 原文：<https://betterprogramming.pub/algorithms-101-palindromes-8a06ea97af86>

## “一个人，一个计划，一条运河——巴拿马！”回文//真

![](img/94ed5195e883a71a4300310447d144ed.png)

照片由[叶夫根尼·切博塔列夫](https://www.pexels.com/@evgeny-tchebotarev-1058775?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)从[佩克斯](https://www.pexels.com/photo/white-lantern-lot-2541310/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)拍摄

今天，我很满意地醒来，因为我意识到这是一个回文日期:02-02-2020。

回文是一个单词、数字或短语，向前和向后读都一样，例如“kayak”、“1001”、“我看到的是一辆车还是一只猫？”，或者“阿爸”。

我喜欢回文——在维基百科页面上阅读更多关于它们为什么有趣的内容。你知道最长的回文有 58，795 个字母吗？

另外，你可以用这首美妙的诗来测试: [*该死的我疯了*](https://genius.com/Demetri-martin-dammit-im-mad-annotated) 作者[迪米特利·马丁](https://en.wikipedia.org/wiki/Demetri_Martin)，其中每一行都是一个回文，就像一首诗本身一样！

# 回文算法

欢迎来到我的算法系列，在这里我将解释如何解决常见的算法问题。

今天，我们将创建一个算法来检查给定的单词是否是回文。我提出了三种解决方案，按照性能最低到最高的顺序排列。

# 设置:正则表达式

如果你想变得更奇特，你可以从思考边缘案例开始。如果你的例子包括空格，不同大小写的字母，或者函数符号呢？

这不是必需的，因为可能测试中给出的唯一例子是一个单词的字符串。否则，您可能希望在代码中添加一些保护措施。将这一行粘贴到函数定义中:

```
let str = str.toLowerCase().replace(/[\W_]/g, '')
```

这一行首先接受下面例子中作为参数传入的字符串，小写所有字母，并取出非字母数字字符。

# 解决方案 1:将字符串与其反向版本进行比较

因为在 JS 中，`.reverse()`函数只对数组有效，所以我们需要:

1.  将单词拆分成数组，保存到变量中。
2.  反转数组。
3.  把它放回去。
4.  将初始字符串与反转的字符串进行比较。

您可以通过使用 ES6 扩展功能使它变得更简单，如下所示:

```
function checkPalindrome(str){
  let reversed = [...str].reverse().join("")
  return str === reversed
}
```

现在，这可能是最直观和直接的解决方案，但遗憾的是，它不是最有效的。

# 解决方案 2:递归

在这个解决方案中，我们将使用递归(一个函数调用自己来查看是否)。以下是步骤:

1.  声明一个接受一个参数(字符串)的函数。
2.  将字符串长度保存到变量中。
3.  检查是否有更多的字母，如果有，继续，否则，你有一个回文。
4.  现在，如果第一个和最后一个字母相同，再次调用该函数，传递第一个和最后一个字母被切片的字符串。否则，返回 false。

这不是一个完美的解决方案，因为如果传递的字符串是一个空字符串或者只有一个字母呢？

# 解决方案 3: for 循环

在这个解决方案中，我们将再次反转一个字符串，这次使用一个`for`循环来检查两边的字母是否完全相同。

1.  用字符串的长度声明一个变量。
2.  使用字符串长度的一半作为参考点，声明一个`for`循环。
3.  检查每个字母是否与其对应的镜像字符相同，或者另一面的字符是否相同(用 index-1 测量)。

这种解决方案效率更高，因为我们只检查一半的字母，其计算时间大约是第一种解决方案的两倍。

# 4.好处:递归+控制流

下面是 Jason Sebring 在 [Stack Overflow](https://stackoverflow.com/a/25091111) 上提出的一个答案，我对此很好奇:

```
function checkPalindrome(str,i) {
  return (i=i||0)<0 || i>=str.length>>1 || str[i]==str[str.length-1-i] && checkPalindrome(str,++i);
}
```

在 JavaScript 中，控制流操作符(`&&`和`||`)是`if/else`的替代物。在本解决方案中，我们在三个地方使用它们。以下是一步一步的解释:

1.  用两个参数声明函数，字符串和索引:`function checkPalindrome(str,i)`。
2.  通过组成一个将始终计算为 false 的表达式来初始化索引，这样它将进行到下一个参数:`(i=i||0)<0`。
3.  检查索引是否已经到一半，但跳过检查中间的奇数字符。我们使用按位运算符`>>`除以 2。如果该表达式为真，则检查完成，如果不是，则前进到下一个条件:`i>=str.length>>1`。
4.  比较镜像字符(两边相同的地方)是否相同。如果不是，退出并假设这个表达式不是回文。如果为真，继续:`str[i]==str[str.length-1-i]`。
5.  递归调用函数重复整个过程:`checkPalindrome(str,++i)`。

# 结论

和 JavaScript 中的所有东西一样，有许多方法可以解决这个问题。

我考虑过使用`.reduce()`或`.every()`，但是考虑到你不能中断迭代，这会导致低性能，这看起来有点大材小用。我很好奇你对这个普遍问题的看法！