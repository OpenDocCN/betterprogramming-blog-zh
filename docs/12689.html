<html>
<head>
<title>Understand Source Code — Diving Deep into the Code Base, Locally and in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解源代码——深入代码库，在本地和生产中</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-source-code-diving-deep-into-the-codebase-locally-and-in-production-cba8a6732460?source=collection_archive---------10-----------------------#2022-06-22">https://betterprogramming.pub/understand-source-code-diving-deep-into-the-codebase-locally-and-in-production-cba8a6732460?source=collection_archive---------10-----------------------#2022-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af20" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么在没有bug的情况下应该进行调试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5b18d096148608d9e69dafb6f8dadd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVRoa4bTEgxNJGqCrdX3Ug.png"/></div></div></figure><p id="5bb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您有一个新的代码库要学习，或者有了一个开源项目。你可能是一个经验丰富的开发人员，对他来说这是一个打包简历中的另一个项目。或者，你可能是一个初级工程师，对他来说这是第一个“真正的”项目。</p><p id="0b4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没关系！</p><p id="787a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了全新的源代码库，我们仍然一无所知。</p><p id="8cbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">经验丰富的学长可能有助于发现一些东西和识别模式。但是我们没有人能读懂并真正理解一个有超过100万行代码的项目。我们查看文档，根据我的经验，这些文档通常与实际的代码库有一点相似之处。我们对各种模块进行了分离和假设，但是很难将它们捡起来。</p><p id="9b14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用IDE工具来搜索连接，但是这真的很难。这就像一群猫在追逐一根纱线一样。</p><p id="8ba1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一名十多年的顾问，我每周都会接到新的客户项目。在这篇文章中，我将描述我用来做这件事的方法，以及我如何在Lightrun中进一步采用这种方法。</p><h1 id="637e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">寻找用法</h1><p id="0160" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">编程语言可以帮很多忙。作为Java开发人员，我们很幸运，基于代码的探索工具非常可靠。我们可以挖掘代码并找到用法。ide会突出显示未使用的代码，它们在这方面非常出色。但是这有几个问题:</p><ul class=""><li id="d3cd" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm mp mq mr ms bi translated">我们需要知道去哪里找，找多深</li><li id="a048" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">测试或API可能会使用代码，但用户实际上并不使用这些代码</li><li id="7b3a" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">通过使用很难理解心流。尤其是异步流</li><li id="a243" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">没有像数据这样的上下文来帮助解释代码流</li></ul><p id="2c11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一定有比随意梳理源文件更好的方法</p><h1 id="833d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">UML生成</h1><p id="3fc4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">另一个选择是从源文件生成UML图表。我个人对这些工具的体验并不好。他们应该对“大局”有所帮助，但我经常对这些工具感到更加困惑。</p><p id="5702" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它们将次要的实现细节和未使用的代码提升到令人难以置信的混乱图表中的同等地位。对于典型的代码库，我们需要的不仅仅是高层视图。魔鬼在细节中，我们的感知应该是版本控制中的实际代码库。不是什么理论模型。</p><h1 id="4669" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">调试作为一种学习工具</h1><p id="1b3c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">调试器立即解决了所有这些问题。我们可以立即验证假设，看到“真实世界”的用法，并跳过一个代码块来理解流程。我们可以放置一个断点来查看我们是否到达了一段代码。如果到达得太频繁，我们不知道发生了什么，我们可以将这个断点设为有条件的。</p><p id="b6e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我习惯在使用调试器研究代码库时读取表中变量的值。</p><p id="386a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个值在这个时间点有意义吗？</p><p id="0437" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果没有，那我就有东西要看，要弄清楚。有了这个工具，我可以快速理解代码库的语义。在接下来的几节中，我将介绍在调试器和生产环境中学习代码的技巧。</p><p id="256f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我使用的是Java，但这应该适用于任何其他编程语言，因为这些概念(大部分)是通用的。</p><h1 id="e0e2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">野外观察点</h1><p id="3347" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我认为大多数开发人员都知道<a class="ae my" href="https://talktotheduck.dev/basics-of-breakpoints-you-might-not-know#heading-field-watchpoint" rel="noopener ugc nofollow" target="_blank">现场观察点</a>，只是忘记了它们！</p><p id="c9c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“谁改变了这个值，为什么？”可能是开发人员问得最多的问题。当我们查看代码时，可能有几十个代码流触发了一个变化。但是在田地上放置一个观察点可以在几秒钟内告诉你一切。</p><p id="66c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在研究代码库时，理解状态突变和传播可能是你能做的最重要的事情。</p><h1 id="3904" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">返回值</h1><p id="6394" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">逐句通过方法时需要理解的最重要的事情之一是返回值。不幸的是，对于调试器来说，当从一个方法返回时，这些信息经常会“丢失”,并且可能会错过流程的关键部分。</p><p id="0b52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，大多数ide允许我们动态地检查返回值，并查看方法执行后返回了什么。在JetBrains IDEs中，比如IntelliJ/IDEA，我们可以启用“显示方法返回值”，正如我在这里讨论的<a class="ae my" href="https://talktotheduck.dev/debugging-tutorial-java-return-value-intellij-jump-to-line-and-more" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/75ca0b6a468463d9b55c05fea64783fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/0*Ehm5ql_d9yIHieqB"/></div></figure><h1 id="3bb4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">作为学习工具的流量控制</h1><p id="5449" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">为什么需要这条线？</p><p id="aaf4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果它不在那里会发生什么？</p><p id="80c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一组很常见的问题。有了调试器，我们可以<a class="ae my" href="https://talktotheduck.dev/debugging-tutorial-java-return-value-intellij-jump-to-line-and-more" rel="noopener ugc nofollow" target="_blank">改变控制流</a>跳转到特定的代码行，或者用特定的值强制方法提前返回。这可以帮助我们检查特定行的情况，例如，如果这个方法是用值X而不是Y调用的呢？</p><p id="c639" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单。只需将执行向后拖一点，然后用不同的值再次调用该方法。这比深入阅读层次结构要容易得多。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/e5591a915cec3a2145d3c72beb306001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*INT54viByDYLF-aE"/></div></div></figure><h1 id="c1d6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">通过对象标记保持跟踪</h1><p id="1feb" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">对象标记是那些未知的调试器功能中的一种，它非常有价值并且非常强大。它对理解“到底发生了什么”有很大的作用</p><p id="cbb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你知道当你调试一个值时，你写下指向对象的指针，这样你就可以跟踪“这个代码块中发生了什么？”。</p><p id="6042" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这变得很难跟踪。所以我们将交互限制在很少的指针上。对象标记让我们通过在固定名称下保存对指针的引用来跳过这一步。即使对象超出范围，引用标记仍然有效。</p><p id="a336" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以开始跟踪对象，以了解流程并了解事情是如何工作的。例如，如果我们正在调试器中查看一个<code class="fe nb nc nd ne b">User</code>对象，并想要跟踪它，我们可以只保留对它的引用。然后在用户对象就位的情况下使用条件断点来检测访问用户的系统区域。</p><p id="971c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这对于跟踪线程也非常有用，有助于理解线程逻辑复杂的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/210314171b7e2c6093f6bf41f8c49631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e7ypwXffxvvr3L0d"/></div></div></figure><h1 id="ed1c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">检查内存中的对象</h1><p id="f44b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我遇到的一种常见情况是在调试器中看到一个组件。但是我一直在寻找这个对象的不同实例。例如，如果你有一个名为<code class="fe nb nc nd ne b">UserMetaData</code>的对象。每个用户对象都有对应的<code class="fe nb nc nd ne b">UserMetaData</code>对象吗？</p><p id="67f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一个解决方案，我们可以使用内存检查工具，看看给定类型的哪些<a class="ae my" href="https://talktotheduck.dev/memory-debugging-and-watch-annotations#heading-memory-usage" rel="noopener ugc nofollow" target="_blank">对象保存在内存</a>中！</p><p id="17e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看实际的对象实例值并检查它们有助于将数字/事实置于对象之后。这是一个帮助我们可视化数据的强大工具。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/416833c09fc7e97ed2349c434e32b8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZBONWJ4JvUPQWpqS"/></div></div></figure><h1 id="81db" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">使用跟踪点语句来跟踪复杂的逻辑</h1><p id="0d15" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在开发过程中，我们通常只是添加日志来查看“是否达到了这条线”很明显，一个断点是有好处的，但是我们并不是总想停下来。停止可能会改变线程的行为，这也可能会非常繁琐。</p><p id="9554" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是添加日志可能会更糟。重新编译、重新运行，并意外地提交到存储库中。对于调试和研究代码来说，这是一个有问题的工具。</p><p id="12ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，我们有<a class="ae my" href="https://talktotheduck.dev/basics-of-breakpoints-you-might-not-know#heading-tracepoints" rel="noopener ugc nofollow" target="_blank">跟踪点</a>，它们是有效的日志，让我们打印出表达式等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/7c5fb26b1a3018728811eceb02b8c390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5dJE8SPBJCixu-VL"/></div></div></figure><h1 id="453c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">生产中发生了什么——又名“现实报道”</h1><p id="741d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这对“简单”的系统非常有用。但是在我们的行业中，有一些平台和设置非常难以在调试器中重现。了解我们的代码在本地工作的方式是一回事。它在生产中的工作方式是完全不同的。</p><p id="eb59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">生产是唯一真正重要的事情，在多开发者项目中，很难评估生产和假设之间的差距。</p><p id="66e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们称之为现实报道。例如，您可以在测试中获得80%的覆盖率。但是如果你对源代码库中频繁访问的类的覆盖率很低，那么QA可能就没那么有效了。我们可以反复研究回购协议。我们可以使用每一种代码分析工具和设置。但他们不会向我们展示真正重要的两件事:</p><p id="3d83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这在生产中实际使用吗？</p><p id="4519" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这在生产中是如何使用的？</p><p id="62a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没有这些信息，我们可能会浪费时间。比如在处理回购上百万行的时候。你不想浪费你的学习时间去阅读一个不常用的方法。</p><p id="8063" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了深入了解生产和调试环境，我们需要一个开发人员可观察性工具，比如Lightrun。你可以在这里<a class="ae my" href="https://lightrun.com/free" rel="noopener ugc nofollow" target="_blank">免费安装。</a></p><h1 id="4b89" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">用计数器测量</h1><p id="9a30" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">计数器让我们看到一行代码到达的频率。这是我们拥有的最有价值的工具之一。</p><p id="0835" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法达到了吗？</p><p id="615a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到达代码中的这个块了吗？多久一次？</p><p id="1abe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想知道先把精力集中在哪里，计数器可能是你可以使用的最方便的工具。你可以在这里阅读关于柜台<a class="ae my" href="https://docs.lightrun.com/metrics/#counter" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/fedf28753f2f7ba64a025b5b80b80349.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/0*JJMVnS36TOVyG6w4"/></div></figure><h1 id="2bc8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">有条件的假设验证</h1><p id="667d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们经常看一个语句，做各种各样的假设。当代码对我们来说是新的时候，这些假设可能是我们理解代码的关键。一个很好的例子是，使用这个特性的大多数用户已经使用这个系统有一段时间了，应该对它很熟悉。</p><p id="f3aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用附加到任何操作(日志、计数器、快照等)的条件语句来测试这一点。).因此，我们可以使用类似于<code class="fe nb nc nd ne b">user.signupDate.getMillis() &lt; …</code>的条件。</p><p id="3114" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以将它添加到一个计数器中，并计算出不符合您预期的用户数量。</p><h1 id="d7c4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">没有噪音的日志和管道学习</h1><p id="a6f9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我认为很明显，在运行时注入日志对于理解我们的系统有很大的不同。但是在生产中，这是有代价的。我正在研究系统，同时查看日志，我所有的“methodX达到值Y”日志给我们可怜的DevOps/SRE团队增加了噪音。</p><p id="9c46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不能这样。研究某样东西应该是孤独的，但是根据定义，生产恰恰相反。</p><p id="e944" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了<a class="ae my" href="https://docs.lightrun.com/logs/#configure-piping" rel="noopener ugc nofollow" target="_blank">管道</a>，我们可以在本地将所有东西记录到IDE中，让其他人免受干扰。因为逻辑是沙箱化的，所以如果您记录太多，就不会有开销。所以尽情狂欢吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/58d5a847eef089d5f1ea4545764c7c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-9pTRhgXUZHYXLVSPRLrNg.gif"/></div></div></figure><h1 id="a37a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">便于学习的快照</h1><p id="6fdb" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">学习中的一个巨大挑战是理解我们“还”不知道的东西。<a class="ae my" href="https://docs.lightrun.com/snapshots-plugin/" rel="noopener ugc nofollow" target="_blank">快照</a>帮助我们更全面地了解代码。快照就像放置任何断点并检查堆栈中变量的值，以查看我们是否理解了概念。它们只是“不会中断”,因此您可以获得所有可以用来学习的信息，但系统会照常运行，包括线程行为。</p><p id="710a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，使用条件快照非常有助于确定特定的问题。例如，当拥有权限X的用户使用这种方法时，会发生什么情况？</p><p id="cb01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单。为权限放置条件快照。然后检查生成的快照，看看变量值是如何受到影响的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/618dc013ebecf2229679e4449c34001e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JPIQylOazGWcCGJfxRauLA.gif"/></div></div></figure><h1 id="971f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">一锤定音</h1><p id="ad2e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">开发人员通常与调试工具关系紧张。</p><p id="8bee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一方面，它们通常是拯救我们的工具，帮助我们找到错误。另一方面，当我们意识到在过去的几个小时里我们是彻头彻尾的白痴时，它们是我们看的工具。</p><p id="2f15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这个指南能鼓励你在没有bug的时候去找调试器。运行调试器所提供的见解，即使您没有主动调试，也可以“改变游戏规则”</p></div></div>    
</body>
</html>