<html>
<head>
<title>These Modern Programming Languages Will Make You Suffer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这些现代编程语言会让你痛苦</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-languages-suck-ad21cbc8a57c?source=collection_archive---------0-----------------------#2020-12-07">https://betterprogramming.pub/modern-languages-suck-ad21cbc8a57c?source=collection_archive---------0-----------------------#2020-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1171" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">欢迎来到现代编程语言的终极评级</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06543f7ed00267b74537b0422b0e37aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zFs-VAB35APZwad--qnvw.jpeg"/></div></div></figure><p id="683b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">特定编程语言的优缺点是什么？对于我的任务来说，X是一种好的语言吗？谷歌“最佳编程语言”会给你一个“Python、Java、JavaScript、C#、C++、PHP”的标准列表，还有一个模糊的利弊列表。看到这样的文章让我畏缩——它们的作者一定是彻头彻尾的懒惰、缺乏经验和想象力。让我们深入探究一下，看看什么是真正糟糕的，什么不是。</p><p id="ef02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将尝试对流行的(和不太流行的)现代编程语言给出一个客观的、希望没有偏见的概述，从最差到最好排序。</p><p id="c571" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，没有一种完美的编程语言。有些最适合后端/ API开发，有些非常适合系统编程。</p><p id="35de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将介绍世界上最常见的两个语系:源于C语言的<a class="ae lq" href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages" rel="noopener ugc nofollow" target="_blank">语言</a>和源于ML语言的<a class="ae lq" href="https://en.wikipedia.org/wiki/ML_(programming_language)" rel="noopener ugc nofollow" target="_blank">语言</a>。</p><p id="28cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编程语言只是开发者工具箱中的工具。为这项工作选择合适的工具很重要。我真的希望这个指南能帮助你选择最适合你的任务的编程语言。做出正确的选择可能会为您节省几个月(甚至几年)的开发时间。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5ff4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么样的语言特征真正重要？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/7460ba0f3f78d07bf7bcab218ecb0b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqsvzacHhqF2rF0ev0ON0Q.jpeg"/></div></div></figure><p id="5434" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大多数其他类似的文章都是基于像<strong class="kw iu"><em class="mr"/></strong>和<strong class="kw iu"> <em class="mr">收入潜力</em> </strong>这样的因素进行比较。受欢迎程度很少是一个好的衡量标准，尤其是在软件领域(尽管一个大的社区生态系统有所帮助)。取而代之的是，我会考虑一种特定语言的长处和短处。</p><p id="359c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我会竖起大拇指👍(即+1)，不赞成👎，或者一个ok👌(不好也不坏)表情符号表示特定语言特征的分数。</p><p id="16b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们将如何衡量？换句话说，除了语言流行度之外，真正重要的是什么？</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4925" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">类型系统</h1><p id="b92c" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">许多人相信类型系统。这就是为什么像TypeScript这样的语言近年来越来越受欢迎。我倾向于同意类型系统消除了程序中的大量错误，使重构更容易。然而，拥有类型系统只是故事的一部分。</p><p id="98a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一门语言有类型系统，那么拥有<em class="mr">类型推理</em>也是非常有用的。最好的类型系统能够推断出大多数类型，而不需要显式地标注函数签名。不幸的是，大多数编程语言只提供基本的类型推理。</p><p id="6ce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于一个类型系统来说，支持代数数据类型也是很好的(稍后会详细介绍)。</p><p id="eb3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最强大的类型系统支持更高级的类型，这是泛型之上的一个抽象层次，允许我们在更高的抽象层次上编程。</p><p id="3933" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还必须记住，人们倾向于把太多的重要性放在类型系统上。有些事情远比静态类型重要，类型系统的存在与否不应该是选择语言的唯一因素。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b6ec" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">学习努力</h1><p id="b209" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们可能有完美的编程语言，但是如果新开发人员的入职可能需要几个月甚至几年(前期投资)，这又有什么用呢？另一方面，有些编程范例需要数年才能熟练掌握。</p><p id="b24a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一门好的语言应该让初学者容易理解，而不应该花很多年去掌握。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8fdc736fc5885c02511daac3ee577fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:2/format:webp/1*caUNu6RMeBKLIht997tR8Q.png"/></div></figure><h1 id="8312" class="ly lz it bd ma mb my md me mf mz mh mi jz na ka mk kc nb kd mm kf nc kg mo mp bi translated">无效的</h1><blockquote class="nd ne nf"><p id="b196" class="ku kv mr kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">我称之为我的十亿美元错误。这是1965年零引用的发明。当时我正在用一种 <a class="ae lq" href="https://suzdalnitski.com/oop-will-make-you-suffer-846d072b4dce" rel="noopener ugc nofollow" target="_blank"> <em class="it">面向对象的</em> </a> <em class="it">语言设计第一个综合型的引用系统。我的目标是确保所有引用的使用都是绝对安全的，由编译器自动执行检查。但是我无法抗拒放入空引用的诱惑，仅仅是因为它太容易实现了。这导致了数不清的错误、漏洞和系统崩溃，在过去的四十年里，这可能造成了数十亿美元的痛苦和损失。</em></p><p id="4dd4" class="ku kv mr kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">-东尼·霍尔，空引用的发明者</p></blockquote><p id="b42f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么空引用不好？空引用破坏了类型系统。当null是默认值时，我们就不能再依赖编译器来检查代码的有效性了。任何可空值都是一个等待爆炸的炸弹。如果我们试图使用我们不认为可能为空的值，但它实际上是空的，该怎么办？我们得到一个运行时异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="97ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们必须依靠<em class="mr">手动运行时检查</em>来确保我们处理的值不为空。即使在静态类型的语言中，空引用也带走了类型系统的许多好处。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2a69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种运行时检查(有时称为空值保护)实际上是糟糕的语言设计的变通办法。他们在我们的代码中散布样板文件。最糟糕的是，不能保证我们不会忘记检查null。</p><p id="d7de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在好的语言中，应该在编译时对值的存在与否进行类型检查。</p><p id="565e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">鼓励使用其他机制处理缺失数据的语言将排名更高。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="df32" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">错误处理</h1><p id="f814" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated"><em class="mr">捕捉</em>异常不是处理错误的好方法。抛出异常是没问题的，但是只有在<em class="mr">异常</em>的情况下，当程序无法恢复，并且不得不崩溃的时候。就像nulls一样，异常会破坏类型系统。</p><p id="c5c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当异常被用作错误处理的主要方式时，不可能知道一个函数是会返回一个期望值还是会崩溃。抛出异常的函数也不可能被编写。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8c6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，仅仅因为我们无法获取一些数据而导致整个应用程序崩溃是不合适的。然而，比我们愿意承认的更多的时候，这就是发生的事情。</p><p id="f713" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种选择是手动检查引发的异常，但是这种方法很脆弱(我们可能会忘记检查异常),并且增加了很多噪音:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="75b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在有更好的错误处理机制。可能的错误应该在编译时进行类型检查。默认情况下不使用异常的语言排名会更高。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="692b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">并发</h1><p id="e77b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们已经到了摩尔定律的尽头:处理器不会再快了。我们生活在多核CPU时代。任何现代应用都必须利用多核优势。</p><p id="c979" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，今天使用的大多数编程语言都是在单核计算时代设计的，根本不具备在多核上有效运行的特性。</p><p id="72ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有助于并发性的库是后来才想到的，它们只是给最初不是为并发性设计的语言添加了创可贴。这不算是好的开发者体验。在现代语言中，并发支持必须是内置的(想想Go/Erlang/Elixir)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8fdc736fc5885c02511daac3ee577fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:2/format:webp/1*caUNu6RMeBKLIht997tR8Q.png"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="64a1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">不变</h1><blockquote class="nd ne nf"><p id="d119" class="ku kv mr kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it">我认为大型的</em> <a class="ae lq" href="https://suzdalnitski.com/oop-will-make-you-suffer-846d072b4dce" rel="noopener ugc nofollow" target="_blank"> <em class="it">面向对象的</em> </a> <em class="it">程序在构建这种包含可变对象的大型对象图时，会越来越复杂。你知道，试着理解并记住当你调用一个方法时会发生什么，副作用会是什么。</em></p><p id="dce5" class="ku kv mr kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it">——</em><a class="ae lq" href="http://www.se-radio.net/2010/03/episode-158-rich-hickey-on-clojure/" rel="noopener ugc nofollow" target="_blank"><em class="it">Rich Hickey</em></a><em class="it">，Clojure的创建者。</em></p></blockquote><p id="9a8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用不变的值编程现在变得越来越流行。甚至像<code class="fe nl nm nn no b">React</code>这样的现代UI库也是为了使用不可变的值。对不可变数据值有一流支持的语言排名会更高。仅仅因为不变性从我们的代码中消除了一整类错误。</p><p id="c535" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么是<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变状态</a>？简单来说，就是数据不变。就像大多数编程语言中的字符串一样。例如，将字符串大写永远不会改变原始字符串，而是总是返回一个新的字符串。</p><p id="0a55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不变性进一步发展了这一思想，确保没有任何东西被改变。总是返回一个新数组，而不是改变原来的数组。更新用户名？将返回一个新的用户对象，其名称已更新，原始对象保持不变。</p><p id="49af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了不可变状态，没有什么是共享的，因此我们不再需要担心线程安全的复杂性。不变性使我们的代码易于并行化。</p><p id="1871" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不改变任何状态的函数被称为纯函数，并且非常容易测试和推理。当使用纯函数时，我们永远不必担心函数之外的任何事情。只专注于你正在处理的这一个功能，忘掉其他的一切。你可以想象开发变得有多容易(与OOP相比，OOP需要记住整个对象图)。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5e00" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">生态系统/工具</h1><p id="13db" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">一种语言可能不太好，但它可能有一个大的生态系统，这使它具有吸引力。使用好的库可以节省几个月甚至几年的开发时间。</p><p id="3a8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经在JavaScript和Python这样的语言中看到了这种情况。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="774b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">速度</h1><p id="3fba" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">语言<strong class="kw iu"> <em class="mr">编译</em> </strong>有多快？程序启动有多快？它们的运行时性能如何？所有这些事情都很重要，都会被列入排名。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f46f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">年龄</h1><p id="ebc9" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">虽然有一些例外，但一般来说，新的语言会比旧的语言更好。原因很简单，因为新的语言会从前辈的错误中吸取教训。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="43e1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">C++</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e2cd00f483f66175bbd6326b97008ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*gqSGrN8Zj8LY-q-VnpzVBQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e8cd1cf22c48bb773ab159b9643fddc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*CzKWXYzsEZwZJuqNyf4udQ.png"/></div></figure><p id="9745" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从最坏的最坏的，可能是计算机科学最大的错误之一，C++开始我们的评级。是的，C++并不被认为是一种闪亮的现代编程语言。但它至今仍被广泛使用，不得不被列入清单。</p><p id="eda0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> C. </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8fdc736fc5885c02511daac3ee577fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:2/format:webp/1*caUNu6RMeBKLIht997tR8Q.png"/></div></figure><h2 id="3a6f" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎语言特征</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/4fd74126840b6a44773078a6779b18e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGTBjWdsyDsaiL2Ys3WUQA.jpeg"/></div></div></figure><blockquote class="oe"><p id="47bc" class="of og it bd oh oi oj ok ol om on lp dk translated"><em class="oo"> C++是一种可怕的语言……而将你的项目限制为C意味着人们不会用任何白痴的"</em> <a class="ae lq" href="https://suzdalnitski.com/oop-will-make-you-suffer-846d072b4dce" rel="noopener ugc nofollow" target="_blank"> <em class="oo">对象模型</em></a><em class="oo">" C&amp;@ p .<br/>——Linus Torvalds，Linux的创造者。</em></p></blockquote><p id="450f" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">C++充斥着各种功能。它试图做任何事情，而不擅长任何特定的事情。C++有<code class="fe nl nm nn no b">goto</code>、指针、引用、OOP、操作符重载和许多其他非生产性的特性。</p><p id="c16e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C++为什么这么差？在我看来，最大的原因是它的年龄。C++是很久以前，1979年设计的。当时的设计师缺乏经验，不知道应该关注什么。添加的功能在当时看起来可能是个好主意。这种语言非常受欢迎，这意味着添加了更多的特性来支持各种用例(创建了更多的特性)。</p><h2 id="9891" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎速度</h2><p id="afd4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">C++因其缓慢的编译时间而臭名昭著。它明显比Java慢，虽然没有Scala差。</p><p id="6c4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过，运行时性能和启动时间都很好。</p><h2 id="c572" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎生态系统/工具</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/663d45b3bdde3948bbcc65f58e927606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHGnpD9luB6O2OjUaoP1Ig.png"/></div></div></figure><p id="e1fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述推文提出了一个很好的观点。C++编译器的错误信息对初学者来说不是很友好。通常情况下，找出错误的确切原因需要一些时间。</p><h2 id="ab37" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎👎碎片帐集</h2><blockquote class="nd ne nf"><p id="9fe6" class="ku kv mr kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it">我曾希望一个可以随意启用的垃圾收集器会成为C++0x的一部分，但是技术问题太多了……</em></p><p id="8fa3" class="ku kv mr kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">-比雅尼·斯特劳斯特鲁普，C++的创造者</p></blockquote><p id="2320" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C++从来没有加入垃圾收集。手动内存管理极易出错。开发人员不得不担心手动释放和分配内存。我将永远不会怀念我使用非垃圾收集语言的日子，如今在垃圾收集语言中，无数的bug都可以很容易地被阻止。</p><h2 id="4cc9" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎面向对象编程的一次失败尝试</h2><blockquote class="oe"><p id="29a9" class="of og it bd oh oi ov ow ox oy oz lp dk translated">我发明了术语<a class="ae lq" href="https://suzdalnitski.com/oop-will-make-you-suffer-846d072b4dce" rel="noopener ugc nofollow" target="_blank">面向对象</a>，我可以告诉你，我脑子里没有C++。</p><p id="0f67" class="of og it bd oh oi ov ow ox oy oz lp dk translated">——艾伦·凯，面向对象编程的发明者。</p></blockquote><p id="1dfe" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">出现于60年代后期，当C++的工作开始时，OOP是一项很酷的新技术。不幸的是，C++在实现OOP的过程中犯了一些关键性的错误(不像Smalltalk这样的语言)，这使得一个非常好的想法变成了一场噩梦。</p><p id="5501" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与Java相比，C++的一个优点是C++中的OOP至少是可选的。</p><h2 id="1865" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎👎学习努力</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/6398aac806c08f06585e3b1674feee7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guc9SVj1TmOmPGr9jMF7OA.png"/></div></div><p class="pb pc gj gh gi pd pe bd b be z dk translated">关于<a class="ae lq" href="https://www.reddit.com/r/ProgrammerHumor/comments/k09yty/my_friend_sent_me_this_thought_it_belonged_here/" rel="noopener ugc nofollow" target="_blank"> Reddit </a>的Mercurial_Rhombus</p></figure><p id="85ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C++是一种复杂的低级语言，没有自动内存管理。由于其功能膨胀，初学者不得不花大量时间学习语言。</p><h2 id="12da" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎并发</h2><p id="0b6a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">C++是在单核计算时代设计的，只有在过去十年中添加的基本并发机制。</p><h2 id="567f" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎错误处理</h2><p id="b6c8" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">捕捉/抛出错误是首选的错误处理机制。</p><h2 id="e269" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎不变</h2><p id="d39d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">没有对不可变数据结构的内置支持。</p><h2 id="2528" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎无效的</h2><p id="49fb" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在C++中，所有引用都可以为空。</p><h2 id="2337" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎转到</h2><p id="e150" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">C++可能是唯一仍然支持goto语句的现代编程语言。在过去，它是错误的主要原因，但是C++已经决定把这个可怕的过去的遗迹放进去。毕竟，功能越多越好，对吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8fdc736fc5885c02511daac3ee577fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:2/format:webp/1*caUNu6RMeBKLIht997tR8Q.png"/></div></figure><h2 id="b19c" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e8cd1cf22c48bb773ab159b9643fddc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*CzKWXYzsEZwZJuqNyf4udQ.png"/></div></figure><p id="c4d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C++原本打算成为一个更好的C版本，但未能实现。</p><p id="02e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C++最好的用途大概是系统编程。然而，考虑到现有的更好和更现代的选择(Rust和Go)，C++甚至不应该用于此。我不认为C++有任何优点，尽管证明我错了。</p><p id="5e04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C++，你该走了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="71bc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/1d328ae07b2d05f87d2631e2cf6ffa57.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*fWv6_uU9u4058LsY3lwtgw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/04c8c854189b4ac356a90f1134d08fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*M78xqGKHewErNZGkXLQPVQ.png"/></div></figure><blockquote class="oe"><p id="bfb6" class="of og it bd oh oi oj ok ol om on lp dk translated">Java是自MS-DOS以来计算机领域最令人苦恼的事情。</p><p id="4860" class="of og it bd oh oi ov ow ox oy oz lp dk translated"><em class="oo">——艾伦·凯，美国</em> <a class="ae lq" href="http://www.cc.gatech.edu/fac/mark.guzdial/squeak/oopsla.html" rel="noopener ugc nofollow" target="_blank"> <em class="oo">发明家</em></a><em class="oo"/><a class="ae lq" href="https://suzdalnitski.com/oop-will-make-you-suffer-846d072b4dce" rel="noopener ugc nofollow" target="_blank"><em class="oo">面向对象编程</em> </a> <em class="oo">。</em></p></blockquote><p id="4d75" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">Java于1995年首次出现，比C++年轻16岁。Java是一种简单得多的语言，这可能是它受欢迎的原因之一。</p><p id="5c8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> C </strong>。</p><h2 id="22c4" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍碎片帐集</h2><p id="165b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">与C++相比，Java提供的最大好处之一是垃圾收集，它本身就消除了一大类错误。</p><h2 id="d591" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍生态系统</h2><p id="8cfd" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Java已经存在很长时间了，它有一个巨大的后端开发生态系统，这大大减少了开发工作。</p><h2 id="c47b" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎面向对象语言</h2><p id="ac4f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我不会在这里深入探讨OOP的缺点，更详细的分析你可以阅读我的另一篇文章<a class="ae lq" href="https://medium.com/better-programming/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7" rel="noopener">面向对象编程——万亿美元的灾难</a>。</p><p id="8e78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，我将简单地引用计算机科学中一些最杰出的人的话，来了解他们对OOP的看法:</p><blockquote class="oe"><p id="c5d0" class="of og it bd oh oi ov ow ox oy oz lp dk translated">很抱歉，我很久以前就为这个主题创造了“对象”这个术语，因为它让许多人关注次要的概念。最大的想法是信息传递。面向对象程序设计的发明者艾伦·凯</p></blockquote><p id="48ab" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">Alan Kay是对的，主流OOP语言关注的是错误的东西——类和对象——而忽略了消息传递。幸运的是，有一些现代语言确实正确地理解了这一点(例如Erlang/Elixir)。</p><blockquote class="oe"><p id="6298" class="of og it bd oh oi ov ow ox oy oz lp dk translated"><em class="oo">有了面向对象的编程语言，计算机软件变得更加冗长，可读性更差，描述性更差，并且更难修改和维护。</em></p><p id="dfb3" class="of og it bd oh oi ov ow ox oy oz lp dk translated"><em class="oo"> — </em> <a class="ae lq" href="http://www.4js.com/files/documents/products/genero/WhitePaperHasOOPFailed.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="oo">理查德·曼斯菲尔德</em> </a></p></blockquote><p id="2750" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">任何使用过面向对象语言(如Java或C#)的人，如果有使用非面向对象语言的经验，可能都会有同感。</p><h2 id="c201" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌速度</h2><p id="08fa" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">显然，Java运行在Java虚拟机之上，而Java虚拟机以启动速度慢而臭名昭著。我见过在JVM上运行的程序需要30秒甚至更长时间才能启动，这对于现代的云原生程序来说是不可接受的。</p><p id="0b71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">较大项目的编译速度很慢，极大地影响了开发人员的生产力(尽管没有Scala那么糟糕)。</p><p id="4fd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从好的方面来看，JVM的运行时性能非常好。</p><h2 id="1b9f" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎学习努力</h2><p id="7cf9" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">虽然Java是一种相当简单的语言，但它对面向对象编程的关注让它变得很难。人们可以很容易地编写一个简单的程序。然而，知道如何编写可靠且可维护的面向对象代码可能需要十年以上的时间。</p><h2 id="9a26" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎并发</h2><p id="a7d2" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Java是在单核计算时代设计的，像C++一样，只有基本的并发支持。</p><h2 id="aff2" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎无效的</h2><p id="f00a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在Java中，所有的引用都是可空的。</p><h2 id="8fd9" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎错误处理</h2><p id="65b8" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">捕捉/抛出错误是首选的错误处理机制。</p><h2 id="7903" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎不变</h2><p id="49c9" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">没有对<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变</a>数据结构的内置支持。</p><h2 id="ea35" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/04c8c854189b4ac356a90f1134d08fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*M78xqGKHewErNZGkXLQPVQ.png"/></div></figure><p id="dbbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Java出现的时候是一种体面的语言。与Scala不同，它一直专注于OOP，这太糟糕了。这种语言非常冗长，并且有很多样板代码。</p><p id="c078" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Java退休的时候到了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="deb1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">C#</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/baf5fa0f45af551522beb02752a34303.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*ws5PiT3jBtq3IbYZPTyNYQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3c64821545f03e0c8758a2dec710a9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*3-dK26VxHTbpgmWEZZjwBw.png"/></div></figure><p id="7003" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从根本上说，C#和Java之间没有什么区别(因为早期版本的C#实际上是Java的微软实现)。</p><p id="1c99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C#与Java有着相同的缺点。C#在2000年首次出现，比Java小5岁，并且从Java的错误中学到了一些东西。</p><p id="7a5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> C </strong>。</p><h2 id="f98a" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌句法</h2><p id="1165" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">C#语法一直比Java领先一点。C#比Java更少受到样板代码的困扰。虽然作为一种面向对象的语言，C#更为冗长。很高兴看到C#语法在每个版本中都得到了改进，增加了一些特性，如表达式体函数成员、模式匹配、元组等等。</p><h2 id="cb77" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎面向对象语言</h2><p id="7d47" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">就像Java一样，C#主要关注面向对象。再说一次，我不打算在这里花太多的时间试图让你相信OOP的缺点，我将简单地引用计算机科学中几个比较突出的人的话。</p><blockquote class="oe"><p id="6182" class="of og it bd oh oi ov ow ox oy oz lp dk translated"><em class="oo">我认为复用性的不足在于</em> <a class="ae lq" href="https://suzdalnitski.com/oop-will-make-you-suffer-846d072b4dce" rel="noopener ugc nofollow" target="_blank"> <em class="oo">面向对象语言</em> </a> <em class="oo">，而不在于函数式语言。因为面向对象语言的问题是它们有所有这些隐含的环境。你想要一个香蕉，但你得到的是一只大猩猩拿着香蕉和整个丛林。</em></p><p id="fda0" class="of og it bd oh oi ov ow ox oy oz lp dk translated"><em class="oo"> —二郎的创造者乔·阿姆斯特朗</em></p></blockquote><p id="b155" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">我不得不同意乔·阿姆斯特朗的观点，与函数式(甚至命令式)代码相比，重用面向对象的代码非常困难。</p><blockquote class="oe"><p id="657d" class="of og it bd oh oi ov ow ox oy oz lp dk translated"><a class="ae lq" href="https://suzdalnitski.com/oop-will-make-you-suffer-846d072b4dce" rel="noopener ugc nofollow" target="_blank">面向对象的</a>程序被提供作为正确程序的替代方案……<br/>——Edsger w . Dijkstra，计算机科学的先驱</p></blockquote><p id="6dc9" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">在我的职业生涯中，我接触过OOP和非OOP语言，我不得不承认OOP代码比非OOP代码更难理解。</p><h2 id="0580" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎多范式？</h2><p id="49f4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">C#号称是多范式语言。特别是C#声称支持函数式编程。我不同意，对于一门语言来说，仅仅支持一级函数是不够的。</p><p id="90af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一门语言应该具备哪些功能特征？至少，内置了对<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变</a>数据结构、模式匹配、函数组合管道操作符、代数数据类型的支持。</p><h2 id="289f" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎并发</h2><p id="600a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">C#创建于单核计算时代，和Java一样只有最基本的并发支持。</p><h2 id="7ade" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎无效的</h2><p id="c683" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在C#中，所有引用都可以为空。</p><h2 id="d712" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎错误处理</h2><p id="4c92" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">捕捉/抛出错误是首选的错误处理机制。</p><h2 id="b832" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎不变</h2><p id="bbdd" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">没有对不可变数据结构的内置支持。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8fdc736fc5885c02511daac3ee577fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:2/format:webp/1*caUNu6RMeBKLIht997tR8Q.png"/></div></figure><h2 id="2746" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3c64821545f03e0c8758a2dec710a9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*3-dK26VxHTbpgmWEZZjwBw.png"/></div></figure><p id="dd65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我职业生涯的很大一部分时间都在使用C#，并且总是对这种语言感到沮丧。就像Java一样，我建议寻找更现代的替代品。它是相同的Java，只是语法更现代一点。</p><p id="6332" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，C#一点都不“犀利”。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="24fb" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">计算机编程语言</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/56b958278d9652c9f0e44927da3e6ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*TYakjZNa7mi-XwTVpstXhw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7110d97cac84665f27fbfa2a94bc0827.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*OBGMrbqEbZ_37MvR9j5jfA.png"/></div></figure><p id="bcd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python于1991年首次出现，是一门古老的语言。与JavaScript一起，Python是世界上最流行的语言之一。</p><p id="6d85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> C </strong>。</p><h2 id="e962" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍生态系统</h2><p id="5513" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Python几乎为所有东西都提供了一个库。与JavaScript不同，Python不能用于前端web开发。然而，它很容易用大量的数据科学库来弥补这一点。</p><h2 id="3330" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍学习努力</h2><p id="3bf0" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Python是一种非常简单的语言，初学者可以在几周内学会。</p><h2 id="f2fe" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎类型系统</h2><p id="e58d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Python是动态类型化的，关于类型系统就不多说了。</p><h2 id="50a1" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎速度</h2><p id="0683" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Python是一种解释型语言，就运行时性能而言，它是最慢的编程语言之一。在运行时性能至关重要的情况下，使用Cython而不是普通Python可能是一个好的解决方案。</p><p id="59a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与本地语言相比，Python启动起来也相当慢。</p><h2 id="f599" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎工具作业</h2><p id="bcc7" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在使用Python和其他现代语言之后，很难不对Python的依赖性管理感到失望。有pip，pipenv，virtualenv，<code class="fe nl nm nn no b">pip freeze</code>等。相比之下，JavaScript中的NPM是你唯一需要的工具。</p><h2 id="ece9" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎并发</h2><p id="136a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Python不是在mind中创建的，只有基本的并发支持。</p><h2 id="635f" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎无效的</h2><p id="8dd4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在Python中，所有引用都是可空的。</p><h2 id="c939" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎错误处理</h2><p id="6420" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">捕捉/抛出错误是首选的错误处理机制。</p><h2 id="5fe8" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎不变</h2><p id="6dce" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">没有对不可变的T2数据结构的内置支持。</p><h2 id="36b8" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7110d97cac84665f27fbfa2a94bc0827.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*OBGMrbqEbZ_37MvR9j5jfA.png"/></div></figure><p id="9a43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python对函数式编程没有合适的支持，真的很不幸。函数式编程非常适合数据科学试图解决的问题。即使对于像web抓取这样非常复杂的任务，函数式语言(比如Elixir)也更适合。</p><p id="2e14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不建议在大型项目中使用Python，因为这种语言并没有考虑到严肃的软件工程。</p><p id="18ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python不应该用于数据科学之外的任何领域，因为没有其他替代方法可用。<a class="ae lq" href="https://en.wikipedia.org/wiki/Julia_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Julia </a>似乎是Python在数据科学领域的一个很好的现代替代品，尽管它的生态系统远没有Python的成熟。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4735" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">以打字打的文件</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/fe4bb1ce8fa09174884806fc9d4789c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*Nx4nt_MUJj_tToFkoZ6pVQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7110d97cac84665f27fbfa2a94bc0827.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*OBGMrbqEbZ_37MvR9j5jfA.png"/></div></figure><p id="7ab5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript是一种编译成js的语言。它的主要目标是通过在JavaScript中添加静态类型来制作“更好的JavaScript”。就像JavaScript一样，TypeScript正被用于前端和后端开发。</p><p id="dc4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript是由安德斯·海尔斯伯格设计的，他也是设计C#的人。TypeScript代码感觉非常C-sharpy，基本上可以认为是浏览器的C#。</p><p id="0fc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> C </strong>。</p><h2 id="82a2" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎JavaScript的超集</h2><p id="52b9" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">是的，作为JavaScript的超集对TypeScript的采用帮助很大。毕竟，很多人已经知道JavaScript了。</p><p id="be32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，作为JavaScript的超集更多的是一个缺点。这意味着TypeScript承载了所有的JavaScript包袱。它受限于JavaScript中所有糟糕的设计决策。</p><p id="d03a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">比如你们有多少人喜欢<code class="fe nl nm nn no b">this</code>这个关键词？可能没有人，但TypeScript已有意决定保持这一点。</p><p id="aecf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类型系统有时表现得很奇怪怎么样？</p><pre class="kj kk kl km gt pj no pk pl aw pm bi"><span id="906d" class="nr lz it no b gy pn po l pp pq">[] == ![];    // -&gt; true<br/>NaN === NaN;  // -&gt; false</span></pre><p id="ee09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，TypeScript具有JavaScript的所有缺点。成为一种坏语言的超集不会变成好语言。</p><h2 id="dc49" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍生态系统</h2><p id="9e72" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">TypeScript可以访问整个JavaScript生态系统，这是非常庞大的。巨大的收益。使用Node Package Manager是一件非常愉快的事情，尤其是与Python等其他语言相比。</p><p id="f438" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">缺点是并不是所有的JavaScript库都有可用的TypeScript声明。想想Ramda，Immutable.js。</p><h2 id="b171" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌类型系统</h2><p id="a40c" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我对TypeScript中的类型系统不太激动，还可以。</p><p id="cc00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的一面是，它甚至支持代数数据类型(有区别的联合):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9c26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一下ReasonML中实现的相同代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1046" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript语法不如函数式语言好。在TypeScript 2.0中，有区别的联合是后来才添加的。在<code class="fe nl nm nn no b">switch</code>中，我们在容易出错的字符串上进行匹配，如果我们错过了一个案例，编译器不会警告我们。</p><p id="607b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript仅提供基本的类型推断。此外，当使用TypeScript时，您会发现使用<code class="fe nl nm nn no b">any</code>比您希望的更频繁。</p><h2 id="4254" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌无效的</h2><p id="7b04" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">TypeScript 2.0增加了对不可空类型的支持，可以选择使用<code class="fe nl nm nn no b">--strictNullChecks</code>编译器标志来启用它。但是……用不可空类型编程不是默认的，在TypeScript中也不被认为是惯用的。</p><h2 id="a033" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎错误处理</h2><p id="bae4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在TypeScript中，通过抛出/捕获异常来处理错误。</p><h2 id="5664" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎新的JS特性</h2><p id="c5d7" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">JavaScript比TypeScript更快获得对新功能的支持。甚至可以使用Babel在JavaScript中启用实验性的特性，这对于TypeScript是做不到的。</p><h2 id="b766" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎不变</h2><p id="0428" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在TypeScript中处理不可变的数据结构要比在JavaScript中糟糕得多。虽然JavaScript开发人员可以使用有助于不变性的库，但TypeScript开发人员通常不得不依赖于本机数组/对象传播运算符(写入时复制):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9cb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，本机扩展操作符不执行深度复制，并且手动扩展深度对象很麻烦。复制大型数组/对象对性能也没有好处。</p><p id="1678" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript中的<code class="fe nl nm nn no b">readonly</code>关键字很好，它使得属性不可变。然而，离支持合适的不可变数据结构还有很长的路要走。</p><p id="a924" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript有很好的库来处理不可变数据(比如Rambda/Immutable.js)。然而，让这样的库与TypeScript类型系统一起工作可能会很棘手。</p><h2 id="3259" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎TypeScript &amp; React——地狱里的一对？</h2><blockquote class="nd ne nf"><p id="3216" class="ku kv mr kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">在JavaScript[和TypeScript]中处理不可变数据比在为其设计的语言中更困难，比如<a class="ae lq" href="https://clojure.org/" rel="noopener ugc nofollow" target="_blank"> Clojure </a>。</p><p id="b4d1" class="ku kv mr kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">-直接来自<a class="ae lq" href="https://reactjs.org/docs/update.html" rel="noopener ugc nofollow" target="_blank"> React文档</a></p></blockquote><p id="744a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">继续前面的缺点，如果你正在做前端web开发，那么你有可能使用React。</p><p id="5b2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React不是为TypeScript设计的。React最初是为函数式语言设计的(稍后会详细介绍)。编程范式之间存在冲突——type script是OOP优先，而React是函数优先。</p><p id="2114" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React期望它的props(即函数参数)是不可变的，而TypeScript对<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变的</a>数据结构没有合适的内置支持。</p><p id="8b05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与JavaScript相比，TypeScript为React开发提供的唯一真正的好处是不必担心PropTypes。</p><h2 id="5759" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">TypeScript还是Hypescript？</h2><p id="6d8a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">TypeScript只是炒作吗？这由你决定。我觉得是。它最大的好处是可以访问整个JavaScript生态系统。</p><p id="bd4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，为什么HypeScript如此受欢迎呢？Java和C#流行的原因是一样的——得到了拥有巨额营销预算的数十亿公司的支持。</p><h2 id="05db" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7110d97cac84665f27fbfa2a94bc0827.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*OBGMrbqEbZ_37MvR9j5jfA.png"/></div></figure><p id="d7e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然TypeScript通常被认为是“更好的JavaScript”，但我对它的评价低于JavaScript。它比JavaScript提供的好处被高估了，特别是对于使用React的前端web开发。</p><p id="372a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript保留了JavaScript所有不好的部分，实际上继承了几十年来JavaScript中糟糕的设计决策，这确实是失败的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="bacf" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">去</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/7090ffb49a5b930a8957d859678a3de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*tH31jAu2X4dJbHAFCvuYhA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/e0fc2b56a5c87582a97204847770474a.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*dtfqjauA1Rvt0pbvNsLrkA.png"/></div></figure><p id="9e94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go旨在帮助提高多核处理器和大型代码库时代的编程效率。Go的设计者主要是因为他们都不喜欢当时在谷歌广泛使用的C++。</p><p id="1f92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> C </strong>。</p><h2 id="2678" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍并发</h2><p id="b012" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">并发性是Go的“杀手锏”特性，Go是为并发性而从头开始构建的。就像Erlang/Elixir一样，Go遵循并发的邮箱模型。不幸的是，Go中的goroutines不提供Erlang/Elixir进程所具有的容错特性。换句话说，goroutine中的异常会导致整个程序停止运行，而Elixir进程中的异常只会导致那个进程停止运行。</p><h2 id="bdaa" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍速度</h2><p id="d7e8" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">谷歌创造Go的主要原因之一是编译速度。甚至有一个笑话说，谷歌在等待他们的C++代码编译时创建了Go。</p><p id="6e31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">围棋是一种快速语言。围棋程序的启动时间非常快。Go编译成原生代码，所以它的运行速度也很惊人。</p><h2 id="84fe" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍学习努力</h2><p id="3892" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Go是一门简单的语言，有以前编程经验的人大概一个月左右就能学会。</p><h2 id="ff27" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍错误处理</h2><p id="7953" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Go不支持异常。相反，Go让开发人员显式地处理可能的错误。与Rust类似，Go返回两个值——调用的结果和潜在的错误。如果一切顺利，那么误差将为零:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="a914" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍没有面向对象的编程</h2><p id="e2c9" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">虽然有些人可能不同意，但我个人认为缺乏OOP特性是一个很大的优势。</p><p id="a6eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重复Linus Torvalds:</p><blockquote class="oe"><p id="fc41" class="of og it bd oh oi ov ow ox oy oz lp dk translated"><em class="oo"> C++是一种可怕的[面向对象]语言……将你的项目限制为C意味着人们不会用任何白痴的“对象模型”C来搞砸事情&amp;@ p .<br/>——Linus Torvalds，Linux的创造者</em></p></blockquote><p id="e662" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">Linus Torvalds因公开批评C++和OOP而广为人知。他100%正确的一点是<em class="mr">限制了</em>程序员的选择。事实上，程序员的选择越少，他们的代码就越有弹性。</p><p id="baba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我看来，Go有意省略了很多OOP特性，以免重蹈C++的覆辙。</p><h2 id="ca2a" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌生态系统</h2><blockquote class="nd ne nf"><p id="7b56" class="ku kv mr kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">一些标准库真的很笨。它的很大一部分与Go自己返回带外错误的哲学不一致(例如，它们返回一个类似-1的值作为索引，而不是<code class="fe nl nm nn no b"><em class="it">(int, error)</em></code>)，其他的依赖于全局状态，例如<code class="fe nl nm nn no b"><em class="it">flag</em></code>和<code class="fe nl nm nn no b"><em class="it">net/http</em></code>。</p></blockquote><p id="52db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go的标准库中缺乏标准化。例如，有些库在出错时返回<code class="fe nl nm nn no b">(int, error)</code>，有些库返回值类似<code class="fe nl nm nn no b">-1</code>，而有些库依赖全局状态，例如<code class="fe nl nm nn no b">flag</code>。</p><p id="cfdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个生态系统没有JavaScript大。</p><h2 id="5fcd" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎类型系统</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/9257fe4c6c8a949a655d11ed32e32c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*59MR7_xA1YrdHs8U.png"/></div></div></figure><p id="27fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几乎每种现代编程语言都有某种形式的泛型(包括可怕的C#/Java，甚至C++也有模板)。泛型允许开发者重用不同类型的函数实现。如果没有泛型，你将不得不为整数、双精度数和浮点数分别实现<code class="fe nl nm nn no b">add</code>函数，导致大量代码重复。换句话说，Go 中<a class="ae lq" href="https://www.reddit.com/r/ProgrammerHumor/comments/eho336/larry_tesler_did_not_have_go_in_mind_when_he/" rel="noopener ugc nofollow" target="_blank">缺乏泛型导致了大量的重复代码。正如一些人所说，“Go”是“去写一些样板文件”的缩写</a></p><h2 id="1b7c" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎无效的</h2><p id="c205" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">不幸的是，当更安全的替代方法已经存在了几十年的时候，Go却在语言中加入了空值。</p><h2 id="f5a7" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎不变</h2><p id="9a86" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Go没有对不可变数据结构的内置支持。</p><h2 id="66fd" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/e0fc2b56a5c87582a97204847770474a.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*dtfqjauA1Rvt0pbvNsLrkA.png"/></div></figure><blockquote class="oe"><p id="4a92" class="of og it bd oh oi oj ok ol om on lp dk translated">围棋不是一门好语言。还不错；就是不好。我们必须小心使用不好的语言，因为如果我们不小心，我们可能会在接下来的20年里一直使用它们。</p><p id="5d54" class="of og it bd oh oi ov ow ox oy oz lp dk translated">——威尔·雅戈在<a class="ae lq" href="http://yager.io/programming/go.html" rel="noopener ugc nofollow" target="_blank">为什么围棋不行</a></p></blockquote><p id="b956" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">如果你不是Google，也没有类似Google的用例，那么Go可能不是一个好的选择。Go是一种最适合系统编程的简单语言。对于API开发来说，Go并不是一个很好的选择(因为有更好的选择，稍后会有更多的介绍)。</p><p id="1425" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为总的来说，Go比Rust更好(尽管类型系统更弱)。它是一种简单的语言，速度非常快，容易学习，并且具有很好的并发特性。是的，Go成功地完成了它成为“更好的C++”的设计目标。</p><h2 id="4d07" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">最佳系统语言奖</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/93ca07569b8ff9da1208b8c9d1583625.png" data-original-src="https://miro.medium.com/v2/resize:fit:166/format:webp/1*hZKZMyfynZ664pj97oPJpA.png"/></div></div></figure><p id="f1f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">最佳系统语言</strong>奖即将揭晓。毫无疑问，Go是系统编程的不二之选。Go是一种低级语言，它非常适合这个领域的事实已经被大量用它构建的成功项目所证实，比如Kubernetes、Docker和Terraform。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1875" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">锈</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/9825796441fabd6c6374234fe3dc4e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*FMNHqDU0UzSkyvJKx-TQig.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/e0fc2b56a5c87582a97204847770474a.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*dtfqjauA1Rvt0pbvNsLrkA.png"/></div></figure><p id="7167" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Rust是一种现代低级语言，最初是作为C++的替代品而设计的。</p><p id="3179" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> C </strong>。</p><h2 id="3441" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍速度</h2><p id="4de4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Rust从一开始就被设计得很快。Rust程序的编译时间比Go程序的编译时间长。Rust程序的运行时性能比Go快一点。</p><h2 id="80db" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍无效的</h2><p id="f764" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">这是我们列表中第一种带有现代零替代的语言！Rust没有null或nil值，Rust开发人员使用<code class="fe nl nm nn no b">Option</code>模式代替。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="92d8" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍错误处理</h2><p id="4b63" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Rust采用现代的函数方法来处理错误，并使用专用的<code class="fe nl nm nn no b">Result</code>类型来表示可能失败的操作。这与上面的<code class="fe nl nm nn no b">Option</code>非常相似，然而<code class="fe nl nm nn no b">None</code>案例现在也有了价值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="8294" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎并发</h2><p id="7a60" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">由于缺乏垃圾收集，并发性在Rust中相当困难。开发人员不得不担心装箱和固定之类的事情，这通常是在垃圾收集语言中自动完成的。</p><h2 id="fe06" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎生态系统</h2><p id="21b1" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">截至撰写本文时，Rust生态系统仍在开发中，还不太成熟。</p><h2 id="b36d" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎低级语言</h2><p id="96b6" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">作为一种低级语言，Rust中的开发者生产力不可能像其他高级语言那样高。这也使得学习变得更加困难。</p><h2 id="f6e6" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/e0fc2b56a5c87582a97204847770474a.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*dtfqjauA1Rvt0pbvNsLrkA.png"/></div></figure><p id="b5e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Rust非常适合系统编程。虽然比Go更复杂，但它提供了一个强大的类型系统，总体来说是一种更好的语言。Rust为nulls提供了一种现代的替代方法和一种处理错误的现代方法。</p><p id="8dc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么Rust的排名仍然低于JavaScript？这是一种为系统编程设计的低级语言。Rust不太适合后端/Web API开发，它的生态系统不像其他语言那样发达。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="59f2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Java Script语言</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/2708d2bb630c5e64a8896e4a822c18be.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*lXUoWcu97jvGX3_sv0zfZw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/e0fc2b56a5c87582a97204847770474a.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*dtfqjauA1Rvt0pbvNsLrkA.png"/></div></figure><p id="f58f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为世界上最流行的编程语言，JavaScript不需要介绍。</p><p id="387e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不，这不是一个错误——JavaScript确实排在Rust、TypeScript和Go之上。让我们找出原因。</p><p id="6f1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> C </strong>。</p><h2 id="5ee6" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍生态系统</h2><p id="fe7d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">JavaScript最大的好处是它的生态系统。JavaScript正被用于你能想到的一切——前端/后端web开发、CLI编程、数据科学，甚至机器学习。JavaScript可能有一个你能想到的所有东西的库。</p><h2 id="6e9b" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍学习努力</h2><p id="455b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">JavaScript(还有Python)是最容易学习的编程语言之一。一个人可以在几周内变得高效。</p><h2 id="1252" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎类型系统</h2><p id="4c8b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">就像Python一样，JavaScript是动态类型化的。没什么好说的了。JavaScript的类型系统有时会非常奇怪:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="55cb" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌不变</h2><p id="06c2" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">正如在TypeScript一节中已经提到的，spread操作符可能会降低性能，甚至在复制对象时不执行深度复制。JavaScript缺乏对不可变数据结构的内置支持，尽管有一些库可以提供帮助(Ramda/Immutable.js)。</p><h2 id="f199" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎React不是为JavaScript设计的</h2><p id="11b6" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在JavaScript中使用React时，必须使用PropTypes。然而，这也意味着必须维护PropTypes，这可能成为一场噩梦。</p><p id="7706" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，如果不小心的话，可能会引入微妙的性能问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a047" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种看似无辜的代码可能成为性能噩梦，因为在JavaScript <code class="fe nl nm nn no b">[] != []</code>中。上面的代码将导致<code class="fe nl nm nn no b">HugeList</code>在每次更新时重新呈现，即使<code class="fe nl nm nn no b">options</code>的值没有改变。这样的问题会越来越多，直到UI最终变得无法使用。</p><h2 id="1eb5" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎<code class="fe nl nm nn no b">this</code>关键字</h2><p id="126f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">JavaScript最大的反特性可能是<code class="fe nl nm nn no b">this</code>关键字。它的行为一贯不一致。它很挑剔，在不同的上下文中可能意味着完全不同的东西。它的行为甚至取决于谁调用了给定的函数。使用这个关键字经常会导致难以调试的微妙而奇怪的错误。</p><h2 id="b4f4" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌并发</h2><p id="9a1f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">JavaScript支持使用事件循环的单线程并发。这消除了对线程同步机制(如锁定)的需要。尽管JavaScript并没有考虑到并发性，但是与大多数其他语言相比，使用并发代码要容易得多。</p><h2 id="9f41" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍新的JS特性</h2><p id="157b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">JavaScript比TypeScript更快获得对新功能的支持。通过使用Babel，甚至可以在JavaScript中启用实验性功能。</p><h2 id="5c94" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎错误处理</h2><p id="3f1f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">捕捉/抛出错误是首选的错误处理机制。</p><h2 id="b0f4" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/e0fc2b56a5c87582a97204847770474a.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*dtfqjauA1Rvt0pbvNsLrkA.png"/></div></figure><p id="31b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript不是一种设计良好的语言。JavaScript的初始版本是在十天内完成的(尽管未来的版本已经解决了它的许多缺点)。</p><p id="dcde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管有缺点，JavaScript对于全栈web开发来说是一个不错的选择。有了适当的纪律和林挺，JavaScript可以成为一门好语言。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4615" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">函数式编程==安心</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/bb044ad4e1af84ab82ad6b8b7f760179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y23gE1vV5Ta8ba4DPFJSEA.jpeg"/></div></div><p class="pb pc gj gh gi pd pe bd b be z dk translated">照片由<a class="ae lq" href="https://unsplash.com/@ante_kante?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安特·汉默斯米特</a>在<a class="ae lq" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="252d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在继续我们的排名之前，我们先绕个小弯。为什么要用函数式编程呢？因为函数式编程让我们<em class="mr">安心。</em></p><p id="6cf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，函数式编程可能听起来很可怕，但实际上，没什么可怕的。简单地说，函数式语言做出了许多<em class="mr">正确的设计决策</em>，而其他人却做出了错误的决策。在大多数情况下，函数式语言都有合适的特性:强大的类型系统，支持代数数据类型，没有空值，没有错误处理异常，内置的不可变数据结构，模式匹配和函数组合操作符。</p><p id="0807" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数式编程语言有哪些共同的优势让它们在我们的排名中如此靠前？</p><h2 id="83f2" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">纯函数编程</h2><p id="a400" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">与命令式(主流语言)不同，函数式编程语言鼓励用<em class="mr">纯</em>函数编程。</p><p id="0d95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么是纯函数？这个想法非常简单——给定相同的输入，一个纯函数将总是返回相同的输出。例如，<code class="fe nl nm nn no b">2 + 2</code>将始终返回<code class="fe nl nm nn no b">4</code>，这意味着加法运算符<code class="fe nl nm nn no b">+</code>是一个纯函数。</p><p id="49f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">纯函数不允许与外界交互(进行API调用，甚至写入控制台)。他们甚至不允许改变状态。这与OOP所采用的方法正好相反，在OOP中，任何方法都可以随意改变其他对象的状态。</p><p id="c9d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很容易区分纯函数和不纯函数——函数是不带参数，还是不返回值？那么它就是一个不纯函数。</p><p id="a9f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是几个不纯函数的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="57f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和几个纯函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="45fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法似乎非常有限，需要一些时间来适应。一开始我确实很困惑！</p><p id="af9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">纯函数有什么好处？这很容易测试(不需要模拟和存根)。关于纯函数的推理很容易——不像在OOP中，不需要记住整个应用程序的状态。你只需要担心你正在工作的当前函数。</p><p id="1596" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">纯函数很容易组合。纯函数非常适合并发，因为函数之间不共享状态。重构纯粹的函数是纯粹的快乐——只是复制和粘贴，不需要复杂的IDE工具。</p><p id="dfc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，纯函数将快乐带回到编程中。</p><p id="ee67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数式编程鼓励使用纯函数——当90%以上的代码库由纯函数组成时，这很好。一些语言将这一点发挥到了极致，完全禁止非纯函数(这并不总是一个好主意)。</p><h2 id="e896" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">不可变数据结构</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/0f10cdd898b18e42645476b077cfb376.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*4Ll21mV5rnojqyPO0UdpEQ.png"/></div></figure><p id="3791" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面所有的函数式语言都内置了对<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变</a>数据结构的支持。数据结构也是<em class="mr">持久的</em>。这仅仅意味着，无论何时进行更改，我们都不必创建整个结构的深层副本。想象一下，一次又一次地复制超过100，000个项目的数组，一定很慢，对吗？</p><p id="1e3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">持久性数据结构只是重用对旧数据结构的引用，同时添加所需的更改，而不是创建副本。</p><h2 id="e001" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">代数数据类型</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/1a88ceb3f2aefc59c888c24b6802395d.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*eDq6g8kW45BUvq4CfgyG9g.png"/></div></figure><p id="92b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ADT是一种建模应用程序状态的强大方法。人们可以认为他们是服用了类固醇的Enums。我们指定了可能组成我们的类型的“子类型”,以及它的构造函数参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4ba6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的“形状”类型可以是<code class="fe nl nm nn no b">Square</code>、<code class="fe nl nm nn no b">Rectangle</code>或<code class="fe nl nm nn no b">Circle</code>。<code class="fe nl nm nn no b">Square</code>构造函数采用单个<code class="fe nl nm nn no b">int</code>参数(宽度)，<code class="fe nl nm nn no b">Rectangle</code>采用两个<code class="fe nl nm nn no b">int</code>参数(宽度和高度)，<code class="fe nl nm nn no b">Circle</code>采用单个<code class="fe nl nm nn no b">int</code>参数(其半径)。</p><p id="cccc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是用Java实现的类似代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="22fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不知道你怎么想，但是我肯定会选择前一个版本——在函数式语言中使用ADT。</p><h2 id="0bd3" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">模式匹配</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/0f2327f754058448c97a2f7699c946c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*tWlxgrAoEkXN9tRu-dvoMA.png"/></div></figure><p id="1c64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有的函数式语言都非常支持模式匹配。一般来说，模式匹配允许编写非常有表现力的代码。</p><p id="6dfb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个关于<code class="fe nl nm nn no b">option(bool)</code>类型的模式匹配的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="cc54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是相同的代码，没有模式匹配:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d0e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">毫无疑问，模式匹配版的表现力强多了，也干净多了。</p><p id="ed16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模式匹配还提供编译时穷举保证，这意味着我们不会忘记检查可能的情况。在非功能性语言中没有这样的保证。</p><h2 id="0561" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">无效的</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/2b1f06f98700c5f075602c1c7b4c344e.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*VB3sHbpJAtenCRYGzvWrsg.png"/></div></figure><p id="638a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数式编程语言通常避免使用空引用。而是使用<code class="fe nl nm nn no b">Option</code>模式(类似于Rust):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="9ced" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">错误处理</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/d7b779d42ba45359406b274217c02abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*n5Xo7XE9ZB4I-U6R0cPyyA.png"/></div></figure><p id="77fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数式语言通常不鼓励使用异常。相反，使用<code class="fe nl nm nn no b">Result</code>模式(再次类似于Rust):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="97d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于函数式错误处理的介绍，请务必阅读OCaml 中的<a class="ae lq" href="https://keleshev.com/composable-error-handling-in-ocaml" rel="noopener ugc nofollow" target="_blank">可组合错误处理。</a></p><h2 id="3566" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">管道转发操作员</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/302d9ea88d6f758b9b812a5098fb1b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*ImQTFdaczUMFhxrpIGdJ_A.png"/></div></figure><p id="200f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有管道转发操作符，函数调用往往会变得嵌套很深，从而降低可读性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="aee0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数式语言有一个特殊的管道操作符，使这项任务变得容易得多:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="95b4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">哈斯克尔</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/9a957854c40d95ce24ab35162c797a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*FuriusxduWPT_PjuzQKQOA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/ebfaa75e16690186427e5d37f29a06e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*IuGZE_Nhzamew8hfy8f2Iw.png"/></div></figure><p id="9f60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Haskell完全可以被称为所有函数式编程语言的“母亲”。Haskell已经30岁了——甚至比Java还老。函数式编程中许多最好的想法都起源于Haskell。</p><p id="f101" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> ML </strong>。</p><h2 id="9de9" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍类型系统</h2><p id="ffb0" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">没有比Haskell更强大的类型系统了。显然，Haskell支持代数数据类型，但它也支持typeclasses。它的类型检查器能够推断出几乎任何东西。</p><h2 id="dd59" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎👎学习努力</h2><p id="3c35" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">哦天啊！众所周知，为了高效地使用Haskell，首先必须精通范畴理论(我不是在开玩笑)。OOP需要多年的经验才能写出像样的代码，而Haskell需要在学习上投入大量的精力，才能有所作为。</p><p id="0210" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用Haskell编写一个简单的“hello world”程序也需要理解单子(尤其是IO单子)。</p><h2 id="81f3" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎👎社区</h2><blockquote class="oe"><p id="f370" class="of og it bd oh oi ov ow ox oy oz lp dk translated">根据我的经验，Haskell社区更加学术化。Haskell libraries邮件列表上最近的一篇文章是这样开始的:</p><p id="ec83" class="of og it bd oh oi ov ow ox oy oz lp dk translated">“在一次私人交流中有人向我指出，元组函数\x-&gt;(x，x)实际上是双应用和一些相关结构单向对角化的特例。”</p><p id="9ccd" class="of og it bd oh oi ov ow ox oy oz lp dk translated">它收到了39个相当热情的回复。</p><p id="1756" class="of og it bd oh oi ov ow ox oy oz lp dk translated">——momentoftop上<a class="ae lq" href="https://news.ycombinator.com/item?id=24978238" rel="noopener ugc nofollow" target="_blank">黑客新闻</a></p></blockquote><p id="0836" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">上面的引用很好地总结了Haskell社区。Haskell社区对学术讨论(和范畴理论)比对解决现实世界的问题更感兴趣。</p><h2 id="c3a1" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎功能纯度</h2><p id="ee19" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">正如我们已经了解到的，纯函数是惊人的。副作用(如与外界交互，包括状态突变)是导致程序大量错误的原因。作为一种纯粹的<em class="mr">函数式语言，Haskell完全不允许它们。这意味着函数永远不能改变任何值，甚至不允许与外界交互(甚至像日志这样的事情在技术上也是不允许的)。</em></p><p id="f4e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，Haskell提供了与外界交互的工作区。你可能会问，它是如何工作的？我们提供一套<em class="mr">指令</em> <strong class="kw iu"> </strong> (IO单子)。这样的指令可能会说，“读取键盘输入，然后在某个函数中使用该输入，然后将结果打印到控制台。”然后语言运行时接受这样的指令并为我们执行它们。我们从不执行与外界直接交互的代码。</p><blockquote class="oe"><p id="9d25" class="of og it bd oh oi ov ow ox oy oz lp dk translated">不惜一切代价避免成功！</p><p id="093b" class="of og it bd oh oi ov ow ox oy oz lp dk translated">—哈斯克尔的非官方座右铭。</p></blockquote><p id="e9d8" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">在实践中，这种对功能纯度的关注显著增加了抽象的数量，这增加了复杂性，并且因此<em class="mr">降低了开发人员的生产力</em>。</p><h2 id="3d17" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍无效的</h2><p id="ab67" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">就像Rust一样，Haskell没有空引用。它使用选项模式来表示可能不存在的值。</p><h2 id="362e" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍错误处理</h2><p id="120f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">虽然有些函数可能会抛出错误，但惯用的Haskell代码使用的模式类似于Rust中的<code class="fe nl nm nn no b">Result</code>类型。</p><h2 id="4b8f" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍不变</h2><p id="a68f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Haskell对不可变的T2数据结构有一流的支持。</p><h2 id="fa4e" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍模式匹配</h2><p id="9bc7" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Haskell有很好的模式匹配支持。</p><h2 id="cdcc" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎生态系统</h2><p id="fbce" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">标准库很乱，特别是默认的prelude(核心库)。默认情况下，Haskell使用抛出异常的函数，而不是返回<em class="mr">选项</em> <strong class="kw iu"> <em class="mr"> </em> </strong>值(函数式编程的黄金标准)。更糟糕的是，Haskell有两个包管理器——Cabal和Stack。</p><h2 id="cfa6" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated"><strong class="ak">判决结果</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/ebfaa75e16690186427e5d37f29a06e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*IuGZE_Nhzamew8hfy8f2Iw.png"/></div></figure><blockquote class="oe"><p id="4c0c" class="of og it bd oh oi oj ok ol om on lp dk translated"><strong class="ak"> <em class="oo">硬核</em> </strong> <em class="oo">函数式编程永远不会成为主流——它需要深入理解许多高度抽象的概念。</em></p><p id="555a" class="of og it bd oh oi ov ow ox oy oz lp dk translated">— David Bryant Copeland在<a class="ae lq" href="https://naildrivin5.com/blog/2019/07/25/four-better-rules-for-software-design.html#conceptual-overhead-creates-confusion-and-complexity" rel="noopener ugc nofollow" target="_blank">软件设计的四个更好的规则</a></p></blockquote><p id="05ff" class="pw-post-body-paragraph ku kv it kw b kx op ju kz la oq jx lc ld or lf lg lh os lj lk ll ot ln lo lp im bi translated">我真的很想喜欢哈斯克尔。不幸的是，哈斯克尔很可能永远被局限在学术界。这是一门很好的语言，我只希望它更实用。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2da5" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">OCaml</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/843dbf744d818e3a3ac271d24ec1f39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*IbB7WSa0aPdzDZCwLkZipQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/ebfaa75e16690186427e5d37f29a06e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*IuGZE_Nhzamew8hfy8f2Iw.png"/></div></figure><p id="dfd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">OCaml是一种函数式编程语言。OCaml代表Object <a class="ae lq" href="https://en.wikipedia.org/wiki/Caml" rel="noopener ugc nofollow" target="_blank"> Caml </a>，然而，具有讽刺意味的是，你将<a class="ae lq" href="https://stackoverflow.com/questions/10779283/when-should-objects-be-used-in-ocaml" rel="noopener ugc nofollow" target="_blank">很少发现有人使用OCaml中的对象。</a></p><p id="9db5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">OCaml几乎和Java一样古老，名字中的“对象”部分大概反映了那个时代对“对象”的大肆宣传。OCaml只是从Caml停止的地方继续。</p><p id="e75e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> ML </strong>。</p><h2 id="9e61" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍类型系统</h2><p id="cf9f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">OCaml的类型系统几乎和Haskell一样好。最大的缺点是缺少typeclasses，但是它支持函子(高阶模块)。</p><p id="f905" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">OCaml是静态类型的——它的类型推断几乎和Haskell一样好。</p><h2 id="192c" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎👎生态系统</h2><p id="8a85" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">OCaml社区很小，这意味着您不会找到用于常见用例的高质量库。例如，OCaml缺乏一个像样的web框架。</p><p id="71de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与其他语言相比，OCaml库的文档相当糟糕。</p><h2 id="c833" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎工具作业</h2><p id="1ec0" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">明面上一塌糊涂。有三个包管理器——Opam、Dune和Esy。</p><p id="579d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">OCaml以非常糟糕的编译器错误消息而闻名。虽然这不是一个交易破坏者，但这有点令人沮丧，并且会影响开发人员的生产力。</p><h2 id="3820" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎学习资源</h2><p id="06e9" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">学习OCaml的最佳途径是<a class="ae lq" href="https://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X" rel="noopener ugc nofollow" target="_blank">真实世界OCaml </a>。这本书自2013年以来就没有更新过，许多例子都已经过时了。用现代工具是不可能照本宣科的。</p><p id="2e23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语言教程通常非常糟糕(与其他语言相比)。它们大多是学术课程的课堂笔记。</p><h2 id="a6ef" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎并发</h2><p id="e05e" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">“多核即将到来，Now™️”总结了OCaml中的并发性。OCaml开发人员多年来一直在等待合适的多核支持，看起来它不会在不久的将来被添加到语言中。OCaml似乎是唯一缺乏适当多核支持的函数式语言。</p><h2 id="6c81" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍无效的</h2><p id="88fc" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">OCaml没有空引用，使用Option模式来表示可能不存在的值。</p><h2 id="b5e6" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍错误处理</h2><p id="be2f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">惯用的OCaml代码使用<code class="fe nl nm nn no b">Result</code>类型模式。</p><h2 id="4cd7" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍不变</h2><p id="f1b3" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">OCaml对不可变的T4数据结构有一流的支持。</p><h2 id="c5de" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍模式匹配</h2><p id="4b70" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">OCaml有很好的模式匹配支持。</p><h2 id="0ac7" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/ebfaa75e16690186427e5d37f29a06e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*IuGZE_Nhzamew8hfy8f2Iw.png"/></div></figure><p id="2434" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">OCaml是一种很好的函数式语言。它的主要缺点是较差的并发支持和一个小社区(因此是一个小的生态系统和缺乏学习资源)。</p><p id="21c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">鉴于它的缺点，我不建议在生产中使用OCaml。</p><ul class=""><li id="3264" class="py pz it kw b kx ky la lb ld qa lh qb ll qc lp qd qe qf qg bi translated"><a class="ae lq" href="https://blog.darklang.com/leaving-ocaml/" rel="noopener ugc nofollow" target="_blank">离开OCaml </a></li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f817" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">斯卡拉</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/a88d8f28cf3022db2835765d60cf9d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*3YvmksPPR068HBXkGkHADg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/ebfaa75e16690186427e5d37f29a06e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*IuGZE_Nhzamew8hfy8f2Iw.png"/></div></figure><p id="1319" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Scala是为数不多的真正多范例语言之一，对面向对象和函数式编程都有很好的支持。</p><p id="6db5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> C </strong>。</p><h2 id="be9c" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍生态系统</h2><p id="b7cc" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Scala运行在Java虚拟机之上，这意味着它可以访问庞大的Java库生态系统。这对于从事后端工作的开发人员来说是一个真正的福音。</p><h2 id="7418" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍类型系统</h2><p id="424c" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Scala可能是唯一一种类型化的函数式语言，它的类型系统不健全，也缺乏正确的类型推断。Scala中的类型系统不如其他函数式语言。</p><p id="ccde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的一面是，Scala支持更高级的类型和类型类。</p><p id="5f0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管有它的缺点，类型系统仍然是非常好的，因此竖起大拇指。</p><h2 id="5f3a" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎简洁/可读性</h2><p id="5e53" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">虽然Scala代码非常简洁，尤其是与Java相比，但是代码可读性不强。</p><p id="813b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Scala是少数几个真正属于C语言家族的函数式语言之一。c系列语言旨在用于命令式编程，而ML系列语言旨在用于函数式编程。因此，在Scala中用类似C的语法进行函数式编程有时会让人感觉很奇怪。</p><p id="7d5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Scala中没有合适的代数数据类型语法，这对可读性有负面影响:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ec1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">合理的ADTs:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7591" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就可读性而言，ML语言中的ADTs是明显的赢家。</p><h2 id="aeb4" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎 👎速度</h2><p id="a567" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">就编译速度而言，Scala可能是最糟糕的编程语言之一。一个简单的“hello world”程序在旧的硬件上编译可能需要10秒钟。Scala编译器不是并发的(使用单核编译代码)，这对编译速度没有帮助。</p><p id="2006" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Scala运行在Java虚拟机之上，这意味着程序启动的时间会更长。</p><h2 id="d51e" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎学习努力</h2><p id="15b2" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Scala有很多特性，这就增加了学习的难度。就像C++一样，这种语言充斥着各种功能。</p><p id="d7b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Scala是最难的函数式语言之一(仅次于Haskell)。事实上，它的可学性差是公司离开Scala的首要决定因素。</p><h2 id="407a" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍不变</h2><p id="f113" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Scala拥有对<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变</a>数据结构的一流支持(使用<em class="mr">用例类</em>)。</p><h2 id="872a" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌无效的</h2><p id="e050" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">缺点是，Scala支持空引用。好的一面是，处理潜在缺失值的惯用方式是使用<code class="fe nl nm nn no b">Option</code>模式(就像其他函数式语言一样)。</p><h2 id="849a" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍错误处理</h2><p id="e553" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">就像在其他函数式语言中一样，Scala习惯使用<code class="fe nl nm nn no b">Result</code>模式进行错误处理。</p><h2 id="2032" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌并发</h2><p id="e14d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Scala运行在JVM之上，而JVM并不是真正为并发性而构建的。从好的方面来看，<a class="ae lq" href="https://en.wikipedia.org/wiki/Akka_(toolkit)" rel="noopener ugc nofollow" target="_blank"> Akka </a>工具包非常成熟，在JVM上提供了类似Erlang的并发性。</p><h2 id="3879" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍模式匹配</h2><p id="ffd1" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Scala有很好的模式匹配支持。</p><h2 id="6985" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/ebfaa75e16690186427e5d37f29a06e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*IuGZE_Nhzamew8hfy8f2Iw.png"/></div></figure><p id="e82f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我真的很想喜欢Scala，但是我就是不能。Scala试图做的太多了。它的设计者不得不做出许多权衡来支持OOP和FP。正如俄罗斯谚语所说，“追逐两只兔子的人一只也抓不到”。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b519" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">榆树</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/9944a6a7e174137581109f1d744ee568.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*bpRljdoYNwkkwzPEQ8_xTg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ab20f3c6c370be870fe7e7d3a328f09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*7zkcv0rLUoLT79Bec9HXNA.png"/></div></figure><p id="f4fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elm是一种编译成js的函数式语言，主要用于前端web开发。</p><p id="537c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elm的独特之处在于它承诺永远不会出现运行时异常。用Elm编写的应用程序非常健壮。</p><p id="9c10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> ML </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8fdc736fc5885c02511daac3ee577fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:2/format:webp/1*caUNu6RMeBKLIht997tR8Q.png"/></div></figure><h2 id="4822" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍非常好的错误信息</h2><p id="0e94" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elm编译器提供了一些我所见过的最好的错误信息，这使得这种语言甚至对于完全的初学者来说也更容易理解。</p><h2 id="eeb4" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍错误处理</h2><p id="c92b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elm没有运行时错误。该语言不支持异常，句号。Elm是一种纯函数式语言，没有运行时异常。这意味着，如果您的代码库是100% Elm，那么您将永远不会看到运行时错误。使用Elm唯一会遇到运行时错误的时候是在与外部JavaScript代码交互的时候。</p><p id="110b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elm如何处理错误？就像许多其他函数式语言一样，使用<code class="fe nl nm nn no b">Result</code>数据类型。</p><h2 id="f3e1" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎功能纯度</h2><p id="615b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">就像Haskell一样，Elm是一种纯函数式语言。</p><p id="3ef3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elm是通过消除所有的运行时异常让您更有效率，还是通过强制在任何地方都保持函数的纯洁性让您效率更低？根据我的经验，Elm中任何重大的重构都是一场噩梦，因为涉及到大量的“管道工程”。</p><p id="d0a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你自己决定吧，但是我会否定榆树的这个特点。</p><h2 id="ad48" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎过于固执己见</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qi"><img src="../Images/5ca08099236e6d7a8146b4140280cf4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WDEERYs8Wc_Cp6Pv.png"/></div></div><p class="pb pc gj gh gi pd pe bd b be z dk translated">在<a class="ae lq" href="https://www.reddit.com/r/ProgrammerHumor/comments/8we9zh/im_learning_elm_and_it_immediately_declared_war/" rel="noopener ugc nofollow" target="_blank"> Reddit上发微博</a></p></figure><p id="ccd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">榆树是一种固执己见的语言。以至于使用制表符被认为是一种语法错误。</p><p id="5fb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elm对“永不出错”的关注正在扼杀这种语言。最新版本(0.19)引入了一个突破性的变化，这使得与JavaScript库的互操作几乎不可能。当然，目的是让人们在Elm中编写自己的库来帮助生态系统成长。然而，很少有公司有资源来重新实施Elm中的所有内容。这使得许多人永远离开了榆树。</p><p id="fb3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elm的设计者似乎过于关注功能的纯粹性，将“永不出错”的理念发挥到了极致。</p><h2 id="419d" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎没有反应</h2><p id="6b10" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elm使用自己的虚拟DOM，不像ReasonML这样的语言，它不使用React。这意味着开发人员无法访问庞大的React库和组件生态系统。</p><h2 id="a17b" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎 👎语言发展</h2><p id="54c9" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">可悲的是，Elm的新版本(0.19.1)已经发布一年多了。开发过程毫无透明度，任何人都无法参与开发。随着每个主要版本的发布，Elm都引入了突破性的变化，这使得一些人无法使用这种语言。我们已经有一年多没有听到它的创造者的任何消息了。我们甚至不知道他是否还在Elm全职工作。这种语言现在可能已经消亡了。</p><h2 id="d68d" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍模式匹配</h2><p id="0979" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elm有很好的模式匹配支持。</p><h2 id="cad1" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍不变</h2><p id="973f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elm对<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变</a>数据结构有一流的支持。</p><h2 id="b6e3" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍无效的</h2><p id="70c4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elm不支持可空引用，就像其他函数式语言一样，它使用了<code class="fe nl nm nn no b">Option</code>模式。</p><h2 id="b0ff" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ab20f3c6c370be870fe7e7d3a328f09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*7zkcv0rLUoLT79Bec9HXNA.png"/></div></figure><p id="0304" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elm是一种优秀的语言。可惜，它似乎没有未来。但是这可能是进入函数式编程的一个好方法。</p><ul class=""><li id="f8d5" class="py pz it kw b kx ky la lb ld qa lh qb ll qc lp qd qe qf qg bi translated">查尔斯·斯卡法尼的《榆树的最大问题》</li><li id="eea9" class="py pz it kw b kx qj la qk ld ql lh qm ll qn lp qd qe qf qg bi translated"><a class="ae lq" href="https://lukeplant.me.uk/blog/posts/why-im-leaving-elm/" rel="noopener ugc nofollow" target="_blank">为什么我要离开卢克·普兰特的榆树</a></li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f6f8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">F#</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/8a040d9398e0b7af749a167e7aa80ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*6XYhMTeTvSLgkiVI3W3Yew.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/c3450ae14c062cf28c5c5441c83d0f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*d0QM_oPhJjHDJ_aR35dGwQ.png"/></div></figure><p id="897f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">F#可以总结为. NET的OCaml，它的语法和OCaml非常相似，只有一些小的区别。F#于2005年首次出现，是一种非常成熟的语言，拥有出色的工具和丰富的生态系统。</p><p id="2809" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> ML </strong>。</p><h2 id="ec05" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍类型系统</h2><p id="5ab2" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">类型系统唯一的缺点是缺少更高级的类型。尽管类型系统非常可靠，编译器仍然能够推断出几乎所有的东西。F#对ADT有适当的支持。</p><h2 id="76ad" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍功能性但不纯粹</h2><p id="5bc0" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">与Haskell/Elm不同，F#非常实用，并且不强制函数的纯洁性。</p><h2 id="64f2" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍学习资源</h2><p id="abd2" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">F#有一些真正<a class="ae lq" href="https://fsharpforfunandprofit.com/" rel="noopener ugc nofollow" target="_blank">好的学习资源</a>，可能与Elixir不相上下。</p><h2 id="8687" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍学习努力</h2><p id="48ef" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">F#是最容易掌握的函数式语言之一。</p><h2 id="344e" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌生态系统</h2><p id="507b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">F#社区相当小，不像像Elixir这样的语言，它没有同样好的库。</p><h2 id="93fe" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍C#互操作</h2><p id="e700" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">从好的方面来说，F#可以访问整个。NET/C#生态系统。与现有C#代码的互操作真的很好。</p><h2 id="a210" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌并发</h2><p id="038d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">F#运行在CLR之上，CLR没有Elixir从Erlang VM中享受到的那种卓越的并发支持(稍后将详细介绍)。</p><h2 id="2844" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍无效的</h2><p id="1e59" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">F#代码中通常不使用空值。它使用选项模式来表示可能不存在的值。</p><h2 id="3f94" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍错误处理</h2><p id="5a79" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">惯用的F#代码使用<code class="fe nl nm nn no b">Result</code>模式进行错误处理。</p><h2 id="fc24" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍不变</h2><p id="a66e" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">F#对<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变</a>数据结构有一流的支持。</p><h2 id="f7c1" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍模式匹配</h2><p id="b803" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">F#有很好的模式匹配支持。</p><h2 id="5863" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/c3450ae14c062cf28c5c5441c83d0f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*d0QM_oPhJjHDJ_aR35dGwQ.png"/></div></figure><p id="0633" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">F#是一种非常可靠的编程语言，具有非常好的类型系统。对于Web API开发来说，它几乎和Elixir一样好(稍后将详细介绍)。但是，F#的问题不在于它有什么，而在于它没有什么。与Elixir相比，它的并发特性、丰富的生态系统和令人惊叹的社区，超过了F#提供的任何静态类型的好处。</p><ul class=""><li id="7d60" class="py pz it kw b kx ky la lb ld qa lh qb ll qc lp qd qe qf qg bi translated">黑暗的新后台将会在F# </li></ul><h2 id="c15a" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">奖金；奖品</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/b49d82641a13d927435a34821f488a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*uSNPih5UwouMt-5PptT3VQ.png"/></div></figure><p id="ee60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">F#获得两项大奖。</p><p id="c8e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">F#获得<strong class="kw iu">fin tech</strong>最佳语言奖。众所周知，金融是F#最大的应用之一。</p><p id="4e64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">F#还获得了<strong class="kw iu">最佳企业软件语言</strong>奖。其丰富的类型系统允许对复杂的业务逻辑进行建模。<a class="ae lq" href="https://pragprog.com/titles/swdddf/domain-modeling-made-functional/" rel="noopener ugc nofollow" target="_blank">领域建模功能化</a>是一本强烈推荐阅读的书。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ec96" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">原因</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/505deb27a77403a3fc568d756f457573.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*pyf_-AQH2lu14dyRnYIH0g.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/36528e6bf5c31deaa27dff81f7c89079.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*4IyuKsPlzIO3q5zKa_pMMA.png"/></div></figure><p id="14dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ReasonML是一种函数式编译成js语言，主要用于前端web开发。</p><p id="4de6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ReasonML不是一种新的语言，它是OCaml(一种古老而久经考验的编程语言)的新语法。脸书支持我。</p><p id="ed93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过利用JavaScript生态系统，ReasonML没有OCaml的缺点。</p><p id="b488" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> ML </strong>。</p><h2 id="a1f2" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍不是JavaScript的超集</h2><p id="76e5" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">ReasonML的语法类似于JavaScript，这使得任何有JavaScript经验的人都更容易理解它。然而，与TypeScript不同，ReasonML甚至没有试图成为JavaScript的超集(正如我们已经了解到的，这是一件好事)。与TypeScript不同，ReasonML不必继承JavaScript几十年来做出的糟糕设计决策。</p><h2 id="fc00" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍学习努力</h2><p id="674d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">由于ReasonML甚至没有试图成为JavaScript的超集，所以它使该语言比JavaScript简单得多。具有JavaScript函数式编程经验的人可以在大约一周内学会ReasonML。</p><p id="014c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ReasonML确实是最简单的编程语言之一。</p><h2 id="cba8" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍功能性的，但不纯粹</h2><p id="6507" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">与Elm不同，ReasonML甚至没有试图成为一种纯粹的函数式语言，也没有“永远没有运行时错误”的目标。这意味着ReasonML非常务实，专注于开发人员的生产力和快速实现结果。</p><h2 id="b1d6" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍类型系统</h2><p id="29e1" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">ReasonML确实是OCaml，这意味着它的类型系统几乎和Haskell的一样好。最大的缺点是缺少typeclasses，但是它支持函子(高阶模块)。</p><p id="f7c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ReasonML是静态类型的，它的类型推断几乎和Haskell一样好。</p><h2 id="b8eb" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍生态系统</h2><p id="8081" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">就像TypeScript一样，ReasonML可以访问整个JavaScript生态系统。</p><h2 id="00f4" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍JavaScript/TypeScript互操作</h2><p id="c1b1" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">ReasonML编译成普通JavaScript。因此，可以在同一个项目中同时使用ReasonML和JavaScript/TypeScript。</p><h2 id="04a0" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍理性和反应——天作之合</h2><p id="fad8" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">如果你正在做前端web开发，那么你很可能正在使用React。您知道React最初是用OCaml编写的，后来才被移植到JavaScript来帮助采用吗？</p><p id="52cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为ReasonML是静态类型的，所以不需要担心PropTypes。</p><p id="b78f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还记得JavaScript一节中那个看似无辜的例子吗？它可能会导致性能灾难。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="aa9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ReasonML对<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变</a>数据结构有适当的支持，这样的代码不会产生性能问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e64d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与JavaScript不同，ReasonML没有任何不必要的重新渲染——开箱即可获得出色的React性能！</p><h2 id="cd81" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎工具作业</h2><p id="226d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">ReasonML不像TypeScript那样成熟，工具上可能会有一些问题。比如官方推荐的VSCode扩展<a class="ae lq" href="https://github.com/jaredly/reason-language-server" rel="noopener ugc nofollow" target="_blank"> reason-language-server </a>目前已经坏了。然而，<a class="ae lq" href="https://github.com/ocamllabs/vscode-ocaml-platform" rel="noopener ugc nofollow" target="_blank">还有其他的选择</a>存在。</p><p id="e436" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ReasonML在幕后使用OCaml编译器，而OCaml以非常糟糕的编译器错误消息而闻名。虽然这不是一个交易破坏者，但这有点令人沮丧，并且会影响开发人员的生产力。</p><p id="05b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望随着语言变得更加成熟，工具会有所改进。</p><h2 id="d4cd" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍无效的</h2><p id="53f4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">ReasonML没有空引用，并使用Option模式来表示可能不存在的值。</p><h2 id="dad6" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍不变</h2><p id="9c58" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">ReasonML对<a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">不可变</a>数据结构有一流的支持。</p><h2 id="95f9" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍模式匹配</h2><p id="7ecc" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">ReasonML有很好的模式匹配支持。</p><h2 id="b3bc" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/36528e6bf5c31deaa27dff81f7c89079.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*4IyuKsPlzIO3q5zKa_pMMA.png"/></div></figure><p id="9cbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ReasonML可能是TypeScript一直想要的，但是失败了。ReasonML向JavaScript添加了静态类型，同时删除了所有不好的特性(并添加了真正重要的现代特性)。</p><h2 id="1d0b" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated"><strong class="ak">最佳前端语言奖</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/a238cad9b805ff239717959d4d6f0ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:166/format:webp/1*UxzOra01CjpZvDpSm1Uw9Q.png"/></div></div></figure><p id="7beb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ReasonML获得了最佳前端语言奖。毫无疑问，ReasonML是前端web开发的最佳选择。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="151b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">长生不老药</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/4b02c64af28c6e41b583289aaf115346.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*6G-q2LUMk0wFO6FcNVdJ0g.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/36528e6bf5c31deaa27dff81f7c89079.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*4IyuKsPlzIO3q5zKa_pMMA.png"/></div></figure><p id="b280" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elixir可能是世界上最流行的函数式编程语言。就像ReasonML一样，Elixir其实并不是一门新语言。相反，Elixir建立在Erlang三十多年的成功之上。</p><p id="e579" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仙丹是围棋的功能表兄弟。就像Go一样，Elixir是为并发性而从头设计的，以利用多个处理器内核。</p><p id="985d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与其他一些函数式语言不同，Elixir非常实用。它专注于获得结果。你不会在Elixir社区找到长时间的学术讨论。<a class="ae lq" href="http://elixirforum.com" rel="noopener ugc nofollow" target="_blank"> Elixir论坛</a>充满了实际问题的解决方案，社区对初学者非常友好。</p><p id="6854" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语系:<strong class="kw iu"> ML </strong>。</p><h2 id="33cc" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍生态系统</h2><p id="5d7a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">真正让仙丹大放异彩的是它的生态系统。在大多数其他语言中，有语言和生态系统——两个独立的东西。在Elixir中，生态系统中的核心框架由核心Elixir团队开发。灵药的创造者José Valim也是灵药生态系统中超级酷的图书馆<a class="ae lq" href="https://github.com/phoenixframework/phoenix" rel="noopener ugc nofollow" target="_blank"> Phoenix </a>和<a class="ae lq" href="https://github.com/elixir-ecto/ecto" rel="noopener ugc nofollow" target="_blank"> Ecto </a>的主要贡献者。</p><p id="a11a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在大多数其他语言中，有许多不同的库专注于同一任务——许多不同的web服务器、许多不同的ORM等等。在Elixir中，开发工作实际上集中在核心的几个库上，这导致了出色的库质量。</p><p id="f407" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elixir库的文档非常好，有大量的例子。与其他一些语言不同，标准库也有很好的文档。</p><h2 id="b7a3" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍凤凰框架</h2><p id="c75b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">凤凰框架的口号是“凤凰就是感觉对”。与其他语言的框架不同，Phoenix内置了很多功能。开箱即用，它支持WebSockets、路由、HTML模板语言、国际化、JSON编码器/解码器、无缝ORM集成(Ecto)、会话、SPA工具包等等。</p><p id="fede" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Phoenix framework以其出色的性能而闻名，能够在一台机器上同时处理<a class="ae lq" href="https://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections" rel="noopener ugc nofollow" target="_blank">百万个连接</a>。</p><h2 id="76be" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍全栈药剂</h2><p id="2651" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Phoenix framework最近引入了<a class="ae lq" href="https://elixirschool.com/blog/phoenix-live-view/" rel="noopener ugc nofollow" target="_blank"> LiveView </a>，它允许在Elixir中构建丰富的实时web界面(想想单页面应用程序)。不需要JavaScript，没有反应！</p><p id="678c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">LiveView甚至负责同步客户端和服务器状态，这意味着我们不必担心开发和维护REST/GraphQL API。</p><h2 id="4ae3" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍数据处理</h2><p id="e91e" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">对于许多与数据处理相关的任务，Elixir可以成为Python的可靠替代品。用Python和Elixir构建了web scraper之后，Elixir为这项任务提供了更好的语言和生态系统。</p><p id="43a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像<a class="ae lq" href="https://github.com/dashbitco/broadway" rel="noopener ugc nofollow" target="_blank">百老汇</a>这样的工具允许在Elixir中建立数据接收/数据处理管道。</p><h2 id="960c" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌类型系统</h2><p id="1dd0" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在我看来，缺乏适当的静态类型是Elixir的最大缺点。虽然Elixir不是静态类型的，但是编译器(以及<a class="ae lq" href="http://erlang.org/doc/apps/dialyzer/dialyzer_chapter.html#:~:text=Dialyzer%20is%20a%20static%20analysis,entire%20(sets%20of)%20applications." rel="noopener ugc nofollow" target="_blank">透析器</a>)会在编译时报告很多错误。这大大超过了动态类型语言(如JavaScript、Python和Clojure)。</p><h2 id="ac3a" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍速度</h2><p id="bb63" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elixir编译器是多线程的，提供极快的编译速度。与Java虚拟机不同，Erlang VM启动速度很快。对于Elixir的用例，运行时性能非常好。</p><h2 id="530b" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍👍可靠性</h2><p id="9728" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elixir构建在Erlang之上，Erlang被用来构建世界上最可靠的软件已经超过30年了。在Erlang VM上运行的一些程序已经能够达到99.9999999%的可靠性。世界上没有其他平台可以拥有同样的可靠性。</p><h2 id="60af" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍并发</h2><p id="686f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">大多数其他编程语言都不是为并发性而设计的。这意味着编写利用多线程/处理器内核的代码绝非易事。其他编程语言利用执行并行代码的线程(和线程读取/写入的共享内存)。这种方法通常容易出错，容易出现死锁，并导致复杂性呈指数级增长。</p><p id="6ddf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elixir建立在Erlang之上，Erlang以其强大的并发特性而闻名，它采用了一种完全不同的并发方法，称为<a class="ae lq" href="https://www.brianstorti.com/the-actor-model/" rel="noopener ugc nofollow" target="_blank">角色模型</a>。在这个模型中，<strong class="kw iu">流程(参与者)之间没有共享</strong>。每个进程维护自己的内部状态，不同进程之间唯一的通信方式是通过<strong class="kw iu">发送消息</strong>。</p><p id="b045" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顺便说一下，actor模型实际上是它的创造者Alan Kay最初打算的面向对象程序设计(OOP ),其中没有共享，对象只通过传递消息进行通信。</p><p id="7528" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们快速比较一下仙丹和它的近亲围棋。与Go不同，Elixir完全是为了容错而设计的。每当goroutine崩溃时，<strong class="kw iu">整个Go程序就会停止</strong>。在Elixir中，每当一个进程死亡时，<strong class="kw iu">只有那个进程死亡</strong>，而不会影响程序的其余部分。更好的是，失败的进程将由它的管理程序自动重启。这允许失败的进程重试已经失败的操作。</p><p id="7571" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elixir进程也是非常轻量级的，可以很容易地在一台机器上运行成千上万个进程。</p><h2 id="aa07" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍 👍缩放比例</h2><p id="9f8f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">再来和围棋做一个对比。Go和Elixir中的并发性利用了并发进程之间的消息传递。Go程序在第一台机器上会运行得更快，因为Go编译成本机代码。</p><p id="3a33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，一旦你开始超越第一台机器，围棋程序就开始输了。为什么？因为Elixir从一开始就被设计成可以在多台机器上运行。Elixir运行于其上的Erlang VM在分发和扩展方面确实大放异彩。它无缝地处理了许多繁琐的事情，比如集群、RPC功能和网络。</p><p id="dae4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从某种意义上说，在微服务成为一种东西的几十年前，Erlang VM就在做微服务。每个进程都可以被看作是一个微服务——就像微服务一样，进程是相互独立的。跨多台机器运行的流程并不少见，这种语言内置了通信机制。</p><p id="9227" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有Kubernetes复杂性的微服务？检查。这就是长生不老药的真正设计目的。</p><h2 id="b472" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍错误处理</h2><p id="0e0b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elixir采用了一种非常独特的错误处理方法。虽然纯函数式语言(Haskell/Elm)被设计成最小化错误的概率，但是Elixir假设<em class="mr">错误将不可避免地发生</em>。</p><p id="eb9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">抛出异常在Elixir中是没问题的，而捕捉异常通常是不鼓励的。相反，进程管理器将自动<em class="mr">重启失败的进程</em>以保持程序运行。</p><h2 id="e15b" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👌学习努力</h2><p id="5d9d" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">灵丹妙药是一种简单的语言，人们可以在一两个月内<a class="ae lq" href="https://pragprog.com/titles/elixir16/programming-elixir-1-6/" rel="noopener ugc nofollow" target="_blank">学会</a>。让学习变得有些困难的是OTP。</p><p id="d42d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">OTP是仙丹的杀手锏。OTP是来自Erlang的一组工具和库，Elixir就是在这些工具和库的基础上构建的。它是显著简化构建并发和分布式程序的秘方。</p><p id="348d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然长生不老药本身很简单，但是要让一个人明白OTP需要一些时间——对我来说确实如此。</p><h2 id="8d72" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍学习资源</h2><p id="4285" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">作为最流行的函数式编程语言，Elixir拥有丰富的学习资源。关于实用程序员<a class="ae lq" href="https://pragprog.com/categories/elixir-phoenix-and-otp/" rel="noopener ugc nofollow" target="_blank">和</a>有十几本神奇的灵丹妙药。学习资源几乎总是对初学者非常友好。</p><h2 id="1797" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👍模式匹配</h2><p id="3cc4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elixir有很好的模式匹配支持。</p><h2 id="12f8" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">👎计算数字</h2><p id="45ba" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Elixir不能很好地处理计算密集型任务。对于这样的任务，应该选择编译到本地的语言(Go/Rust是很好的选择)。</p><h2 id="497e" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">好吧，Erlang是怎么回事？</h2><p id="0ab9" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">对于所有的意图和目的，仙丹和Erlang在引擎盖下是相同的。Erlang是一种功能强大的语言，语法怪异。可以认为Elixir是Erlang更好、更现代的语法(以及非常好的生态系统和社区)。</p><h2 id="a259" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">裁决</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/36528e6bf5c31deaa27dff81f7c89079.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*4IyuKsPlzIO3q5zKa_pMMA.png"/></div></figure><p id="8a56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elixir可能是所有函数式语言中最成熟的。它还运行在为函数式编程而设计的虚拟机之上。它完全是为并发性而设计的，非常适合现代多核处理器时代。</p><p id="7e53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">观看简短的<a class="ae lq" href="https://www.youtube.com/watch?v=lxYFOM3UJzo" rel="noopener ugc nofollow" target="_blank">长生不老药纪录片</a>了解更多信息。</p><h2 id="f14b" class="nr lz it bd ma ns nt dn me nu nv dp mi ld nw nx mk lh ny nz mm ll oa ob mo oc bi translated">奖金；奖品</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/4d3e160dde5165fde35b1f4ac79bceed.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*RwH0ya2xr07QWPeOux963A.png"/></div></figure><p id="9adb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">长生不老药获得两项大奖。</p><p id="b0c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它的弹性、功能优先的方法和令人惊叹的生态系统使它成为构建Web APIs的最佳语言。</p><p id="6f43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">OTP和actor模型使得Elixir成为构建并发和分布式软件的最佳语言<strong class="kw iu">。与它的命令式表亲Go不同，用Elixir编写的软件可以水平扩展到数千个服务器，并且具有开箱即用的容错能力。</strong></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ac0e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">为什么不使用合适的工具呢？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qo"><img src="../Images/567106e94f18bcf2c6b5ba374977ad4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F57kq5OAo_8OShoWxxNLIA.jpeg"/></div></div><p class="pb pc gj gh gi pd pe bd b be z dk translated"><a class="ae lq" href="https://unsplash.com/@haupes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Haupes公司</a>在<a class="ae lq" href="https://unsplash.com/s/photos/tool?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="70db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会用螺丝刀钉钉子吗？大概不会。因此，我们可能不应该试图将一种编程语言用于所有事情——每种语言都有它的位置。</p><p id="a6e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go是系统编程的最佳语言。用于前端开发的最佳选择无疑是ReasonML，它符合一门优秀编程语言的大部分要求。Web API开发的绝对赢家是Elixir，它唯一的缺点是缺乏静态类型系统(这被一个伟大的生态系统、社区、可靠性和并发特性所抵消)。对于任何种类的并发/分布式软件来说，最好的选择还是仙丹。</p><p id="7852" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你从事数据科学，那么，不幸的是，唯一合理的选择是Python。</p><p id="c45a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我真的希望这篇文章是有用的。比较编程语言不是一件容易的事情，但是我尽力了。</p><p id="1bb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你有什么想法和体会？我错过了什么重要的事情吗？某些语言的排名应该更低还是更高？请在评论中告诉我。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1de8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">下一步是什么？</h1><ul class=""><li id="a81e" class="py pz it kw b kx ms la mt ld qp lh qq ll qr lp qd qe qf qg bi translated"><a class="ae lq" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank">以下是如何不在编程上吃亏的方法</a></li><li id="512f" class="py pz it kw b kx qj la qk ld ql lh qm ll qn lp qd qe qf qg bi translated"><a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">面向对象编程——万亿美元的灾难</a></li><li id="b793" class="py pz it kw b kx qj la qk ld ql lh qm ll qn lp qd qe qf qg bi translated"><a class="ae lq" href="https://suzdalnitski.com/oop-will-make-you-suffer-846d072b4dce" rel="noopener ugc nofollow" target="_blank">面向对象编程是计算机科学最大的错误</a></li><li id="43e4" class="py pz it kw b kx qj la qk ld ql lh qm ll qn lp qd qe qf qg bi translated"><a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/fp-toy-7f52ea0a947e">函数式编程？别烦了，这是个愚蠢的玩具</a>(讽刺)</li><li id="28b1" class="py pz it kw b kx qj la qk ld ql lh qm ll qn lp qd qe qf qg bi translated"><a class="ae lq" href="https://suzdalnitski.com/oop-design-patterns-bd2c4fb3014c" rel="noopener ugc nofollow" target="_blank">OOP为什么这么浪费？</a></li></ul></div></div>    
</body>
</html>