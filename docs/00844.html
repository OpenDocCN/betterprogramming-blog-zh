<html>
<head>
<title>Hook Your Fetch Requests With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React挂钩您的获取请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hook-your-fetch-requests-with-react-e8c93dbad932?source=collection_archive---------1-----------------------#2019-07-21">https://betterprogramming.pub/hook-your-fetch-requests-with-react-e8c93dbad932?source=collection_archive---------1-----------------------#2019-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ae8fb73a54effc72a4f8fc91350e68c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLe2NCWaAMxPyubLPKinWQ.png"/></div></div></figure><p id="f9db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从16.8版本开始，<a class="ae kz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>团队为社区提供了附加的钩子。</p><p id="5791" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它们让我们编写功能组件，并使用类组件以前独有的特性，如状态、上下文和生命周期回调。</p><p id="acc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除此之外，React文档为我们提供了构建自己的钩子来将组件逻辑提取到可重用函数中的可能性。</p><p id="801b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于这种说法，我们可以在大多数项目中识别各种情况，在这些情况下，我们可以使用这种强大的功能来使开发更快、更容易。</p><p id="58f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">比方说，您有两个或更多实现公共逻辑的组件。我们可以创建一个钩子来实现这个逻辑，并在我们所有的组件中使用它，这意味着更少的击键和重复的代码。</p><p id="fa6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在其他适合使用钩子的情况中，本文讨论了何时必须与REST API通信来获取或提交数据。</p><p id="c7aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，我们将构建一个管理需要完成的任务列表的示例应用程序(以前的待办事项示例)。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="b54c" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">后端</h1><p id="1d0f" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">由于本文关注的是应用程序的前端，我们将为后端使用一个模拟REST API，<a class="ae kz" href="https://www.mockapi.io/" rel="noopener ugc nofollow" target="_blank"> mockAPI.io </a>。</p><p id="898b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它有一个免费的帐户选项，让你只能创建一个项目，但有多个端点。在我们的例子中，它非常合适，因为我们只需要一个端点(“任务”)。</p><p id="1655" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该数据将有五个字段:</p><ol class=""><li id="1c03" class="mk ml it kd b ke kf ki kj km mm kq mn ku mo ky mp mq mr ms bi translated"><code class="fe mt mu mv mw b">ID</code></li><li id="cd4c" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky mp mq mr ms bi translated"><code class="fe mt mu mv mw b">createdAt</code></li><li id="cb07" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky mp mq mr ms bi translated"><code class="fe mt mu mv mw b">description</code></li><li id="b7b8" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky mp mq mr ms bi translated"><code class="fe mt mu mv mw b">done</code>(布尔型)</li><li id="9124" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky mp mq mr ms bi translated"><code class="fe mt mu mv mw b">updatedAt</code></li></ol><p id="9289" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在下图中查看该字段的定义:</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0544e103f6f8aa110e44eaeaa76af1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*wTg8P4oLnASwylvWfZvBNA.png"/></div></figure><p id="b4ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">mockAPI为每个资源/集合提供了四个REST动词:</p><ol class=""><li id="1557" class="mk ml it kd b ke kf ki kj km mm kq mn ku mo ky mp mq mr ms bi translated"><code class="fe mt mu mv mw b">GET</code>(取数据)</li><li id="fb79" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky mp mq mr ms bi translated"><code class="fe mt mu mv mw b">POST</code>(创建新数据)</li><li id="e0dc" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky mp mq mr ms bi translated"><code class="fe mt mu mv mw b">PUT</code>(更新数据)</li><li id="fa68" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky mp mq mr ms bi translated"><code class="fe mt mu mv mw b">DELETE</code>(销毁数据)</li></ol><p id="7682" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mt mu mv mw b">GET</code>动词可以和<code class="fe mt mu mv mw b">ID</code>参数一起使用，以获取一个特定的任务或所有的任务。</p><p id="4bd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我在mockAPI中创建的定义的图片，所以你可以更好地形象化它。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c2b0a702b8cb3bc51173f98c920ffaf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*DSEJ732vzhgoVk6N8S69yA.png"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">剩余动词定义</p></figure><p id="60a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">mockAPI给我的应用提供的后端地址是<code class="fe mt mu mv mw b">https://5cfabdcbf26e8c00146d0b0e.mockapi.io<strong class="kd iu">/</strong>:endpoint</code> <em class="nm">。</em></p><p id="7198" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mt mu mv mw b">:endpoint</code>是我们创建的资源(任务)的名称。</p><p id="08d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，如果你将浏览器指向<code class="fe mt mu mv mw b"><a class="ae kz" href="https://5cfabdcbf26e8c00146d0b0e.mockapi.io/tasks" rel="noopener ugc nofollow" target="_blank">https://5cfabdcbf26e8c00146d0b0e.mockapi.io<strong class="kd iu">/</strong>tasks</a></code> url，你会看到一个列表；我们的任务清单。</p><p id="42cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成这一部分后，让我们开始工作中有趣的部分，那就是:</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="ffdf" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">前端</h1><p id="f775" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">好吧，这不是最有趣的部分，因为这不是我们应该建立的，但我们会实现的。</p><p id="27e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除此之外，识别可以使用钩子的情况的最简单的方法(至少对我来说)是构建应用程序组件，而不必担心这个问题。</p><p id="269b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的应用程序将由一个容器(<code class="fe mt mu mv mw b">List</code>)组成，它将负责状态管理并向我们的后端发出获取请求。</p><p id="c129" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们不会使用Axios或其他HTTP请求包装器；我们将使用JavaScript获取API。</p><p id="d33f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你对它不熟悉，你可以在<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank"> MDN web文档</a>中了解更多。</p><p id="5423" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其他组件都是表示性的:</p><ul class=""><li id="3e9e" class="mk ml it kd b ke kf ki kj km mm kq mn ku mo ky nn mq mr ms bi translated"><code class="fe mt mu mv mw b">Filter</code>:处理选择过滤控件。从<code class="fe mt mu mv mw b">List</code>容器接收过滤器值和<code class="fe mt mu mv mw b">setFilter</code>回调。</li><li id="0b01" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky nn mq mr ms bi translated"><code class="fe mt mu mv mw b">NewTask</code>:处理创建新<code class="fe mt mu mv mw b">Task</code>的文本输入。从<code class="fe mt mu mv mw b">List</code>容器接收<code class="fe mt mu mv mw b">newTask</code>值和<code class="fe mt mu mv mw b">setNewTask</code>回调。</li><li id="3021" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky nn mq mr ms bi translated"><code class="fe mt mu mv mw b">Task</code>:处理列表中显示的每个任务。接收任务本身和来自<code class="fe mt mu mv mw b">List</code>容器的回调(<code class="fe mt mu mv mw b">toogleTask</code>和<code class="fe mt mu mv mw b">deleteTask</code>)。</li><li id="af62" class="mk ml it kd b ke mx ki my km mz kq na ku nb ky nn mq mr ms bi translated"><code class="fe mt mu mv mw b">ActionButtons</code>:处理每个任务动作按钮的绘制和点击。从<code class="fe mt mu mv mw b">Task</code>组件接收任务和回调(<code class="fe mt mu mv mw b">toogleTask</code>和<code class="fe mt mu mv mw b">deleteTask</code>)。</li></ul><p id="f6a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在<a class="ae kz" href="https://codesandbox.io/s/blissful-brown-bsezz" rel="noopener ugc nofollow" target="_blank"> Codesandox </a>上查看工作应用程序和完整的源代码。</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d233" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是简单明了的代码。我确信这不是最好的方法，还有很多改进的空间，但是对于本文来说，这已经很好了。</p><p id="41de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将关注处理获取数据的容器方法。</p><p id="4f31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我把它们复制到这里，这样我们就可以清楚地看到代码的重复，我们可以用钩子把它们去掉。</p><p id="4bff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从运行在<code class="fe mt mu mv mw b">useEffect</code>钩子内部的初始化代码开始:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nq np l"/></div></figure><p id="537b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它从API获取数据，将其转换为<a class="ae kz" href="https://www.json.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>，并将其传递给其他函数，以给予它们正确的处理。</p><p id="39fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其他方法也是如此。我将用粗体和斜体标记相关代码。</p><pre class="nd ne nf ng gt nr mw ns nt aw nu bi"><span id="3ee9" class="nv li it mw b gy nw nx l ny nz">const addTask = () =&gt; {<br/>    if (!newTask) return;<br/>    setLoading(true);<br/><strong class="mw iu"><em class="nm">    fetch("</em></strong><a class="ae kz" href="https://5cfabdcbf26e8c00146d0b0e.mockapi.io/tasks" rel="noopener ugc nofollow" target="_blank"><strong class="mw iu"><em class="nm">https://5cfabdcbf26e8c00146d0b0e.mockapi.io/tasks</em></strong></a><strong class="mw iu"><em class="nm">", {<br/>      method: "POST",<br/>      headers: {<br/>        Accept: "application/json",<br/>        "Content-Type": "application/json"<br/>      },<br/>      body: JSON.stringify({<br/>        description: newTask,<br/>        createdAt: new Date().toISOString(),<br/>        done: false,<br/>        updatedAt: ""<br/>      })<br/>    })<br/>      .then(resp =&gt; resp.json())</em></strong><br/>      .then(data =&gt; {<br/>        const newList = [...list, data].sort((a, b) =&gt;<br/>          a.createdAt &lt; b.createdAt ? 1 : -1<br/>        );<br/>        setList(newList);<br/>        setNewTask("");<br/>        setLoading(false);<br/>      });<br/>  };</span><span id="6621" class="nv li it mw b gy oa nx l ny nz">const toogleTask = task =&gt; {<br/>    const { id, done } = task;<br/>    setLoading(true);<br/>    <strong class="mw iu"><em class="nm">fetch(`</em></strong><a class="ae kz" href="https://5cfabdcbf26e8c00146d0b0e.mockapi.io/tasks/${id}`" rel="noopener ugc nofollow" target="_blank"><strong class="mw iu"><em class="nm">https://5cfabdcbf26e8c00146d0b0e.mockapi.io/tasks/${id}`</em></strong></a><strong class="mw iu"><em class="nm">, {<br/>      method: "PUT",<br/>      headers: {<br/>        Accept: "application/json",<br/>        "Content-Type": "application/json"<br/>      },<br/>      body: JSON.stringify({<br/>        done: !done,<br/>        updatedAt: new Date().toISOString()<br/>      })<br/>    })<br/>      .then(resp =&gt; resp.json())</em></strong><br/>      .then(data =&gt; {<br/>        const newList = list<br/>          .map(l =&gt; {<br/>            if (l.id === id) {<br/>              l.done = data.done;<br/>              l.updatedAt = data.updatedAt;<br/>            }<br/>            return l;<br/>          })<br/>          .sort((a, b) =&gt; (a.createdAt &lt; b.createdAt ? 1 : -1));<br/>        setList(newList);<br/>        setNewTask("");<br/>        setLoading(false);<br/>      });<br/>  };</span><span id="e480" class="nv li it mw b gy oa nx l ny nz">const deleteTask = task =&gt; {<br/>    const { id } = task;<br/>    setLoading(true);<br/><strong class="mw iu"><em class="nm">    fetch(`</em></strong><a class="ae kz" href="https://5cfabdcbf26e8c00146d0b0e.mockapi.io/tasks/${id}`" rel="noopener ugc nofollow" target="_blank"><strong class="mw iu"><em class="nm">https://5cfabdcbf26e8c00146d0b0e.mockapi.io/tasks/${id}`</em></strong></a><strong class="mw iu"><em class="nm">, {<br/>      method: "DELETE",<br/>      headers: {<br/>        Accept: "application/json",<br/>        "Content-Type": "application/json"<br/>      }<br/>    })<br/>      .then(resp =&gt; resp.json())</em></strong><br/>      .then(data =&gt; {<br/>        const newList = list<br/>          .filter(l =&gt; l.id !== data.id)<br/>          .sort((a, b) =&gt; (a.createdAt &lt; b.createdAt ? 1 : -1));<br/>        setList(newList);<br/>        setLoading(false);<br/>      });<br/>  };</span></pre><p id="1241" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在这里可以识别的唯一区别是，一些Fetch调用有默认的头。其他的，比如<code class="fe mt mu mv mw b">GET</code>，不需要它(因为Fetch API使用的默认动词是<code class="fe mt mu mv mw b">GET</code>)，但是看起来都一样。</p><p id="e632" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那是我们可以装钩子的地方。这就是我们现在要做的。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="1e10" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">定制挂钩</h1><p id="a3e1" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">你可能已经知道(或者不知道):</p><blockquote class="ob"><p id="ec2a" class="oc od it bd oe of og oh oi oj ok ky dk translated"><em class="ol">“自定义钩子是一个JavaScript函数，其名称以“</em> <code class="fe mt mu mv mw b"><em class="ol">use</em></code> <em class="ol">”开头，可以调用其他钩子。”(</em> <a class="ae kz" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank"> <em class="ol">反应过来文档</em> </a> <em class="ol"> ) </em></p></blockquote><p id="c649" class="pw-post-body-paragraph kb kc it kd b ke om kg kh ki on kk kl km oo ko kp kq op ks kt ku oq kw kx ky im bi translated">所以最后，自定义钩子可以写成简单的JavaScript函数。</p><p id="4200" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，我们可以把它想象成一个函数，它接收端点URL，存储它，并返回一个对象，该对象包含我们将使用不同动词进行Fetch调用的方法。</p><p id="4a90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我想出的代码:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nq np l"/></div></figure><p id="870c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单明了的代码，没什么太复杂的。我已经添加了一个助手函数(<code class="fe mt mu mv mw b">customFetch</code>)，所以我不必再次重写整个获取命令。</p><p id="4708" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们如何利用这一点？</p><p id="82f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一步是在<code class="fe mt mu mv mw b">List</code>容器中导入钩子。</p><p id="1a30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的例子中，我将<code class="fe mt mu mv mw b">useFetch</code>代码放在了<code class="fe mt mu mv mw b">src/Hooks</code>文件夹中:</p><pre class="nd ne nf ng gt nr mw ns nt aw nu bi"><span id="106a" class="nv li it mw b gy nw nx l ny nz">import useFetch from "../Hooks/useFetch";</span></pre><p id="fcff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二步是使用钩子，通知端点URL并将其归属于一个常量。</p><pre class="nd ne nf ng gt nr mw ns nt aw nu bi"><span id="864b" class="nv li it mw b gy nw nx l ny nz">const tasksApi = useFetch(<br/>    "<a class="ae kz" href="https://5cfabdcbf26e8c00146d0b0e.mockapi.io/tasks" rel="noopener ugc nofollow" target="_blank">https://5cfabdcbf26e8c00146d0b0e.mockapi.io/tasks</a>"<br/>  );</span></pre><p id="8caf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这两行代码，我们就可以使用我们的定制钩子了，比如在这个<code class="fe mt mu mv mw b">addTask</code>代码中:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nq np l"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="208d" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="6615" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">就像我们在网络上看到的任何其他代码一样，钩子还有很大的改进空间。</p><p id="8e10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个很好的补充，我认为是有意义的，就是添加一个HTTP基本认证，它将auth令牌存储在状态中，并在所有后续的Fetch头中使用它。</p><p id="bb10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这是另一篇文章的内容，或者是读者的一个练习。</p><p id="f786" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，如果您检查代码，您可以找到其他地方，您可以在那里创建一个定制的钩子或助手函数来使代码变得更小，例如数组排序部分，它在所有四个方法(<code class="fe mt mu mv mw b">useEffect</code>、<code class="fe mt mu mv mw b">addTask</code>、<code class="fe mt mu mv mw b">deleteTask</code>和<code class="fe mt mu mv mw b">toogleTask</code>)中重复出现。</p><p id="abc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这可能也是另一篇文章的主题(或者这篇文章的评论)。</p><p id="baa0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，我认为我们已经完成了这里的工作，并且已经完成了这篇文章想要达到的目标。</p><p id="828b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用我们构建的<code class="fe mt mu mv mw b">useEffect</code>钩子的工作应用程序可以在<a class="ae kz" href="https://codesandbox.io/s/todo-example-v2-usefetch-article-1d403" rel="noopener ugc nofollow" target="_blank"> Codesandbox </a>中获得。</p><p id="88b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望你喜欢这篇短文，并从中有所收获。</p><p id="1ca1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一如既往地欢迎任何建议或意见。</p></div></div>    
</body>
</html>