<html>
<head>
<title>File Processing Using Concurrency With GoLang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GoLang并发处理文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/file-processing-using-concurrency-with-golang-9e08920fab63?source=collection_archive---------0-----------------------#2022-05-30">https://betterprogramming.pub/file-processing-using-concurrency-with-golang-9e08920fab63?source=collection_archive---------0-----------------------#2022-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="109e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go中的主并发</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/169213d679390f6127329ac900d540e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlz9v7VdJDf7O-bCz14vIw.png"/></div></div></figure><p id="be67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GoLang对并发程序有着令人难以置信的支持，在本文中，我们将看到如何优化一个处理CSV文件的程序，以便向其用户发送SMS通知。</p><p id="b16f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您是使用GoLang的新手，并且想要更好地理解并发性是如何工作的，我建议您首先阅读这篇文章:<a class="ae lq" href="https://levelup.gitconnected.com/concurrency-in-golang-goroutines-and-channels-explained-55ddb5e1881?gi=18f0db78ea33" rel="noopener ugc nofollow" target="_blank">GoLang中的并发性，Goroutines和Channels解释</a>。</p><p id="ba9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于本文，我们将使用CSV文件，这个程序的目的是读取文件并处理其数据。文件内容表示3，000个用户的列表。</p><p id="40a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该程序应该读取这个文件，并向每个用户和他们的朋友发送通知。</p><p id="0925" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这个Github <a class="ae lq" href="https://github.com/YairFernando67/fileProcessing" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到源代码，以供参考。</p><p id="80e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，我们开始吧。我们将首先创建一个Go模块、<code class="fe lr ls lt lu b">main.go</code>文件和一个名为CSV的包。这个包将有一个名为<code class="fe lr ls lt lu b">ProcessFile</code>的方法，它将从主包中被调用。让我们首先创建Go模块。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="94f8" class="lz ma it lu b gy mb mc l md me">go mod init github.com/GithubHandle/fileProcessing</span></pre><p id="7c27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">初始文件夹结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/6125652f2daba56415b68ef7ae6f35e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*6iKdod5V29Oq7UCwejggRQ.png"/></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">文件夹结构</p></figure><p id="04c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，还有一个<code class="fe lr ls lt lu b">students.csv</code>文件，你可以从存储库中获取这个文件。<code class="fe lr ls lt lu b">main.go</code>和<code class="fe lr ls lt lu b">csv.go</code>文件是这样的:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="380d" class="lz ma it lu b gy mb mc l md me">package main</span><span id="6c58" class="lz ma it lu b gy mk mc l md me">import "github.com/YairFernando67/fileProcessing/csv"</span><span id="2eed" class="lz ma it lu b gy mk mc l md me">func main() {<br/>  csv.ProcessFile()<br/>}</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><pre class="lv lu lw lx aw ly bi"><span id="7891" class="lz ma it lu b gy ms mt mu mv mw mc l md me">package csv</span><span id="9715" class="lz ma it lu b gy mk mc l md me">func ProcessFile() {</span><span id="aa3f" class="lz ma it lu b gy mk mc l md me">}</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="38c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们打开文件并阅读其内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c937" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，我们首先使用<code class="fe lr ls lt lu b">os</code>包打开<code class="fe lr ls lt lu b">csv</code>文件。然后文件被传递给另一个名为<code class="fe lr ls lt lu b">scanFile</code>的函数。该函数使用<code class="fe lr ls lt lu b">bufio</code>包来初始化一个新的扫描仪，并扫描文件的每一行。对于每一行，我们提取关于用户的信息，并将其附加到一个用户切片中。扫描完成后，该函数将用户切片返回给调用者。</p><p id="a200" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户结构在<code class="fe lr ls lt lu b">csv/user.go</code>中定义，看起来是这样的。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="d48f" class="lz ma it lu b gy mb mc l md me">package csv</span><span id="a02a" class="lz ma it lu b gy mk mc l md me">type User struct {<br/>  Id, Name, LastName, Email, Phone string<br/>  FriendIds                 []string<br/>}</span></pre><p id="abe3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您运行该程序，您将看到用户的切片被打印到控制台。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="ac16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好，我们现在将文件的内容表示为一个用户切片，我们现在可以使用这个切片向每个用户和他们的朋友发送短信通知。</p><p id="94c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们将首先看看如何在不使用并发的情况下按顺序完成这项工作。然后我们将修改程序使它更快。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9bdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于顺序处理，我们创建了一个函数并将用户传递给它。该功能覆盖所有用户，对于每个用户，它检查是否已经被访问过，如果没有被访问过，它将该用户标记为被访问过，并发送SMS通知。然后，它还搜索用户的朋友<code class="fe lr ls lt lu b">id</code> s，找到每个用户，并执行相同的步骤，检查它是否被访问过，将他们标记为被访问过，并发送通知。</p><p id="4b58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lr ls lt lu b">sendSmsNotification</code>函数中，我们使用<code class="fe lr ls lt lu b">time.Sleep</code>函数来模拟发送通知的延迟。</p><p id="cdba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们在这个版本的程序上运行一个基准测试，看看它有多快。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8603" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们运行<code class="fe lr ls lt lu b">go test -bench=. github.com/yaairfernando/fileProcessing/csv -benchtime=5x</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a2b3d1c8dd95af2b1fcb57a42bfc6cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*4ZfSlO2WC3i1OCOz9pjWnQ.png"/></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">顺序处理基准</p></figure><p id="a3d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">处理所有用户花费了<code class="fe lr ls lt lu b">199.723</code>秒。让我们看看如何使用并发来提高程序的性能。为此，我们将添加另一个方法来并发处理用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d639" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个并发实现，我们创建了两个通道，<code class="fe lr ls lt lu b">usersCh</code>将保存初始用户列表，<code class="fe lr ls lt lu b">unvisitedUsers</code>将保存单个未访问用户。</p><p id="37ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第35行中，我们向第一个通道提供了用户的初始列表，这是作为这个函数的参数得到的。这在一个单独的goroutine中运行，因为我们不希望主goroutine被阻塞，这是我在这篇<a class="ae lq" href="https://levelup.gitconnected.com/concurrency-in-golang-goroutines-and-channels-explained-55ddb5e1881" rel="noopener ugc nofollow" target="_blank">文章</a>中谈到的一个概念，如果你仍然对阻塞概念感到困惑，你可以去看看。</p><p id="1122" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们叫<code class="fe lr ls lt lu b">initializeWorkers</code>。这个函数实际上初始化了由常数<code class="fe lr ls lt lu b">MAX_GOROUTINES</code>决定的N个goroutines，在这个例子中，我们从10个开始。每个worker都是一个监听<code class="fe lr ls lt lu b">unvisitedUsers</code>通道的函数，对于它接收到的每个用户，它向用户发送SMS通知，并通过在列表中找到每个用户来处理其朋友id，然后将用户发送到<code class="fe lr ls lt lu b">usersCh</code>通道。用户朋友<code class="fe lr ls lt lu b">id</code>的处理在一个单独的goroutine中运行，因为我们不想在这里阻塞当前的goroutine。</p><p id="7cbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该功能将允许程序有10个goroutines等待用户被发送到<code class="fe lr ls lt lu b">unvisitedUsers</code>通道。并且这些goroutines中的每一个都将并发运行，从而提高程序的性能。</p><p id="bea2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里需要注意的另一件重要的事情是，在第57行中，我们使用这个语法来检查<code class="fe lr ls lt lu b">usersCh</code>通道是否仍然打开，这阻止了我们向关闭的通道发送数据。在本例中，这一点很重要，因为我们将关闭通道，我们不希望其他goroutines尝试向该通道发送数据。</p><p id="1255" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后在第37行，我们有覆盖<code class="fe lr ls lt lu b">usersCh</code>通道的<code class="fe lr ls lt lu b">processUsers</code>函数，对于它接收到的每个用户列表，它检查该用户是否已经被访问过，如果没有，那么它将其标记为已访问，并将该用户发送到<code class="fe lr ls lt lu b">unvisitedUsers</code>通道。该函数还跟踪有多少用户使用了<code class="fe lr ls lt lu b">count</code>变量，通过这样做，我们可以检查是否已经达到第75行的大小，并关闭<code class="fe lr ls lt lu b">usersCh</code>通道，这将终止程序。</p><p id="ebb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们对这个版本的程序进行基准测试，看看它改进了多少。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e94e87a7c161f5f652e49e72149dbb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*qldReCG0Y8W8Y0wGpL6h_g.png"/></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">并发处理基准</p></figure><p id="1d9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，只用了<code class="fe lr ls lt lu b">19.936</code>秒就完成了！！这是一个巨大的性能提升。我们还可以通过增加或减少<code class="fe lr ls lt lu b">MAX_GOROUTINES</code>常量来控制我们希望程序拥有多少活动的go routine/worker。</p><p id="2ce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们增加工人的数量，我们的程序将运行得更快，因为更多的任务将同时运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1abc6c2f7ed3931f5b5a9886671f7a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*ZFdSp3Sx_MOZqxldsCnc6Q.png"/></div></figure><p id="b70b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个很好的例子，说明了如何使用通道和goroutines来提高程序的性能。通道是go routine之间的一种很好的通信方式，go routine允许您并发地运行代码。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="feed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你觉得这篇文章很有用，并且学到了一些新东西。感谢您的阅读。敬请关注。</p></div></div>    
</body>
</html>