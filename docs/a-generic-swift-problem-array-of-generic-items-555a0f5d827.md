# 一个“通用”的快速面试问题:过滤一系列通用项目

> 原文：<https://betterprogramming.pub/a-generic-swift-problem-array-of-generic-items-555a0f5d827>

## 根据我最近的编码采访

![](img/06ef6257bc135b37e708a07437ec6c1a.png)

今天早上我的花园里长了一朵美丽的苔藓

Generic 是 Swift 中一个强大的概念，它为数据结构提供了灵活性，能够在不同的数据类型上执行。然而，它非常依赖编译器推断底层类型的能力。在这篇文章中，我将讨论一个使用泛型的场景。

最近在一次编码面试中，我遇到了如下问题。

有 2 种(或更多)过滤器类型都符合相同的协议`Filter`。

在每个具体对象中，它可以有多个特定于类型本身的不同参数，这些参数不能从接口访问。

然而，这些参数看起来具有相同的类型(例如:`Float`)，尽管这并不总是正确的。这意味着从更广泛的角度来看，我们可以考虑一个通用的解决方案来更新每个滤波器的值。

**注意:**假设上述代码来自第三方库，这意味着不建议(允许)我们修改它。接受现实，继续前进。

让我们来讨论这个问题。

假设我们在应用程序中有一个切换器，用户可以在`FilterA`和`FilterB`之间切换，并调整相应的值。

如果是`FilterA`，UI 显示 1 个滑块来调整`param`的值。另外，有两个滑块分别用于“T6”和“T7”。

如果引入更多的过滤器，我们希望编写能够轻松伸缩的智能整洁的代码。类似于:

然后这(可能)发生在函数内部:

这显然是不可扩展的。对于现有`Filter`中的每个新过滤器或新参数，以重复的方式添加更多代码。

因为不可能修改`FilterA`和`FilterB`，一个新的包装器来拯救我们。

现在使用包装器是可行的:

每当我们创建一个新的 filter 实例(`FilterManager`)时，我们可以传入底层的 filter，以及一个带有闭包的参数列表，告诉它们在收到更新时做什么。

不再有 if-else 或 switch-case。然而，泛型的问题出现在最后。

编译器能够推断每个对象的具体类型，直到最后一行出现编译错误。

> 异类集合文本只能推断为“[Any]”；如果有意这样做，请添加显式类型批注

这是什么意思？`filterA`和`filterB`不都是`FilterManager`类型的吗？

这是对泛型类型的一个常见误解。事实上，`filterA`的型号是`FilterManager<FilterA>`，而`filterB`是`FilterManager<FilterB>`。

基础类型是编译器决定泛型对象实际类型的关键。在这种情况下，我们的过滤器有不同的类型，容器数组只能推断到最高的共同祖先是`[Any]`。

然而，我们可以为这两个实例手动定义一个公共类型，并公开我们需要的基本属性和功能。

现在可以创建一个包含`filterA`和`filterB`的数组了:

这个问题的要点是，人们经常假设泛型类型的实例具有相同的类型。但是，如果基础类型不同，情况就不一样了。

编码快乐！

**旁注:**在写这篇文章的时候，我在想一个更好的解决方案，也许是用`associatedtype`或者别的什么。我很高兴如果任何人有其他解决这个问题的方法，可以在评论区发布。