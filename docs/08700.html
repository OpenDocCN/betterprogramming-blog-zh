<html>
<head>
<title>The UIViewController Lifecycle Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UIViewController生命周期解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-uiviewcontroller-lifecycle-explained-17c83d2c572f?source=collection_archive---------0-----------------------#2021-06-02">https://betterprogramming.pub/the-uiviewcontroller-lifecycle-explained-17c83d2c572f?source=collection_archive---------0-----------------------#2021-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="769e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当一个VC被创建并呈现时会发生什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c76e6617b7fee1a43ad0282bc118de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S9xnBSfIq9MUTMaW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tolga__?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托尔加·乌尔坎</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="965d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当开发一个应用程序时，我们可能需要在加载一个<code class="fe lv lw lx ly b">UIView</code>时添加一些自定义逻辑。例如，我们可能需要执行一个网络调用来从后端获取一些数据。在其他情况下，当视图即将被取消并对用户隐藏时，我们可能需要清理一些资源。</p><p id="6687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这些想法很简单，但在iOS开发中还是有一些细微差别。一起探索它们可能会有所帮助。</p><p id="f8ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">注意:即使您只使用SwiftUI进行开发，您也可以从本文中受益。SwiftUI视图可能被加载到一个</em> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/uihostingcontroller" rel="noopener ugc nofollow" target="_blank"><em class="lz">UIHostingController</em></a></code> <em class="lz">中，它继承了</em> <code class="fe lv lw lx ly b"><em class="lz">UIViewController</em></code> <em class="lz">，所以这些想法在那个上下文中也是有效的。</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="cad7" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">生命周期</strong></h1><p id="08f5" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">视图控制器的生命周期可以分为两个大的阶段:T21视图加载和视图生命周期。</p><p id="d14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图控制器在第一次访问视图时创建它的视图，用它需要的所有数据装载它。这个过程就是视图加载。</p><p id="51f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个责任是在需要时呈现和隐藏它的视图。当这些事件发生时，VC通知我们这些事件，以便我们可以运行一些定制的逻辑。这是视图生命周期。</p><p id="8076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图摘自<code class="fe lv lw lx ly b">UIViewController</code>文档，显示了视图生命周期:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/2b44a6900daab86b25fc68aaf726eb5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*lGLebpbej42v742YSEHRxw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自:<a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiviewcontroller" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></figure><p id="16f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个<a class="ae ky" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">有限状态机(FSM) </a>中，我们可以看到每个状态(白色和浅蓝色圆圈)会发生什么。例如，如果VC处于<code class="fe lv lw lx ly b">appearing</code>状态，它只能进入<code class="fe lv lw lx ly b">appeared</code>状态，调用<code class="fe lv lw lx ly b">viewDidAppear(_:)</code>方法)。或者它可以直接进入<code class="fe lv lw lx ly b">disappearing</code>状态，调用<code class="fe lv lw lx ly b">viewWillDisappear(_:)</code>方法。</p><h2 id="82d9" class="nf mi it bd mj ng nh dn mn ni nj dp mr li nk nl mt lm nm nn mv lq no np mx nq bi translated">查看加载</h2><p id="24df" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">要记住的第一个细微差别是，当创建VC时，视图是<em class="lz">而不是</em>自动加载到内存中的。</p><p id="973c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">UIViewController.init</code>方法不调用<code class="fe lv lw lx ly b">loadView</code>方法。这个函数在<code class="fe lv lw lx ly b">ViewController</code>第一次被要求在屏幕上显示它的视图时被调用。</p><p id="ce04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果VC存在，而视图以前从未被加载过，则调用<code class="fe lv lw lx ly b">loadView</code>方法。之后，VC调用<code class="fe lv lw lx ly b">viewDidLoad</code>方法，这是一个方便的覆盖点，可以添加一些只需要执行一次的定制逻辑。</p><p id="5421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码显示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AppDelegate</code>创建了两个视图控制器:<code class="fe lv lw lx ly b">mainVC</code>和<code class="fe lv lw lx ly b">secondaryVC</code>。当<code class="fe lv lw lx ly b">mainVC</code>打印<code class="fe lv lw lx ly b">loadView</code>和<code class="fe lv lw lx ly b">viewDidLoad</code>日志时，<code class="fe lv lw lx ly b">secondaryVC</code>不打印。</p><p id="1466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">secondaryVC</code>没有显示，其视图也不会显示。因此，没有必要用一个可能根本不会被使用的视图来占用设备的内存。</p><p id="57bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完整起见，这是<code class="fe lv lw lx ly b">ViewController</code>的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a3e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们刚刚创建了一个属性来保存VC的<code class="fe lv lw lx ly b">name</code>，并且我们覆盖了<code class="fe lv lw lx ly b">loadView</code>和<code class="fe lv lw lx ly b">viewDidLoad</code>方法来打印日志。</p><p id="6ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">logMethod</code>方法很有意思。它使用<code class="fe lv lw lx ly b">#function</code>元参数。该参数由编译器赋值，包含当前方法的名称。通过将该参数传递给log函数，我们可以打印出调用<code class="fe lv lw lx ly b">log</code>函数本身的方法的名称！</p><p id="754f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行代码，我们将获得以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/c00cd52abce1896a1ee255ce4696d71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hTvbgBwshtin8llWLfwGQ.png"/></div></div></figure><blockquote class="nu nv nw"><p id="53a4" class="kz la lz lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">注意:还有另一种方法来强制VC将视图加载到内存中:通过访问视图来更新它的一个属性。尝试添加行<code class="fe lv lw lx ly b">secondaryVC.view.backgroundColor = .systemRed</code>来查看视图是否被加载，即使VC不存在。</p></blockquote><h2 id="c02c" class="nf mi it bd mj ng nh dn mn ni nj dp mr li nk nl mt lm nm nn mv lq no np mx nq bi translated"><strong class="ak">视图生命周期</strong></h2><p id="6cae" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这是视图控制器的第二个职责。每当出现一个视图控制器时，它都会通过<code class="fe lv lw lx ly b">viewWillAppear</code>方法，然后调用<code class="fe lv lw lx ly b">viewDidAppear</code>方法。</p><p id="108b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图消失时也会发生同样的情况:首先调用<code class="fe lv lw lx ly b">viewWillDisappear</code>方法，然后调用<code class="fe lv lw lx ly b">viewDidDisappear</code>方法。</p><p id="d049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过修改我们的<code class="fe lv lw lx ly b">ViewController</code>类中的代码来轻松检查这一点。</p><p id="b826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个自定义的<code class="fe lv lw lx ly b">View</code>，这样我们就可以向它添加一个按钮。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="200a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个视图有一个名为<code class="fe lv lw lx ly b">Present</code>的按钮，用户可以点击它来显示另一个视图控制器。该按钮位于屏幕中央。</p><p id="04a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们把这个观点和我们的VC联系起来。我们可以修改<code class="fe lv lw lx ly b">loadView</code>方法来创建自定义的<code class="fe lv lw lx ly b">View</code>，设置它的交互，并将其用作<code class="fe lv lw lx ly b">ViewController</code>的默认视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c4eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是第11行，每当用户点击<code class="fe lv lw lx ly b">Present</code>按钮时，我们都会呈现一个名为<code class="fe lv lw lx ly b">Modal</code>的新<code class="fe lv lw lx ly b">ViewController</code>。</p><p id="7729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们为视图生命周期添加一些其他日志行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没有什么特别的:我们覆盖了生命周期方法，添加了一个日志来查看它们何时被调用。如果我们现在运行代码，我们可以看到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a13b23fd95988eb740b1fe5b1822a9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5SNEJ4fVcx668FG_iu5xQ.png"/></div></div></figure><p id="5eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以点击模拟器上的<code class="fe lv lw lx ly b">Present</code>按钮，看看接下来会发生什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0257c6280e79a1618dde65d5193ddd62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IrWhFQtGDZ6YpewE59smwQ.png"/></div></div></figure><p id="c6ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到<code class="fe lv lw lx ly b">Modal</code> VC已经被加载并呈现。然而<code class="fe lv lw lx ly b">Main</code> VC仍然在<code class="fe lv lw lx ly b">Modal</code>后面。这是为什么呢？如果我们看屏幕，很容易理解:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d5b936b110ce70e855eebe8ccc48a5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*uS0iPdUtRJRJGxbii_rHaw.png"/></div></figure><p id="3782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">红色圆圈突出显示了旧VC的<code class="fe lv lw lx ly b">View</code>仍然在那里，并且在我们刚刚呈现的模态视图下面部分可见。所以，现在还没有消失。</p><p id="ecaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以从上到下滑动，并解散<code class="fe lv lw lx ly b">Modal</code> VC。让我们看看我们的输出是如何变化的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/36095296fd3e3047bf7904a73e359afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_qAccmSk9Y0mSYgfWs9Mg.png"/></div></div></figure><p id="8dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe lv lw lx ly b">viewWillDisappear</code>和<code class="fe lv lw lx ly b">viewDidDisappear</code>最终被调用。</p><p id="ba24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些方法(<code class="fe lv lw lx ly b">viewDidLoad</code>、<code class="fe lv lw lx ly b">viewWillAppear</code>、<code class="fe lv lw lx ly b">viewDidAppear</code>、<code class="fe lv lw lx ly b">viewWillDisappear</code>、<code class="fe lv lw lx ly b">viewDidDisappear</code>)总是被VC调用，尽管我们没有什么可运行的。这些是VC提供给我们的钩子，让我们在那些时刻运行一些特定的代码。</p><p id="bde0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">注意:在重写这些方法时，要记住调用</em> <code class="fe lv lw lx ly b"><em class="lz">super</em></code> <em class="lz">，传递调用钩子时我们收到的相同参数。如果我们不这样做，行为是未定义的。</em></p><h2 id="8e41" class="nf mi it bd mj ng nh dn mn ni nj dp mr li nk nl mt lm nm nn mv lq no np mx nq bi translated">方法之间的差异</h2><p id="2cfa" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">顾名思义，这些方法之间有一些细微的差别:</p><ul class=""><li id="3e76" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">当VC正在呈现视图，但是视图还不可见时，调用<code class="fe lv lw lx ly b">viewWillAppear</code>。</li><li id="feb8" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">当视图已经呈现在屏幕上时，调用<code class="fe lv lw lx ly b">viewDidAppear</code>。</li><li id="d9a9" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">当VC将要关闭视图时，调用<code class="fe lv lw lx ly b">viewWillDisappear</code>,但是视图仍然呈现在屏幕上</li><li id="f35c" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">viewDidDisappear</code>当视图不再被渲染时被调用。</li></ul><p id="e119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了验证这一点，让我们修改一下<code class="fe lv lw lx ly b">loadView</code>的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码中的变化发生在第12行到第14行。这里，我们在一个单独的变量中创建VC，然后将<code class="fe lv lw lx ly b">modalPresentationStyle</code>更改为<code class="fe lv lw lx ly b">fullScreen</code>。这迫使<code class="fe lv lw lx ly b">Modal</code>视图覆盖整个屏幕，因此<code class="fe lv lw lx ly b">Main</code> VC将不再可见。</p><p id="c6da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">注意:使用这种方法，我们将不再能够通过从上到下滑动来解散新的VC。如果您想要建立这种行为，您需要添加一个关闭按钮。</em></p><p id="52d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行这个新代码并点击<code class="fe lv lw lx ly b">Present</code>按钮，我们将获得以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/2f8b4298a36ab38036ca09eeb4f48fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKY9II4aDNTxJ_IK-2itlw.png"/></div></div></figure><p id="8013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的部分浓缩在最后四行。加载<code class="fe lv lw lx ly b">Modal</code>视图后:</p><ul class=""><li id="72ad" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">Main</code> VC的观点即将被驳回。</li><li id="afe0" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">Modal</code> VC的观点即将呈现。</li><li id="9aaa" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">Modal</code> VC的观点提出来了。</li><li id="7a34" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">VC的观点最终被驳回。</li></ul><p id="287b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，<code class="fe lv lw lx ly b">Modal</code> VC的<code class="fe lv lw lx ly b">viewXXXAppear</code>方法被<code class="fe lv lw lx ly b">Main</code>的<code class="fe lv lw lx ly b">viewXXXDisappear</code>方法包装。这是有意义的，因为<code class="fe lv lw lx ly b">Modal</code>视图即将完全覆盖<code class="fe lv lw lx ly b">Main</code>视图。只有当<code class="fe lv lw lx ly b">Modal</code>的视图完全呈现在屏幕上时，这个过程才完成。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ae03" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="6acf" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在本文中，我们探索了<code class="fe lv lw lx ly b">ViewController</code>生命周期方法如何相互作用，以及如何在我们的应用中利用它们。</p><p id="5795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们探索了一些他们的优化，陷阱，以及他们如何改变VC的演示模式。</p><p id="8d97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呈现的钩子是重要的。我们可以使用它们来加载和卸载资源，或者执行与视图生命周期相关的操作。</p></div></div>    
</body>
</html>