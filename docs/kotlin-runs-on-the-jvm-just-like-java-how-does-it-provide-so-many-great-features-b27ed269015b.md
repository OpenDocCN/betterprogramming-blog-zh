# 如果 Kotlin 像 Java 一样在 JVM 上运行，那么它是如何提供这么多优秀特性的？

> 原文：<https://betterprogramming.pub/kotlin-runs-on-the-jvm-just-like-java-how-does-it-provide-so-many-great-features-b27ed269015b>

## 看看 Kotlin 生成的字节码以及它如何在 JVM 上运行

![](img/6edda4092334cbe0bdb78ce585186604.png)

支撑一棵树的手臂

着眼于基本面；当我们提到一种**JVM 语言**时，我们到底指的是什么？Kotlin 语言与此有什么关系？不是只有 Java 可以在 JVM 上运行吗？在这篇文章中，我想谈谈 JVM 是什么以及它是如何协同工作的。特别是，我将演示如何在 JVM 上执行除 Java 之外的其他语言。为此，我们将学习什么是 JVM 字节码，以及它如何使 JVM 语言成为可能。****

****Kotlin 编程语言提供了许多 Java 中没有的特性，比如适当的*函数类型*、*扩展函数、*或者通过*对象*声明的内置单例支持。Kotlin 如何提供比原本打算在 JVM 上运行的语言更多的特性？我深入了解了 Kotlin 的工作原理以及 JVM 语言的真正含义。我们将看看 Kotlin 的字节码生成。如果你以前也想过这些事情，这篇文章应该会给黑暗带来一些光明🙂****

# ****Java 虚拟机****

****大多数人以前都听过 Java 虚拟机(JVM)这个术语。但实际上是什么呢？简单定义如下:*Java 虚拟机是计算机用来运行 Java 字节码的。*
当然，关于这个复杂的工具还有很多要学的，在 [Oracle 的规范](https://docs.oracle.com/javase/specs/jvms/se19/html/index.html)中有更详细的描述。您可能已经知道，JVM 是运行在各种操作系统上的抽象虚拟计算机。事实上，JVM 是 Java“平台无关”的原因，因为它充当了执行代码和操作系统之间的抽象。就像任何真正的计算机一样，JVM 提供了一组定义好的指令，这些指令可以被程序使用，并在随后的过程中由 JVM 自己翻译成特定于机器的指令。****

****正如在 [JVM 规范](https://docs.oracle.com/javase/specs/jvms/se19/html/index.html)中所描述的，Java 虚拟机对编程语言 Java 一无所知。然而，它定义了二进制格式`class`，这是一个包含要执行的机器指令(=字节码)的文件(除了一些更多的信息)。这是一个极其相关的问题，具有以下含义:****

1.  ****JVM 不仅仅致力于将 Java 作为一种编程语言来运行。****
2.  ****您可以自由选择创建 JVM 程序的技术，只要您提供合适的 a `class`文件格式并遵守其非常严格的限制。****
3.  ****不管它的来源是什么(读:编程语言)，任何 Java 字节码都可以与 JVM 上的其他 Java 字节码互操作。****

# ****创建类文件****

****从人类可读的源代码创建类文件的过程就是编译器的工作。一个例子是 JDK 附带的 Oracle Java 编译器`javac`，它将`.java`文件编译成`.class`文件。
除了 Java，在过去几年中出现了许多其他的 [JVM 语言](https://en.wikipedia.org/wiki/List_of_JVM_languages)，它们都试图为开发人员提供一种替代的抽象来为 JVM 创建程序。其中一种语言是科特林语。****

# ****Kotlin 字节码生成——什么是 Kotlin？****

****正如官方常见问题中所说，“Kotlin 产生 Java 兼容的字节码”。这意味着 Kotlin 编译器能够将所有精彩的 Kotlin 特性转化为 JVM 兼容的指令。幸运的是，我们可以使用 IntelliJ IDEA 提供的工具来观察这个复杂的过程。这些工具让我们检查由 Kotlin 编译器生成的字节码。现在，如果你不习惯的话，字节码不是特别易读。作为一种简化，IDEA 还允许我们将字节码转换回 Java 指令，这将在下一节中讨论。****

****让我们来看看一些有趣的 Kotlin 特性，并了解它们转换成什么字节码！****

# ****顶级功能****

****在. kt 文件中定义的这个简单的顶级函数可以用 IntelliJ 进行研究:
**工具→ Kotlin →显示 Kotlin 字节码**将在 ide 中打开一个新窗口，提供编译器为当前`.kt`文件创建的字节码的实时预览。结果是下面的字节码。****

```
**public final class FileKt {// access flags 0x19
  public final static foobar()V
   L0
    LINENUMBER 1 L0
    RETURN
   L1
    MAXSTACK = 0
    MAXLOCALS = 0[@Lkotlin/Metadata](http://twitter.com/Lkotlin/Metadata);(...)
  // compiled from: File.kt
}**
```

****如前所述，没有多少人会喜欢阅读这种语法，这就是为什么我们也可以选择“反编译”这个选项。之后，IDEA 展示了上面的字节码的 Java 表示。****

****正如您所看到的，并且可能已经知道的，一个 Kotlin 顶级类被编译成一个带有静态函数的最终 Java 类。这种结构让我们想起了扩展函数意味着替换的概念:实用程序类，即最终类中静态函数的集合。在 Kotlin 中，你可以在任何文件的顶层声明这些东西。****

****让我们看一个更难的:****

# ******类和扩展函数******

****在下一个例子中，我们看一个包含类型`Int`的单个属性的类。除此之外，该文件还在这个新类上定义了一个扩展函数，它是在顶层定义的。****

****在查看相应的字节码时，我们在这里感兴趣的是什么？首先，我们应该看看这个类被编译成什么样子，因为我们使用了一个*主构造函数*和一个 *val* 关键字。这两种东西在 Java 中都不存在，所以了解相应的 Java 代码应该很有趣。****

****嗯，这里没有真正的惊喜。该属性成为一个`final`成员，并在该类的单个构造函数中赋值。在 Kotlin 中声明要简单得多，不是吗？****

****现在，扩展函数会发生什么？****

****扩展函数本身被编译成一个静态函数，其 *receiver 对象、* MyClass *、*成为该函数的一个参数。
我们在示例中可以观察到的另一件事是使用了一个名为`Intrinsics`的类。这个是 Kotlin 标准库的一部分，作为一个工具集来检查参数是否不是`null`。让我们快速做一个实验，看看如果我们将原始扩展函数的参数类型改为`String?`，然后以空安全的方式访问`length`，会发生什么。这里我们跳过 Kotlin 代码，直接跳到 Java 表示:****

****检查`value`已经没有必要了，因为我们已经告诉编译器`null`是一个可以接受的指向。由于我们添加了可空性检查并应用了默认值，返回表达式变得更加复杂。太棒了。****

****下一个也是最后一个例子有点复杂。这是 Kotlin 和 Java 代码之间最大的区别:****

# ******科特林山脉******

****下面的代码定义了一个函数，该函数包含一个简单的循环，用于将几个整数打印到控制台。然而，这里有一些有趣的事情:我们使用一个范围，或者更具体地说，级数，来生成我们想要迭代的数字序列。此外，该声明中还包含两个中缀函数。****

****在字节码中看这个应该更有趣。让我们看看结果如何。****

****好吧，这里有很多代码。这是什么？尽管给定的 Java 代码非常容易阅读，但它看起来不像是循环遍历几个数字的常见方式。编译器解析级数的方式比简单的`for`循环要复杂一些。这个例子表明，与您用 Kotlin 编写的原始简洁代码相比，最终的字节码可能非常庞大。有趣的学习，如果你问我！****

# ****结论****

****大多数时候你并不真正关心 Kotlin 编译器在幕后产生了什么。尽管如此，观察一个编译器做什么真的很有趣，也很有帮助。这样做也回答了我最初提出的 Kotlin 和 JVM 语言到底是什么的问题。最终，这些只是产生字节码的抽象。类文件，就像 Java 那样。编程语言本身可以是任意的，只要编译器产生可行的字节码。****

****另一方面，我们还看到，在某些情况下，编译后的 Java 代码比预期的更加冗长。这会影响性能吗？是的，的确，它确实有轻微的影响。如果你对更多考虑性能的“Kotlin → Java 字节码”例子感兴趣，可以看看 Dmitry Jemerov 的这个[演示](https://de.slideshare.net/intelliyole/kotlin-bytecode-generation-and-runtime-performance)。公平地说，这是一个老资源，随着 Kotlin 编译器的每一个新版本，事情都会发生变化，因为最终，它只需要将 Kotlin 文件翻译成 JVM 理解的字节码。每一个新的 JVM 版本都是 Kotlin 编译器改进的潜在机会。****