<html>
<head>
<title>Agile Git Integration With gitworkflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与gitworkflows的敏捷Git集成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/agile-git-integration-with-gitworkflows-d6207bcf4ed?source=collection_archive---------13-----------------------#2019-12-03">https://betterprogramming.pub/agile-git-integration-with-gitworkflows-d6207bcf4ed?source=collection_archive---------13-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当集成特性和修复时，gitworkflow的简化版本如何给敏捷团队带来灵活性和安全性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec1b85dbb882607e02e82111be026b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aVP35nX819CsV8UD"/></div></div></figure><p id="063f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将探索基于<a class="ae lq" href="https://git-scm.com/docs/gitworkflows" rel="noopener ugc nofollow" target="_blank"> gitworkflows </a>的特性分支的使用，以便在特性和修复完全就绪时集成它们。虽然这是一个不太为人所知的工作流程，但它提供了很大程度的自由度和灵活性。</p><p id="c148" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们不会涵盖所有的gitworkflows，而是一个简化的变体，集中于处理单个持久化分支、单个集成分支和单个特性分支。</p><p id="977d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:对于那些熟悉<a class="ae lq" href="https://datasift.github.io/gitflow/IntroducingGitFlow.html" rel="noopener ugc nofollow" target="_blank"> GitFlow </a>的人来说，我应该注意到虽然名字相似，<em class="lr">这是两个完全不同的工作流程。</em>本文将只介绍Git核心团队的工作流程。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="efcd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">对动态Git策略的需求</h1><p id="73df" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在我描述这个工作流是什么之前，让我们看几个场景:</p><ul class=""><li id="ef68" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">假设您负责一个大型组织内部的应用程序。您向它添加功能，并在问题出现时提供修复。您的组织喜欢频繁地发布，您可能知道也可能不知道哪些工作项将被包含，直到接近最终的预发布测试周期。</li><li id="e691" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">或者，您正在开发相同类型的应用程序，并且您的一个特性在测试后期发现了一个不明显的bug，需要从发布中删除。</li><li id="b9db" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">或者，假设一个开发人员实现了一个新的特性，这个新特性使得测试环境停止，并且必须被删除，直到修复后测试才能继续。</li></ul><p id="e479" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这些场景中，都需要一定程度的开发灵活性。您的核心需求是能够<em class="lr">快速从一个版本中删除特性或修复，而不会引入重大风险</em>。</p><p id="f221" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是工作流的全部内容——能够根据需要快速添加或删除分支的功能。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="a60c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">仅仅使用一个开发分支怎么样？</h1><p id="994e" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">那么，为什么需要这样做呢？难道我们不能让所有的开发人员在一个持久开发分支上编码，并定期为主要特性分离分支，然后将它们合并回来吗？</p><p id="63be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，也许吧，但是如果您在发布之前发现开发分支中两周前提交的特性有问题，您有什么选择？</p><ul class=""><li id="9e18" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">延迟发布以进行修复。</li><li id="6556" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">重新提交以禁用该特性，希望您正确地禁用了它，并且这是唯一引入的新问题。</li><li id="78d6" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">与缺陷一起发布。</li></ul><p id="8c41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我看来，这些都不是很好的选择。你不得不冒不必要的风险，或者在不必要的时候推迟约会。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="2614" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">分支结构概述</h1><p id="81b6" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">使用Git核心团队的工作流，您只需根据不包括引入问题的分支的组合定制一个发布。</p><p id="0eea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个工作流中，您有<em class="lr">特性分支</em>，它们代表了被更改的单个工作项。这些是您的个人修复和新功能。</p><p id="17d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个特征分支从<em class="lr">主分支</em>分支。除了它所代表的意义之外，这没什么太不寻常的。<em class="lr"> Master代表可发布的代码。</em>这是经过全面测试的代码，由产品管理部门审查，不会引入任何回归问题。</p><p id="a5d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工作流有趣的地方在于它的<em class="lr">提议更新</em>分支的概念(通常简称为<em class="lr"> pu </em>)。<em class="lr">提议的更新</em>是一个包含已完成的特性或修复的分支，这些特性或修复已准备好被共同评估以形成一个完成的构建。</p><p id="4b75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:gitworkflows也提倡一个<code class="fe nk nl nm nn b">next</code>分支和一个<code class="fe nk nl nm nn b">maint</code>分支。<code class="fe nk nl nm nn b">next</code>相当于预发布环境，而<code class="fe nk nl nm nn b">maint</code>基于上一个生产版本。你可能需要也可能不需要这些分支。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="8427" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">测试和集成</h1><p id="9a80" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">因此，所有的测试和产品评审都是基于提议的更新分支进行的。</p><p id="63f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦集成测试分支被证明是好的，在将它们合并之前，在将特性分支重新基于主分支之后，用于单独变更的特性分支被合并到主分支中。</p><p id="752d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这为我们做了几件事:</p><ul class=""><li id="bafd" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">它保持了版本历史的整洁。</li><li id="b789" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">它确保了特性分支不会互相渗透，这样你就不会依赖于你不想依赖的代码。</li><li id="8e64" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">如果集成分支被破坏，我们可以随意重新生成它。</li></ul><p id="da8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我可以在这里更详细地解释这些，但是最好向您展示单个特性的生命周期。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="4990" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">案例研究:添加黑暗主题</h1><p id="ffd5" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">因为每个应用程序都需要一个黑暗的主题，让我们在案例研究中以此为例。</p><p id="c11d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Priya查看了团队的敏捷董事会，决定在票务系统中加入ID为“FOO-123”的“添加黑暗主题”故事。她查看了用户故事和接受标准，认为她已经有足够的信息可以开始了，所以她将它分配给自己并创建了一个分支。</p><p id="9cb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">她通过切换到<code class="fe nk nl nm nn b">master</code>分支然后运行<code class="fe nk nl nm nn b">git checkout -b FOO-123</code>来创建这个分支。</p><p id="95ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将基于工作项的标识符(FOO-123)从当前分支创建一个分支，然后切换到当前分支。</p><p id="8b1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后Priya花时间进行测试和修改，直到她对自己的功能满意为止。一旦她准备好了，她就打开一个从<code class="fe nk nl nm nn b">FOO-123</code>到<code class="fe nk nl nm nn b">pu</code>(建议更新)分支的合并请求(也称为拉请求)。</p><p id="3eaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Jerome对分支进行了代码审查，对工作很满意，并批准了合并请求，因此Priya将其合并到<code class="fe nk nl nm nn b">pu</code>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/92ca8919abe4855534d1b00cce090db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I4CbXZVt9JQNnRi6"/></div></div></figure><p id="36b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">持续集成服务器看到了触发构建的<code class="fe nk nl nm nn b">pu</code>分支的变更。构建成功，随后部署到测试环境中。</p><p id="1545" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在那里，质量保证审查该特性，没有发现任何问题。产品管理部门看着它，同样很高兴。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5c9a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">从建议的更新中删除项目</h1><p id="23b4" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">不幸的是，Landon一直在做一个新的页面，没有考虑到新引入的主题。黑暗主题在这个页面上表现不好，所以当产品管理和质量保证部门审查Landon的页面时，就产生了一个问题。</p><p id="11c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为开发周期只剩下一天，而Landon的新页面对业务至关重要，所以团队决定从这个版本中删除黑暗主题，并将其移到下一个版本中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/66d0a991f5443f00f91be144991f27d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eGuKZLSkEKBe7pWw"/></div></div></figure><p id="8d1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了做到这一点，团队决定从当前的<code class="fe nk nl nm nn b">master</code>分支中重新创建<code class="fe nk nl nm nn b">pu</code>分支。他们要么通过删除并重新分支最近的<code class="fe nk nl nm nn b">master</code>提交的<code class="fe nk nl nm nn b">pu</code>，要么通过硬重置<code class="fe nk nl nm nn b">pu</code>以匹配最近的<code class="fe nk nl nm nn b">master</code>提交，然后强制推送。</p><p id="6c21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:强制推动是危险的和破坏性的，会吹走分支上的变化。</p><p id="016a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们想要删除对<code class="fe nk nl nm nn b">pu</code>分支的更改，并从原始状态开始。</p><p id="2e2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果让几个有资格的人执行强制推送来定期重置<code class="fe nk nl nm nn b">pu</code>分支让您感到厌烦，我建议您考虑删除<code class="fe nk nl nm nn b">pu</code>分支并重新分支，但是这样做可能会有额外的开销。</p><p id="3fdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦<code class="fe nk nl nm nn b">pu</code>分支可用，所有<em class="lr">应该</em>集成到其中的特性分支将被合并回其中，新的构建将被生成并部署到测试环境中。</p><p id="56ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我喜欢把它想象成一个高度可配置的菜单，在这里你可以选择每个特性是否是一个分支的一部分。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="a421" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">集成到母版中</h1><p id="36cf" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">下一个冲刺阶段，一旦发布被清除，Priya对FOO-123做了一些额外的调整，以允许黑暗主题在Landon的新功能上正确呈现。一旦她准备好了，她就提交另一个拉请求，并在获得批准后合并到<code class="fe nk nl nm nn b">pu</code>中。</p><p id="4700" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一次，一切都很好，FOO-123获得了批准，并进入了发行版。该特征现在需要合并到<code class="fe nk nl nm nn b">master</code>分支中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/bbfe88ae586d64835200a2f2caf9c149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n4NquvfumCiqoEfP"/></div></div></figure><p id="83b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然将<code class="fe nk nl nm nn b">pu</code>直接合并到<code class="fe nk nl nm nn b">master</code>分支<em class="lr">可以</em>工作，但是它有一些缺点:</p><ul class=""><li id="263a" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">您需要检查<code class="fe nk nl nm nn b">pu</code>分支，以确保与它集成的每一个特性都已经通过测试，并被批准发布。如果你犯了一个错误，你就向一个生产就绪的分支中添加了一些未经测试的东西。</li><li id="0a54" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">将整个集成分支合并到<code class="fe nk nl nm nn b">master</code>中会使阅读和理解单个提交历史变得更加困难，因为特性会从一个分支转移到另一个分支。虽然查看单个特性可能有意义，但是阅读实际的整个分支历史会更困难。</li></ul><p id="bf9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们需要<em class="lr">将特征分支合并到主分支中，而不是将建议的更新合并到主分支中。</em></p><p id="fa15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是人们理解Git核心团队工作流程的首要问题，所以强调这一点很重要。</p><p id="dd88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">取而代之的是，我们首先切换到我们的特性分支，然后<code class="fe nk nl nm nn b">git rebase master</code>将该特性重新基于最新版本的master。这有助于保持我们的版本历史原始，并允许我们在分支内部解决合并冲突，而不是在我们正在集成的分支内部。</p><p id="39be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦完成，合并被提交，我们切换到<code class="fe nk nl nm nn b">master</code>分支，然后通过<code class="fe nk nl nm nn b">git merge FOO-123</code>(分支的名称)合并主题分支。</p><p id="54e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提交和推送合并后，它现在是下一个版本的正式部分，如果您愿意，可以删除单个特性分支<em class="lr">和</em>。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5cca" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">师父有问题怎么办？</h1><p id="bd7c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如果代码进入了需要移除的<code class="fe nk nl nm nn b">master</code>分支，那么现在就有问题了。这个工作流不擅长处理这个任务，因为<code class="fe nk nl nm nn b">master</code>应该是持久的。</p><p id="45fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正因为如此，如果你有任何疑问，我强烈建议你推迟合并到<code class="fe nk nl nm nn b">master</code>中，因为在这个过程的后期合并到master中要比试图从master中删除一些东西或修补master容易得多。</p><p id="fa43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以做的事情之一是制定一个规则，一旦工作项被产品管理批准，它们就被关闭并合并到<code class="fe nk nl nm nn b">master</code>中，任何调整都需要一个新的工作项，而不是重新打开旧的工作项。</p><p id="7c72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据我的经验，这往往会产生良好的结果，但你的里程可能会有所不同。</p><p id="abb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你<em class="lr">真的</em>需要对<code class="fe nk nl nm nn b">master</code>进行调整，在我看来你有几个选择:</p><ul class=""><li id="e1ca" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">要求一个新的工作项通过管道并进入<code class="fe nk nl nm nn b">master</code>分支，包含您想要的任何变更。</li><li id="c8ff" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">将<code class="fe nk nl nm nn b">master</code>恢复到已知的良好状态，然后强制将项目推回并合并到该状态。</li><li id="dfbf" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">使用revert commit将特定的提交还原到master并在以后重新集成。</li></ul><p id="71c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些都不是很好的选择:</p><ul class=""><li id="8285" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">你总是希望<code class="fe nk nl nm nn b">master</code>是可发布的，所以等待一个新项目的到来限制了你的灵活性。</li><li id="07a1" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">除非在极端情况下，否则强制推送在你的<code class="fe nk nl nm nn b">master</code>分支上做起来太危险了，所以它不应该是你正常工作流程的一部分。</li><li id="5373" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">还原提交会使您的版本历史变得混乱，如果后续提交修改了相同的代码区域，甚至可能无法工作。</li></ul><p id="e765" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总而言之，在集成之前，你最好花额外的时间来确保特性真的很好。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1cad" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">其他建议</h1><p id="44af" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我强烈建议您在<code class="fe nk nl nm nn b">master</code>分支上标记发布，因为标记的存在允许您快速创建一个<code class="fe nk nl nm nn b">maint</code>分支，以便在以后需要时提供补丁，而不必猜测或搜索哪个提交散列对应于您的最后一个产品发布。</p><p id="96e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我主张你应该在每次冲刺开始的时候把你的<code class="fe nk nl nm nn b">pu</code>分支重置为<code class="fe nk nl nm nn b">master</code>。这有助于在比较特征分支和<code class="fe nk nl nm nn b">pu</code>分支时保持分支比较的准确性。这也使得识别<code class="fe nk nl nm nn b">pu</code>分支中仍悬而未决的东西变得容易。</p><p id="ed81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一些版本控制工具，如GitHub的web用户界面，通过将您试图集成的分支合并到您的特性分支来处理合并冲突。</p><p id="5b6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当试图将一个特征分支合并到<code class="fe nk nl nm nn b">pu</code>时，这是一个问题，因为你不希望其他特征在你不知情的情况下进入特征分支。相反，使用命令行或外部工具如<a class="ae lq" href="https://www.gitkraken.com/invite/4tRysUoN" rel="noopener ugc nofollow" target="_blank"> GitKraken </a>来解决<code class="fe nk nl nm nn b">pu</code>中的合并冲突。</p><p id="5826" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你不喜欢<code class="fe nk nl nm nn b">pu</code>这个名字，我推荐叫分公司<code class="fe nk nl nm nn b">qa</code>。我个人用<code class="fe nk nl nm nn b">releases</code>代替<code class="fe nk nl nm nn b">master</code>，用<code class="fe nk nl nm nn b">qa</code>代替<code class="fe nk nl nm nn b">pu</code>，但是概念是一样的，不管你用哪个术语。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1a3e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">维护版本呢？</h1><p id="9676" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">这个模型不太适合长期运行的维护分支。如果你在一个不经常发布的环境中工作，你应该考虑像GitFlow或者其他Git方法。</p><p id="c282" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般来说，在Git核心团队的工作流程下，您会发现自己希望更频繁地从<code class="fe nk nl nm nn b">master</code>发布补丁，而不是将补丁发布到产品中。</p><p id="4710" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果您<em class="lr">确实</em>需要做一个修补程序，您可以切换到您在给定版本的<code class="fe nk nl nm nn b">master</code>分支上创建的标签，并在该位置创建一个代表产品补丁的新分支。</p><p id="c25d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，您可以总是拥有一个<code class="fe nk nl nm nn b">maint</code>分支，并更新该分支以指向最新的产品发布，提交每个发布。</p><p id="78a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建修补程序分支后，您可以分支该分支，为生产修补程序创建单独的功能分支。然后，将您的特性分支合并到修复分支，生成一个构建，让QA和产品验证这个构建，然后将它应用到生产中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/d59704eb3b6b50298e0eb83bce3c8cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZsI_j9ODlr_mHQyr"/></div></div></figure><p id="740c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个不同的工作流的存在是为了防止<code class="fe nk nl nm nn b">master</code>中比生产标签更新的变更进入生产。</p><p id="c1b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦应用了生产补丁，该特性也应该合并到<code class="fe nk nl nm nn b">pu</code>中，然后在<code class="fe nk nl nm nn b">pu</code>中测试后再合并到<code class="fe nk nl nm nn b">master</code>中。如果做不到这一点，将会导致一个回归问题，即在下一个版本中不再存在应用的产品补丁。</p><p id="9b1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然您<em class="lr">可以用这种方式</em>处理维护问题，但是如果您确实习惯性地需要生产补丁和维护分支，您应该考虑更频繁地发布<em class="lr"/>，以便在计划的发布中更容易实现缺陷解决，并且补丁是为那些真正可怕的高严重性错误保留的。</p><p id="2c98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果事情严重到足以保证生产补丁对您的团队来说是经常发生的，那么您也应该好好审视一下您的开发和测试实践。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="cfeb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="a9d3" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">这个工作流程并不适合所有人，但是如果您想要绝对控制哪个构建中有什么特性，这是一个需要认真考虑的工作流程。</p><p id="08df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这只是gitworkflow的一种风格。如果您想了解更多，我推荐您阅读以下材料:</p><ul class=""><li id="43ea" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><a class="ae lq" href="https://git-scm.com/docs/gitworkflows" rel="noopener ugc nofollow" target="_blank">git workflow文档</a></li></ul></div></div>    
</body>
</html>