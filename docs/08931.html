<html>
<head>
<title>How Observables Work — Introduction to the Observable Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Observable如何工作JavaScript中的Observable模式介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-the-observable-pattern-in-javascript-3e6ae0ebc22?source=collection_archive---------2-----------------------#2021-06-28">https://betterprogramming.pub/an-introduction-to-the-observable-pattern-in-javascript-3e6ae0ebc22?source=collection_archive---------2-----------------------#2021-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/526319dbd4792c951db2ce8da72d66c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Scn_CahlNOhEw_lO"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Andrew Coop 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="3ed6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你曾经使用过JavaScript，那么你很有可能使用过<code class="fe le lf lg lh b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>。这是该语言的一个超级有趣和强大的特性，但它的局限性是它只能处理单一事件(当某件事情完成或失败时)。</p><p id="953f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正因为如此，<code class="fe le lf lg lh b">Observables</code>在很多情况下会更加有用。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="413b" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">可观与承诺</h1><p id="3be0" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><code class="fe le lf lg lh b">Observables</code>可以提供<code class="fe le lf lg lh b">Promise</code>的特性，处理零个或多个事件，像流一样工作。默认情况下，<code class="fe le lf lg lh b">Observables</code>可以被取消，只有当你订阅时才开始，而不是像<code class="fe le lf lg lh b">Promises</code>那样立即开始。最重要的是，你可以使用操作符，如果需要的话甚至可以重试。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="50d8" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">可观察的行话</h1><p id="def4" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">当你在谈论<code class="fe le lf lg lh b">Observables</code>时，你需要熟悉几个概念:</p><ul class=""><li id="fbf3" class="ms mt it ki b kj kk kn ko kr mu kv mv kz mw ld mx my mz na bi translated"><code class="fe le lf lg lh b">Observable</code>:懒惰的多值施法者。</li><li id="772a" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated"><code class="fe le lf lg lh b">Observer</code>:来自<code class="fe le lf lg lh b">Observable</code>的价值消费者。</li><li id="7249" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated"><code class="fe le lf lg lh b">Subjects</code>:一种特殊类型的<code class="fe le lf lg lh b">Observable</code>，其工作方式类似于事件发射器，可以向许多<code class="fe le lf lg lh b">Observers</code>多播值，因为它保存了所有<code class="fe le lf lg lh b">Observers</code>的列表，其中<code class="fe le lf lg lh b">Observable</code>只能单播。</li><li id="12c8" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated"><code class="fe le lf lg lh b">Subscription</code>:订阅时返回的对象。它代表一种可任意使用的资源。</li><li id="cd70" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated"><code class="fe le lf lg lh b">Operators</code>:用于管道<code class="fe le lf lg lh b">Observable</code>值或创建<code class="fe le lf lg lh b">Observables</code>的函数。</li><li id="d057" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated"><code class="fe le lf lg lh b">Scheduler</code>:控制订阅开始时间和消息发送时间的部分。</li></ul></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="81a4" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">理解可观察的API</h1><p id="05c1" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我想使用第三方库，但是我相信如果我展示一个简单得多的<code class="fe le lf lg lh b">Observable</code>代码会更好，这样你就可以理解在引擎盖下发生了什么。让我们先了解一下<code class="fe le lf lg lh b">Observable</code>是如何工作的。</p><pre class="ng nh ni nj gt nk lh nl nm aw nn bi"><span id="f029" class="no lq it lh b gy np nq l nr ns">const obs = new <strong class="lh iu">Observable</strong>((subscriber) =&gt; {<br/>  // some logic<br/>});</span></pre><p id="9354" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用函数初始化<code class="fe le lf lg lh b">Observable</code>。这个功能就是<code class="fe le lf lg lh b">observer</code>。<code class="fe le lf lg lh b">observer</code>被一个对象调用，即<code class="fe le lf lg lh b">subscriber</code>。一旦用<code class="fe le lf lg lh b">subscriber</code>对象调用了<code class="fe le lf lg lh b">observer</code>函数，它就可以调用这个订阅者中的三个方法——方法<code class="fe le lf lg lh b">next</code>、<code class="fe le lf lg lh b">error</code>、<strong class="ki iu">、</strong>和<code class="fe le lf lg lh b">complete</code>。</p><pre class="ng nh ni nj gt nk lh nl nm aw nn bi"><span id="a39c" class="no lq it lh b gy np nq l nr ns">const obs = new <strong class="lh iu">Observable</strong>((subscriber) =&gt; {<br/>  subscriber.<strong class="lh iu">next</strong>(20);<br/>  subscriber.<strong class="lh iu">next</strong>(30);<br/>  subscriber.<strong class="lh iu">complete</strong>(40);<br/>});</span></pre><p id="afc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码会发出<code class="fe le lf lg lh b">20</code>、<code class="fe le lf lg lh b">30</code>，然后用<code class="fe le lf lg lh b">40</code>完成订阅。您使用<code class="fe le lf lg lh b">next</code>方法来发出任何值。您可以使用<code class="fe le lf lg lh b">error</code>方法在出错的情况下发出一个错误。您可以用<code class="fe le lf lg lh b">complete</code>方法发出信号表示您已经完成了值的发出，该方法(像<code class="fe le lf lg lh b">error</code>方法一样)将<em class="nt">终止订阅</em>。</p><p id="8d0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您初始化一个<code class="fe le lf lg lh b">Observable</code>时，您得到一个<code class="fe le lf lg lh b">observable</code>对象，您可以调用subscribe方法来初始化值发出。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9bee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您订阅一个<code class="fe le lf lg lh b">observable</code>时，您会得到一个<code class="fe le lf lg lh b">subscription</code>对象。<code class="fe le lf lg lh b">subscribe</code>方法有三个功能。只有第一个是必需的。也可以用包含<code class="fe le lf lg lh b">next</code>、<code class="fe le lf lg lh b">complete</code>和<code class="fe le lf lg lh b">error</code>方法的单个对象来调用它。</p><p id="0e00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些值仅在您订阅时发出，而不是在您创建<code class="fe le lf lg lh b">observable</code>时发出。这意味着，对于我们的例子，每次我订阅，我会得到三个值，并完成。因为<code class="fe le lf lg lh b">subscription</code>完成了，我不需要<code class="fe le lf lg lh b">unsubscribe</code>，这是一个你可以在订阅时返回的<code class="fe le lf lg lh b">subscription</code>对象上调用的方法。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="d4e3" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建一个基本的可观察对象</h1><p id="5e5b" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">一个简单的<code class="fe le lf lg lh b">observable</code>实现可以是这样的:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5d20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码显示，当您初始化<code class="fe le lf lg lh b">Observable</code>时，它会接受一个<code class="fe le lf lg lh b">observer</code>函数，但在调用<code class="fe le lf lg lh b">subscribe</code>方法之前不会对它做任何事情。这就是为什么<code class="fe le lf lg lh b">subscription</code>是触发数值发射的功能。</p><p id="d2ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个<code class="fe le lf lg lh b">if</code>和<code class="fe le lf lg lh b">else</code>简单地覆盖了<code class="fe le lf lg lh b">complete</code>方法来调用<code class="fe le lf lg lh b">unsubscribe</code>，这可以是一个由<code class="fe le lf lg lh b">observer</code>返回的函数来帮助清理<code class="fe le lf lg lh b">subscription</code>。</p><p id="8710" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用一个包含三个方法的<code class="fe le lf lg lh b">Observer</code>对象调用<code class="fe le lf lg lh b">observer</code>函数，这三个方法将调用传递给<code class="fe le lf lg lh b">subscribe</code>函数的三个方法。<code class="fe le lf lg lh b">Observer</code>可能看起来像这样:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8516" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您可能已经意识到的，这是一个回调系统，它以一种奇怪的前后方式将函数匹配在一起，从而创建了<code class="fe le lf lg lh b">subscription</code>系统。</p><p id="8d0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现可能要复杂得多，因为这甚至不包括调度器和管道值的能力。要开始使用<code class="fe le lf lg lh b">Observables</code>，考虑安装并使用<a class="ae kf" href="https://rxjs.dev/guide/observable" rel="noopener ugc nofollow" target="_blank"> RxJs库</a>。它附带了大量的操作符和其他特性。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="afe2" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用可观测量</h1><p id="55bc" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">用<code class="fe le lf lg lh b">Promises</code>不能做的事情是一遍又一遍地发出值。下面的代码显示了一个使用<code class="fe le lf lg lh b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval" rel="noopener ugc nofollow" target="_blank">setInterval</a></code>定时器函数的例子:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2ba1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你也可以使用它作为一个简单的文件上传器，并监控进度，这比使用<code class="fe le lf lg lh b">Promise</code>更好。美妙的是停止上传非常容易。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d779" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe le lf lg lh b">Promise</code>实现这一点将需要<code class="fe le lf lg lh b">Promise</code>和回调的奇怪组合，这几乎让人难以理解。</p><p id="0dac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看本文的所有源代码。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="8560" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">结论</strong></h1><p id="5bc2" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">打开一个完全不同的编程世界。它们使您的应用程序具有无限的能力和更多的控制力，具有反应性和事件驱动性。你甚至不需要把<code class="fe le lf lg lh b">Promises</code>留在后面，因为把它们和<code class="fe le lf lg lh b">Promises</code>结合起来也一样容易。</p><p id="dae3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑冒险进入<code class="fe le lf lg lh b">Observables</code>的世界，用JavaScript等等改进你的编程方式。<a class="ae kf" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>是一个功能强大的库，拥有多种语言版本，如Java、Python、Javascript、Kotlin、C++等。看看这个。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/79122679204c8ac0aa65ca22857737ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kKfpitAbaRbqRAXx0-YqTw.gif"/></div></div></figure><p id="c729" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="nt"> YouTube频道</em> </strong> <em class="nt"> : </em> <a class="ae kf" href="https://www.youtube.com/channel/UCrU33aw1k9BqTIq2yKXrmBw" rel="noopener ugc nofollow" target="_blank"> <em class="nt">分号前</em></a><em class="nt"><br/></em><strong class="ki iu"><em class="nt">网站</em></strong><em class="nt">:</em><a class="ae kf" href="https://beforesemicolon.com/" rel="noopener ugc nofollow" target="_blank"><em class="nt">beforesemicolon.com</em></a></p></div></div>    
</body>
</html>