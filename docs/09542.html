<html>
<head>
<title>Build Your First Golang CLI Tool for JSON Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建第一个用于JSON验证的Golang CLI工具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-first-golang-cli-tool-for-json-validation-30dd4ff0b963?source=collection_archive---------6-----------------------#2021-09-07">https://betterprogramming.pub/build-your-first-golang-cli-tool-for-json-validation-30dd4ff0b963?source=collection_archive---------6-----------------------#2021-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5952" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">检查JSON格式是否正确的工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c6bc053ececba09abd00b88b8a13bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YH_zfktV-QwoIB65qCWmAw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@_imkiran?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">赛·基兰·阿纳加尼</a>在<a class="ae ky" href="https://unsplash.com/s/photos/linux?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="6de5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的3个月里，我一直在和Golang一起工作，我最终决定做一些有助于我提升技能的事情。除了命令行之外，还有什么比设计应用程序更好的方法呢！让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5a03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们将建造什么？</h1><p id="aae4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将构建一个命令行工具，帮助我们验证文本文件中的JSON文本，并告诉我们文件的格式是否正确。</p><p id="068e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果文件格式正确，用户可以为我们提供一个选项，使用命令行参数生成一个格式正确的JSON文件。</p><p id="7071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以为我们的应用程序设置详细级别，这意味着我们可以告诉用户文件格式是否正确，错误是什么以及在哪一行检测到它。对于这个例子来说，错误处理是非常基本的，它包括一个括号和引号检查。然而，主要的复杂性在于为用户提供详细的能力并找出错误的位置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1691" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="9073" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你应该知道基本的Golang语法来理解代码。如果你理解了<a class="ae ky" href="https://gobyexample.com/" rel="noopener ugc nofollow" target="_blank">切片、函数、指针和控制结构</a>，那么我们就可以开始了！我在要点代码中提供了注释，这样你就不会迷路。</p><p id="4775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这个<a class="ae ky" href="https://github.com/shadowshot-x/go-cli-jsonOps" rel="noopener ugc nofollow" target="_blank"> Github资源库</a>中找到完整的源代码。</p><h1 id="1b65" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">项目结构</h1><p id="604a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可以在<code class="fe ne nf ng nh b">main.go</code>里面写完整的代码。然而，我决定以模块的形式编写代码，这样我就可以添加更多的功能。我采用这个项目结构来实现模块化。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="b9cb" class="nm md it nh b gy nn no l np nq">- src/<br/>-- example.com/<br/>--- check.txt<br/>--- go.mod<br/>--- main.go<br/>--- jsonvalidator/<br/>    - jsonvalidator.go<br/>    - jsonvalidator_test.go</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5068" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">项目索引</h1><p id="68fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我把这个项目分成几个部分，以便你能更好地理解它。</p><ol class=""><li id="12e7" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">使用<code class="fe ne nf ng nh b">flags</code>从CLI获取参数并解析</li><li id="5706" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">使用<code class="fe ne nf ng nh b">os</code>模块检查文件有效性并读取文件</li><li id="c09a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">JSON文件的验证逻辑和详细的处理</li><li id="cdc3" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">保存格式良好的JSON文件</li></ol><h1 id="b118" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">1.解析从CLI到Golang变量的参数</h1><p id="490c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Golang有一个名为<a class="ae ky" href="https://pkg.go.dev/flag" rel="noopener ugc nofollow" target="_blank"> flag </a>的包，帮助我们在命令行级别进行解析。在这里，我使用这个包来解析Golang变量的参数。<code class="fe ne nf ng nh b">flag</code>包帮助定义参数，提供描述，并通过引用指针变量来传递这些参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="946d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还检查用户是否提供了正确数量的参数。命名错误由Golang中的标志包本身处理。</p><h1 id="ebe0" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">2.文件验证并读取文件内容</h1><p id="f92c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们希望确保用户在参数中提供的文件是正确的并且存在。使用函数处理这种情况有助于减少冗余代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="5115" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">3.JSON文件的验证逻辑和详细处理</h1><p id="8d16" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">还记得验证括号代码<a class="ae ky" href="https://leetcode.com/problems/valid-parentheses/" rel="noopener ugc nofollow" target="_blank">有效性的问题吗？</a></p><p id="576b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，我们在这里处理的问题是它的一个扩展版本。我在Golang 中实现了一个s <a class="ae ky" href="https://yourbasic.org/golang/implement-stack/" rel="noopener ugc nofollow" target="_blank"> tack来解决这个问题。首先，我们需要确保文件中没有前导或尾随空格。</a></p><p id="e868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们逐个字符地检查文件。每当我们遇到<code class="fe ne nf ng nh b">{</code>时，我们就把它添加到堆栈中，每当我们看到<code class="fe ne nf ng nh b">}</code>时，我们就从堆栈中弹出。</p><p id="d44e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果堆栈在结束前的任何一点变空，我们知道括号是无效的。如果堆栈最后不是空的，我们知道括号是不平衡的。</p><p id="6553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要检查文件中是否没有<code class="fe ne nf ng nh b">“”</code>以外的字符。所以，我使用了一个简单的计数器，当我们看到一个开始引用<code class="fe ne nf ng nh b">“</code>时，它就会被设置。如果没有设置，我们看到一个字符，这意味着这个字符在引号之外。</p><p id="b37f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还添加了线条功能。每当看到换行符时，我们就增加line变量。因此，对于循环中的每次迭代，我们将得到当前的行号。</p><p id="3349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在我们看到错误的每个位置，我们可以检查verbose。如果设置了verbose，我们可以描述错误和位置。我编写了一个单独的函数，打印文件内容，并在出错的行号上添加一个高亮显示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="079e" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">4.保存格式良好的JSON</h1><p id="486e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个简单的逻辑，使用<code class="fe ne nf ng nh b"><a class="ae ky" href="https://pkg.go.dev/io/ioutil" rel="noopener ugc nofollow" target="_blank">ioutil</a></code>包的<code class="fe ne nf ng nh b">WriteFile</code>功能来实现。我们需要一个字节数组来做到这一点，我们可以根据用户提供的参数来控制它。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="b7ff" class="nm md it nh b gy nn no l np nq">if *prettyPtr == 1 {</span><span id="a61b" class="nm md it nh b gy oh no l np nq">err := ioutil.WriteFile("shadow-pretty.json", fileBytes, 0644)</span><span id="4d53" class="nm md it nh b gy oh no l np nq">if err != nil {</span><span id="9ae1" class="nm md it nh b gy oh no l np nq">fmt.Println(err)</span><span id="40cc" class="nm md it nh b gy oh no l np nq">os.Exit(1)</span><span id="12fe" class="nm md it nh b gy oh no l np nq">}</span><span id="5b6d" class="nm md it nh b gy oh no l np nq">fmt.Println("Saved Your Pretty JSON file in ./shadow-pretty.json")</span><span id="b6df" class="nm md it nh b gy oh no l np nq">}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3d23" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将所有东西捆绑在一起</h1><p id="b6d9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因此，在看到了独立工作的模块后，让我们将它们组合起来完成我们的项目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="02e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！如果您一直这样做，那么您已经构建了Golang的第一个CLI应用程序。要查看完整的代码，请务必访问上面提供的Github链接。</p><p id="9e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看这段代码在您的终端上会是什么样子，您可以查看下面的屏幕截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/e7ead30491a68c42bbb174b8e854c281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Js1gJeWl38LguASY0jG47A.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="00af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="fc36" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望你从这篇文章中获得一些知识。感谢阅读。</p><p id="7a57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些帮助我建立这个项目的参考资料:</p><ol class=""><li id="7df1" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.rapid7.com/blog/post/2016/08/04/build-a-simple-cli-tool-with-golang/" rel="noopener ugc nofollow" target="_blank">用Golang构建简单的CLI工具</a></li><li id="49f1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/13514184/how-can-i-read-a-whole-file-into-a-string-variable" rel="noopener ugc nofollow" target="_blank">如何将整个文件读入一个字符串变量</a></li></ol></div></div>    
</body>
</html>