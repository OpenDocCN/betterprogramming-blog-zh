<html>
<head>
<title>How to Set Up CI/CD With GitHub Actions for iOS (Updated)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用GitHub Actions为iOS设置CI/CD(更新)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-setup-ci-cd-a-swift-project-with-github-actions-31210592c14c?source=collection_archive---------8-----------------------#2020-04-22">https://betterprogramming.pub/how-to-setup-ci-cd-a-swift-project-with-github-actions-31210592c14c?source=collection_archive---------8-----------------------#2020-04-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="7a80" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">推送至特定分支时执行操作</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/eb12c160114949440832c8db31e03420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwt7byU6MG5J7MfbSDr2vw.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">图片由<a class="ae kw" href="https://www.pxfuel.com/en/free-photo-jlbxz" rel="noopener ugc nofollow" target="_blank"> Pxfuel </a>提供</p></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><a href="https://raulferrer.dev"><div class="gi gj kx"><img src="../Images/4559de80fb63bfa9a7c3d7a9ceaa962f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JG2ALPF7dH51wuAxTnReEQ.png"/></div></a></figure><p id="6ca9" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">我们来谈谈如何用GitHub Actions设置持续集成和持续交付(CI/CD)。但是等一下——CI/CD是什么意思？</p><p id="d7d0" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">当不同的开发人员在一个应用程序中一起工作时，如果代码合并同时发生，就会出现许多问题:不同开发人员的代码之间的冲突、错误等。这一切都让这个过程变得缓慢。这就是CI/CD的用武之地。</p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="78d3" class="mb mc ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">持续集成</h1><p id="0b5c" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">持续集成(CI)允许不同的开发人员频繁地上传和合并同一个存储库分支中的代码变更。一旦代码被上传，它将通过单元测试和集成测试自动验证(上传的代码和应用程序的其余组件)。如果出现错误，可以更简单地进行更正。</p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="544d" class="mb mc ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">连续交付(CD)</h1><p id="c467" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">在连续交付(CD)中，引入并通过CI流程的新代码会自动发布到生产环境中(这种实现可能需要人工批准)。我们的意图是，存储库代码总是处于允许在生产环境中实现的状态。</p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="9006" class="mb mc ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">持续部署(CD)</h1><p id="9af1" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">在连续部署(CD)中，代码中经过前面两个阶段的所有更改都会自动在生产中实现。</p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="50b9" class="mb mc ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">执行CI/CD的工具</h1><p id="f4d0" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">有许多工具可以配置和执行整个CI/CD流程:</p><ul class=""><li id="5b82" class="my mz ir la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated"><a class="ae kw" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank">詹金斯</a>:自由</li><li id="34fa" class="my mz ir la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><a class="ae kw" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> TravisCI </a>:免费开源库</li><li id="0045" class="my mz ir la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">Nevercode :商用</li><li id="8f9e" class="my mz ir la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">CircleCI :商业版(有一个有限的免费版本)</li><li id="03ca" class="my mz ir la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">商业版(有一个有限的免费版本)</li><li id="6629" class="my mz ir la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><a class="ae kw" href="https://appcenter.ms/" rel="noopener ugc nofollow" target="_blank"> Visual Studio应用中心</a>:商业版(有一个有限的免费版本)</li></ul><div class="nm nn gq gs no np"><a href="https://medium.com/@RaulFerrer_dev/how-to-automatize-the-deployment-of-ios-applications-with-bitrise-c2ca95fa831a" rel="noopener follow" target="_blank"><div class="nq ab fp"><div class="nr ab ns cl cj nt"><h2 class="bd is gz z fq nu fs ft nv fv fx iq bi translated">如何使用Bitrise自动部署iOS应用程序</h2><div class="nw l"><h3 class="bd b gz z fq nu fs ft nv fv fx dk translated">节省大量开发时间</h3></div><div class="nx l"><p class="bd b dl z fq nu fs ft nv fv fx dk translated">medium.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kq np"/></div></div></a></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oe"><img src="../Images/27fbe14eb5377d24cd6910021c9fd147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FvrY8YWdWTmeDhd0.png"/></div></div></figure><p id="e531" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated"><a class="ae kw" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>是执行CI/CD流程的新工具，<a class="ae kw" href="https://github.blog/2018-10-17-action-demos/" rel="noopener ugc nofollow" target="_blank">2018年10月推出</a>，2019年8月beta版上线，2019年11月最终发布。GitHub Actions也是付费的，虽然它有一个带有一些限制的免费版本。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj of"><img src="../Images/0f68fedd8251f24d07338dca34f3f03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/0*q3U2OPCCCLk0fBiS.png"/></div></figure></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="97c3" class="mb mc ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">在iOS/Swift项目中使用GitHub操作的示例</h1><p id="8deb" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">为了展示如何在iOS上的CI/CD过程中使用GitHub动作，我将使用<a class="ae kw" href="https://github.com/raulferrerdev/GHFollowers" rel="noopener ugc nofollow" target="_blank">我自己的项目</a>(基于<a class="ae kw" href="https://seanallen.co/" rel="noopener ugc nofollow" target="_blank"> Sean Allen </a>课程)。</p><p id="b6f1" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">首先，我们进入GitHub项目并访问Actions选项卡:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj og"><img src="../Images/af4209b0288bcfd27730db285d9f6146.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*hvfujRGLu_PKv3kW"/></div></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oh"><img src="../Images/10b4ca3564e3c29e85c3e88164f32a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7jHIV_XZqCR1hZAE.png"/></div></div></figure><p id="5917" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">我们进入一个屏幕，允许我们在预定义的工作流或建立我们自己的工作流之间进行选择。在我们的情况下，我们会选择建立我们自己的。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oh"><img src="../Images/8e6bd9a1c00eca82769a8a66130250d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FebcS2zNRj6RMoIu.png"/></div></div></figure><p id="cb3e" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">我们看到在名为<code class="fe oi oj ok ol b">main.yml</code>的文件中有一个工作流，它在<code class="fe oi oj ok ol b">.github/workflows/</code>中。我们可以用不同的工作流程创建不同的文件。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oh"><img src="../Images/a169210817033eadcfe2478c9901f91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s3rbHTtqI4fffJpY.png"/></div></div></figure><p id="4c30" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">现在我们将改变文件的内容，这样一方面它执行应用程序，另一方面，它执行编程的测试。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="om on l"/></div></figure><h2 id="fc6c" class="oo mc ir bd md op oq dn mh or os dp ml lh ot ou mn ll ov ow mp lp ox oy mr oz bi translated">'名称'</h2><p id="41bc" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">这是我们工作流程的标签。</p><h2 id="c533" class="oo mc ir bd md op oq dn mh or os dp ml lh ot ou mn ll ov ow mp lp ox oy mr oz bi translated">“开”</h2><p id="f8f1" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">GitHub执行用<code class="fe oi oj ok ol b">on</code>键定义的工作流——在我们的例子中，任何<code class="fe oi oj ok ol b">push</code>事件。我们还可以定义一个特定的分支。例如，<code class="fe oi oj ok ol b">devel</code>分支中的<code class="fe oi oj ok ol b">push</code>事件:</p><pre class="kh ki kj kk gu pa ol pb pc aw pd bi"><span id="7650" class="oo mc ir ol b gz pe pf l pg ph">on:<br/>  push:<br/>    branches:<br/>    - devel</span></pre><h2 id="d602" class="oo mc ir bd md op oq dn mh or os dp ml lh ot ou mn ll ov ow mp lp ox oy mr oz bi translated">乔布斯的</h2><p id="9031" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">每个工作流由一个或多个<code class="fe oi oj ok ol b">jobs</code>组成。在我们的例子中，只有一个。</p><h2 id="6de7" class="oo mc ir bd md op oq dn mh or os dp ml lh ot ou mn ll ov ow mp lp ox oy mr oz bi translated">“连续运行”</h2><p id="367e" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">此参数包含将在其中执行代码的虚拟机的类型。在这种情况下，我们将使用<code class="fe oi oj ok ol b">macos-latest</code>(查看不同类型的可用虚拟机)。</p><h2 id="7f8b" class="oo mc ir bd md op oq dn mh or os dp ml lh ot ou mn ll ov ow mp lp ox oy mr oz bi translated">“战略”和“矩阵”</h2><p id="1be7" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">一个<code class="fe oi oj ok ol b">strategy</code>创建一个<code class="fe oi oj ok ol b">matrix</code>环境，在其中执行工作。每个<code class="fe oi oj ok ol b">matrix</code>允许我们建立一组不同配置的虚拟环境。在我们的例子中，我们设置了iOS模拟器，操作系统为13.2.2，iPhone 11 Pro Max设备为:</p><pre class="kh ki kj kk gu pa ol pi bn pj pk bi"><span id="7136" class="pl mc ir ol b be pm pn l po ph">strategy:<br/>        matrix:<br/>          destination: ['platform=iOS Simulator,OS=13.2.2,name=iPhone 11 Pro Max']</span></pre><p id="725d" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">多种配置的一个例子是:</p><pre class="kh ki kj kk gu pa ol pi bn pj pk bi"><span id="cf2b" class="pl mc ir ol b be pm pn l po ph">strategy:<br/>        matrix:<br/>          destination: os: [ubuntu-latest, windows-latest, macOS-latest]</span></pre><p id="ed35" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">一个作业将在ubuntu上运行，另一个将在windows和macOS上运行。</p><h2 id="141d" class="oo mc ir bd md op oq dn mh or os dp ml lh ot ou mn ll ov ow mp lp ox oy mr oz bi translated">“步骤”</h2><p id="a0bb" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">一个<code class="fe oi oj ok ol b">step</code>是一系列的任务。在我们看到的例子中，第一步是检查存储库，以便工作流可以访问它。在这种情况下，这意味着<code class="fe oi oj ok ol b">master</code>分支。</p><pre class="kh ki kj kk gu pa ol pb pc aw pd bi"><span id="4d04" class="oo mc ir ol b gz pe pf l pg ph">- name: Checkout<br/>  uses: actions/checkout@master</span></pre><p id="9dec" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">第二步，在上面定义的环境中构建应用程序(<code class="fe oi oj ok ol b">destination</code>):</p><pre class="kh ki kj kk gu pa ol pb pc aw pd bi"><span id="d77b" class="oo mc ir ol b gz pe pf l pg ph">- name: Build<br/>    run: |<br/>       xcodebuild clean build -project GHFollowers.xcodeproj -scheme GHFollowers -destination "${destination}" CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO ONLY_ACTIVE_ARCH=NO<br/>    env: <br/>      destination: ${{ matrix.destination }}</span></pre><p id="74ed" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">最后，在最后一步中，执行应用程序中创建的测试:</p><pre class="kh ki kj kk gu pa ol pb pc aw pd bi"><span id="34e5" class="oo mc ir ol b gz pe pf l pg ph">- name: Test<br/>  run: |<br/>          xcodebuild clean test -project GHFollowers.xcodeproj -scheme GHFollowersTests -destination "${destination}" CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO ONLY_ACTIVE_ARCH=NO<br/>  env: <br/>         destination: ${{ matrix.destination }}</span></pre><p id="97e6" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">当我们将代码上传到存储库时，这个工作流将会运行。如果我们再次访问存储库的“操作”( Actions)选项卡，我们可以看到工作流执行的时间列表。在这种情况下，如果没有发生错误，我们将获得以下内容:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oh"><img src="../Images/974694135b4e6352fb7c1f7005eba813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dBGpCyG_TPPzRfGF.png"/></div></div></figure><p id="dd88" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">我们可以证明当其中一个测试失败时会发生什么。通过更改其中一个测试，使其不符合要求，您将获得:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oh"><img src="../Images/c82698ffd2dbf9feaf5a13746d50c89d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JZF0lCoY192P_S7c.png"/></div></div></figure><p id="5833" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">这里我们可以看到什么测试失败了。</p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="fed4" class="mb mc ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">结论</h1><p id="b5c6" class="pw-post-body-paragraph ky kz ir la b lb mt js ld le mu jv lg lh mv lj lk ll mw ln lo lp mx lr ls lt ik bi translated">GitHub Actions是CI/CD工具组中的新成员。它是最近才出现的，所以有必要看看它是如何与TravisCI、Bitrise或Jenkins等工具相抗衡的。</p></div></div>    
</body>
</html>