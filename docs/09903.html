<html>
<head>
<title>The Most Delicious Function — Yummy Curry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最美味的功能——美味的咖喱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-most-delicious-function-yummy-curry-aa7c225a1899?source=collection_archive---------10-----------------------#2021-10-27">https://betterprogramming.pub/the-most-delicious-function-yummy-curry-aa7c225a1899?source=collection_archive---------10-----------------------#2021-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b1a6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将一个获得多个参数的函数变成一次只获得一个参数的函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/29c0e7cfe1f411242d46f01b003a7037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sicBmc6WtZmMxYkJ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ninjason?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jason Leung </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="dd32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是一个辛辣的食物和函数式编程的爱好者，你会很高兴。</p><p id="3aad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将解释什么是<code class="fe ls lt lu lv b">curry</code>函数，如何构建它，以及使用它的好处。</p><h1 id="b3c4" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">简短的历史课</h1><p id="9fb0" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">“Currying”是一种数学和计算机科学技术。</p><p id="bc28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“currying”这个名字是在1967年哈斯克尔·库里(Haskell Curry)之后创造的。库里是美国数学家和逻辑学家。</p><p id="3a68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他的名字可能听起来很熟悉。Haskell编程语言也是以他的名字命名的。Haskell的创建者希望它被命名为“Curry”，但这个名字已经被取了。</p><h1 id="b273" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">什么是Currying？</h1><p id="2a7f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在我们继续实现<code class="fe ls lt lu lv b">Curry</code>函数或者解释为什么我们应该使用它之前，我们需要理解它背后的数学技术。</p><p id="b9ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种技术，我们可以得到一个有多个参数的函数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="92c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一次获取一个参数的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0f9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先通过100米的尤塞恩博尔特记录，然后我们得到一个函数返回。</p><p id="342a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向该函数传递我跑100米的结果(我差一点就跑完了)，它将运行下划线函数，并向我们返回false。</p><h1 id="690a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">有什么好处？</h1><p id="3355" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Currying主要用于从一般的函数中生成更具体的函数。</p><p id="18c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个咖啡机的例子。我们将从一个制作咖啡的通用函数(作者没有制作好咖啡)开始，并开始创建更具体的函数。</p><p id="c229" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们的<code class="fe ls lt lu lv b">makeCoffee</code>函数的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="acae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做一杯美味的美式咖啡简单又容易，但是周六就要到了，我们要举办一场卡布奇诺派对。我们不想每次都用‘卡布奇诺’来调用<code class="fe ls lt lu lv b">makeCoffee</code>函数。</p><p id="5014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们很幸运，因为<code class="fe ls lt lu lv b">makeCoffee</code>是咖喱，我们可以创造我们的新品牌<code class="fe ls lt lu lv b">makeCappuccino</code>功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b216" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以轻松地为所有快乐的客人提供卡布奇诺。</p><p id="a314" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的咖啡师朋友过来告诉我们，完美的卡布奇诺配有3.5盎司的牛奶。因为我们渴望完美，我们创造了我们的<code class="fe ls lt lu lv b">makePerfectCappuchino</code>功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b81a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们利用了curried函数返回curried函数本身的事实，从<code class="fe ls lt lu lv b">makeCappuccino</code>创建了一个更具体的函数。</p><p id="4d5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以为我们所有的客人提供一杯完美的卡布奇诺。</p><p id="f79e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的例子，但是这个工具可以在很多情况下提供帮助，并帮助减少我们编写的新函数的数量。</p><h1 id="7173" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">手工染色</h1><p id="8511" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在我们开始用更花哨的方法涂抹之前，让我们先用手动涂抹来弄脏我们的手。</p><p id="fa12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用常规函数语法和ES6 arrow函数语法分别编写我们的<code class="fe ls lt lu lv b">isNewOlympicRecord</code>函数。</p><p id="c5ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的目标是能够以这种方式调用我们的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cb1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要用手工编写<code class="fe ls lt lu lv b">isNewOlympicRecord</code>,我们有三个要求:</p><ol class=""><li id="eaa0" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">每次我们收到一个参数，我们需要返回一个新的函数。</li><li id="8a75" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">这个函数需要“记住”我们已经传递给它的参数。</li><li id="9d73" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">当我们得到最后一个参数时，我们需要计算结果并返回它。</li></ol><p id="7ed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，JS的闭包可以帮助我们轻松实现第二个需求。闭包为我们提供了一种创建可以访问外部函数范围的内部函数的方法。</p><p id="0e89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以像母亲和婴儿一样思考这个问题。婴儿可以利用他母亲的资源。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b143" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，<code class="fe ls lt lu lv b">babyFunc</code>可以访问<code class="fe ls lt lu lv b">motherFunc</code>的范围，这意味着他可以访问以下内容:</p><ol class=""><li id="e2ce" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">论据:<code class="fe ls lt lu lv b">arg1</code>，<code class="fe ls lt lu lv b">arg2</code></li><li id="b26f" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">变量:<code class="fe ls lt lu lv b">var1</code>，<code class="fe ls lt lu lv b">var2</code></li><li id="5c57" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">功能:<code class="fe ls lt lu lv b">func1</code>，<code class="fe ls lt lu lv b">func2</code></li></ol><p id="adbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以返回一个“记住”外部作用域函数的参数的函数。</p><p id="1c79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下的就是当我们得到最后一个参数时计算结果，并在我们收到的每个参数上返回一个新函数。</p><p id="bc92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结合起来，我们得到以下结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以使用arrow函数语法编写一个不太冗长的版本。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ab97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个版本是等效的。</p><p id="13d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我们已经建立了我们的手动<code class="fe ls lt lu lv b">curry</code>功能。</p><h1 id="ac97" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">为N个参数构建我们自己的定制函数</h1><p id="ab13" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">编写我们自己的手动curry函数可能相当麻烦，如果我们得到了一个函数作为参数，并希望使它成为curry函数，该怎么办？</p><p id="ba15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这些情况和其他情况，我们将编写自己的<code class="fe ls lt lu lv b">curry</code>函数。我们的函数将得到世界上任何一个函数，并返回给我们一个新的漂亮的curried函数。</p><p id="5f57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要考虑的第一件事是我们的停止条件，也就是什么时候停止返回一个函数，并运行带有所有参数的原始函数。</p><p id="9cb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们的<code class="fe ls lt lu lv b">curry</code>函数得到的参数数量与原始函数应该得到的数量相同时，我们需要这样做。</p><p id="1d29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，当我们收到原始函数<strong class="ky ir">的arity数量的参数时，我们应该运行原始函数。Arity就是函数接受的参数的数量。</strong></p><p id="2616" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的第一个版本<code class="fe ls lt lu lv b">curry</code>将得到以下两个参数:</p><ol class=""><li id="46a5" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">arity</code>:号。</li><li id="d75b" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe ls lt lu lv b">f</code>:功能。</li></ol><p id="83d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">返回值将是如下所示的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8e3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在函数体内我们会发现什么？</p><p id="65b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们知道，我们应该不断返回一个函数，直到我们得到<code class="fe ls lt lu lv b">arity</code>数量的参数，我们需要一种方法来记住我们已经得到的参数(范围到救援！)</p><p id="b9d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们会有这样的东西:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c5a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们没有达到停止条件，我们需要做什么？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5a85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需返回我们的<code class="fe ls lt lu lv b">curried</code>函数！这是我们的第一个版本。</p><h1 id="86bf" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">第二个版本:自动Arity，纯</h1><p id="6671" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">对于我们当前版本的<code class="fe ls lt lu lv b">curryN</code>，我们有两个问题:</p><ol class=""><li id="a903" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">它不纯洁！我们正在改变<code class="fe ls lt lu lv b">args</code>数组，所以我们应该使代码不可变。</li><li id="e7bf" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">我们每次调用<code class="fe ls lt lu lv b">curryN</code>都要指定函数的arity是什么。相反，我们可以推导出arity。</li></ol><p id="b082" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决我们的第一个问题，我们需要停止变异<code class="fe ls lt lu lv b">args</code>数组。</p><p id="1716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种方法是获取数组作为输入，并返回一个新数组作为输出。</p><p id="2755" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们并不真的想从用户那里获得输入，我们将创建另一个嵌套函数，它将被立即调用以给出第一个输入——一个空的<code class="fe ls lt lu lv b">args</code>数组。</p><p id="c9cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到这样的结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8a27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到了不可变的<code class="fe ls lt lu lv b">curry</code>函数，所有神奇的事情都是使用<code class="fe ls lt lu lv b">nextCurried</code>作为IIFE(立即调用的函数表达式)发生的，它得到一个空数组作为第一个参数。</p><p id="ff7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着我们从用户那里获得更多的参数，我们继续用一个新的参数数组调用<code class="fe ls lt lu lv b">nextCurried</code>。</p><p id="75c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们要做的最后一件事是推导arity，因为我们不希望我们函数的用户在每次调用我们的<code class="fe ls lt lu lv b">curryN</code>函数时都要声明arity。</p><p id="a4f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何做到这一点？</p><p id="c4f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，JavaScript中的函数是对象，<code class="fe ls lt lu lv b">Function</code>对象具有属性length。</p><p id="e256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Function.length</code>给我们确切需要的，用户输入函数所期望的参数个数。我们可以重命名我们的函数<code class="fe ls lt lu lv b">curry</code>并使用<code class="fe ls lt lu lv b">Function.length</code>。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3927" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">重要提示:</strong> <code class="fe ls lt lu lv b">Function.length</code>不考虑“静止参数”。对于更复杂的用例，当<code class="fe ls lt lu lv b">Function.length</code>没有返回参数的真实数目时，用户将不得不自己陈述arity。</p><p id="6602" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以使用ES6 arrow函数语法创建我们的<code class="fe ls lt lu lv b">curry</code>函数，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8ae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">较短但不清晰。在这个版本中，我们仍然以完全相同的方式调用函数。函数参数<code class="fe ls lt lu lv b">nextCurried</code>只是为我们返回的函数起一个名字。</p><h1 id="00bd" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">使用Curry的第三方库</h1><p id="9641" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">尽管我们自己编写<code class="fe ls lt lu lv b">curry</code>函数很有趣，但是已经有一些很好的经过测试的实现，包括如下:</p><h2 id="7025" class="nj lx iq bd ly nk nl dn mc nm nn dp mg lf no np mi lj nq nr mk ln ns nt mm nu bi translated">Ramda.js</h2><div class="nv nw gp gr nx ny"><a href="https://ramdajs.com/docs/#curry" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">拉姆达文件</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">接受一个收敛函数和一个分支函数列表，并返回一个新函数。新的……</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">ramdajs.com</p></div></div></div></a></div><p id="2ff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个使用方法和我们的<code class="fe ls lt lu lv b">curry</code>一样，如果要指定arity，可以使用Ramda.js的<code class="fe ls lt lu lv b">CurryN</code>。</p><h2 id="ca38" class="nj lx iq bd ly nk nl dn mc nm nn dp mg lf no np mi lj nq nr mk ln ns nt mm nu bi translated"><strong class="ak"> lodash </strong></h2><div class="nv nw gp gr nx ny"><a href="https://lodash.com/docs/4.17.15#curry" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">Lodash文档</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">编辑描述</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">lodash.com</p></div></div></div></a></div><p id="60f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与我们的<code class="fe ls lt lu lv b">curry</code>函数使用相同的API。它也可以指定arity，还有一个很好的函数<code class="fe ls lt lu lv b">curryRight</code>，它以相反的顺序接收参数。</p><div class="nv nw gp gr nx ny"><a href="https://lodash.com/docs/4.17.15#curryRight" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">Lodash文档</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">编辑描述</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">lodash.com</p></div></div></div></a></div><h1 id="576b" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">下一步是什么？</h1><p id="9b76" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如果你喜欢这篇短文，我相信你会喜欢凯尔·辛普森的JS功能课程:</p><div class="nv nw gp gr nx ny"><a href="https://github.com/getify/Functional-Light-JS" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">GitHub-getify/Functional-Light-JS:JavaScript中务实、平衡的FP。推特上的@FLJSBook。</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">这本书是对JavaScript中FP的一个平衡的、实用的审视。第一版现已完成。在线阅读此处了解…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div><p id="a6a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我建议复习更多类似以下的概念:</p><ul class=""><li id="c9e4" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr on nb nc nd bi translated">部分应用</li><li id="1f7e" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr on nb nc nd bi translated">排版和管道功能</li></ul><p id="1fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">坚持学习！</p></div></div>    
</body>
</html>