<html>
<head>
<title>Java Annotations Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java注释解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/java-annotations-explained-f1c26580b839?source=collection_archive---------2-----------------------#2020-01-27">https://betterprogramming.pub/java-annotations-explained-f1c26580b839?source=collection_archive---------2-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6cbe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在我们的代码中添加和使用元数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e91d940af4f5469f38ec86435b0d300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbPlRPBROntX9uvbHVwrsQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jasminnb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jasmin Ne </a>在<a class="ae ky" href="https://unsplash.com/@jasminnb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kz"><p id="7ceb" class="la lb it bd lc ld le lf lg lh li lj dk translated"><em class="lk">“注释| a-nə-ˈtā-shən <br/> 1:以评论或解释的方式添加的注释”——</em><a class="ae ky" href="https://www.merriam-webster.com/dictionary/annotation" rel="noopener ugc nofollow" target="_blank"><em class="lk">韦氏词典</em> </a></p></blockquote><p id="ac1f" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf lj im bi translated">有了<a class="ae ky" href="https://www.jcp.org/en/jsr/detail?id=175" rel="noopener ugc nofollow" target="_blank"> JSR-175 </a>，Java 5获得了<a class="ae ky" href="https://en.wikipedia.org/wiki/Metadata_facility_for_Java" rel="noopener ugc nofollow" target="_blank">元数据功能</a>，允许我们用<em class="mg">装饰性语法元数据</em>来注释我们的代码。</p><p id="bf55" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">可以为类型、字段、方法、参数、构造函数、局部变量、类型参数、类型用法甚至其他注释类型提供元数据。通过各种各样的工具，可以在代码生命周期的不同阶段使用它。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="ac45" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">注释剖析</h1><p id="2bc5" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">注释类型的基本定义很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="314b" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">让我们一行一行地看一遍，下面会详细解释每件事:</p><ul class=""><li id="39b8" class="ns nt it ln b lo mh lr mi lu nu ly nv mc nw lj nx ny nz oa bi translated">1: <code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html" rel="noopener ugc nofollow" target="_blank">@Retention</a></code> —注释将在我们代码的哪个生命周期中可用。</li><li id="2eb2" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">2: <code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html" rel="noopener ugc nofollow" target="_blank">@Target</a></code> —我们可以使用注释的地方。</li><li id="f54f" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">3: <code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html" rel="noopener ugc nofollow" target="_blank">@Inherited</a></code> —如果存在，被注释的类型将把它传递给任何子类型。</li><li id="5a7b" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">4: <code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html" rel="noopener ugc nofollow" target="_blank">@Documented</a></code> —如果存在，像<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html" rel="noopener ugc nofollow" target="_blank">javadoc</a></code>这样的文档工具可以访问它。</li><li id="4b75" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">5: <code class="fe ob oc od oe b">@interface</code> —标记注释类型。</li><li id="a945" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">6–7:注释的值，可选默认值。</li></ul><h2 id="021e" class="ok mu it bd mv ol om dn mz on oo dp nd lu op oq nf ly or os nh mc ot ou nj ov bi translated">基本用法</h2><p id="40df" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">最简单的注释用法是在兼容的目标站点使用<code class="fe ob oc od oe b">@MyAnnotation</code>。</p><p id="d89d" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">但是如果没有提供默认值，注释可能需要设置多个值。值名<code class="fe ob oc od oe b">value()</code>是一个特殊的名称。如果没有其他值，它可以不带名称使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="9d70" class="ok mu it bd mv ol om dn mz on oo dp nd lu op oq nf ly or os nh mc ot ou nj ov bi translated">@保留</h2><p id="22d2" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">我们代码的典型生命周期如下:</p><pre class="kj kk kl km gt ow oe ox oy aw oz bi"><span id="321f" class="ok mu it oe b gy pa pb l pc pd">Source Code<br/>   ▼<br/>   ▼ ◁ Compiler<br/>   ▼<br/>Class file<br/>   ▼<br/>   ▼ ◁ JVM<br/>   ▼<br/>Runtime</span></pre><p id="b1e6" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">注释的<em class="mg">保留策略</em>反映了这些生命周期，并为我们提供了一种方式来指定元数据的确切可用性:</p><ul class=""><li id="8f81" class="ns nt it ln b lo mh lr mi lu nu ly nv mc nw lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">RetentionPolicy.SOURCE</code> <br/>注释只在源中可用。编译器将丢弃元数据，因此编译器和运行时都不能访问它。这个保留策略对于<em class="mg">预编译</em>工具很有用，比如<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html" rel="noopener ugc nofollow" target="_blank">注释处理器</a>。</li><li id="3f44" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">RetentionPolicy.CLASS</code> <br/>默认保留策略。注释对编译器是可见的，并且在类文件中可用，但在运行时不可用。任何<em class="mg">后编译</em>字节码工具都可能使用元数据。</li><li id="6eda" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">RetentionPolicy.RUNTIME</code> <br/>所有元数据在运行时都将可用。</li></ul><p id="b307" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">我们的定制注释需要哪种保留策略取决于我们的需求。</p><p id="b1db" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">提供的元数据可能包含关于带注释的代码内部工作的敏感信息。我们应该始终选择尽可能低的保持率，以便我们的代码仍然能够工作。</p><h2 id="b1da" class="ok mu it bd mv ol om dn mz on oo dp nd lu op oq nf ly or os nh mc ot ou nj ov bi translated">@目标</h2><p id="f570" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">不是每个注释在每个可用的目标上都有意义。这就是为什么我们可以明确地设定可接受的目标。八个可用目标在<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html" rel="noopener ugc nofollow" target="_blank">java.lang.annotation.ElementType</a></code>中定义:</p><ul class=""><li id="e83f" class="ns nt it ln b lo mh lr mi lu nu ly nv mc nw lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">ElementType.PACKAGE</code> —包装声明。</li><li id="dba9" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">ElementType.TYPE</code> —类、接口、枚举。</li><li id="4156" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">ElementType.TYPE_PARAMETER</code>-类属类型参数。从Java 8开始可用。</li><li id="2760" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">ElementType.TYPE_USE</code> —类型的任何用法，如声明、泛型参数或类型转换。从Java 8开始可用。</li><li id="1932" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">ElementType.ANNOTATION_TYPE</code>-注释类型。</li><li id="9d8b" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">ElementType.CONSTRUCTOR</code> —构造函数声明。</li><li id="367b" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">ElementType.FIELD</code> —字段和枚举常量。</li><li id="03bd" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">ElementType.METHOD</code> —方法声明。</li><li id="c766" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">ElementType.LOCAL_VARIABLE</code> —局部变量声明(不保留在类文件中或运行时)。</li></ul><p id="aa04" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated"><code class="fe ob oc od oe b">@Target</code>注释接受一组目标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9341" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">如果没有指定<code class="fe ob oc od oe b">@Target</code>，注释默认为除<code class="fe ob oc od oe b">ElementType.TYPE_PARAMETER</code>之外的所有可用的<code class="fe ob oc od oe b">ElementType</code>。</p><h2 id="30d1" class="ok mu it bd mv ol om dn mz on oo dp nd lu op oq nf ly or os nh mc ot ou nj ov bi translated">@继承</h2><p id="20fc" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">默认情况下，注释不会被继承。通过将<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html" rel="noopener ugc nofollow" target="_blank">@Inherited</a></code>添加到注释类型，我们允许它被继承。这只适用于带注释的类型声明，这将把它传递给它们的子类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="714f" class="ok mu it bd mv ol om dn mz on oo dp nd lu op oq nf ly or os nh mc ot ou nj ov bi translated">@已记录</h2><p id="b55c" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">Java对文档的默认行为是忽略任何注释。使用<code class="fe ob oc od oe b">@Documented</code>我们可以改变这一点，使元数据及其值可以通过文档访问。</p><h2 id="8c4f" class="ok mu it bd mv ol om dn mz on oo dp nd lu op oq nf ly or os nh mc ot ou nj ov bi translated">@可重复</h2><p id="ee0f" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">在Java 8之前，我们只能在目标上应用一次特定的注释类型。在注释<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html" rel="noopener ugc nofollow" target="_blank">@Repeatable</a></code>的帮助下，我们现在可以通过提供一个中间注释来声明一个可重复的注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f103" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">现在我们可以多次使用我们的注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="2ed7" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">注释值</h1><p id="ce90" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">能够注释我们的代码并检查注释是否出现在不同的生命周期事件中是很棒的。但是，除了注释类型本身之外，提供额外的值会更好。甚至支持默认值。</p><p id="da47" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">值是可选的，将注释分成两组:</p><ul class=""><li id="fa13" class="ns nt it ln b lo mh lr mi lu nu ly nv mc nw lj nx ny nz oa bi translated">标记-没有值。仅仅是存在就是实际的元数据。例子:<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html" rel="noopener ugc nofollow" target="_blank">@Documented</a></code>、<code class="fe ob oc od oe b">@Inherited</code>、<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html" rel="noopener ugc nofollow" target="_blank">@Override</a></code>。</li><li id="9621" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">配置—存在值，可能带有默认值，以便在使用时减少输入。例子:<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html" rel="noopener ugc nofollow" target="_blank">@Target</a></code>，<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html" rel="noopener ugc nofollow" target="_blank">@Retention</a></code>。</li></ul><p id="dda9" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">Java语言规范(JLS) <a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7" rel="noopener ugc nofollow" target="_blank">将</a> <em class="mg"> </em>配置拆分为普通注释和单元素注释。但在我看来，这两者的行为重叠足以被视为(几乎)相等。</p><p id="f7dc" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">配置注释支持多个值。允许的类型在<a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.1" rel="noopener ugc nofollow" target="_blank"> JLS 9.6.1 </a>中定义:</p><ul class=""><li id="0ee1" class="ns nt it ln b lo mh lr mi lu nu ly nv mc nw lj nx ny nz oa bi translated">原始类型</li><li id="63b3" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b">String</code></li><li id="9434" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">类型<code class="fe ob oc od oe b">Class</code>或<code class="fe ob oc od oe b">Class&lt;T&gt;</code></li><li id="a2f1" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">枚举类型</li><li id="849d" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">注释类型</li><li id="aed1" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated">任何先前类型的数组(仅一维)</li></ul><p id="fa2a" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">数组是唯一处理的。如果使用时只提供一个值，我们可以省略花括号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fc41" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">默认值必须是常量表达式，尽管<code class="fe ob oc od oe b">null</code>是不可接受的。通过使用<code class="fe ob oc od oe b">{}</code>作为默认值，数组可以返回一个空数组。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="baca" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">内置注释</h1><p id="4662" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">除了我们已经遇到的创建注释类型本身之外，JDK还包括多个注释:</p><ul class=""><li id="84b5" class="ns nt it ln b lo mh lr mi lu nu ly nv mc nw lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html" rel="noopener ugc nofollow" target="_blank">@Override</a></code> <br/>表示一个方法覆盖/替换一个继承的方法。这些信息并非绝对必要，但有助于减少错误。如果我们想要覆盖一个方法，但是在签名中有一个简单的类型，或者错误的参数类型，这个错误可能会被忽略。但是如果我们提供了一个<code class="fe ob oc od oe b">@Override</code>注释，编译器会确保我们确实覆盖了一个方法，而不仅仅是意外地添加或重载了它。</li><li id="1fd5" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" rel="noopener ugc nofollow" target="_blank">@Deprecated</a></code> <br/>另一个只编译的注释。我们可以将代码标记为不推荐使用，编译器/IDE可以访问这些信息来告诉我们不应该再使用这些代码。从Java 9开始，以前的标记注释变成了配置注释。添加值<code class="fe ob oc od oe b">String since() default ""</code>和<code class="fe ob oc od oe b">boolean forRemoval() default false</code>是为了给编译器和ide提供更多信息。</li><li id="2937" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" rel="noopener ugc nofollow" target="_blank">@FunctionalInterface</a></code> <br/>从Java 8开始，我们可以将接口标记为<em class="mg">单抽象方法接口</em> (SAM)，所以可以作为lambdas使用。这个标记注释允许编译器确保一个接口只有一个抽象方法。如果我们添加另一个抽象方法，我们的代码将不再编译。这个注释启用了编译器检查，但不是绝对必要的。任何SAM都自动成为一个功能接口。</li><li id="618a" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html" rel="noopener ugc nofollow" target="_blank">@SafeVarargs</a></code> <br/>另一个“相信我，我是工程师”的记号笔标注。告诉编译器我们在使用<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html" rel="noopener ugc nofollow" target="_blank"> varargs </a>时不会做任何不安全的操作。</li><li id="8818" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html" rel="noopener ugc nofollow" target="_blank">@SuppressWarnings</a></code> <br/>一个配置注释，接受一个警告名数组，这些警告名在编译时应该被禁用。</li></ul></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="8df8" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">如何在运行时访问注释</h1><p id="1f91" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">添加元数据是不够的。我们也需要以某种方式访问它。多亏了反射，我们可以通过类对象来访问它:</p><h2 id="73cb" class="ok mu it bd mv ol om dn mz on oo dp nd lu op oq nf ly or os nh mc ot ou nj ov bi translated">检查注释</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="5dd4" class="ok mu it bd mv ol om dn mz on oo dp nd lu op oq nf ly or os nh mc ot ou nj ov bi translated">访问元数据</h2><p id="af77" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">相当于<code class="fe ob oc od oe b">boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>，我们也有访问实际注释实例的方法，为我们提供对其值的访问。</p><p id="65be" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">以下是适用于不同目标的一些方法:</p><p id="d82f" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ln iu">类</strong> </a></p><ul class=""><li id="ca1e" class="ns nt it ln b lo mh lr mi lu nu ly nv mc nw lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getAnnotation-java.lang.Class-" rel="noopener ugc nofollow" target="_blank">&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass)</a></code> —如果存在，返回特定的注释，否则返回<code class="fe ob oc od oe b">null</code>。</li><li id="6544" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getAnnotations--" rel="noopener ugc nofollow" target="_blank">Annotation[] getAnnotations()</a></code> —返回给定类型的所有注释。</li><li id="dd6e" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getAnnotationsByType-java.lang.Class-" rel="noopener ugc nofollow" target="_blank">&lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass)</a></code>-返回给定注释类型的所有注释。</li></ul><p id="c280" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ln iu">方法</strong> </a></p><ul class=""><li id="c4a4" class="ns nt it ln b lo mh lr mi lu nu ly nv mc nw lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#getDeclaredAnnotations--" rel="noopener ugc nofollow" target="_blank">&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</a></code> —如果存在，返回特定的注释，否则返回<code class="fe ob oc od oe b">null</code>。</li><li id="36c5" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#getDeclaredAnnotations--" rel="noopener ugc nofollow" target="_blank">Annotation[] getDeclaredAnnotations()</a></code> —返回方法的所有注释。</li><li id="937c" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#getParameterAnnotations--" rel="noopener ugc nofollow" target="_blank">Annotation[][] getParameterAnnotations()</a></code> —返回一个二维数组，包含按声明顺序排列的参数注释。</li></ul></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="9015" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">用例</h1><p id="8e72" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">一个很好的用例是序列化。有了注释，可以提供许多关于如何处理数据结构的额外元数据。</p><p id="7394" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">JSON序列化框架<a class="ae ky" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank"> Jackson </a>使用<code class="fe ob oc od oe b"><a class="ae ky" href="https://github.com/FasterXML/jackson-annotations/blob/master/src/main/java/com/fasterxml/jackson/annotation/JsonProperty.java" rel="noopener ugc nofollow" target="_blank">@JsonProperty</a></code>注释来提供修改默认序列化过程所需的所有信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="12b8" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">另一个很好的用例是<a class="ae ky" href="https://resteasy.github.io/" rel="noopener ugc nofollow" target="_blank"> RESTEasy </a>如何使用注释来<a class="ae ky" href="https://docs.jboss.org/resteasy/docs/4.4.2.Final/userguide/html/Using_Path.html" rel="noopener ugc nofollow" target="_blank">描述REST端点</a>，因此在其他地方不需要额外的配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b659" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">通过这种方式，RestEASY可以执行路由(<code class="fe ob oc od oe b">@Path</code>)，验证允许的HTTP方法(<code class="fe ob oc od oe b">@POST</code>和<code class="fe ob oc od oe b">@HEAD</code>)，提供从请求中提取的数据(<code class="fe ob oc od oe b">@FormParam</code>和<code class="fe ob oc od oe b">@HeaderParam</code>，并使用定义的媒体类型进行响应(<code class="fe ob oc od oe b">@Produces</code>)。</p><p id="8d82" class="pw-post-body-paragraph ll lm it ln b lo mh ju lq lr mi jx lt lu mj lw lx ly mk ma mb mc ml me mf lj im bi translated">所有这些都不需要任何附加的配置文件或对象。配置就在相应的代码中。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="7a9d" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">结论</h1><p id="280f" class="pw-post-body-paragraph ll lm it ln b lo nl ju lq lr nm jx lt lu nn lw lx ly no ma mb mc np me mf lj im bi translated">注释是为我们自己或者第三方工具和库提供额外数据的好方法。但是要注意解析、编译和查找注释的额外成本，尤其是在运行时。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt ow oe pe bn pf pg bi"><span id="798e" class="ph mu it oe b be pi pj l pc pd"><strong class="oe iu">You like my ramblings about Java? Check out my upcoming book!</strong><br/><a class="ae ky" href="https://belief-driven-design.com/book/" rel="noopener ugc nofollow" target="_blank">https://belief-driven-design.com/book/</a></span></pre><h1 id="eb0e" class="mt mu it bd mv mw pk my mz na pl nc nd jz pm ka nf kc pn kd nh kf po kg nj nk bi translated">资源</h1><ul class=""><li id="2a3f" class="ns nt it ln b lo nl lr nm lu pp ly pq mc pr lj nx ny nz oa bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/annotations/index.html" rel="noopener ugc nofollow" target="_blank">Java教程—注释</a>(甲骨文)</li><li id="cfe7" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/package-summary.html" rel="noopener ugc nofollow" target="_blank">java.lang.annotation</a></code> <a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/package-summary.html" rel="noopener ugc nofollow" target="_blank">包概要</a> (JavaSE 8)</li><li id="6236" class="ns nt it ln b lo of lr og lu oh ly oi mc oj lj nx ny nz oa bi translated"><a class="ae ky" href="https://www.baeldung.com/java-custom-annotation" rel="noopener ugc nofollow" target="_blank">创建自定义注释</a> (Baeldung)</li></ul></div></div>    
</body>
</html>