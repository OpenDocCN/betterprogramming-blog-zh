<html>
<head>
<title>How To Send Server-Side Notifications Through WebSockets in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript通过WebSockets发送服务器端通知</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solving-real-life-problems-in-javascript-sending-server-side-notifications-through-websockets-a3bdb2cc065?source=collection_archive---------2-----------------------#2021-01-26">https://betterprogramming.pub/solving-real-life-problems-in-javascript-sending-server-side-notifications-through-websockets-a3bdb2cc065?source=collection_archive---------2-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f761" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何将解决方案扩展到Android和iOS</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fa8f6f1a7ac84492bd3e8c11733d6338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kwYQ93v6jRRufqs9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普拉蒂克·卡蒂亚尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="46ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，你有一个与后端通信的前端应用程序，你需要向用户发送通知:我们将在<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>下看到你如何在没有开销的情况下做到这一点。</p><p id="bf66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将介绍如何通过WebSockets发送常规通知，将集群考虑在内，我们还将展示iOS和Android上的移动通知作为额外的奖励。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="855b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">背景</h1><p id="90b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://github.com/websockets/ws" rel="noopener ugc nofollow" target="_blank"> ws </a> <strong class="lb iu"> </strong>库，而不是更流行的<a class="ae ky" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>。这主要是因为我们认为不需要Socket.io，ws就足够了，但也因为ws将允许我们更深入地了解WebSockets机制，从长远来看，这可能更有指导意义和实用价值。</p><p id="1066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的用例将涉及向特定用户发送通知。这意味着我们的应用程序的用户将被识别，比如说通过他们的用户名。大部分复杂性由此而来，因为向所有连接的客户端广播通知要容易得多。哦，别担心，我们也会广播的！</p><p id="6ee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将解决WebSocket在服务器端或客户端被关闭的问题，以及如何正确处理这些情况。</p><p id="bcdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于演示的目的，让我们假设我们的应用程序是一个游戏。JavaScript前端将在后端使用API，而后端将使用通知服务。让我们建立后者！</p><p id="dd97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，我们假设你知道WebSockets背后的基本理论，但是如果你不知道，你会在Medium上找到许多关于这个的文章。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb67" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置通知程序服务</h1><p id="941e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是我们的服务器端<code class="fe mz na nb nc b">connect</code>方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/918a45518a843392231e38e3e7ef0101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gj96wwzT695XTze5ua-vEg.png"/></div></div></figure><p id="59f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将使用ws库创建服务器，<code class="fe mz na nb nc b">noServer</code> <em class="ne"> </em>选项允许WebSocket服务器与HTTP(s)服务器分离(后者作为参数传递给我们的方法，所以不要混淆<code class="fe mz na nb nc b">server</code> <em class="ne">、</em>和<code class="fe mz na nb nc b">this.server</code>，前者是HTTP服务器，后者是我们的WebSocket服务器)。</p><p id="8aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用来自HTTP请求的升级头，通过发出一个连接事件路由到我们的WebSockets服务器，该事件将在一个<code class="fe mz na nb nc b">add</code>方法中处理。ws库为我们提供了一个<code class="fe mz na nb nc b">handleUpgrade</code> <em class="ne"> </em>助手来完成这项工作。您可以浏览ws文档以获得更多信息。</p><p id="77db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">我们希望WebSocket绑定到一个特定的用户</strong>。有许多方法可以做到这一点；这里我们选择使用用户名作为唯一标识符。该用户名只是客户端发出的WebSocket请求的一个查询参数(见下文)。注意，我们在这里使用Node.js <code class="fe mz na nb nc b">url</code>模块来解析请求。如果没有提供用户名，那么套接字就在这里被销毁。</p><p id="0cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">connect</code>方法还做了两件事:如果WebSocket服务器关闭，它会设置一个监听器，并设置一个时间间隔(这里是10秒)来检查(通过一个<code class="fe mz na nb nc b">checkAll</code> <em class="ne"> </em>方法)连接是否仍然存在(稍后将详细介绍)。我们的<code class="fe mz na nb nc b">close</code>方法会简单的清除这个区间。</p><p id="d5cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会在这里展示如何启动通知程序，但基本上，一旦应用程序启动时，您的应用程序HTTP服务器启动并运行，只需调用通知程序服务的<code class="fe mz na nb nc b">connect</code>方法，并将HTTP服务器实例作为参数，您就可以开始了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="01c3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通知和广播</h1><p id="b5fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们正在为我们的通知服务使用一个类。在我们的构造函数中，我们将如下设置连接池:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="97ad" class="nj md it nc b gy nk nl l nm nn">this.connections = new Map()</span></pre><p id="761d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript <code class="fe mz na nb nc b">Map</code>对象是在内存中存储键/值对的好方法。当然，如果需要的话，我们很快就会看到如何使用持久层(例如，如果您有一个集群化的Node.js应用程序，就会使用持久层)。</p><p id="1c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们的<code class="fe mz na nb nc b">add</code>方法就是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6927a589a21a19a85461bd9664bf61ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScclkK0FP-ieuT9rjlqF4g.png"/></div></div></figure><p id="ed7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将连接设置为“活动的”，并使用ws <code class="fe mz na nb nc b">pong</code> <em class="ne"> </em>事件，在每次成功的ping之后发出，以确认这一点(稍后将再次详细介绍)。</p><p id="bffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还监听web socket<em class="ne"/><code class="fe mz na nb nc b">close</code><em class="ne"/>事件，以防连接被关闭。我们的<code class="fe mz na nb nc b">remove</code>方法将从连接池中删除该连接，如下所示:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="2345" class="nj md it nc b gy nk nl l nm nn"><em class="ne">this</em>.connections.delete(id)</span></pre><p id="4d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们设置连接，键是<code class="fe mz na nb nc b">id</code>(这里是用户名)，值是WebSocket。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="84b3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">保持联系</h1><p id="9f62" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如上所述，每隔十秒钟，我们将检查与WebSocket服务器的连接是否仍然存在。下面是我们的<code class="fe mz na nb nc b">checkAll</code>方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/8d1b9a425e89111d17bc6e2fa8b4d9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8RetVDbSXf_OVNFiC0b9g.png"/></div></div></figure><p id="dcce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑非常简单:在ping之前，每个连接的<code class="fe mz na nb nc b">isAlive</code>属性都被设置为<code class="fe mz na nb nc b">false</code>(有关ping/pong机制的更多信息，请参见ws文档)。如果ping成功，<em class="ne"> </em> <code class="fe mz na nb nc b">isAlive</code>属性将被设置回<code class="fe mz na nb nc b">true</code>(参见我们的<code class="fe mz na nb nc b">add</code>方法和<code class="fe mz na nb nc b">pong</code>事件监听器)。如果连接一开始就不存在，那么它就会被终止。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="354a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">发送和广播</h1><p id="59ba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将使用两个非常简短的方法，它们旨在供您的应用程序在需要时从其他服务中调用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/f8afd7f68cd697e922f18cbc45a606fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8LH1pdbQxn0K4qFLQYOVGg.png"/></div></div></figure><p id="c437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我们在示例中选择的WebSocket <code class="fe mz na nb nc b">id</code>是用户名，但是它可以是您真正想要的任何东西，只要它对于连接的用户是唯一的。</p><p id="b8c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://gist.github.com/iperiago/8fba72dc5f3b8e2a7b2ddc3dfd9816a5#file-notifier1-js" rel="noopener ugc nofollow" target="_blank">要点</a>中找到完整的(基本的)通知器类代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b91" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">客户端设置</strong></h1><p id="297d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了与我们的通知服务器进行通信，一切都归结为通过设置客户端通知程序来使用WebSocket对象:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3240" class="nj md it nc b gy nk nl l nm nn">let notifier = new WebSocket(`${server}/?username=${username}`)</span></pre><p id="95e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe mz na nb nc b">server</code> <em class="ne"> </em>是您的服务器域(通常，如果您的HTTP服务器是https://myapp.com，那么您的WebSocket服务器将是wss://myapp.com)，而<code class="fe mz na nb nc b">username</code> <em class="ne"> </em>当然是当前认证用户的用户名。</p><p id="68c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您必须为客户端通知程序附加一个处理程序。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="d15b" class="nj md it nc b gy nk nl l nm nn">notifier.onmessage = message =&gt; {<br/>  const notification = JSON.parse(message)</span><span id="2637" class="nj md it nc b gy nr nl l nm nn">  // do stuff<br/>}</span></pre><p id="8d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过确保如果通告程序服务器以某种方式关闭，则客户端通告程序会继续尝试重新连接，直到服务器再次响应，从而对此进行优化。但我会让你来决定。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f1a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">考虑到聚类</strong></h1><p id="1c4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通常，您将利用Node.js处理多个内核的能力，并使用集群(例如，通过像<a class="ae ky" href="https://pm2.keymetrics.io" rel="noopener ugc nofollow" target="_blank"> pm2 </a>这样的工具)。在这种情况下，上述方法将不起作用，因为您的应用程序将有多个实例，每个实例都使用自己的通知程序和通知程序池。因此，如果一个实例处理给定用户的WebSocket连接，而另一个实例处理通知服务<code class="fe mz na nb nc b">send</code> <em class="ne"> </em>方法调用，那么后者不会找到正确的连接id，也不会发生任何事情。</p><p id="bad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，一个解决方案是使用Redis和<a class="ae ky" href="https://redis.io/topics/pubsub" rel="noopener ugc nofollow" target="_blank">发布/订阅</a>机制。这里我们不会展示如何设置Redis服务(但是如果您感兴趣，我们将在以后的文章中介绍)，但是总体方法依赖于Redis服务中的三个方法:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="e35e" class="nj md it nc b gy nk nl l nm nn">subscribe (channel, callback) { … }</span><span id="375a" class="nj md it nc b gy nr nl l nm nn">unsubscribe () { … }</span><span id="9fc8" class="nj md it nc b gy nr nl l nm nn">publish (channel, message) { … }</span></pre><p id="5907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在假设我们称这项服务为“redis”。如果你使用依赖注入(正如我推荐的)，你必须将这个服务注入到你的通知构造器中。然后它将作为<code class="fe mz na nb nc b">this.redis</code>可用。</p><p id="c328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当添加连接时，只需在我们的<code class="fe mz na nb nc b">Map</code>对象中设置连接后，向我们的<code class="fe mz na nb nc b">add</code>方法添加以下代码行:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="35cd" class="nj md it nc b gy nk nl l nm nn">this.redis.subscribe(‘websockets’, this.onMessage.bind(this))</span></pre><p id="d094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">websockets</code> <em class="ne"> </em>是我们这里的频道名称，但是可以是你想要的任何东西。新的<code class="fe mz na nb nc b">onMessage</code>方法将是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/c1b285e35ce8d15ce5b253b8698a972d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQ71e_sQm7xzT0oiVnE1kw.png"/></div></div></figure><p id="8eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们已经为我们的<code class="fe mz na nb nc b">send</code> <em class="ne"> </em>和<code class="fe mz na nb nc b">broadcast</code>方法引入了一个新的参数。事实上，下面是更新后的<code class="fe mz na nb nc b">send</code>和<code class="fe mz na nb nc b">broadcast</code>方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/308c2ff7e457285831f5ab329a767771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ri55568OqN6Diy__P_-80w.png"/></div></div></figure><p id="516a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在应该都说得通了吧？<code class="fe mz na nb nc b">publish</code>参数是一种停止任何发布循环的方法。我们发布一次，然后当我们的Redis服务发送消息时，没有必要再发布一次；否则，我们将陷入无限循环。</p><p id="2949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在我们的通知服务<code class="fe mz na nb nc b">close</code>方法中，我们应该添加下面一行代码，以便正确清理:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="a29a" class="nj md it nc b gy nk nl l nm nn">this.redis.unsubscribe()</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="23fb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理移动通知</h1><p id="4467" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">相同的通知服务可以用于发送移动(iOS或Android)通知。为此，您需要依靠适当的助手服务(或自己制作)。这里我们将使用<a class="ae ky" href="https://github.com/ToothlessGear/node-gcm" rel="noopener ugc nofollow" target="_blank"> node-gcm </a>发送Android通知，使用<a class="ae ky" href="https://github.com/parse-community/node-apn" rel="noopener ugc nofollow" target="_blank"> node-apn </a>发送iOS通知。</p><p id="bf7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该参考这两个库的文档，在您的通告程序构造函数中设置它们。不应该超过这个:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3c07" class="nj md it nc b gy nk nl l nm nn"><em class="ne">this</em>.apnProvider = new apn.Provider({ token: config.apn })</span><span id="7c24" class="nj md it nc b gy nr nl l nm nn"><em class="ne">this</em>.gcmProvider = new gcm.Sender(config.gcm.key)</span></pre><p id="efc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这里的<code class="fe mz na nb nc b">config</code>对象被注入到通知器的构造函数中，并被适当地格式化。</p><p id="38b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你做到了这一点，你的通知器<code class="fe mz na nb nc b">send</code>方法看起来就像这样，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/cf1c62cc2a8190b20e8dca64ac97dee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4N8RoBtGPrM0CIThL87-5Q.png"/></div></div></figure><p id="d567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新增了选项参数<code class="fe mz na nb nc b">androidDevices</code>和<code class="fe mz na nb nc b">appleDevices</code>，包含用户设备上的必要信息，它们仅用于发送消息。(如何获取它们并在您的用户实体中持久化它们是一个全新的任务，我们不在这里讨论。)</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="1c03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们的通知程序可以在许多方面得到很大的改进(例如，添加日志记录)，此外，我们有意忽略了Redis服务实现的细节，以及在将实际通知发送给设备id已知并持久化的用户之前的整个移动通知过程。但是这应该足以让您构建并创建自己的通知程序。</p><p id="76a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://gist.github.com/iperiago/8fba72dc5f3b8e2a7b2ddc3dfd9816a5#file-notifier2-js" rel="noopener ugc nofollow" target="_blank">要点</a>中找到改进的通知服务。编码快乐！</p></div></div>    
</body>
</html>