<html>
<head>
<title>Blazing Blade: Building a Simple API with Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">炽热的刀锋:用Rails构建简单的API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/blazing-blade-building-a-simple-api-with-rails-1acd3e947a16?source=collection_archive---------9-----------------------#2019-08-06">https://betterprogramming.pub/blazing-blade-building-a-simple-api-with-rails-1acd3e947a16?source=collection_archive---------9-----------------------#2019-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fb0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">使用Rails创建第一个API的程序指南</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/6c99b0c16c52b7670a6d3f2b2f6a70d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lxIpW4ds1a-Bst95"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae lf" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b05d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我首先要说的是，这是一篇非常全面的文章，正因为如此，这篇文章相当长。然而，我写这篇文章的意图是，任何有Rails经验的人都可以用它来构建一个简单的、纯粹的后端公共API。虽然它的信息量很大，但还是一步一步来。当你读完它的时候，你应该能像我一样做一些东西。</p><p id="13e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将解释我的整个过程:从头开始创建API，从最初的计划阶段(以及关于我的API包含的信息类型的简要背景)到实现序列化和CORS特性，最后到发布，因此它可能会被其他人使用。主要部分被分成“章节”，向<em class="ko">火徽</em>系列致敬，你会在继续这篇文章时了解更多。</p><p id="855d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇序言的最后，我想说的是，虽然这里有很多内容要介绍，但是如果我可以构建这样的东西，那么你也可以！毕竟，这就是这篇文章的全部目的。你需要多少时间就花多少时间——我希望这是一个易于阅读的指导性指南，所以请在评论中留下任何反馈或问题。这段代码也会推送到我的<a class="ae lf" href="https://github.com/TimeSmash/fire-emblem-7-chars-api" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><h1 id="19b0" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">序言:API、计划阶段和火徽</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi me"><img src="../Images/05537e20fe8f23067f18242b1787d11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*P0BUIETJb1rGJwLolGZepQ.gif"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">火徽首次进军美国。这个游戏中的人物是我们API的重点。</p></figure><p id="176d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近，我在Flatiron School上学期间，一直在学习和参与关于使用Rails作为API的讨论。在许多练习中，我们会利用一些API或粗略的指导方针来创建一个可以作为自定义API的后端。然而，我们从来没有涉及到制作一个每个人都可以访问和使用的API。因为我没有这方面的经验，所以我决定自己尝试这个过程。</p><p id="6277" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是一个狂热的视频游戏迷，实际上已经有几个视频游戏API，比如奇妙的PokeAPI和IDGB。无论是口袋妖怪还是特定的视频游戏，这两者都提供了关于某个主题的大量信息。这些信息是以JSON的形式出现的——当我们向API发出GET请求时，我们会收到一些以这种格式返回的信息。还有许多具有类似行为的APIs您主要将它们用于信息，然后就看您如何处理这些信息了。</p><p id="37b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他们说什么都有一个API——事实上，有多个API做类似的事情，尽管它们的执行可能非常不同。</p><p id="c18e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，你知道为什么没有API吗？2003年发布的一款视频游戏中可玩角色的基本信息，就是这些。</p><p id="6e97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">火之徽章:炽热之刃</em>(在西方以<em class="ko">火之徽章</em>发布)是火之徽章系列中第一个进入北美的游戏，这得益于通过非常受欢迎的Gamecube游戏<em class="ko"> Super Smash Bros .混战</em>引入该系列的角色。这个游戏让我接触到了策略RPG——我几乎觉得我欠它什么。那么，为什么不为游戏中的一些数据做一个API呢？</p><p id="1ebe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">火徽系列的每个游戏都涉及一个王国。它着重于这些国家的居民和王权，他们之间的关系，以及国家之间战争的原因和影响。这个系列的每一次迭代都是一个精心制作的故事，独特、有趣的角色都有自己的背景故事、动机和个性。更不用说其他的特征了，比如他们所属的战斗类别，或者他们的元素亲和力。每个角色都有如此多的含义——对于一个简单的API来说，它们是一个很好的焦点。</p><p id="8332" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我寻找任何与火徽有关的API时，我只找到了那些致力于令人难以置信的成功的手机游戏<em class="ko">火徽英雄</em>的API，其中有许多角色，包括一些来自炽热之刃的角色。然而，并不是所有来自那个游戏的可玩角色都包含在英雄中，而且大多数API很大程度上是基于角色的属性而不是角色本身。我选择了一条不同的路线，一条包括所有来自炽热之刃的可玩角色的路线，用更少的数字统计支持更多的个人统计。这种类型的数据已经够多了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mf"><img src="../Images/fc230261067f81b0190d1252730846e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8R8gmsio9O_il6Jo6QHW5g.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">看看这些角色！这么多信息要覆盖！</p></figure><p id="fb95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在看了各种参数后，我决定我的API将提供这个游戏中人物的姓名、性别、起始职业、国籍、游戏内描述和亲和力。该信息成为为该角色创建的对象中的键，而值成为与这些键相关的信息。</p><p id="8449" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我创建的第一个角色对象是以我个人最喜欢的Lyn为模型的。我决定先找到她所有的信息，作为我必须制作的其他43件物品的模板。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mg"><img src="../Images/50ab74e9da6a3c86cbf144a65496087f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HX_38Ac0lvI3ypKMDsUyXQ.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">所有字符将基于的原型(带有create语法)。注意:Lyn的全名其实是Lyndis。</p></figure><p id="4ea8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到这里所有的值都是字符串。因为这是我创建的第一个API，所以我不想过多地使用不同的数据类型。字符串很容易使用，也足够简单，通常不会引起问题——即使引起问题，也很容易解决。</p><p id="cb57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我建立了我想要展示的角色细节，知道我最终会得到一系列的对象。这样一个数组的命运是成为一个JSON，所以我知道我的最终目标是什么:创建一个API，向用户呈现关于所有字符或特定字符的JSON。</p><p id="801c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">后来，在基础工作完成之后，我考虑了我希望这个API具有的未来功能，比如一些基本的定制选项，比如返回所有女性字符或男性字符，或者让字符可以通过名称访问。在这篇文章中，我并没有明确地讲述如何做到这一点，但是在创建应用程序的过程中考虑挑战目标是明智的。通过在开始时建立其中的一些，您可以更好地了解您的产品的优化版本可以做什么，并且当您实际开始编码时，您可以决定什么是可行的。</p><p id="48c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了基本的游戏计划，我开始在Rails中设置一切。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="b277" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">第1章:设置Rails的基础知识</h1><p id="141a" class="pw-post-body-paragraph jq jr it js b jt mt jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn im bi translated"><strong class="js iu">重要提示:</strong> Rails使用SQLite作为默认的数据库语言。我发布这个API的平台Heroku不允许在上传到它的API中使用SQLite，内存原因在这里<a class="ae lf" href="https://devcenter.heroku.com/articles/sqlite3" rel="noopener ugc nofollow" target="_blank">进一步解释</a>。我不知道会发生这种情况，所以我不得不稍后将我的数据库改为Postgres，如第五章的可选部分所示。如果使用命令<code class="fe my mz na nb b">rails new project_name — api -d -postgresql</code>打开一个以Postgres作为默认数据库语言的Rails应用程序，这本来是可以避免的。</p><p id="da17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Rails实际上有一个有用的命令，当想要创建一个API时可以调用这个命令。该命令是:</p><p id="6d09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe my mz na nb b">rails new project_name --api</code></p><p id="6241" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很简单，对吧？通过使用<code class="fe my mz na nb b">--api</code>，我们从常规的Rails设置中去掉了很多脂肪。根据<a class="ae lf" href="https://guides.rubyonrails.org/api_app.html" rel="noopener ugc nofollow" target="_blank">文档</a>的说法，当我们以这种方式启动Rails时，它不会产生太多处理浏览器使用的中间件，这意味着大多数前端代码要么是基本的，要么不存在。这听起来很不利，但实际上对我们来说很好——这个API和其他许多API一样，并不特别关注前端的使用。这个命令使我们的代码更简洁，更容易导航。</p><p id="3c58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个命令在启动Rails时做的另一个重要改变是将<code class="fe my mz na nb b">ApplicationController</code>的继承从<code class="fe my mz na nb b">ActionController::Base</code>改为<code class="fe my mz na nb b">ActionController::API</code>。这意味着失去更多面向前端的方法，这实际上也是一件好事，因为我们无论如何都不会使用这些方法。</p><p id="e832" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我利用<code class="fe my mz na nb b">--api</code>创建了我的rails应用程序:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nc"><img src="../Images/28d7864bf07b6ed08d2c9461432bdab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xA96K_swCVjjCEk40NZG2g.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">使用— api命令可以减少Rails中的大量前端脂肪</p></figure><p id="70b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我确保将目录更改到这个新创建的文件夹，这样我就可以从终端快速访问它。永远记得把Rails放入为你制作的新文件夹，否则你在运行像<code class="fe my mz na nb b">rails c</code>或<code class="fe my mz na nb b">rails s</code>这样的命令时会遇到问题。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/98d723c0e7630647376add57e6a73050.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*wW4VGJOT0IVem9p5MRLnHg.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">我刚刚创建了这个目录，所以为了使用Rails，我必须进入这个目录。</p></figure><p id="9568" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我已经建立了项目的基本框架，并且在正确的目录中，我可以开始工作了。是时候开放VSCode并创建一些迁移和路由来使用了。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="c675" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">第2章:迁移和数据播种</h1><p id="573a" class="pw-post-body-paragraph jq jr it js b jt mt jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn im bi translated">我要做的第一件事是创建一个要使用的表，对于我想要包含的每条数据都有一列。记住这个API有名字、性别、起始职业、国籍、游戏中的描述以及每个可玩角色的亲和力，所有这些特征都是字符串。因为它们都是字符串，我甚至不需要指定它们的数据类型，因为Rails假定列值是字符串数据类型，除非另有说明。</p><p id="8065" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我为我的表编写的代码:</p><p id="252b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe my mz na nb b">rails g resource character name gender starting_class occupation nationality description affinity</code></p><p id="c189" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我查看了我的迁移，以确保一切正常:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f954a005f5cdeaecf63ba23bf56d7bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*1qEfRG_VgaaFIuSWgZ3EQQ.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">从原型迁移所有数据列。</p></figure><p id="d846" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后跑了<code class="fe my mz na nb b">rails db:migrate</code>推过去。</p><p id="6953" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一点上，我开始寻找我需要的所有球员的数据。我很快意识到,“职业”一栏并不适用于所有角色——它要么显得多余，要么缺乏对我来说足够“官方”的数据，所以我决定去掉它。为了实践的目的，我决定采取创建另一个迁移来修复我的错误的更费力的方法，而不是懒惰地回滚或完全删除迁移。下面的图表显示了我是如何创建这个迁移的，以及当用特定的语法编写时(在这里的文档<a class="ae lf" href="https://edgeguides.rubyonrails.org/active_record_migrations.html" rel="noopener ugc nofollow" target="_blank">中有更多的解释</a>)里面的代码是如何为我生成的，以删除这个列。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nf"><img src="../Images/e53dbf255c2e91b1328af718fcebb727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PN1m9m0s1sHcJXo-p2egqA.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">在更复杂的应用程序中，您可能需要以比回滚更具体的方式来修改表。</p></figure><p id="2b1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我再次跑<code class="fe my mz na nb b">rails db:migrate</code>继续我的寻找。几个小时后，我得到了我需要的东西。(如果我知道如何使用<a class="ae lf" href="https://www.scrapehero.com/a-beginners-guide-to-web-scraping-part-1-the-basics/" rel="noopener ugc nofollow" target="_blank">刮刀</a>，可能会更快！)我进入我的<code class="fe my mz na nb b">seeds.db</code>文件，创建了几个新角色，总共44个。</p><p id="ab50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，除了“职业”键之外，我之前为自己制作的原型与我必须编码的内容相匹配。我为正式创建这个JSON中的第一个对象而写的代码可以在下面看到:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ng"><img src="../Images/7ceed054c67118acf73dc815140b6891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmGHYK86aa8MEbH-urkaWw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">如何将每个字符构造成类字符的实例。</p></figure><p id="d337" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦这些都建立起来，我运行<code class="fe my mz na nb b">rails db:seed</code>将这些数据放入我的角色表中。使用<code class="fe my mz na nb b">rails c</code> (rails控制台)的快速检查显示我已经成功地转移了数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nh"><img src="../Images/ee0436bdf2bd96bad4b2680636b5e1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8vQq1ECK03_6V-VnsAVjLA.gif"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">在rails控制台中，我们运行Character.all来查看所有已创建对象的简短列表，然后运行Character.all.length来确保存在44个字符对象。</p></figure><p id="f595" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决了这个问题，下一步就是建立路由，这样客户端就可以实际访问这些数据。</p><h1 id="0f42" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">第3章:路由和序列化</h1><p id="9d52" class="pw-post-body-paragraph jq jr it js b jt mt jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn im bi translated">我打开我的<code class="fe my mz na nb b">characters_controller.rb</code>文件，为索引(将显示所有角色)和show(将基于他们的id显示某个特定角色的数据)编写了路径。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/da988467348d133caccc45f12f8e2fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*MVb0bLLsojDcrVVYMBjMvg.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">建立索引并显示路线</p></figure><p id="c325" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，在运行rails时，一个新的<code class="fe my mz na nb b">routes.rb</code>文件已经建立。在内部，它默认允许所有的<code class="fe my mz na nb b">resources</code>用于创建的模型。因为我有资源<code class="fe my mz na nb b">:characters</code>，这意味着所有的路线对我都是可用的。目前，当用户发出HTTP请求时，所有的数据都会被发送过来。我希望发出请求的客户端能够看到大部分内容，但我不认为他们真的有必要看到对象的时间属性<code class="fe my mz na nb b">created_at</code>或<code class="fe my mz na nb b">updated_at</code>。这就是序列化程序的用武之地。</p><p id="6962" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您只想发送部分数据时，可以使用序列化程序。因为默认情况下会发送所有数据，所以我们使用序列化来确保只发送我们<em class="ko">想要</em>发送的数据。虽然我不想发送的项目相对来说是无害的，但是您也可以理解为什么在大规模应用程序中这可能是一个大问题。例如，客户不应该一直发送他们的账号或出生日期等私人信息。</p><p id="c350" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了防止<code class="fe my mz na nb b">created_at</code>和<code class="fe my mz na nb b">updated_at</code>被发送过来，我将在应用程序中创建一个名为services的新文件夹。在其中，我将创建一个名为<code class="fe my mz na nb b">character_serializer.rb</code>的序列化程序。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/af5269bdd2d60617ec1d9735abd427a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*FCoOE0JKR0AE920YnsETaw.gif"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">创建一个服务文件夹来存储我们的序列化程序，然后创建所述序列化程序。</p></figure><p id="5dd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">序列化器的组成很简单——您正在创建一个具有自己的实例变量和方法的类，与Rails中的其他一些类不同，序列化器可以在不继承类的情况下创建。(这并不是说它们<em class="ko">不能</em>——像其他类一样，它们可以从更高级别的类继承，但是对于这个例子，我们保持简单)。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nk"><img src="../Images/d3c8faa249e4491d12aaaac15a309d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pTdKy42e-mLsBBOTJWqOSg.png"/></div></div></figure><p id="eebf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此图像分解了序列化程序是如何制作的。首先，我们创建一个实例变量<code class="fe my mz na nb b">@character</code>，它是一个包含角色所有键和值的对象。接下来，我们创建一个可以在对象上运行的实例方法。为了保持代码整洁，我创建了一个变量<code class="fe my mz na nb b">options</code>，它被设置为一个带有特定关键字的对象，这个关键字<code class="fe my mz na nb b">.to_json</code>方法可以理解。单词<code class="fe my mz na nb b">except</code>表示对象中的所有数据都应该被转换成JSON，只有两个属性除外，这两个属性在数组中由它们的键名列出。还有其他这样的关键字来告诉<code class="fe my mz na nb b">to_json</code>如何选择使用什么数据来创建JSON，比如<code class="fe my mz na nb b">include</code>或<code class="fe my mz na nb b">only</code>。同样，为了简单起见，我只使用了<code class="fe my mz na nb b">except</code>关键字，但是给出我们想要的输出也是有意义的。我在说“返回这个对象的所有属性，<em class="ko">除了</em>这些。”，所以那个关键词是最贴切的。</p><p id="b9f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当我们发出一个HTTP请求时，它们只有其他属性可以使用。但是就目前情况来看，我们实际上还没有在任何地方整合序列化程序——它只是一个位于服务中的文件，没有在任何地方被使用或引用。为了实现我们的CharacterSerializer的使用，我们需要将它放在呈现JSONs的地方。没有比我们的<code class="fe my mz na nb b">characters_controller</code>更好的地方了！</p><p id="bbac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以前，我们只有一些代码，当一个特定的HTTP请求被调用时，它会显示一个JSON。最初编写时，JSON中的所有内容都是默认呈现的。现在我们有了一个序列化器来呈现我们想要的东西，我们可以稍微美化一下这段代码。我们调用我们的序列化器和它包含的一个方法，根据实例方法中编写的代码呈现一个过滤的JSON。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nl"><img src="../Images/b6842a867cb42fe00e5e2c316b87e72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSigUwel2bzLXBCOQ7PZig.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">在我们的控制器方法中利用序列化器只发送我们想要的数据</p></figure><p id="f6a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码的工作方式是创建一个新的<code class="fe my mz na nb b">CharacterSerializer</code>实例，将一个字符对象作为它的参数。角色对象在初始化时被设置为<code class="fe my mz na nb b">@character</code>，然后通过<code class="fe my mz na nb b">to_serialized_json</code>方法转换为JSON，该方法又以options hash作为参数，最终生成一个没有<code class="fe my mz na nb b">created_at</code>和<code class="fe my mz na nb b">updated_at</code>的JSON。</p><p id="f715" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，是时候呈现我们刚刚制作的定制JSON了。要做到这一点就像调用<code class="fe my mz na nb b">render</code>一样简单！这是代码中没有改变的一部分，因为最终，我们仍然呈现一个JSON——我们只是必须首先序列化那个JSON。</p><p id="1293" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在已经创建了所有的对象，它们存储在数组<code class="fe my mz na nb b">Character.all</code>中。我们创建了访问所有对象或单个对象的路径，并序列化了每个方法中呈现的JSON。</p><p id="a628" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前，客户端可以对我拥有的字符集合执行所有HTTP请求，但是这些数据更像是一个库。就像图书馆一样，我应该能够借阅书籍，但我不应该能够添加任何我想要的书，或者编辑该书的内容，或者从图书馆中删除它。换句话说，我只希望客户端能够<em class="ko">读取</em>这些数据。我不希望人们未经我的允许添加、编辑或删除这些信息。事实上，就目前而言，我不需要除我之外的任何人来做这些事情。</p><p id="65da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何限制来自客户端的某些HTTP请求，以确保它们只能做我们希望它们做的事情？进入CORS！</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="f56c" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">第4章:使用CORS</h1><p id="6057" class="pw-post-body-paragraph jq jr it js b jt mt jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn im bi translated">CORS(跨源资源共享)是web应用程序允许请求的一种方式。例如，当查看维基百科的文章时，如果需要的话，任何网站都应该能够从中提取一些内容。但是对于某人的个人银行账户来说，情况就不一样了——毕竟，你不想让街上的雅虎看到你赚了多少钱！</p><p id="f509" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个API，我将允许所有用户向它发出GET请求。所有其他请求都将被拒绝。为此，我必须做几件事。</p><p id="679b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我进入gem文件并取消对gem 'rack-cors '的注释，然后运行bundle install。之后，我需要进入cors.rb文件，其文件路径是config/initializer/CORS . Rb。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/048ab5499cf2b79f0fe66fd600c9e002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*QebNG_eChCNVRlv0W0-rGw.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">使用CORS允许所有用户访问这个API，但是不允许除GET之外的任何HTTP请求</p></figure><p id="4561" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来源是指发出请求的网站。我想允许任何网站发出请求，所以我用*来表示。资源字也带一个*。当向主机服务器发出请求时，会读取标头。它们可能写得像“Content-Type: 'application/json '”，但是对于这个API，我会宽容一些，允许任何类型的头。这些方法是一个网站可以发出的HTTP请求的<em class="ko">种</em>,所以我将其限制为只获取请求。现在，如果另一个网站尝试GET之外的任何其他方法，CORS不会允许的！</p><p id="a32b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们终于完成了这个应用程序的基本功能！做了这么多工作，直到现在我都忘了做一个GitHub库。这是一个危险的遗漏，也是我们要解决的问题——在下一章，我们将学习如何在GitHub中创建新的回购协议和本地计算机上已建立的回购协议。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="a9e6" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">第5章:将一切推给GitHub</h1><p id="2c00" class="pw-post-body-paragraph jq jr it js b jt mt jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn im bi translated">没有尽快把我的代码发布到Github是多么愚蠢的事情！</p><p id="a8a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个优秀的程序员都应该从创建一个GitHub库<em class="ko">开始第一件事</em>——这使得你的工作比我们将要做的要容易得多。</p><p id="5656" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我应该提到的另一件事是，一旦你的代码达到了一个基准，最好的做法就是git commit换句话说，当你做了一个以前不能运行的东西，不管它有多小。这样，你就有了一个越来越有效的产品的许多版本。不要重蹈我的覆辙——想象一下，如果发生了意外，我的笔记本电脑停止了工作。我甚至无法证明我迄今为止所做的工作是存在的，更不用说恢复它了。</p><p id="d546" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">版本控制——保存产品成功版本的过程——不仅对API重要，对任何编码项目都是如此。做好，经常做！</p><p id="a88a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谢天谢地，到目前为止我已经避免吃任何乌鸦了。尽管我已经开始编码了，但我们现在要做一个GitHub repo，把它从菜单上完全去掉。<em class="ko">如果你很好地掌握了GitHub以及在这种情况下该怎么做，请随意跳到第6章。</em></p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="12e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GitHub为你开始写代码但没有想到要事先创建一个库的情况做了准备。事实上，当您在GitHub上创建一个新的存储库时，它会自动跳转到一个页面，该页面显示了我将要运行的命令。请将此作为快速指南，此处显示的流程只是其更清晰的版本。这不需要很长时间，所以你可以上传你的回购，然后马上回到编码。</p><ol class=""><li id="d03c" class="nn no it js b jt ju jx jy kb np kf nq kj nr kn ns nt nu nv bi translated">首先，我们需要创建一个新的存储库。转到您的个人资料，然后存储库，然后创建一个新的存储库。这将打开一个页面，询问您的回购名称、描述、私人/公共首选项，以及初始化自述文件的选项，该文件将作为您的回购的文档。我将把我的repo命名为fire-徽-7-chars-api，这是我很久以前运行rails new时使用的名字，然后我将对它做一个简短的描述。显然，我希望这是一个公共回购，所以我将把它标记出来，我不需要README，因为rails new为我创建了一个README。(我确实在这一点上稍微编辑了自述文件GitHub上的这一步是一个很好的提醒，至少要开始你的自述文件，这样你就不会忘记了。)</li></ol><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nw"><img src="../Images/02314d3307f67f4093c775a88a4dbfe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*800gYPV9v5TdOxIH9rpEYA.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">创建一个新的GitHub库来保存我们已经写好的代码。</p></figure><p id="b3f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.接下来，您将进入快速设置页面。我们将遵循“在命令行上创建一个新的存储库”的步骤，尽管有些不同。观察下面的图片，看看我们从本地目录链接文件的过程</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nx"><img src="../Images/142ec566ecb1e64ad4b5976dd2cb1cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90NdFD5sGXb-jlGUyDN0bw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">我们将要经历的步骤是将我的本地目录与远程repo链接起来。不需要自述文件，因为它已经由rails构建了。</p></figure><p id="3353" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.我们做的第一件事是打开终端，<code class="fe my mz na nb b">git init</code>创建一个本地存储库，它的内容将填充我们刚刚创建的GitHub repo。</p><p id="2641" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.然后，我们将运行<code class="fe my mz na nb b">git add .</code>来存放我们所有的更改。<br/> <br/>之后，我们将使用a -m进行git commit，它保存了我要为这个回购的第一次更新放置的消息。到目前为止，我想要的一切都在工作，所以我会发一个简短的消息来反映这一点。</p><p id="2aba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是时候把这个和我刚刚创建的回购联系起来了。一旦我这样做了，这个本地存储库和Github上的存储库之间的关系就建立了；这允许在我的计算机和GitHub之间进行推或拉请求。</p><pre class="kq kr ks kt gt ny nb nz oa aw ob bi"><span id="a1af" class="oc lh it nb b gy od oe l of og">git remote add origin https://github.com/TimeSmash/fire-emblem-7-chars-api.git</span></pre><p id="d036" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我想推进到我的主分支，因为到目前为止我只提交了我的更改。我<code class="fe my mz na nb b">git push -u origin master</code>，然后检查我在GitHub上的回购，以确保推送发生。当我重新加载我的页面，瞧！一切都在那里，因为它应该是。</p><p id="b6f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了它，我们就可以上路了！最后就是把这个API公开。为此，我们要去赫罗库，把这个东西从地面上弄下来！</p><p id="005f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…直到我了解到Heroku不允许在上传到它的API中使用SQLite。如果你早在第一章就读过<strong class="js iu">重要的</strong>备忘录，我应该做的是使用Postgres作为默认数据库来运行我的命令。现在，我必须将Rails默认的数据库语言SQLite改为Postgres，这将在下面的可选部分中描述。</p><p id="3265" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">可选:以下内容是关于将数据库从SQLite改为Postgres。如果你开始使用Postgres作为你的默认数据库，或者知道如何改变数据库语言，请随意跳到第6章。</em></p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="2354" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个简短的部分中，我们将讨论如何从SQLite转换到Postgres。直接从Heroku 获得的深入指导也很有帮助——在这篇文章中，我们将做一个非常快速的概述。</p><ol class=""><li id="8532" class="nn no it js b jt ju jx jy kb np kf nq kj nr kn ns nt nu nv bi translated">首先，我们进入gem文件，将所需的gem从<code class="fe my mz na nb b">sqlite3</code>更改为<code class="fe my mz na nb b">pg</code></li></ol><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oh"><img src="../Images/385d5708bc0d3c04643d7cdf77abe9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*I8UBGcLMyJ6F2xO-Z7mcZA.gif"/></div></div></figure><p id="84e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.然后，我们跑<code class="fe my mz na nb b">bundle install</code>。这只是安装了Postgres gem用于此应用程序。</p><p id="989e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.之后，我不得不使用Finder启动Postgres应用程序，但您可能不必这样做。(如果您在后续步骤中没有问题，此步骤可视为可选步骤)。</p><p id="b778" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.现在，我们进入<code class="fe my mz na nb b">database.yml</code>，将<code class="fe my mz na nb b">sqlite3</code>的任何实例更改为<code class="fe my mz na nb b">postgres</code>。我们还必须想出定制的数据库名称。在开发数据库中，我将名称改为<code class="fe my mz na nb b">characters</code>以保持一致。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4ad0c2a7f70e38959cda089c19715d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*ZMd7qCoD3Aqh4ONNFBhSBg.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">不要介意池和超时，那些是这样来的。</p></figure><p id="6d8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.然后，我所要做的就是<code class="fe my mz na nb b">rake db:create</code>、<code class="fe my mz na nb b">rake db:migrate</code>和<code class="fe my mz na nb b">rake db:seed</code>，它们运行我已经创建的迁移和种子数据，以创建一个表来引用。最后，我通过使用<code class="fe my mz na nb b">rails s</code>来见证我的HTTP请求在<code class="fe my mz na nb b">localhost3000</code>和<code class="fe my mz na nb b">rails c</code>上工作以检查我的数据库的状态，来测试是否一切正常。</p><p id="97ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！我们现在去赫罗库。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="e164" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">第6章:使用Heroku宣传一个API</h1><p id="19bc" class="pw-post-body-paragraph jq jr it js b jt mt jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn im bi translated">因为这里的主要焦点是宣传我们的API，所以我不打算进入Heroku的后勤或在其上创建一个帐户。只需知道Heroku是一个平台，开发者可以轻松地在线存储他们创建的应用程序。如果你对Heroku和随之而来的小事情感兴趣，这里有一篇Lauren Orsini的精彩文章。</p><p id="f45d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建我的帐户后，我选择通过GitHub选项部署API，这很容易，就像复制粘贴我的repo的链接一样。然后是部署选项。</p><p id="2c84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Heroku提供了<em class="ko">自动部署选项，</em>这意味着每当你对相关分支进行git推送时，该应用/API的新版本就会更新。这是可选的，可以禁用。如果选择自动部署，Heroku将要求分支机构从GitHub repo进行部署。在更复杂的应用程序中，由于各种原因，人们可能会选择不使用主分支作为要部署的分支，这就是Heroku的原因。然而，由于这个应用程序相对简单，而且我目前没有什么特别需要更新的，所以我决定启用自动部署，使用master作为讨论中的分支。</p><p id="cb2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">选择自动部署的规范后，系统会询问您从哪个分支手动部署，因此您可以实际上传您的应用程序。理想情况下，您应该从那里完成。我有一个关于这个设置的问题，所以我不得不使用终端来解决它。我将回顾一下我是如何通过一个过程化的格式通过终端命令上传我的API的，如下所示。</p><ol class=""><li id="eefe" class="nn no it js b jt ju jx jy kb np kf nq kj nr kn ns nt nu nv bi translated">创建一个新的应用程序，命名为“fire-embryo-7-char-details”(这是我的一个错误，也许用我在GitHub上的名字会更容易，但是唉)</li><li id="851d" class="nn no it js b jt oj jx ok kb ol kf om kj on kn ns nt nu nv bi translated">从终端运行命令<code class="fe my mz na nb b">heroku login</code>。这可确保您登录到Heroku的CLI，这对于后续命令的正常运行至关重要。</li><li id="2b40" class="nn no it js b jt oj jx ok kb ol kf om kj on kn ns nt nu nv bi translated">运行heroku <code class="fe my mz na nb b">git:remote fire-emblem-7-char-details</code>。这在我的本地计算机和我刚刚创建的名为fire-embryo-7-char-details的heroku存储库之间建立了一个关系。</li><li id="149c" class="nn no it js b jt oj jx ok kb ol kf om kj on kn ns nt nu nv bi translated">带着你选择的消息运行<code class="fe my mz na nb b">git add . </code>和<code class="fe my mz na nb b">git commit</code>，准备好要推送的一切。</li><li id="006d" class="nn no it js b jt oj jx ok kb ol kf om kj on kn ns nt nu nv bi translated">运行<code class="fe my mz na nb b">git push heroku master</code>将你的代码推送到新创建的heroku库。</li><li id="371d" class="nn no it js b jt oj jx ok kb ol kf om kj on kn ns nt nu nv bi translated">运行<code class="fe my mz na nb b">rake db:migrate</code>来执行您的迁移</li><li id="7bff" class="nn no it js b jt oj jx ok kb ol kf om kj on kn ns nt nu nv bi translated">运行<code class="fe my mz na nb b">rake db:seed</code>来填充你的数据库。</li></ol></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3f10" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">最后一章:光(在隧道的尽头)</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/307d6ace5623c13ab039d3ec2694247f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*PksyKtADCZLx5tDm9ZNInw.gif"/></div></figure><p id="387c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">恭喜你，你一路过关斩将！</p><p id="c413" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您已经完成了创建一个具有CORS功能和序列化的纯后端API的分步指南。把这篇文章作为参考，你应该也能做一个简单的API！</p><p id="4d1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以这篇文章为基础，你可以做很多事情——一切尽在掌握。像<em class="ko">炽焰之刃</em>里那么多角色一样，去开拓自己的道路，去探索，看看你能做什么！</p></div></div>    
</body>
</html>