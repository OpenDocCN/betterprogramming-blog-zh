<html>
<head>
<title>Understanding the Object-Oriented Programming Style in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中面向对象的编程风格</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-object-oriented-programming-style-in-javascript-f400257a490f?source=collection_archive---------15-----------------------#2021-03-23">https://betterprogramming.pub/understanding-the-object-oriented-programming-style-in-javascript-f400257a490f?source=collection_archive---------15-----------------------#2021-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解今天仍然适用的经典编程范例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7585d9759318a2adf4d79ddcafc275e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ipvtJ1zHKQw1Juec"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@joannakosinska?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔安娜·科辛斯卡</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="395b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是JavaScript编程风格系列文章的第四篇。我之前已经介绍过m<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/understanding-the-monolithic-style-in-javascript-f86f78b21536">on lithic</a>，c <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/whats-the-cookbook-style-in-javascript-be98658d5be1"> ookbook </a>和p <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/whats-a-pipeline-style-in-javascript-2084b66133f0"> ipeline </a>样式。本文介绍了当今最流行的编程范式——面向对象(OO)风格。在本文中，我将展示面向对象的一种常见的子风格——用对象编程。</p><p id="0eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和我以前的文章一样，我将统计乔纳森·斯威夫特的经典文章《一个适度的提议》中的用词频率。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ddab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是对象？</h1><p id="c3b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你在高中或大学学过编程课程，或者了解编程文献，那么你已经了解了面向对象编程(OOP)的概念。OOP引入了程序应该模拟真实世界形成方式的思想，这意味着程序是由与其他对象交互的对象组成的。</p><p id="8bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我使用objects方法编写的跟踪学生考试成绩的程序将有一个<code class="fe mz na nb nc b">student</code>对象、<code class="fe mz na nb nc b">test</code>对象、<code class="fe mz na nb nc b">course</code>对象，甚至可能有一个<code class="fe mz na nb nc b">grading-scale</code>对象，这取决于我如何编写程序。</p><p id="1b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个对象都包含自己的数据和处理数据的函数(有时称为<em class="nd">方法</em>)。如果我愿意，对象可以与其他对象对话。如果我想真正在OO范式中工作，我将创建从其他对象继承属性(数据和函数)的对象，这样我就不必不断地重新定义保持不变的属性。例如，如果我正在编写一个关于汽车的程序，我不需要为每种类型的汽车定义方向盘，除非特定类型汽车的方向盘看起来或行为不像大多数汽车方向盘。</p><p id="099e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些重要的概念组成了OO范式。<em class="nd">传承</em>就是其中一个重要的概念。另一个是通过封装隐藏数据，这是面向对象程序的一个重要特征。<em class="nd">隐藏数据</em>意味着不允许自由访问对象的数据(没有这个，对象的用户可以将任何有效的数据分配给对象的一个属性)。</p><p id="3755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子是具有年龄属性的<code class="fe mz na nb nc b">student</code>对象。年龄通常被定义为整数，大多数编程语言允许整数保存从-20亿到+20亿的数字。很明显，一个学生的年龄必须在0到120岁之间，所以我需要保护他的财产不被随意分配。</p><p id="1dab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以通过要求年龄只能通过检查以确保输入的年龄是有效年龄的函数来分配来保护学生的年龄。该功能成为对象界面的一部分，即用户与对象交互的方式。</p><p id="c83c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个与继承相关但又不同的重要概念是<em class="nd">组合。</em>当继承模型是-a关系时，组合模型具有-a关系。例如，如果我正在构建一个<code class="fe mz na nb nc b">student</code>对象，那么一个学生就有一个名字。一个学生有专业。学生有一份已完成课程的清单。Has-a关系与is-a关系一样重要(如果不是更重要的话),但是在讨论OO编程的惊人特性时经常被忽略。</p><p id="4dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将要演示的词频程序专门关注has-a关系。我要实现的主要对象是词频控制器对象(WFC)。WFC将有一个单词管理器(WM)、一个停用单词管理器(SWM)和一个词频管理器(WFM)作为其组成部分。这些部分没有可以沿着继承链继承的特征，因为每个经理都完全独立于其他经理。</p><p id="c5de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这个特殊的问题(词频)不适用于继承解决方案之外，软件工程师Joshua Bloch在他的书《有效的Java》中概述了继承的几个问题在本书中，Bloch认为，因为继承会导致封装失败，所以对于大多数应用程序来说，使用组合通常比继承更好。我强烈建议你拿起这本书，即使你不打算做任何Java开发。他的见解在很大程度上适用于大多数编程语言。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eaf2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">面向对象编程的真正简史</h1><p id="93d3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第一个面向对象的编程语言是<a class="ae ky" href="https://en.wikipedia.org/wiki/Simula" rel="noopener ugc nofollow" target="_blank"> Simula </a>，由奥利·约翰·达尔和克利斯登·奈加特于20世纪60年代在挪威计算中心首次开发。Simula是作为ALGOL 60语言(最有影响力，但未得到充分利用的编程语言之一)的超集开发的，它引入了类、继承、虚拟过程和协程的概念。</p><p id="179c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数(如果不是全部的话)现代OO编程语言，包括C++、Java和C#，都受到了Simula的极大影响，这些语言的许多主要开发者也是如此，如比雅尼·斯特劳斯特鲁普(C++)和詹姆斯·高斯林(Java)。</p><p id="8574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继Simula之后，下一个认真采用OOP的语言是<a class="ae ky" href="https://en.wikipedia.org/wiki/Smalltalk" rel="noopener ugc nofollow" target="_blank"> Smalltalk </a>。Smalltalk是在20世纪70年代中后期由计算机科学家Alan Kay作为主要语言设计者在Palo Alto研究中心开发的。</p><p id="22f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Smalltalk最初是作为一种教育应用程序语言开发的，Kay从教育语言徽标中获得了很多灵感。尽管如此，Smalltalk仍然在许多科学和商业应用程序中找到了自己的路，许多未来的OOP语言使用了Smalltalk中首次开发的特性。</p><p id="ff5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Smalltalk之后，开发了诸如C++、Java和C#之类的语言，将OOP的特性与更传统的命令式特性相结合。当然，Java在它的OOP理念上走得最远，语言的每个方面都是面向对象的，以至于甚至写一个“Hello，world！”程序需要创建一个对象来显示消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9f36" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一个面向对象的词频统计程序</h1><p id="2b89" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这就把我们带到了当前的任务——设计一个展示传统的面向对象特性的词频计数程序。第一项任务是将问题分解成对象。这个问题由三个主要对象组成:1)我们从中提取单词的文本；2)我们想要从文本中移除的停用词；以及3)词频本身。</p><p id="f9d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结构提出了三个类:一个存储文本的<code class="fe mz na nb nc b">WordsManager</code>类，一个存储停用词的<code class="fe mz na nb nc b">StopWordsManager</code>类，以及一个对词进行计数并存储最终的词频排序列表的<code class="fe mz na nb nc b">WordFreqManager</code>类。</p><p id="3ef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要在这个列表中添加第四个控制程序的类。这个类叫做<code class="fe mz na nb nc b">WordFreqController</code>，熟悉<a class="ae ky" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank">模型-视图-控制器设计模式</a> (MVC)的人会明白我为什么使用控制器类。我的程序的结构更像是模型-控制器结构，但是MVC模式可以作为理解程序结构的基础。</p><p id="52b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，下面是我的词频统计程序，以面向对象的方式编写:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="aa0d" class="ni md it nc b gy nj nk l nl nm">class WordsManager {<br/>  constructor(text) {<br/>    this.wordset = read(text);<br/>  }</span><span id="9a49" class="ni md it nc b gy nn nk l nl nm">  parse_words() {<br/>    let wordList = [];<br/>    let index = 0;<br/>    let word = "";<br/>    while (index &lt; this.wordset.length) {<br/>      let c = this.wordset[index];<br/>      c = c.toLowerCase();<br/>      if (c &gt;= "a" &amp;&amp; c &lt;= "z") {<br/>        word += c;<br/>        index++;<br/>        continue;<br/>      }<br/>      index++;<br/>      if (word != "") {<br/>        wordList.push(word);<br/>      }<br/>      word = "";<br/>    }<br/>    this.wordset = wordList;<br/>  }</span><span id="a0b5" class="ni md it nc b gy nn nk l nl nm">  get words() {<br/>    this.parse_words();<br/>    return this.wordset;<br/>  }<br/>}</span><span id="1db2" class="ni md it nc b gy nn nk l nl nm">class StopWordsManager {<br/>  constructor(file) {<br/>    this.stopWords = read(file);<br/>    this.stopWords = this.stopWords.replace(/(\r\n|\n|\r)/gm, "");<br/>    this.stopWords = this.stopWords.split(",");<br/>  }<br/>  <br/>  get text() {<br/>    return this.stopWords;<br/>  }</span><span id="fb95" class="ni md it nc b gy nn nk l nl nm">  isStopWord(word) {<br/>    if (this.stopWords.find(aWord =&gt; aWord == word)) {<br/>      return true;<br/>    }<br/>    return false;<br/>  }<br/>}</span><span id="45bd" class="ni md it nc b gy nn nk l nl nm">class WordFreqManager {<br/>  constructor() {<br/>    this.word_freqs = new Map();<br/>  }</span><span id="9a8a" class="ni md it nc b gy nn nk l nl nm">  increment(word) {<br/>    if (this.word_freqs.has(word)) {<br/>      this.word_freqs.set(word, this.word_freqs.get(word)+1);<br/>    }<br/>    else {<br/>      this.word_freqs.set(word, 1);<br/>    }<br/>  }</span><span id="8643" class="ni md it nc b gy nn nk l nl nm">  sort() {<br/>    let wordFreqList = Array.from(this.word_freqs);<br/>    for (let i = 0; i &lt; wordFreqList.length-1; i++) {<br/>      for (let j = 0; j &lt; wordFreqList.length-i-1; j++) {<br/>        if (wordFreqList[j][1] &lt; wordFreqList[j+1][1]) {<br/>          let temp = wordFreqList[j];<br/>          wordFreqList[j] = wordFreqList[j+1];<br/>          wordFreqList[j+1] = temp;<br/>        }<br/>       }<br/>    }<br/>    return wordFreqList;<br/>  }<br/>}</span><span id="1b55" class="ni md it nc b gy nn nk l nl nm">class WordFreqController {<br/>  constructor(file) {<br/>    this.words_manager = new WordsManager(file);<br/>    this.stopwords_manager = new StopWordsManager("stopwords.txt");<br/>    this.wordFreq_manager = new WordFreqManager();<br/>    this.word_count = [];<br/>  }<br/>   <br/>  run() {<br/>    for (let word of this.words_manager.words) {<br/>      if (!this.stopwords_manager.text.includes(word)) {<br/>        this.wordFreq_manager.increment(word);<br/>      }<br/>    }<br/>    this.word_count = this.wordFreq_manager.sort();<br/>    const num_words = 15;<br/>    for (let i = 0; i &lt; num_words; i++) {<br/>      print(this.word_count[i]);<br/>    }<br/>  }<br/>}</span><span id="08d7" class="ni md it nc b gy nn nk l nl nm">// main program<br/>let wfc = new WordFreqController("text.txt");<br/>wfc.run();</span></pre><p id="3cc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是这个程序的输出:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="45f8" class="ni md it nc b gy nj nk l nl nm">children,18<br/>kingdom,15<br/>thousand,15<br/>country,11<br/>own,10<br/>child,10<br/>hundred,8<br/>parents,7<br/>little,7<br/>shillings,7<br/>nor,7<br/>publick,6<br/>food,6<br/>pounds,6<br/>time,5</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e5ef" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">还有其他面向对象的风格</h1><p id="46d6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我在这里展示的程序仅仅展示了一种OOP风格。这种风格是大多数学生在学校学到的，所以它通常被认为是编写面向对象程序的唯一方法。但实际上，面向对象的风格要多得多。在我的下一篇文章中，我将展示另一种面向对象的风格，Christina Lopes称之为<em class="nd">信箱</em>风格。</p><p id="4cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>