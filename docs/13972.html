<html>
<head>
<title>Frontend Backend Communication in Tauri: Implementing Progress Bars and Interrupt Button</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tauri中的前端后端通信:实现进度条和中断按钮</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/front-end-back-end-communication-in-tauri-implementing-progress-bars-and-interrupt-buttons-2a4efd967059?source=collection_archive---------2-----------------------#2022-10-21">https://betterprogramming.pub/front-end-back-end-communication-in-tauri-implementing-progress-bars-and-interrupt-buttons-2a4efd967059?source=collection_archive---------2-----------------------#2022-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f4d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简化异步通信</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87f514ae55ec55594fa27ad7a861abf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPeQCA8IoOL-mw0DBXWY_Q.png"/></div></div></figure><div class="ku kv gp gr kw kx"><a href="https://medium.com/@applied-math-coding/membership" rel="noopener follow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd iu gy z fp lc fr fs ld fu fw is bi translated">通过我的推荐链接加入Medium-applied . math . coding</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">获得我所有的故事，以及其他作家在媒体上发表的数千篇故事。我坚信，媒介是…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ks kx"/></div></div></a></div><p id="bb45" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这个小故事中，我想简单介绍一下Tauri是如何支持前端和后端之间的异步通信的。当后端通知UI有关变化(如长时间运行的任务的进度消息或UI受其影响的状态变化)时，通常需要这些特性。我们会看到，通常对Tauri来说，我们的目标并不难实现。Tauri基于其<code class="fe mi mj mk ml b"><a class="ae mm" href="https://tauri.app/v1/api/js/window" rel="noopener ugc nofollow" target="_blank">Window</a></code> <a class="ae mm" href="https://tauri.app/v1/api/js/window" rel="noopener ugc nofollow" target="_blank"> -API </a>提供了非常易于使用的异步消息传递工具。</p><p id="6244" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><em class="mn">对于不熟悉Tauri或者Rust又想快速总结一下的，建议看这里的</em><a class="ae mm" href="https://medium.com/@applied-math-coding/list/an-introduction-into-rust-22c99777c5e5" rel="noopener"><em class="mn"/></a><em class="mn"/><a class="ae mm" rel="noopener ugc nofollow" target="_blank" href="/building-a-desktop-app-with-tauri-8e281b8c4f64"><em class="mn">这里的</em> </a> <em class="mn">。</em></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="dc53" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">从后端发送</h1><p id="864b" class="pw-post-body-paragraph lm ln it lo b lp nn ju lr ls no jx lu lv np lx ly lz nq mb mc md nr mf mg mh im bi translated">假设在前端，我们有一些组件通过调用Tauri命令来触发运行一个长时间运行的任务。任务可以定期发送其进度状态的更新，并作为一个<code class="fe mi mj mk ml b"><a class="ae mm" href="https://tauri.app/v1/api/js/event" rel="noopener ugc nofollow" target="_blank">Event</a></code>发送给客户机。作为回报，客户端可以显示进度条或任何指示器。为此，客户端必须注册一个事件侦听器，如下所示:</p><pre class="kj kk kl km gt ns ml nt nu aw nv bi"><span id="40a0" class="nw mw it ml b gy nx ny l nz oa">import { <strong class="ml iu">appWindow </strong>} from '@tauri-apps/api/window';</span><span id="9c51" class="nw mw it ml b gy ob ny l nz oa">const <strong class="ml iu">unlistenProgress </strong>= await <strong class="ml iu">appWindow</strong>.listen(<br/>  '<strong class="ml iu">PROGRESS</strong>',<br/>  ({event, payload}) =&gt; console.log(payload)<br/>);</span></pre><p id="b005" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们导入代表Tauri对当前窗口的抽象的实例<code class="fe mi mj mk ml b">appWindow</code>。在这种情况下，我们可以在一个命名事件上注册一个监听器(这里是<code class="fe mi mj mk ml b">'PROGRESS'</code>)。</p><p id="f817" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">每当具有此名称的事件到达时，监听器本身就会被调用，并在特定的有效负载中被传递。后者的内容是自定义的，我们可以在后端指定它。这个方法，也就是<code class="fe mi mj mk ml b">listen</code>，返回一个<code class="fe mi mj mk ml b">Promise</code>，用一个重要的函数<code class="fe mi mj mk ml b">unlistenProgress</code>解析。对此的调用，如<code class="fe mi mj mk ml b">unlistenProgress()</code>，将监听器从事件中断开。例如，当我们的组件在导航过程中被破坏时，这尤其有用。</p><p id="e6db" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了让后端在这个<code class="fe mi mj mk ml b">appWindow</code>实例上发出事件，我们需要在命令调用中将它作为参数传递:</p><pre class="kj kk kl km gt ns ml nt nu aw nv bi"><span id="ebc0" class="nw mw it ml b gy nx ny l nz oa">const result = await invoke('<strong class="ml iu">do_some_long_task</strong>', {    <br/>    window: <strong class="ml iu">appWindow</strong><br/>});</span></pre><p id="95bd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">注意，即使不考虑这个参数，Tauri也将它作为一个参数在带有签名<code class="fe mi mj mk ml b">(..., window: Window)</code>的<code class="fe mi mj mk ml b">#[tauri::command]</code>注释函数中传递。</p><p id="8271" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在后端，为了触发我们的<code class="fe mi mj mk ml b">'PROGRESS'</code>事件，我们必须做以下事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3632" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们定义了一个客户<code class="fe mi mj mk ml b">Payload</code>，它需要是可克隆和可序列化的。然后我们只需在传递的带有有效负载的<code class="fe mi mj mk ml b">window</code>实例上调用<code class="fe mi mj mk ml b">emit</code>方法。就这些了。这确保了将我们的事件发送到特定的窗口。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="ad72" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">从前端发送</h1><p id="f95f" class="pw-post-body-paragraph lm ln it lo b lp nn ju lr ls no jx lu lv np lx ly lz nq mb mc md nr mf mg mh im bi translated">向服务器发送消息的一个常见场景是通知长时间运行的任务停止。为此，在后端我们注册了一个合适的处理程序来监听客户端发送的<code class="fe mi mj mk ml b">STOP</code>-事件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="575c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">简单的想法是有一些可变标志<code class="fe mi mj mk ml b">stop</code>，当信号到达时，它从<code class="fe mi mj mk ml b">false</code>变为<code class="fe mi mj mk ml b">true</code>。信号本身被注册为由<code class="fe mi mj mk ml b">window.once("STOP", ...)</code>监听。</p><p id="8430" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">返回的<code class="fe mi mj mk ml b">handler</code>在这个方法的最后用<code class="fe mi mj mk ml b">window.unlisten(...)</code>取消注册。正如你所看到的，我们必须注意这样一个事实，即注册的处理程序将在一个单独的线程中运行。</p><p id="7a7c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">出于这个原因，我们必须传递一个同步的ref-counter ( <code class="fe mi mj mk ml b">Arc</code>)，它包装了一个<code class="fe mi mj mk ml b">RwLock</code>来读写共享值。</p><p id="08e4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">对于这种情况，前端代码看起来非常简单:</p><pre class="kj kk kl km gt ns ml nt nu aw nv bi"><span id="30cf" class="nw mw it ml b gy nx ny l nz oa">import { appWindow } from '<a class="ae mm" href="http://twitter.com/tauri" rel="noopener ugc nofollow" target="_blank">@tauri</a>-apps/api/window';</span><span id="a7b6" class="nw mw it ml b gy ob ny l nz oa">async function doStop() {<br/> await appWindow.<strong class="ml iu">emit</strong>('STOP');<br/> console.log('all stopped');<br/>}</span></pre><p id="15ca" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这只是向当前窗口发出一个名为<code class="fe mi mj mk ml b">'STOP'</code>的事件。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="f975" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">上面的机制我已经用于一个关于计算牛顿分形的小应用，你可能从我的故事<a class="ae mm" href="https://applied-math-coding.medium.com/producing-newton-fractals-in-rust-and-zoom-into-them-3e12785f5f3d" rel="noopener">这里</a>知道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe od l"/></div></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="642d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">感谢阅读！</p></div></div>    
</body>
</html>