<html>
<head>
<title>Convenient Tactics of Logging in NodeJS and JavaScript in the Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览器登录NodeJS和JavaScript的便捷策略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/convenient-tactics-of-logging-in-nodejs-and-javascript-in-the-browser-9f97e9d550e4?source=collection_archive---------16-----------------------#2022-02-08">https://betterprogramming.pub/convenient-tactics-of-logging-in-nodejs-and-javascript-in-the-browser-9f97e9d550e4?source=collection_archive---------16-----------------------#2022-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1284" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">记录成功</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/157108a05da253ee92f3d5e113ad687b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJgYmlhSHF3aGbyQ12pndA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><p id="8432" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">作为开发人员，如果没有某种日志记录机制，在我们的应用程序中调试bug是极其困难的。</p><p id="c3c9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是因为日志可以捕获我们代码中的任何时间点，并捕获堆栈跟踪或关于我们应用程序生命周期当前状态的有用信息，这些信息可用于及时追溯状态。</p><p id="1c20" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这篇文章中，我们将介绍几种用JavaScript登录nodejs和浏览器环境的便捷策略。</p><h1 id="3ff6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">跟踪/调试</h1><p id="c1fe" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">随着时间的推移，我们的项目越来越大，建立日志来跟踪我们的代码变得越来越重要，因为我们的代码变得越来越复杂。代码复杂性的增加导致代码维护和可读性的难度增加。</p><p id="1af9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当意外行为发生时，没有比日志记录更好的跟踪变化的方法了。</p><p id="485c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9cc9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们期望的行为是，对于每个获取的猫图像，我们创建一个包含单个<code class="fe mv mw mx my b">img</code>元素的新元素，该元素最终将被分组到一个“类似画廊”的视图中。在客户端显示时，每张图像在视觉上应该以相同的尺寸显示，并且每张图像应该不同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/6e33d6b895f979c202c65d0c11bd03c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*1U2Ppa7badgzZbZn.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><p id="7718" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，前两个图像是重复的。通过在我们的代码中放置简单的记录器，它提供了一个定位错误开始的捷径:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/a8a4513522d84280244c22a4659e8c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7ypphOwNuZDJuGv4.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ca65" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">前两个对象是相同的，因此我们可以立即了解我们的for循环是如何开始的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/4651b92008545e08b175d796bd43b917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h_abaOF7scLDf46R.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><p id="69bf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个问题现在变得很明显。每个循环都希望从数组中的一个对象<code class="fe mv mw mx my b">pulled</code>开始。每个循环都认为数组已经发生了变异，因此我们需要对数组进行变异:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/5d34136a1b7108e5631e77299f8577bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-cUUPMyQwPWpOKRj.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/c281fd6d11ad77564148aef5b5f6abd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*BqQo_AFD7gd2s9On.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><h1 id="9629" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">表演</h1><p id="9dd1" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">在现代应用程序中，如果我们希望我们的应用程序保持竞争力，性能是首要考虑的问题。作为开发人员，让用户满意是我们的责任，一切从代码开始。通过利用<code class="fe mv mw mx my b">console</code>,我们可以记录代码不同部分的性能。</p><h1 id="2fd9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">分析</h1><p id="12e9" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">日志比我们想象的要有用得多。甚至在我们的代码中放置随机日志也能给我们提供信息来改进我们的应用程序。</p><p id="2aae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以使用我们的日志记录信息来找出以下内容:</p><ul class=""><li id="4ce5" class="nd ne it lc b ld le lg lh lj nf ln ng lr nh lv ni nj nk nl bi translated">重复请求</li><li id="954a" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">内存泄漏</li><li id="181a" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">不必要的变量</li><li id="29a1" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">打字稿</li><li id="fc21" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">提醒我们重访托多斯</li><li id="eac5" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">跟踪函数调用</li><li id="ac6d" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">意外行为</li></ul><p id="9559" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这样的例子不胜枚举。</p><h1 id="c8ea" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">重要的记录方法</h1><p id="0010" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">如果断言失败或者是<code class="fe mv mw mx my b">false</code>，那么<code class="fe mv mw mx my b">console.assert</code>对于将错误消息写入控制台(通常用于验证我们函数中的输入或输出)是有用的。否则什么都不会发生。与通用的<code class="fe mv mw mx my b">console.log</code>相比，这提供了一种“惰性加载”的感觉，从而更容易避免更多的内存使用。</p><p id="cb47" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mv mw mx my b">console.clear</code>可以用来清除控制台。当您意识到有太多的日志，并希望将它放在正在调试的函数之前，以确保您在控制台中看到的第一条消息直接来自该函数时，这非常有用。这有助于避免不必要地上下滚动来大海捞针。</p><p id="a750" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mv mw mx my b">console.error</code>也可以帮助将消息记录到控制台，但在浏览器控制台中，它实际上显示的消息看起来像错误，因为它们是红色背景。在大多数情况下，这就足够了。但是在某些情况下，我们仍然会选择一种更好的方式来显示错误信息，比如<code class="fe mv mw mx my b">console.log('%c"obj" is not an object', 'color:red;font-weight:400', obj)</code>。</p><p id="b033" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mv mw mx my b">console.debug</code>以“详细”级别向控制台输出消息。库利用这种方法来记录更多的技术信息，以便开发人员能够更深入地了解他们正在使用的库中的技术细节。</p><p id="7174" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mv mw mx my b">console.dir</code>除了能够向控制台显示<em class="nr">对象的所有</em>属性外，还可用于向控制台显示任何内容(可通过<code class="fe mv mw mx my b">depth</code>选项进行配置)。如果在浏览器中使用，我们在<code class="fe mv mw mx my b">console.dir</code>中使用的对象可以是<em class="nr">交互式的</em>，我们可以点击属性/方法，同时能够展开/折叠它们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/da12ea50669a6708d32831fe09a92f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g7Bm_FqeXEmsUO79.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><p id="07dc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mv mw mx my b">console.group</code>和<code class="fe mv mw mx my b">console.groupEnd</code>可用于将多个日志包装在一个包装的“容器”中，其中每行可缩进，模拟控制台中的“分组”效果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/0d2d34a31063ca0a0b5443f014ceab84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o_K7nS7L7yfnYIcj.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><p id="ce96" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我发现<code class="fe mv mw mx my b">console.group</code>的有趣之处在于，如果需要，我们可以多次使用它来嵌套/缩进底层消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/29fb205c9045e9638f5ba8afb3b55a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4fRKwl6mvGUDxK47.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><h1 id="f0da" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">策略</h1><p id="3992" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">有时，我们会过于激动，记录太多的信息。这会影响运行时性能，尤其是当我们在日志中包含大对象的时候。</p><p id="1b78" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">日志在NodeJS中非常有用。但是有些时候它们是没有用的。然而，我们也有机会将这些对<em class="nr">无用的日志变成有用的</em>。</p><p id="18b5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们看看下面这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="59b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当我们创建<code class="fe mv mw mx my b">Profile</code>的实例并将每个实例记录到控制台时，我们希望在输出中看到有用的信息，如<code class="fe mv mw mx my b">firstName</code>、<code class="fe mv mw mx my b">lastName</code>、<code class="fe mv mw mx my b">fullName</code>和所有的<code class="fe mv mw mx my b">familyMembers</code>。</p><p id="4db8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但实际情况是，当他们在控制台中显示时，这是我们得到的信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/63f3df235fb0a3a42e62dbe2cb0d343b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dqbH0TZeT53qHB8P.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><p id="857e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">那么如何才能让这个输出有用的信息呢？谢天谢地，NodeJS为我们定制对象的输出提供了一个有用的方法。</p><h1 id="7f2a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><code class="fe mv mw mx my b">Inspect</code>(建议:创建全局用户片段)</h1><p id="c58e" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">为了定制控制台中对象的输出，我们可以附加一个值为<code class="fe mv mw mx my b">"nodejs.util.inspect.custom"</code>的<code class="fe mv mw mx my b">Symbol</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b1a6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">将我们的<code class="fe mv mw mx my b">Profile</code>实例记录到控制台可以按照我们想要的方式显示信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8a4e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我建议将它绑定到一个定制的用户片段，因为如果你像我一样，你每次都会使用它来获得更有效率的开发体验。</p><p id="0961" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">值得一提的是<code class="fe mv mw mx my b">[Symbol.for('nodejs.util.inspect.custom')]() {}</code>还带有3个参数:</p><p id="a248" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mv mw mx my b">[Symbol.for('nodejs.util.inspect.custom')](depth, inspectOptions, inspect) {}</code></p><p id="826f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可以在这里找到更多关于这些论点的信息。</p><h1 id="8b45" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">自动化</h1><p id="b368" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">我们之前的例子很好，因为我们可以在开发应用程序的同时实时分析日志记录。</p><p id="a7e6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，有时我们希望在自动化脚本中看到日志(比如让脚本每15分钟获取一次数据)，而我们<em class="nr">不再在运行时分析这些日志。</em></p><p id="637f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">默认情况下，NodeJS中的<code class="fe mv mw mx my b">Console</code>构造函数通过将其输出传送到<code class="fe mv mw mx my b">stdout</code>和<code class="fe mv mw mx my b">stderr</code>来登录到终端。实际上，我们可以配置这两个函数，将其输出传输到其他地方，比如一个文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/221615f771c12f77eaf2ebc143a94c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/0*IvX5geH-kh1-7_L_.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><p id="1ae7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/166779831b0436a53d97ce2e70899ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ppFpdlaZu8F_bEqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ky kz ep" href="https://medium.com/u/9204b4ca7056?source=post_page-----9f97e9d550e4--------------------------------" rel="noopener" target="_blank"> jsmanifest </a></p></figure><h1 id="7776" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">实践中的伐木工人</h1><p id="2d29" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated"><a class="ae nw" href="https://github.com/pinojs/pino-http" rel="noopener ugc nofollow" target="_blank">Pino-http</a>【Pino】提供了一个库来接入<a class="ae nw" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> expressjs </a>请求管道，作为一个中间件来记录我们从http请求中想要的任何东西。</p><p id="76fa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><a class="ae nw" href="https://www.npmjs.com/package/file-stream-rotator" rel="noopener ugc nofollow" target="_blank"> file-stream-rotator </a>可以与服务器应用程序中的日志中间件结合使用，将它们的日志保存在一个文件中。它旨在定期提供Express日志的自动轮换，需要根据日期、大小限制或组合进行轮换，并根据计数或已用天数删除旧日志文件。</p><p id="613a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><a class="ae nw" href="https://github.com/sindresorhus/log-update" rel="noopener ugc nofollow" target="_blank">日志更新</a>允许开发者利用节点的<code class="fe mv mw mx my b">stdout</code>和<code class="fe mv mw mx my b">stderr</code>(相同的I/O <code class="fe mv mw mx my b">Console</code>用途)在终端中模拟进度条或定制动画</p><p id="d875" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">roarr将信息记录为JSON，它支持nodejs和浏览器环境</p><p id="65fd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了支持markdown语法之外，logdown.js还为节点和浏览器环境提供了一种日志记录机制。</p><h1 id="940d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="5dcd" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">本帖到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>