<html>
<head>
<title>RxJava: Multi-Threading in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">rx Java:Android中的多线程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjava-multi-threading-in-android-302a7419edbf?source=collection_archive---------2-----------------------#2020-02-09">https://betterprogramming.pub/rxjava-multi-threading-in-android-302a7419edbf?source=collection_archive---------2-----------------------#2020-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a44c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何掌握RxJava的详细指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bfde9a7dba0b61a97afddd7e8a538dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GjqUALlCl8D4r9VKWUYSg.png"/></div></div></figure><p id="d412" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>已经进入开发市场很长时间了，但是在与我的一些同事交流时，我发现许多人还没有开始使用RxJava，因为他们不知道它提供的好处。</p><p id="e349" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然有很多文章，但我写这篇文章是为了解释一个人如何容易习惯使用RxJava。在起点，一切都是新的，比如术语和使用什么。</p><p id="895a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要继续和它一起工作，这样我们才能习惯和理解它。在本帖中，我们将讨论RxJava的基础知识和一些有用的见解。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c338" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么是RxJava</h1><p id="a7de" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">RxJava是<a class="ae lq" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">反应式扩展</a>的Java VM实现:一个通过使用可观察序列来组成异步和基于事件的程序的库。</p><p id="431b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单来说，我们可以把它定义为一个带有可观察流的异步编程的API。它结合了观察者模式、迭代器模式和函数式编程的最佳思想。</p><p id="855c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它扩展了observer模式以支持数据/事件序列，并添加了操作符，允许您以声明的方式将序列组合在一起，同时抽象出诸如低级线程、同步、线程安全和并发数据结构之类的问题。</p><p id="28ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，我们可以说，由一个组件发出的数据和由Rx库提供的底层结构会将这些更改传播到另一个注册为接收这些数据更改的组件。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d4a8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">为什么要用RxJava？</h1><p id="8054" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在开始使用任何东西之前，我们需要分析我们为什么需要这个东西。将Executor服务用于线程化，将AsyncTask用于其他异步操作可以执行我们的任务，但是要正确地管理它们，我们要付出更多的努力。</p><h2 id="955a" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated"><strong class="ak">轻松多线程</strong></h2><p id="b3c2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">对于异步工作，线程管理至关重要。在许多情况下，当一个任务正在执行时，我们会遇到后台线程和主线程之间进行通信的情况。</p><p id="7eca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个简单的例子是在后台线程执行的同时更新UI。虽然听起来很容易，但我们知道在更新UI之前需要执行多少检查。</p><p id="474c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Rx使我们变得更容易，所以通过使用Rx，我们可以很容易地控制我们在一个单独的线程中开始的任务。</p><h2 id="5a61" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated"><strong class="ak">简单的错误处理</strong></h2><p id="cb52" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">错误是最让开发者沮丧的事情。在执行大量复杂的异步操作时，我们会在许多地方遇到错误。</p><p id="0e2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了避免这种情况，我们通常使用<code class="fe nh ni nj nk b">try</code> / <code class="fe nh ni nj nk b">catch</code>或其他一些补丁代码来解决这个问题。但是Rx提供了处理这些错误的标准方法。它有一个标准的成功和失败交付方法。</p><h2 id="ee79" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated"><strong class="ak">避免回调地狱</strong></h2><p id="18b5" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在任何时候，如果您已经进行了嵌套网络调用，您可能知道处理它们的痛苦。但是Rx有许多运营商可以非常容易地解决这类问题。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f0e0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">观察者模式</h1><p id="b503" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们稍微了解一下观察者模式。观察者模式是一种软件设计模式，其中一个名为<em class="nl">主题</em>的对象维护一个名为<em class="nl">观察者</em>的依赖者列表。</p><p id="b3e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它会自动通知它们任何状态变化，通常是通过调用它们的一个方法。简而言之，将会有一个观察者订阅可观察的<strong class="kw iu"> </strong>来获得最新数据或状态变化的通知。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="051f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">公式</h1><p id="6500" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在某种程度上，RxJava就是学习这个公式，并根据我们的要求应用它。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="2bc0" class="mv lz it nk b gy nq nr l ns nt">Rx= SCHEDULERS + OBSERVABLE + OBSERVER</span></pre><p id="fc0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来分析和理解每个组件。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c314" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">可观察量</h1><p id="969b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在RxJava中，Observables是向观察者发送数据的来源。对于观察者来说，要想听到可观测的东西，他们需要先订阅。</p><p id="5ee8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">订阅后创建的实例，在RxJava2中，称为<em class="nl"> Disposable </em>。如果任务完成或者停止监听Observables，我们可以通过调用Disposable实例上的方法<code class="fe nh ni nj nk b">dispose()</code>来取消订阅。</p><p id="aee6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以把可观的东西看作供应商。它们处理数据并将数据提供给其他组件。它做一些工作，并发出一些值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/8f07f105f7c38f4e573932db3d643fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dk5LNuA3lmBuU7SwQfjITQ.png"/></div></div></figure><p id="eb4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj nk b">Observable.OnSubscribe</code>是一个接口，它定义了当订户订阅可观察对象时要采取的动作。subscribe方法仅在观察者订阅可观察对象时运行。</p><p id="84f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建一个简单的可观察对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d911" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">观察者</h1><p id="5467" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">观察器是使用由可观察对象发出的数据的组件。在Rx中，观察者使用<code class="fe nh ni nj nk b">subscribe</code>方法订阅可观察对象，以接收可观察对象发出的数据。</p><p id="0b4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每当可观察对象发出数据时，所有注册的观察对象都会在<code class="fe nh ni nj nk b">onNext()</code>方法回调中接收数据。在这里，我们可以执行各种操作，比如解析JSON响应或更新UI等。如果有一个误差从可观察对象中抛出，观察者将在<code class="fe nh ni nj nk b">onError()</code>中接收到它。</p><p id="a380" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要理解观察者，我们应该知道三种基本方法。</p><ul class=""><li id="00ca" class="nx ny it kw b kx ky la lb ld nz lh oa ll ob lp oc od oe of bi translated"><code class="fe nh ni nj nk b">onNext()</code>:用于观察对象发射下一个物品时接收数据。</li><li id="71b2" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><code class="fe nh ni nj nk b">onError()</code>:发生错误时触发。</li><li id="12c7" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><code class="fe nh ni nj nk b">onComplete()</code>:最后一个项目发出后调用。基本上工作完成的时候。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/81d2ddfb4be6d76a9839e2430d7ec767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BZRUVhz-_qtx6ItvyMpmw.png"/></div></div></figure><p id="f6c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建一个简单的观察者实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c094" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们向观察者订阅可观察的。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="af6e" class="mv lz it nk b gy nq nr l ns nt">observableObject<!-- -->.<strong class="nk iu">subscribe</strong>(<!-- -->observerInstance<!-- -->);</span></pre><p id="329a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就在观察者和被观察者之间建立了一种联系。可观察对象现在会发出被观察者的<code class="fe nh ni nj nk b">onNext()</code>捕捉到的值。</p><p id="e45f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">控制台的输出是:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="910a" class="mv lz it nk b gy nq nr l ns nt">Output:<br/>onSubscribe<br/>onNext 10<br/>onNext 20<br/>onNext 30<br/>onComplete</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="56cf" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">调度程序</h1><p id="3d4a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">调度器用于指定工作必须在哪个线程上完成，因此这在线程管理的情况下更有用。</p><p id="3853" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Rx中，调度器是告诉可观察对象或观察者应该在哪个线程上运行的组件。</p><p id="e9d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe nh ni nj nk b">subscribeOn()</code>来告诉观察对象它应该在哪个线程上运行，我们可以使用<code class="fe nh ni nj nk b">observeOn()</code>来告诉观察对象它们应该在哪个线程上发出数据。</p><p id="8882" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有许多调度程序，但我们将讨论我们最常用的三个主要调度程序。</p><h2 id="a1a4" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated"><strong class="ak"> Schedulers.io() </strong></h2><p id="e56c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">通常用于IO相关的东西，如网络请求、文件系统操作等。IO调度程序由线程池支持。我们一般用它来表示:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="ba1a" class="mv lz it nk b gy nq nr l ns nt">observableInstance.subscribeOn(<strong class="nk iu">Schedulers.io()</strong>)</span></pre><p id="ebb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">返回用于IO绑定工作的默认共享调度程序实例。这可用于异步执行阻塞IO操作。</p><p id="a538" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个实现类似于来自<code class="fe nh ni nj nk b">java.util.concurrent</code>的<code class="fe nh ni nj nk b">ThreadPoolExecutor</code> <em class="nl"> </em>，具有一个无限的线程池。</p><p id="eb0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该实现由一个单线程<code class="fe nh ni nj nk b">ScheduledExecutorService</code>实例池支持，这些实例将尝试重用工作器使用的先前启动的实例，否则它们将启动一个新的支持<code class="fe nh ni nj nk b">ScheduledExecutorService</code>实例。</p><p id="4d00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，这个调度程序可能会创建无限数量的工作线程，这会导致系统变慢或<code class="fe nh ni nj nk b">OutOfMemoryError</code>。因此，对于临时用途或实现运算符时，必须释放Worker实例。</p><p id="f524" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过在代码中引用scheduler类之前必须设置的系统属性来控制这个标准调度程序的某些属性。支持的系统属性<code class="fe nh ni nj nk b">System.getProperty()</code>。</p><p id="6493" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，<code class="fe nh ni nj nk b">io()</code>调度器工作线程的保持活动时间为60秒，默认情况下，<code class="fe nh ni nj nk b">io()</code>调度器的线程优先级为<code class="fe nh ni nj nk b">NORM_PRIORITY</code>。</p><p id="ca02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们从应用的任何部分调用<code class="fe nh ni nj nk b">Schedulers.io()</code> <strong class="kw iu"> </strong>时，Rx框架中的以下方法被调用:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="642d" class="mv lz it nk b gy nq nr l ns nt">@NonNull<br/>public static Scheduler io() {<br/>    return RxJavaPlugins.<em class="nl">onIoScheduler</em>(<em class="nl">IO</em>);<br/>}</span></pre><h2 id="902e" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">Schedulers.computation()</h2><p id="d901" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">该调度程序可用于执行CPU密集型操作，如处理大量数据、位图处理等。使用该调度程序创建的线程数量完全取决于移动设备上可用的CPU内核数量。</p><p id="85e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果您的手机上有两个内核，那么池中将有两个线程。这也意味着，如果这两个线程很忙，那么进程将不得不等待它们可用。</p><p id="730b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这限制了并行运行的线程数量，当任务完全受限于CPU时，我们应该使用计算调度器；那是当它们需要计算能力并且没有阻塞代码的时候。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="98d5" class="mv lz it nk b gy nq nr l ns nt">observableInstance.subscribeOn(<strong class="nk iu">Schedulers.computation()</strong>)</span></pre><h2 id="b986" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">AndroidSchedulers.mainThread()</h2><p id="2643" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这个调度器由<a class="ae lq" href="https://github.com/ReactiveX/RxAndroid" rel="noopener ugc nofollow" target="_blank"> Rx Android </a>库提供，包名为io . react vex . Android . schedulers。</p><p id="4246" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个调度器用于将执行带回主线程，以便在需要时可以完成UI更新。这通常与如下所示的<code class="fe nh ni nj nk b">observeOn()</code>一起使用。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="3aca" class="mv lz it nk b gy nq nr l ns nt">observableInstance.observeOn(<strong class="nk iu">AndroidSchedulers.mainThread()</strong>)</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ca25" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">例子</h1><p id="2e42" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们通过一个例子来更好地理解所有这些组件。</p><h2 id="8150" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">第一步</h2><p id="08d0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">将依赖项添加到应用程序级<code class="fe nh ni nj nk b">build.gradle</code>。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="c833" class="mv lz it nk b gy nq nr l ns nt">//RxJava<br/>implementation 'io.reactivex.rxjava2:rxjava:2.2.8'</span><span id="fac4" class="mv lz it nk b gy om nr l ns nt">//RxAndroid<br/>implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'</span><span id="a428" class="mv lz it nk b gy om nr l ns nt">//ViewModel<br/>implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0'</span></pre><h2 id="1bc9" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">第二步</h2><p id="00d0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在潜入之前，让我们先了解一些方法，比如<code class="fe nh ni nj nk b">subscribeOn()</code>和<code class="fe nh ni nj nk b">observeOn()</code>。</p><p id="baff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj nk b">subscribeOn()</code>:这是一个方法，告诉观察对象它们应该在哪个线程上运行。无论您将<code class="fe nh ni nj nk b">subscribeOn()</code>方法放在观察对象链的哪个位置，它都只作用于根观察对象，并控制它应该在哪个线程上运行。</p><p id="2eb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个可观察对象应该只有一个<code class="fe nh ni nj nk b">subscribeOn()</code>来定义它的执行线程。尽管我们定义了多个<code class="fe nh ni nj nk b">subscribeOn()</code>方法，但最接近根可观察对象的方法将会起作用，其他的都不行。</p><p id="7be7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们有一系列的可观测值，那么根可观测值就是发射源。</p><p id="0b79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj nk b">observeOn()</code>:该方法告诉所有后续操作符将在哪个线程上执行(直到遇到另一个<code class="fe nh ni nj nk b">observeOn</code>)，它可能在链中多次出现，改变不同代码段的执行线程。</p><p id="68d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个方法告诉观察者他们应该在哪个线程上使用发出的可观察值。如果我们在一个可观察对象上定义了<code class="fe nh ni nj nk b">subscribeOn()</code>,而没有指定<code class="fe nh ni nj nk b">observeOn()</code>,那么观察者将只消费那个特定线程上的项目。</p><p id="65da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">用例</strong></p><p id="60b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，我们在单独的工作线程中运行的<code class="fe nh ni nj nk b">Scheduler.io()</code>上执行网络请求，但是我们需要用<code class="fe nh ni nj nk b">AndroidSchedulers.mainThread()</code>指定<code class="fe nh ni nj nk b">observeOn()</code>来使用发出的数据来更新UI。</p><p id="111a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建一个简单的应用程序，它有一个活动，在这个活动中，单击一个按钮，调用<code class="fe nh ni nj nk b">ViewModel</code>上的方法，从远程repo或本地计算中获取数据，以检查Rx是如何执行多线程的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8245" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来过一遍<code class="fe nh ni nj nk b">ViewModel</code>的逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2935" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/96436e883bc61548f7987da3ccddc509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pq5ayZgBMQBbN11Y0A_ncg.png"/></div></div></figure><h2 id="5b5b" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated"><strong class="ak">第三步</strong></h2><p id="1c05" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">分析。当我们观察<code class="fe nh ni nj nk b">ViewModel</code>中的方法时，我们可以理解为:</p><ol class=""><li id="42d7" class="nx ny it kw b kx ky la lb ld nz lh oa ll ob lp oo od oe of bi translated"><code class="fe nh ni nj nk b">CompositeDisposable</code>:一次性容器，可容纳多种其他一次性物品，并提供O(1)的添加和移除复杂度。</li><li id="5baf" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oo od oe of bi translated"><code class="fe nh ni nj nk b">subscribe()</code>:这个方法有两个部分，成功和失败块，我们可以根据需要处理每一种情况。</li><li id="54cf" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oo od oe of bi translated"><code class="fe nh ni nj nk b">subscribeOn()</code>和<code class="fe nh ni nj nk b">observeOn()</code> : <code class="fe nh ni nj nk b">subscribeOn()</code>用于指定被观察对象应该在哪个线程上执行工作，<code class="fe nh ni nj nk b">observeOn()</code>用于指定被观察对象应该在哪个线程上发出项目。</li><li id="8750" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oo od oe of bi translated"><code class="fe nh ni nj nk b">onCleared()</code>:这是<code class="fe nh ni nj nk b">ViewModel</code>被覆盖的方法，在这里我们可以处理掉所有的一次性物品。当<code class="fe nh ni nj nk b">ViewModel</code>被销毁时调用这个方法。</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3f23" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">奖金</h1><p id="f93a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">渴望了解更多关于Rx的信息，请继续阅读RxJava 上的系列<a class="ae lq" href="https://medium.com/@pavan.careers5208/complete-guide-on-rxjava-d997235e4eec" rel="noopener">完整指南。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0f35" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="7e2b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这还不是关于RxJava的全部知识；还有更多的探索，如不同的方法来创建一个可观测量和可观测量的类型，运营商等。</p><p id="c6b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将在接下来的文章中写下这些。让我们继续学习。</p><p id="f2dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请让我知道你的建议和意见。</p><p id="0489" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p></div></div>    
</body>
</html>