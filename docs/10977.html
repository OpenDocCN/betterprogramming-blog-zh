<html>
<head>
<title>GraphQL as an API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL作为API网关</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/graphql-as-apigateway-2058ba9dad7?source=collection_archive---------11-----------------------#2022-02-08">https://betterprogramming.pub/graphql-as-apigateway-2058ba9dad7?source=collection_archive---------11-----------------------#2022-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="10ba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">讨论图QL的N+1问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/30926ca0dfa807bfc0538527c47e166e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCEFuTIvovPhvovq0whGQw.jpeg"/></div></div></figure><p id="8358" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我之前的博客中，我解释了GraphQL如何用于微服务间的通信。我曾提到GraphQL也可以作为微服务的APIGateway。在这篇博客中，我将讨论如何从APIGateway利用GraphQL，以及一个众所周知的问题。</p><p id="9956" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以有不同的客户端(web、移动等)和多个微服务。所有这些微服务将只有一个网关。这里我将同时使用REST和GraphQL。REST用于客户端与网关之间的通信，然后网关将通过GraphQL与服务通信，并将响应返回给客户端。响应可以来自单个服务，也可以来自多个服务的聚合数据。API网关当然可以执行其他常用功能，如负载平衡、授权/认证或为express应用程序提供额外的安全性等。</p><h1 id="7355" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">实施</strong></h1><p id="b9c1" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在这里，我将展示如何使用APIGateway从单个服务中获取数据。(在我之前的博客中，我已经解释了HTTP POST请求是如何通过查询和变量产生的，所以这里不再解释。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e718" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，APIGateway用于返回来自不同服务的聚合数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="33d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> GraphQL N+1问题:</strong></p><p id="a5d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们开始深入研究GraphQL时，我们将开始听到人们谈论GraphQL的这个问题。那么什么是GraphQL N+1问题呢？</p><p id="6ad2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们想要获取所有用户的所有帖子。</p><p id="38f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们使用REST，我们将进行两次GET调用——一次获取所有用户，另一次获取这些用户的所有帖子。</p><p id="4ed0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是对于GraphQL，我们都知道GraphQL使用解析器函数来处理任何查询。解析程序同时解析同一级别的字段，在后续请求中，子级别的字段将被解析。</p><p id="e241" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，在这种情况下，首先解析器将运行查询<code class="fe mm mn mo mp b">getAllUsers</code>来获取用户列表，假设我们在数据库中有4个用户，然后它将为这4个用户中的每一个运行<code class="fe mm mn mo mp b">getPostsByUserId</code>，这样它将获取子级字段的数据。</p><p id="5ee0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在每个请求之后，我们需要聚集用户并发布数据，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a2ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，合并所有数据。这样，解析器进行1+N(在本例中是1+4)个查询。</p><p id="d321" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为发现问题是找到解决方案的第一步，所以这个问题也可以通过使用数据的批处理和缓存来解决(或者至少我们可以说是优化的)，并且有多个包可用于此(<a class="ae mq" href="https://www.npmjs.com/package/dataloader" rel="noopener ugc nofollow" target="_blank"> DataLoader包</a>等)</p><h1 id="6d79" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">结论</strong></h1><p id="bf37" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如前一篇博客所述——graph QL提供了精确提取数据(没有提取不足或提取过多)的好处，因此，它非常快，并在内部处理数据的聚合。</p><p id="794e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇博客中，我们讨论了GraphQL N+1问题。因此，根据业务用例，在权衡利弊之后，我们可以使用GraphQL作为微服务之间的通信。</p><p id="cd6b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在<a class="ae mq" href="https://github.com/aindrila-choudhuri/graphql-microservices-communication" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到完整的源代码。</p><p id="d462" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">继续编码，继续改变世界！:)</p></div></div>    
</body>
</html>