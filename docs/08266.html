<html>
<head>
<title>Mastering the Art of JavaScript Console Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript控制台日志记录的艺术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-the-art-of-console-logging-7518fead4e1a?source=collection_archive---------6-----------------------#2021-04-12">https://betterprogramming.pub/mastering-the-art-of-console-logging-7518fead4e1a?source=collection_archive---------6-----------------------#2021-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e048" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">成为专业控制台用户的10种控制台方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87f9c8f764edf2040d17740ae2e90efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*94gGcaE4ER-Jndqi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@theforestbirds?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joel&amp;Jasmin fr estbird</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="9dc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在漫长的调试过程中，我们都使用控制台对象进行虚拟打印。调试是前端开发人员必须面对的日常任务之一。为此，您可以使用调试器或控制台对象。</p><p id="66d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用后者时，大多数开发人员坚持使用最基本的<code class="fe lv lw lx ly b">console.log()</code>版本。然而，控制台对象有一个为不同场景定制的很棒的API。为什么只坚持一种方法？你充分利用它了吗？你想简化你的调试体验吗？</p><p id="7061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过了解最相关的控制台方法的来龙去脉，您将能够为工作选择正确的工具。在调试/记录代码时，您还将能够提取最相关的信息。最后，通过变得更有效率，你将会节省时间并让自己少一些麻烦。</p><p id="1836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看10种最相关的控制台方法:</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8539" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.console.log/.错误/。警告</h1><p id="4fb7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">console.log()</code>并不是写入控制台的唯一方式。控制台对象可以打印不同级别的文本:<code class="fe lv lw lx ly b">warn</code>、<code class="fe lv lw lx ly b">error</code>、<code class="fe lv lw lx ly b">log</code>。</p><p id="32a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用合适的品牌:</p><ul class=""><li id="cf85" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">代码不言自明。</li><li id="0adb" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">日志更容易区分。在打印一些调试日志时特别有用。</li><li id="a5c7" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">很容易通过相应的级别过滤相关的消息。</li></ul><p id="0d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看不同级别的活动:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/3403685676bb1e4c216319aa42c43843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVHqkhyev8utSTH0BXjvZw.png"/></div></div></figure><p id="0f30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">日志工具和浏览器允许您按严重性过滤日志消息。</p><p id="854f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需做一些简单的事情，如使用正确的日志级别，就可以看到许多好处。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="46e8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.console.count/。countReset</h1><p id="4422" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这项功能是我衡量绩效时的常用工具之一。当您调试组件的性能时，这很有用。</p><blockquote class="ns"><p id="62bd" class="nt nu it bd nv nw nx ny nz oa ob lu dk translated">"<code class="fe lv lw lx ly b"><strong class="ak">console.count()</strong></code>方法记录了这个对<code class="fe lv lw lx ly b">count()</code>的特定调用被调用的次数。"— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Console/count" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="66c4" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">当调用<code class="fe lv lw lx ly b">console.count('xxx')</code>时，它将打印出现的次数以及参数字符串。</p><p id="6276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个处决:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/349c0b1a77ca3d8312f3e3e4ffc850c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*ADBO48gcfY41VXVi6iaEJQ.png"/></div></figure><p id="34fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那有用在哪里？假设您有一个计算或渲染成本很高的组件。添加一个计数器来查看它被调用的次数是很有用的。它会让你知道有多少次昂贵的渲染/计算正在发生。</p><p id="1cf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像React这样的框架有自己的开发工具来绘制组件渲染，但不幸的是，在应该使用它们的关键场景中，它们并不可靠。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您可以随时使用<code class="fe lv lw lx ly b">console.countReset()</code>方法重置计数器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/9f6938181c21df8557eb9fa30084b824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ia_YK5TtO1okG4XuQE1YA.png"/></div></div></figure><p id="ca0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个完美的调试伴侣。您可以深入JavaScript代码，了解一段代码执行了多少次。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="165d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.console.time/.时间日志/。时间结束</h1><p id="8808" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">性能调试的另一个有用工具。<code class="fe lv lw lx ly b">console.time</code>方法将帮助您更好地理解应用程序各部分之间耗费了多少时间。</p><blockquote class="ol om on"><p id="8df8" class="kz la oo lb b lc ld ju le lf lg jx lh op lj lk ll oq ln lo lp or lr ls lt lu im bi translated">"启动一个计时器，您可以用它来跟踪一个操作需要多长时间。您给每个计时器一个唯一的名称，并且在一个给定的页面上可以运行多达10，000个计时器。当你用同样的名字调用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Console/timeEnd" rel="noopener ugc nofollow" target="_blank">console.timeEnd()</a></code>时，浏览器会输出计时器启动后经过的时间，以毫秒为单位。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Console/time" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="37ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，使用<code class="fe lv lw lx ly b">console.time()</code>启动定时器。然后，您可以使用<code class="fe lv lw lx ly b">console.timeLog()</code>来打印您可能感兴趣的任何中间时间结果。这种粒度方法将帮助您更好地理解代码的性能。</p><p id="ed74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oo">注意:一些浏览器可能会在该函数中接受第二个参数，您可以在其中记录额外的数据。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="f5ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是调用的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/219729befe0a89366f0989eadc98445a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjdtaypX4FFPGGIInI_W5A.png"/></div></div></figure><p id="63b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，这些值会根据运行代码的机器而有所不同。根据同一台计算机上的许多因素，执行时间也会有所不同。在根据性能时间观察做出决策时，请记住这两点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0e44" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.控制台.时间戳</h1><p id="2a91" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">此功能是非标准的，可能会因浏览器而异。</p><blockquote class="ol om on"><p id="57d6" class="kz la oo lb b lc ld ju le lf lg jx lh op lj lk ll oq ln lo lp or lr ls lt lu im bi translated">向浏览器的<a class="ae ky" href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference" rel="noopener ugc nofollow" target="_blank">性能</a>或<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Tools/Performance/Waterfall" rel="noopener ugc nofollow" target="_blank">瀑布</a>工具添加单个标记。这使您可以将代码中的某个点与时间轴中记录的其他事件相关联，如布局和绘画事件。— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Console/timeStamp" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="4957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在调试一些性能问题时，这是另一个巨大的帮助。它允许您向性能监视器UI添加一些输入，以便您可以将其用作参考。</p><p id="7b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看下面的例子:我们有一段处理一些项目的代码。我们想对执行过程有更多的了解。为此，我们可以使用性能监视器。</p><p id="1f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们的数组中处理了100个项目时，我们将使用<code class="fe lv lw lx ly b">console.timeStamp()</code>来打印一条消息。这些参考点可能会派上用场，帮助我们进一步了解正在发生的事情。在这个特定的例子中，由于我们要处理1000个项目，我们应该会看到十个<code class="fe lv lw lx ly b">timeStamps</code>出现在性能监视器中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="89a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们转到Chrome开发者工具，记录该按钮点击的性能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f2cff0a9ef8eca12a0938c07fdfc398e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpQBHNtZ2xWnz2_d9N-VUA.png"/></div></div></figure><p id="5b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不出所料，我们观察了十个<code class="fe lv lw lx ly b">timeStamp</code>习俗的实例。在这个小而简单的例子中，我们可以看到100个项目之间的时间是如何变化的，即使我们只是执行加法。这符合我们的预期，因为这是JavaScript执行的本质。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="01b0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.console.profile/.profileEnd</h1><p id="12cc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们看看最后的控制台方法，重点是内存/性能调试。<code class="fe lv lw lx ly b">console.profile()</code>允许您以编程方式启动JavaScript分析器。这使得profiler非常细粒度，只针对代码的特定区域。当你完成后，就打电话给<code class="fe lv lw lx ly b">console.profileEnd()</code>来结束分析。</p><p id="c973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这是非标准特性。行为可能因供应商而异。</p><p id="1731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个使用示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="814c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行后，您可以通过单击“...”来检查结果在Chrome开发者工具上，然后在“更多工具”和“JavaScript分析器”上</p><p id="f37f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们的例子的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/a85e8673810f0e1b62b8cac7b4a27afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gN6-Xm3CGbsYh-XWpNS6jg.png"/></div></div></figure><p id="1ed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够以编程方式分析我们的代码，让我们能够精确定位我们可能怀疑有内存问题的任何区域。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7a01" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.控制台.表格</h1><p id="2555" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个特性让你以一种更友好的方式来表示对象。函数的参数可以是对象或数组:</p><ul class=""><li id="5c9f" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">如果它是一个对象，它将显示它的可枚举属性。</li><li id="e70e" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">如果是数组，将显示每一项。</li></ul><p id="0d28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想在调试时比较两个对象。不使用调试器，您可以使用<code class="fe lv lw lx ly b">console.table()</code>方法来查看用户友好的比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="c907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/4a723cc378d3cc3df1794194f837fb1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRUbF77xCYi_c6m7A9wztw.png"/></div></div></figure><p id="ee76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时您不需要启动调试器，只需要一个友好的对象可视化就可以了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3a70" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">7.控制台.目录</h1><p id="9d3c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个函数与前一个函数有着相同的目标:帮助在控制台中可视化表示一个对象。</p><blockquote class="ol om on"><p id="c7a0" class="kz la oo lb b lc ld ju le lf lg jx lh op lj lk ll oq ln lo lp or lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Console</code>方法<code class="fe lv lw lx ly b"><strong class="lb iu">dir()</strong></code>显示指定JavaScript对象属性的交互式列表。输出显示为带有显示三角形的分层列表，可让您查看子对象的内容。— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Console/dir" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="b350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe lv lw lx ly b">console.log()</code>有什么区别？<code class="fe lv lw lx ly b">console.log()</code>方法使用<code class="fe lv lw lx ly b">toString</code>方法表示对象，而<code class="fe lv lw lx ly b">console.dir()</code>显示交互对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/6bb632b100d638894d2a9c93c3de8b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*uBXj3D8rcwwQCbC6S_NK0g.png"/></div></figure><p id="fd02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意在<code class="fe lv lw lx ly b">console.log()</code>执行中，我们没有得到对象类型，而在<code class="fe lv lw lx ly b">console.dir()</code>中我们得到了它。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="51f2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">8.控制台.组</h1><p id="96b7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">帮助您更好地可视化日志的另一种方法。这将增加你的日志层次。您将能够按层对它们进行分组。在调用<code class="fe lv lw lx ly b">console.groupEnd()</code>之前，每个<code class="fe lv lw lx ly b">console.group()</code>会将后续控制台消息缩进一个额外的级别。</p><p id="c195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="efad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看它的控制台结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/feef725b50ad2d23ad760ac46afc67aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8gONTHQza2m8imeBP33KPA.png"/></div></div></figure><p id="245c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你有很多日志并且你需要一点清晰的时候，这是非常有用的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f48c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">9.控制台. trace</h1><p id="c92f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个简单而强大的特性。控制台接口的<code class="fe lv lw lx ly b">trace</code>方法将当前方法堆栈跟踪输出到浏览器控制台。</p><p id="4fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过一个实践示例来更好地理解这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/ddc0aec8c96e490724a26e44e0d97dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*KptzJ_WyxMuA2yfjqwxccQ.png"/></div></figure><p id="4723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以观察到<code class="fe lv lw lx ly b">foo()</code>调用的堆栈跟踪。这有助于详细调试错误和异常，而无需使用调试工具。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3f99" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">10.控制台.断言</h1><p id="ddd1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我把一个最有用的方法留到了最后。<code class="fe lv lw lx ly b">console.assert()</code>可以通过使用类似测试的语法来帮助识别代码库中的bug。</p><blockquote class="ns"><p id="f986" class="nt nu it bd nv nw nx ny nz oa ob lu dk translated">如果断言为假，<code class="fe lv lw lx ly b"><strong class="ak">console.assert()</strong></code>方法将向控制台写入一条错误消息。如果断言为真，则什么都不会发生。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/console/assert" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="c9d9" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">让我们做一个虚拟的例子，我们将检查对象参数是否为falsy。当然，像TypeScript这样的工具将帮助您主动发现这些不一致之处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/aa6757684a3046763632c818662d3ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CnDzoxkpuq9IVBRXkG27RQ.png"/></div></div></figure><p id="3e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码不应该意外地被发布到产品中。这只是为了帮助你调试会话。通过放置断言，您可以在不同的方法上验证您的假设，而不必自己添加断点来进行检查。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a27f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最后的想法</h1><p id="09ca" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经看到当正确使用时，控制台方法在我们的日常开发生活中有多大的帮助。它涵盖了广泛的领域:</p><ul class=""><li id="a81d" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">对象可视化</li><li id="4010" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">误差增大</li><li id="bc58" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">数据比较</li><li id="df1c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">性能监控器</li><li id="cdcd" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">内存分析</li><li id="2d27" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">输出的粒度级别</li></ul><p id="f292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您并不总是需要控制台界面来进行调试。你可以使用调试器。根据不同的场景，您可能会使用其中一种工具。然而，通过了解你所掌握的所有工具，你可以做出更好的决定。</p><p id="b68c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能让你开始使用控制台方法，并打破默认使用<code class="fe lv lw lx ly b">console.log()</code>的习惯。</p><p id="55dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0040" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">有关系的</h1><div class="pa pb gp gr pc pd"><a rel="noopener  ugc nofollow" target="_blank" href="/5-common-javascript-memory-mistakes-c8553972e4c2"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">5个常见的JavaScript内存错误</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">避免应用程序内存泄漏的技巧</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">better编程. pub</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ks pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a rel="noopener  ugc nofollow" target="_blank" href="/10-javascript-array-methods-to-boost-your-code-performance-acb57b455189"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">提高代码性能的10种JavaScript数组方法</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">Every、some、includes和其他数组方法</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">better编程. pub</p></div></div><div class="pm l"><div class="ps l po pp pq pm pr ks pd"/></div></div></a></div></div></div>    
</body>
</html>