<html>
<head>
<title>Dynamic Programming Interview Questions (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划面试问题(下)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-programming-series-2-longest-palindromic-substring-bd1271e3a947?source=collection_archive---------3-----------------------#2020-06-20">https://betterprogramming.pub/dynamic-programming-series-2-longest-palindromic-substring-bd1271e3a947?source=collection_archive---------3-----------------------#2020-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3081" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">查找最长的回文子串</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d9c4fe2e8261e94b14202f9e8643b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cwTXkJbiKnXTB-Im"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">菲利普·里昂在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="08c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列的这一章中，我们将一起使用动态编程来解决一个问题。承蒙<a class="ae ky" href="https://leetcode.com/problems/longest-palindromic-substring/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>的帮助，我们正在解决的问题如下:</p><blockquote class="lv lw lx"><p id="7764" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">给定一个字符串<em class="it"> s </em>，找出<em class="it"> s </em>中最长的回文子串。你可以假设<em class="it"> s </em>的最大长度是1000。</p><p id="0e20" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">例1:输入:' babad '输出:' bab '注意:' aba '也是有效答案。</p><p id="8074" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">示例2:输入:“cbbd”输出:“bb”</p></blockquote><p id="bb3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回想一下本系列的第一章<a class="ae ky" href="https://medium.com/@steffy.lo98/dynamic-programming-series-1-what-is-it-and-why-is-it-so-important-64675b9f6049" rel="noopener">你认为我们应该使用自上而下还是自下而上的DP方法来解决这个问题？花点时间想想你会使用哪种方法，为什么。</a></p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3e2f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">我的方法和原因</h1><p id="9364" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">每当我看到一个看起来可以用DP解决的问题时，我都忍不住要先看看强力解决方案。暴力解决方案显然是非常低效的。它包括遍历一个子串所有可能的开始和结束位置，然后检查它是否是一个回文。如果我们看一下示例1的输入(“babad”)，使用零索引，这给了我们<em class="ly"> (0，0)，(0，1)，(0，2)，…，(0，n-1) </em>作为第一个字母的可能开始和结束位置，<em class="ly"> (1，1)，(1，2)，…，(1，n-1) </em>作为第二个字母，等等，其中<em class="ly"> n </em>是字符串输入的长度(因此在这种情况下<em class="ly"> n = 5这意味着字符串“babad”总共有<em class="ly"> n + (n-1) + … + 1 = n(n+1)/2 </em>个不同的可能子字符串，并且因为验证每个子字符串将花费<em class="ly"> O(n) </em>时间，所以总时间复杂度总计为<em class="ly"> O(n ) </em>。</em></p><p id="dac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我从这种暴力分析中得到了什么呢？我们需要验证每一个可能的子串。这意味着自下而上的方法效果最好。</p><p id="89a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经选择了将要使用的方法，让我们建立一些基本案例。</p><ul class=""><li id="8d94" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">情况0 ( <em class="ly"> n = 0 </em>):空字符串是一个回文，这是毫无疑问的。</li><li id="a8d7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">案例1 ( <em class="ly"> n = 1 </em>):因为一个字母本身就是一个回文，所以所有长度为1的子串都是一个回文。</li><li id="82e6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">情况2 ( <em class="ly"> n = 2 </em>):长度为2的子串只有在第一个和最后一个字母相同的情况下才能是回文。</li><li id="36b5" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">情况3 ( <em class="ly"> n = 3 </em>):如果第一个和最后一个字母相同，长度为3的子串是回文。中间的字母无关紧要，因为我们知道单个字母本身就是一个回文。嗯…这看起来很熟悉。似乎我们可以通过使用案例1和案例2的结果来确定案例3。</li><li id="c31b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">情况4 ( <em class="ly"> n = 4 </em>):长度为4的子串是回文，如果第一个和最后一个字母相同，剩下的两个字母组成一个回文。</li></ul><p id="2e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到现在为止，你应该开始看到回文的结构了。似乎单词是回文，第一个和最后一个字母必须相同，不包括第一个和最后一个字母的字符串也必须是回文。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/32c50d5362789f33e6f26c3bfd75d984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BlpI9agQPi9K35Kf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="f688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它本质上有以下递归定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，我们有三种基本情况:情况0、情况1和情况2。由于我们使用自下而上(列表)的方法，我们现在必须将这些基本情况的初始值列表，并使用这些值来计算我们给定输入的期望解。</p><p id="e410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们应该如何着手做这件事呢？我们如何表示一个子串所有可能的开始和结束位置，并存储它们的解呢？对此，什么是好的数据结构？嗯，看起来矩阵(即2D阵列)会工作得很好。</p><p id="cf89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将<em class="ly">I</em>s定义为子串的起始索引，将<em class="ly">j</em>s定义为子串的结束索引，这样矩阵的对角线必须是<code class="fe nx ny nz oa b">True</code>并且对角线以下的任何内容都必须是<code class="fe nx ny nz oa b">False</code>，因为我们不需要以逆序考虑子串。请注意，我们的矩阵大小为<em class="ly"> n * n </em>，其中<em class="ly"> n </em>是我们输入字符串的长度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/cd086144b6db7b0e19ad899ba37cedab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*foW65cF1vU_0UaTh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="b5c4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">用Python实现</h1><p id="6b9f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">所以现在我们知道该怎么做了，让我们把这个想法移到Python上。首先，我们有一个接受输入字符串的主函数。让我们初始化2D数组，使所有的<code class="fe nx ny nz oa b">False</code>值都像这样:</p><pre class="kj kk kl km gt oc oa od oe aw of bi"><span id="10d2" class="og mk it oa b gy oh oi l oj ok">def main(string):<br/>    # A matrix of booleans, storing the results of whether the substring at index i to j is a palindrome<br/>    palindrome_table = [[False for i in range(len(string))] for j in range(len(string))]</span></pre><p id="c8af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们想将对角线设置为填充所有的<code class="fe nx ny nz oa b">True</code>值:</p><pre class="kj kk kl km gt oc oa od oe aw of bi"><span id="9e6b" class="og mk it oa b gy oh oi l oj ok">for k in range(len(string)):<br/>   palindrome_table[k][k] = True</span></pre><p id="30bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们已经计算了第一个和第二个基本案例(案例0和案例1)的值！对于第三种基本情况，我们需要检查长度为2的每个子串是否是一个回文，并存储它们的结果:</p><pre class="kj kk kl km gt oc oa od oe aw of bi"><span id="caa2" class="og mk it oa b gy oh oi l oj ok">for k in range(len(string) - 1):<br/>   if string[k] == string[k+1]:<br/>       palindrome_table[k][k+1] = True</span></pre><p id="02d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来不错。现在，我们必须继续构建矩阵，同时从基础案例开始逐步推进:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们已经完成了价值矩阵。现在怎么办？我们如何找到最长的回文子串？嗯，只需通过调整现有代码来跟踪最长子串的起始和结束索引:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/c5462fd0accf8ee3a96e71f7211c7ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qaTlrIJkyK4l-wY1"/></div></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="4bc2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="7e04" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们完事了。这的确很有挑战性，但我们做到了！在本系列的下一部分，我们将继续用动态编程解决更多的问题。如果你没有得到这个，不要担心。我发现这也很难。下次我们会做一个更简单的。</p><p id="1371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>