<html>
<head>
<title>How to Fully Test a React Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何全面测试React组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fully-testing-a-react-component-e81eb5c4f9d?source=collection_archive---------10-----------------------#2020-01-19">https://betterprogramming.pub/fully-testing-a-react-component-e81eb5c4f9d?source=collection_archive---------10-----------------------#2020-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f457" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可测试的代码是好代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1da35ad08c08d4ad4f3e60d2fbdffc2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*79pbuYfzFQ0HfwUm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@omerrana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Omer Rana </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="12ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在React.js的很多测试教程中看到的东西是正在测试的组件，但有些东西被忽略了。或者更糟，完全依赖快照测试，它不能测试所有的东西。开发人员经常在更改后更新快照，甚至不看快照表示中发生了什么变化(我在专业上也见过这种情况！).所以，如果你有很多React和测试React代码的质量经验，你最好跳过这一步去读别的。但是如果你有任何空白，请继续阅读！</p><p id="27a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在本教程中使用<code class="fe lv lw lx ly b">create-react-app</code>，因为这是一种简单的入门方式，并且已经提供了对通用测试库的支持:<code class="fe lv lw lx ly b">jest</code>。运行完<code class="fe lv lw lx ly b">npx create-react-app my-project</code>后，我编辑了<code class="fe lv lw lx ly b">src/App.js</code>文件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该组件呈现一个输入，用户可以输入一个神奇宝贝的名字，然后在点击搜索按钮后看到神奇宝贝的图像。以下是三种主要的用户流:</p><ol class=""><li id="47e0" class="mb mc it lb b lc ld lf lg li md lm me lq mf lu mg mh mi mj bi translated">用户输入一个神奇宝贝的正确名称并点击搜索按钮，然后在屏幕上查看神奇宝贝的图像。</li><li id="fcd3" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated">用户输入了不正确的名称，但在屏幕上看到一个错误。</li><li id="d5f7" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated">用户没有在输入中输入任何内容，而是单击了search按钮，然后看到一个错误，要求用户首先键入姓名。</li></ol><p id="ee88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">getPokemon</code>功能基本上只是使用原生的<code class="fe lv lw lx ly b">fetch</code>功能，通过使用<a class="ae ky" href="https://pokeapi.co/" rel="noopener ugc nofollow" target="_blank">免费神奇宝贝API </a>按名称检索一个神奇宝贝。该文件如下所示:</p><pre class="kj kk kl km gt mp ly mq mr aw ms bi"><span id="0910" class="mt mu it ly b gy mv mw l mx my">// API.js</span><span id="7028" class="mt mu it ly b gy mz mw l mx my">export const getPokemon = name =&gt;<br/>  fetch(`https://pokeapi.co/api/v2/pokemon/${name}`)<br/>    .then(res =&gt; res.json());</span></pre><p id="690e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们为组件编写一个测试。为此，我们可以通过以下方式将<code class="fe lv lw lx ly b">enzyme</code>添加到我们的项目中:</p><pre class="kj kk kl km gt mp ly mq mr aw ms bi"><span id="21e8" class="mt mu it ly b gy mv mw l mx my">npm i --save-dev enzyme enzyme-adapter-react-16</span></pre><p id="d4a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用<code class="fe lv lw lx ly b">create-react-app</code>已经为我们建立的测试文件。为了使事情更简单，我简单地在同一个文件中配置了<code class="fe lv lw lx ly b">enzyme</code>,然后编写了一个简单的测试来覆盖第一个用例</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="6cae" class="nh mu it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">用户流#1</h1><h2 id="9d6d" class="mt mu it bd ni ny nz dn nm oa ob dp nq li oc od ns lm oe of nu lq og oh nw oi bi translated">用户输入一个神奇宝贝的正确名称并点击搜索按钮，然后在屏幕上查看神奇宝贝的图像</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的测试模拟了API，所以我们在测试过程中实际上不必触及API。当你在开发时，依赖API是不切实际的，这也是“关注点分离”的一个很好的实践。</p><p id="665f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚编写的测试确保用户输入的内容用于获取相关的神奇宝贝。这是可以的，但我们不是在测试整个流程。我们还必须确保用户不会收到错误，而是看到一个图像，并且该图像与他们在响应中收到的图像相同。在我们的例子中，我们伪造了这个响应，并在我们的<code class="fe lv lw lx ly b">describe</code>块中保持图像路径在<code class="fe lv lw lx ly b">randomImagePath</code> const中。然而，为了等待API的结果，我们必须将测试转换成异步测试— <code class="fe lv lw lx ly b">Promise</code>对象是异步操作的表示。然后，我们还必须创建一个助手函数，帮助我们等待承诺的解决。显然，在我们的例子中，我们立即解析了承诺，但是我们仍然必须等待一个滴答过去，以便JavaScript可以执行下一个操作。这是测试之后的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2a02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们不仅断言使用用户输入调用了<code class="fe lv lw lx ly b">getPokemon</code>函数，而且我们还可以测试在被模仿的<code class="fe lv lw lx ly b">getPokemon</code> API调用解析后，没有错误，页面上的一个图像标签使用了来自API响应的正确URL。</p><p id="6b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这个测试用例之后，我们可以确保之前描述的第一个用例得到了充分的测试。让我们进入下一个测试。</p><h1 id="ea32" class="nh mu it bd ni nj oj nl nm nn ok np nq jz ol ka ns kc om kd nu kf on kg nw nx bi translated">用户流#2</h1><h2 id="1249" class="mt mu it bd ni ny nz dn nm oa ob dp nq li oc od ns lm oe of nu lq og oh nw oi bi translated">用户输入了不正确的名称，但在屏幕上看到一个错误</h2><p id="4e5e" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">为了测试这一点，我们必须模拟我们的spy函数到<code class="fe lv lw lx ly b">reject</code>的实现，而不是解析。完成之后，我们可以简单地断言页面上有一个错误，并且该错误的文本是正确的。在第一个测试下面添加了另一个测试后，我们的<code class="fe lv lw lx ly b">App.test.js</code>文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7b64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个测试非常简单明了。请注意，我们已经通过移动测试本身中API调用的<code class="fe lv lw lx ly b">mockImplementation</code>部分进行了调整，并在每次测试后恢复模拟，因此测试之间没有干扰。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="4293" class="nh mu it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">用户流#3</h1><h2 id="f435" class="mt mu it bd ni ny nz dn nm oa ob dp nq li oc od ns lm oe of nu lq og oh nw oi bi translated">用户没有在输入中输入任何内容，而是单击了search按钮，然后看到一个错误，要求用户首先键入姓名</h2><p id="ef7b" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">这个测试用例比其他的稍微短一点。添加最后一个测试后，我们的文件现在看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a4a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了断言错误以正确的文本显示之外，我们还断言<code class="fe lv lw lx ly b">API</code>函数<code class="fe lv lw lx ly b">getPokemon</code>从未被调用，因此节省了一个不必要的API调用。如果将来某个开发人员决定改变这种行为，这个测试将会中断并给他们提供一个提示。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="c38d" class="nh mu it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">继续前进</h1><p id="7d0a" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">如果您想测试自己，还有一个小功能没有测试。对于第一个用例，我们当前的React组件在收到来自Pokemon API的成功响应后也会清除输入。然而，这不是我们目前的第一个测试，所以您可以修改它，以包括这个<code class="fe lv lw lx ly b">expect</code>断言。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="297b" class="nh mu it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">结论</h1><p id="a246" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">所有这些测试都足够了吗？不，我们仍然应该进行快照测试，以确保组件结构不会被开发人员有意更改。此外，我们测试流程中的一个主要缺口是我们没有测试过<code class="fe lv lw lx ly b">getPokemon</code>函数。但这是有意的，本文只是关于测试React组件和分离所有其他代码。正确的单元测试是小型的，只测试一段代码。这不是不测试其他代码的借口，而是鼓励为它们建立单独的单元测试文件。API调用测试非常简单，使用<code class="fe lv lw lx ly b">axios</code>和<code class="fe lv lw lx ly b">axios-mock-adapter</code>可以进一步简化。也许我们会在另一篇文章中讨论这个问题。下次见！</p></div></div>    
</body>
</html>