<html>
<head>
<title>What’s Coming in C# 10?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# 10中有什么新内容？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/upcoming-features-in-c-10-f4471203dacc?source=collection_archive---------4-----------------------#2021-08-18">https://betterprogramming.pub/upcoming-features-in-c-10-f4471203dacc?source=collection_archive---------4-----------------------#2021-08-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a9db" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">文件范围的命名空间、记录结构等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/2abaeeb7d2eb0dc890c961d90ba53870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2RYlrI0h2KEKwfHK"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@bermixstudio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Bermix工作室</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="7ba0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">十多年前，C#是一种Windows编程语言。你用它在你的Windows机器上制作“Windowsey”的东西。自从微软<a class="ae kz" href="https://devblogs.microsoft.com/dotnet/net-core-is-open-source/" rel="noopener ugc nofollow" target="_blank">决定开源。NET 2014年</a>，该语言及其生态系统已经走过了漫长的道路。</p><p id="2346" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天，C#是一种非常适合几乎任何软件项目的语言，从半低级代码到成熟的Web应用程序。NET生态系统是全世界许多开发人员的首选。</p><p id="9dfc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">C# 的前一版本带来了几个主要的新特性，但是与诸如Go，甚至TypeScript这样的语言相比，C#仍然有点冗长。</p><p id="866d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然运行一个最小的Hello World程序所需的代码量在过去已经减少了，但是任何真实世界的程序仍然包含大量的using指令、命名空间声明和编译器所需的其他程序。</p><p id="7188" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在C# 10即将发布的版本中，语言团队希望减少所需的强制仪式代码的数量。虽然与C# 9相比，这一次这些特性可能看起来不那么重要，但它们为语言引入了一些急需的简洁。</p><p id="8460" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你觉得这篇文章很有趣，并且想跟踪这种语言的发展，它的提议，草案，规范和所有关于C#的东西，请前往<a class="ae kz" href="https://github.com/dotnet/csharplang/tree/main/proposals" rel="noopener ugc nofollow" target="_blank">CSharpLang库</a>。它包含了所有的细节。</p><p id="1f48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们深入研究这些特性之前，请记住，这些都不是最终结果。这里的一些特性甚至被认为可以进入C# 9，但是最终没有通过。在这篇文章和C# 10的实际发布之间，事情可能会发生变化。</p><p id="5915" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，说点好的。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="a8fe" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">全局使用指令</h1><p id="139d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">每一个C#源文件都以同样古老的仪式开始:使用指令。它们告诉编译器应该在哪里寻找代码中使用的类型。</p><p id="5411" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用指令有两个问题:它们非常重复，并且大多是自动管理的，要么通过IntelliSense，要么通过第三方扩展。</p><p id="f273" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我几天前写的一段代码，包含了一个非常简单的100 SLOC程序的用法:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="462b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">前六种极为常见。如果我不得不尝试一下，我使用的大约90%的源文件都会用到它们。其他一些在我的应用程序中很常见。一定有更好的方法。</p><p id="ded1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从C# 10开始，这些可以用全局using指令来表示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="6e5a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些命名空间随后会在项目的每个源文件中使用。这允许您将源文件中的using指令缩小到特定于该段代码的指令，以及在全局名称空间不适合该单独的源文件时的类型别名。</p><p id="3f32" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有趣的是，编译器会自动选取这些全局using指令。不像C++的头文件系统，它需要一个include:<code class="fe nc nd ne nf b">#include &lt;Precompiled.hpp&gt;</code>——这样C#优雅地避免了命名空间和头文件的常见问题，比如循环包含。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="a6dd" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">文件范围的命名空间</h1><p id="463a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">C#的另一个产物是名称空间声明。与C++不同，为类型声明命名空间是强制性的。这意味着每个文件都从两级缩进开始:一级用于命名空间，另一级用于类型定义:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="eebc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">类似于以前版本中对<code class="fe nc nd ne nf b">using</code>语句的处理，C# 10允许您放弃缩进，只为每个文件声明一个名称空间:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="3dea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">没什么大不了的，编译后的代码看起来完全一样，使用文件范围的名称空间完全是可选的；您之前的所有代码仍然可以很好地编译。虽然我已经习惯了C#类的形式，但是消除语言中不必要的缩进是一件好事。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9080" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">记录和构建改进</h1><p id="9e5b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在下一个版本的C#中，<code class="fe nc nd ne nf b">record</code>和<code class="fe nc nd ne nf b">struct</code>类型都有很多变化和改进。因为这些是高度相关的(就像，其中一些不能没有其他的存在)，我将在这一节中对它们进行总结。</p><h2 id="8513" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">记录结构</h2><p id="537d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在以前的C#版本中，<code class="fe nc nd ne nf b">record</code>介绍了类型。记录是具有引用类型行为的类型，但是是值类型比较。简单地说，这意味着它们仍然在堆上分配，但是相等性是由它们的值决定的，而不是由引用决定的。</p><p id="4f7f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从设计角度来看，<code class="fe nc nd ne nf b">record</code>类型通常用于表示成员，其值代表特定时间点的对象。因此，与常规类相反，记录的值不会被更新——相反，记录的新副本是用更新后的值创建的。</p><p id="9e70" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是通过使用<code class="fe nc nd ne nf b">with</code>关键字完成的，例如:</p><pre class="kk kl km kn gu ns nf nt nu aw nv bi"><span id="b8e9" class="ng me iu nf b gz nw nx l ny nz">var e = someEvent with { CorrelationId = Guid.NewGuid(); }</span></pre><p id="4388" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这将创建记录的副本，并设置更新后的<code class="fe nc nd ne nf b">CorrelationId</code>属性。原始记录保持不变。</p><p id="98bd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有时，拥有这些“随时间变化”的语义是可取的，但拥有引用类型语义是不可取的——例如，如果您的记录只包装值类型。为了填补这一空白，<code class="fe nc nd ne nf b">record struct</code>将在C# 10中得到支持，为您带来两全其美。</p><h2 id="2830" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">无参数结构构造函数</h2><p id="b171" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">为了给<code class="fe nc nd ne nf b">record struct</code>类型铺平道路，在C# 10中，<code class="fe nc nd ne nf b">struct</code>可以包含一个公共的无参数构造函数。这适用于所有结构类型:</p><ul class=""><li id="9c1b" class="oa ob iu lc b ld le lg lh lj oc ln od lr oe lv of og oh oi bi translated"><code class="fe nc nd ne nf b">struct</code></li><li id="a438" class="oa ob iu lc b ld oj lg ok lj ol ln om lr on lv of og oh oi bi translated"><code class="fe nc nd ne nf b">record struct</code></li><li id="3bcf" class="oa ob iu lc b ld oj lg ok lj ol ln om lr on lv of og oh oi bi translated"><code class="fe nc nd ne nf b">ref struct</code></li><li id="af32" class="oa ob iu lc b ld oj lg ok lj ol ln om lr on lv of og oh oi bi translated"><code class="fe nc nd ne nf b">readonly struct</code></li></ul><p id="ff13" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，也可以为结构指定字段初始值设定项。任何没有被构造函数显式设置的字段都将被初始化为默认值。任何没有初始值设定项的值都将被归零。</p><p id="f103" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">没什么太刺激的。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="ee34" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">通用属性</h1><p id="ffd1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">引进于。NET 2.0中，现代代码中经常使用属性来修饰属性或类型，以便为这些成员提供元数据。您可能熟悉的一个属性是在<code class="fe nc nd ne nf b">Newtonsoft.Json</code>和<code class="fe nc nd ne nf b">System.Text</code>中都可以找到的<code class="fe nc nd ne nf b">JsonConverterAttribute</code>。它用于指示属性和类型的自定义序列化行为。</p><p id="d24d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">考虑以下转换器，<a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to?pivots=dotnet-5-0" rel="noopener ugc nofollow" target="_blank">由提供。网络文档</a>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="c4b0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目前，如果您想将这个转换器应用到您的类中的一个属性，您必须按照以下方式做一些事情:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="3483" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这并不理想。主要是因为被传递的类型是不受约束的——你可以传递一个有效的转换器，但也可能只是<code class="fe nc nd ne nf b">typeof(string)</code>。</p><p id="3452" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这导致代码的总体可设计性差，因为属性的作者不能有意义地约束被传递的类型。使用静态代码分析检测该错误是有问题的。</p><p id="183c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为阻止实现<code class="fe nc nd ne nf b">Attribute</code>类型的运行时限制随着。NET核心运行时，属性在技术上可以是泛型的。C# 10将为这一特性带来语言支持。</p><p id="1764" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着在C# 10中，上面的例子可以表示为:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="2155" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当传递一个不是真正的<code class="fe nc nd ne nf b">JsonConverter</code>类型时，提供编译时错误，并产生稍微简洁的代码。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="ae99" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">荣誉奖</h1><p id="66a6" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">有一堆更小的改进和优化，并没有真正保证他们自己的一节。</p><p id="2c89" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不过，把它们排除在外是不对的，所以在这里它们没有特定的顺序:</p><h2 id="2208" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">常量插值字符串</h2><p id="70fe" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在C#中，任何<code class="fe nc nd ne nf b">const</code>值都必须是编译时常数。对于字符串，这意味着它们必须是文字字符串，即<code class="fe nc nd ne nf b">string.Format</code>和插值字符串是不可能的——即使格式化或插值字符串中的所有成分都是常数！</p><p id="9436" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">考虑以下字符串:</p><pre class="kk kl km kn gu ns nf nt nu aw nv bi"><span id="78f1" class="ng me iu nf b gz nw nx l ny nz">const string Foo = $"Foo";</span></pre><p id="cff4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目前，该语言不允许将该表达式用作<code class="fe nc nd ne nf b">const</code>值。在C# 10中，这个限制被取消了，只要一个字符串的所有组成部分在编译时都是可解析的，插值后的字符串就可以用作<code class="fe nc nd ne nf b">const</code>值。</p><p id="5261" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着在C# 10中，以下代码可以编译:</p><pre class="kk kl km kn gu ns nf nt nu aw nv bi"><span id="9ca8" class="ng me iu nf b gz nw nx l ny nz">public class C<br/>{<br/>    const string S1 = "Hello world";<br/>    const string S2 = "Hello" + " " + "World";<br/>    const string S3 = S1 + " Kevin, welcome to the team!";<br/>}</span></pre><h2 id="c84c" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">解构赋值和声明</h2><p id="3b69" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">当使用解构时，你可以赋值或者声明你要解构的变量。这意味着这两种解构目前都可以编译:</p><pre class="kk kl km kn gu ns nf nt nu aw nv bi"><span id="c464" class="ng me iu nf b gz nw nx l ny nz">// Assign variables through deconstruction<br/>int x = 0;<br/>int y = 0;<br/>(x, y) = point;</span><span id="2cf9" class="ng me iu nf b gz oo nx l ny nz">// Declare variables through deconstruction<br/>(int x, int y) = point;</span></pre><p id="72ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，不允许将它们混合使用。如果其中一个变量之前已经在代码中声明过，而另一个变量是通过解构获得的，这可能会有问题。</p><p id="3e7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个限制在C# 10中被取消了，允许你在解构时混合声明和赋值:</p><pre class="kk kl km kn gu ns nf nt nu aw nv bi"><span id="7598" class="ng me iu nf b gz nw nx l ny nz">int x = 10;<br/>(x, int y) = point;</span></pre><p id="3825" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你知道，万一你遇到了这个非常特殊的问题。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="76bb" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="eb2b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">C# 9引入了许多新特性，而C# 10即将发布的版本看起来更像是一个维护版本。详细阐述前面介绍的功能，同时主要关注减少代码中的强制噪声。</p><p id="54af" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那很好。在过去的几年里，C#作为一种语言一直在快速发展。在过去的几个主要版本中，趋势是每个主要特性版本都被一个主要关注改进的版本所替代。这次发布的肯定是后者。</p><p id="2299" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本文中列出的特性并不是决定性的。正如本文开头所提到的，C# 10的组成仍然在不断变化。我主要关注那些或多或少能保证成功的特性。如果有更多的补充，我会更新文章。</p><p id="610b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读！</p></div></div>    
</body>
</html>