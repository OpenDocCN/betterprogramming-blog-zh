<html>
<head>
<title>Implementing ‘Map’ in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中实现“地图”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-map-in-go-40c55d34dbb4?source=collection_archive---------16-----------------------#2020-03-03">https://betterprogramming.pub/implementing-map-in-go-40c55d34dbb4?source=collection_archive---------16-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ab6a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Go和Go例程将一个数组通用映射到另一个数组</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e80673d96598215e64857eb77b3ada6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*wPHs_uuY8isxMLfvpfjgGQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由<a class="ae ku" href="https://www.flaticon.com/" rel="noopener ugc nofollow" target="_blank">https://www.flaticon.com/</a>提供</p></figure><h1 id="2b4f" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><code class="fe ln lo lp lq b">'Map'?</code>有什么好处</h1><p id="4bff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">想象一个有n个条目的数组。您希望处理数组中的每个条目，但是每个过程需要三秒钟。你必须开始写代码。</p><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="dd93" class="ms kw it lq b gy mt mu l mv mw">arr := [...]interface{..., ..., ..., ...}<br/>for i, entry := range arr {<br/>    doSomething(i, entry)<br/>}</span></pre><p id="9fc2" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">现在<code class="fe ln lo lp lq b">doSomething</code>是一名举重运动员。如果处理每个强制完成的条目需要大约三秒钟，那么处理<em class="mn">(t)</em>n个数组所需的总时间为:</p><p id="c4ef" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe ln lo lp lq b">t = N * 3s</code></p><p id="0bfc" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">通过使用一个<code class="fe ln lo lp lq b">Map</code>函数，我们可以尝试在一个<code class="fe ln lo lp lq b">goroutine</code>中分别处理每个条目。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="2e2e" class="kv kw it bd kx ky nj la lb lc nk le lf jz nl ka lh kc nm kd lj kf nn kg ll lm bi translated">平行地图在Go中</h1><p id="d76f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">想象一个叫做<code class="fe ln lo lp lq b">ParallelMap</code>的函数。它需要两个参数:</p><ul class=""><li id="ffa0" class="no np it lt b lu mx lx my ma nq me nr mi ns mm nt nu nv nw bi translated">任何种类的对象。姑且称之为<code class="fe ln lo lp lq b">source</code>。</li><li id="11b6" class="no np it lt b lu nx lx ny ma nz me oa mi ob mm nt nu nv nw bi translated">一个<code class="fe ln lo lp lq b">Function</code>，它接受<code class="fe ln lo lp lq b">source</code>的一个条目，并在处理该条目后返回一个新的值/类型。姑且称之为<code class="fe ln lo lp lq b">transform</code>。</li></ul><p id="1774" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">它返回:</p><ul class=""><li id="ceb2" class="no np it lt b lu mx lx my ma nq me nr mi ns mm nt nu nv nw bi translated">另一个<code class="fe ln lo lp lq b">array</code>对象是<code class="fe ln lo lp lq b">function</code>转换<code class="fe ln lo lp lq b">source</code>条目的结果。</li></ul><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="2e84" class="ms kw it lq b gy mt mu l mv mw"><em class="mn">// ParallelMap an array of something into another thing using go routine</em><br/><em class="mn">// Example:</em><br/><em class="mn">//  Map([]int{1,2,3}, func(num int) int { return num+1 })</em><br/><em class="mn">//  Results: []int{2,3,4}</em><br/>func ParallelMap(source interface{}, transform interface{}) (interface{}, error) {<br/>    <em class="mn">// TODO:</em><br/>}</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="5089" class="kv kw it bd kx ky nj la lb lc nk le lf jz nl ka lh kc nm kd lj kf nn kg ll lm bi translated">1.确保源的类型</h1><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="421b" class="ms kw it lq b gy mt mu l mv mw">sourceV := reflect.ValueOf(source)<br/>kindOf := sourceV.Kind()<br/>if kindOf != reflect.Slice &amp;&amp; kindOf != reflect.Array {<br/>    return nil, errors.New("Source value is not an array")<br/>}</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="033e" class="kv kw it bd kx ky nj la lb lc nk le lf jz nl ka lh kc nm kd lj kf nn kg ll lm bi translated">2.确保<code class="fe ln lo lp lq b">Transform</code>不为零并且是一个函数</h1><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="7db6" class="ms kw it lq b gy mt mu l mv mw">if transform == nil {<br/>    return nil, errors.New("Transform function cannot be nil")<br/>}</span><span id="6d67" class="ms kw it lq b gy oc mu l mv mw">tv := reflect.ValueOf(transform)<br/>if tv.Kind() != reflect.Func {<br/>    return nil, errors.New("Transform argument must be a function")<br/>}</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="2641" class="kv kw it bd kx ky nj la lb lc nk le lf jz nl ka lh kc nm kd lj kf nn kg ll lm bi translated">3.准备结果容器</h1><p id="fe35" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里我们遇到一个困难:我们想制作结果容器，但是我们不知道结果的数组入口类型是什么。</p><p id="4322" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">调用者知道结果类型，所以我们将<code class="fe ln lo lp lq b">ParallelMap</code>函数签名改为:</p><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="d768" class="ms kw it lq b gy mt mu l mv mw">func ParallelMap(source interface{}, transform interface{}, T reflect.Type) (interface{}, error) {</span></pre><p id="d142" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">让我们添加一些验证并继续创建结果容器。</p><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="fe01" class="ms kw it lq b gy mt mu l mv mw">if T == nil {<br/>    return nil, errors.New("Map result type cannot be nil")<br/>}</span><span id="7ab9" class="ms kw it lq b gy oc mu l mv mw"><em class="mn">// kinda equivalent to = make([]T, srcV.Len())</em><br/>result := reflect.MakeSlice(reflect.SliceOf(T), srcV.Len(), srcV.Cap())</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="914a" class="kv kw it bd kx ky nj la lb lc nk le lf jz nl ka lh kc nm kd lj kf nn kg ll lm bi translated">4.形成循环</h1><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="b4dd" class="ms kw it lq b gy mt mu l mv mw"><em class="mn">// create a waitgroup with length = source array length</em><br/><em class="mn">// we'll reduce the counter each time an entry finished processing</em><br/>wg := &amp;sync.WaitGroup{}<br/>wg.Add(srcV.Len())</span><span id="5325" class="ms kw it lq b gy oc mu l mv mw"><em class="mn">// for each entry in source array</em><br/>for i := 0; i &lt; srcV.Len(); i++ {<br/>    <em class="mn">// one go routine for each entry</em><br/>    go func(idx int, entry reflect.Value) {<br/>        <em class="mn">//Call the transformation and store the result value</em><br/>        tfResults := tv.Call([]reflect.Value{entry})</span><span id="917b" class="ms kw it lq b gy oc mu l mv mw"><em class="mn">//Store the transformation result into array of result</em><br/>        resultEntry := result.Index(idx)<br/>        if len(tfResults) &gt; 0 {<br/>            resultEntry.Set(tfResults[0])<br/>        } else {<br/>            resultEntry.Set(reflect.Zero(T))<br/>        }</span><span id="6ecb" class="ms kw it lq b gy oc mu l mv mw"><em class="mn">//this go routine is done</em><br/>        wg.Done()<br/>    }(i, srcV.Index(i))<br/>}</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="e677" class="kv kw it bd kx ky nj la lb lc nk le lf jz nl ka lh kc nm kd lj kf nn kg ll lm bi translated">5.等待并返回</h1><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="53b2" class="ms kw it lq b gy mt mu l mv mw">wg.Wait()<br/>return result.Interface(), nil</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="6be1" class="kv kw it bd kx ky nj la lb lc nk le lf jz nl ka lh kc nm kd lj kf nn kg ll lm bi translated">6.将它们缝合在一起</h1><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="66c6" class="ms kw it lq b gy mt mu l mv mw"><em class="mn">// Map Error Collection</em><br/>var (<br/>    ErrMapSourceNotArray   = errors.New("Input value is not an array")<br/>    ErrMapTransformNil     = errors.New("Transform function cannot be nil")<br/>    ErrMapTransformNotFunc = errors.New("Transform argument must be a function")<br/>    ErrMapResultTypeNil    = errors.New("Map result type cannot be nil")<br/>)</span><span id="d02e" class="ms kw it lq b gy oc mu l mv mw"><em class="mn">// ParallelMap an array of something into another thing using go routine</em><br/><em class="mn">// Example:</em><br/><em class="mn">//  Map([]int{1,2,3}, func(num int) int { return num+1 }, reflect.Type(1))</em><br/><em class="mn">//  Results: []int{2,3,4}</em><br/>func ParallelMap(source interface{}, transform interface{}, T reflect.Type) (interface{}, error) {<br/>    srcV := reflect.ValueOf(source)<br/>    kind := srcV.Kind()<br/>    if kind != reflect.Slice &amp;&amp; kind != reflect.Array {<br/>        return nil, ErrMapSourceNotArray<br/>    }</span><span id="291b" class="ms kw it lq b gy oc mu l mv mw">if transform == nil {<br/>        return nil, ErrMapTransformNil<br/>    }</span><span id="e8cf" class="ms kw it lq b gy oc mu l mv mw">tv := reflect.ValueOf(transform)<br/>    if tv.Kind() != reflect.Func {<br/>        return nil, ErrMapTransformNotFunc<br/>    }</span><span id="d19b" class="ms kw it lq b gy oc mu l mv mw">if T == nil {<br/>        return nil, ErrMapResultTypeNil<br/>    }</span><span id="72ea" class="ms kw it lq b gy oc mu l mv mw"><em class="mn">// kinda equivalent to = make([]T, srcv.Len())</em><br/>    result := reflect.MakeSlice(reflect.SliceOf(T), srcV.Len(), srcV.Cap())</span><span id="a461" class="ms kw it lq b gy oc mu l mv mw"><em class="mn">// create a waitgroup with length = source array length</em><br/>    <em class="mn">// we'll reduce the counter each time an entry finished processing</em><br/>    wg := &amp;sync.WaitGroup{}<br/>    wg.Add(srcV.Len())<br/>    for i := 0; i &lt; srcV.Len(); i++ {<br/>        <em class="mn">// one go routine for each entry</em><br/>        go func(idx int, entry reflect.Value) {<br/>            <em class="mn">//Call the transformation and store the result value</em><br/>            tfResults := tv.Call([]reflect.Value{entry})</span><span id="0ec9" class="ms kw it lq b gy oc mu l mv mw"><em class="mn">//Store the transformation result into array of result</em><br/>            resultEntry := result.Index(idx)<br/>            if len(tfResults) &gt; 0 {<br/>                resultEntry.Set(tfResults[0])<br/>            } else {<br/>                resultEntry.Set(reflect.Zero(T))<br/>            }</span><span id="f9cd" class="ms kw it lq b gy oc mu l mv mw"><em class="mn">//this go routine is done</em><br/>            wg.Done()<br/>        }(i, srcV.Index(i))<br/>    }</span><span id="3e33" class="ms kw it lq b gy oc mu l mv mw">wg.Wait()<br/>    return result.Interface(), nil<br/>}</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="cfa8" class="kv kw it bd kx ky nj la lb lc nk le lf jz nl ka lh kc nm kd lj kf nn kg ll lm bi translated">通过单元测试确保“ParallelMap”行为</h1><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="3f91" class="ms kw it lq b gy mt mu l mv mw">func TestParallelMap(t *testing.T) {<br/>    type args struct {<br/>        arr       interface{}<br/>        transform interface{}<br/>        t         reflect.Type<br/>    }<br/>    tests := []struct {<br/>        name    string<br/>        args    args<br/>        want    interface{}<br/>        wantErr bool<br/>    }{<br/>        {<br/>            name:    "Argument is not an array",<br/>            args:    args{arr: 1, transform: nil, t: nil},<br/>            want:    nil,<br/>            wantErr: true,<br/>        },<br/>        {<br/>            name:    "Transform function is nil",<br/>            args:    args{arr: []int{1, 2, 3}, transform: nil, t: nil},<br/>            want:    nil,<br/>            wantErr: true,<br/>        },<br/>        {<br/>            name:    "Transform is not a function",<br/>            args:    args{arr: []int{1, 2, 3}, transform: 1, t: nil},<br/>            want:    nil,<br/>            wantErr: true,<br/>        },<br/>        {<br/>            name:    "T is not supplied",<br/>            args:    args{arr: []int{1, 2, 3}, transform: 1, t: nil},<br/>            want:    nil,<br/>            wantErr: true,<br/>        },<br/>        {<br/>            name: "Valid transform",<br/>            args: args{arr: []int{1, 2, 3}, transform: func(num int) int {<br/>                return num + 1<br/>            }, t: reflect.TypeOf(1)},<br/>            want:    []int{2, 3, 4},<br/>            wantErr: false,<br/>        },<br/>        {<br/>            name: "Valid transform",<br/>            args: args{arr: []int{1, 2, 3}, transform: func(num int) string {<br/>                return strconv.Itoa(num)<br/>            }, t: reflect.TypeOf("")},<br/>            want:    []string{"1", "2", "3"},<br/>            wantErr: false,<br/>        },<br/>    }<br/>    for _, tt := range tests {<br/>        t.Run(tt.name, func(t *testing.T) {<br/>            got, err := ParallelMap(tt.args.arr, tt.args.transform, tt.args.t)<br/>            if (err != nil) != tt.wantErr {<br/>                t.Errorf("Map() error = %v, wantErr %v", err, tt.wantErr)<br/>                return<br/>            }<br/>            if !reflect.DeepEqual(got, tt.want) {<br/>                t.Errorf("Map() = %v, want %v", got, tt.want)<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="4fa0" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">测试结果表明:</p><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="11ce" class="ms kw it lq b gy mt mu l mv mw">Running tool: /usr/local/opt/go/libexec/bin/go test -timeout 30s github.com/bastianrob/arrayutil -run ^(TestParallelMap)$</span><span id="80fb" class="ms kw it lq b gy oc mu l mv mw">ok      github.com/bastianrob/arrayutil    0.005s<br/>Success: Tests passed.</span></pre><h1 id="c92a" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">情况如何？</h1><p id="f77c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">嗯，代码实际上仍然是一种命令式风格，包装在使用<code class="fe ln lo lp lq b">goroutine</code>实现并发的<code class="fe ln lo lp lq b">ParallelMap</code>函数中。(也许我们应该改名叫<code class="fe ln lo lp lq b">ConcurrentMap</code>？)</p><p id="f56e" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">但是这和这篇荒谬文章开头的假想情况相比如何呢？让我们来测试一下:</p><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="5a6f" class="ms kw it lq b gy mt mu l mv mw">func BenchmarkParallelMap(b *testing.B) {<br/>    source := [100]int{}<br/>    for i := 0; i &lt; len(source); i++ {<br/>        source[i] = i + 1<br/>    }<br/>    transf := func(num int) int {<br/>        <em class="mn">//fake, long running operations</em><br/>        time.Sleep(20 * time.Millisecond)<br/>        return num + 1<br/>    }</span><span id="3c06" class="ms kw it lq b gy oc mu l mv mw">b.ResetTimer()<br/>    for n := 0; n &lt; b.N; n++ {<br/>        ParallelMap(source, transf, reflect.TypeOf(1))<br/>    }<br/>}</span><span id="014c" class="ms kw it lq b gy oc mu l mv mw">func BenchmarkImperative(b *testing.B) {<br/>    source := [100]int{}<br/>    for i := 0; i &lt; len(source); i++ {<br/>        source[i] = i + 1<br/>    }<br/>    transf := func(num int) int {<br/>        <em class="mn">//fake, long running operations</em><br/>        time.Sleep(20 * time.Millisecond)<br/>        return num + 1<br/>    }</span><span id="498a" class="ms kw it lq b gy oc mu l mv mw">b.ResetTimer()<br/>    for n := 0; n &lt; b.N; n++ {<br/>        for _, num := range source {<br/>            transf(num)<br/>        }<br/>    }<br/>}</span></pre><p id="39e1" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe ln lo lp lq b">Benchmark</code>结果显示:</p><pre class="kj kk kl km gt mo lq mp mq aw mr bi"><span id="9bf3" class="ms kw it lq b gy mt mu l mv mw">BenchmarkParallelMap            100      22908438 ns/op       13801 B/op         305 allocs/op<br/>PASS<br/>ok      github.com/bastianrob/arrayutil    2.321s<br/>Success: Benchmarks passed.</span><span id="a349" class="ms kw it lq b gy oc mu l mv mw">BenchmarkImperative               1      2251692199 ns/op      1240 B/op           7 allocs/op<br/>PASS<br/>ok      github.com/bastianrob/arrayutil    2.258s<br/>Success: Benchmarks passed.</span></pre><p id="3dd6" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们可以完成100个<code class="fe ln lo lp lq b">ParallelMap</code>，而标准的命令式只能完成一个。</p><p id="34dc" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">这些你都可以在我的<a class="ae ku" href="https://github.com/bastianrob/go-experiences/tree/master/parallelmap" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>