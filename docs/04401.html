<html>
<head>
<title>Build Your Own Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您自己的地图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-own-map-b9a0c9d6fbab?source=collection_archive---------6-----------------------#2020-04-10">https://betterprogramming.pub/build-your-own-map-b9a0c9d6fbab?source=collection_archive---------6-----------------------#2020-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为了更好地理解它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/148d3fb3d0c682ddaba0883267676e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N3uMMhGVKV65xNdX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@dead____artist?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">捕捉人心的照片。</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>。</p></figure><p id="05de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射是使用映射器函数将元素数组转换为新数组的过程。它形成了一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Many-to-many_(data_model)" rel="noopener ugc nofollow" target="_blank">多对多关联</a>，并且您将获得与您最初提供的数据长度相同的数据。</p><p id="a5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看下图。它使用带有<a class="ae ky" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">声明性方法</a>的映射过程。我们并不指定<em class="lv">如何</em>进行映射，而是<em class="lv">用<strong class="lb iu"> </strong>做什么。我们只是提供了[🥔,🌽,🥚]和映射器函数<code class="fe lw lx ly lz b">cook</code>，让<code class="fe lw lx ly lz b">map</code>处理对它们的迭代，并对每个函数应用映射器函数。最后，它将返回新的数组[🍟,🍿,🍳].</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/dc295a2c27ad544b0c97639d1e3cd205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zDZIH4Enyrhyx3NC.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片(灵感来自<a class="ae ky" href="https://overflowjs.com" rel="noopener ugc nofollow" target="_blank"> Overflowjs </a>)。</p></figure><p id="a405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到映射，我们有几个选择(声明式和命令式方法)。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ccb8" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">For循环</h1><p id="e3bd" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们可以使用简单的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener ugc nofollow" target="_blank"> for循环</a>来迭代数组元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，索引跟踪、初始化以及将结果推送到数组的工作由我们来完成。这是<a class="ae ky" href="https://en.wikipedia.org/wiki/Imperative_programming" rel="noopener ugc nofollow" target="_blank">命令式编程</a>的一个明显例子，它告诉计算机我们想要如何使用一步一步的过程来实现某件事情。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="a864" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">为每一个</h1><p id="0d63" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">另一个选项是<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank"> forEach </a>，它遍历数组中的每个元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ab2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感觉好点了，对吧？我们不再需要跟踪元素索引。但是我们同意在函数范围之外改变一个项目，在这个例子中是<code class="fe lw lx ly lz b">result</code>，是不理想的。如果我们能进一步抽象这一点，那就太好了。</p><p id="d3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原生JavaScript映射是更好的选择。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="eb7a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">原生JS映射</h1><p id="5295" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们用JavaScript的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">原生映射方法</a>。我们需要的只是一个数据数组和一个映射函数。将获得一个数组，并迭代数组中的每个元素，同时对它们应用映射函数。最后，这将返回一个长度相同的转换后的数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就可读性而言，这比像forEach 的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">或loop </a>的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener ugc nofollow" target="_blank">要好得多。然而，</a><a class="ae ky" href="https://github.com/dg92/Performance-Analysis-JS" rel="noopener ugc nofollow" target="_blank">性能</a>是决定选择哪个选项的一个非常关键的因素。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ccb1" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">构建映射函数</h1><p id="78fe" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">现在到了有趣的部分。您知道构建一个映射函数并没有那么难吗？让我们来看看实际情况。</p><h2 id="caac" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">自带地图功能(用于循环版本)</h2><p id="69d6" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在这个例子中，我们抽象出索引跟踪并初始化一个起始数组。我们需要传递的只是一个映射函数和一个项目数组，我们已经准备好了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="895a" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">自带地图功能(递归版本)</h2><p id="ddbd" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">构建map函数的递归版本是一件有趣的事情。但是它是如何工作的呢？</p><p id="ca88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们仍然将映射器函数和数组传递给该函数，但是我们使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> ES6析构赋值</a>将数组分成两个参数，称为<code class="fe lw lx ly lz b">head</code>和<code class="fe lw lx ly lz b">tail</code>。</p><p id="6503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，我们希望采取一步一步的方法，递归地对每个数组元素执行映射函数。在这个过程中，我们使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展语法</a>将每个<code class="fe lw lx ly lz b">MapRecursive</code>调用的结果与映射的<code class="fe lw lx ly lz b">fn(head)</code>的结果连接起来。</p><p id="979b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一直持续到<code class="fe lw lx ly lz b">head</code>变成<code class="fe lw lx ly lz b">undefined</code>，意味着数组中不再有元素。这时我们从<code class="fe lw lx ly lz b">line 8</code>上显示的递归函数中退出，然后开始返回新的转换后的数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="cde0" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">自带地图功能(生成器版本)</h2><p id="748c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">你也可以使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">生成器函数</a>来构建一个地图函数。这不是处理映射的理想方式，并且不能给出与前面例子相同的结果，因为生成器函数返回一个迭代器对象。这仅仅是教育性的，也是为了看看类似的概念如何应用于生成器函数。</p><p id="cb86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面的评论部分看到调用<code class="fe lw lx ly lz b">MapGenerator</code>的最终结果是什么样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="e8b4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">参考</h1><ul class=""><li id="40e6" class="nt nu it lb b lc na lf nb li nv lm nw lq nx lu ny nz oa ob bi translated"><a class="ae ky" href="https://www.freecodecamp.org/news/implement-array-map-with-recursion-35976d0325b2/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/implement-array-map-with-recursion-35976d 0325 b 2/</a></li><li id="3a00" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><a class="ae ky" href="https://www.digitalocean.com/community/tutorials/list-processing-with-map-filter-and-reduce" rel="noopener ugc nofollow" target="_blank">https://www . digital ocean . com/community/tutorials/list-processing-with-map-filter-and-reduce</a></li></ul></div></div>    
</body>
</html>