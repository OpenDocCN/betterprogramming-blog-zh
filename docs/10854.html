<html>
<head>
<title>The Most Efficient Way to Write Enumerations in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript编写枚举的最有效方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-most-efficient-way-to-write-enumerations-in-javascript-a1b9f41ea651?source=collection_archive---------12-----------------------#2022-01-31">https://betterprogramming.pub/the-most-efficient-way-to-write-enumerations-in-javascript-a1b9f41ea651?source=collection_archive---------12-----------------------#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我从Vue源代码中学到的一个技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/57645f5ab41bf39a925f6720380c711f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*56ovgzi56Wq33-5p"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@joeyc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔·凯恩</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript语言本身不支持枚举。如果我们想模拟枚举，我们可以使用一个对象。</p><p id="3016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设有这样一个场景，我们需要统计员工的技术栈，目前需要标注的技术有CSS、JavaScript、HTML、WebGL。</p><p id="5cf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我可以这样写枚举:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cb98" class="ma mb it lw b gy mc md l me mf">const SKILLS = {<br/>  CSS: 1 ,<br/>  JS: 2,<br/>  HTML: 3,<br/>  WEB_GL: 4<br/>}</span></pre><p id="f061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前是这样写的，但是最近看Vue源代码的时候发现了一个高效使用枚举的窍门，在这里分享给大家。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4ac1" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">定义枚举</h1><p id="a541" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们可以这样写上面的枚举:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2cb0" class="ma mb it lw b gy mc md l me mf">const SKILLS = {<br/>  CSS: 1 ,<br/>  JS: 1 &lt;&lt; 1,<br/>  HTML: 1 &lt;&lt; 2,<br/>  WEB_GL: 1 &lt;&lt; 3<br/>}</span></pre><h2 id="2f9a" class="ma mb it bd mo nj nk dn ms nl nm dp mw li nn no my lm np nq na lq nr ns nc nt bi translated">什么是&lt;&lt; ?</h2><p id="d87e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">The <strong class="lb iu">左移运算符(</strong> <code class="fe nu nv nw lw b"><strong class="lb iu">&lt;&lt;</strong></code> <strong class="lb iu"> ) </strong>将第一个操作数左移指定的位数。向左移位的多余比特被丢弃。零比特从右边移入。</p><p id="62ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><ul class=""><li id="ff98" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">二进制的<code class="fe nu nv nw lw b">1</code>是<code class="fe nu nv nw lw b">0000 0001</code>，左移一位是<code class="fe nu nv nw lw b">0000 0010</code>，十进制是2。</li><li id="95c8" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">如果我们将它移动两位，它将变成<code class="fe nu nv nw lw b">0000 0100</code>，十进制的4。</li><li id="1058" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">如果我们把它移位三位，就会变成<code class="fe nu nv nw lw b">0000 1000</code>，十进制是8。</li><li id="16f7" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">如果我们把它移位N位，它将变成十进制的<code class="fe nu nv nw lw b">2^N</code>。</li></ul><h1 id="4392" class="mn mb it bd mo mp ol mr ms mt om mv mw jz on ka my kc oo kd na kf op kg nc nd bi translated">使用</h1><p id="69d7" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">按照上述方法定义枚举后，我们可以这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/9dc27536ffcf4265d81e6e81d6153286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UyGbTCZS9UjZfphvQtaOmA.png"/></div></div></figure><p id="866e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:<code class="fe nu nv nw lw b">|</code>是按位OR运算符，它在每个位位置返回一个<code class="fe nu nv nw lw b">1</code>，其中一个或两个操作数的对应位是<code class="fe nu nv nw lw b">1</code></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4717" class="ma mb it lw b gy mc md l me mf">const a = 5;        // 00000000000000000000000000000101<br/>const b = 3;        // 00000000000000000000000000000011</span><span id="ac21" class="ma mb it lw b gy ot md l me mf">console.log(a | b); // 00000000000000000000000000000111<br/>// expected output: 7</span></pre><h1 id="23dd" class="mn mb it bd mo mp ol mr ms mt om mv mw jz on ka my kc oo kd na kf op kg nc nd bi translated">这个代码怎么理解？</h1><p id="6e4b" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在JavaScript中，整数存储在4个字节中，也就是32位。第一个代表正负，后面31个代表数字。</p><p id="7405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们用二进制表示<code class="fe nu nv nw lw b">1</code>、<code class="fe nu nv nw lw b">1 &lt;&lt; 2</code>时，它们看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/e7068a24bd925e1aa8d9827d61d6ad2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wK8BzZ2e1SoEJez_1gwSQg.png"/></div></div></figure><p id="e137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义的enum变量只有一个二进制格式的<code class="fe nu nv nw lw b">1</code>，并且占据不同的位置。</p><p id="b4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们给技能添加枚举选项时，我们使用<code class="fe nu nv nw lw b">skills | skill</code>。假设现在我们需要添加的技能是<code class="fe nu nv nw lw b">SKILLS.CSS</code>，那么在执行过程中，它是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/a7fa6c4670db1bfa9d3bf8fde181a631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-C6eLBEY6ppUWNAk56gug.png"/></div></div></figure><p id="6a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以发现在<code class="fe nu nv nw lw b">skills</code>中，<code class="fe nu nv nw lw b">SKILLS.CSS</code>对应的位置会变成1。</p><p id="6b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反之，那么我们就可以通过检查<code class="fe nu nv nw lw b">skills &amp; SKILLS.CSS</code>的结果是否为0来判断<code class="fe nu nv nw lw b">skills</code>中是否存在<code class="fe nu nv nw lw b">SKILLS.CSS</code>。</p><p id="be4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ow">对了，在这里我们还可以发现这一招有一个缺点，就是枚举项不能超过31。</em></p><h1 id="c5b9" class="mn mb it bd mo mp ol mr ms mt om mv mw jz on ka my kc oo kd na kf op kg nc nd bi translated">为什么要用这一招？</h1><p id="5212" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">答案很简单，这样的代码运行起来更高效。CPU里有直接对应位操作的指令，所以效率更高。</p><p id="7590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以做一个性能测试。</p><p id="5bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不使用位运算，而是使用传统方法(数组或映射)来实现，那么代码如下。</p><p id="0c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按阵列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="db38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过地图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="beb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe nu nv nw lw b"><a class="ae ky" href="https://jsbench.me/" rel="noopener ugc nofollow" target="_blank">jsbench.me</a></code>的性能测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/1cdea559c911025f3f7db8d291430cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*enO82AMcZqQaQWSESe5WZg.png"/></div></div></figure><p id="2a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用按位枚举，性能会显著提高。</p><h1 id="bf28" class="mn mb it bd mo mp ol mr ms mt om mv mw jz on ka my kc oo kd na kf op kg nc nd bi translated">从Vue源代码中学习</h1><p id="ae5e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我是从Vue源码里学的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ad43" class="ma mb it lw b gy mc md l me mf">export const enum ShapeFlags {<br/>  ELEMENT = 1,<br/>  FUNCTIONAL_COMPONENT = 1 &lt;&lt; 1,<br/>  STATEFUL_COMPONENT = 1 &lt;&lt; 2,<br/>  TEXT_CHILDREN = 1 &lt;&lt; 3,<br/>  ARRAY_CHILDREN = 1 &lt;&lt; 4,<br/>  SLOTS_CHILDREN = 1 &lt;&lt; 5,<br/>  TELEPORT = 1 &lt;&lt; 6,<br/>  SUSPENSE = 1 &lt;&lt; 7,<br/>  COMPONENT_SHOULD_KEEP_ALIVE = 1 &lt;&lt; 8,<br/>  COMPONENT_KEPT_ALIVE = 1 &lt;&lt; 9,<br/>  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT<br/>}</span></pre><p id="f994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github1s.com/vuejs/core/blob/HEAD/packages/shared/src/shapeFlags.ts" rel="noopener ugc nofollow" target="_blank">https://github 1s . com/vuejs/core/blob/HEAD/packages/shared/src/shape flags . ts</a></p><p id="92ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次看这段代码的时候，我有点疑惑，但最后还是想通了。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="e29c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这一招对你有帮助。感谢阅读。</p></div></div>    
</body>
</html>