<html>
<head>
<title>Designing an NFT Smart Contract for Flexible Minting and Claiming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为灵活的铸造和索赔设计NFT智能合同</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/designing-an-nft-smart-contract-for-flexible-minting-and-claiming-5b420a9a2d82?source=collection_archive---------6-----------------------#2022-01-27">https://betterprogramming.pub/designing-an-nft-smart-contract-for-flexible-minting-and-claiming-5b420a9a2d82?source=collection_archive---------6-----------------------#2022-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b55b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们也没有汽油了。了解我们为什么以及如何优化它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/372ccc9edd6821a0d0fc2504abd77035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zf8P5S_fmjOLrL0xvFzt5g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><p id="433a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有问题的智能合同是我们为NFT人开发的。这个项目本质上是一个艺术项目——旨在探索合作，以及一个社区，而不仅仅是为他们，如何创造一个NFT系列。</p><p id="4b05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的智能合约需要考虑各种不同的铸造需求，以涵盖我们项目的各种元素，我们将在下面详细探讨。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/12f3bcbac9c55c8c1c8d287944961aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfuPEp38OfE2cRpMAnruag.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">1500个人中的每一个人都有一份由社区成员贡献的手写简历。</p></figure><p id="0c11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章是我们探索合同实现的系列文章中的第一篇——它通常是为那些对我们的技术方法感兴趣的人准备的，但将以这样一种方式撰写，希望即使是不太懂技术的人也能从中学习一些东西。</p><p id="f7f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们深入技术内容之前，让我们提供一些背景信息，说明为什么该合同需要这么多功能:</p><ul class=""><li id="d0ef" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">我们的创世纪系列(由229个人组成)是使用Opensea的ERC1155共享合同铸造的。我们希望使用自己的ERC721契约，通过刻录原始令牌并在契约中捕获它们，将旧集合合并到新集合中。</li><li id="9490" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">我们的作者计划中的作者因提交了bios(“传记”的简称，即一个背景故事)给我们人类。我们需要给他们一种方法来认领他们的人类，而不用付钱给造币厂。每个作者根据他们提交的简历的数量获得不同数量的薄荷糖。</li><li id="9614" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">需要为使用钱包地址的个人保留35个设置了令牌id的荣誉人(自定义一对一)。</li><li id="d830" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">我们有一个预售列表，希望控制谁可以访问，并限制可以铸造的令牌数量。</li><li id="91b6" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">我们的公开销售对所有人开放，但我们想限制每笔交易和每个地址的薄荷糖数量。</li></ul><p id="f8c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，但肯定不是最不重要的，我们想利用随机铸造策略。许多项目在随机化元数据时利用起源散列作为种子。我们只是在造币厂上线之前透露了元数据。这有三个主要目的:</p><ol class=""><li id="e5f1" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr mh lz ma mb bi translated">我们想在造币活动之前展示我们的整个系列。我们已经被过度宣传的薄荷糖烧伤太多次了，在展示后产生真正令人失望的艺术品，所以我们想向我们的社区展示他们到底得到了什么。</li><li id="9c4e" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr mh lz ma mb bi translated">我们希望这个过程尽可能的公平和透明，取消团队铸造精选或稀有令牌的选项。我们和其他人一样有机会。</li><li id="4afd" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr mh lz ma mb bi translated">我们想规避揭露的需要，以消除狙击的可能性，并确保收集不会在未揭露的默默无闻中憔悴，如果我们不薄荷了。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/bc3dd6d0025fec94843e1669af86abd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZzZdmAPsdV3j2I3YRQA8g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在造币活动前浏览该系列</p></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="9db5" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated"><strong class="ak">一份重要的免责声明</strong></h2><p id="cfb7" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在继续之前，我想提醒一下这篇文章，我不是可靠性专家。我做了很多年的开发人员，从事过各种各样非常不同的项目，但这是我部署到以太坊Mainnet的第一个智能合同，所以这是NDA(不是开发人员的建议)。</p><p id="7728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很幸运有一些非常聪明的人在我前进的道路上帮助我。我只是想借此机会分享我的思考过程和我们做出某些决定的原因，希望它可以帮助甚至一个人开始他们自己的NFT项目，因为如果没有向其他人学习，我不可能做到这一点，他们非常慷慨地分享了他们的经验。有很多很棒的资源，我会在这篇文章的底部链接一些我用过的资源。</p><p id="9af8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在通读本指南时需要参考代码，可以在Etherscan上找到我们的验证合同:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="c670" class="mq mr iq np b gy nt nu l nv nw"><a class="ae kv" href="https://etherscan.io/address/0x8575B2Dbbd7608A1629aDAA952abA74Bcc53d22A#code" rel="noopener ugc nofollow" target="_blank">https://etherscan.io/address/0x8575B2Dbbd7608A1629aDAA952abA74Bcc53d22A#code</a></span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="0f7a" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated"><strong class="ak">造币时随机分配令牌ID</strong></h2><p id="3c78" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">值得一提的是，这种策略采用了伪随机数生成的方法。“正确地”做到这一点需要使用类似Chainlink的VRF(可验证的随机函数)<a class="ae kv" href="https://docs.chain.link/docs/chainlink-vrf/" rel="noopener ugc nofollow" target="_blank"> (1) </a>的东西。</p><p id="d456" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们做了一个有根据的假设，我们相对不为人知的小收藏(1500个)和它的低铸币价格(0.025 Eth)很少或没有激励人们想出一个复杂的方法来尝试和利用它。</p><p id="335a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，利用像VRF这样的方法会使我们的造币过程过于昂贵。在做了大量的研究和阅读了无数的论坛帖子后，我偶然发现了一些ERC721的1001-digital <a class="ae kv" href="https://github.com/1001-digital/erc721-extensions" rel="noopener ugc nofollow" target="_blank"> (2) </a>扩展，它们涵盖了随机令牌分配。</p><p id="7e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们来说,<code class="fe nx ny nz np b">RandomlyAssigned</code>扩展并不是现成的，因为我们需要在已知id和随机id之间“分割”集合(我们将很快对此进行解释)。</p><p id="f1d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与此同时，您可以从构造函数中看到,“人类”契约继承自扩展，还有其他一些契约:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="9152" class="mq mr iq np b gy nt nu l nv nw">constructor(<br/>  string memory uri,<br/>  address adminSigner,<br/>  address openseaAddress<br/> )<br/>  ERC721('Humans Of NFT', 'HUMAN')<br/>  RandomlyAssigned(<br/>   MAX_HUMANS_SUPPLY,<br/>   NUMBER_OF_GENESIS_HUMANS + NUMBER_OF_RESERVED_HUMANS<br/>  )<br/> {<br/>  _defaultUri = uri;<br/>  _adminSigner = adminSigner;<br/>  _openseaSharedContractAddress = openseaAddress;<br/> }</span></pre><p id="2c17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nx ny nz np b">RandomlyAssigned</code>构造函数现在接受两个参数:</p><ul class=""><li id="7288" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">集合的总大小(<code class="fe nx ny nz np b">MAX_HUMANS_SUPPLY</code>)</li><li id="af7e" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">开始随机令牌ID分配的索引(<code class="fe nx ny nz np b">NUMBER_OF_GENESIS_HUMANS + NUMBER_OF_RESERVED_HUMANS )</code>)。</li></ul><p id="ced8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们的Genesis集合中有229个人，所以我们想为burn-to-claim机制保留令牌id<code class="fe nx ny nz np b">1–229</code>。换句话说，Genesis ID #1的所有者应该在新的集合中接收ID #1(即替换令牌)。</p><p id="d252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们为特定的地址保留令牌ID<code class="fe nx ny nz np b">230-264</code>,这样收到荣誉令牌的个人就可以使用预先确定的ID来认领他们的人类。</p><p id="c8ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就在<code class="fe nx ny nz np b">265-1500</code>之间留下了一个应该随机分布的令牌id池，我们可以从<code class="fe nx ny nz np b">RandomlyAssigned</code>构造函数中看到:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="1655" class="mq mr iq np b gy nt nu l nv nw">// RandomlyAssigned.sol</span><span id="25ce" class="mq mr iq np b gy oa nu l nv nw">constructor(uint256 maxSupply_, uint256 numReserved_)<br/>  WithLimitedSupply(maxSupply_, numReserved_)<br/> {<br/>  startFrom = numReserved_ + 1;<br/> }</span></pre><p id="b7e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nx ny nz np b">maxSupply_</code> arg不在<code class="fe nx ny nz np b">RandomlyAssigned</code>契约中使用，而是传递给它所继承的<code class="fe nx ny nz np b">WithLimitedSupply</code>契约。</p><p id="c256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际的随机化使用了一种流行的生成伪随机数的方法(显然我不认为这是我的功劳)，该方法从使用特定于块的数据以及函数调用方地址(<code class="fe nx ny nz np b">msg.sender</code>)生成的散列中转换出一个<code class="fe nx ny nz np b">uint256</code>。</p><p id="91f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，它将结果存储在一个<code class="fe nx ny nz np b">tokenMatrix</code>映射中，该映射存储了哪些id已经被使用:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="76e8" class="mq mr iq np b gy nt nu l nv nw">function nextToken() internal override returns (uint256) {<br/>  uint256 maxIndex = maxAvailableSupply() - tokenCount();<br/>  uint256 random = uint256(<br/>   keccak256(<br/>    abi.encodePacked(<br/>     msg.sender,<br/>     block.coinbase,<br/>     block.difficulty,<br/>     block.gaslimit,<br/>     block.timestamp<br/>    )<br/>   )<br/>  ) % maxIndex;</span><span id="d43a" class="mq mr iq np b gy oa nu l nv nw">  ...</span><span id="6458" class="mq mr iq np b gy oa nu l nv nw">  return value + startFrom;</span><span id="58d2" class="mq mr iq np b gy oa nu l nv nw">}</span></pre><p id="2d2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nx ny nz np b">maxIndex</code>是可从可用池中分配的最大可能ID。<code class="fe nx ny nz np b">maxAvailableSupply()</code>返回池中id的数量(即<code class="fe nx ny nz np b">1500 — 229 — 35 = 1236</code>)，并且<code class="fe nx ny nz np b">tokenCount()</code>返回已经从池中铸造的代币的数量。</p><p id="4b13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们已经铸造了150个带有随机id的代币，那么<code class="fe nx ny nz np b">maxIndex = 1236 — 150</code>，也就是<code class="fe nx ny nz np b">1086</code>，因此我们的<code class="fe nx ny nz np b">maxIndex</code>是1086。我们将使用<code class="fe nx ny nz np b">keccak256</code>算法生成的散列转换为<code class="fe nx ny nz np b">uint256</code>，然后将<strong class="ky ir">模运算(% ) </strong>产生的余数除以<code class="fe nx ny nz np b">maxIndex</code>(它总是产生一个小于<code class="fe nx ny nz np b">maxIndex</code>的整数)。</p><p id="8503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还记得在<code class="fe nx ny nz np b">RandomlyAssigned</code>构造函数中，我们将<code class="fe nx ny nz np b">startFrom</code>变量设置为等于我们保留的令牌数(即创世纪令牌+荣誉)+ 1。</p><p id="bcda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当我们最终返回新的随机令牌ID时，它落在范围<code class="fe nx ny nz np b">229 &lt; random_id &lt;= 1500</code>内。</p><p id="9735" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到契约本身，可用的令牌池在<code class="fe nx ny nz np b">WithLimitedSupply</code>构造函数中设置:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="344d" class="mq mr iq np b gy nt nu l nv nw">constructor(uint256 maxSupply_, uint256 reserved_) {<br/>  _maxAvailableSupply = maxSupply_ - reserved_;<br/> }</span></pre><p id="5c00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，mint函数的每个变体都利用一个修饰符来检查所请求的令牌数是否在随机ID池中剩余的可用令牌数的限制范围内，以防止任何人铸造超出所需范围的ID。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="056c" class="mq mr iq np b gy nt nu l nv nw"> /// <a class="ae kv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> amount Check whether number of tokens are still available<br/> /// <a class="ae kv" href="http://twitter.com/dev" rel="noopener ugc nofollow" target="_blank">@dev</a> Check whether tokens are still available<br/> modifier ensureAvailabilityFor(uint256 amount) {<br/>  require(<br/>   availableTokenCount() &gt;= amount,<br/>   'Requested number of tokens not available'<br/>  );<br/>  _;<br/> }</span></pre><p id="7950" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在主合同中，我们有一个名为<code class="fe nx ny nz np b">_mintRandomId()</code>的便利函数，它负责生成一个随机ID，并将选择的令牌铸造到提供的地址。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="dc6a" class="mq mr iq np b gy nt nu l nv nw">/// @dev internal check to ensure a genesis token ID, or ID outside of the collection, doesn't get minted<br/>function _mintRandomId(address to) private {<br/>  uint256 id = nextToken();<br/>  assert(<br/>    id &gt; NUMBER_OF_GENESIS_HUMANS + NUMBER_OF_RESERVED_HUMANS &amp;&amp;<br/>    id &lt;= MAX_HUMANS_SUPPLY<br/>);<br/>   _safeMint(to, id);<br/>}</span></pre><p id="1965" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，这种方法相对简单——我们承认这不是一个防弹的解决方案，但我们可以很高兴地说，它像预期的那样工作，我们为我们推出该系列的不泄露方法感到自豪。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="44be" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated"><strong class="ak">一些意想不到的后果</strong></h2><p id="acc2" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">感谢我们在最终部署到<code class="fe nx ny nz np b">mainnet</code>之前进行了一系列测试，合同完全按照我们的预期运行。我们对我们采取的方法感到自豪，并且一切(大部分)进展顺利。</p><p id="f13a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在mint的经历中，我们确实经历了两个小问题，不幸的是，这两个问题本来是可以避免的，但是我们把它们作为经验教训。这两个问题都不是由合同中的缺陷引起的，而是由我们的mint网站前端的一些有缺陷的逻辑引起的。</p><p id="1aa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管我们在本地环境和testnets上进行了所有的测试，但直到我们在mainnet上开展预售活动时，我们才遇到这个特殊的问题。我们开始收到一些用户的报告，称他们的交易失败是因为汽油用完了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/bfa187eb890dec21d97588c95a7b2723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQb5tUgCNQTfYpDfwsxJLQ.png"/></div></div></figure><p id="2d1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在做了一些初步调查之后(尽管有点惊慌)，我们确定Metamask在估计一些(但不是所有)事务的gas限制方面做得非常差。</p><p id="16cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们仍然不能100%确定为什么会这样，但我在这个阶段的假设是，这至少部分是由于令牌id的随机化。无论哪种方式，这都是一个相对简单的修复，只需要在前端部署一个小补丁。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="b465" class="mq mr iq np b gy nt nu l nv nw">const GAS_LIMIT_PER: number = 200000;</span><span id="a02c" class="mq mr iq np b gy oa nu l nv nw">...</span><span id="bdda" class="mq mr iq np b gy oa nu l nv nw">mintPresale(<br/>  qty: number, <br/>  priceInEth: number, <br/>  coupon: String<br/>) <br/>{<br/>  const mintPriceBn = utils.parseEther(priceInEth.toString());<br/>  return this.contract.mintPresale(qty, coupon, {<br/>    value: mintPriceBn.mul(qty),<br/>    gasLimit: GAS_LIMIT_PER * qty,<br/>  });<br/>}</span></pre><p id="073b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码片段显示了我们实现的简单修复，它涉及到根据铸造的令牌数量为每笔交易手动设置<code class="fe nx ny nz np b">gasLimit</code>。</p><p id="be3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应该注意的是，我们严重高估了限额，这导致了更高的天然气估计值，但实际交易使用的天然气要少得多。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/f547186162ed423294347fe0552bfa21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbJjeiwsjaChqvX6n0wTgg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预售期间铸造1枚代币时的用气量</p></figure><p id="d4ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个问题稍微“严重”一些。事实是，这只是一个疏忽，是我们的业余错误。回过头来看，我认为这是我们错过的东西，因为我们根本没有考虑到系列销售如此之快的情况。</p><p id="3e5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们真的希望这个系列需要几天才能完成，更不用说在一分钟之内完成，所以在这种情况下，我们根本没有想过要投入资金。</p><p id="39d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，事后看来，这是一个愚蠢的错误，因为人们确实应该考虑所有的情况。我们的错误是，如果<code class="fe nx ny nz np b">availableTokenCount()</code>返回<code class="fe nx ny nz np b">0</code>，我们没有阻止用户调用mint函数。</p><p id="e526" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，用户界面引用了不正确的变量，导致显示给用户的电源在达到零时重置。这样做的结果是，许多人继续尝试铸造，即使没有更多的代币可用。</p><p id="e6f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如预期的那样，合同恢复了交易，因为包含了<code class="fe nx ny nz np b">ensureAvailabilityFor</code>修饰语，但是用户仍然为失败的交易支付天然气费用。我们在几分钟内部署了一个前端修复程序，最终为170多次失败的交易退还了损失的油费。</p><p id="6e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得庆幸的是，没有一笔交易损失超过0.004 Eth，所以损失很小。总而言之，这是一个很有价值的教训，值得庆幸的是，代价并不太大。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="32ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的下一篇文章中，我们将深入探讨如何通过使用签名优惠券来处理我们的售前/允许列表:</p><div class="od oe gp gr of og"><a href="https://medium.com/@humansofnft/handling-nft-presale-allow-lists-off-chain-47a3eb466e44" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">离线处理NFT预售/允许列表</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">一种使用离线生成的签名优惠券而不是链上允许列表的新方法。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kp og"/></div></div></a></div></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="a01e" class="mq mr iq bd ms mt mu dn mv mw mx dp my lf mz na nb lj nc nd ne ln nf ng nh ni bi translated"><strong class="ak">附录</strong></h2><p id="6dd5" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">①<a class="ae kv" href="https://docs.chain.link/docs/chainlink-vrf/" rel="noopener ugc nofollow" target="_blank">https://docs.chain.link/docs/chainlink-vrf/</a></p><p id="ab12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/1001-digital/erc721-extensions" rel="noopener ugc nofollow" target="_blank">https://github.com/1001-digital/erc721-extensions</a></p></div></div>    
</body>
</html>