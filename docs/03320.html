<html>
<head>
<title>To Mutate or Not to Mutate? The JavaScript Array Methods Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">变异还是不变异？JavaScript数组方法备忘单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/to-mutate-or-not-to-mutate-javascript-array-methods-cheat-sheet-2a7f39c9ca65?source=collection_archive---------20-----------------------#2020-02-03">https://betterprogramming.pub/to-mutate-or-not-to-mutate-javascript-array-methods-cheat-sheet-2a7f39c9ca65?source=collection_archive---------20-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f6ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">记住九种使数组变异的方法的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80341a147dc5adab1cac42eb36b2cc69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mrmIKJgf3bsYC9-l"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@milenatrifonova?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米莲娜·特里福诺娃</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="8cd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你开始学习不同的方法来操作一个数组时，你的世界被照亮了。可以添加和删除元素！你可以逆转他们！然后，您会意识到并非所有内置数组方法都按照您希望的方式运行。在这个过程中的某个地方，您会弄不清哪个方法改变了原始数组，哪个没有。</p><p id="ff0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有一个工具能告诉你一个特定的数组方法是否改变了原始数组，那不是很好吗？</p><p id="de93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我知道。我们可以随时查看MDN的文档。更好的是，有一个很棒的网站<a class="ae ky" href="https://doesitmutate.xyz/" rel="noopener ugc nofollow" target="_blank"/>(希望)列出了所有常用的数组方法，并将它们标识为“变异”或“不变异”</p><p id="bfc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我做了一个快速统计，发现网站上列出的31种方法中只有9种会改变数组。</p><p id="accf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个想法:为什么不仅仅记住九个破坏性的数组方法？这样，在处理数组时，我们不需要停顿太久。如果我们调用这九个方法中的任何一个，原始数组肯定会被修改。</p><p id="90fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，让我们来探索这九种方法，看看变异者是如何变异的！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="40a5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.。推送()</h1><p id="99fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">.push()</code>方法接受一个将被添加到数组末尾的数组元素。</p><p id="94c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们有一个名为<code class="fe mz na nb nc b">happy</code>的数组，由三个笑脸表情组成。在我们推了一个便便脸之后，<code class="fe mz na nb nc b">happy</code>数组现在有一个快乐的便便脸附加在末尾:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="12a7" class="nh md it nc b gy ni nj l nk nl">let happy = ['🙂', '😀', '😊'];</span><span id="39b7" class="nh md it nc b gy nm nj l nk nl">happy.push('💩');</span><span id="aa5e" class="nh md it nc b gy nm nj l nk nl">happy<br/>// =&gt; [ '🙂', '😀', '😊', '💩']</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bfaf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.。流行()</h1><p id="9f34" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个方法类似于<code class="fe mz na nb nc b">.push()</code>方法，因为两者都涉及到改变数组的最后一项。</p><p id="4423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe mz na nb nc b">.push()</code>方法不同，<code class="fe mz na nb nc b">.pop()</code>将移除数组的最后一项。如下图所示，我们只需将<code class="fe mz na nb nc b">.pop()</code>的便便从<code class="fe mz na nb nc b">happy</code>数组中取出！</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="57ac" class="nh md it nc b gy ni nj l nk nl">happy<br/>// =&gt; [ '🙂', '😀', '😊', '💩']</span><span id="d153" class="nh md it nc b gy nm nj l nk nl">happy.pop();</span><span id="99a5" class="nh md it nc b gy nm nj l nk nl">happy<br/>// =&gt; [ '🙂', '😀', '😊']</span></pre><p id="7967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:便便表情符号不是随机选择的。正是在这里帮助我们记住 <code class="fe mz na nb nc b"><em class="nn">.push()</em></code> <em class="nn">和</em> <code class="fe mz na nb nc b"><em class="nn">.pop()</em></code> <em class="nn">都是通过添加(</em><strong class="lb iu"><em class="nn">p</em></strong><em class="nn">ushing)或移除(</em><strong class="lb iu"><em class="nn">p</em></strong><em class="nn">opping)最后一项(</em><strong class="lb iu"><em class="nn">p</em></strong><em class="nn">OOP)来对数组进行变异。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2cc6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.。未移位()</h1><p id="3186" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">.unshift()</code>方法的工作方式与<code class="fe mz na nb nc b">.push()</code>相似，除了它在数组的开头添加了一个新项目。</p><p id="5b8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们干净，没有便便的笑脸的例子。在我们将一个幽灵表情符号传递到<code class="fe mz na nb nc b">.unshift()</code>方法之后，<code class="fe mz na nb nc b">happy</code>数组现在由一个幽灵领导！</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7ea9" class="nh md it nc b gy ni nj l nk nl">let happy = [ '🙂', '😀', '😊']</span><span id="97dd" class="nh md it nc b gy nm nj l nk nl">happy.unshift('👻');</span><span id="60d7" class="nh md it nc b gy nm nj l nk nl">happy<br/>// =&gt; [ '👻', '🙂', '😀', '😊']</span></pre><p id="1519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们想删除第一项呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9eef" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.。shift()</h1><p id="ecdc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">.pop()</code>删除最后一项，<code class="fe mz na nb nc b">.shift()</code>只是删除数组中的第一项，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4516" class="nh md it nc b gy ni nj l nk nl">happy<br/>// =&gt; [ '👻', '🙂', '😀', '😊']</span><span id="06a7" class="nh md it nc b gy nm nj l nk nl">happy.shift();</span><span id="87c8" class="nh md it nc b gy nm nj l nk nl">happy<br/>// =&gt; ['🙂', '😀', '😊']</span></pre><p id="5f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">提示:您可能已经注意到了，</em> <code class="fe mz na nb nc b"><em class="nn">.unshift()</em></code> <em class="nn">和</em> <code class="fe mz na nb nc b"><em class="nn">.shift()</em></code> <em class="nn">是镜像方法，用于添加/移除数组中的第一项。同理，你可以把</em> <code class="fe mz na nb nc b"><em class="nn">.push()</em></code> <em class="nn">和</em> <code class="fe mz na nb nc b"><em class="nn">.pop()</em></code> <em class="nn">看成是另一组添加/移除数组最后一项的方法。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1105" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.。反向()</h1><p id="061b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个显而易见的。顾名思义，<code class="fe mz na nb nc b">.reverse()</code>方法颠倒数组中元素的顺序。在这里，由于使用了<code class="fe mz na nb nc b">.reverse()</code>方法，我们可以看到一个盈亏月亮的效果。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="cbcd" class="nh md it nc b gy ni nj l nk nl">let moon = ['🌒', '🌓', '🌔', '🌕'];</span><span id="03b8" class="nh md it nc b gy nm nj l nk nl">moon.reverse();</span><span id="7ae4" class="nh md it nc b gy nm nj l nk nl">moon<br/>// =&gt; [ '🌕', '🌔', '🌓', '🌒']</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="25ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.。拼接()</h1><p id="a97f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">.splice()</code>方法非常强大，因为它可以接受任意多的参数，并通过添加和/或替换数组中的项目来改变数组。</p><p id="3acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的三只聪明猴子数组示例中，我们通过传入三种类型的参数来实现<code class="fe mz na nb nc b">.splice()</code>方法:</p><ol class=""><li id="74aa" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">变化开始的索引(索引1)</li><li id="46bd" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">要移除的项目数量(一个项目:无恶不作的猴子)</li><li id="58ba" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">要添加到数组中的项目(三个邪恶面)</li></ol><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1623" class="nh md it nc b gy ni nj l nk nl">let monkeys = ['🙈', '🙉', '🙊'];</span><span id="64e3" class="nh md it nc b gy nm nj l nk nl">monkeys.splice(1, 1, '😈', '😈', '😈');</span></pre><p id="6a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，听不见邪恶的猴子不见了，取而代之的是三张邪恶的脸:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f459" class="nh md it nc b gy ni nj l nk nl">monkeys<br/>// =&gt; [ '🙈', '😈', '😈', '😈', '🙊']</span></pre><p id="b6d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以选择仅将项目添加到数组内的特定位置。在这里，我们在索引2处插入了邪恶的面孔，但保留了所有三只猴子(作为第二个参数传入<code class="fe mz na nb nc b">0</code>):</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="16fc" class="nh md it nc b gy ni nj l nk nl">let monkeys = ['🙈', '🙉', '🙊'];</span><span id="7c7c" class="nh md it nc b gy nm nj l nk nl">monkeys.splice(2, 0, '😈');</span><span id="21e0" class="nh md it nc b gy nm nj l nk nl">monkeys<br/>// =&gt; [ '🙈', '🙉', '😈', '🙊']</span></pre><p id="1734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">提示:注意</em> <code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank"><em class="nn">.slice()</em></a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank"> <em class="nn">方法</em> </a> <em class="nn">。表面上看起来像是</em> <code class="fe mz na nb nc b"><em class="nn">.splice()</em></code> <em class="nn">，但是</em> <code class="fe mz na nb nc b"><em class="nn">.slice()</em></code> <em class="nn">方法产生了一个新的数组，因此不会改变原来的数组。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ee0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.。排序()</h1><p id="3321" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个太棒了。默认情况下,<code class="fe mz na nb nc b">.sort()</code>方法确实对数组中的项目进行了降序排序，但是它不一定按照我们普通人所期望的方式运行。</p><p id="eb84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一组数字。如果我们应用<code class="fe mz na nb nc b">.sort()</code>方法会发生什么？</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5e9b" class="nh md it nc b gy ni nj l nk nl">let numbers = [3, 25, 99];</span><span id="d65b" class="nh md it nc b gy nm nj l nk nl">numbers.sort();</span><span id="7f16" class="nh md it nc b gy nm nj l nk nl">numbers<br/>// =&gt; [ 25, 3, 99 ]</span></pre><p id="7c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很奇怪，对吧？</p><p id="e008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，<code class="fe mz na nb nc b">.sort()</code>方法将每一项转换成一个字符串，并根据它们的Unicode码位进行比较。</p><p id="2344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过调用<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt" rel="noopener ugc nofollow" target="_blank">.codePointAt()</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt" rel="noopener ugc nofollow" target="_blank">方法</a>来检查字符串第一个值的Unicode码位。</p><p id="65ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些数字强制转换成字符串后，我们看到了为什么<code class="fe mz na nb nc b">.sort()</code>认为<code class="fe mz na nb nc b">25</code>小于<code class="fe mz na nb nc b">3</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别忘了表情符号也是作为字符串传入的！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="aa56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="7b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您真的想按照人类理解的顺序对数字进行排序，您可以在<code class="fe mz na nb nc b">.sort()</code>方法中传递一个比较函数作为参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的脑袋还没有爆炸，看看这篇深入研究<code class="fe mz na nb nc b">.sort()</code>方法的惊人文章。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4c80" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.。copyWithin()</h1><p id="1e02" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">顾名思义，该方法复制数组的一部分，并将其放在同一数组的另一部分上。</p><p id="d8cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它接受三个参数:</p><ol class=""><li id="1c7d" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">放置复制项的索引</li><li id="a9e3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">(可选)开始复制项目的索引(包含)</li><li id="3076" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">(可选)结束复制项目的索引(不含)</li></ol><p id="3af0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举例来说，下面是我们如何利用<code class="fe mz na nb nc b">.copyWithin()</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="1640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有另一个例子来帮助阐明每个论点的目的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d9d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意最后一项(“🙏”)被替换后，我们复制了两个项目(“👌", "✋").</p><p id="e301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我还没有机会在我的程序中使用<code class="fe mz na nb nc b">.copywithin()</code>，但这个方法的功能似乎与<code class="fe mz na nb nc b">.splice()</code>相似。基于两种方法接受的参数类型，后者提供了更多的灵活性，因为我们可以插入新的项，而不是从内部复制。所以选你的毒药吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c160" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">9.。填充()</h1><p id="651b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，<code class="fe mz na nb nc b">.fill()</code>方法将数组中的部分或全部项改变为传入的值。</p><p id="1c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还接受3个参数:</p><ol class=""><li id="82c3" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">用于填充数组的值</li><li id="6673" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">(可选)起始索引(含)</li><li id="68b0" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">(可选)结束索引(不含)</li></ol><p id="a2aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，你可以修复一颗破碎的心:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="97fa" class="nh md it nc b gy ni nj l nk nl">let spreadTheLove = ["&lt;3", "💔", "love", "heart"];</span><span id="4c83" class="nh md it nc b gy nm nj l nk nl">spreadTheLove.fill("❤️", 1, 2);</span><span id="7380" class="nh md it nc b gy nm nj l nk nl">spreadTheLove<br/>// =&gt; [ '&lt;3', '❤️', 'love', 'heart']</span></pre><p id="8d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者只是用爱填满它们:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5b25" class="nh md it nc b gy ni nj l nk nl">spreadTheLove = ["&lt;3", "💔", "love", "heart"];</span><span id="5d39" class="nh md it nc b gy nm nj l nk nl">spreadTheLove.fill("❤️");</span><span id="e34b" class="nh md it nc b gy nm nj l nk nl">spreadTheLove<br/>// =&gt; [ '❤️', '❤️', '❤️', '❤️' ]</span></pre><p id="3d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">.fill()</code>方法的一个显著特征是它只接受一个静态值。如果你想在一个数组中插入多个值，去别处看看。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a0eb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概述</h1><p id="0406" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">同样，下面是改变原始数组的九个基本数组方法:</p><ul class=""><li id="07cb" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oe nu nv nw bi translated"><code class="fe mz na nb nc b">.push()</code> —添加一个新项作为数组的最后一项。</li><li id="c5b5" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oe nu nv nw bi translated"><code class="fe mz na nb nc b">.pop()</code> —删除数组的最后一项。</li><li id="4136" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oe nu nv nw bi translated"><code class="fe mz na nb nc b">.unshift()</code> —添加一个新项目作为数组的第一个项目。</li><li id="a0a3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oe nu nv nw bi translated"><code class="fe mz na nb nc b">.shift()</code> —删除数组的第一项。</li><li id="0f7e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oe nu nv nw bi translated"><code class="fe mz na nb nc b">.reverse()</code> —反转数组的顺序。</li><li id="bcc3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oe nu nv nw bi translated"><code class="fe mz na nb nc b">.splice()</code> —删除/替换数组中的项目。</li><li id="0a80" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oe nu nv nw bi translated"><code class="fe mz na nb nc b">.sort()</code> —根据Unicode码位对数组中的项目重新排序。</li><li id="e466" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oe nu nv nw bi translated"><code class="fe mz na nb nc b">.copyWithin()</code> —复制数组的一部分，并将其放在同一数组的另一部分上。</li><li id="c661" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oe nu nv nw bi translated"><code class="fe mz na nb nc b">.fill()</code> —将数组中的部分或全部项目更改为传入的值。</li></ul><p id="57ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过记住这九个方法，我能够加快我的编码过程。这也减轻了我对意外复制或改变数组的担心。希望你也觉得有用！</p></div></div>    
</body>
</html>