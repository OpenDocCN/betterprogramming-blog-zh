<html>
<head>
<title>How to Avoid Model Changes Nightmare in Java or Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免Java或Kotlin中的模型变更噩梦</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-avoid-model-changes-nightmare-in-java-kotlin-9f9cba2a532b?source=collection_archive---------8-----------------------#2022-01-22">https://betterprogramming.pub/how-to-avoid-model-changes-nightmare-in-java-kotlin-9f9cba2a532b?source=collection_archive---------8-----------------------#2022-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="10ab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在将模型变更部署到生产环境之前，您需要验证的事情</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e9b9c374860c8debb0ab290a1ab71cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OeKE26QtG86OyLOHLobAtQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@afgprogrammer" rel="noopener ugc nofollow" target="_blank">穆罕默德·拉赫马尼</a>在<a class="ae kv" href="https://unsplash.com/photos/_Fx34KeqIEw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="582c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模型的变化是可怕的。告诉我这听起来是否熟悉。您对API契约中使用的数据模型中的一个字段进行了小小的更改。你在你的本地机器上测试了它，你对你的改变有信心。</p><p id="9f0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将代码部署到产品中。你拍拍自己的背，呷一口茶，准备结束一天的工作。</p><p id="5bc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，突然你开始收到警报和升级，你的电子邮件收件箱被客户投诉淹没。你知道你搞砸了一些事情。但是哪里出了问题，改变是非常简单的。</p><p id="3462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您急于回滚您的更改。几分钟之内，错误就消失了。但是已经有很多业务功能被中断，客户不高兴了。</p><p id="5e3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你在探查哪里出了问题，却发现你漏掉了一些简单的东西。</p><p id="7e3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">凭着多年的经验，我怎么会犯这样愚蠢的错误呢？</p><p id="aa78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你为自己犯了这么小的错误而感到羞耻，以至于你想摆脱尴尬。也许如果我改名换姓离开这个国家，没有人会认出我？</p><p id="e81a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你开始质疑你的职业选择。也许我应该进入一个不同的职业，我知道一些photoshop，也许我可以做平面设计。</p><p id="533e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快，压力球在哪里？</p><p id="bbc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打破生产代码并不光彩。为了帮助您避免这样的陷阱，我整理了在将您的模型变更部署到生产中之前您需要验证的东西。</p><p id="9b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然大多数要点也适用于其他语言，但有些要点是Java和Kotlin用户特有的。</p><h1 id="7529" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如果要添加新属性，请添加JsonIgnoreProperties批注</h1><p id="2160" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用Jackson解析JSON数据的一个常见问题是，当JSON包含未知属性时，反序列化会失败。当您向一个现有的模型类中添加一个新的属性时，请确保该类用<code class="fe mp mq mr ms b">@JsonIgnoreProperties(ignoreUnknown = true)</code>进行了注释。</p><p id="98ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个例子。</p><p id="ca21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，订单服务调用用户服务来获取用户详细信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/e04322cdc17ebbd326be39dc5d3a8255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSVO2OFzfuEHrs-Nrxp1AA.png"/></div></div></figure><p id="c196" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户服务将通过序列化为JSON数据来返回用户类的对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/6dbe63ef92163bfa66f2aad08ef73dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VD5qPF_fxvBx0OwigUaGNg.png"/></div></div></figure><p id="25f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且我们在订单服务中去序列化这些JSON数据。</p><pre class="kg kh ki kj gt mx ms my mz aw na bi"><span id="8616" class="nb lt iq ms b gy nc nd l ne nf">userResponseJson = getJsonResponseFromUserService()<br/>user = jacksonObjectMapper.readValue(userResponseJson, User.class);</span></pre><p id="b755" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，明天如果我们在用户服务的用户模型中添加一个新字段“地址”,用户服务返回的JSON将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e1e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将中断订单服务中的反序列化，并出现异常。</p><pre class="kg kh ki kj gt mx ms my mz aw na bi"><span id="f900" class="nb lt iq ms b gy nc nd l ne nf">com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException</span></pre><p id="e072" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为Jackson不确定如何处理未知属性<em class="ng">地址</em>。您可以通过在模型类中添加JsonIgnoreProperties注释来解决这个问题，Jackson将忽略任何未知的属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><blockquote class="nh ni nj"><p id="e487" class="kw kx ng ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">注意:如果您计划向一个没有JsonIgnoreProperties的类添加一个新的属性，那么您必须首先添加注释，首先重新启动依赖服务(在本例中是order service)，以便在依赖服务中获得最新的模型。</p></blockquote><h1 id="eb6c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">测试代码和数据的向后兼容性</strong></h1><p id="52be" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是您在将任何模型变更部署到生产环境之前应该遵循的最重要的事情。这将有助于你发现任何隐藏在黑暗中的神秘虫子。</p><p id="c85d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">代码的向后兼容性(旧模型类与新数据):</strong></p><p id="50ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统中可能有客户端仍在使用您的旧模型类来反序列化新数据。为了确保反序列化不会在这里中断，请测试旧模型类是否可以反序列化新数据。</p><p id="2a68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以我们之前的例子为例，我们向现有的用户类添加了一个新的属性(地址)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="42ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更改之后，用户服务将发送新的JSON数据，但是订单服务仍然使用旧版本的用户类来反序列化这些数据</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/b42555b9be7b4cc824b9aca45704cbfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6j9lYalI-wOx_Az8AHOWFw.png"/></div></div></figure><p id="637c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该测试这个场景，并确保旧模型能够反序列化新数据。</p><p id="adb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此编写单元测试是一个有点挑战性的问题。您需要找出一种方法来保留旧版本的模型类，并根据最新版本的类创建的数据进行测试。</p><p id="ba04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">数据的向后兼容性(新模型与旧数据):</strong></p><p id="837c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用旧数据测试新模型的需要不是很直观(至少对我来说是这样😅).因为，一旦您改变了您的模型，您的服务中的API将总是发送新的数据。那么，为什么需要用旧数据进行测试呢🤔？</p><p id="6619" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我举一个例子来说明为什么需要确保这种兼容性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/4dafe22bee4ae2d5c2877755a6094fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MoChY8TeGUNE-LOfGlKH0g.png"/></div></div></figure><p id="c679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们前面看到的，用户服务提供了一个API来返回用户的详细信息。</p><p id="e116" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Order service提供了一个API，用于返回订单的用户详细信息，它从用户服务中读取用户数据并返回相同的数据。</p><p id="bc7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">履行服务正在调用订单管理服务API来获取订单的用户详细信息。</p><p id="7b8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户服务更新了用户类别模型。和履行服务重新启动，并从用户服务中获得最新型号。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/fd9b14e0996ae65266c5f20070fdaa43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ayLdVi0bNalxArSKQgiJAA.png"/></div></div></figure><p id="05d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">订单管理仍然使用旧版本的模型，因此返回旧的JSON。而fulfillment service正在尝试使用新模型对其进行反序列化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新模型类</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">旧的JSON数据</p></figure><p id="5552" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，您需要测试使用新类反序列化旧数据的场景，以避免任何不必要的意外。</p><h1 id="9468" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">当属性可选时设置默认值</strong></h1><p id="6734" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这一点是Kotlin独有的，所以java用户可以跳过这一点。在kotlin中，如果您正在反序列化带有可选属性的JSON，请确保您的类中的这些可选属性可以为空或者设置了默认值。否则，反序列化将会中断。但是，在JAVA中，这不是必需的，因为JAVA将未知字段设置为null。</p><p id="54fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以我们之前的用户模型为例。如果lastName是可选属性，并且我们试图反序列化没有lastName的用户数据。</p><pre class="kg kh ki kj gt mx ms my mz aw na bi"><span id="b09e" class="nb lt iq ms b gy nc nd l ne nf">{  <br/>  "firstName": "Thor" <br/>}</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="218a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反序列化将在这里中断，您将看到如下错误:</p><pre class="kg kh ki kj gt mx ms my mz aw na bi"><span id="a978" class="nb lt iq ms b gy nc nd l ne nf">Instantiation of User value failed for JSON property lastName due to missing (therefore NULL..</span></pre><p id="eefb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">若要解决此问题，请为该属性分配一个默认值，或者使该属性可为空。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="beb9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">删除/更改字段时迁移数据平台。</strong></h1><p id="ca9d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">大多数公司都有数据仓库来实现和支持他们的商业智能(BI)活动，尤其是分析。通常，主数据库中的数据被注入到数据仓库中的表中，分析报告在这些表的基础上构建。</p><p id="71b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能已经基于您正在更改的属性创建了一些报告。因此，在更改/删除任何现有属性之前，请确保通知各自的团队并准备好迁移计划。</p><h1 id="9a1e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">了解您的数据交换协议中的默认设置</strong></h1><p id="1725" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不同的数据交换协议及其对象映射器反序列化数据的方式不同。理解你的反序列化器的行为，尤其是知道它设置了什么默认值是非常重要的。否则，您可能会遇到意想不到的行为。</p><p id="61b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑这个例子，您使用Jackson将下面的JSON数据反序列化为java对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="kg kh ki kj gt mx ms my mz aw na bi"><span id="f6e0" class="nb lt iq ms b gy nc nd l ne nf">user = jacksonObjectMapper().readValue(json, User::class.java)</span></pre><p id="93c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，Jackson会将未知字段设置为null。<strong class="ky ir">在这种情况下，user.lastName将为null。</strong></p><p id="5e4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想执行一个函数，当姓氏可用时，你可以在user.lastName上写一个空检查，一切都很好！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="18ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你使用protobuf并且使用消息反序列化同一个JSON。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ae85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反序列化的proto对象将具有空字符串""的默认值。<em class="ng"> user.lastName </em>在这种情况下不会为null，而是一个空字符串("")</p><p id="4010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您想要实现与上面相同的行为，在姓氏可用时执行一个函数，您将需要对空白字符串进行额外的检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7d0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">永远不要改变现有字段的含义。</strong></p><p id="412f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">改变现有字段的含义是一个很大的问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="422e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您有一个产品类，单价是以卢比表示的产品价格(理想情况下，属性名称不应该如此模糊😄).后来，您意识到您需要更多的粒度，并希望以paise表示单价值。</p><p id="0c01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您不应该更新unitPrice的现有行为并开始在现有属性<em class="ng"> unitPrice </em>中发送paise中的单价。因为可能有其他服务基于单价以卢比为单位的假设使用该字段，而他们的假设将会失效。</p><p id="3137" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，您应该添加一个新的字段“单价”,如果需要的话，删除旧的字段“单价”。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者您也可以创建一个更新版本的产品类，并将其用于您的用例。</p><h1 id="5742" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">编写合同测试</h1><p id="4c37" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">自动化测试是防御之墙，也是守夜人，保护您的代码免受远方野人的攻击。</p><p id="8585" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置和编写一个集成测试可能看起来像是一个耗时且乏味的任务，但是从长远来看，可以把它看作是一项投资，它会把你从许多麻烦中解救出来。</p><p id="bc93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在微服务架构中，单独测试服务的简单单元测试和集成测试是不够的。您需要契约测试来测试多个服务之间的集成点。</p><p id="f027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">契约测试本身是一个完全不同的主题，我们不会在本文中深入讨论更多的细节。有多种工具可用于契约测试，其中最流行的是<a class="ae kv" href="https://docs.pact.io/#:~:text=Pact%20is%20a%20code%2Dfirst%20consumer%2Ddriven%20contract%20testing%20tool,of%20the%20automated%20consumer%20tests." rel="noopener ugc nofollow" target="_blank"> Pact </a>。</p><h1 id="3d60" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="e409" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不管你喜不喜欢，模型变更是软件工程师经常要做的事情，尤其是如果你在一个快节奏的公司工作。</p><p id="d512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这几点能在你满怀信心地进行下一次车型改款时对你有所帮助。</p><p id="8cbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我错过了任何重要的点，请让我知道。感谢阅读。</p></div></div>    
</body>
</html>