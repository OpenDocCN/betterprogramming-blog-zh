<html>
<head>
<title>Difference Between Procedural and Object Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">过程编程和面向对象编程的区别</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-should-now-the-difference-between-procedural-style-coding-and-object-oriented-style-coding-f9e25d6d0470?source=collection_archive---------4-----------------------#2022-11-12">https://betterprogramming.pub/why-you-should-now-the-difference-between-procedural-style-coding-and-object-oriented-style-coding-f9e25d6d0470?source=collection_archive---------4-----------------------#2022-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7c5c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通往干净和可维护代码的踏脚石</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/678e8159f8738f25d7d5015a2c0e2db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSh1OU7MFHkPzTsRsahVFQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://pixabay.com/photos/confused-muddled-illogical-880735/" rel="noopener ugc nofollow" target="_blank">困惑</a></p></figure><h1 id="b0d0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">前言</h1><p id="47cf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">软件行业的大多数人使用主要为面向对象编程(OOP)设计的编程语言。虽然用面向对象的方式编码是完全有效的，但了解多种编程范例可能会派上用场。</p><h1 id="de6a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="9882" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，OOP与过程式编码形成了对比。此外，这篇文章解释了为什么在某些情况下您可能想要使用过程式编码。如果您喜欢只阅读代码，可以直接跳到文章的底部。在那里你可以找到GitHub上代码的链接。</p><h1 id="0921" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是面向对象编程(OOP)？</h1><p id="fb4f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">OOP是一种软件设计范式，其中程序是围绕对象和数据结构而不是功能和逻辑来构建的。经典的OOP编程语言有Python、Java、C#等等。</p><h2 id="9439" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">例子</h2><p id="c791" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设您被要求创建一个程序来计算圆、正方形和矩形的面积。要求是用OOP风格写代码。你会怎么做？请随意写一些伪代码或尝试一下并编码它！</p><h2 id="1469" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">暗示</h2><ol class=""><li id="ba0f" class="mw mx iq lq b lr ls lu lv lx my mb mz mf na mj nb nc nd ne bi translated">你的程序结构会是什么样的？</li><li id="638a" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">你的程序有多少个类和方法？</li><li id="097f" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">这些类和方法是如何组织的？</li></ol><p id="140f" class="pw-post-body-paragraph lo lp iq lq b lr nk jr lt lu nl ju lw lx nm lz ma mb nn md me mf no mh mi mj ij bi translated"><strong class="lq ir">一种可能的解决方案:</strong></p><pre class="kg kh ki kj gt np nq nr bn ns nt bi"><span id="63d2" class="nu kx iq nq b be nv nw l nx ny">// Data Object Asymetry<br/>// Object Oriented example</span></pre><pre class="nz np nq oa ob aw oc bi"><span id="2582" class="mk kx iq nq b gy od oe l of ny">case class Square(var side: Double = 0) {</span><span id="5a30" class="mk kx iq nq b gy og oe l of ny">  println(side * side)</span><span id="d1ce" class="mk kx iq nq b gy og oe l of ny">}</span><span id="1045" class="mk kx iq nq b gy og oe l of ny">case class Rectangle(var height: Double = 0, var width: Double = 0) {</span><span id="6321" class="mk kx iq nq b gy og oe l of ny">  println(height * width)</span><span id="de6b" class="mk kx iq nq b gy og oe l of ny">}</span><span id="6b95" class="mk kx iq nq b gy og oe l of ny">case class Circle(<br/>    var pi: Double,<br/>    var center: Double = 0,<br/>    var radius: Double = 0<br/>) {</span><span id="852e" class="mk kx iq nq b gy og oe l of ny">  println(pi * radius * radius)</span><span id="7cd6" class="mk kx iq nq b gy og oe l of ny">}</span><span id="34a0" class="mk kx iq nq b gy og oe l of ny">object Geometry extends App {</span><span id="8aad" class="mk kx iq nq b gy og oe l of ny">  val pi = 3.141<br/>  val side = 2.0<br/>  val height = 1.0<br/>  val width = 2.0<br/>  val center = 2.0<br/>  val radius = 0.5</span><span id="eae8" class="mk kx iq nq b gy og oe l of ny">  Square(side)<br/>  Rectangle(height, width)<br/>  Circle(pi, center, radius)</span><span id="7d11" class="mk kx iq nq b gy og oe l of ny">}</span></pre><p id="155a" class="pw-post-body-paragraph lo lp iq lq b lr nk jr lt lu nl ju lw lx nm lz ma mb nn md me mf no mh mi mj ij bi translated">该程序设计有封装数据和功能的类。每个类对象都是相互独立的。这使得添加新函数变得困难，因为所有的类都需要改变。然而，添加新的类是很容易的。例如，如果我想打印每一个周长<code class="fe oh oi oj nq b">Shape</code>，这样的函数需要单独添加到每个类中。然而，添加类<code class="fe oh oi oj nq b">Trapeze</code>将是一个简单的任务。换句话说，如果我们添加一个类，我们只在一个地方编辑代码。如果我们添加一个函数，我们必须至少在三个地方编辑代码。</p><h1 id="8f87" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是过程式编码？</h1><p id="84e9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">过程式代码是一种软件设计范例，其中程序的逻辑被置于程序设计的中心。一些主要的过程语言是Fortran、COBOL和C#，等等。</p><h2 id="41fd" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">任务—程序示例</h2><p id="a983" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">接下来，你将如何在程序编码中实现<code class="fe oh oi oj nq b">Geometry</code>应用？思考与OOP示例提示中相同的问题。</p><h2 id="00aa" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">可能的解决方案:</h2><pre class="kg kh ki kj gt np nq nr bn ns nt bi"><span id="bb85" class="nu kx iq nq b be nv nw l nx ny">// Data Object Asymetry<br/>// Procedual example</span></pre><pre class="nz np nq oa ob aw oc bi"><span id="b378" class="mk kx iq nq b gy od oe l of ny">case class Square(var side: Double = 0) {}</span><span id="1bef" class="mk kx iq nq b gy og oe l of ny">case class Rectangle(var height: Double = 0, var width: Double = 0) {}</span><span id="c10d" class="mk kx iq nq b gy og oe l of ny">case class Circle(var center: Double = 0, var radius: Double = 0) {}</span><span id="9046" class="mk kx iq nq b gy og oe l of ny">object Geometry extends App {</span><span id="fb7e" class="mk kx iq nq b gy og oe l of ny">  val pi = 3.141<br/>  val square = Square(2.0)<br/>  val rectangle = Rectangle(1.0, 2.0)<br/>  val circle = Circle(1, 0.5)<br/>  val shapes = List(square, rectangle, circle)</span><span id="ca94" class="mk kx iq nq b gy og oe l of ny">  def hasArea(shape: Any): Unit =<br/>    shape match {</span><span id="030f" class="mk kx iq nq b gy og oe l of ny">      case Square(side) =&gt; println(side * side)</span><span id="701f" class="mk kx iq nq b gy og oe l of ny">      case Rectangle(height, width) =&gt; println(height * width)</span><span id="6296" class="mk kx iq nq b gy og oe l of ny">      case Circle(center, radius) =&gt; println(pi * radius * radius)</span><span id="d80c" class="mk kx iq nq b gy og oe l of ny">      case _ =&gt; println("Not a Shape")</span><span id="1878" class="mk kx iq nq b gy og oe l of ny">    }</span><span id="a0e2" class="mk kx iq nq b gy og oe l of ny">  <br/>  shapes.foreach(shape =&gt; hasArea(shape))</span><span id="751a" class="mk kx iq nq b gy og oe l of ny">}</span></pre><h2 id="a731" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">说明</h2><p id="af4f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">同样，我们为所需的各种形状创建了case类。但是，这些case类不包含任何功能。任何方法都是在程序体中顺序实现的。在过程式编码中，很容易添加新的函数。然而，添加新的类更加复杂。</p><p id="eb24" class="pw-post-body-paragraph lo lp iq lq b lr nk jr lt lu nl ju lw lx nm lz ma mb nn md me mf no mh mi mj ij bi translated">例如，在上面的程序中，如果我们添加一个新的函数'<code class="fe oh oi oj nq b">hasCircumfrance</code>,代码只需要在一个地方编辑。但是，如果我们想添加另一个类，我们必须至少编辑代码中的两个地方。体内的每一个函数都需要改变，再加上程序顶部的类定义需要添加。</p><h2 id="ff62" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">什么时候以及为什么要使用这两种方法？</h2><p id="00b8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您可能已经注意到了这两种编程风格的不对称本质。要么很难添加新的数据结构，因为所有的功能都需要改变。或者很难添加新的功能，因为所有的类都需要改变。</p><p id="295d" class="pw-post-body-paragraph lo lp iq lq b lr nk jr lt lu nl ju lw lx nm lz ma mb nn md me mf no mh mi mj ij bi translated">要编写干净且可维护的代码，您应该了解这两种方法。在某些情况下，您希望能够轻松地添加功能，而在另一个用例中，您希望轻松地添加类。在写代码之前，你应该问问自己哪种风格更好。</p><p id="cf1c" class="pw-post-body-paragraph lo lp iq lq b lr nk jr lt lu nl ju lw lx nm lz ma mb nn md me mf no mh mi mj ij bi translated">编码风格高度依赖于一个人试图解决的用例或业务用例。在几何示例中，如果我期望永远不添加任何新的<code class="fe oh oi oj nq b">Shapes</code>，而是添加许多函数，我将使用过程化风格编写程序。另一方面，如果我预计随着时间的推移会添加更多的形状，而函数会保持不变，我会选择用OOP风格编写程序</p><h1 id="9aae" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">关键外卖</h1><p id="4595" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">罗伯特·c·马丁(Robert C. Martin)在他的名著《敏捷软件工艺手册》(A Handbook of Agile Software craftness)中写道:“成熟的程序员知道，一切都是对象的想法是一个神话。有时你真的想要简单的数据结构和在其上操作的程序。最后，知道你想用什么样的风格来编程你的应用程序将会极大地增强这个应用程序的可维护性。</p><h1 id="35cc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结束语</h1><p id="3f01" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">感谢您阅读这篇文章。希望你能从中得到一些有价值的东西。请随意添加评论、问题或备注。祝你一周愉快！:)</p><h2 id="bda1" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">GitHub:</h2><p id="a09b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://github.com/DataBach-maker/ScalaExamples/tree/main/OOP_vs_PSC" rel="noopener ugc nofollow" target="_blank">https://github . com/DataBach-maker/Scala examples/tree/main/OOP _ vs _ PSC</a></p><h2 id="4e85" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">参考</h2><p id="2014" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">R. C .马丁(2011年)。<em class="ok">干净的代码——敏捷软件工艺手册</em>。皮尔森教育。</p></div></div>    
</body>
</html>