<html>
<head>
<title>How To Build a Modal With Ionic and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Ionic和React建立一个模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ionic-react-modal-9e3d319eb6ac?source=collection_archive---------4-----------------------#2019-12-10">https://betterprogramming.pub/ionic-react-modal-9e3d319eb6ac?source=collection_archive---------4-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0bd6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何声明并向Ionic + React模式传递参数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4d6d0795cd8554762e2d54cae8b2b778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTN15RS0mfGtXUAQF5RVJQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@the_roaming_platypus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> timJ </a>在<a class="ae ky" href="https://unsplash.com/s/photos/dialog?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="68b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些天我对Ionic React很感兴趣，因此，我在尝试不同的组件。</p><p id="a3a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中之一是模态，我几乎毫无例外地在所有应用程序中使用它。</p><p id="73fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管它的专用<a class="ae ky" href="https://ionicframework.com/docs/api/modal" rel="noopener ugc nofollow" target="_blank">文档</a>非常简洁，但我走得更远了，因为我喜欢在它们自己独立的组件中声明它们。这就是我写这篇新博文的原因。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="756e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><p id="a470" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了给应用程序添加一个模型，我们按照文档中显示的那样进行(告诉你，这是有据可查的)。</p><p id="17ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用组件<code class="fe mz na nb nc b">IonModal</code>，为了触发它的打开和关闭，我们还使用一个状态(在一个<code class="fe mz na nb nc b">useState</code>钩子的帮助下)来修改它的属性<code class="fe mz na nb nc b">isOpen</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="cfe7" class="nh md it nc b gy ni nj l nk nl">import React, { useState } from 'react';<br/>import { IonModal, IonButton, IonContent<strong class="nc iu"><em class="nm"> </em></strong>} from '@ionic/react';<br/><br/>export const Tab1: React.FC = () =&gt; {<br/>  const [showModal, setShowModal] = useState(false);<br/><br/>  return (<br/>    &lt;IonContent&gt;<br/>      &lt;IonModal isOpen={showModal}&gt;<br/>        &lt;p&gt;This is the modal content.&lt;/p&gt;<br/>        &lt;IonButton onClick={() =&gt; setShowModal(false)}&gt;<br/>            Close Modal<br/>        &lt;/IonButton&gt;<br/>      &lt;/IonModal&gt;<br/>      &lt;IonButton onClick={() =&gt; setShowModal(true)}&gt;<br/>            Show Modal<br/>      &lt;/IonButton&gt;<br/>    &lt;/IonContent&gt;<br/>  );<br/>};<br/><br/>export default Tab1;</span></pre><p id="ca12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我使用了<code class="fe mz na nb nc b">tab</code>初学者工具包来开发这篇文章，这就是为什么上面的页面的名称是<code class="fe mz na nb nc b">Tab1</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e67" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建一个组件</h1><p id="bb1f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">模态可能很快变得像页面一样复杂。这就是为什么我习惯于在它们自己的组件中声明它们。然后，让我们试着在一个单独的新文件中创建一个新的，比如叫做<code class="fe mz na nb nc b">MyModal.tsx</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b2cf" class="nh md it nc b gy ni nj l nk nl">import React from 'react';<br/>import {IonHeader, IonContent, IonToolbar, IonTitle} from '@ionic/react';<br/><br/>class MyModal extends React.Component {<br/><br/>  render() {<br/>    return &lt;&gt;<br/>      &lt;IonHeader&gt;<br/>        &lt;IonToolbar color="primary"&gt;<br/>          &lt;IonTitle&gt;My Modal&lt;/IonTitle&gt;<br/>        &lt;/IonToolbar&gt;<br/>      &lt;/IonHeader&gt;<br/>      &lt;IonContent className="ion-padding"&gt;<br/>        &lt;p&gt;This is the modal content.&lt;/p&gt;<br/>      &lt;/IonContent&gt;<br/>    &lt;/&gt;<br/>  };<br/><br/>}<br/><br/>export default MyModal;</span></pre><p id="f781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们创建了它，我们就可以在我们的页面上使用它来替换以前的模态内容。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9458" class="nh md it nc b gy ni nj l nk nl">import React, { useState } from 'react';<br/>import { IonModal, IonButton, IonContent<strong class="nc iu"><em class="nm"> </em></strong>} from '@ionic/react';</span><span id="01b0" class="nh md it nc b gy nn nj l nk nl">import MyModal from './MyModal';<br/><br/>export const Tab1: React.FC = () =&gt; {<br/>  const [showModal, setShowModal] = useState(false);<br/><br/>  return (<br/>    &lt;IonContent&gt;<br/>      &lt;IonModal isOpen={showModal}&gt;<br/>        &lt;MyModal&gt;&lt;/MyModal&gt;<br/>        &lt;IonButton onClick={() =&gt; setShowModal(false)}&gt;<br/>            Close Modal<br/>        &lt;/IonButton&gt;<br/>      &lt;/IonModal&gt;<br/>      &lt;IonButton onClick={() =&gt; setShowModal(true)}&gt;<br/>            Show Modal<br/>      &lt;/IonButton&gt;<br/>    &lt;/IonContent&gt;<br/>  );<br/>};<br/><br/>export default Tab1;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ff1e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">要关闭模态</h1><p id="7012" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">超级，我们实现了第一步，我们现在有一个在单独的组件中声明的模态。</p><p id="ed8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在我们上面的例子中，分别关闭模态按钮和将显示状态设置为<code class="fe mz na nb nc b">false</code>的<code class="fe mz na nb nc b">IonButton</code>按钮的动作仍然在我们的组件之外呈现。</p><p id="11a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从设计的角度来看，这有点不幸，因为我认为在模型本身的头部呈现这样的动作是很常见的。</p><p id="71bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将这个按钮移到模态中，我实际上找到了两种可能的解决方案。一个用的是<code class="fe mz na nb nc b">callback</code>，可能是最干净的一个，另一个用的是<code class="fe mz na nb nc b">references</code>。</p><p id="027d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能会有更多，我真的很高兴听到他们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="62c6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">回收</h1><p id="34b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这个解决方案中，我们希望向组件传递一个回调来关闭模态。我们用一个新的属性来增强它，我们也在我们的头中使用它来添加相关的按钮。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="44aa" class="nh md it nc b gy ni nj l nk nl">import React from 'react';<br/>import {IonHeader, IonContent, IonToolbar, IonTitle, IonButtons, IonButton, IonIcon} from '@ionic/react';<br/><br/>type MyModalProps = {<br/>  closeAction: Function;<br/>}<br/><br/>class MyModal extends React.Component&lt;MyModalProps&gt; {<br/><br/>  render() {<br/>    return &lt;&gt;<br/>      &lt;IonHeader&gt;<br/>        &lt;IonToolbar color="primary"&gt;<br/>          &lt;IonTitle&gt;My Modal&lt;/IonTitle&gt;<br/>          &lt;IonButtons slot="end"&gt;<br/>            &lt;IonButton onClick={() =&gt; this.props.closeAction()}&gt;<br/>              &lt;IonIcon name="close" slot="icon-only"&gt;&lt;/IonIcon&gt;<br/>            &lt;/IonButton&gt;<br/>          &lt;/IonButtons&gt;<br/>        &lt;/IonToolbar&gt;<br/>      &lt;/IonHeader&gt;<br/>      &lt;IonContent className="ion-padding"&gt;<br/>        &lt;p&gt;This is the modal content.&lt;/p&gt;<br/>      &lt;/IonContent&gt;<br/>    &lt;/&gt;<br/>  };<br/><br/>}<br/><br/>export default ({closeAction}: { closeAction: Function }) =&gt; (<br/>  &lt;MyModal closeAction={closeAction}&gt;<br/>  &lt;/MyModal&gt;<br/>)</span></pre><p id="2168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦组件被修改，我们可以创建一个新的函数(在我们的页面上)来设置显示状态为<code class="fe mz na nb nc b">false</code>，并将其作为回调传递给我们的组件。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5251" class="nh md it nc b gy ni nj l nk nl">import React, {useState} from 'react';<br/>import {IonModal, IonButton, IonContent} from '@ionic/react';<br/>import MyModal from './MyModal';<br/><br/>export const Tab1: React.FC = () =&gt; {<br/>  const [showModal, setShowModal] = useState(false);<br/><br/>  async function closeModal() {<br/>    await setShowModal(false);<br/>  }<br/><br/>  return (<br/>    &lt;IonContent&gt;<br/>      &lt;IonModal isOpen={showModal}&gt;<br/>        &lt;MyModal closeAction={closeModal}&gt;&lt;/MyModal&gt;<br/>      &lt;/IonModal&gt;<br/>      &lt;IonButton onClick={() =&gt; setShowModal(true)}&gt;<br/>        Show Modal<br/>      &lt;/IonButton&gt;<br/>    &lt;/IonContent&gt;<br/>  );<br/>};<br/><br/>export default Tab1;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0638" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><p id="b470" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一个可能的解决方案是使用DOM引用来消除模态。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4270" class="nh md it nc b gy ni nj l nk nl">import React, {RefObject} from 'react';<br/>import {IonHeader, IonContent, IonToolbar, IonTitle, IonButtons, IonButton, IonIcon} from '@ionic/react';<br/><br/>class MyModal extends React.Component {<br/><br/>  headerRef: RefObject&lt;HTMLIonHeaderElement&gt; = React.createRef();<br/><br/>  async closeModal() {<br/>    if (!this.headerRef || !this.headerRef.current) {<br/>      return;<br/>    }<br/><br/>    await (this.headerRef.current.closest('ion-modal') as <br/>                HTMLIonModalElement).dismiss();<br/>  }<br/><br/>  render() {<br/>    return &lt;&gt;<br/>      &lt;IonHeader ref={this.headerRef}&gt;<br/>        &lt;IonToolbar color="primary"&gt;<br/>          &lt;IonTitle&gt;My Modal&lt;/IonTitle&gt;<br/>          &lt;IonButtons slot="end"&gt;<br/>            &lt;IonButton onClick={() =&gt; this.closeModal()}&gt;<br/>              &lt;IonIcon name="close" slot="icon-only"&gt;&lt;/IonIcon&gt;<br/>            &lt;/IonButton&gt;<br/>          &lt;/IonButtons&gt;<br/>        &lt;/IonToolbar&gt;<br/>      &lt;/IonHeader&gt;<br/>      &lt;IonContent className="ion-padding"&gt;<br/>        &lt;p&gt;This is the modal content 3.&lt;/p&gt;<br/>      &lt;/IonContent&gt;<br/>    &lt;/&gt;<br/>  };<br/><br/>}<br/><br/>export default MyModal;</span></pre><p id="85ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的方法有一个效果，我们的页面上用于显示目的的<code class="fe mz na nb nc b">state</code>，可能最终不再与模态的有效状态同步，因为我们使用DOM关闭了它。</p><p id="4bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服这种情况，我们可以在对话框关闭后同步信息。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8951" class="nh md it nc b gy ni nj l nk nl">import React, {useState} from 'react';<br/>import {IonModal, IonButton, IonContent} from '@ionic/react';<br/>import MyModal from './MyModal';<br/><br/>export const Tab1: React.FC = () =&gt; {<br/>  const [showModal, setShowModal] = useState(false);<br/><br/>  return (<br/>    &lt;IonContent&gt;<br/>      &lt;IonModal isOpen={showModal}<br/>        onDidDismiss={() =&gt; setShowModal(false)}&gt;<br/>        &lt;MyModal&gt;&lt;/MyModal&gt;<br/>      &lt;/IonModal&gt;<br/>      &lt;IonButton onClick={() =&gt; setShowModal(true)}&gt;<br/>        Show Modal<br/>      &lt;/IonButton&gt;<br/>    &lt;/IonContent&gt;<br/>  );<br/>};<br/><br/>export default Tab1;</span></pre><p id="e450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但不幸的是，这种方法有一个缺点。</p><p id="6f2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们修改状态以同步它时，我们的组件将被“重新呈现”。因此，它比使用<code class="fe mz na nb nc b">callback</code>的解决方案性能稍差，这就是为什么我发现了第一个解决方案清洁剂。</p><p id="b689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">附注:昨天晚上，我花了几个小时尝试将<code class="fe mz na nb nc b">shouldComponentUpdate</code>和<code class="fe mz na nb nc b">React.Memo</code>包在模态组件周围，以便在模态被解除后状态被修改时不会再次呈现页面，但没有成功。</p><p id="61bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可能的，同样，我也很乐意听到这方面的任何建议。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed47" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">发布后更新</h1><p id="7765" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://twitter.com/elylucas" rel="noopener ugc nofollow" target="_blank"> Ely Lucas </a>谢天谢地<a class="ae ky" href="https://dev.to/elylucas/comment/imio" rel="noopener ugc nofollow" target="_blank">回复了</a>这篇博文，给出了一个有效且有趣的评论:实际上，不使用按钮也可以解除modal。例如通过敲击Esc键或点击背景。</p><p id="b579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在任何情况下都必须定义一个<code class="fe mz na nb nc b">onDidDismiss</code>的处理程序，以便在对话框关闭后同步打开状态(正如我们在上一章中所做的)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f71a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概述</h1><p id="071a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过<code class="fe mz na nb nc b">callack</code>或<code class="fe mz na nb nc b">reference</code>按钮关闭模态都是可能的。</p><p id="1c52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，监听<code class="fe mz na nb nc b">onDidDismiss</code>以将状态设置为<code class="fe mz na nb nc b">false</code>，即使它触发了重新渲染，也是一种强制。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2677" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">传递参数</h1><p id="8816" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在前面的例子中，我们已经使用了一个属性来传递一个回调以关闭模式。同样，我们可以使用相同的方法来定义任何其他属性。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f547" class="nh md it nc b gy ni nj l nk nl">import React from 'react';<br/>import {IonHeader, IonContent, IonToolbar, IonTitle, IonButtons, IonButton, IonIcon} from '@ionic/react';<br/><br/>type MyModalProps = {<br/>  closeAction: Function;<br/>  text: string;<br/>}<br/><br/>class MyModal extends React.Component&lt;MyModalProps&gt; {<br/><br/>  render() {<br/>    return &lt;&gt;<br/>      &lt;IonHeader&gt;<br/>        &lt;IonToolbar color="primary"&gt;<br/>          &lt;IonTitle&gt;My Modal&lt;/IonTitle&gt;<br/>          &lt;IonButtons slot="end"&gt;<br/>            &lt;IonButton onClick={() =&gt; this.props.closeAction()}&gt;<br/>              &lt;IonIcon name="close" slot="icon-only"&gt;&lt;/IonIcon&gt;<br/>            &lt;/IonButton&gt;<br/>          &lt;/IonButtons&gt;<br/>        &lt;/IonToolbar&gt;<br/>      &lt;/IonHeader&gt;<br/>      &lt;IonContent className="ion-padding"&gt;<br/>        &lt;p&gt;{this.props.text}&lt;/p&gt;<br/>      &lt;/IonContent&gt;<br/>    &lt;/&gt;<br/>  };<br/><br/>}<br/><br/>export default ({closeAction, text}: { closeAction: Function, text: string }) =&gt; (<br/>  &lt;MyModal closeAction={closeAction} text={text}&gt;<br/>  &lt;/MyModal&gt;<br/>)</span></pre><p id="f68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，将页面中的任何其他参数传递给我们的模态组件。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="31d7" class="nh md it nc b gy ni nj l nk nl">import React, {useState} from 'react';<br/>import {IonModal, IonButton, IonContent} from '@ionic/react';<br/>import MyModal from './MyModal';<br/><br/>export const Tab1: React.FC = () =&gt; {<br/>  const [showModal, setShowModal] = useState(false);<br/><br/>  async function closeModal() {<br/>    await setShowModal(false);<br/>  }<br/><br/>  return (<br/>    &lt;IonContent&gt;<br/>      &lt;IonModal isOpen={showModal}&gt;<br/>        &lt;MyModal closeAction={closeModal}<br/>                 text="This is the updated modal content."&gt;<br/>        &lt;/MyModal&gt;<br/>      &lt;/IonModal&gt;<br/>      &lt;IonButton onClick={() =&gt; setShowModal(true)}&gt;<br/>        Show Modal<br/>      &lt;/IonButton&gt;<br/>    &lt;/IonContent&gt;<br/>  );<br/>};<br/><br/>export default Tab1;</span></pre><p id="8bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到无限和更远的地方。</p><p id="aeef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div></div>    
</body>
</html>