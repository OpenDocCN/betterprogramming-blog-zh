<html>
<head>
<title>Building an Icon System in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中构建图标系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-an-icon-system-in-react-16757d73cc35?source=collection_archive---------0-----------------------#2022-07-10">https://betterprogramming.pub/building-an-icon-system-in-react-16757d73cc35?source=collection_archive---------0-----------------------#2022-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b815" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">反应图标</h2><div class=""/><div class=""><h2 id="a637" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">将svg图标从<code class="fe ko kp kq kr b">`symbol`</code>迁移到React组件:从Figma或Sketch开始构建图标集的简单Gulp工作流</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/ace610a0786409a7cbd64e9fc9163ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xH2n9R9TQBGtzOfh"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="59bc" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当我开始一个新项目时，我总是面临的任务之一就是定义一个图标系统。</p><p id="d896" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">作为一名设计师，我的目标是控制项目的所有元素，图标是非常常见的。</p><p id="f239" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">设计特定的图标并不总是必要的，我经常使用许多在线可用的库中的一个，但是当不可能时，除了设计方面，我总是试图优化它们的使用。</p><p id="05f9" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">多年来，我定义了一个工作流，从设计到编码，除了不可避免的持续更新，它仍然有效。我从图标字体到svg，从Illustrator到Sketch，但是开发过程几乎是一样的。</p><h1 id="fc01" class="mf mg iq bd mh mi mj mk ml mm mn mo mp kf mq kg mr ki ms kj mt kl mu km mv mw bi translated">经典的方式</h1><p id="5dbf" class="pw-post-body-paragraph lj lk iq ll b lm mx ka lo lp my kd lr ls mz lu lv lw na ly lz ma nb mc md me ij bi translated">我第一次接触图标是使用<a class="ae li" href="https://www.sitepoint.com/create-an-icon-font-illustrator-icomoon/" rel="noopener ugc nofollow" target="_blank">图标字体</a>，但是当svg成为一个可行的选择时，我工作流程的目标变成了创建一个SVG文件，其中所有图标都被存储为<a class="ae li" href="https://css-tricks.com/svg-symbol-good-choice-icons/" rel="noopener ugc nofollow" target="_blank">符号</a>。</p><p id="c8fd" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了更好地解释，我创建了一个带有三个图标的示例<em class="nc">草图</em>文件(当然，您的图标集将有更多)。你可以用Figma、InkScape、Affinity Designer、Illustrator或任何你喜欢的软件以同样的方式开始。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nd"><img src="../Images/44f5276d439aeda1a38af771fae7df63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a33tZFxeHuMxcD9FCQnB-w.png"/></div></div></figure><p id="79c9" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我现在使用Sketch，因为它似乎是简单性和输出质量之间的最佳折衷，尽管它经常需要额外的关注来消除SVG代码中经常(实际上太频繁)生成的<code class="fe ko kp kq kr b">transform</code>属性。</p><p id="e5f1" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">对于复杂的图标，我暂时切换到Illustrator或InkScape，然后将结果粘贴到Sketch中。</p><p id="3270" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Bjango网站上有两篇有趣的文章可以帮助您选择更好的解决方案:<a class="ae li" href="https://bjango.com/articles/svgpassthroughprecision/" rel="noopener ugc nofollow" target="_blank"> SVG直通精度</a>和<a class="ae li" href="https://bjango.com/articles/svgexports/" rel="noopener ugc nofollow" target="_blank">理想SVG导出</a>。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="54dc" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">绘制并导出图标后，每个图标都会有一个SVG文件，如下所示:</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="6e63" class="np mg iq kr b be nq nr l ns nt">&lt;svg  width="96" height="96" viewBox="0 0 96 96"&gt;<br/>  &lt;polyline fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="6" points="12 46.782 39.491 80 84.164 17"/&gt;<br/>&lt;/svg&gt;</span></pre><p id="163b" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">目标是通过创建一个新的svg文件来合并所有的SVG文件，它将每个图标封装在一个带有唯一id的<em class="nc">标签</em>中:</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="cbde" class="np mg iq kr b be nq nr l ns nt">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg  xmlns:xlink="http://www.w3.org/1999/xlink"&gt;<br/>  &lt;symbol id="check" viewBox="0 0 96 96"&gt;<br/>    &lt;polyline points="12 46.782 39.491 80 84.164 17" /&gt;<br/>  &lt;/symbol&gt;<br/>  &lt;symbol id="plus" viewBox="0 0 96 96"&gt;<br/>    &lt;line x1="12" x2="84.853" y1="48.692" y2="48.119" /&gt;<br/>    &lt;line x1="48.692" x2="48.119" y1="85" y2="11" /&gt;<br/>  &lt;/symbol&gt;<br/>  &lt;symbol id="x" viewBox="0 0 96 96"&gt;<br/>    &lt;line x1="17" x2="81" y1="14" y2="78" /&gt;<br/>    &lt;line x1="17" x2="81" y1="78" y2="14" /&gt;<br/>  &lt;/symbol&gt;<br/>&lt;/svg&gt;</span></pre><p id="2d7a" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">请注意:</p><ul class=""><li id="905f" class="nu nv iq ll b lm ln lp lq ls nw lw nx ma ny me nz oa ob oc bi translated">我们现在有了一个独特的<code class="fe ko kp kq kr b">svg</code>标签来包装所有的图标</li><li id="3832" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated">每个图标都被包裹在一个<code class="fe ko kp kq kr b">symbol</code>标签中</li><li id="bf49" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated">每个<code class="fe ko kp kq kr b">symbol</code>标签都有一个唯一的<code class="fe ko kp kq kr b">id</code>(对应于原始文件名)和一个<code class="fe ko kp kq kr b">viewBox</code>属性</li><li id="cc47" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated">每个表象属性(<code class="fe ko kp kq kr b">fill</code>、<code class="fe ko kp kq kr b">stroke*</code>等)都被移除</li></ul><p id="9571" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在，我们能够以这种方式在html页面中嵌入图标:</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="f29c" class="np mg iq kr b be nq nr l ns nt">&lt;svg role="img"&gt;<br/>  &lt;title&gt;Plus icon&lt;/title&gt;<br/>  &lt;use xlink:href="icons.svg#check"&gt;&lt;/use&gt;<br/>&lt;/svg&gt;</span></pre><p id="7f91" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><em class="nc">(这是一个非常基础的实现，你可能需要添加更多的属性来提高可访问性，看看</em> <a class="ae li" href="https://css-tricks.com/accessible-svg-icons/" rel="noopener ugc nofollow" target="_blank"> <em class="nc">可访问的SVG图标</em> </a> <em class="nc">)。</em></p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="a19d" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果你只有三个图标，就像我的例子，手动合并它们并不是不可能的，但是如果你有很多图标并且/或者需要不止一次地更新它们，那就不是一个可行的选择。</p><p id="4f1b" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我已经建立了一个简单的<a class="ae li" href="https://gulpjs.com/" rel="noopener ugc nofollow" target="_blank"> Gulp </a>文件来完成所有的工作。除了吞咽本身，它还需要:</p><ul class=""><li id="aac6" class="nu nv iq ll b lm ln lp lq ls nw lw nx ma ny me nz oa ob oc bi translated"><a class="ae li" href="https://www.npmjs.com/package/gulp-svgmin" rel="noopener ugc nofollow" target="_blank">一饮而尽——svgmin</a>，一饮而尽实施<a class="ae li" href="https://github.com/svg/svgo" rel="noopener ugc nofollow" target="_blank"> SVGO </a></li><li id="844c" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated">将所有的svg文件合并成一个文件</li><li id="ae5e" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated"><a class="ae li" href="https://www.npmjs.com/package/gulp-rename" rel="noopener ugc nofollow" target="_blank">吞咽-重命名</a>重命名我们的输出文件</li></ul><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="0cb8" class="np mg iq kr b be nq nr l ns nt">/* eslint-env node */<br/><br/>const gulp = require('gulp')<br/>  ,rename = require('gulp-rename')<br/>  ,svgstore = require('gulp-svgstore')<br/>  ,svgmin = require('gulp-svgmin')<br/>;<br/><br/>const svg_files_folder = './icons-svg-files',<br/>  output_file = 'icons.svg',<br/>  dest_folder = './';<br/><br/>gulp.task('default', function() {<br/><br/>  return gulp.src([svg_files_folder + '/*.svg'])<br/><br/>    // https://github.com/svg/svgo/tree/master/plugins<br/>    // https://github.com/svg/svgo#built-in-plugins<br/>    .pipe(svgmin({<br/>      multipass: true,<br/>      full: true,<br/>      plugins: [<br/>        { name: 'cleanupIDs', params: { remove: true, minify: true } }<br/>        , 'removeDoctype'<br/>        , 'removeComments'<br/>        , 'removeTitle'<br/>        , 'removeDimensions'<br/>        , 'collapseGroups'<br/>        , { name: 'cleanupNumericValues', params: { floatPrecision: 4 } }<br/>        , { name: 'convertColors', params: { names2hex: true, rgb2hex: true } }<br/>        , 'removeStyleElement'<br/>        , 'removeEmptyContainers'<br/>        , { name: 'removeAttrs', params: { attrs: ['(filter|fill|stroke|fill-rule|stroke-linecap|stroke-linejoin|stroke-width|transform|style|class|data.*)', 'svg:(width|height)'] } }<br/>        , 'removeUselessDefs'<br/>      ]<br/>    }))<br/>    .pipe(svgstore())<br/>    .pipe( rename(output_file) )<br/>    .pipe(gulp.dest(dest_folder));<br/>});</span></pre><p id="54c5" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们看看我们的gulp文件:</p><ul class=""><li id="45b0" class="nu nv iq ll b lm ln lp lq ls nw lw nx ma ny me nz oa ob oc bi translated">首先，我们实例化三个变量(<code class="fe ko kp kq kr b">svg_files_folder</code>、<code class="fe ko kp kq kr b">output_file</code>和<code class="fe ko kp kq kr b">dest_folder</code>)，以便于脚本的重用</li><li id="1c9c" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated"><code class="fe ko kp kq kr b">gulp.src</code>从源文件夹中收集所有svg文件(<code class="fe ko kp kq kr b">svg_files_folder</code>)</li><li id="9008" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated"><code class="fe ko kp kq kr b">svgmin</code> svgmin根据输入的参数将SVGO应用于所有文件(其他信息参见<a class="ae li" href="https://github.com/svg/svgo#readme" rel="noopener ugc nofollow" target="_blank"> SVGO GitHub自述文件</a>)</li><li id="9764" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated">SVG文件现在可以被重命名并保存到<code class="fe ko kp kq kr b">dest_folder</code></li></ul><p id="1588" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><em class="nc">关于安装和使用Gulp的最详细信息，请看一下</em> <a class="ae li" href="https://gulpjs.com/docs/en/getting-started/quick-start/" rel="noopener ugc nofollow" target="_blank"> <em class="nc">快速启动页面</em> </a> <em class="nc">。</em></p><p id="d41f" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这样，不管你有多少个图标，你都可以非常快速地构建你的图标文件，你只需要执行gulpfile:</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="5f99" class="np mg iq kr b be nq nr l ns nt">cd path/to/your/project/folder<br/>gulp <br/># or <br/># gulp --gulpfile your-gulpfile-name.js<br/># if your file is not called `gulpfile.js`</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="a9df" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这种方法肯定比使用多个文件或在HTML页面中嵌入svg代码更方便:http请求的数量会减少，SVG文件可以被缓存。</p><p id="337c" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">另一方面，您必须手动检查未使用的图标，这可能会不必要地使文件变得混乱。此外，设计包含<code class="fe ko kp kq kr b">use</code>标签的SVG有时会很棘手。</p><h1 id="1b53" class="mf mg iq bd mh mi mj mk ml mm mn mo mp kf mq kg mr ki ms kj mt kl mu km mv mw bi translated">切换到反应</h1><p id="d1cf" class="pw-post-body-paragraph lj lk iq ll b lm mx ka lo lp my kd lr ls mz lu lv lw na ly lz ma nb mc md me ij bi translated">通过使用web组件模块，我们不再需要在一个文件中收集所有图标，也不必检查未使用的图标。</p><p id="532e" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们可以将svg文件直接包含在我们的<code class="fe ko kp kq kr b">jsx</code>文件中，或者更好的是，为每个图标创建一个组件以便于使用，如下所示:</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="25c0" class="np mg iq kr b be nq nr l ns nt">import PropTypes from 'prop-types';<br/><br/>function Check(props) {<br/>  return (<br/>    &lt;svg  width="96" height="96" viewBox="0 0 96 96" <br/>      fill="none" <br/>      stroke={props.stroke}<br/>      strokeLinecap={props.strokeLinecap} <br/>      strokeLinejoin={props.strokeLinejoin}  <br/>      strokeWidth={props.strokeWidth} <br/>    &gt;<br/>      &lt;polyline points="12 46.782 39.491 80 84.164 17"/&gt;<br/>    &lt;/svg&gt;<br/>  );<br/>}<br/><br/>Check.propTypes = {<br/>  stroke            : PropTypes.string.isRequired,<br/>  strokeLinecap     : PropTypes.string,<br/>  strokeLinejoin    : PropTypes.string,<br/>  strokeWidth       : PropTypes.number.isRequired<br/>};<br/>Check.defaultProps = {<br/>  stroke            : '#000',<br/>  strokeLinecap     : 'round',<br/>  strokeLinejoin    : 'round',<br/>  strokeWidth       : 6<br/>};<br/><br/>export default Check;</span></pre><p id="8e79" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe ko kp kq kr b">Props</code>不是真正需要的，但是它们允许你在其他项目中重用你的组件。您也可以使用css并以另一种方式构建您的组件，但是无论您选择哪种方式，您都必须处理几个svg文件。如果您意识到构建完文件后，需要进行修改，该怎么办呢？</p><p id="a42a" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">幸运的是，我们的gulpfile，经过一些调整，可以再次帮助我们。</p><p id="b7d0" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">第一步与前面的工作流程相同(准备并保存图标)，所有的更改都在gulpfile和我们需要准备的两个新文件中。</p><p id="173b" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">目标是为每个图标创建一个组件。因为它们将有相同的<code class="fe ko kp kq kr b">&lt;svg&gt;</code>标签，我们将删除它，使所有的图标共享同一个标签。</p><p id="2bbc" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在处理结束时，我们的目录树将如下所示:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e9ac28cbf505e5f0ce211a9017f414e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PZbr4vH3jpaYhSoGCeWBoQ.png"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">来自<a class="ae li" href="https://phosphoricons.com/" rel="noopener ugc nofollow" target="_blank">https://phosphoricons.com/</a>的图标</p></figure><p id="e094" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是一个生成组件的例子(<code class="fe ko kp kq kr b">check.jsx</code>):</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="95a7" class="np mg iq kr b be nq nr l ns nt">/* GENERATED FILE */<br/><br/>import BaseIcon from '../base-icon';<br/><br/>export default function (props) {<br/>  return (<br/>    &lt;BaseIcon {...props}&gt;<br/>      &lt;polyline points="12 46.782 39.491 80 84.164 17"/&gt;<br/>    &lt;/BaseIcon&gt;<br/>  );<br/>}</span></pre><p id="565b" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是导入的<code class="fe ko kp kq kr b">base-icon</code>文件(由所有<code class="fe ko kp kq kr b">.jsx</code>图标文件导入):</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="c9ed" class="np mg iq kr b be nq nr l ns nt">export default function (props) {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;svg  <br/>        width="2em" height="2em" viewBox='0 0 96 96'<br/>        stroke="currentColor" stroke-width="4" fill="none"&gt;<br/>        {props.children}<br/>      &lt;/svg&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="bf9b" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><strong class="ll ja">免责声明</strong>:注意，如上所述，本文仅旨在定义一种生成和管理图标的方法，所有风格和设计方面的考虑都留待以后的文章。详细地说，分配给<code class="fe ko kp kq kr b">base-icon.jsx</code>文件的属性的唯一目的是使查看结果更加容易和直接。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="3e56" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在让我们看看新的Gulpfile以及它是如何变化的:</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="2dec" class="np mg iq kr b be nq nr l ns nt">/* eslint-env node */<br/><br/>const gulp = require('gulp')<br/>  ,replace = require('gulp-replace')<br/>  ,rename = require('gulp-rename')<br/>  ,svgmin = require('gulp-svgmin')<br/>  ,wrap = require("gulp-wrap")<br/>  ,fs = require('fs')<br/>;<br/><br/>const svg_files_folder = './icons-svg-files',<br/>  dest_folder = '../src/icon-components/',<br/>  jsx_template = './icon-components-template.jsx';<br/><br/>let icons_component_list = [];<br/><br/>gulp.task('icons_components', function () {<br/>  return gulp.src([<br/>    svg_files_folder + '/*.svg'<br/>  ])<br/>    .pipe(svgmin({<br/>      multipass: true,<br/>      full: true,<br/><br/>      // https://github.com/svg/svgo/tree/master/plugins<br/>      // https://github.com/svg/svgo#built-in-plugins<br/>      plugins: [<br/>        { name: 'cleanupIDs', params: { remove: true, minify: true } }<br/>        , 'removeDoctype'<br/>        , 'removeComments'<br/>        , 'removeTitle'<br/>        , 'removeDimensions'<br/>        , 'collapseGroups'<br/>        , { name: 'cleanupNumericValues', params: { floatPrecision: 4  } }<br/>        , { name: 'convertColors', params: { names2hex: true, rgb2hex: true } }<br/>        , 'removeStyleElement'<br/>        , 'removeEmptyContainers'<br/>        , { name: 'removeAttrs', params: { attrs: ['(filter|fill|stroke|fill-rule|stroke-linecap|stroke-linejoin|stroke-width|transform|style|class|data.*)', 'svg:(width|height)'] } }<br/>        , 'removeUselessDefs'<br/>      ]<br/>    }))<br/>    .pipe(replace(/&lt;\/?svg(.*?)&gt;/g, ''))<br/>    .pipe(wrap({ src: jsx_template}))<br/>    .pipe(rename(function (path) {<br/>      icons_component_list.push(path.basename);<br/>      path.extname = '.jsx';<br/>    }))<br/>    .pipe(gulp.dest(dest_folder + '/src'));<br/>});<br/><br/>gulp.task('icons_component_main', function(cb) {<br/><br/>  return fs.writeFile(dest_folder + '/icons.jsx',<br/>    '/* GENERATED FILE */\n\n' +<br/>    icons_component_list.map(item =&gt; {<br/><br/>      let module_name = (item.charAt(0).toUpperCase() + item.substr(1))<br/>        .replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });<br/><br/>      return `export { default as Icon${module_name} } from './src/${item}.jsx';`;<br/>    }).join('\n'),<br/>    cb);<br/>});<br/><br/>gulp.task('default',<br/>  gulp.series(<br/>    'icons_components',<br/>    'icons_component_main',<br/>  )<br/>);</span></pre><p id="141d" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">它不再需要<code class="fe ko kp kq kr b">svgstore</code>模块，而是使用:</p><ul class=""><li id="1f26" class="nu nv iq ll b lm ln lp lq ls nw lw nx ma ny me nz oa ob oc bi translated"><a class="ae li" href="https://www.npmjs.com/package/gulp-replace" rel="noopener ugc nofollow" target="_blank">吞咽-更换</a>以移除<code class="fe ko kp kq kr b">svg</code>标签</li><li id="e2cd" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated"><a class="ae li" href="https://www.npmjs.com/package/gulp-wrap" rel="noopener ugc nofollow" target="_blank">大口包装</a>用模板包装我们的<code class="fe ko kp kq kr b">jsx</code>文件</li><li id="dfce" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated"><a class="ae li" href="https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#file-system" rel="noopener ugc nofollow" target="_blank"> fs </a>，节点文件系统模块</li></ul><p id="d81c" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe ko kp kq kr b">output_file</code>变量已经被移除，但是我们添加了:<code class="fe ko kp kq kr b">jsx_template</code>(模板文件的路径)和<code class="fe ko kp kq kr b">icons_component_list</code>，这将收集图标的所有文件名来构建一个<em class="nc">聚合器模块</em>(稍后将详细介绍)。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="dfb5" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">第一个任务与其他gulpfile相同(访问svg文件并将svgo应用于所有这些文件)。</p><p id="62ed" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">注意，使用的<code class="fe ko kp kq kr b">svgmin</code>配置移除了(几乎)所有属性，如果你想保留其中一些属性，你可能需要一个模块(比如<a class="ae li" href="https://github.com/janjakubnanista/svg-to-jsx" rel="noopener ugc nofollow" target="_blank"> svg-to-jsx </a>)来使它们适应jsx语法(比如<code class="fe ko kp kq kr b">stroke-width</code>必须变成<code class="fe ko kp kq kr b">strokeWidth</code>)。</p><p id="41f8" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">下一步是使用<code class="fe ko kp kq kr b">gulp-replace</code>和一个简单的正则表达式(<code class="fe ko kp kq kr b">.pipe(replace(/&lt;\/?svg(.*?)&gt;/g, ''))</code>)删除<code class="fe ko kp kq kr b">svg</code>标签。</p><p id="8f77" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">然后我们可以使用<code class="fe ko kp kq kr b">gulp-wrap</code>将我们的模板(<code class="fe ko kp kq kr b">icon-components-template.jsx</code>)应用到结果代码中。</p><p id="d9c0" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如你所见，这真的很简单。您只需创建一个包含所需内容的文件，并在您想要放置生成的代码的位置插入一个占位符(<code class="fe ko kp kq kr b">&lt;%= contents %&gt;</code>)，剩下的工作将由<code class="fe ko kp kq kr b">gulp-wrap</code>完成(显然，如果您更改了模板，您将需要再次运行gulp)。</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="e52a" class="np mg iq kr b be nq nr l ns nt">/* GENERATED FILE */<br/><br/>import BaseIcon from '../base-icon';<br/><br/>export default function (props) {<br/>  return (<br/>    &lt;BaseIcon {...props}&gt;<br/>      &lt;%= contents %&gt;<br/>    &lt;/BaseIcon&gt;<br/>  );<br/>}</span></pre><p id="e975" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在，您可以在React应用程序中嵌入图标:</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="18ae" class="np mg iq kr b be nq nr l ns nt">import Check from './icon-components/src/check';<br/>import Plus from './icon-components/src/plus';<br/>import X from './icon-components/src/x';<br/><br/>function App() {<br/>  return (<br/>    &lt;div className="app"&gt;<br/>      &lt;h1&gt;React Icons example&lt;/h1&gt;<br/><br/>      &lt;p&gt;&lt;Check /&gt; &lt;Plus /&gt; &lt;X /&gt;&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre><p id="05f1" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是结果:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/dc1536309c8f9248f47eed7ceac7d170.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*mz8NkWeN6AXpot_1bTvO1A.png"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="591d" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">但是我们可以做得更好。你还记得<code class="fe ko kp kq kr b">icons_component_list</code>变量吗？我们在最后一个gulp任务(<code class="fe ko kp kq kr b">icons_component_main</code>)中用过。它的作用是建立一个集合所有图标的文件:</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="3f34" class="np mg iq kr b be nq nr l ns nt">/* GENERATED FILE */<br/><br/>export { default as IconCheck } from './src/check.jsx';<br/>export { default as IconPlus } from './src/plus.jsx';<br/>export { default as IconX } from './src/x.jsx';</span></pre><p id="a1e8" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在我们可以用一种更简洁的方式通过同一个文件导入所有图标(我也给所有图标名称添加了一个前缀<code class="fe ko kp kq kr b">Icon</code>，但这并不是真正需要的)。</p><pre class="kt ku kv kw gt nl kr nm bn nn no bi"><span id="0b34" class="np mg iq kr b be nq nr l ns nt">import './App.css';<br/>import {IconCheck, IconPlus, IconX} from './icon-components/icons';<br/><br/>function App() {<br/>  return (<br/>    &lt;div className="app"&gt;<br/>      &lt;h1&gt;React Icons example&lt;/h1&gt;<br/><br/>      &lt;p&gt;&lt;IconCheck /&gt; &lt;IconPlus /&gt; &lt;IconX /&gt;&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="8787" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><em class="nc"> React图标系统文章:</em></p><ol class=""><li id="746b" class="nu nv iq ll b lm ln lp lq ls nw lw nx ma ny me ok oa ob oc bi translated"><strong class="ll ja">在React中建立图标系统</strong> <em class="nc">(本文)</em></li><li id="a93c" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me ok oa ob oc bi translated"><strong class="ll ja">下一步:</strong><a class="ae li" href="https://medium.com/@massimo.cassandro/styling-icons-in-react-part-i-1a99207a7bc" rel="noopener">React中的样式图标—第一部分:从设计到代码</a></li><li id="0372" class="nu nv iq ll b lm od lp oe ls of lw og ma oh me ok oa ob oc bi translated"><a class="ae li" href="https://medium.com/me/stats/post/ddd3c8b328de" rel="noopener">React中的样式图标—第二部分:双色调和非方形图标</a></li></ol></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="c54a" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae li" href="https://medium.com/@massimo.cassandro/my-dev-publications-eacf6727e4a" rel="noopener"> <em class="nc">我的所有出版物</em> </a></p></div></div>    
</body>
</html>