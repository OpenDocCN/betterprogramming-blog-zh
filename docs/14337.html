<html>
<head>
<title>Navigating With Parcelable Arguments in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jetpack Compose中使用可打包参数导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/jetpack-compose-navigation-with-parcelable-arguments-5be907551848?source=collection_archive---------3-----------------------#2022-11-30">https://betterprogramming.pub/jetpack-compose-navigation-with-parcelable-arguments-5be907551848?source=collection_archive---------3-----------------------#2022-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ad34" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在您的Android应用中使用导航合成</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e30267e957b74f457db68c31cf6384d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9l9pVxi5esdkXu64ZDi3_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6221" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Android团队宣布使用<code class="fe lr ls lt lu b">Parcelable</code>在屏幕之间传递参数是一种反模式。但是许多人还不准备放弃…而且在另一个屏幕上显示之前保存所有数据也不方便。</p><p id="ba3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，您将学习一种使用Jetpack Compose导航库传递参数的简单方法。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="a128" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们看看谷歌为我们导航争论提供了什么。一个有足够样板代码的解决方案，但是我们必须将它与我的解决方案进行比较。</p><p id="3571" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，您需要将<a class="ae mc" href="https://developer.android.com/jetpack/compose/navigation" rel="noopener ugc nofollow" target="_blank">导航库</a>添加到项目中:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="24b7" class="mh mi iq lu b be mj mk l ml mm">dependencies {<br/>    def nav_version = "2.5.3"<br/><br/>    implementation("androidx.navigation:navigation-compose:$nav_version")<br/>}</span></pre><p id="0095" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这之后，我们应该创建导航图，其中<code class="fe lr ls lt lu b"><a class="ae mc" href="https://developer.android.com/reference/androidx/navigation/NavController" rel="noopener ugc nofollow" target="_blank">NavController</a></code>是控制导航栈的核心API。</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="06be" class="mh mi iq lu b be mj mk l ml mm">val navController = rememberNavController()<br/><br/>NavHost(navController = navController, startDestination = "profile") {<br/>    composable("profile") { Profile(/*...*/) }<br/>    composable("friendslist") { FriendsList(/*...*/) }<br/>    /*...*/<br/>}</span></pre><p id="d285" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">NavHost</code>将<code class="fe lr ls lt lu b">NavController</code>与一个导航图链接起来，该导航图指定了您应该能够在其中导航的组件。当你运行这个<code class="fe lr ls lt lu b">NavHost</code>时，它会从<code class="fe lr ls lt lu b">startDestination</code> ( <code class="fe lr ls lt lu b">profile</code>)开始。要进入下一个屏幕，您需要调用以下命令:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="c950" class="mh mi iq lu b be mj mk l ml mm">navController.navigate("friendslist")</span></pre><p id="d7ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来很简单，但这里有两个主要问题:</p><ol class=""><li id="e254" class="mn mo iq kx b ky kz lb lc le mp li mq lm mr lq ms mt mu mv bi translated">我们有<code class="fe lr ls lt lu b">String</code>作为一条在编写代码时可能导致错误的路径</li><li id="68c3" class="mn mo iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">没有样板文件，我们无法在屏幕间发送<code class="fe lr ls lt lu b">parcelable</code>，如这里的<a class="ae mc" href="https://stackoverflow.com/a/65619560/7205194" rel="noopener ugc nofollow" target="_blank">所示</a>。</li></ol><p id="62c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，现在我给你看我自己对这个问题的决定。</p><h1 id="656f" class="nb mi iq bd nc nd ne nf ng nh ni nj nk jw nl jx nm jz nn ka no kc np kd nq nr bi translated"><span class="l ns nt nu bm nv nw nx ny nz di"> P </span> <strong class="ak">为Parcelables提供Jetpack组合导航</strong></h1><p id="6f65" class="pw-post-body-paragraph kv kw iq kx b ky oa jr la lb ob ju ld le oc lg lh li od lk ll lm oe lo lp lq ij bi translated">首先，我们需要创建一个描述屏幕的抽象类。看起来是这样的:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="6af8" class="mh mi iq lu b be mj mk l ml mm">abstract class Screen(<br/>    open val route: String,<br/>    open val arguments: Bundle? = null<br/>) {<br/>    constructor(route: String, extra: Extra) : this(route, Bundle().apply { putParcelable(extra.key, extra.parcelable) })<br/><br/>    data class Extra(val key: String, val parcelable: Parcelable)<br/>}</span></pre><p id="4f44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">之后，我们需要创建自己的<code class="fe lr ls lt lu b">ComposeNavigator</code>实现:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="612d" class="mh mi iq lu b be mj mk l ml mm">@Navigator.Name("composable")<br/>public class ComposeNavigator : Navigator&lt;Destination&gt;()</span></pre><p id="e4e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<code class="fe lr ls lt lu b">Destination</code>是我们自己的类，它与原来的类不同，它接受带有参数的内容lambda:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="d693" class="mh mi iq lu b be mj mk l ml mm">@NavDestination.ClassType(Composable::class)<br/>public class Destination(<br/>   navigator: ComposeNavigator,<br/>   internal val content: @Composable (backStackEntry: NavBackStackEntry, arguments: Bundle?) -&gt; Unit<br/>) : NavDestination(navigator)</span></pre><p id="e370" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一步是创建一个<code class="fe lr ls lt lu b">NavController</code>来控制我们的屏幕:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="7126" class="mh mi iq lu b be mj mk l ml mm"><br/>public class NavExtrasHostController(context: Context, public val startDestination: Screen) :<br/>    NavHostController(context) {<br/><br/>    private val _currentScreensBackStack: MutableStateFlow&lt;MutableMap&lt;String, Screen&gt;&gt; =<br/>        MutableStateFlow(mutableMapOf(startDestination.route to startDestination))<br/><br/>    public val currentScreensBackStack: StateFlow&lt;Map&lt;String, Screen&gt;&gt; =<br/>        _currentScreensBackStack.asStateFlow()<br/><br/>    override fun popBackStack(): Boolean {<br/>        _currentScreensBackStack.update { screensMap -&gt;<br/>            screensMap.apply { remove(currentDestination?.route) }<br/>        }<br/>        return super.popBackStack()<br/>    }<br/><br/>    public fun navigate(screen: Screen, navOptions: NavOptions? = null) {<br/>        _currentScreensBackStack.update { it.apply { put(screen.route, screen) } }<br/>        navigate(route = screen.route, navOptions = navOptions)<br/>    }<br/>}</span></pre><p id="8d3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里你可以看到<code class="fe lr ls lt lu b">currentScreensBackStack</code>是一个地图，它在一个路线屏幕中存储了屏幕，允许我们在保持后退的同时沿着图表移动。当用户按back时，我们从后台堆栈中移除最后一个屏幕。</p><p id="f6c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以看到，一个新的功能导航，你可以添加下一个屏幕到<code class="fe lr ls lt lu b">currentScreensBackStack</code>。</p><p id="e89d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们将创建一个func，它允许我们创建自己的<code class="fe lr ls lt lu b">NavExtrasHostController</code>，但是在此之前，我们应该创建一个saver类，它可以在配置更改和进程死亡时保存和恢复<code class="fe lr ls lt lu b">NavExtrasHostController</code>:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="723f" class="mh mi iq lu b be mj mk l ml mm">private fun NavExtrasControllerSaver(<br/>    context: Context,<br/>    startDestination: Screen<br/>): Saver&lt;NavExtrasHostController, *&gt; = Saver&lt;NavExtrasHostController, Bundle&gt;(<br/>    save = { it.saveState() },<br/>    restore = { createNavExtrasController(context, startDestination).apply { restoreState(it) } }<br/>)</span></pre><p id="b57b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和<code class="fe lr ls lt lu b">createNavExtrasController()</code>功能:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="f3a5" class="mh mi iq lu b be mj mk l ml mm"><br/>private fun createNavExtrasController(context: Context, startDestination: Screen) =<br/>    NavExtrasHostController(context, startDestination = startDestination).apply {<br/>        navigatorProvider.addNavigator(ComposeNavigator())<br/>        navigatorProvider.addNavigator(DialogNavigator())<br/>    }</span></pre><p id="cfa1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这些步骤之后，我们可以创建记忆功能，它将创建出<code class="fe lr ls lt lu b">NavExtrasHostController</code>添加我们的<code class="fe lr ls lt lu b">ComposeNavigator</code>并使用<code class="fe lr ls lt lu b">NavExtrasControllerSaver</code>保存和恢复它:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="2b6b" class="mh mi iq lu b be mj mk l ml mm">@Composable<br/>public fun rememberNavExtrasController(<br/>    startDestination: Screen,<br/>    vararg navigators: Navigator&lt;out NavDestination&gt;<br/>): NavExtrasHostController {<br/>    val context = LocalContext.current<br/>    return rememberSaveable(<br/>        inputs = navigators,<br/>        saver = NavExtrasControllerSaver(context, startDestination)<br/>    ) {<br/>        createNavExtrasController(context, startDestination)<br/>    }.apply {<br/>        for (navigator in navigators) {<br/>            navigatorProvider.addNavigator(navigator)<br/>        }<br/>    }<br/>}</span></pre><p id="1e72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一步是创建我们自己的<code class="fe lr ls lt lu b">NavHost</code>:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="0a1b" class="mh mi iq lu b be mj mk l ml mm">@Composable<br/>public fun NavHost(<br/>    navController: NavExtrasHostController,<br/>    graph: NavGraph,<br/>    modifier: Modifier = Modifier<br/>) {<br/>    val lifecycleOwner = LocalLifecycleOwner.current<br/>    val viewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) {<br/>        "NavHost requires a ViewModelStoreOwner to be provided via LocalViewModelStoreOwner"<br/>    }<br/>    val onBackPressedDispatcherOwner = LocalOnBackPressedDispatcherOwner.current<br/>    val onBackPressedDispatcher = onBackPressedDispatcherOwner?.onBackPressedDispatcher<br/><br/>    // Setup the navController with proper owners<br/>    navController.setLifecycleOwner(lifecycleOwner)<br/>    navController.setViewModelStore(viewModelStoreOwner.viewModelStore)<br/>    if (onBackPressedDispatcher != null) {<br/>        navController.setOnBackPressedDispatcher(onBackPressedDispatcher)<br/>    }<br/>    // Ensure that the NavController only receives back events while<br/>    // the NavHost is in composition<br/>    DisposableEffect(navController) {<br/>        navController.enableOnBackPressed(true)<br/>        onDispose {<br/>            navController.enableOnBackPressed(false)<br/>        }<br/>    }<br/><br/>    // Then set the graph<br/>    navController.graph = graph<br/><br/>    val saveableStateHolder = rememberSaveableStateHolder()<br/><br/>    // Find the ComposeNavigator, returning early if it isn't found<br/>    // (such as is the case when using TestNavHostController)<br/>    val composeNavigator = navController.navigatorProvider.get&lt;Navigator&lt;out NavDestination&gt;&gt;(<br/>        ComposeNavigator.NAME<br/>    ) as? ComposeNavigator ?: return<br/>    val visibleEntries by remember(navController.visibleEntries) {<br/>        navController.visibleEntries.map {<br/>            it.filter { entry -&gt;<br/>                entry.destination.navigatorName == ComposeNavigator.NAME<br/>            }<br/>        }<br/>    }.collectAsState(emptyList())<br/>    val screensBackStack by navController.currentScreensBackStack.collectAsState()<br/><br/>    val backStackEntry = visibleEntries.lastOrNull()<br/><br/>    var initialCrossfade by remember { mutableStateOf(true) }<br/>    if (backStackEntry != null) {<br/>        // while in the scope of the composable, we provide the navBackStackEntry as the<br/>        // ViewModelStoreOwner and LifecycleOwner<br/>        Crossfade(backStackEntry.id, modifier) {<br/>            val lastEntry = visibleEntries.last { entry -&gt;<br/>                it == entry.id<br/>            }<br/>            // We are disposing on a Unit as we only want to dispose when the CrossFade completes<br/>            DisposableEffect(Unit) {<br/>                if (initialCrossfade) {<br/>                    // There's no animation for the initial crossfade,<br/>                    // so we can instantly mark the transition as complete<br/>                    visibleEntries.forEach { entry -&gt;<br/>                        composeNavigator.onTransitionComplete(entry)<br/>                    }<br/>                    initialCrossfade = false<br/>                }<br/>                onDispose {<br/>                    visibleEntries.forEach { entry -&gt;<br/>                        composeNavigator.onTransitionComplete(entry)<br/>                    }<br/>                }<br/>            }<br/><br/>            lastEntry.LocalOwnersProvider(saveableStateHolder) {<br/>                val previousScreenExtras = screensBackStack[lastEntry.destination.route]?.arguments<br/><br/>                val newLastEntryArguments = (lastEntry.arguments ?: Bundle()).apply {<br/>                    if (previousScreenExtras != null) {<br/>                        putAll(previousScreenExtras)<br/>                    }<br/>                }<br/><br/>                (lastEntry.destination as Destination).content(lastEntry, newLastEntryArguments)<br/>            }<br/>        }<br/>    }<br/><br/>    val dialogNavigator = navController.navigatorProvider.get&lt;Navigator&lt;out NavDestination&gt;&gt;(<br/>        Companion.NAME<br/>    ) as? DialogNavigator ?: return<br/><br/>    // Show any dialog destinations<br/>    DialogHost(dialogNavigator)<br/>}</span></pre><p id="cc55" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">带有路由的重载函数:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="5711" class="mh mi iq lu b be mj mk l ml mm">@Composable<br/>public fun NavExtrasHost(<br/>    navController: NavExtrasHostController,<br/>    modifier: Modifier = Modifier,<br/>    route: String? = null,<br/>    builder: NavGraphBuilder.() -&gt; Unit<br/>) {<br/>    NavHost(<br/>        navController,<br/>        remember(route, navController.startDestination.route, builder) {<br/>            navController.createGraph(navController.startDestination.route, route, builder)<br/>        },<br/>        modifier<br/>    )<br/>}</span></pre><p id="4db4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这些步骤之后，我们需要创建一个<code class="fe lr ls lt lu b">composable </code>函数来发送参数给内容:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="91c5" class="mh mi iq lu b be mj mk l ml mm">public fun NavGraphBuilder.composable(<br/>    route: String,<br/>    arguments: List&lt;NamedNavArgument&gt; = emptyList(),<br/>    deepLinks: List&lt;NavDeepLink&gt; = emptyList(),<br/>    content: @Composable (backStackEntry: NavBackStackEntry, arguments: Bundle?) -&gt; Unit<br/>) {<br/>    addDestination(<br/>        Destination(provider[ComposeNavigator::class], content).apply {<br/>            this.route = route<br/>            arguments.forEach { (argumentName, argument) -&gt;<br/>                addArgument(argumentName, argument)<br/>            }<br/>            deepLinks.forEach { deepLink -&gt;<br/>                addDeepLink(deepLink)<br/>            }<br/>        }<br/>    )<br/>}</span></pre><p id="9e3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们已经更新了<code class="fe lr ls lt lu b">composable</code>函数，并将我们的参数添加到导航中。</p><h1 id="5e9d" class="nb mi iq bd nc nd ne nf ng nh ni nj nk jw nl jx nm jz nn ka no kc np kd nq nr bi translated"><span class="l ns nt nu bm nv nw nx ny nz di">H</span>T14】如何使用</h1><p id="75b2" class="pw-post-body-paragraph kv kw iq kx b ky oa jr la lb ob ju ld le oc lg lh li od lk ll lm oe lo lp lq ij bi translated">在开始使用我们的导航库实现之前，我们应该描述一下我们的屏幕。代码如下:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="1cc3" class="mh mi iq lu b be mj mk l ml mm">data class ProfilePage(val id: String) : Screen(PROFILE_ROUTE, Screen.Extra(PROFILE_EXTRAS_KEY, Profile(id))) {<br/><br/>    @Parcelize<br/>    data class Profile(val id: String) : Parcelable<br/><br/>    companion object {<br/>        const val PROFILE_ROUTE = "profile"<br/><br/>        const val PROFILE_EXTRAS_KEY = "profile_extras_key"<br/><br/>        @Composable<br/>        fun Page(profile: Profile) {<br/>            Text(profile.id)<br/>        }<br/>    }<br/>}<br/><br/>const val FRIENDS_LIST_ROUTE: String = "friendsList"<br/><br/>object FriendsList : Screen(FRIENDS_LIST_ROUTE) {<br/><br/>    @Composable<br/>    fun Page(navigateNextScreen: (String) -&gt; Unit) {<br/>        LazyColumn {<br/>            items(10) {<br/>                Text(it.toString(), modifier = Modifier<br/>                    .fillParentMaxWidth()<br/>                    .clickable { navigateNextScreen(it.toString()) })<br/>            }<br/><br/>        }<br/>    }<br/>}</span></pre><p id="5576" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这之后，我们应该实现<code class="fe lr ls lt lu b">NavExtrasHost</code>，仅此而已:</p><pre class="kg kh ki kj gt md lu me bn mf mg bi"><span id="d7ed" class="mh mi iq lu b be mj mk l ml mm">val navController = rememberNavExtrasController(startDestination = FriendsList)<br/>NavExtrasHost(navController = navController) {<br/>    composable(ProfilePage.PROFILE_ROUTE) { _, arguments -&gt;<br/>        val profile: Profile = arguments?.getParcelable(PROFILE_EXTRAS_KEY) ?: return@composable<br/>            ProfilePage.Page(profile)<br/>        }<br/><br/>    composable(FriendsList.route) { _, _ -&gt;<br/>        FriendsList.Page(navigateNextScreen = { navController.navigate(ProfilePage(it)) })<br/>    }<br/>}</span></pre><p id="66fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，现在您可以使用<code class="fe lr ls lt lu b">parcelable</code>参数进行导航。</p><p id="6b79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">仅此而已。感谢阅读。</p></div></div>    
</body>
</html>