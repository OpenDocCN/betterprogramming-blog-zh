<html>
<head>
<title>Sets and Hashes in Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis中的集合和散列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sets-and-hashes-in-redis-abf747cabfb5?source=collection_archive---------1-----------------------#2020-10-06">https://betterprogramming.pub/sets-and-hashes-in-redis-abf747cabfb5?source=collection_archive---------1-----------------------#2020-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbd4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的应用选择正确的数据类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc1d58069fc7f53497e1ed6d6e9cc497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euR8W12cZ6OMb9v2bVj6uQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3562" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天的主题是Redis中的集合和散列。这是Redis中最有用的两种数据类型，它们经常被开发人员忽略。理解它们背后的基本概念很重要，因为选择正确的数据类型在尝试扩展应用程序时会有很大帮助。</p><p id="0d51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我将使用<a class="ae lu" href="https://github.com/andymccurdy/redis-py" rel="noopener ugc nofollow" target="_blank"> Redis-Py </a>来展示这些功能。无论您使用哪种编程语言，其背后的概念都是一样的。Redis-Py使用与原始命令相同的函数调用名称，除了一些小的例外。你可以在下面的链接找到<a class="ae lu" href="https://redis.io/clients" rel="noopener ugc nofollow" target="_blank">支持的编程语言的完整列表。</a></p><div class="lv lw gp gr lx ly"><a href="https://redis.io/clients" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">雷迪斯</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">StackExchange的COM包装。Redis允许在COM环境中使用Redis，如经典ASP (ASP 3.0)使用…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">redis.io</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2d02" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">设置</h1><p id="8d6f" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">确保您的本地计算机上安装了Redis。本地机器必须包含具有最低配置设置的Linux发行版。</p><h2 id="280f" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">自己编译</h2><p id="e817" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">您可以使用以下命令在您的机器上下载并编译它(编写本文时版本为6.0.8):</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="063f" class="nr mv it oe b gy oi oj l ok ol">wget http://download.redis.io/releases/redis-6.0.8.tar.gz<br/>tar xzf redis-6.0.8.tar.gz<br/>cd redis-6.0.8<br/>make</span></pre><p id="8c21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成后，您应该会看到一个<code class="fe om on oo oe b">src</code>文件夹。将工作目录更改为<code class="fe om on oo oe b">src</code>文件夹。</p><h2 id="e3d9" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">人的本质</h2><p id="8e2c" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">对于Ubuntu用户，安装如下:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="95dd" class="nr mv it oe b gy oi oj l ok ol">sudo apt-get update <br/>sudo apt-get install redis-server</span></pre><h2 id="10b9" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">正在启动Redis服务器</h2><p id="2cdc" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">完成后，用下面的命令启动Redis服务器:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="582f" class="nr mv it oe b gy oi oj l ok ol">redis-server</span></pre><p id="7f18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了检查您的Redis服务器是否在工作，请使用以下命令启动命令行界面:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="52d5" class="nr mv it oe b gy oi oj l ok ol">redis-cli</span></pre><p id="d8f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Redis提示符下向它发送一个<code class="fe om on oo oe b">ping</code>命令:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="86dc" class="nr mv it oe b gy oi oj l ok ol">redis&gt; ping</span></pre><p id="70b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您的Redis服务器返回<code class="fe om on oo oe b">PONG</code>，则它工作正常。</p><h2 id="472c" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">redispy</h2><p id="283f" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">你可以通过<code class="fe om on oo oe b">pip install</code>轻松安装Redis-Py。强烈建议您在继续之前创建一个虚拟环境。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="e620" class="nr mv it oe b gy oi oj l ok ol">pip install redis</span></pre><p id="28cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使用它，您需要导入它并传递适当的配置。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="58bd" class="nr mv it oe b gy oi oj l ok ol">import redis</span><span id="7cc9" class="nr mv it oe b gy op oj l ok ol">r = redis.Redis(host="localhost", password='password', port=6379, db=0)</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="245f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">设置</h1><p id="6b66" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在Redis中，集合只是字符串的集合，分为有序和无序两类。在本教程中，我们只是探索无序集。集合中的每个元素称为<code class="fe om on oo oe b">member</code>。集合的一个主要特征是它不允许重复成员。向集合中添加相同的元素没有任何效果。因此，在将特定成员添加到集合之前，不需要检查它是否存在于集合中。</p><p id="befa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，您可以执行大多数针对集合的操作，如交集和并集。如果您需要计算或合并成千上万的数据，这是非常有用的。例如，假设您已经收集了平台A和平台b中用户使用的所有标签，您可以在查询数据时调用intersect函数。这比在应用程序中查询所有内容并执行交集要干净和优化得多。</p><p id="d115" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当处理大量唯一标识的数据点时，集合是理想的选择，例如用于身份验证的ID号和电子商务产品的标签。您可以将所有ID号建模为单个键中的元素，而不是为每个ID声明多个键。</p><h2 id="c498" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">初始化</h2><p id="4554" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">让我们通过初始化以下变量来测试一下。第一个变量表示用户的id列表，而第二个变量保存管理员的id。用户可以是管理员，也可以通过ID <code class="fe om on oo oe b">1001</code>显示。根据您的偏好，您可以使用Python集合而不是列表。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="6853" class="nr mv it oe b gy oi oj l ok ol">user_id = ["1001", "1002", "1003", "1004", "1005"]<br/>admin_id = ["1001", "1006", "1007"]</span></pre><h2 id="966d" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">添加新的键或元素</h2><p id="fef6" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">向现有的添加一个新的键或元素非常简单明了。只需调用<code class="fe om on oo oe b">sadd</code>函数:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="804d" class="nr mv it oe b gy oi oj l ok ol">for key in user_id:<br/>    r.sadd("user", key)</span><span id="53dd" class="nr mv it oe b gy op oj l ok ol">for key in admin_id:<br/>    r.sadd("admin", key)</span></pre><h2 id="06d5" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">检查键/元素是否存在</h2><p id="ab7e" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">通常，您应该使用<code class="fe om on oo oe b">exists()</code>来检查Redis数据库中是否存在一个键。对于Redis集合，它带有<code class="fe om on oo oe b">sismember()</code>,可以用来确定一个元素是否存在于集合中。如果存在则返回<code class="fe om on oo oe b">1</code>，否则返回<code class="fe om on oo oe b">0</code>。此外，如果键不存在，它也将返回0。为了方便起见，Redis-Py自动将返回的结果映射为布尔值:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="4bf0" class="nr mv it oe b gy oi oj l ok ol">r.sismember("user", "1004")<br/># True</span><span id="0e2b" class="nr mv it oe b gy op oj l ok ol">r.sismember("admin", "1004") <br/># False</span></pre><h2 id="c6fc" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">获取所有元素</h2><p id="5de2" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如果您正在寻找一种快速获取集合中所有元素的方法，<code class="fe om on oo oe b">smembers()</code>是您的正确选择:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="67ca" class="nr mv it oe b gy oi oj l ok ol">r.smembers("user")<br/># {b'1001', b'1004', b'1002', b'1005', b'1003'}</span></pre><h2 id="05dc" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">获取元素的数量</h2><p id="6441" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">从逻辑上讲，您可以使用<code class="fe om on oo oe b">smembers()</code>提取所有元素，并通过Python中的<code class="fe om on oo oe b">len()</code>计算元素的数量。但是，如果您只想知道元素的总数，这种方法是无效的。幸运的是，Redis为这样的用例提供了一个名为<code class="fe om on oo oe b">scard()</code>的特殊函数。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8459" class="nr mv it oe b gy oi oj l ok ol">r.scard("user")<br/># 5</span></pre><h2 id="f8ec" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">差异</h2><p id="cbf0" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">正如我前面提到的，当查询数据时，可以在Redis内部直接执行一些set操作。例如，您可以通过下面的代码片段找到<code class="fe om on oo oe b">user</code>集合和<code class="fe om on oo oe b">admin</code>集合之间的差异:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="ab2f" class="nr mv it oe b gy oi oj l ok ol">r.sdiff("user", "admin")<br/># {b'1003', b'1004', b'1002', b'1005'}</span></pre><h2 id="f106" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">交集</h2><p id="3408" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">同样，您可以使用<code class="fe om on oo oe b">sinter()</code>来识别两个集合之间的公共元素。以下示例说明了如何获取同时也是管理员的用户:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="4889" class="nr mv it oe b gy oi oj l ok ol">r.sinter("user", "admin")<br/># {b'1001'}</span></pre><h2 id="262d" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">联盟</h2><p id="7471" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">Redis集合中的另一个常见操作是<code class="fe om on oo oe b">sunion()</code>，它将两个集合中的所有元素组合在一起。返回的结果将不包含任何重复的成员:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="ceff" class="nr mv it oe b gy oi oj l ok ol">r.sunion("user", "admin")<br/># {b'1001', b'1004', b'1002', b'1005', b'1007', b'1003', b'1006'}</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="331c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">混杂</h1><p id="6bd9" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">与集合不同，Redis中的散列是用来存储复杂数据的。哈希表示为字符串字段和字符串值之间的映射。因此，它们是存储Python中的字典等对象的完美数据类型。</p><p id="b771" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，带有姓名和年龄字段的<code class="fe om on oo oe b">User</code>对象。与其对姓名和年龄使用不同的键，不如使用包含所有必需字段的单个散列更有效。不用初始化不同的<code class="fe om on oo oe b">&lt;key&gt;:&lt;id&gt;:&lt;field&gt;</code>字符串键，比如<code class="fe om on oo oe b">userhash:1001:name</code>，您可以简单地使用<code class="fe om on oo oe b">{“userhash:1001”: {“name”: “Alice”}}</code>创建它。</p><p id="c298" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，官方文档建议尽可能使用散列，因为<a class="ae lu" href="https://redis.io/topics/memory-optimization" rel="noopener ugc nofollow" target="_blank">小散列编码在一个非常小的空间里</a>。哈希能够存储许多元素，也可以用来存储其他实例，而不是对象。</p><h2 id="56f9" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">初始化</h2><p id="ce0a" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">让我们创建一个新的Python字典作为测试数据的一部分。为了简单起见，我将用一个名称字段来初始化它:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="65e7" class="nr mv it oe b gy oi oj l ok ol">hash_data = {"userhash:1001": {"name": "Alice"}, "userhash:1002": {"name": "Bonnie"}, "userhash:1003": {"name": "Cassie"}, "userhash:1004": {"name": "Dolores"}, "userhash:1005": {"name": "Erika"}}</span></pre><h2 id="a72c" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">添加新哈希</h2><p id="46f8" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">Redis提供了两个不同的内置函数来设置hash中的键值对:</p><ul class=""><li id="5136" class="oq or it la b lb lc le lf lh os ll ot lp ou lt ov ow ox oy bi translated"><code class="fe om on oo oe b">hset</code> —用值设置散列中的字段(键)。如果散列不存在，将创建一个新的散列。如果字段(键)已经存在于现有散列中，它将被新值覆盖。</li><li id="ca61" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><code class="fe om on oo oe b">hmset</code> —类似于<code class="fe om on oo oe b">hset</code>，但它允许在一个命令中有多个输入参数。该函数已被弃用，从现在开始，您应该使用<code class="fe om on oo oe b">hset</code>作为单个或多个输入参数。</li></ul><p id="e6f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在撰写本文时，Redis-py提供了更新的<code class="fe om on oo oe b">hset</code>,其结构如下:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="ab06" class="nr mv it oe b gy oi oj l ok ol">def hset(self, name, key=None, value=None, mapping=None)</span></pre><ul class=""><li id="6814" class="oq or it la b lb lc le lf lh os ll ot lp ou lt ov ow ox oy bi translated"><code class="fe om on oo oe b">name</code> —哈希的标识符。</li><li id="97b3" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><code class="fe om on oo oe b">key</code> —散列中字段的名称。</li><li id="d888" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><code class="fe om on oo oe b">value</code> —相应字段的值。</li><li id="c59d" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><code class="fe om on oo oe b">mapping</code> —接受字典作为输入。用作<code class="fe om on oo oe b">hmget</code>的替代，用于将字典解析为相应的键值对。</li></ul><p id="80a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，您可以使用:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="ab5f" class="nr mv it oe b gy oi oj l ok ol">r.hset("userhash:1001", None, None, {"name": "Alice"})</span></pre><p id="e14f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="ee3a" class="nr mv it oe b gy oi oj l ok ol">r.hset("userhash:1001", mapping={"name": "Alice"})</span></pre><p id="2e44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">向Redis服务器添加新散列。</p><p id="7771" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行以下命令循环遍历我们的数据以添加新的散列:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="e17a" class="nr mv it oe b gy oi oj l ok ol">for key in hash_data:<br/>    r.hset(key, mapping=hash_data[key])</span></pre><h2 id="1f6c" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">检查哈希/字段是否存在</h2><p id="93b1" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">要检查现有散列或散列中字段的存在，您应该使用<code class="fe om on oo oe b">hexists()</code>:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="a3ff" class="nr mv it oe b gy oi oj l ok ol">r.hexists("userhash:1001", "name")<br/># True</span></pre><h2 id="a185" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">获取特定字段的值</h2><p id="ac74" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated"><code class="fe om on oo oe b">hget()</code>是hash中最重要的函数之一，用于获取特定字段的值。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="0945" class="nr mv it oe b gy oi oj l ok ol">r.hget("userhash:1001", "name")<br/># b'Alice'</span></pre><h2 id="d4b9" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">获取所有字段</h2><p id="f053" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如果您正在寻找一种快速简单的方法来获取hash中所有字段的名称，那么对于这种用例来说，<code class="fe om on oo oe b">hkeys()</code>是最好的选择。在Redis-Py中，它将返回包含所有字段的列表:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8379" class="nr mv it oe b gy oi oj l ok ol">r.hkeys("userhash:1001")<br/># [b'name']</span></pre><h2 id="7773" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">获取所有字段和值</h2><p id="1ec8" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">您可以通过<code class="fe om on oo oe b">hgetall()</code>函数轻松获得单个散列的所有字段及其各自的值。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="5ae9" class="nr mv it oe b gy oi oj l ok ol">r.hgetall("userhash:1001")<br/># {b'name': b'Alice'}</span></pre><h2 id="8592" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">处理嵌套数据结构</h2><p id="b713" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在撰写本文时，Redis本身不支持嵌套数据结构。如果您的数据包含嵌套字典，最好的方法是用<code class="fe om on oo oe b">json.dumps</code>进行序列化，并将其存储为一个字符串。然后，从Redis中检索后，您可以简单地用<code class="fe om on oo oe b">json.loads</code>将其反序列化。</p><p id="8522" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您也可以使用<code class="fe om on oo oe b">pickle</code>来实现这一点，但是在存储用户输入时必须小心，因为它容易出现远程代码执行漏洞。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ad1b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">临时演员</h1><p id="e556" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">这里有一些可以在Redis中使用的有用命令。</p><h2 id="e33f" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">从Redis服务器获取所有密钥</h2><p id="feff" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">最新版本的Redis自带<code class="fe om on oo oe b">scan_iter()</code>功能，比<code class="fe om on oo oe b">keys()</code>更值得推荐的选择。<code class="fe om on oo oe b">keys()</code>应仅在开发中用于调试目的。在Redis-Py中，您可以使用以下代码片段获取并打印数据库中的所有键:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="d2cc" class="nr mv it oe b gy oi oj l ok ol">for key in r.scan_iter():<br/>    print(key)</span></pre><h2 id="6217" class="nr mv it bd mw ns nt dn na nu nv dp ne lh nw nx ng ll ny nz ni lp oa ob nk oc bi translated">清除数据库</h2><p id="c590" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">有两个函数可以用来清除Redis数据库。</p><ul class=""><li id="871f" class="oq or it la b lb lc le lf lh os ll ot lp ou lt ov ow ox oy bi translated"><code class="fe om on oo oe b">flushdb</code> —清除并移除当前数据库中的所有密钥。</li><li id="eaf1" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><code class="fe om on oo oe b">flushall</code> —清除并移除服务器中所有数据库的所有密钥。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e7eb" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="8486" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">让我们回顾一下今天所学的内容。</p><p id="81e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们首先简单解释了Redis中的集合和散列数据类型。然后，我们执行了设置和安装Redis服务器的必要步骤。</p><p id="dc9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们继续深入探讨Redis集合背后的基本概念。我们测试了一些有用的功能，比如设置和从集合中检索数据。</p><p id="ab53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们研究了Redis散列，这是在Python中存储字典等对象的理想选择。为了提高效率，强烈建议使用哈希而不是字符串日期类型。</p><p id="ea96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读这篇文章。希望下次能再见到你！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="12f2" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">参考</h1><ul class=""><li id="14f2" class="oq or it la b lb nm le nn lh pe ll pf lp pg lt ov ow ox oy bi translated"><a class="ae lu" href="https://redis.io/topics/data-types-intro" rel="noopener ugc nofollow" target="_blank">Redis数据类型和抽象的介绍</a></li><li id="1dfb" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><a class="ae lu" href="https://redis.io/topics/data-types" rel="noopener ugc nofollow" target="_blank"> Redis —数据类型</a></li><li id="7baa" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><a class="ae lu" href="https://stackoverflow.com/questions/13557075/redis-set-vs-hash" rel="noopener ugc nofollow" target="_blank">stack overflow—Redis set vs hash</a></li></ul></div></div>    
</body>
</html>