<html>
<head>
<title>Garbage Collection and the Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">垃圾收集和浏览器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/garbage-collection-and-the-browser-43bb60a2553c?source=collection_archive---------20-----------------------#2020-01-02">https://betterprogramming.pub/garbage-collection-and-the-browser-43bb60a2553c?source=collection_archive---------20-----------------------#2020-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4dc3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在Chrome、Safari等后台存储和移除数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/99d23fc555887b58751232dbeeb2f5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCxs5pWOtbxzxwFZ6UIKOA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@creativeexchange?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae kv" href="https://unsplash.com/s/photos/cleaning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的创意交流</a></p></figure><p id="5f42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当某样东西出现在你的网页上时，它被储存在哪里？在现代浏览器中，内存分配的过程是自动的，但这并不意味着开发人员应该想当然地认为这个过程是理所当然的，并期望它每次都能完美地工作。理解JavaScript和浏览器如何处理内存对于解决臃肿的应用程序和创建快速动态的内容至关重要。</p><p id="df11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript分两个阶段在浏览器中呈现内容:编译阶段，然后是执行阶段。在编译阶段，JS引擎遍历代码，找到每个变量或函数标识表达式，在内存中为它们分配一个位置，并建立从标识符到内存位置的引用。这些是空白引用，本质上是实际对象的占位符。</p><p id="f2c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在执行阶段，引擎再次一行一行地遍历代码，给每个变量赋值并调用函数。标识符相对于它们在作用域链中的位置被解析<a class="ae kv" href="http://davidshariff.com/blog/javascript-scope-chain-and-closures/" rel="noopener ugc nofollow" target="_blank">，从局部作用域开始，向上通过父作用域，直到到达第一个可访问的标识符，或者直到到达可能的最高作用域(其中父作用域为空)。)</a></p><p id="0b21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于在小规模应用程序中启动和运行代码来说很好，但是当应用程序开始变大并且内存中存储了更多的对象时会发生什么呢？计算机内存是有限的，需要有一种方法来清理没有使用的内存，以便为更多的数据腾出空间，并且不限制同一台机器上运行的其他应用程序的内存。</p><p id="7816" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在低级语言中，这种内存管理是由开发人员手动完成的，这是一个相当复杂的过程，会导致应用程序具有非常明确和微调的内存使用。对于更高级的语言，比如JavaScript，这种内存管理是由一种叫做<em class="ls">垃圾收集器</em>的结构自动执行的<a class="ae kv" href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/dee93e92aef212fd6fc79dbc5b15ede3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVea5N58kpbLdCfjeeVuAg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/" rel="noopener ugc nofollow" target="_blank">极客为极客</a>进行标记和扫描的可视化</p></figure><p id="da57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览器使用了许多技术来判断内存中哪些对象是需要的，现代浏览器使用的<a class="ae kv" href="https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/" rel="noopener ugc nofollow" target="_blank">技术被称为标记和清除算法。</a>浏览器引擎周期性地从根对象(全局范围)开始，找到从根引用的每个对象，然后检查从这些对象引用的所有对象，等等。，向下移动作用域链并记下哪些对象是可达的或不可达的。<a class="ae kv" href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/" rel="noopener ugc nofollow" target="_blank">使用深度优先的搜索方法，所有可到达的对象被标记为<em class="ls">真</em>，所有不可到达的被标记为<em class="ls">假</em>。这就是所谓的标记阶段。</a></p><p id="e1e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，引擎在内存堆中移动，清除所有不可到达的对象，释放它们的内存位置供将来使用。这是扫描阶段。</p><p id="d622" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这有助于您理解浏览器在运行应用程序时是如何分配和清除内存的。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="0ffc" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">资源</h1><div class="mt mu gp gr mv mw"><a href="https://scotch.io/tutorials/understanding-hoisting-in-javascript" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">理解JavaScript中的提升</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">在本教程中，我们将研究JavaScript中著名的提升机制是如何发生的。在我们开始之前，让我们…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">scotch.io</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk kp mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">内存管理</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">像C这样的低级语言有手工内存管理原语，比如malloc()和free()。相比之下…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">developer.mozilla.org</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk kp mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://www.chromium.org/developers/memory-usage-backgrounder" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">内存使用背景介绍Chromium项目</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">Chromium内存使用如果您在Chromium中测量内存，这里是一些背景信息。多流程模型…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.chromium.org</p></div></div><div class="nf l"><div class="nm l nh ni nj nf nk kp mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">ECMAScript 2015语言规范- ECMA-262第6版</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">编辑描述</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.ecma-international.org</p></div></div><div class="nf l"><div class="nn l nh ni nj nf nk kp mw"/></div></div></a></div></div></div>    
</body>
</html>