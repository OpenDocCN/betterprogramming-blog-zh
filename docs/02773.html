<html>
<head>
<title>Simple Audio Processing in Python With Pydub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pydub在Python中进行简单的音频处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-audio-processing-in-python-with-pydub-c3a217dabf11?source=collection_archive---------0-----------------------#2019-12-30">https://betterprogramming.pub/simple-audio-processing-in-python-with-pydub-c3a217dabf11?source=collection_archive---------0-----------------------#2019-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1328" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python中过滤、混合、加载和保存音频</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e309fe834463c73e8b93163bc9dfc381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cNQXdQcUAs5nnz7T"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@adigold1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adi Goldstein </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="88f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，在脚本或应用程序中，我们需要执行音频处理任务。</p><p id="cb6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些可能包括:</p><ul class=""><li id="0c32" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">加载和保存不同类型的音频文件。</li><li id="774b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">分段分割或附加音频。</li><li id="c42b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">混合来自两个不同音频文件的音频。</li><li id="1015" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更改音量或声相设置。</li><li id="0b9b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">应用简单的效果，如滤镜。</li><li id="a327" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">产生音频音调。</li></ul><p id="63db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都可以使用<a class="ae ky" href="https://github.com/jiaaro/pydub" rel="noopener ugc nofollow" target="_blank"> Pydub </a>来实现，这是一个简单、<em class="mj"> </em>设计良好的Python模块，用于音频操作。Pydub是我学习基本音频脚本的首选工具。用PyDub作者的话说:</p><blockquote class="mk"><p id="b513" class="ml mm it bd mn mo mp mq mr ms mt lu dk translated">" Pydub让你以一种不愚蠢的方式对音频做一些事情."</p></blockquote></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="f7ed" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">装置</h1><p id="922c" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">Pydub可以和<a class="ae ky" href="https://pypi.org/project/pip/" rel="noopener ugc nofollow" target="_blank"> pip </a>一起安装，这是Python所有最新版本都附带的。只需键入:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="8f7c" class="od nc it nz b gy oe of l og oh">pip install pydub</span></pre><p id="3671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们准备使用Pydub。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="622f" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">加载和播放音频</h1><p id="eff7" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">Pydub中的主类是<code class="fe oi oj ok nz b">AudioSegment</code>。一个<code class="fe oi oj ok nz b">AudioSegment</code>作为一个容器来加载、操作和保存音频。</p><p id="bb1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建我们的第一个音频脚本，我们需要一个测试音频文件，这可以是任何支持的格式，如WAV，MP3或AIFF。出于本教程的目的，我们将使用<code class="fe oi oj ok nz b">urllib.request</code>下载一个文件作为脚本的一部分。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="110c" class="od nc it nz b gy oe of l og oh">import urllib.request</span><span id="c983" class="od nc it nz b gy ol of l og oh">from pydub import AudioSegment<br/>from pydub.playback import play</span><span id="4d5b" class="od nc it nz b gy ol of l og oh"># Download an audio file<br/>urllib.request.urlretrieve("<a class="ae ky" href="https://tinyurl.com/wx9amev" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/wx9amev</a>", "metallic-drums.wav")</span><span id="0204" class="od nc it nz b gy ol of l og oh"># Load into PyDub<br/>loop = AudioSegment.from_wav("metallic-drums.wav")</span><span id="149f" class="od nc it nz b gy ol of l og oh"># Play the result<br/>play(loop)</span></pre><p id="cf4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果听起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="5eb2" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">基本音频操作</h1><p id="38a4" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在我们已经加载了一些音频，我们可以进行各种形式的操作:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="3be6" class="od nc it nz b gy oe of l og oh"># Repeat 2 times<br/>loop2 = loop * 2</span><span id="a9ef" class="od nc it nz b gy ol of l og oh"># Get length in milliseconds<br/>length = len(loop2)</span><span id="0147" class="od nc it nz b gy ol of l og oh"># Set fade time<br/>fade_time = int(length * 0.5)</span><span id="df88" class="od nc it nz b gy ol of l og oh"># Fade in and out<br/>faded = loop2.fade_in(fade_time).fade_out(fade_time)</span></pre><p id="7c84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在最后一行代码中，我们是如何链接<code class="fe oi oj ok nz b">fade_in()</code>和<code class="fe oi oj ok nz b">fade_out()</code>操作的。这是因为每个操作都返回一个<code class="fe oi oj ok nz b">AudioSegment</code>实例。</p><p id="4e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果听起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="35b5" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">分层音频</h1><p id="0000" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">除了操纵单个音频段，我们还可以用不同的音量和声相设置对不同的段进行分层和混合。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="9e18" class="od nc it nz b gy oe of l og oh"># Download another loop<br/>urllib.request.urlretrieve("https://tinyurl.com/yx3k5kw5", "beat.wav")</span><span id="7439" class="od nc it nz b gy ol of l og oh"># Load into PyDub<br/>beat = AudioSegment.from_wav("beat.wav")</span><span id="4e39" class="od nc it nz b gy ol of l og oh"># Mix with our original loop<br/>mixed = beat[:length].overlay(loop2)</span></pre><p id="8ca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在最后一行，我们使用Python“slice”操作符将<code class="fe oi oj ok nz b">beat</code>分割为<code class="fe oi oj ok nz b">length</code>毫秒。</p><p id="a347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为我们的<code class="fe oi oj ok nz b">beat</code> <code class="fe oi oj ok nz b">AudioSegment</code>是<code class="fe oi oj ok nz b">loop2</code>的两倍长。通过<code class="fe oi oj ok nz b">length</code>切片意味着我们将<code class="fe oi oj ok nz b">beat</code>的前半部分与<code class="fe oi oj ok nz b">loop2</code>混合。</p><p id="edd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果听起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是向<code class="fe oi oj ok nz b">overlay()</code>提供<code class="fe oi oj ok nz b">loop=True</code>参数。这将根据需要自动循环较短的线段，以与较长的线段对齐。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="1d70" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">应用效果</h1><p id="a567" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在下一个示例中，我们将通过对音频应用声相、过滤和反转效果来将所有内容组合在一起。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="8ada" class="od nc it nz b gy oe of l og oh"># Filter the beat at 3kHz<br/>filtered = beat.low_pass_filter(3000)</span><span id="f055" class="od nc it nz b gy ol of l og oh"># Mix loop2 with a reversed, panned version<br/>loop = loop2.reverse().pan(-0.5).overlay(loop2.pan(0.5))</span><span id="5744" class="od nc it nz b gy ol of l og oh"># Mix our filtered beat with the new loop at -3dB<br/>final = filtered.overlay(loop2 - 3, loop=True)</span></pre><p id="7b18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们对<code class="fe oi oj ok nz b">pan()</code>方法的论证中，我们提供了一个在<code class="fe oi oj ok nz b">-1</code>和<code class="fe oi oj ok nz b">1</code>之间的值，其中<code class="fe oi oj ok nz b">-1</code>在左边，<code class="fe oi oj ok nz b">1</code>在右边，<code class="fe oi oj ok nz b">0</code>在中间。</p><p id="c812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果听起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4d93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步，我们可以将新的音频循环保存到一个新文件中。这可以是任何支持的音频格式:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="200e" class="od nc it nz b gy oe of l og oh">final.export("final.mp3", format="mp3")</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="3043" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">合成音调</h1><p id="1a4a" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">除了加载和处理音频文件，Pydub还可以合成新的音调。</p><p id="1846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些可以是任何频率的正弦波、方波或锯齿波。它还会产生白噪声。音调可以变成<code class="fe oi oj ok nz b">AudioSegment</code>并像常规音频文件一样组合。</p><p id="adb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们将使用<code class="fe oi oj ok nz b">Sine</code>类为和声序列中的前15个音程生成正弦音调。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="97a0" class="od nc it nz b gy oe of l og oh"># Create an empty AudioSegment<br/>result = AudioSegment.silent(duration=0)</span><span id="da1d" class="od nc it nz b gy ol of l og oh"># Loop over 0-14<br/>for n in range(15):</span><span id="833e" class="od nc it nz b gy ol of l og oh">    # Generate a sine tone with frequency 200 * n<br/>    gen = Sine(200 * n)</span><span id="3d89" class="od nc it nz b gy ol of l og oh">    # AudioSegment with duration 200ms, gain -3<br/>    sine  = gen.to_audio_segment(duration=200).apply_gain(-3)</span><span id="6e3c" class="od nc it nz b gy ol of l og oh">    # Fade in / out<br/>    sine = sine.fade_in(50).fade_out(100)</span><span id="b7ac" class="od nc it nz b gy ol of l og oh">    # Append the sine to our result<br/>    result += sine</span><span id="ea8b" class="od nc it nz b gy ol of l og oh"># Play the result<br/>play(result)</span></pre><p id="56d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们如何使用<code class="fe oi oj ok nz b">+=</code>操作符将每个200毫秒的正弦音调附加到空段的末尾。</p><p id="170b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果听起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="2d90" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">缺点</h1><p id="f34c" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">Pydub非常适合简单的音频任务。然而，如果你想做更复杂的处理，如加快或减慢声音，改变音高，或应用时变效果，这不是最好的选择。</p><p id="ff94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，Pydub的优势之一是它的纯Python实现。这最大限度地减少了本机依赖性。</p><p id="8eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这样做的一个缺点是Pydub不是很高效。为了尽可能快地处理大量文件，最好使用<a class="ae ky" href="http://sox.sourceforge.net" rel="noopener ugc nofollow" target="_blank"> SoX </a>或<a class="ae ky" href="https://github.com/rabitt/pysox" rel="noopener ugc nofollow" target="_blank"> PySoX </a>。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="f9b8" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">完整代码示例</h1><p id="2d79" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">本教程的完整代码可以在这个要点中找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">完整代码示例</p></figure><p id="e865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你对好的Python音频框架或者Pydub的好应用有什么建议，我很乐意在下面的评论中听到。</p></div></div>    
</body>
</html>