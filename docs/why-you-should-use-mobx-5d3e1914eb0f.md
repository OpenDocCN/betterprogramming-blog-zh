# 为什么应该使用 MobX

> 原文：<https://betterprogramming.pub/why-you-should-use-mobx-5d3e1914eb0f>

## react 状态管理解决方案的比较

![](img/6aaeec381d66d02cf00592ba09f20012.png)

这些年来，我使用过各种状态管理库(使用或不使用 react ),但在过去几年中，MobX 是我的首选解决方案——从简单的玩具应用程序到由多个团队构建的复杂应用程序，我甚至在非 react (Vue.js)的框架中使用它。

为什么我经常使用它？我将通过列举 MobX 的优势，并将每个优势与我认为的替代解决方案的缺点进行比较，来尝试回答这个问题(因为这更适合 react 用户，所以我将它与 redux 和使用上下文的状态管理进行比较)

本文假设您熟悉 MobX 及其工作原理，如果您不熟悉，您应该阅读 [MobX 文档](https://mobx.js.org/README.html#introduction)。

## 目录

*   [优点](#f25a)
    –[MobX 具有最少的样板文件](#91bb)
    –[MobX 总是呈现最少的必需组件](#324e)
    –[MobX 不需要您更改代码](#2957)
    –[MobX 很容易组合](#2957)
    –[逻辑不应该是视图层的一部分](#a5c0)
    –[MobX 不限于全局状态【T23](#7a3d)
*   [缺点](#6750)
    –[MobX 不具备不变性](#2944)
    –[MobX 更难跟踪和调试](#0ad3)

# MobX 的优势

## MobX 有最少的样板文件

Redux 因其样板文件而臭名昭著。redux 中有一个简单的 api 调用方法，每个应用程序都有这样或那样的形式:

要做一些非常简单的事情，需要很多代码，而且这还是在我们添加最小的库以使 redux 在重要的应用程序中可用之前，比如*redux-thunk*/*redux-saga*、 *reselect* (用于模块化)和 *normalizr* (用于规范化)。

相反，做同样事情的 MobX 商店应该这样写:

对于那些想知道这与之前的 *redux* 示例功能完全相同的人来说。除了更加简洁之外，它也更加清晰和直接，没有额外的功能会向你袭来。

与 *redux* 的例子不同，它会自动记忆，并且不需要 *thunk* 或 *saga* 在真正的应用程序中工作。(虽然它没有正常化，但需要做更多的工作)

有各种各样的尝试来减少样板文件——从 redux 本身，如 *actionCreatorCreator* (我一听到这个名字就害怕)到成熟的传统库，如 *ducks* 。不幸的是，他们要么没有实现他们的主张，要么没有得到太多的欢迎。

大量样板代码并不局限于创建*redux*reducer 的逻辑层部分。它还被添加到消费者部分——反应组件:

React 中状态管理的另一个选项是使用上下文 api。

让我们用上下文和钩子做一个相同的 api 例子:

这与 *MobX* 的例子没有太大区别——我们只添加了`createContext`和`Context.Provider`。然而，我们需要使用`Context.Provider`和`useContext`每次我们想要的状态，需要单独使用。

您的应用程序增长得越多，状态在树中的位置越靠前，这种情况就越常见，直到您的顶级组件看起来像这样:

如果你遵循 Kent C. Dodds 关于如何构建状态的指导方针，你可能会说这不应该发生，因为状态只应该尽可能地接近用法，而不是所有的都应该留在顶部。

不幸的是，我发现许多常见的用例需要将状态提升到应用程序的顶部——任何需要在应用程序的两个部分(如主窗口和侧栏，或导航栏)显示的内容，例如:通知/消息，验证(和我的用户信息)，显示订阅源/群组是否有更多项目要显示，在线用户的数量等等。

由于您经常将状态和动作与 MobX 捆绑在一起，因此它也吸取了道具钻取问题的教训——将单个道具向下发送几个级别比发送多个级别要容易得多，这使得您的较低级别组件更简单。

## MobX 总是呈现最少的必需组件

开箱即用，而且不费吹灰之力，MobX 将只重新渲染组件，当您更新商店的特定部分时，这些组件的渲染树实际上会发生变化。这意味着 MobX 永远不会渲染一个组件，除非它所依赖的道具改变了；它永远不会呈现实际发生变化的组件的父组件或它的兄弟组件。

要使用 redux 获得类似的功能，您需要使用困难且非常手动的记忆化过程。
让我们以前面提到的资源 api 为例。

如果我们天真地使用 redux，那么每次存储中的任何*资源*发生变化时，所有 *ResourceView* 组件都会重新呈现。

为了让它变得更有性能，我们需要使用记忆化。
让我们更改代码以使用*重新选择*库:

这更像是样板文件，但除此之外，很难使用它——您需要手动考虑哪些状态排列需要重新呈现您的组件，并把它们都考虑进去。

如果你的组件稍微复杂一点，那么维护和扩展也将成为一场噩梦(通常对于顶级组件如页面或导航来说就是如此)

使用上下文进行状态管理也会遇到类似的问题，如果您只想在实际资源发生变化时呈现`ResourceView`，那么您必须为每个 resourceId 创建一个`Context`(或者以某种方式重新构建您的应用程序)。

即使你做了所有这些，仍然有只有 MobX 能处理的边缘情况。
考虑这样一种情况，你想计算自从你的 fetch 在一个资源属性中被调用以来的秒数，这个资源属性在某个东西被加载时被更新，并且当它完成时显示请求花费了多长时间。

现在每秒钟`ResourceView`都会重新渲染，尽管我们只显示了`<Loader/>`组件，实际上没有任何变化。
重新选择和上下文根本无法确定，只要 *loading* 属性为真，就没有使用资源的其他属性。

然而，默认情况下，Mobx 不会重新渲染 *ResourceView* ，直到加载属性被更改——因为 MobX 只根据上次渲染中使用的属性进行渲染。

**注意:**MobX 的这个特性依赖于引用最底层的可观察组件，并且对于每个组件使用 observer(两者都是在 React 中使用 MobX 的自然方式)。
如果你在你的应用程序顶部引用一个可观察的值，并将该值作为道具发送到整个渲染树，那么每一次修改都会渲染所有内容。(所以不要那么做)

## MobX 不需要你修改代码

使用 MobX 看起来就像普通的 javascript，它不需要您更改代码或架构来支持它(不像 Redux，在较小程度上也不像 Context)。

事实上，这是一个不可见的抽象，在许多情况下，如果你去掉所有的 MobX 代码——*@ observable*， *@computed* ， *@action* 和*observer*decorator，你的代码将完全一样地工作(尽管会有一些性能问题)。

就其核心而言，MobX 根本不是一个状态管理解决方案，它是一种提高性能的元编程方法——因此，它完全不受如何构建代码的影响。
国家管理部分是你用它构建的。

有些人会认为这是一个缺点，但是我喜欢我的框架和库尽可能的非个人化，这样我就可以用我认为最好的方式来构建我的代码。

## MobX 很容易组装

redux 最大的问题之一，至少对我来说，是因为它的全局性质，很难编写它(composeReducers 肯定不是我所指的那种编写)。

redux 在可组合性方面有问题的主要原因是 redux 中存储内的路径很重要。按照使用 *redux* 的标准方式，你不能对`authentication/user/current`和`groups/user/manager`下的减速器模块使用相同的组件，即使商店本身完全相同。

如果你使用`connect`函数，你需要为同一个组件使用不同的 hoc，或者创建一个接受商店路径作为属性的组件。

这就是为什么规范化在 Redux 中如此重要——如果你总是把所有相同的对象放在相同的位置，你就不会有这个问题。
但这意味着每个需要显示共享对象的 reducer 都需要访问共享资源池——例如，加载用户的存储的每个 api 调用都需要访问共享用户存储。

这破坏了模块自包含的能力，但对大多数应用程序来说还不算太坏，问题真正出在开始使用第三方组件的时候。

由于第三方组件和模块无法预测你的商店将会是什么样子，所以如果没有一些可怕的诡计，他们就无法从你的商店中获益。这就是为什么 redux 没有很多流行的用户模块/库(比如简单的 REST 消费者),但是有很多中间件的原因之一。

redux 让可组合的实用程序库变得困难的一个很好的例子是 redux-forms——无论何时你创建或使用 redux-form 的实例，你必须给它在存储中的路径(并且它必须在 reducer 中是顶层)

## 逻辑不应该是视图层的一部分

在单页应用程序扩散之前，我就开始做 web UI，就像现在一样，有许多相互竞争的想法和框架。但是他们都同意的一件事是，你的视图层永远不应该包含逻辑(无论你把那个层中的对象称为控制器、Dao 还是 fat 模型)。

也许我很守旧，但是我仍然不能忍受在视图层内部看到逻辑——在 React 中，这意味着在组件内部。

有充分理由说明为什么不应该将逻辑放在视图层中:

*   **这使得重构**变得更加困难——如果你的组件知道你的商店的结构(这就是 redux 中的 *connect* 所发生的),那么任何改变结构的重构都需要你改变视图层。它还将应用程序的逻辑与视图的结构联系起来——如果同一个模型有不同类型的视图，这将是一个问题。
*   **如果视图负责应用程序的流程，那么维护和推理应用程序的流程就更加困难** —如果你的组件调用 api，那么要知道一个动作是否会导致 API 调用，你必须遵循生命周期和你的渲染树的渲染。当您的逻辑从视图中分离出来时，操作的结果更加确定，并且与您正在查看的页面或当前显示的组件无关
*   **它使得测试更慢更复杂** —如果你的视图负责调用 API 和执行业务逻辑，这意味着你需要启动视图(在这种情况下是 React 的渲染)来测试应用的流程。如果您的逻辑没有连接到视图，那么测试它通常就像测试一个普通的 javascript 函数一样简单。
*   **横切关注点更难使用**——像日志记录、缓存和错误处理这样的事情，当它们被分割在多个组件之间时，就更难做了。

如果您使用 *react-mobx* 的 inject 从 store inside 组件中提取状态，这些问题也是相关的。

## MobX 不局限于全局状态

不是所有的东西都应该在逻辑层。对于一个组件来说是本地的或者不在远处的组件之间共享的东西不应该保存在组件的状态中。
表单是组件本地的一个例子(除非它在会话之间持续存在)。

当在组件内部使用 MobX 时，可以获得与使用 MobX 获得全局状态相同的好处，即性能和没有样板文件。

让我们以一个使用钩子的简单表单为例:

# 缺点

## MobX 不能很好地处理不可变性

MobX 广泛依赖于突变来判断什么需要重新计算，因此在不变性方面表现不佳。并不是说不可变性不起作用，只是如果你经常使用不可变性，你会失去 MobX 提供的性能优势，并且使用它不会有什么好处。

## MobX 更难跟踪和调试

由于 MobX 使用“magic ”(也称为元编程)来跟踪正在使用和订阅的可观察对象，因此它对正常的调试和编程工具隐藏了许多实现。

当您想知道是什么导致了重新计算/重新呈现，以及如果您更改了什么，什么会重新呈现时，调试就成了一个问题。这是 redux 最强大的特性——所有的样板文件都是为了让应用程序流易于理解和维护。
对于非常大的应用程序以及多个开发人员在同一个应用程序上工作，MobX 会变得难以维护，需要制定严格的约定来保持状态和应用程序流的可管理性。

Redux 倒回时间和跟踪状态变化的能力也是维护和调试代码的一个非常强大的工具，这是 MobX 无法真正做到的(如果您使用 actions 和 strict mode，您将得到它的近似值，这很好，但还不够接近)。

MobX 状态树试图解决一些棘手的问题，但代价是固执己见，失去了吸引人们使用 MobX 的灵活性。

*最初发表于*[T5【https://www.alonbd.com】](https://www.alonbd.com/blog/2019-10-09-why-you-should-use-mobx)*。*