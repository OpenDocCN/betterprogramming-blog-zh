<html>
<head>
<title>Automatically Injecting Node.js Service Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动注入Node.js服务依赖项</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automatically-injecting-node-js-service-dependencies-81182d6d4d9?source=collection_archive---------9-----------------------#2021-01-08">https://betterprogramming.pub/automatically-injecting-node-js-service-dependencies-81182d6d4d9?source=collection_archive---------9-----------------------#2021-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="788e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">管理服务依赖关系的更好方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7aaf60f5ac36aa5cf1d4e509fd8f3fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kt9ASTd0y9Ekn60B"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特·拉赫曼</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="e070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想分享我最近在Node.js项目中使用的一种方法。它帮助我以更好的方式管理服务依赖。</p><p id="f9ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现，将依赖注入模式和函数式编程的某些方面结合起来，可以获得更易测试、可读性更好、无重复的代码库。</p><p id="972d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们看看在我们的服务中处理依赖性的传统方式。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2948" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><code class="fe mr ms mt mu b"><strong class="ak">Require</strong></code> <strong class="ak">模块直接服务</strong></h1><p id="8afe" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">声明服务依赖关系的一种常见方法是直接在服务文件中<code class="fe mr ms mt mu b">require</code>它们。这个简单的例子包含一个服务，它负责将用户保存到数据库中，然后发送一封电子邮件通知它的创建:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a4b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们需要直接在服务文件中的依赖关系。我个人不喜欢这种方法，原因有二:</p><ul class=""><li id="f322" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">这有点难以测试，因为我们必须使用像<code class="fe mr ms mt mu b"><a class="ae kv" href="https://www.npmjs.com/package/proxyquire" rel="noopener ugc nofollow" target="_blank">proxyquery</a></code>这样的包来覆盖依赖关系。</li><li id="7867" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">它可能需要不会在服务的所有功能上使用的依赖项。在理想的情况下，我们应该只导入将在所有函数中使用的依赖项，但有时这是不可能的。</li></ul><p id="3bc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试这个方法应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5f09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们可以通过将依赖项直接注入到函数中来避免覆盖它们，会怎么样呢？</p><h1 id="c8c8" class="lz ma iq bd mb mc nq me mf mg nr mi mj jw ns jx ml jz nt ka mn kc nu kd mp mq bi translated">注入依赖关系</h1><p id="0521" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">下面是相同服务的一个示例，但是需要文件顶部的依赖项，我们将做一点更改，以参数形式接收它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="51fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种方法中，函数的依赖项是通过参数传递的。从测试的角度来看，我们可以看到上一种方法的改进。测试这个方法变得容易多了，因为我们不需要一些包来覆盖直接需要的依赖项。我们可以手动模拟我们的依赖关系，或者使用像<a class="ae kv" href="https://sinonjs.org/" rel="noopener ugc nofollow" target="_blank"> sinon </a>这样的包来为我们做繁重的工作。另一个优点是，我们只需查看函数声明就可以知道它的所有依赖项。</p><p id="01a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用我们的新方法测试方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d894" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的一个问题是，每次我们调用函数<code class="fe mr ms mt mu b">createUser</code>时，我们都需要依赖关系来这样做。如果模块经常被其他服务使用，这可能会导致我们的代码库出现大量重复。</p><p id="d398" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们有一个接受服务并自动为我们解决所有依赖关系以避免这种“需要重复”的注射器工具，那不是很好吗？</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="abdf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">功能DI喷射器</h1><p id="4125" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在我向您介绍函数DI Injector之前，让我们仔细看看我们的<code class="fe mr ms mt mu b">createUser</code>函数正在接收哪些参数:</p><pre class="kg kh ki kj gt nv mu nw nx aw ny bi"><span id="954f" class="nz ma iq mu b gy oa ob l oc od">const createUser = (userRepository, emailService, user) …</span></pre><p id="6e98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看参数，我们可以看到函数依赖项作为第一个参数被传递。通常，我们总是传递相同的实现，不管我们在哪里调用这个函数(除了在测试文件上)。每次我们调用这个函数时，唯一会改变的参数是<code class="fe mr ms mt mu b">user</code>参数，对吗？每次我们调用这个函数时，都会创建一个新用户，但是依赖关系(<code class="fe mr ms mt mu b">userRepository</code>、<code class="fe mr ms mt mu b">emailService</code>)总是有相同的实现。</p><p id="ee9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，让我们用“元数据”来分离不经常改变的依赖关系，元数据在函数调用之间总是不同的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e72d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将<code class="fe mr ms mt mu b">createUser</code>函数转化为<a class="ae kv" href="https://en.wikipedia.org/wiki/Partial_application" rel="noopener ugc nofollow" target="_blank">部分函数应用</a>。基本上，我们可以调用<code class="fe mr ms mt mu b">createuser</code> <em class="oe"> </em>函数，首先传递依赖项，这将返回另一个函数，只需要<code class="fe mr ms mt mu b">user</code> <em class="oe"> </em>参数。通过这一改变，我可以向您介绍DI喷油器的功能:</p><blockquote class="of og oh"><p id="294e" class="kw kx oe ky b kz la jr lb lc ld ju le oi lg lh li oj lk ll lm ok lo lp lq lr ij bi translated">“部分应用(或部分函数应用)是指将一些参数固定到一个函数上，产生另一个具有更少参数的函数的过程。”</p><p id="4688" class="kw kx oe ky b kz la jr lb lc ld ju le oi lg lh li oj lk ll lm ok lo lp lq lr ij bi translated"><em class="iq"> —维基百科</em></p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4006" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，这可能很复杂，但是<code class="fe mr ms mt mu b">injectFunctionDependencies</code> <em class="oe"> </em>函数将接收一个服务对象和一个函数名，并自动解析它的依赖关系。</p><p id="c92e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们讨论一下每段代码的作用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4379" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们集中了解决依赖关系的方法。DependencyInjector允许我们通过调用<em class="oe"> </em> <code class="fe mr ms mt mu b">injectUserRepository</code> <em class="oe"> </em>和<code class="fe mr ms mt mu b">injectEmailService</code> <em class="oe">来注入<code class="fe mr ms mt mu b">userRepository</code> <em class="oe"> </em>和<code class="fe mr ms mt mu b">emailService</code> <em class="oe"> </em>。每次我们调用其中的一些函数，结果将是另一个具有更少参数的函数，从而减少每次调用中剩余的参数数量。我们称这种技术为currying，这是函数式编程领域的另一个概念。</em></p><blockquote class="of og oh"><p id="0af7" class="kw kx oe ky b kz la jr lb lc ld ju le oi lg lh li oj lk ll lm ok lo lp lq lr ij bi translated">Currying是一种技术，它将一个接受多个参数的函数转换成一系列接受单个参数的函数</p><p id="81c7" class="kw kx oe ky b kz la jr lb lc ld ju le oi lg lh li oj lk ll lm ok lo lp lq lr ij bi translated">— <em class="iq">维基百科</em></p></blockquote><p id="02c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们注入完依赖项后，我们调用<code class="fe mr ms mt mu b">getFun</code>，它将返回原始函数及其所有已解析的依赖项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="396b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这部分代码不言自明。基本上，它得到一个函数的所有参数名。这里很清楚为什么我们改变了原来的<code class="fe mr ms mt mu b">createUser</code> <em class="oe"> </em>函数，只接收它的第一次调用的依赖关系:</p><pre class="kg kh ki kj gt nv mu nw nx aw ny bi"><span id="fe09" class="nz ma iq mu b gy oa ob l oc od">const createUser = (userRepository, emailService) =&gt; user =&gt; ....</span></pre><p id="8dda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这样做，这个函数<code class="fe mr ms mt mu b">getParamNames</code> <em class="oe"> </em>将返回所有依赖项的名称——在本例中是<code class="fe mr ms mt mu b">userRepository</code> <em class="oe"> </em>和<code class="fe mr ms mt mu b">emailService</code>，对吗？有了所有依赖项的名称，我们现在可以创建一个映射来描述每个依赖项是如何被解析的。这就是我们到达注射器服务的最后一步:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="59eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们基本上是在告诉依赖关系应该如何解决。<code class="fe mr ms mt mu b">servicesInjectors</code>映射将使用依赖项的名称作为键，这是我们从<code class="fe mr ms mt mu b">getParamNames</code>函数和将依赖项本身解析为值的函数中得知的。</p><p id="770e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让这个方法工作，我们的依赖项名称应该与<code class="fe mr ms mt mu b">servicesInjector</code>映射键相匹配，这没什么大不了的，也有助于我们通过代码库保持某种依赖项的默认命名约定。返回的对象将由服务的所有原始函数加上我们在<code class="fe mr ms mt mu b">funcName</code> <em class="oe"> </em>参数中指定的函数组成，所有的依赖关系都已解析。</p><p id="3b88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看最后的结果是什么样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7f57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！不再需要依赖关系，只需要传递服务和函数名，就可以解决依赖关系。现在,<code class="fe mr ms mt mu b">createUser</code>函数将需要每次调用都会改变的唯一参数——用户本身。</p><p id="8b66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天就到这里吧——我希望这篇文章对你有所帮助。</p><p id="e947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保重，编码愉快！</p><p id="66c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的源代码是<a class="ae kv" href="https://github.com/brunneus/di-injector" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>