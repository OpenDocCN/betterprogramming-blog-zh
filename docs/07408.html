<html>
<head>
<title>How To Do Infinite Scrolling the Right Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以正确的方式进行无限滚动</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-do-infinite-scrolling-the-right-way-a64e3463b0e3?source=collection_archive---------7-----------------------#2021-01-12">https://betterprogramming.pub/how-to-do-infinite-scrolling-the-right-way-a64e3463b0e3?source=collection_archive---------7-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="656e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用React钩子实现简单高效的无限滚动</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3c09ff73290cf4aa795a540ba1011711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hkLOVPKKV4HWhFw4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@luddelorentz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢德·洛伦兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="b17d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无限滚动是一种UX设计技术，它在用户向下滚动页面时不断加载内容。这种方法不需要任何分页元素。通过将用户从这种负担中解放出来，它带来了干净的UX体验。您肯定经历过这种行为，因为流行的社交媒体提要使用这种技术实现。</p><p id="0a6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最明显的好处是，只有相关信息在用户需要时才被加载。它减少了初始请求数据的大小，并让应用程序有机会根据需要逐步呈现元素。它不需要显示任何分页元素，也不需要用导航操作来打扰用户。</p><p id="2593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理大量的条目时，这种技术与列表虚拟化相结合，但这是另一篇文章的主题。在这里，我们将着重于如何使无限滚动发生。</p><p id="d25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将探索传统的实现方式，看看如何改进。作为一个技术栈，我将使用React Hooks和TypeScript来取乐，但用普通的JavaScript也可以轻松做到。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc2e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最常见的方法</h1><p id="7afd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你在网上搜索，你会发现最常见的方法是依靠浏览器滚动事件。您可以设置一个句柄来检查滚动的位置，并查看滚动是在最后一个元素之前还是之后。有了这些信息，您就可以决定是否触发无限滚动回调。</p><p id="8468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所做的是在列表的末尾定义一个元素，并检查用户是否滚动到最后一项来触发新元素的加载。</p><p id="d85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何呈现该列表的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="289a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从定义我们的<code class="fe nb nc nd ne b">hasReachedBottom</code>函数开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3f2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这个特定的实现依赖于页面上最后一项的元素。这并不十分相关，对于您的具体情况，还有其他计算方法。</p><p id="7f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们使用这个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><ol class=""><li id="de13" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">检查当前没有挂起的请求。</li><li id="6a36" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">检查元素是否已到达底部。</li><li id="e005" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">执行网络请求。</li></ol><p id="49e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nb nc nd ne b">offset</code>变量。我们使用偏移量只是为了预测最后一个元素何时可见。如果您想在用户到达最后一个元素之前加载内容，这很方便。如果内容加载速度很快，这将是一个完美的体验。</p><p id="ca6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个重要的注意事项是，总是清理自己。使用<code class="fe nb nc nd ne b">useEffect</code>时，可以返回一个负责清理的函数。在这种情况下，我们需要清理滚动事件处理程序。否则，我们会遇到内存泄漏。</p><p id="245b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种方法很简单，但不是最有效的。对于每个用户滚动事件，我们手动检查他们是否到达了列表的底部。我们可以比这更有效率。</p><p id="a5de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看Mozilla开发者页面，您会看到以下警告:</p><blockquote class="nt nu nv"><p id="1213" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">因为<code class="fe nb nc nd ne b">scroll</code>事件可以高速触发，事件处理器不应该执行计算量大的操作，比如DOM修改。相反，建议使用<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame()</a></code>、<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank">setTimeout()</a></code>或<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent" rel="noopener ugc nofollow" target="_blank">CustomEvent</a></code>抑制事件，如下所示。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/scroll_event" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb61" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">十字路口观察员前来救援</h1><p id="f61c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不久前发布了<code class="fe nb nc nd ne b">IntersectionObserver</code>功能。这使我们能够被动地观察元素，并在这些元素在视口中变得可见或隐藏时获取事件。</p><p id="3379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您阅读MDN文档，您会发现推荐的用例之一确实是无限滚动特性。</p><blockquote class="nt nu nv"><p id="536b" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">-页面滚动时延迟加载图像或其他内容。</p><p id="ffc3" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">- <strong class="lb iu">实现“无限滚动”网站，当你滚动的时候，越来越多的内容被加载和呈现，这样用户就不用翻页了。</strong></p><p id="d782" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">-报告广告的可见性，以便计算广告收入。</p><p id="892b" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">-根据用户是否会看到结果来决定是否执行任务或动画过程。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="35b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们该拿它怎么办？我们将在列表的末尾放置一个元素。将监控该元素，一旦它变得可见，它将触发回调，我们可以有条件地决定是否要获取更多的项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d0de47c85932a8c0a2eb4a4ce51ea1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*jvmTdzANehwYjbfdG2-WAw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的图式方法</p></figure><p id="6268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看React挂钩和TypeScript的实现细节:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致了更干净的实现。我们不必处理一种强制性的方法来知道用户是否到达了最后一个元素。当项目的可见性发生变化时，浏览器会通知我们。当元素在屏幕上出现或消失时，交叉点观察器API将做出反应。</p><p id="e082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浏览器将为我们做繁重的工作。这种实现导致委托给我们的事件更少，因此实现的性能更高。</p><p id="5fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们之前使用的偏移方法在这里也是可行的。<code class="fe nb nc nd ne b">Intersection Observer</code>接受第二个参数，这是一组选项。如果您想预测用户对该元素的访问，可以使用<code class="fe nb nc nd ne b">rootMargin: -100px</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0c71" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">支持交叉观察器</h1><p id="ff06" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对这个功能的支持度还是蛮大的:<strong class="lb iu"> <em class="nw"> </em> </strong> 92.3%。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/305934af3f2e04f205862e47ba143dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CTIrtd1L5CfaeGz8.png"/></div></div></figure><p id="d204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你担心的是7.7%的用户，不要慌。你可以只使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的浏览器不支持的话，这个工具会添加<code class="fe nb nc nd ne b">IntersectionObserver</code>功能。这段代码将只在这种情况下下载polyfill，不会影响已经支持<code class="fe nb nc nd ne b">IntersectionObserver</code>的用户。聚合填充是最大化新浏览器功能覆盖范围的好方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a5ab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">包装完毕</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/60b19875a948ae8597fae5746dc203a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HliRRmts364eze7y"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@dascal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adrian Dascal </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="d3c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经探讨了实现无限滚动的最常见方法及其缺陷。我们已经看到了一个性能更好、更具声明性、更易于使用的解决方案。</p><p id="7158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的警告是，它需要使用polyfill来确保它覆盖我们100%的用户群，但在工具的帮助下这是可能的。</p><p id="2f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我写了另一篇关于<code class="fe nb nc nd ne b">IntersectionObserver</code>的文章。如果您对这个API感兴趣，值得一看:</p><div class="od oe gp gr of og"><a href="https://medium.com/better-programming/sticky-done-the-right-way-880af0122a71" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">用正确的方法制作粘性HTML元素</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">创建滚动时保持不变的元素的最佳实践</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><p id="8b74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p></div></div>    
</body>
</html>