<html>
<head>
<title>Tutorial: Dark Mode in React Native With Styled Components and Styled System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:使用样式化组件和样式化系统的React Native中的黑暗模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tutorial-dark-mode-in-react-native-with-styled-components-and-a-styled-system-1463ae2b606b?source=collection_archive---------10-----------------------#2019-11-06">https://betterprogramming.pub/tutorial-dark-mode-in-react-native-with-styled-components-and-a-styled-system-1463ae2b606b?source=collection_archive---------10-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1de1bbf81f22129c124c8b37387cec09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EaEBdPhIhPcSjUSlROYxYw.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Elliott Engelmann 在<a class="ae kf" href="https://unsplash.com/s/photos/dark?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="db19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我相信你已经注意到了席卷应用程序世界的最新趋势:我们知道并喜爱的许多公司，包括Slack、Instagram、Medium等等，现在都为用户提供了切换到深色主题的能力。苹果和谷歌也在各自的操作系统中加入了相同的功能。</p><p id="4c43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果你曾经想在你的React原生应用中实现颜色模式，本指南将向你展示一种实现它的技术。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="6150" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">正在设置</h1><p id="162b" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们需要做的第一件事是配置我们的主题。在我们的主题对象中，我们将在颜色对象中嵌套一个模式对象。这里需要注意的是，<code class="fe mo mp mq mr b">dark</code>对象的形状和它上面定义的颜色是一样的。</p><p id="25fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要将我们的模式导出为一个字符串数组，这样我们就可以在它们之间循环。你可能注意到我们也没有一个<code class="fe mo mp mq mr b">light</code>模式；这是因为我们会自动将顶层颜色分配给一个<code class="fe mo mp mq mr b">default</code>模式。因为我们没有可以直接引用的默认模式对象，所以我们需要在开始时使用<code class="fe mo mp mq mr b">unshift</code>手动添加它。现在你的主题对象应该看起来像这样:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="fb9f" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">配置上下文</h1><p id="8c06" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">接下来，如果你还没有，你会想从<code class="fe mo mp mq mr b">styled-components</code>开始在<code class="fe mo mp mq mr b">ThemeProvider</code>中包装你的应用。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="be27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们的应用程序可以访问我们的主题，我们需要设置我们自己的上下文提供者来处理在主题之间切换的逻辑并记住用户的偏好:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1042" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里没有什么太花哨的东西。我们只是创建了一个上下文提供者，它有两个道具，<code class="fe mo mp mq mr b"> mode </code>和<code class="fe mo mp mq mr b">toggleMode</code>。然后我们赋予<code class="fe mo mp mq mr b">mode</code>一个默认值。</p><p id="5eec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还导出了一个名为<code class="fe mo mp mq mr b">useAppContext</code>的定制钩子，这纯粹是为了方便，这样我们就可以访问我们的AppProvider的上下文，而不必每次都引用<code class="fe mo mp mq mr b">React.useContext(AppContext)</code>。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a0fc" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">切换模式</h1><p id="6674" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">正如我们在上面看到的，我们的AppProvider组件接受两个属性，<code class="fe mo mp mq mr b">mode</code>和<code class="fe mo mp mq mr b">toggleMode</code>——我们将在下面的App.tsx文件中定义它们。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="128f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以循环遍历我们之前创建的模式数组，并将该值设置为一个状态。</p><p id="12cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我们要做的是根据当前的活动模式动态更新我们的主题对象。我们可以使用Lodash的一些辅助函数来实现这一点:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ada2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这项技术的伟大之处在于，你可以添加尽可能多的颜色模式，而不是管理两个独立的亮/暗主题对象，当你点击<code class="fe mo mp mq mr b">toggleMode</code>时，它会在它们之间循环。</p><p id="4ed7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6cd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们就要完成设置切换配色方案的逻辑了。我们仍然需要做的是将用户的首选项设置为异步存储，这样下次用户打开应用程序时，它会记住他们首选的颜色模式:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bf1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<code class="fe mo mp mq mr b">toggleMode</code>函数所在的同一个App.tsx文件中，我们添加了两个<code class="fe mo mp mq mr b">useEffect</code>钩子。</p><p id="da83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个在mount上运行(注意空的依赖数组),负责从AsyncStorage获取用户的首选项并将其设置为state。</p><p id="b81a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个用于在每次更新时将新模式设置为AsyncStorage。就<code class="fe mo mp mq mr b">colorModeStorage</code>实用程序而言，它只是一个包含一些setter/getter函数的对象:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="45fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们都设置好了，我们需要做的最后一件事是给我们的应用程序添加一个按钮/开关，我们将使用它来循环模式。但是，如何做到这一点取决于您，超出了本教程的范围。</p><p id="10f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确保您的所有组件在切换颜色模式时反应良好，请确保始终使用您的主题中的颜色。因为我们使用的是<a class="ae kf" href="https://styled-system.com/" rel="noopener ugc nofollow" target="_blank">风格系统</a>，你应该像这样引用你主题的颜色:</p><pre class="ms mt mu mv gt my mr mz na aw nb bi"><span id="66b2" class="nc lm it mr b gy nd ne l nf ng">&lt;Box bg="primary" /&gt;</span></pre><p id="0f59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样。您可以在下面看到完整的App.tsx文件:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ef62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一句，如果你在你的应用程序中使用<code class="fe mo mp mq mr b">react-navigation</code>(我相信你们大多数人都是这样)，你可能已经注意到默认情况下你可能使用的任何组件——比如<code class="fe mo mp mq mr b">Tabs</code>等。—不要自动切换颜色模式。</p><p id="9cc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢天谢地，<code class="fe mo mp mq mr b">react-navigation</code>支持主题化——你只需要告诉你的导航器使用哪个主题。可以这样做:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0441" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一切都准备好了。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="568a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">资源</h1><p id="7bab" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">非常感谢Brent Jackson，他为他的色彩模式指南<a class="ae kf" href="https://styled-system.com/guides/color-modes" rel="noopener ugc nofollow" target="_blank">撰写了</a><a class="ae kf" href="https://styled-system.com/" rel="noopener ugc nofollow" target="_blank">风格系统</a>。</p><p id="d0f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章改编自他的React本地应用指南。</p></div></div>    
</body>
</html>