<html>
<head>
<title>How To Improve the Jest Performance in CI Environments When Using TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在CI环境中使用TypeScript提高Jest性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-improve-the-jest-performance-in-ci-environments-when-using-typescript-66a186cb5cd4?source=collection_archive---------6-----------------------#2022-08-30">https://betterprogramming.pub/how-to-improve-the-jest-performance-in-ci-environments-when-using-typescript-66a186cb5cd4?source=collection_archive---------6-----------------------#2022-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4910" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">消除项目中停滞的测试用例和内存不足错误的技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8ff606b1db777d89a30ed6eb7e8e7a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lqit3x9qjIQRLHP2QS_UcA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://www.iconfinder.com/search?q=thunder&amp;price=free" rel="noopener ugc nofollow" target="_blank">iconfinder.com</a>和<a class="ae kv" href="https://freeicons.io/profile/3" rel="noopener ugc nofollow" target="_blank"> freeicons.io </a>的图标</p></figure><p id="16a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个开发人员或开发团队在构建新项目时都必须做出决策，在这种情况下，我们谈论的是Node.js项目。当谈到JavaScript开发时，您可以做出的最佳决定之一是使用TypeScript，因为这将为您提供额外的工具来编写更清晰和可维护的代码。</p><p id="d8ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个好的决定是在项目中添加一个测试框架或库，众所周知，Jest是目前使用最多的框架，也是一个不错的选择，因为它有一个强大的内置断言库。</p><p id="28e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但并非最不重要的是，我们应该添加一个管道，以确保我们不会引入错误，并且在每次合并或发布之前一切正常。让我们用詹金斯来完成这项任务，尽管它也可能是任何其他的选择。</p><p id="e33b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至此，你已经认识了这个故事的三个主角:<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a>、<a class="ae kv" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest.js </a>、<a class="ae kv" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>。让我们开始吧。</p><h1 id="d5f1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题是</h1><p id="d3ce" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一切都开始了，因为它被要求更新项目的依赖关系，因为一些漏洞被发现，因为它已经有很长一段时间，因为最后一次更新。在此过程之后，我更新了以下依赖项(仅提及最相关的部分):</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6932" class="mu lt iq mq b gy mv mw l mx my">typescript     from 3.9.7  to 4.7.4<br/>jest           from 26.4.2 to 28.1.1<br/>ts-jest        from 26.3.0 to 28.0.5</span></pre><p id="4aa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，当我推动更改并且Jenkins运行测试时，在两个不同的时刻发现了两个不同的问题:</p><ol class=""><li id="5ba6" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">测试阶段在每次管道执行时都被随机测试用例卡住，并且永远不会结束。</li><li id="1b4f" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">在实现了第一个问题的解决方法，并通过一些额外的代码和测试将更改合并到另一个特性分支之后，在stage的日志中显示了以下错误“JavaScript堆内存不足错误”</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/32a2786573fa55ed0126455b618fc876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rAtnLfqJxidWhzH3WN4WjQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JavaScript堆内存不足错误</p></figure><p id="2d4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，重要的是要说，在依赖项更新之前，单元测试的测试阶段花费了1.59分钟，e2e测试花费了3.26分钟。请记住这些数字，以备后用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/8b4264fbd08407db4cde9b65aec717cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Kd6eMPu4KZ9RwfdGS4X0Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试阶段的CI流水线时间</p></figure><h1 id="1581" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">“停滞的测试用例”的解决方法</h1><p id="2306" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如您在这个<a class="ae kv" href="https://stackoverflow.com/questions/62885390/my-jests-tests-are-leaking-memory-how-can-i-fix-this" rel="noopener ugc nofollow" target="_blank">堆栈溢出问题</a>的答案中所看到的，当您寻找如何修复这个问题的信息时，您可以找到的第一个也是最常用的方法与Jest运行测试所使用的线程数量有关。您可以使用两种不同的选项来更改默认行为:</p><ul class=""><li id="8a10" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr np nf ng nh bi translated"><code class="fe nq nr ns mq b"><a class="ae kv" href="https://jestjs.io/docs/cli#--runinband" rel="noopener ugc nofollow" target="_blank">— runInBand</a></code>:这将连续运行所有的测试，并使用主进程，而不是创建更多的线程。</li><li id="deed" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr np nf ng nh bi translated"><code class="fe nq nr ns mq b"><a class="ae kv" href="https://jestjs.io/docs/cli#--maxworkersnumstring" rel="noopener ugc nofollow" target="_blank">— maxWorkers</a></code>:这允许您设置可以使用多少线程来运行测试。这默认为您的计算机上可用的内核数量减去一个主线程。</li></ul><p id="4e4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我在package.json测试脚本中添加了选项— <code class="fe nq nr ns mq b"> runInBand</code>,以避免Jest一次运行多个测试，这意味着这个过程需要更少的内存。然而，这也意味着需要更长的时间才能完成。这解决了第一个问题，但是我们必须处理JavaScript堆内存不足错误。</p><h1 id="0c5f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">深入挖掘，寻找“内存不足错误”的根本原因</h1><p id="7072" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了更好地理解这个问题，我做的第一件事就是从测试执行中获取更多的概要信息。我通过将<code class="fe nq nr ns mq b">test package.json</code>脚本更新为以下内容实现了这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有jest分析的测试脚本</p></figure><p id="6444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许我单独运行测试，并获得在运行每个测试后分配了多少内存的信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/27327bb38cb88fd4d97674a03546f7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YrsLi11XJ1n_LJz-Vv7Gxw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">jest-logHeapUsage选项</p></figure><p id="f88b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我意识到Jest消耗的内存比Jenkins容器中可用的内存多，并且花了很长时间才开始运行第一个测试。</p><p id="206e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的第一个选择是使用<a class="ae kv" href="https://swc.rs/" rel="noopener ugc nofollow" target="_blank"> SWC </a>来加速测试，与<a class="ae kv" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>相比，它有望将编译速度提高20倍。然而，我在设置它时遇到了几个问题，因为它似乎不能很好地处理循环依赖。</p><p id="7b66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在搜索另一个选项时，我最终选择了一个名为<a class="ae kv" href="https://huafu.github.io/ts-jest/user/config/isolatedModules#example" rel="noopener ugc nofollow" target="_blank">隔离模块</a>的<a class="ae kv" href="https://huafu.github.io/ts-jest/" rel="noopener ugc nofollow" target="_blank"> ts-jest </a>配置选项。简而言之，它禁用了TypeScript类型检查，从而减少了内存消耗和执行时间。</p><h1 id="12df" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最终解决方案</h1><p id="e9ec" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我猜想您对类型检查有所顾虑，因为我们一开始并没有使用TypeScript来禁用它。但是不用担心，我们只需要在CI环境中禁用它。正如您在下面的脚本中看到的，我们需要通过发送一个环境变量来禁用CI脚本的类型检查。然后，您只需要确保在配置管道时使用了<code class="fe nq nr ns mq b">test:ci</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cd8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，让我向您展示使用普通测试和CI测试执行测试的两个图像，以便您可以看到不同之处:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/d5d15f939af713f700d2a641e7f24d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3s_u5Hrf9Lugi0qgpqLwg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无优化—正常测试脚本(npm运行测试)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/8c658de9a6ae7036a3d10a13a41a217c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkX7WhVz-Mui9-0LB0IElA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带优化— CI测试脚本(npm运行测试:CI)</p></figure><p id="f977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们查看前面图像中的三个步骤，并对每个步骤进行比较，我们可以看到以下内容:</p><ol class=""><li id="138e" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">执行的第一个测试:启动时间和消耗的内存是3，065秒，在CI脚本中相应地减少了170MB</li><li id="5251" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">执行的最后一个测试:在CI脚本中，最终的堆大小减少了167MB</li><li id="762a" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">执行摘要:在CI脚本中，执行持续时间少了11，375秒</li></ol><p id="5ad3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我向您展示一下，经过改进后，测试在CI环境中的运行速度提高了50%以上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/dd6f41971e97289d747c16b55f3ccd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyJUfR-9LoldP6dgdxsZ3w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">改进后测试阶段的CI流水线时间</p></figure><p id="dc26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！我希望这篇文章对您有所帮助。欢迎所有建设性的反馈。</p></div></div>    
</body>
</html>