<html>
<head>
<title>Data Visualization in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的数据可视化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-visualization-in-go-e3135d93f8a8?source=collection_archive---------6-----------------------#2022-01-05">https://betterprogramming.pub/data-visualization-in-go-e3135d93f8a8?source=collection_archive---------6-----------------------#2022-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="073b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建漂亮的图表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb3eb93ac79209447226c15528aba2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*41zf-lHPTkT4EM70"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将展示如何使用Golang来分析、处理和可视化数据。这是一个初学者友好的教程，并不真正需要任何水平的Golang专业知识。</p><p id="3d62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用来自<a class="ae ky" href="https://www.kaggle.com/khaiid/most-selling-pc-games" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的畅销电脑游戏数据集。您可以下载数据集，并将其作为<code class="fe lv lw lx ly b">games.csv</code>保存在您的工作目录中，以便继续使用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b06f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">读取数据集</strong></h1><p id="b705" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们正在处理的数据集包含显示几款电脑游戏在一段时间内销售数量的数据。</p><p id="080d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要将数据集读入我们的Go程序。让我们创建一个新的入口文件<code class="fe lv lw lx ly b">main.go</code>，然后创建一个主函数，并在这里添加下面的代码片段<a class="ae ky" href="https://gist.github.com/horlabyc/5d9f9d6aaba6269c36d340dbb8487167" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的片段来看:</p><ol class=""><li id="4c85" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们使用Golang的<code class="fe lv lw lx ly b">os</code>包打开数据集的文件，提供文件名作为参数，并将数据集保存为<code class="fe lv lw lx ly b">file</code></li><li id="eebd" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">声明两个变量来保存游戏名称和每个游戏的销售额。<code class="fe lv lw lx ly b">games</code>是一片<code class="fe lv lw lx ly b">string</code>而<code class="fe lv lw lx ly b">sales</code>则是一片<code class="fe lv lw lx ly b">float64</code></li><li id="7de7" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">如果在读取文件时出现错误，我们将记录错误并退出程序。</li><li id="596b" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们使用<code class="fe lv lw lx ly b">encoding/csv</code>包创建了一个新的CSV阅读器。在这里，我们提供读取文件作为参数。然后，我们将阅读器的LazyQuote属性设置为true，以便在CSV文件中未加引号的字段上添加引号。</li><li id="9fbd" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">然后，我们使用创建的阅读器读取CSV文件，并将其保存为<code class="fe lv lw lx ly b">records</code>。如果在读取文件时发生错误，我们记录错误并退出程序。</li></ol><p id="f92f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里应该注意的是，CSV数据集将被读取为<code class="fe lv lw lx ly b">records</code>，每一行都被表示为一个数组元素，即标题将是数组中的第一个元素，随后，每一行也是如此。</p><p id="0eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的下一件事是格式化得到的记录。我们创建了一个新函数来处理这个问题。该函数接受字符串片<code class="fe lv lw lx ly b">[][]string</code>的一片<code class="fe lv lw lx ly b">record</code>，返回与<code class="fe lv lw lx ly b">gameNames</code>和<code class="fe lv lw lx ly b">sales</code>类型相同的两个变量</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ol class=""><li id="6067" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们创建了新的变量<code class="fe lv lw lx ly b">gameName []string{}</code>和<code class="fe lv lw lx ly b">sales []float64{}</code></li><li id="e6c9" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们在这里创建一个<code class="fe lv lw lx ly b">for</code>循环，遍历<code class="fe lv lw lx ly b">records</code>的每个元素。注意循环是如何从第一个索引而不是第0个索引开始的，这是为了删除CSV头。</li><li id="cd5d" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">然后，我们将数据追加到创建的<code class="fe lv lw lx ly b">gamesNames</code>切片中。游戏的名字出现在数据集的第一列，这解释了为什么我们在<code class="fe lv lw lx ly b">records</code> <code class="fe lv lw lx ly b">r[0]</code>中附加每个元素的第0个索引</li><li id="1667" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们还将数据添加到创建的<code class="fe lv lw lx ly b">sales</code>切片中。销售数字出现在数据集的第二列，这解释了为什么追加<code class="fe lv lw lx ly b">records</code> <code class="fe lv lw lx ly b">r[1]</code>中每个元素的第一个索引也注意到了我们如何在将<code class="fe lv lw lx ly b">string</code>追加到<code class="fe lv lw lx ly b">sales.</code>之前将其转换为<code class="fe lv lw lx ly b">float64</code></li><li id="2703" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">然后我们返回两个切片；<code class="fe lv lw lx ly b">gameNames</code>和<code class="fe lv lw lx ly b">sales</code></li></ol><p id="26df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从主函数中，我们现在可以调用<code class="fe lv lw lx ly b">formatRecords</code>函数并相应地更新<code class="fe lv lw lx ly b">gameNames</code>和<code class="fe lv lw lx ly b">sales</code>变量，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="46df" class="mg mh it bd mi mj nt ml mm mn nu mp mq jz nv ka ms kc nw kd mu kf nx kg mw mx bi translated"><strong class="ak">数据集映射</strong></h1><p id="b469" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，我们需要映射我们的记录，这样它就被表示为一个键/值对的映射，键是游戏的名称，值是销售额，就像<code class="fe lv lw lx ly b">map[string]float64{ "game1": 20.5, "game2": 3 }</code>一样。我们还将按照销售数量的降序对地图进行排序。我们通过创建另一个像这样的函数来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ol class=""><li id="5b7a" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们创建一个新的映射变量<code class="fe lv lw lx ly b">dataMap</code>，键为<code class="fe lv lw lx ly b">string</code>，值为<code class="fe lv lw lx ly b">float64</code></li><li id="fc48" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">循环遍历<code class="fe lv lw lx ly b">gameNames</code>切片，对于切片中的每个名称，我们将数据映射值设置为游戏名称，将密钥设置为当前索引<code class="fe lv lw lx ly b">sales</code>的值</li></ol><p id="b4b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们已经能够将我们的记录转换成<code class="fe lv lw lx ly b">gameNames</code>与销售数量的关系图。接下来要做的是对数据进行排序。为此，我们需要实现自定义排序。你可以在Golang <a class="ae ky" href="https://gobyexample.com/sorting" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多关于排序的信息</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="da7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是怎么回事？？？</p><ol class=""><li id="da2f" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们创建一个具有<code class="fe lv lw lx ly b">Value</code>(字符串)和<code class="fe lv lw lx ly b">Key</code>(浮动64)属性的结构类型<code class="fe lv lw lx ly b">Data</code>。这代表了我们的数据存在的格式</li><li id="9b86" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们还创建了一个类型为<code class="fe lv lw lx ly b">[]Data</code>的变量<code class="fe lv lw lx ly b">DataList</code>。</li><li id="a005" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">然后我们创建三个函数<code class="fe lv lw lx ly b">Len, Swap and Less</code>。在Golang中实现自定义排序需要这些函数。</li><li id="72e0" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">现在，在<code class="fe lv lw lx ly b">mapData</code>函数中，我们创建了一个新数据，它是一个类型为<code class="fe lv lw lx ly b">DataList</code>的切片，其长度将是<code class="fe lv lw lx ly b">dataMap</code>的长度。然后我们迭代<code class="fe lv lw lx ly b">dataMap</code>并相应地设置填充<code class="fe lv lw lx ly b">data</code>切片</li><li id="623d" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">然后我们使用Golang的排序包对填充的<code class="fe lv lw lx ly b">data</code>进行排序。请注意，我们做了反向排序，因为我们希望按降序排序。</li><li id="78c9" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">然后我们返回数据。</li></ol><p id="a18f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样调用主函数中的<code class="fe lv lw lx ly b">mapData</code>函数；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们已经能够读取、分析和清理我们的数据。下一步是在图表上可视化数据，我们将利用条形图，其中X轴显示游戏名称，Y轴显示销售数量。为此，我们将利用<a class="ae ky" href="https://github.com/go-echarts/go-echarts" rel="noopener ugc nofollow" target="_blank"> go-echat </a>库。这个库对于Golang中的数据可视化非常有用。</p><ol class=""><li id="9f93" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们需要在您的终端中运行<code class="fe lv lw lx ly b">$ go get -u github.com/go-echarts/go-echarts/v2/.</code>来添加库。</li><li id="7514" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们将只绘制数据集中的前10个数据，请记住，我们已经按照销售数量的降序对数据集进行了排序。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ac47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这里发生了什么？</p><ol class=""><li id="74b8" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">在<code class="fe lv lw lx ly b">createChart</code>函数中，我们将排序后的数据作为参数传递。</li><li id="3259" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们用go-echart库创建了一个新的条形图实例</li><li id="7f18" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们在条形图上设置了一些全局选项，包括图表标题和副标题。</li><li id="dbb9" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们设置X轴数据，这是游戏名称，也是我们排序数据图的关键</li><li id="0684" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">下一件事是生成Y轴数据，它代表每款PC游戏的销售数量。这是通过新函数<code class="fe lv lw lx ly b">generateBarItems</code>完成的，该函数将<code class="fe lv lw lx ly b">sortedData</code>作为参数。在这个函数中，我们遍历了<code class="fe lv lw lx ly b">sortedData</code>，并相应地追加了条形数据。这表示为<code class="fe lv lw lx ly b">items</code></li><li id="26f2" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">回到<code class="fe lv lw lx ly b">createChart</code>函数，我们使用<code class="fe lv lw lx ly b">os</code>包的<code class="fe lv lw lx ly b">Create</code>方法创建一个新的HTML文件(<code class="fe lv lw lx ly b">games.html)</code>)。然后，我们在新的HTML文件中呈现图表。</li></ol><p id="926a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们就能够从我们的数据集生成一个条形图。你现在可以运行<code class="fe lv lw lx ly b">go run main.go</code>来编译和运行程序。您可以打开新的HTML文件来查看图表</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/1afcaf4588a588e2543e787134f3a6df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dq2FDK8PJMDkoGLEj5gVrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="41ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经了解了如何读取文件(CSV)，处理文件内容，然后用文件内容创建图表。代码可以在这个<a class="ae ky" href="https://github.com/horlabyc/data-visualization" rel="noopener ugc nofollow" target="_blank">库</a>中找到。感谢阅读。</p></div></div>    
</body>
</html>