# 用函数式编程语言编写代码时要避免的 5 种反模式

> 原文：<https://betterprogramming.pub/5-anti-patterns-to-avoid-when-writing-code-in-a-functional-programming-language-a354418b1844>

## Scala 的用例示例

![](img/addb76f63dbd7d044eab38583df1e7ed.png)

照片由[普里西拉·杜·普里兹](https://unsplash.com/@priscilladupreez?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

在过去的几年里，函数式编程语言获得了极大的发展。

许多人可以看到编写包含诸如作为一等公民的功能的代码的好处。他们在并发环境中拥抱不变性，运行繁重的计算任务而不用担心一些并发问题，并且喜欢编写尽可能简洁的通用代码。

我认为这是函数式编程语言再次成为主流的好迹象。然而，用函数式编程语言编写代码的难点之一是它的设计模式和反模式，它们不同于常规的编程语言。

我经常看到工程师编写大型代码库，我将他们归类为反模式。当我最初用函数式编程语言编写生产就绪的应用程序时，我也致力于这些反模式。从那以后，我阅读了许多关于函数式编程设计模式的书籍，这些书籍帮助我创建了更易维护的代码。

# 过度嵌套的匿名回调函数。

匿名函数有利于代码的可重用性。然而，过多的匿名功能会伤害那些想要扩展功能的工程师的眼睛。尽管 DRY 是一条可行之路，但有时候复制比错误的抽象要好。

我接触过代码库，在那里工程师将编写一个非常简洁和抽象的方法。代码是这样的:

能告诉我`buildRunner`的定义是什么吗？

然后，这个`buildRunner`用于支付处理器中的所有动作操作，如授权、捕获和作废。我看了它两天，终于明白它想做什么。

这使得你写的所有函数的摘要尽可能的干巴巴。然而，对于普通的工程师来说，拥有一个嵌套的匿名回调来构建一个新的特性或者维护它是很困难的。大多数工程师需要几天的时间来理解`buildRunner`试图做什么。

函数式编程的好处是，你可以查看函数签名，并立即知道它试图做什么。然而，这个函数并没有解释它是做什么的。这让试图改变代码库的工程师更加困惑。

因此，一个好的经验法则是不使用匿名函数是可能的。相反，使用高阶函数。

如果你想使用匿名功能，请在顶部加一个`type`以便于阅读。http4s 通过包装其类型输入`Kleisli`在内部完成这项工作。`Kleisli`本身就是一个匿名函数，也就是`A => F[B]`。然而，用`type`定义包装匿名函数有助于代码库的可读性。

# 模式匹配到极致

关于在函数式编程中编写代码的好处，我们首先了解到的是模式匹配特性——它消除了我们在通用编程语言中经常使用的难看的 if-else 语句。

如果你只有一个短代码，模式匹配是很好的。当你有两层以上的[模式匹配](https://www.bmc.com/blogs/callback-hell/)时，事情变得更像一个回调地狱。

通常，不熟悉使用函数式编程语言编写代码的工程师不知道该语言提供了多少内置的高阶函数。因此，它们通过模式匹配和递归函数来默认它们的函数实现。

在函数实现中使用嵌套的 case 表达式和递归实现会导致代码难以阅读和理解。在 PR 注释中花费很长时间，如果实现中有 bug 的话，就更难找到了。

编写嵌套模式匹配 case 语句的一个解决方案是只关心成功案例，而将错误场景留在函数实现之外。此外，如果可能，使用库或语言提供的内置高阶函数、`map`和`flatMap`。它为您的代码库提供了更好的人机工程学，并且您可以立即识别出错误在哪里被处理。

在函数定义中表达类型的美妙之处在于，函数实现不再需要处理所有的错误情况——类型系统可以将这些错误情况传播给调用者——强制函数在堆栈中处理这些错误。

# 在界面上使用 Monad 转换器

遇到嵌套效果时使用 Monad Transformer 非常有用。在上面的场景中，Monad Transformer 是解决严重嵌套效果的另一个解决方案——它有助于使您的 API 可组合。然而，我们不应该将 Monad Transformer 暴露在接口上，因为这会使我们的 API 与特定的 Monad Transformer 紧密相关。

我们来举一个更具体的例子。下面的界面可以是`Future[Either[Throwable, String]]`而不是`EitherT[Future, Throwable, String]`。

所有想要使用`someFunction`作为 API 的函数也需要使用`EitherT`。

如果它是一系列函数，并且我们看到一些函数返回一个`OptionT`呢？

我们将需要调用几次`value`来返回到我们的效果`Future`，不必要的包装。

或者，我们应该让`someFunction`返回一个`Future[Either[Throwable, String]]`，并让 effect 检测您在程序中需要什么约束。

总之，拥有最纯粹的效果形式比 monad 转换器更好，因为它不会锁定使用 API 的服务来使用 monad 转换器。

# 在 API 上返回布尔值

许多 API 可能会返回一个布尔值来表示一种逻辑或另一种逻辑。取自 Scala 中[实用 Fp 的经典例子是`filter`函数。](https://www.google.com/search?q=parctical+fp&%0Aoq=parctical+fp&aqs=chrome..69i57j0i13j46i13j0i13l5j0i22i30l2.4661j1j1&sourceid=chrome&ie=UTF-8)

如果你看一下函数定义,‘filter’实际上是做什么的？

如果谓词评估为`true`，它将丢弃列表中的元素。另一方面，这也意味着如果谓词的计算结果为`true`，它将保留列表中的元素。

这是模糊的。

Scala 中还有`filterNot`，函数定义相同，但名称不同。我经常看到许多错误发生在这两个函数中，因为工程师们关注这两个函数之间的差异。

我们可以通过用有意义的值包装谓词的 ADT(代数数据类型)来改进这一点。

这个 ADT 帮助我们创建一个更具体的函数签名，如下所示:

无论谁使用这个函数，都会知道他们是想保留这个元素还是丢弃它们。

为了解决 filter 类的这个问题，你可以从 scala List trait 中创建一个扩展方法`filterBy`。

避免布尔值混淆的关键是使用 ADT 给出有意义的值，并用 ADT 扩展这些函数。尽管如此，这会导致更多的样板文件，但是您在构建应用程序时会遇到更少的混乱和错误。

用 ADT 包装所有返回的布尔型 API 可能有些过分。因此，您可以在关键组件中用 ADT 包装布尔返回的 API，并在应用程序的其余部分中保持灵活性。这是与你的团队成员达成一致的问题。

# 在你的特性中使用通用数据结构

这种说法可能会引起争议，因为在常规的软件工程实践中，接口应该尽可能地通用，以便可扩展。这在理论上听起来很棒，但在实践中却不行。

一个例子是`Seq`——Scala 标准库中定义的通用表示。很一般的是`List`、`Vector`、`Stream`都是从`Seq`延伸出来的。这是一个问题，因为这些数据结构的行为各不相同。

例如，我们有一个返回`Future[Seq[String]]`的特征:

有些工程师会调用函数`fetchAll`，用`toList`函数把`Seq`转换成`List`。

怎么知道打`toList`是安全的？解释器可能将`Seq`定义为`Stream`，在这种情况下，它将具有不同的语义，并且可能在调用者端抛出异常。

因此，为了减少调用者方面的惊喜，最好根据应用程序的目标和性能定义一个更具体的类型，比如`List`、`Vector`、`Stream`。

# 结论

这些反模式的问题在于，它不是泛型编程语言中的反模式。

例如，我们被教导写抽象是好的，它让你的代码库保持干燥。然而，过度嵌套的匿名回调函数可能很难阅读。解决这个问题的最好方法是复制代码以增加可读性。返回布尔值的 API 可能不是问题，它存在于许多 API 设计和应用程序中。然而，实现一个返回布尔值的 API 并不能清楚地说明这些布尔值是什么意思。此外，人的思维经常会忽略文档中的小细节，这可能会导致实现中的错误。

模式匹配是函数式编程语言中的一个强大特性，但它过于一般化。如果你能找到一个更好的高阶函数来实现这个函数，你应该用它来代替。

过于通用的数据结构会增加 API 使用的模糊性。因此，最好创建一个更具体的类型，并使函数声明对调用方尽可能清晰。

我希望您在用函数式编程语言编写代码时避免这种反模式。你认为这些是反模式吗？在用函数式编程语言编写代码时，你能想到的另一个反模式是什么？请在下面评论它们，这样我也可以向它们学习！

*最初发表于*[*【https://edward-huang.com】*](https://edward-huang.com/scala/functional-programming/2022/04/18/5-anti-pattern-for-writing-code-in-a-functional-programming-language/)*。*