<html>
<head>
<title>Angular: State Management With NGXS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:使用NGXS进行状态管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-state-management-with-ngxs-8b17719def29?source=collection_archive---------0-----------------------#2020-04-26">https://betterprogramming.pub/angular-state-management-with-ngxs-8b17719def29?source=collection_archive---------0-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a030" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解NGXS的基础知识，并构建一个示例CRUD应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b943c5e083b0b504a77b5cd83c9b148a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXtorLrcgvH99ZwcldxFhQ.png"/></div></div></figure><p id="11da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">NGXS本质上是Angular的状态管理库。您可能遇到过Angular的其他状态管理解决方案，比如NgRx和Akita。下面是我以前写的两篇关于使用NgRx进行状态管理的文章:</p><ul class=""><li id="7234" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae lz" href="https://medium.com/better-programming/angular-getting-started-with-ngrx-75b9139c23eb" rel="noopener">Angular:NgRx</a>入门</li><li id="c867" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://medium.com/better-programming/angular-building-a-crud-application-with-ngrx-40e5f1c0b50c" rel="noopener"> Angular:用NgRx </a>构建一个CRUD应用程序</li></ul><p id="2974" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我打算涵盖以下主题。</p><ul class=""><li id="a148" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">NGXS是什么？</li><li id="5294" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">NGXS的基本概念</li><li id="c07f" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">构建一个示例CRUD应用程序</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="efd0" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">NGXS是什么？</h1><p id="210a" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">如上所述，NGXS是专门为Angular开发的状态管理解决方案。在我们深入讨论细节之前，让我们试着理解角度应用中<em class="nj">状态</em>的概念。</p><h2 id="58ec" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">状态</h2><p id="6823" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">理论上，应用程序状态是应用程序的整个内存。简而言之，应用程序状态由API调用接收的数据、用户输入、呈现UI状态、应用程序首选项等组成。应用程序状态的一个简单、具体的例子是CRM应用程序中维护的客户列表。</p><p id="090c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们试着在角度应用程序的上下文中理解应用程序状态。众所周知，角度应用通常由许多组件组成。这些组件中的每一个都有自己的状态，并且不知道其他组件的状态。为了在父子组件之间共享信息，我们使用了<code class="fe nw nx ny nz b">@Input</code>和<code class="fe nw nx ny nz b">@Output</code>装饰器。然而，只有当您的应用程序由几个组件组成时，这种方法才是实用的，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/9a510e22a2ac70bd7828e220cb572fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6unZOSJ_Q19DtN7wUOyBZg.png"/></div></div></figure><p id="2c2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当组件数量增加时，仅仅通过<code class="fe nw nx ny nz b">@Input</code>和<code class="fe nw nx ny nz b">@Output</code>装饰者在组件之间传递信息就成了一场噩梦。我们就拿下图来对此进行阐述吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/e29c4823ccd4d597f42198948f979fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-EGRb0a_fYChM4P7RnC74w.png"/></div></div></figure><p id="35eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您必须将信息从组件3传递到组件6，您将必须跳四次并涉及其他三个组件。如您所见，这是一种非常麻烦且容易出错的状态管理方式。在这种情况下，拥有一个像NGXS这样的状态管理解决方案会派上用场。它将简单地转换上面的数据传输模型，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/6a02691bdf93f733a33ecb296f1f901f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFDXotMaH03nuEwwRoyMag.png"/></div></div></figure><p id="1894" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据这种体系结构，数据在存储和组件之间流动，而不是在组件之间流动。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="e906" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">NGXS的基本概念</h1><p id="c14a" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">NGXS包括四个主要概念——存储、动作、状态和选择。</p><h2 id="7a1d" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">商店</h2><p id="e8b6" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">商店是整个状态管理过程中的关键元素。它促进了组件和状态之间的交互。你可以通过角度依赖注入获得对外挂的引用，如下所示。</p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="66ba" class="nk mn it nz b gy og oh l oi oj">constructor(private store: Store) { }</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/3f07da7ada2ea1ada87a3f116d2b0d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*Mng5YIomYEnPulgL-ksMqA.png"/></div></figure><p id="0f2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该存储引用随后可用于两个主要操作:</p><ul class=""><li id="e06f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">通过<code class="fe nw nx ny nz b">store.dispatch(…)</code>方法向商店分派动作，这将依次触发状态修改器函数。</li><li id="658e" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">通过选择来检索应用程序状态。</li></ul><h2 id="4010" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">状态</h2><p id="e820" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在NGXS的上下文中，状态是定义状态容器的类。这些类持有整个应用程序状态的不同部分。假设您的应用程序包含两个名为User和Product的特性模块。这些模块中的每一个都处理整体状态的不同部分。产品信息将一直保持在状态中的<code class="fe nw nx ny nz b">products</code>部分。用户信息将一直保持在<code class="fe nw nx ny nz b">user</code>区的状态。这些切片也被称为<em class="nj">切片</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/1b53c0f8fae1956d49827259ab437584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLx0P782Zp4zRjfIOh4XEg.png"/></div></div></figure><p id="3434" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在NGXS中，状态类通常定义如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="900c" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">行动</h2><p id="fa1f" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">动作是您分派到存储区的指令，可选地带有一些元数据(有效负载)。根据操作类型，商店决定执行哪些操作。每个动作包含一个作为其唯一标识符的<code class="fe nw nx ny nz b">type</code>字段。状态修饰符函数将使用可选地嵌入在动作中的元数据来修改状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/9295dafc8c8cd03a950c4a96b5869fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*xbaYFiWHqyW93JVZKwmCHg.png"/></div></figure><p id="a46b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">以下是一个没有任何元数据的简单操作。它将具有<code class="fe nw nx ny nz b">type</code>属性，该属性本质上描述了动作的目的。State类将有一个方法来监听这个动作，然后通过后端API检索用户并更新应用程序状态。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9d34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">以下是带有元数据的动作定义。</strong>同样，State类将有一个监听这个动作的方法，并将调用后端API来创建一个用户。状态类函数将获得嵌入在动作中的<code class="fe nw nx ny nz b">user</code>对象，并将其传递给API调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="8b7e" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">挑选</h2><p id="fb11" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">选择是从全局状态容器中分割状态的特定部分的函数。您基本上可以使用<code class="fe nw nx ny nz b">Select</code>函数来查询应用程序状态。在NGXS中，有两种选择状态的方法——您可以在<code class="fe nw nx ny nz b">Store</code>服务上调用<code class="fe nw nx ny nz b">select</code>方法，或者使用<code class="fe nw nx ny nz b">@Select</code>装饰器。首先，我们来看一下<code class="fe nw nx ny nz b">@Select</code>装饰器。</p><p id="90ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">选择装饰器:</strong>您可以使用<code class="fe nw nx ny nz b">@select</code>装饰器从商店中选择数据片。下面的代码片段说明了这种技术。</p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="c87c" class="nk mn it nz b gy og oh l oi oj">@Select(AppState.users) user$: Observable&lt;User[]&gt;;</span></pre><p id="3480" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">存储选择函数:<code class="fe nw nx ny nz b">Store</code>类还有一个<code class="fe nw nx ny nz b">select</code>函数，可以用来读取应用程序状态的一部分。</p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="12bb" class="nk mn it nz b gy og oh l oi oj">constructor(private store: Store) {</span><span id="1945" class="nk mn it nz b gy op oh l oi oj">   this.users$ = this.store.select(state =&gt; state.users);</span><span id="3d44" class="nk mn it nz b gy op oh l oi oj">}</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="15f4" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">构建一个示例CRUD应用程序</h1><p id="7eef" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在本文的其余部分，我们将使用NGXS构建一个简单的课程管理系统。如下所示，您将能够通过这个简单的web应用程序在课程实体上执行所有CRUD操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/7d7adcf3aa12b5627b727a690bdd643f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nT3YF7AMhXUEWtIhbI_r3g.gif"/></div></div></figure><h2 id="a20e" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">项目结构</h2><p id="a8c9" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">如下图所示，我们的应用程序将由两个主要模块组成，即<code class="fe nw nx ny nz b">App</code>和<code class="fe nw nx ny nz b">Course</code>。课程模块又将有两个定制组件，即<code class="fe nw nx ny nz b">Course List</code>和<code class="fe nw nx ny nz b">Create Course</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/5a0045bcb8a291a9685bd08520b49787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-DcBhZ3ctw87xSw49-zvg.png"/></div></div></figure><h2 id="7506" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">REST API</h2><p id="93a1" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">一般来说，Angular应用程序与REST API交互，对数据执行CRUD操作。</p><p id="a0aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我在Spring Boot<a class="ae lz" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank">中实现了一个简单的REST API，它公开了下面的端点。我们将使用这个API从Angular应用程序进行连接，并执行数据操作。</a></p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="3245" class="nk mn it nz b gy og oh l oi oj">// Retrieve all courses<br/>GET     <a class="ae lz" href="http://localhost:8080/api/courses" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/courses</a></span><span id="2539" class="nk mn it nz b gy op oh l oi oj">// Create a course<br/>POST    <a class="ae lz" href="http://localhost:8080/api/courses" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/courses</a></span><span id="6465" class="nk mn it nz b gy op oh l oi oj">// Delete a course<br/>DELETE  <a class="ae lz" href="http://localhost:8080/api/courses/%7BcourseId%7D" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/courses/{courseId}</a></span><span id="483a" class="nk mn it nz b gy op oh l oi oj">// Update a course<br/>PUT     <a class="ae lz" href="http://localhost:8080/api/courses/%7BcourseId%7D" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/courses/{courseId}</a></span></pre><h2 id="0583" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">完整源代码</h2><p id="2173" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">您可以在<a class="ae lz" href="https://github.com/sarindufit/ngxs-crud-app" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个示例应用程序的完整源代码。请注意，我还将Spring Boot应用程序(REST API)的可执行JAR文件(course-1.0.0-SNAPSHOT.jar)添加到了同一个存储库中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/305ed4bc5734b98bd2bdfcb7d89c3441.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*qzsmSJI8EO-VgnvkggtVAA.png"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="160f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">设置项目</h1><h2 id="b1aa" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated"><strong class="ak">使用的软件版本</strong></h2><ul class=""><li id="ab83" class="lq lr it kw b kx ne la nf ld ot lh ou ll ov lp lv lw lx ly bi translated">角度CLI: 8.0.1</li><li id="c8ae" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">节点:11.6.0</li><li id="c39c" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">角度:8.0.2</li><li id="e3f0" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">NGXS: 3.6.2</li><li id="e74d" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">引导程序:4.4.1</li></ul><h2 id="4af0" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">项目初始化</h2><p id="c8ad" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">步骤1:执行下面的命令并创建一个新项目。</p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="6fbb" class="nk mn it nz b gy og oh l oi oj">ng new ngxs-crud-app</span></pre><p id="93ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">步骤2:我们将使用<a class="ae lz" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>向我们的应用程序添加样式。您可以使用下面的命令安装Bootstrap。</p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="fa12" class="nk mn it nz b gy og oh l oi oj">npm install bootstrap --save</span></pre><p id="4311" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">步骤3:通过更新<code class="fe nw nx ny nz b">angular.json</code>文件导入引导程序，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="99e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">步骤4:安装NGXS依赖项。</p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="77af" class="nk mn it nz b gy og oh l oi oj">npm install @ngxs/store --save<br/>npm install @ngxs/logger-plugin @ngxs/devtools-plugin --save-dev</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="148e" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">向根模块添加NGXS支持</h1><p id="a9ea" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">为了将NGXS支持添加到您的应用程序中，您必须更新<code class="fe nw nx ny nz b">app.module.ts</code>文件，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="7ffb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，在完成应用程序之前，我们将对该文件进行一些额外的调整。</p><h2 id="e3e0" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated"><strong class="ak">特别说明</strong></h2><ul class=""><li id="28ca" class="lq lr it kw b kx ne la nf ld ot lh ou ll ov lp lv lw lx ly bi translated"><code class="fe nw nx ny nz b">NgxsReduxDevtoolsPluginModule</code>模块已注册，以便将应用程序与<a class="ae lz" href="http://extension.remotedev.io/" rel="noopener ugc nofollow" target="_blank"> Redux Devtools扩展</a>集成。</li><li id="d029" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">是一个简单的控制台日志插件，用于记录正在处理的操作。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="5786" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">创建和设置“课程”功能模块</h1><h2 id="c49f" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">生成“课程”模块</h2><p id="16de" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">如前所述，我们的应用程序由两个主要模块组成，<code class="fe nw nx ny nz b">App</code>和<code class="fe nw nx ny nz b">Course</code>。现在是用下面的命令创建<code class="fe nw nx ny nz b">Course</code>模块的时候了。</p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="a686" class="nk mn it nz b gy og oh l oi oj">ng generate module course</span></pre><p id="c7df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该命令将在<code class="fe nw nx ny nz b">app</code>文件夹下直接创建一个名为<code class="fe nw nx ny nz b">course</code>的子文件夹。此外，一个名为<code class="fe nw nx ny nz b">course.module.ts</code>的新文件将被创建并放在<code class="fe nw nx ny nz b">app/course</code>文件夹下。</p><p id="826c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是<code class="fe nw nx ny nz b">course.module.ts</code>文件的初始版本。注意，这个文件将在下游被修改，以声明组件和声明服务提供者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="40da" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">定义“课程”模型</h2><p id="fac7" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">下一步，您必须定义代表<code class="fe nw nx ny nz b">Course</code>实体的模型接口。创建一个名为<code class="fe nw nx ny nz b">course.model.ts</code>的文件，并将其放在<code class="fe nw nx ny nz b">app/course/model</code>文件夹下。这个文件的内容应该如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="c035" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">定义服务类别</h2><p id="b7a7" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">服务用于与REST API交互并执行数据操作。为了定义服务类，创建一个名为<code class="fe nw nx ny nz b">course.service.ts</code>的文件，并将其放在<code class="fe nw nx ny nz b">app/course/services</code>文件夹下。</p><p id="22e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个文件的内容应该如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="79b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，它有通过REST API检索、创建、更新和删除<code class="fe nw nx ny nz b">Course</code>实体的方法。一旦定义了服务类，您必须在如下所示的<code class="fe nw nx ny nz b">course.module.ts</code>文件中注册它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a6be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图说明了此时我们的应用程序的文件夹结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/0870e82e0672d1d6de524e892589320c.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*SXCGm8Y-XDvJ5GcPF0SqDg.png"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="ac69" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">将NGXS工件添加到“课程”模块</h1><p id="adf7" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">下一步，您必须定义NGXS工件，比如状态类、动作和选择。这些工件将被创建在一个名为<code class="fe nw nx ny nz b">store</code>的目录中，该目录位于<code class="fe nw nx ny nz b">app/course</code>目录下。</p><h2 id="902c" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">定义NGXS操作(course.actions.ts)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="6669" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们为四个不同的CRUD操作定义了四个动作— <code class="fe nw nx ny nz b">AddCourse</code>、<code class="fe nw nx ny nz b">GetCourses</code>、<code class="fe nw nx ny nz b">UpdateCourse</code>和<code class="fe nw nx ny nz b">DeleteCourse</code>。</p><h2 id="8e27" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">定义状态和选择(course.state.ts)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2c12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">特别说明:</strong></p><ul class=""><li id="9550" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">定义应用程序状态(@State): </strong>如前一节所述，在NGXS中，状态是定义状态容器的类。这些类持有整个应用程序状态的不同部分。在上面的文件中，<code class="fe nw nx ny nz b">CourseState</code>保存了属于课程模块的状态片。该状态片的格式定义如下。<code class="fe nw nx ny nz b">courses</code>属性保存加载到状态的课程实体数组。<code class="fe nw nx ny nz b">areCoursesLoaded</code>是一个布尔标志，用于表示课程是否已经加载到状态中。</li></ul><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="75f0" class="nk mn it nz b gy og oh l oi oj">export class CourseStateModel {</span><span id="6d4f" class="nk mn it nz b gy op oh l oi oj">  courses: Course[];</span><span id="edbc" class="nk mn it nz b gy op oh l oi oj">  areCoursesLoaded: boolean;</span><span id="67bc" class="nk mn it nz b gy op oh l oi oj">}</span></pre><ul class=""><li id="18f5" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">定义状态片标识符:</strong>下面代码片段中的<code class="fe nw nx ny nz b">name</code>属性表示表示课程模块的状态片的名称。在这个实例中，<code class="fe nw nx ny nz b">courses</code>切片包含了所有课程的相关信息。</li></ul><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="1ae7" class="nk mn it nz b gy og oh l oi oj">@State&lt;CourseStateModel&gt;({</span><span id="2613" class="nk mn it nz b gy op oh l oi oj">  name: 'courses',</span><span id="5e63" class="nk mn it nz b gy op oh l oi oj">  defaults: {</span><span id="f202" class="nk mn it nz b gy op oh l oi oj">      courses: [],</span><span id="04b2" class="nk mn it nz b gy op oh l oi oj">      areCoursesLoaded: false</span><span id="50bc" class="nk mn it nz b gy op oh l oi oj">  }</span><span id="8fb4" class="nk mn it nz b gy op oh l oi oj">})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/f5953b313a27a9c0da3a244d54c3af18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*BEEbLHuIacw0l6VGkqpqbA.png"/></div></figure><ul class=""><li id="3860" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">定义选择(@Selector): </strong>在上面的文件中，我们定义了两个选择，分别用于从状态中检索课程列表和检查<code class="fe nw nx ny nz b">areCoursesLoaded</code>标志的值。</li><li id="1b53" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu">定义动作监听器(@Action): </strong>这些是监听分派给商店的不同动作的函数。基于在@Action decorator中指定的动作类型，相应的函数将被调用。例如，如果您将类型为<code class="fe nw nx ny nz b">GetCourses</code>的动作分派给商店，将会调用下面的函数。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f871" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在此阶段，您的项目文件夹结构应该如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/e5aebffd632546cd7eb222ab8c29e68c.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*2rnQwM-TQidt15HkrJtQpQ.png"/></div></figure><h2 id="f97c" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">在NGXS模块中注册课程状态</h2><p id="3740" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在定义了NGXS工件之后，您必须将<code class="fe nw nx ny nz b">CourseState</code>附加到父NGXS模块。如前一节所示，NGXS模块是在<code class="fe nw nx ny nz b">app.module.ts</code>文件中定义的。让我们在该文件中做一个小小的调整，并在NGXS父模块中注册<code class="fe nw nx ny nz b">CourseState</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="c0f9" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">创建组件和定义路线</h1><p id="0831" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">正如我们前面讨论的，我们的应用程序由两个主要模块组成，即<code class="fe nw nx ny nz b">App</code>和<code class="fe nw nx ny nz b">Course</code>。课程模块由两部分组成，即<code class="fe nw nx ny nz b">courses-list</code>和<code class="fe nw nx ny nz b">create-course</code>。</p><p id="87f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的下一步是创建这两个组件并定义相应的路由。注意，<code class="fe nw nx ny nz b">courses-list</code>和<code class="fe nw nx ny nz b">create-course</code>目录将被创建在<code class="fe nw nx ny nz b">app/course/component</code>目录下。</p><h2 id="abb2" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">定义“课程-列表”组件</h2><p id="bf28" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">模板:<code class="fe nw nx ny nz b">courses-list.component.html</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ba99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件:<code class="fe nw nx ny nz b">courses-list.component.ts</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="904a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">特别说明:</strong></p><p id="c411" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该组件负责简化列表、更新和删除操作。</p><h2 id="67b6" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">定义“创建课程”组件</h2><p id="dafa" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">模板:<code class="fe nw nx ny nz b">create-course.component.html</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e938" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件:<code class="fe nw nx ny nz b">create-course.component.ts</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="9f84" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">在课程模块中声明组件</h2><p id="7282" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">您必须在已经创建好的<code class="fe nw nx ny nz b">course.module.ts</code>文件中声明上述组件。此外，这些组件将在<code class="fe nw nx ny nz b">app.module.ts</code>文件中用于定义路线。为了将这些组件暴露给<code class="fe nw nx ny nz b">app.module.ts</code>文件，您必须在<code class="fe nw nx ny nz b">exports</code>数组中定义这些组件。请注意，我还导入了<code class="fe nw nx ny nz b">FormsModule</code>和<code class="fe nw nx ny nz b">HttpClientModule</code>，它们将分别被模板和服务使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="6600" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">配置路线</h2><p id="d50e" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">现在是时候定义路线并将相应的组件与这些路线相关联了。这必须在<code class="fe nw nx ny nz b">app.module.ts</code>中完成，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="0aa4" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">定义路由器出口</h2><p id="dbb9" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">作为最后一步，您必须在<code class="fe nw nx ny nz b">app.component.html</code>中定义路由器出口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="dd58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个阶段，你的文件夹结构应该如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/a4f6b526973f0e63d1a74ae7920b89c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*YO3GOrnSBctluOdTjlUveQ.png"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="5796" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">配置代理以访问REST API</h1><p id="7963" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">正如本文开头提到的，我们使用一个用Spring Boot编写的简单的REST API来连接Angular应用程序。</p><p id="eff1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Spring Boot应用程序在<code class="fe nw nx ny nz b">localhost:8080</code>运行，而角度应用程序在<code class="fe nw nx ny nz b">localhost:4200</code>运行。当Angular应用程序试图访问REST API时，这种不匹配将导致跨源资源共享(CORS)错误。为了解决这个问题，我们必须创建一个代理。</p><h2 id="d797" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">创建代理文件</h2><p id="cdaf" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在项目的根文件夹中创建一个名为<code class="fe nw nx ny nz b">proxy.conf.json</code>的文件(与<code class="fe nw nx ny nz b">package.json</code>文件在同一层)，并在其中添加以下内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="75ce" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">注册代理文件</h2><p id="5096" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在CLI配置文件<code class="fe nw nx ny nz b">angular.json</code>中，将<code class="fe nw nx ny nz b">proxyConfig</code>选项添加到<code class="fe nw nx ny nz b">serve</code>目标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="248d" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">运行应用程序</h1><p id="c852" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">应用程序应该分两步启动。您必须首先启动Spring Boot应用程序(REST API ),然后启动Angular应用程序。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="e0db" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">运行Spring Boot应用程序(REST API)</h1><p id="c800" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">Spring Boot应用程序被打包成一个名为<code class="fe nw nx ny nz b">course-1.0.0-SNAPSHOT.jar</code>的可执行JAR文件，放在<a class="ae lz" href="https://github.com/sarindufit/ngxs-crud-app" rel="noopener ugc nofollow" target="_blank">这里(GitHub) </a>。</p><p id="9722" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，要执行这个JAR文件，您必须在系统上安装Java 8。如果安装了Java 8，您可以执行下面的命令并启动应用程序。</p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="34d7" class="nk mn it nz b gy og oh l oi oj">java -jar {path_to_the_jar_file}/course-1.0.0-SNAPSHOT.jar</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="a62e" class="nk mn it bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">运行角度应用程序</h2><p id="07d4" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">可通过执行以下命令启动角度应用。</p><pre class="kj kk kl km gt oc nz od oe aw of bi"><span id="d521" class="nk mn it nz b gy og oh l oi oj">ng serve</span></pre><p id="0775" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当应用程序成功启动时，从您的浏览器导航到<code class="fe nw nx ny nz b">http://localhost:4200/courses</code>，您应该会看到下面的屏幕。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f90f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="5eb8" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">这个故事的主要目的是提供一个分步指南来构建一个基于NGXS的Angular应用程序。如果您以前使用过NgRx，您会理解与NgRx相比，NGXS的样板代码更少。在我的下一篇文章中，我希望通过使用Akita作为状态管理系统来实现类似的CRUD应用程序。随后，我们可以将NgRx、NGXS和Akita作为状态管理系统进行比较。</p></div></div>    
</body>
</html>