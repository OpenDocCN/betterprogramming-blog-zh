<html>
<head>
<title>How To Implement Authentication in React Using Auth0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Auth0在React中实现认证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-authentication-in-react-using-auth0-1b5ecb6c8fe0?source=collection_archive---------5-----------------------#2020-01-03">https://betterprogramming.pub/how-to-implement-authentication-in-react-using-auth0-1b5ecb6c8fe0?source=collection_archive---------5-----------------------#2020-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ab87" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">现代技术堆栈中PKCE的授权代码流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9aeb752fd0af591c4ad0a3f1c987f12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mMCYwce7GTLAibGe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰森·黑眼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="eb0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" href="https://medium.com/better-programming/how-to-securely-implement-authentication-in-single-page-applications-670534da746f" rel="noopener">上一篇文章</a>中，我讲述了在单页面应用程序中实现OAuth和OpenID Connect时的正确认证流程。我知道这是一个巨大的信息量，肯定难以下咽，但让我们把这些新知识投入使用。在这篇文章中，我将展示之前提出的概念的实现。</p><p id="edc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中讨论的所有代码都可以在下面的存储库中找到:</p><div class="lv lw gp gr lx ly"><a href="https://github.com/dennisMeeQ/auth0-react-express" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">dennisMeeQ/auth0-react-express</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用Auth0、React和Express在单个应用程序中实现OAuth/OIDC流的示例。请参考…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="71c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以随意克隆它或直接试用部署的代码:</p><div class="lv lw gp gr lx ly"><a href="https://spa-auth0.herokuapp.com" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">所有Auth:用Auth0反应</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用React和Auth0的OAuth/OpenID连接流的示例实现</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">spa-auth0.herokuapp.com</p></div></div></div></a></div><p id="f00d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续创建您自己的帐户。你可以使用一次性电子邮件地址或假电子邮件地址。别担心，我不会卖你邮箱的。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5f3f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">体系结构</h1><p id="7cfb" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">上面显示的演示应用程序由三个组件组成:</p><ul class=""><li id="7b58" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ky" href="https://auth0.com" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>提供的授权服务器</li><li id="188f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">前端或客户端，用React编写</li><li id="5f2f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">后端或者API，用Node.js和Express写的</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/c70cfd8b0f607e16676b6f4f10bd240e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4HxWsPhOruHt8McnCyUmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单页应用程序的基本设置</p></figure><p id="0f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所使用的技术(React、Express和Auth0)是我当前的首选堆栈，但这里显示的原则绝不仅限于此堆栈。</p><p id="1e77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以用另一种SPA视图技术做同样的事情，比如Vue.js或者Angular任何服务器技术(Java &amp; Spring，PHP等。);以及任何OAuth/OpenID连接授权服务器(例如Okta、Keycloak、AWS Cognito等。).</p><p id="524f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我尽量不添加任何特定的技术决策，比如数据库(Mongo或SQL)或样式(material UI或bootstrap)，以尽可能简单地复制和粘贴这些代码。</p><p id="ba62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端和API通过Docker构建和交付，并部署在令人惊叹的Heroku上。必要时，GitHub通过<a class="ae ky" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank">动作</a>直接提供自动化。</p><p id="029f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序的相当一部分代码摘自Auth0关于单页应用程序的教程。它提供了一个很好的起点，但是，以我的拙见，它没有解释一些重要的细节。让我们来解决这个问题！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="cf83" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">授权服务器</h1><p id="444c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们应该设置的第一件事是我们的授权服务器。为此，前往https://auth0.com的<a class="ae ky" href="https://auth0.com" rel="noopener ugc nofollow" target="_blank">，创建一个免费账户。</a></p><p id="bc31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在注册过程中，您将被要求提供您的租户域。这很重要，因为这将是您未来的应用程序用于登录的域。所以一定要选择比“foobar”更有意义的东西如果您需要遵守地区法律，例如欧洲的GDPR，地区也很重要。否则最大的区别大概就是性能了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/ae0c7348a330c4bb8aef30e7f3f49bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNpj2Rx_q_Hvi0UHR5PnYQ.png"/></div></div></figure><p id="fb53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">登录后，创建一个新的应用程序。您将被要求输入名称和类型。名称并不重要，以后可以更改。对于类型，选择单页应用程序。后者很重要，因为它会自动配置一些重要的参数，比如OAuth认证流。</p><p id="efa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建应用程序后，您将进入快速入门部分，该部分提供了设置和实现应用程序的基本指南。如上所述，您可以遵循该教程，最终您将获得一个非常好的基线。或者你可以在这里继续阅读，获得完整的图片。</p><p id="a8fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的新应用程序中，在“设置”下，我们可以对设置进行更多更改:</p><ul class=""><li id="5b84" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">在Allowed Callback URLs下，我们需要定义一组URL，Auth0可以在成功登录后将用户重定向到这些URL。对于开发来说，React的默认URL(<a class="ae ky" href="http://localhost:3000`" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>)就足够了。我还添加了我的高效前端URL<a class="ae ky" href="https://spa-auth0.herokuapp.com`" rel="noopener ugc nofollow" target="_blank">(https://spa-auth0.herokuapp.com</a>)。</li><li id="fa73" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">应该在“允许的Web源”下设置相同的URL集。</li><li id="2585" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">使用允许的注销URL，您可以设置在注销后允许Auth0重定向到哪里。我使用与这里允许的回调URL相同的URL。</li><li id="c03a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">根据JWT到期，您可以设置令牌的生命周期。您可以保留默认值(10小时)，但我通常根据应用程序将它设置为1-2小时(360-720)。</li><li id="e3be" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">稍后配置我们的客户端应用程序时，将需要客户端ID。</li></ul><p id="8657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，目前，在开始编码之前，我们还有一件事要做:一个API。用Auth0的术语来说，API是一个端点，在您的客户端应用程序收到令牌后，它将消费令牌。在我们上面的图片中，它是后端。</p><p id="8de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到Auth0菜单中的API，并创建一个。您为它选择的名称无关紧要，但标识符很重要。如果你已经知道API的全限定URL，你应该在这里选择——类似于<a class="ae ky" href="https://api.allthingsauth.dev" rel="noopener ugc nofollow" target="_blank">https://API . all things sauth . dev</a>。不要担心，它不一定要在互联网上可用，甚至还不存在。这只是一个名称，但它应该是唯一的，并标识您的端点。它的网址是一个很好的选择，但是如果你愿意，你也可以叫它“埃斯梅拉达”。我不会阻止你。</p><p id="be16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为签名算法，对于在签名模式下使用<a class="ae ky" href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" rel="noopener ugc nofollow" target="_blank"> RSA </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/SHA-2" rel="noopener ugc nofollow" target="_blank"> SHA256 </a>作为哈希算法的<a class="ae ky" href="https://en.wikipedia.org/wiki/Public-key_cryptography" rel="noopener ugc nofollow" target="_blank">非对称</a>密钥签名，您应该在这里选择RS256。</p><p id="896d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我们有一个正在运行的授权服务器，可以开始研究我们的API了。终于有代码了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="25a8" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">API保护</h1><p id="693b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们的API有两个简单的端点，显示来自“星球大战”的一些内容(我从awesome <a class="ae ky" href="https://www.swapi.co/" rel="noopener ugc nofollow" target="_blank"> SWAPI </a>借用了这些内容):一个载入一些关于物种的信息，第二个载入关于“星球大战”宇宙中的角色的信息。您可以在浏览器中或通过shell上的curl亲自尝试:</p><ul class=""><li id="4f96" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ky" href="https://api-auth0.herokuapp.com/species" rel="noopener ugc nofollow" target="_blank">https://api-auth0.herokuapp.com/species</a></li><li id="8bf2" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://api-auth0.herokuapp.com/people" rel="noopener ugc nofollow" target="_blank">https://api-auth0.herokuapp.com/people</a></li></ul><p id="cf6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个函数返回一个JSON对象，和预期的一样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="24b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，第二个行为古怪，返回:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="21de" class="oo mv it ok b gy op oq l or os"><em class="ot">{“msg”:”Invalid token”}</em></span></pre><p id="0f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看代码，并尝试找出原因:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="cd64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这里创建的两个端点在本质上非常相似。唯一的区别是其中一个使用了<code class="fe ou ov ow ok b">authenticated</code> <em class="ot"> </em>中间件，而另一个没有。</p><p id="ecc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个中间件是奇迹发生的地方，接下来让我们来看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="d6fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的中间件需要理解OpenID Connect定义的JWT格式的令牌。</p><p id="b2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们首先需要配置一些选项来将我们的授权服务器标识为我们的令牌的一个<code class="fe ou ov ow ok b">issuer</code> <em class="ot"> </em>。在本例中，这是我们之前创建的Auth0租户。指定该值对于定义我们不希望接受来自任何其他服务器的令牌非常重要。将此配置值与令牌中包含的值进行比较是验证令牌的第一步。</p><p id="e2fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ok b">audience</code> <em class="ot"> </em>值向Auth0和客户端应用程序标识我们的API，我们还需要用令牌上的值对此进行交叉检查。为什么？如果一个系统有不止一个API，并且授权服务器想要发布对一个API有效但对另一个API无效的令牌，这就变得很重要了。</p><p id="3097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ok b">algorithm</code> <em class="ot"> </em>设置指定了预期用于对令牌进行签名的签名算法。将它设置为我们之前在Auth0: <code class="fe ou ov ow ok b">RS256</code>创建API时选择的值。</p><p id="d07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够实际验证令牌的签名，我们需要授权服务器的公钥。向我们的API提供这个的最简单的方法是作为一个配置值。但是这相当笨重，不太灵活，并且不能很好地处理授权服务器上的<a class="ae ky" href="https://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys" rel="noopener ugc nofollow" target="_blank">密钥轮换</a>。</p><p id="c1b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的方法是在运行时从授权服务器加载公钥，然后缓存一段时间。</p><p id="9861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，这是使用<code class="fe ou ov ow ok b">jwks-rsa</code>包实现的，该包以<a class="ae ky" href="https://tools.ietf.org/html/rfc7517" rel="noopener ugc nofollow" target="_blank"> JWK </a>格式从服务器加载密钥。在上面的代码示例中，用于加载此内容的URL(在我们的示例中为<a class="ae ky" href="https://spa-test.auth0.com/v2/.well-known/jwks.json" rel="noopener ugc nofollow" target="_blank">https://spa-test.auth0.com/v2/.well-known/jwks.json</a>)被指定为依赖于发布者URL的配置值。</p><p id="0808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们也可以将OIDC配置元数据端点(<a class="ae ky" href="https://spa-test.auth0.com/v2/.well-known/openid-configuration" rel="noopener ugc nofollow" target="_blank">https://spa-test.auth0.com/v2/.知名/openid-configuration </a>)在运行时获取这个URL(见<code class="fe ou ov ow ok b">jwks_uri</code> <em class="ot"> </em>参数)。所有这些都是由OpenID Connect指定的。</p><p id="f97d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为为每个API请求加载公钥会非常低效和缓慢，所以密钥应该被缓存一段时间。缓存时间到期或签名无效会触发我们的API从授权服务器重新加载公钥。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0df8" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">令牌时间</h1><p id="d431" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">汪，现在我们终于有了所有的成分来验证传递给API的令牌。当(base64)解码时，这样的标记可能如下所示:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="2a25" class="oo mv it ok b gy op oq l or os">{<br/>  "typ": "JWT",<br/>  "alg": "RS256",<br/>  "kid": "RkU2MjcxOEU1N0JENzEzNzBBQ0QwREQ5NTM1NjU1ODU0QzQxNjc1Mw"<br/>}.<br/>{<br/>  "iss": "https://spa-test.auth0.com/",<br/>  "sub": "auth0|5daaba984718d10c5d15dd1e",<br/>  "aud": [<br/>    "https://api.allthingsauth.dev",<br/>    "https://spa-test.auth0.com/userinfo"<br/>  ],<br/>  "iat": 1577204248,<br/>  "exp": 1577290648,<br/>  "azp": "melxSZVFgL9ONwTaggwozHOsjeTVvJOF",<br/>  "scope": "openid profile email"<br/>}.<br/>[...signature...]</span></pre><p id="4028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，需要检查令牌的以下方面，以确保它是有效的:</p><ul class=""><li id="9b0b" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe ou ov ow ok b">iss</code>值与来自配置(<em class="ot">发行方</em>)的预期值一致</li><li id="18a6" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe ou ov ow ok b">alg</code>值是我们所期望的(配置<em class="ot">算法</em></li><li id="645b" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe ou ov ow ok b">aud</code>数组包含我们的API的<em class="ot">观众</em>值</li><li id="3585" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">令牌未过期。为了检查这一点，我们需要确保<code class="fe ou ov ow ok b">exp</code>时间戳不是在过去。在这里，允许几分钟的<a class="ae ky" href="https://en.wikipedia.org/wiki/Clock_skew" rel="noopener ugc nofollow" target="_blank">时钟偏差</a>是可以的。</li><li id="7436" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">最后但同样重要的是，签名与令牌的内容相匹配</li></ul><p id="7f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们不需要自己实现所有这些，因为我们使用了<code class="fe ou ov ow ok b">express-jwt</code> npm包(由Auth0提供)来为我们完成所有这些。</p><p id="6e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该库返回一个express中间件，我们可以将它传递给经过身份验证的端点。通过这样做，我们只允许在请求包含前面定义的有效令牌的情况下访问这个端点。让我们试试这个:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="1452" class="oo mv it ok b gy op oq l or os">$&gt; curl 'https://api-auth0.herokuapp.com/people' -H 'Authorization: Bearer eyJ0eXAiO…cFA94GEhPqnt5w'</span><span id="8bc7" class="oo mv it ok b gy ox oq l or os">{“people”:[{“name”:”Yoda”,”height”:”66",”birth_year”:”896BBY”,”gender”:”male”,”species”:”Yoda’s species”},{“name”:”Luke Skywalker”,”height”:”172",”birth_year”:”19BBY”,”gender”:”male”,”species”:”Human”},{“name”:”C-3PO”,”height”:”167",”birth_year”:”112BBY”,”gender”:”n/a”,”species”:”Droid”},{“name”:”Leia Organa”,”height”:”150",”birth_year”:”19BBY”,”gender”:”female”,”species”:”Human”},{“name”:”R2-D2",”height”:”96",”birth_year”:”33BBY”,”gender”:”n/a”,”species”:”Droid”},{“name”:”Chewbacca”,”height”:”228",”birth_year”:”200BBY”,”gender”:”male”,”species”:”Wookiee”},{“name”:”Jabba Desilijic Tiure”,”height”:”175",”birth_year”:”600BBY”,”gender”:”hermaphrodite”,”species”:”Hutt”}]}</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6f5d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">注册</h1><p id="df8a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在，让我们看看前端应用程序以及用户获取这种令牌的方式。</p><p id="299d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们将使用Auth0作为我们的授权服务器，所以我们也将使用Auth0的连接SDK——它与服务器接口良好。由于我们使用了非常标准的OAuth和OIDC流，我们可以使用任何其他的React库，甚至(我几乎不敢写)自己实现它。</p><p id="a44a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Auth0认证的核心是一个名为<a class="ae ky" href="https://github.com/dennisMeeQ/auth0-react-express/blob/master/client/src/auth/react-auth0-spa.js" rel="noopener ugc nofollow" target="_blank"> react-auth0-spa.js </a>的文件。Auth0提供了一个完全工作的实现,我用它做了一些小的改动。我不会在这里详细讨论这个文件。它基本上只是初始化一个Auth0客户端，并将其放入一个具有现代和性感的自定义钩子的React上下文中，并公开提供者。有了钩子，每当我们需要在一个组件中使用Auth0时，我们只需调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="1ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了设置<code class="fe ou ov ow ok b">Auth0Provider</code>，我们需要在应用程序的根目录(通常是<code class="fe ou ov ow ok b">index.js</code>)中用React <code class="fe ou ov ow ok b">App</code>对象包装它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="a434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面提到的三个配置值是:</p><ul class=""><li id="357d" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe ou ov ow ok b">domain</code>只是我们之前配置的Auth0端点的URL</li><li id="12ae" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe ou ov ow ok b">client_id</code>惟一地标识了我们的客户端应用程序，我们可以在Auth0客户端配置中找到正确的值</li><li id="40df" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe ou ov ow ok b">audience</code>是我们想要调用的API端点的ID，可以在Auth0 API配置中找到</li></ul><p id="0c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们有了Auth0 SDK的基本设置，现在可以开始工作了。第一:登录。我们只是为用户提供一个登录按钮来点击，仅此而已:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="298f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用的登录流程是PKCE的授权代码流程。所有血淋淋的细节请参考我的<a class="ae ky" href="https://medium.com/better-programming/how-to-securely-implement-authentication-in-single-page-applications-670534da746f" rel="noopener">上一篇文章</a>。我们的客户端应用程序需要担心这个流程中的三件事:</p><ol class=""><li id="d52f" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu oy nx ny nz bi translated">将用户的浏览器重定向到Auth0</li><li id="6ec1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oy nx ny nz bi translated">用户在Auth0处输入凭据后，他们将被重定向回带有授权代码的客户端应用程序。我们的应用程序需要提供一个回调来正确地响应这个重定向。</li><li id="ffad" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oy nx ny nz bi translated">重定向之后，客户端需要对Auth0执行POST请求，以将授权代码交换为令牌</li></ol><p id="235d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来很复杂？不要担心Auth0库会自动为您完成所有这些工作。</p><p id="2897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续<a class="ae ky" href="https://spa-auth0.herokuapp.com" rel="noopener ugc nofollow" target="_blank">尝试一下</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/40e0dcde8a18b3ecb92e7eec84c890ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*w55fm5UcYyW4_hu5nZszOQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演示应用中经过验证的组件</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0a19" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">经过身份验证的组件和API调用</h1><p id="01c6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果您尝试过该应用程序，您可能会注意到在登录后，顶部导航中会出现两个新的菜单项:People和Profile。当您注销时，它们会消失。这就是我所说的<em class="ot">认证组件。请注意，这不是一项安全功能，而是一项UX功能。</em></p><p id="001d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们需要教会我们的React路由器仅在当前用户通过身份验证的情况下路由到这些组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="cdb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里使用的<code class="fe ou ov ow ok b">AuthenticatedRoute</code>组件是Auth0提供的<a class="ae ky" href="https://github.com/auth0-samples/auth0-react-samples/blob/master/01-Login/src/components/PrivateRoute.js" rel="noopener ugc nofollow" target="_blank">示例实现</a>，我没有做任何改动就使用了它。</p><p id="8bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它基本上包装了一个普通的组件，并检查用户是否经过身份验证。如果不是，它首先尝试让用户静默登录。如果失败，它会将用户重定向到Auth0登录屏幕。只有在用户通过身份验证后，它才会将用户路由到目标组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/78af293fc4ad9849500d018870eda777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yoNZ5ldGApfvAU5P5rEQrg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调用经过身份验证的组件时自动登录</p></figure><p id="f23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在这样一个经过身份验证的组件中，我们通常希望调用一个本身经过身份验证的API端点。正如我们在上面看到的，我们需要在<code class="fe ou ov ow ok b">Authorization</code>头中提供一个令牌，以允许从中读取数据。让我们看看如何做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="f824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们使用<code class="fe ou ov ow ok b">getTokenSilently()</code>从Auth0模块请求令牌。</p><p id="b031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们调用<a class="ae ky" href="https://api-auth0.herokuapp.com/people" rel="noopener ugc nofollow" target="_blank">https://api-auth0.herokuapp.com/people</a>并将令牌放入适当的报头中。如果API端点认为我们的令牌有价值，它将返回请求的数据。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2b62" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">令牌刷新</h1><p id="ca18" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">有两种情况我们需要刷新用户的令牌:</p><ol class=""><li id="16ac" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu oy nx ny nz bi translated">当令牌过期但用户执行另一个操作时，如加载经过身份验证的API</li><li id="6c75" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oy nx ny nz bi translated">当页面重新加载时。请记住，我们是在一个单页面应用程序中，所有的应用程序状态，包括用户的令牌，都保存在内存中。当页面重新加载时，这个内存范围被销毁并重新初始化。</li></ol><p id="ac3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望对用户来说，这两种情况都能尽可能平稳地处理，最好是在用户没有察觉的情况下。Auth0库会为您做这件事，您不必担心。</p><p id="7c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，当用户在Auth0登录时，将在用户的浏览器中为该主机设置一个会话cookie。稍后，当我们由于上述两个原因之一需要会话刷新时，Auth0库将使用不可见的iframe和web消息执行不可见的令牌刷新。这个过程在我的<a class="ae ky" href="https://medium.com/better-programming/how-to-securely-implement-authentication-in-single-page-applications-670534da746f" rel="noopener">上一篇</a>中有描述，这里就不赘述了。</p><p id="1aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要从React应用程序内部自己触发这个不可见的刷新，我们总是可以调用<code class="fe ou ov ow ok b">getTokenSilently()</code>方法。这将为您提供缓存的令牌，或者，如果它不可用，执行不可见的流来获取令牌。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a125" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">注销</h1><p id="6b94" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">与令牌刷新类似，注销也非常简单:Auth0库处理繁重的工作。当用户单击注销按钮时，我们可以调用相应的函数——就像之前看到的登录一样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="48aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Auth0库将首先销毁客户端应用程序中的任何缓存令牌。然后，用户将被重定向到Auth0，这将依次删除存储在那里的会话cookie。之后，用户将被重定向回客户端应用程序。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2dc8" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">安全性</h1><p id="4ca4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在我的<a class="ae ky" href="https://medium.com/better-programming/how-to-securely-implement-authentication-in-single-page-applications-670534da746f" rel="noopener">上一篇文章</a>中，我谈了很多关于安全性以及它在实现认证时的重要性。让我们仔细检查列表，看看我们是否修补了所有漏洞:</p><ul class=""><li id="11a5" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><strong class="lb iu"> TLS: </strong>安全第一法则？使用TLS。在这种情况下，我可以依赖Heroku——因为它会自动创建TLS证书并为我的应用程序部署它们。爱死了！</li><li id="de42" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu">重定向保护:</strong>在这里，Auth0保护了我们。之前在Auth0中配置我们的客户端时，我们配置了重定向URL(<em class="ot">回调URL，</em>作为Auth0调用它们)。Auth0将拒绝重定向到除这些已配置的URL之外的任何URL。</li><li id="89ba" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"> CSRF保护:</strong>这也是Auth0开箱即用通过PKCE流和状态参数提供的。这两个都是在使用Auth0的库时自动设置的，我们不必担心。</li></ul><p id="bd01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们只剩下一个我们必须自己花费一些脑力的领域:<em class="ot">跨站点脚本保护(XSS)。</em></p><h2 id="4d33" class="oo mv it bd mw pb pc dn na pd pe dp ne li pf pg ng lm ph pi ni lq pj pk nk pl bi translated">XSS</h2><p id="a45d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks" rel="noopener ugc nofollow" target="_blank"> React </a>已经对<a class="ae ky" href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)" rel="noopener ugc nofollow" target="_blank">跨站脚本</a>攻击有了很好的内置保护。因此，仅仅通过我们的架构选择，我们已经朝着挫败这些讨厌的攻击迈出了一大步。</p><p id="5d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据我所知，还有两个攻击点。其中之一是，开发人员通过在JSX元素上使用<a class="ae ky" href="https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml" rel="noopener ugc nofollow" target="_blank">dangerouslySetInnerHTML</a>属性，选择明确放弃React的保护机制，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="1fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法允许我们设置元素的innerHTML，而不使用React的内置转义机制来防止XSS。不太好。</p><p id="7a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止一个开发者不小心使用这个，我们可以使用一个非常简单但是有效的保护:ESLint。它的<a class="ae ky" href="https://github.com/yannickcr/eslint-plugin-react" rel="noopener ugc nofollow" target="_blank"> react插件</a>有一个内置的规则叫做<a class="ae ky" href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/no-danger.md" rel="noopener ugc nofollow" target="_blank"> react/no-danger </a>，应该可以让你远离麻烦……我的意思是脱离危险区。</p><p id="fef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该规则会将任何对<code class="fe ou ov ow ok b">dangerouslySetInnerHTML</code>的使用显示为错误，并让你三思。</p><p id="11b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您随后验证您的ESLint扫描在每次提交或至少每次构建或拉取请求时都是干净的，那么您就万事俱备了。你可以在你的CI/CD工具中或者直接在GitHub中用一些<a class="ae ky" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank">动作</a>来完成。我喜欢自己的一些好行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="0ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我不仅在倒数第二个步骤中运行ESLint，还将<code class="fe ou ov ow ok b">npm audit</code>作为最后一个命令。这会检查npm自己的漏洞数据库，并在发现问题时中断构建。这试图解决第二个仍然开放的攻击媒介:第三方库。从历史上看，这些是React应用程序中许多<a class="ae ky" href="https://app.snyk.io/vuln/SNYK-JS-SERIALIZEJAVASCRIPT-536840" rel="noopener ugc nofollow" target="_blank">【XSS】</a><a class="ae ky" href="https://snyk.io/vuln/npm:handlebars:20151207" rel="noopener ugc nofollow" target="_blank">问题</a>的来源。</p><p id="8c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对此的解决方案是将内置的<code class="fe ou ov ow ok b">npm audit</code>与一个良好的依赖检查工具如<a class="ae ky" href="https://snyk.io" rel="noopener ugc nofollow" target="_blank"> snyk </a>结合起来。通常，snyk在新的漏洞被添加到npm数据库之前就知道它们，但是<code class="fe ou ov ow ok b">npm audit</code>有一个好处，当npm被安装时，它可以本地运行。</p><p id="9965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要设置snyk，只需连接你的GitHub repo，然后snyk会每天自动扫描你项目的依赖项，并向你发送一份有新漏洞的报告。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/266d22dfcfc5a054e123c0312ff3b07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UPa9AXaaGfPgcnu-snIJhA.png"/></div></div></figure><p id="65e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以将它配置为在GitHub中运行，处理每个pull请求以及我们的基本检查:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/5d97ff87abd3ff0fd237647cf2f5f22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffZNXGasi2xonAVeselqHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">snyk签入GitHub pull请求</p></figure><p id="17c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您愿意，您甚至可以让snyk向您的存储库创建一个pull请求来修复漏洞。相当漂亮！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="bedb" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="4416" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我希望这篇文章让您对如何在React应用程序中实现OAuth和OpenID Connect有了一个好的印象。以我的拙见，结合Node.js/Express后端和作为授权服务器的Auth0，这是一个很棒的单页面应用程序。但是，当然，还有其他的技术选择可以考虑。</p><p id="2e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章中，我将尝试用不同的授权服务器Keycloak实现相同的设置。敬请关注。</p></div></div>    
</body>
</html>