<html>
<head>
<title>Creating Apps Without Storyboards in iOS 13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS 13中创建不带故事板的应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-apps-without-storyboards-in-ios-13-fc9550bb9c12?source=collection_archive---------1-----------------------#2019-09-25">https://betterprogramming.pub/creating-apps-without-storyboards-in-ios-13-fc9550bb9c12?source=collection_archive---------1-----------------------#2019-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0fe1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建没有故事板的应用程序的分步指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d0ddb0ad6ecaf79aa1b5e87bfa4c2b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANBfrHjoa7TWt8EWvHzXXg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@williamtm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">威廉·胡克</a>在<a class="ae kv" href="https://unsplash.com/s/photos/iphone-app?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4ec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有兴趣在iOS 12或以下版本中创建无故事板的应用，请阅读我之前的文章<a class="ae kv" href="https://medium.com/better-programming/creating-ios-apps-without-storyboards-42a63c50756f" rel="noopener"> <em class="ls">创建无故事板的iOS应用</em> </a>。</p><p id="e68d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多iOS开发文章和教程使用故事板来创建用户界面。这是有意义的，因为它们是创建和修改你的设计的非常直观的方式，并有助于加快学习过程。</p><p id="3856" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，除非你发现自己是一个应用程序的唯一开发者，否则这不是团队环境中专业iOS开发的完全现实的观点。</p><p id="753b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你第一次面对一个只有很少或者没有故事板的应用时，它可能会对系统造成冲击。让我们通过了解在没有故事板的情况下如何设计一个应用程序来为这种可能性做好准备。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b9e0" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">使用编程布局的情况</h1><p id="3dd8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我是一个非常视觉化的人，我个人反对这种方法，所以我可以理解你是否也有这种想法。</p><p id="be30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你曾经在团队环境中工作过，你可能会有一些非常困难的尝试来解决故事板的合并冲突。你可能还会被同事阻止，他们需要在你完成特定任务之前修改故事板。</p><p id="c4df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这些事情还没有发生在你身上，它们会发生的。有一些方法可以缓解这些问题，比如拆分故事板和<a class="ae kv" href="https://docs.elementscompiler.com/Platforms/Cocoa/XIB/" rel="noopener ugc nofollow" target="_blank">xib</a>，但它们并不是万无一失的，一旦你习惯了没有故事板，你就会开始看到好处。</p><p id="6c23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，最大的好处是比你一直坚持故事板更好地理解UIKit。而且，正如我们在<a class="ae kv" href="https://developer.apple.com/wwdc19/" rel="noopener ugc nofollow" target="_blank"> WWDC2019 </a>上看到的<a class="ae kv" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>的首次亮相，故事板真的将成为过去。</p><p id="4038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，为什么这么多的团队环境趋向于去除故事板和xib呢？</p><p id="1019" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了合并冲突和阻塞问题，团队远离故事板的主要原因之一是大多数属性值不容易被审查。</p><p id="400a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从故事板XML中挑选代码很容易出错，因此您最好重做这项工作，这消除了拥有代码存储库的一个优势。让我们看一个例子。</p><p id="5f0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我有一个简单的单视图应用程序，其表单包含两个文本字段和一个按钮。按钮对其中一个文本字段有一个垂直约束，该约束有一个常量<code class="fe mx my mz na b">20</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/bc6fb8fb633e796794a700b86bbfedf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*DhFcaJAiLLfLSS5O3EkEPQ.png"/></div></figure><p id="875a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计师要求我们将这个数字增加到<code class="fe mx my mz na b">40</code>。我进行了更改，提交了一份PR，并指定您为审核人。您可以在PR中看到以下变化。</p><p id="df4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始代码:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="ab90" class="ng mb iq na b gy nh ni l nj nk">&lt;rect key="frame" x="20" y="383" width="374" height="30"/&gt;<br/>&lt;rect key="frame" x="20" y="333" width="374" height="30"/&gt;<br/>&lt;constraint firstItem="pYg-JC-an0" firstAttribute="top" secondItem="Kfc-mn-gVn" secondAttribute="bottom" constant="20" id="r92-HL-ecY"/&gt;</span></pre><p id="9423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修改代码:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="431c" class="ng mb iq na b gy nh ni l nj nk">&lt;rect key="frame" x="20" y="363" width="374" height="30"/&gt;<br/>&lt;rect key="frame" x="20" y="313" width="374" height="30"/&gt;<br/>&lt;constraint firstItem="pYg-JC-an0" firstAttribute="top" secondItem="Kfc-mn-gVn" secondAttribute="bottom" constant="40" id="r92-HL-ecY"/&gt;</span></pre><p id="c1e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里改变了什么？你知道它应该是按钮控件和文本字段之间的约束，但是你确定<code class="fe mx my mz na b">pYg-JC-an0</code>和<code class="fe mx my mz na b">Kfc-mn-gVn</code>是正确的控件吗？</p><p id="7868" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以浏览XML来找到这两个值，但是如果这是一个包含许多控件的复杂视图，并且我修改了所有控件的间距，那该怎么办呢？你真的有时间把他们都找出来吗？</p><p id="09b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果代码就在您面前，在视图控制器中，包含所有其他视图逻辑，不是更容易吗？</p><p id="5634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，在这个例子中，编程布局中的这种修改会是什么样子呢？</p><p id="acf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始约束:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="9f80" class="ng mb iq na b gy nh ni l nj nk">loginButton.topAnchor.constraint(equalTo: passwordTextField.bottomAnchor, constraint: 20)</span></pre><p id="5158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修改的约束:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="1756" class="ng mb iq na b gy nh ni l nj nk">loginButton.topAnchor.constraint(equalTo: passwordTextField.bottomAnchor, constraint: 40)</span></pre><p id="2fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是啊。差别很大。</p><p id="b3d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不仅会使PRs更容易审查，而且追踪与布局相关的bug也变得更加容易。所有与布局相关的设置都将在代码中呈现在你面前，而不是隐藏在Xcode检查器的几十个地方。</p><p id="7dbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，让我们看看没有故事板的情况下需要做些什么。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a84a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">入门指南</h1><p id="739a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了开始学习编程布局，让我们在Xcode中创建新项目。</p><p id="726b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，创建一个单视图应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/f195740ba221771ef69d5b4a8abb6550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5BkQsr1dqRAqIRio8bixQ.png"/></div></div></figure><p id="2310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">把它命名为<code class="fe mx my mz na b">GoodbyeStoryboard</code>。如果你正在使用SwiftUI，你不需要担心这些，所以确保用户界面设置为<code class="fe mx my mz na b">Storyboard</code>。将项目保存在适当的位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/ab4593a41496eedc1454b41fae3d0231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCNEr8QpJcdDD3PgBGfJ8w.png"/></div></div></figure><h2 id="288e" class="ng mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated">删除故事板</h2><p id="182a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">一旦项目被创建并在Xcode中打开，选择<code class="fe mx my mz na b">Main.storyboard</code>文件并删除它。从确认对话框中选择<em class="ls">移至垃圾桶</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/5fa4f883bd0acf4adfb29953ef7b0fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqTGnQXSz8JEpHB--kU9nQ.png"/></div></div></figure><p id="45c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拜拜故事板！</p><p id="7ea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在项目导航器中，选择项目。</p><p id="b024" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<em class="ls">部署信息</em>部分下的<code class="fe mx my mz na b">GoodbyeStoryboard</code>目标中，从主界面字段中删除单词<code class="fe mx my mz na b">Main</code>并按⌘S保存更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/2d625b1e860b5250667d632928bd8174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6VwaNZZ_NeWeiE3tsEDrw.png"/></div></div></figure><p id="ed39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，选择<code class="fe mx my mz na b">Info.plist</code>文件，在列表中展开<code class="fe mx my mz na b">Application Scene Manifest</code> → <code class="fe mx my mz na b">Scene Configuration </code> → <code class="fe mx my mz na b">Application Session Role </code> → <code class="fe mx my mz na b">Item 0</code>并移除项目<code class="fe mx my mz na b">Storyboard Name</code>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c805" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">将ViewController分配给窗口</h1><p id="0f47" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果您现在构建并运行，项目将成功构建，应用程序将运行，但您只会看到一个黑屏。</p><p id="9418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为您的应用程序不再有窗口。而且，即使这样，Xcode为您创建的<code class="fe mx my mz na b">ViewController.swift</code>也不再被设置为窗口的根视图控制器。</p><p id="d231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些都是故事板自动处理的事情，而你却没有意识到。虽然这听起来像是积极的，但这也意味着使用UIKit的一些方面您还没有意识到，这是一个问题。</p><p id="38dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需要少量代码就可以补救这种情况。打开<code class="fe mx my mz na b">SceneDelegate.swift</code>。您将看到一个类型为<code class="fe mx my mz na b">UIWindow?</code>的<code class="fe mx my mz na b">window</code>属性，除了一些空函数，唯一真正的代码在方法<code class="fe mx my mz na b">scene(_:willConnectTo:options:)</code>中，并且只包含一个guard语句。</p><p id="20e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">删除方法<code class="fe mx my mz na b">scene(_:willConnectTo:options:)</code>中的所有现有代码，并替换为以下代码:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="9bd3" class="ng mb iq na b gy nh ni l nj nk">func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {<br/>  guard let windowScene = (scene as? UIWindowScene) else { return }<br/>  window = UIWindow(frame: UIScreen.main.bounds)<br/>  let viewController = ViewController()<br/>  window?.rootViewController = viewController<br/>  window?.makeKeyAndVisible()<br/>  window?.windowScene = windowScene<br/>}</span></pre><p id="b791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个新的场景被添加到应用程序中时，就会执行<code class="fe mx my mz na b">scene(_:willConnectTo:options:)</code>方法，这是实例化我们的应用程序窗口并使<code class="fe mx my mz na b">ViewController</code>成为该窗口的根视图控制器的最佳位置。</p><p id="a7d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一行一行地检查上面的代码:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="e858" class="ng mb iq na b gy nh ni l nj nk">guard let windowScene = (scene as? UIWindowScene) else { return }</span></pre><p id="78b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们通过将<code class="fe mx my mz na b">scene as? UIWindowScene</code>分配给名为<code class="fe mx my mz na b">windowScene</code>的属性，修改了方法中的原始guard语句，使我们可以访问当前场景的<code class="fe mx my mz na b">UIWindowScene</code>对象。</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="f5b9" class="ng mb iq na b gy nh ni l nj nk">window = UIWindow(frame: UIScreen.main.bounds)</span></pre><p id="b3f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们创建窗口。通过使用<code class="fe mx my mz na b">UIWindow(frame: UIScreen.main.bounds)</code>，我们正在创建一个新窗口，并将其大小设置为设备的屏幕大小。</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="80b1" class="ng mb iq na b gy nh ni l nj nk">let viewController = ViewController()<br/>window?.rootViewController = viewController</span></pre><p id="b1a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在初始化一个新的视图控制器。然后我们将它分配给窗口的<code class="fe mx my mz na b">rootViewController</code>属性。根视图控制器只是一个窗口内容的容器。</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="c528" class="ng mb iq na b gy nh ni l nj nk">window?.makeKeyAndVisible()</span></pre><p id="7c57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们使窗口可见。<code class="fe mx my mz na b">makeKeyAndVisible()</code>方法只是一个方便的方法，它强制窗口成为关键窗口(换句话说，它把它放在所有其他窗口的前面——在这一点上，没有其他窗口),并使它可见。</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="2a5d" class="ng mb iq na b gy nh ni l nj nk">window?.windowScene = windowScene</span></pre><p id="c938" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将<code class="fe mx my mz na b">windowScene</code>属性分配给新创建的<code class="fe mx my mz na b">window</code>对象。</p><p id="5017" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并运行，你应该会看到…一个黑色的视图占据了整个屏幕。这不是很令人印象深刻，我们写代码之前有一个黑屏，所以这甚至工作吗？</p><p id="cc13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mx my mz na b">ViewController.swift</code>，在<code class="fe mx my mz na b">super.viewDidLoad()</code>行后的<code class="fe mx my mz na b">viewDidLoad()</code>方法中添加以下内容:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="f800" class="ng mb iq na b gy nh ni l nj nk">view.backgroundColor = .white</span></pre><p id="c0eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并再次运行，你现在应该看到一个完整的白色屏幕，证明我们现在有一个窗口，而且<code class="fe mx my mz na b">ViewController</code>实际上是可见的。</p><p id="684a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你，你现在已经建立了一个没有故事板的应用程序！而且只用了四行代码。</p><p id="1e2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总结一下到目前为止我们所做的，我们移除了故事板，修改了项目，使它不再寻找故事板，创建了我们的主应用程序窗口，并使<code class="fe mx my mz na b">ViewController</code>成为窗口的根视图控制器。</p><p id="6e01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单的东西。但是，那些您将拖放到故事板中并连接到<code class="fe mx my mz na b">IBOutlets</code>和<code class="fe mx my mz na b">IBActions</code>的视图和控件呢？我们接下来会看看这些。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="18b3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">添加UI元素</h1><p id="7ea9" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在我们有了一个可以再次使用的视图，让我们深入研究如何添加UI元素。</p><p id="cd8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在故事板中，我们只需将一个文本字段或按钮拖到视图上，并创建出口和动作，这样我们就可以用代码与它进行交互，但是没有故事板，这是如何实现的呢？</p><p id="158e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从单个控件开始，慢慢来。</p><p id="0e6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mx my mz na b">ViewController.swift</code>尚未打开，请将其打开。在<code class="fe mx my mz na b">viewDidLoad()</code>函数的正上方添加以下内容:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="ae65" class="ng mb iq na b gy nh ni l nj nk">var loginButton: UIButton!</span></pre><p id="52ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，通过在<code class="fe mx my mz na b">viewDidLoad()</code>中的<code class="fe mx my mz na b">view.backgroundColor = .white</code>行之后添加以下代码，实例化并配置按钮控件:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="788a" class="ng mb iq na b gy nh ni l nj nk">loginButton = UIButton(type: .system)<br/>loginButton.setTitle("Login", for: .normal)<br/>loginButton.translatesAutoresizingMaskIntoConstraints = false<br/>view.addSubview(loginButton)</span></pre><p id="e84d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一行一行地看看这个:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="7034" class="ng mb iq na b gy nh ni l nj nk">loginButton = UIButton(type: .system)</span></pre><p id="5e8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这相当于在“身份”检查器中设置<code class="fe mx my mz na b">Class</code>值，在“属性”检查器中设置<code class="fe mx my mz na b">Type</code>值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a5027a5210967840ae7ead64885ef8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*IpmNuPVuhrPwjPH-BpNrHQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2743960b82fca697d398a87fbc9a4ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*RSkGfAVCB2AS_-YE5tyOhQ.png"/></div></figure><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="3759" class="ng mb iq na b gy nh ni l nj nk">loginButton.setTitle("Login", for: .normal)</span></pre><p id="6320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将按钮的标题设置为正常状态。这相当于在属性检查器中设定这些值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ab468aafe0932f3b453cf6e4efdea8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*_rjNFzVMSAsUk8BwcHSw1w.png"/></div></figure><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="95d0" class="ng mb iq na b gy nh ni l nj nk">loginButton.translatesAutoresizingMaskIntoConstraints = false</span></pre><p id="2a81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在事情变得有趣了，因为这可能是你以前从未见过的。</p><p id="d3a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们声明我们将使用<code class="fe mx my mz na b">AutoLayout</code>。这看起来不像是我们正在做的事情，而且显式地设置这一点看起来很奇怪，但是这实际上是在你每次向故事板添加视图或控件时为你做的。</p><p id="3541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，不管你知不知道，你一直都在这么做。下面是按钮的脚本XML的一部分:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="8691" class="ng mb iq na b gy nh ni l nj nk">&lt;button opaque="NO" contentMode="scaleToFill" fixedFrame="YES" <br/>   contentHorizontalAlignment="center"     <br/>   contentVerticalAlignment="center" <br/>   buttonType="roundedRect"<br/>   lineBreakMode="middleTruncation" <br/>   translatesAutoresizingMaskIntoConstraints="NO" <br/>   id="DLu-Zl-IKU"&gt;</span></pre><p id="53b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会在最后看到<code class="fe mx my mz na b">translatesAutoresizingMaskIntoConstraints="NO"</code>一直都在。所以，是的，为你添加的每一个视图或控件都这样做是很乏味的，但是你做得越多，它就会变得越自动化。</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="4032" class="ng mb iq na b gy nh ni l nj nk">view.addSubview(loginButton)</span></pre><p id="b89f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你把一个控件拖到故事板上时，很明显它已经变成了它的父控件的子视图，即使你从来没有想过它。与代码中的大多数事情一样，我们需要明确地说明这一点。</p><p id="dc5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来处理按钮的定位。现在，我们就把它放在中间。在<code class="fe mx my mz na b">viewDidLoad()</code>功能后增加以下功能:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="53c6" class="ng mb iq na b gy nh ni l nj nk">func constraintsInit() {<br/>    NSLayoutConstraint.activate([<br/>      loginButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),<br/>      loginButton.centerYAnchor.constraint(equalTo: view.centerYAnchor)<br/>    ])<br/>}</span></pre><p id="679d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里所做的是将<code class="fe mx my mz na b">loginButton</code>的中心X和中心Y锚点分别与<code class="fe mx my mz na b">view</code>的中心X和中心Y锚点对齐。</p><p id="61e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对主播不熟悉，我强烈推荐找一个主播教程。锚点非常易于阅读和理解，但是深入解释它们超出了本文的范围。我们会更多地使用它们，所以，如果它们对你来说是新的，现在就跟着做吧。</p><p id="a73e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到<code class="fe mx my mz na b">viewDidLoad()</code>，在<code class="fe mx my mz na b">view.addSubview(loginButton)</code>之后添加这一行:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="accb" class="ng mb iq na b gy nh ni l nj nk">constraintsInit()</span></pre><p id="0d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并运行，您应该看到您的登录按钮就在视图的中央。</p><p id="62e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们加快进度，添加简单登录表单的剩余部分。在<code class="fe mx my mz na b">var loginButton: UIButton!</code>行的正下方添加以下代码:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="b00e" class="ng mb iq na b gy nh ni l nj nk">var nameTextField: UITextField!<br/>var passwordTextField: UITextField!</span></pre><p id="ceef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，在<code class="fe mx my mz na b">viewDidLoad()</code>行之后<code class="fe mx my mz na b">view.addSubview(loginButton)</code>行之前添加:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="3687" class="ng mb iq na b gy nh ni l nj nk">nameTextField = UITextField(frame: .zero)<br/>nameTextField.placeholder = "Login Name"<br/>nameTextField.borderStyle = .roundedRect<br/>nameTextField.translatesAutoresizingMaskIntoConstraints = false<br/>view.addSubview(nameTextField)</span><span id="7f64" class="ng mb iq na b gy oa ni l nj nk">passwordTextField = UITextField(frame: .zero)<br/>passwordTextField.placeholder = "Password"<br/>passwordTextField.isSecureTextEntry = true<br/>passwordTextField.borderStyle = .roundedRect<br/>passwordTextField.translatesAutoresizingMaskIntoConstraints = false<br/>view.addSubview(passwordTextField)</span></pre><p id="054f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，这里唯一应该是新的东西是在我们将框架设置为<code class="fe mx my mz na b">.zero</code>的实例化行中。</p><p id="580c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这对您来说是新的，它确实如其名:它将控件的大小设置为零。如果保持这种方式，运行应用程序时您将看不到该控件，因为它的高度和宽度都为零。这将通过添加我们的约束来解决，这是我们接下来要做的。</p><p id="3dcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mx my mz na b">constraintsInit()</code>中，在<code class="fe mx my mz na b">loginButton.centerYAnchor.constraint(equalTo: view.centerYAnchor)</code>行的末尾添加一个逗号，然后添加:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="36d3" class="ng mb iq na b gy nh ni l nj nk">passwordTextField.bottomAnchor.constraint(equalTo: loginButton.topAnchor, constant: -20),</span><span id="7247" class="ng mb iq na b gy oa ni l nj nk">passwordTextField.leadingAnchor.constraint(equalTo: view.readableContentGuide.leadingAnchor, constant: 20),</span><span id="40d1" class="ng mb iq na b gy oa ni l nj nk">passwordTextField.trailingAnchor.constraint(equalTo: view.readableContentGuide.trailingAnchor, constant: -20),</span><span id="eed7" class="ng mb iq na b gy oa ni l nj nk">nameTextField.bottomAnchor.constraint(equalTo: passwordTextField.topAnchor, constant: -20),</span><span id="ee98" class="ng mb iq na b gy oa ni l nj nk">nameTextField.leadingAnchor.constraint(equalTo: view.readableContentGuide.leadingAnchor, constant: 20),</span><span id="9ab9" class="ng mb iq na b gy oa ni l nj nk">nameTextField.trailingAnchor.constraint(equalTo: view.readableContentGuide.trailingAnchor, constant: -20)</span></pre><p id="52a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了指出我们使用<code class="fe mx my mz na b">readableContentGuide</code>进行文本字段的水平布局之外，我不打算在此详述。</p><p id="1993" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用约束条件时，可以使用一些指南，可读内容指南是一种在视图中定义可读区域的指南，该区域不会被系统控件(如滚动条)遮挡。</p><p id="3ae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还通过考虑设备宽度和动态文本大小来调整可读宽度。这是一个需要注意的重要指南，尤其是在调整用户界面的可访问性时。</p><p id="448c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并运行，您应该会看到一个非常基本的登录表单，它是以完全编程的方式创建的，没有故事板！</p><p id="c81a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有最后一件事要处理:行动。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ea26" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">添加操作</h1><p id="7836" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当使用故事板时，你可能会将登录按钮连接到一个<code class="fe mx my mz na b">IBAction</code>来处理点击事件。因为我们没有使用界面构建器，所以没有<code class="fe mx my mz na b">IBAction</code>可以利用。相反，我们将使用一个目标动作。</p><p id="4095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mx my mz na b">constraintsInit()</code>功能后添加这个新功能:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="6ad4" class="ng mb iq na b gy nh ni l nj nk">@objc func handleLoginTouchUpInside() {<br/>    print("Login has been tapped")<br/>    if nameTextField.isFirstResponder {<br/>      nameTextField.resignFirstResponder()<br/>    }<br/>    if passwordTextField.isFirstResponder {<br/>      passwordTextField.resignFirstResponder()<br/>    }<br/>  }</span></pre><p id="2c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为用户可能会关注任一文本字段，所以我们将简单地查询每个字段，并询问它是否是第一个响应者。如果是这样，我们将放弃第一响应者的身份。</p><p id="1da1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这对你来说是新的，在一个文本字段上重新签名第一个响应者将会隐藏键盘。此外，请注意，还有其他方法可以做到这一点，但这是一个足够好的演示方法。</p><p id="88b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，要为按钮上的点击事件添加一个动作，就在<code class="fe mx my mz na b">viewDidLoad()</code>中的<code class="fe mx my mz na b">view.addSubview(loginButton)</code>行下面添加以下内容:</p><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="1853" class="ng mb iq na b gy nh ni l nj nk">loginButton.addTarget(self, <br/>                      action: #selector(handleLoginTouchUpInside), <br/>                      for: .touchUpInside)</span></pre><p id="523f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将为登录按钮添加一个目标，当检测到内部动作时，该按钮将运行<code class="fe mx my mz na b">handleLoginTouchUpInside()</code>功能。</p><p id="4044" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建和运行，你应该看到一切工作了！如果您有任何问题，本文底部有完整的代码清单。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="05ea" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="1320" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如你所见，移除故事板并不困难。它揭示了视图和视图控制器的一些内部工作方式，尤其是布局，这是通过使用故事板对您隐藏的。</p><p id="a9fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种接触是一件好事，因为您将更加熟悉视图、控制器和约束是如何工作的。</p><p id="4fc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有了工具带中的编程布局，所有UI代码都将完全公开，并且更容易审查和调试。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a60a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">完整列表</h1><pre class="kg kh ki kj gt nc na nd ne aw nf bi"><span id="ade5" class="ng mb iq na b gy nh ni l nj nk">class ViewController: UIViewController {</span><span id="b31d" class="ng mb iq na b gy oa ni l nj nk">  var loginButton: UIButton!<br/>  var nameTextField: UITextField!<br/>  var passwordTextField: UITextField!</span><span id="39e8" class="ng mb iq na b gy oa ni l nj nk">  override func viewDidLoad() {<br/>    super.viewDidLoad()<br/>    view.backgroundColor = .white</span><span id="a02b" class="ng mb iq na b gy oa ni l nj nk">    loginButton = UIButton(type: .system)<br/>    loginButton.setTitle("Login", for: .normal)<br/>    loginButton.translatesAutoresizingMaskIntoConstraints = false<br/>    view.addSubview(loginButton)<br/>    loginButton.addTarget(self, action: #selector(handleLoginTouchUpInside), for: .touchUpInside)</span><span id="7a03" class="ng mb iq na b gy oa ni l nj nk">    nameTextField = UITextField(frame: .zero)<br/>    nameTextField.placeholder = "Login Name"<br/>    nameTextField.borderStyle = .roundedRect<br/>    nameTextField.translatesAutoresizingMaskIntoConstraints = false<br/>    view.addSubview(nameTextField)</span><span id="9b1c" class="ng mb iq na b gy oa ni l nj nk">    passwordTextField = UITextField(frame: .zero)<br/>    passwordTextField.placeholder = "Password"<br/>    passwordTextField.isSecureTextEntry = true<br/>    passwordTextField.borderStyle = .roundedRect<br/>    passwordTextField.translatesAutoresizingMaskIntoConstraints = false<br/>    view.addSubview(passwordTextField)</span><span id="cb73" class="ng mb iq na b gy oa ni l nj nk">    constraintsInit()<br/>  }</span><span id="0a96" class="ng mb iq na b gy oa ni l nj nk">  func constraintsInit() {<br/>    NSLayoutConstraint.activate([<br/>      loginButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),<br/>      loginButton.centerYAnchor.constraint(equalTo: view.centerYAnchor),</span><span id="8bdf" class="ng mb iq na b gy oa ni l nj nk">      passwordTextField.bottomAnchor.constraint(equalTo: loginButton.topAnchor, constant: -20),<br/>      passwordTextField.leadingAnchor.constraint(equalTo: view.readableContentGuide.leadingAnchor, constant: 20),<br/>      passwordTextField.trailingAnchor.constraint(equalTo: view.readableContentGuide.trailingAnchor, constant: -20),</span><span id="8ef0" class="ng mb iq na b gy oa ni l nj nk">      nameTextField.bottomAnchor.constraint(equalTo: passwordTextField.topAnchor, constant: -20),<br/>      nameTextField.leadingAnchor.constraint(equalTo: view.readableContentGuide.leadingAnchor, constant: 20),<br/>      nameTextField.trailingAnchor.constraint(equalTo: view.readableContentGuide.trailingAnchor, constant: -20)<br/>    ])<br/>  }</span><span id="134b" class="ng mb iq na b gy oa ni l nj nk">  @objc func handleLoginTouchUpInside() {<br/>    print("Login has been tapped")<br/>    if nameTextField.isFirstResponder {<br/>      nameTextField.resignFirstResponder()<br/>    }<br/>    if passwordTextField.isFirstResponder {<br/>      passwordTextField.resignFirstResponder()<br/>    }<br/>  }<br/>}</span></pre></div></div>    
</body>
</html>