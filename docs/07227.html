<html>
<head>
<title>Understanding the Builder Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解生成器设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-builder-design-pattern-f4f56fa18c9?source=collection_archive---------4-----------------------#2020-12-21">https://betterprogramming.pub/understanding-the-builder-design-pattern-f4f56fa18c9?source=collection_archive---------4-----------------------#2020-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e370" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">灵活构建复杂对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48b2182a810de6081267a01021b6c077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AyVQN_4jn9xfWLoS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">瑞安·斯通在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="737c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_2?dchild=1&amp;keywords=Design+Patterns%3A+Elements+of+Reusable+Object-Oriented+Software&amp;qid=1608215228&amp;sr=8-2" rel="noopener ugc nofollow" target="_blank"> <em class="lv">设计模式:可复用面向对象软件的要素</em> </a> <em class="lv">一书中描述了23种经典的设计模式。</em>这些模式为软件开发中经常重复出现的特定问题提供解决方案。</p><p id="9fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将描述<strong class="lb iu">构建器模式</strong>是如何工作的，以及何时应该应用它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5666" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">构建器模式:基本思想</h1><blockquote class="mv mw mx"><p id="3d5c" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated"><strong class="lb iu">构建器模式</strong>是<a class="ae ky" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">设计模式</a>，旨在为<a class="ae ky" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象编程</a>中的各种对象创建问题提供灵活的解决方案。构建器设计模式的目的是<a class="ae ky" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">将复杂对象的构建从其表示中分离出来。</a></p><p id="5320" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">— <a class="ae ky" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><p id="1c10" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">将复杂对象的构造与其表示分离，以便同一构造过程可以创建不同的表示</p><p id="78be" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">—设计模式:可重用面向对象软件的元素</p></blockquote><p id="83ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多情况下，一个类的构造函数有一个很长的参数列表，这些参数没有语义值，或者没有被该类的所有实例使用。这导致构造函数有一个很长的参数列表，或者迫使它们用不同的参数定义许多构造函数，从而导致类中构造函数方法的激增。</p><p id="b301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码显示了一个经典的问题，即存在一个带有必须初始化的参数列表的构造函数，即使所讨论的对象在其某些属性中不需要值。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="836c" class="ng me it nc b gy nh ni l nj nk">new User('carlos', 'Caballero', 26, true, true, false, null, null);</span></pre><p id="c885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建器模式允许我们编写更清晰的代码，因为它避免了上面提出的问题。这个模式的UML图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/db6606ddcc00fa1d75ac1ef23c678e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDOZtAwnZqqp-a8VAc2qjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自D <code class="fe nm nn no nc b">esign Patterns: Elements of Reusable Object-Oriented Software.</code>的UML图</p></figure><p id="9421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构成这种模式的类有:</p><ul class=""><li id="0ea5" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe nm nn no nc b">Product</code>:施工过程的具体结果。也就是说，它们将是我们应用程序的模型。</li><li id="99fa" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nm nn no nc b">Builder</code> <strong class="lb iu"> : </strong>混凝土建造者的通用接口。</li><li id="b2e0" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nm nn no nc b">ConcreteBuilder</code> <strong class="lb iu"> : </strong>建设性过程的不同实现。这些类将负责阐明每个对象构造过程的业务逻辑的差异。</li><li id="fc02" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nm nn no nc b">Director</code> <strong class="lb iu"> : </strong>定义了执行构建步骤的顺序。其目的是特定配置的可重用性。在这种模式的一些实现中，可以省略<code class="fe nm nn no nc b">Director</code>,尽管强烈推荐使用它，因为它将客户端从具体的构造步骤中抽象出来。</li><li id="c530" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nm nn no nc b">Client</code>:使用模式的类。有两种可能性:</li></ul><ol class=""><li id="9a8e" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu od nv nw nx bi translated">客户端使用<code class="fe nm nn no nc b">ConcreteBuilder</code>，一个接一个地执行构建步骤。</li><li id="ce46" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu od nv nw nx bi translated">客户端使用<code class="fe nm nn no nc b">Director</code>来实现每个构造过程，并作为<code class="fe nm nn no nc b">Client</code>和<code class="fe nm nn no nc b">ConcreteBuilder</code>类之间的中介。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c00b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">构建器模式:何时使用</h1><p id="0867" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">构建器模式解决的问题很容易识别。应该使用这种模式:</p><ol class=""><li id="a76a" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu od nv nw nx bi translated">当需要使用一个长参数列表的构造函数或者有一个长的不同参数的构造函数列表时。</li><li id="204c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu od nv nw nx bi translated">当需要构建同一对象的不同表示时。也就是说，当需要具有不同特性的同一类的对象时。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0892" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">构建器模式:优点和缺点</h1><p id="1ecf" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">构建器模式有许多<em class="lv">优势</em>，可以总结为以下几点:</p><ul class=""><li id="9bed" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">可以逐步创建对象。</li><li id="6f0a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">创建一个物体<em class="lv">可以被推迟</em>直到所有必要的信息都可用。在执行<code class="fe nm nn no nc b">Builder </code>类的<code class="fe nm nn no nc b">build</code>方法之前，不会获得对象。</li><li id="e9be" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">干净的代码:应用单一责任原则(SRP ),因为对象的复杂构造与该对象的业务逻辑相隔离。</li></ul><p id="5bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，构建器模式的主要缺点是增加了代码的复杂性和所需类的数量。这是应用设计模式时一个众所周知的缺点——在代码中获得抽象必须付出的代价。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="809f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将向您展示构建器模式的三个应用示例:</p><ul class=""><li id="42cf" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">构建器模式的基本结构。在这个例子中，我们将把理论上的UML图转换成TypeScript代码，以便识别模式中涉及的每个类。</li><li id="52db" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">视频游戏中<strong class="lb iu"> </strong>角色的创作。让我们想想经典的WoW ( <em class="lv">魔兽世界</em>)场景，玩家可以在两个种族之间进行选择:人类和兽人。</li><li id="aa5f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">在销售点(POS)创造产品(汉堡)。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="27be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例将展示使用TypeScript实现这种模式。我们选择了TypeScript而不是JavaScript来实现这个实现——后者缺少接口或抽象类，因此实现接口和抽象类的责任将落在开发人员身上。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0f97" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">示例1:构建器模式的基本结构</h1><p id="115b" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">在第一个例子中，我们将把理论上的UML图转换成TypeScript来测试这种模式的潜力。这是要实现的图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6cdaa5de4bd9f90734e139300ae37119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*ypzQEbjEiU7jK6IuG990Zg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成器模式基本结构的类图。</p></figure><p id="1d4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们定义问题的模型(<code class="fe nm nn no nc b">Product</code>)。在这个类中，我们将有一个简单的字符串列表。为此，我们定义了经典的<code class="fe nm nn no nc b">addPart</code>、<code class="fe nm nn no nc b">removePart</code>和<code class="fe nm nn no nc b">showParts</code>方法来管理这个属性。</p><p id="692a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，请注意，对象的构造函数不接收初始参数列表(在TypeScript中不需要定义它)，但是模型属性将通过方法进行修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品类别。</p></figure><p id="492e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是创建定义具体构建器的构建器接口。在生成器中，定义了添加和移除每个部件的操作(<code class="fe nm nn no nc b">A</code>、<code class="fe nm nn no nc b">B</code>和<code class="fe nm nn no nc b">C</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建器界面。</p></figure><p id="1ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">concrete builder类有一个我们想要构建的类的私有对象(<code class="fe nm nn no nc b">Product</code>)。将对其属性进行必要的修改，以根据每种情况构建对象。</p><p id="7a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，构造函数方法所做的是初始化产品，有一个<code class="fe nm nn no nc b">build</code>方法负责返回已经在<code class="fe nm nn no nc b">ConcreteBuilder1</code>类中配置的对象，并重置内部对象以便能够构建另一个对象。在调用<code class="fe nm nn no nc b">build</code>方法之前，<code class="fe nm nn no nc b">ConcreteBuilder1</code>类配置一个具体的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ConcreteBuilder1类。</p></figure><p id="45c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了通过<code class="fe nm nn no nc b">ConcreteBuilder1</code>类构建对象的具体操作，下一步就是定义执行不同构造的具体步骤。<code class="fe nm nn no nc b">Director</code>类负责定义使用<code class="fe nm nn no nc b">Builder</code>对象指定构造步骤的方法。</p><p id="2af5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，<code class="fe nm nn no nc b">Director</code>类从<code class="fe nm nn no nc b">Builder</code>类接收一个对象作为参数(在本例中是<code class="fe nm nn no nc b">ConcreteBuilder1</code>)，并且定义了几个构造:</p><ul class=""><li id="d4f7" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe nm nn no nc b">BasicObject</code> →它只包含a部分。</li><li id="a7a4" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nm nn no nc b">FullObject</code> →由A、B、c三部分组成。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，有必要定义利用该模式的<code class="fe nm nn no nc b">Client</code>或<code class="fe nm nn no nc b">Context</code>类。这个客户端非常干净，因为您只定义了想要使用的<code class="fe nm nn no nc b">Builder</code>对象，对象的创建是通过<code class="fe nm nn no nc b">Director</code>调用的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="81d6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">示例2:创建视频游戏英雄</h1><p id="4216" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">现在您已经看到了经典的理论示例，因此您理解了模式中每个类的职责。现在，这里有另一个例子，我们用一个特定的问题来识别每一个类。</p><p id="d126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的问题是电子游戏中不同英雄或角色的表现。我们将关注经典的WoW ( <em class="lv">魔兽世界</em>)游戏，游戏中的英雄分为两个种族:人类和兽人。每个英雄都可以有<code class="fe nm nn no nc b">armor</code>、<code class="fe nm nn no nc b">weapon</code>或者不同的<code class="fe nm nn no nc b">skills</code>，这取决于英雄是人类还是兽人。</p><p id="ec81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在没有应用构建器模式的情况下，它会导致在<code class="fe nm nn no nc b">Hero</code>类中定义一个带有一长串参数(<code class="fe nm nn no nc b">race</code>、<code class="fe nm nn no nc b">armor</code>、<code class="fe nm nn no nc b">skills</code>等)的构造器，这又会导致在构造器中定义逻辑来决定盔甲是人类还是兽人。因此，对于这个最初的解决方案，问题是耦合的，因为业务逻辑的任何变化都意味着必须重写相当多的代码，几乎没有任何重用的可能性。</p><p id="c107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们要做的第一件事就是停下来，想想构建器模式是如何帮助我们解决这个问题的。因此，我们专注于展示解决这个问题的UML图，并开始实现它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/45c32e273aa35c12c6785a49b891b770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*veQJQy779Jp8ulyOGVI0Lg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Builder模式应用于视频游戏的英雄创建问题。</p></figure><p id="6120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们遵循与上例相同的顺序，从我们想要灵活构建的模型或对象开始。</p><p id="a911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no nc b">Hero</code>类定义了<code class="fe nm nn no nc b">race</code>、<code class="fe nm nn no nc b">armor</code>、<code class="fe nm nn no nc b">weapon</code>和<code class="fe nm nn no nc b">skills</code>属性。所有这些属性都可以是对象，但是为了使这个例子简单，我们把它们作为字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="fb92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no nc b">HeroBuilder</code>接口为特定的构建器定义了方法。让我们观察一下<code class="fe nm nn no nc b">Hero</code>对象是如何用<code class="fe nm nn no nc b">setArmor</code>、<code class="fe nm nn no nc b">setWeapon</code>和<code class="fe nm nn no nc b">setSkills</code>一点一点地配置的。最后，我们有完成对象配置并提取<code class="fe nm nn no nc b">Hero</code>对象的<code class="fe nm nn no nc b">build</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="993c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦构建器被定义(作为抽象类或接口)，我们必须构建我们的问题所需要的两个特定的构建器:<code class="fe nm nn no nc b">HumanHeroBuilder</code>和<code class="fe nm nn no nc b">OrcHeroBuilder</code>。在演示代码中，我们根据每个构建器使用了不同的字符串。需要注意的是，每个构建器的build方法都返回已构建的对象(<code class="fe nm nn no nc b">Hero</code>)并重置对象的状态，因此它可以构建另一个对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="51f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模式的最后一个元素是<code class="fe nm nn no nc b">Hero-Director</code>类，它允许您存储代码中重复出现的配置。在我们的例子中，我们创建了三个<code class="fe nm nn no nc b">Hero</code>创建设置。例如，<code class="fe nm nn no nc b">createHero</code>方法构建一个完整的英雄——也就是说，它分配盔甲、能力和武器。我们也用<code class="fe nm nn no nc b">createHeroBasic</code>的方法创造一个没有任何装备的英雄。最后，为了说明另一个配置，定义了<code class="fe nm nn no nc b">createHeroWithArmor</code>方法，该方法返回一个只分配了盔甲的英雄。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="099e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们展示了一个控制台客户端，它利用了我们在整个示例中构建的两个构建器。在这个例子中，我们创建了两个构建者，<code class="fe nm nn no nc b">HumanHeroBuilder</code>和<code class="fe nm nn no nc b">OrcHeroBuilder</code>，以及导演类，<code class="fe nm nn no nc b">HeroDirector</code>。作为演示，让我们使用两个构建器和控制器来创建三个<code class="fe nm nn no nc b">HeroDirector</code>类预先配置的英雄配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8b41" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">示例3:汉堡的制作(销售点)</h1><p id="1b66" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">在下面的例子中，我们将为一家汉堡店创建一个POS。与前面的例子相比，本例中的主要变化是，对要创建的对象的每个修改操作都将返回构建器本身，而不是不返回任何值。这样，由构建器本身执行的不同操作可以被链接起来，因为每个操作都返回<code class="fe nm nn no nc b">Builder</code>对象。</p><p id="cfbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循前面例子中给出的相同方法，我们从查看UML图开始，以识别该模式的每个部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/0b2e875b73ef7318a4305094ec016a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*gJwzL4XkgppN_7E9gbPn4w.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用于销售点的生成器模式。</p></figure><p id="7f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们想要构建的对象将是对应于<code class="fe nm nn no nc b">Burger</code>类的对象，其中有一个要在每个汉堡中配置的配料列表。<code class="fe nm nn no nc b">Burger</code>类将有对应于它的每个属性的访问器方法。</p><p id="4914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是与该类相关联的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汉堡班。</p></figure><p id="107d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，已经包含了<code class="fe nm nn no nc b">BurgerType</code>枚举类型，它允许定义应用程序中存在的不同类型的汉堡。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="0c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nm nn no nc b">BurgerBuilder</code>类中，每个方法在被配置的对象上执行修改。返回的构建器能够将不同的操作链接在一起。当然，<code class="fe nm nn no nc b">build</code>方法还是会返回<code class="fe nm nn no nc b">Burger</code>类对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no nc b">BurgerDirector</code>类负责配置<code class="fe nm nn no nc b">BurgerBuilder</code>类中定义的操作。在这里，您可以看到不同类型的汉堡是如何使用链式方法进行配置的，这使得代码更容易阅读。重要的是要记住，在执行<code class="fe nm nn no nc b">build</code>方法之前，相同的汉堡是被配置的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们展示使用该模式的客户机。在这种情况下，选择一个随机数来定义汉堡的类型，并调用控制器来为我们提供该汉堡。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用汉堡餐厅POS的客户端类。</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="22f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我创建了三个<code class="fe nm nn no nc b">npm</code>脚本，通过它们可以执行本文中的代码:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3108" class="ng me it nc b gy nh ni l nj nk">npm run example1<br/>npm run example2<br/>npm run example3</span></pre><p id="aa91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/Caballerog/blog/tree/master/builder-pattern" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="184e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="8ec7" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">Builder是一种设计模式，它允许您避免使用带有一长串参数的构造函数，这些参数并非都是必需的。它允许您以更灵活的方式构建某个对象的实例，因为它只允许您配置那些绝对必要的属性。</p><p id="6466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码要干净得多，因为构造函数中没有不被使用的参数——只使用创建对象所需的那些参数。此外，由于有一个用于构建器的<code class="fe nm nn no nc b">Director</code>类，对象创建配置被重用，因此在客户机上没有与<code class="fe nm nn no nc b">Builder</code>类的直接交互。</p><p id="60d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这个模式最重要的不是它的具体实现，而是能够认识到这个模式可以解决的问题，以及何时可以应用它。具体的实现是最不重要的，因为这将取决于所使用的编程语言。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7441" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><ul class=""><li id="84da" class="np nq it lb b lc oe lf of li oo lm op lq oq lu nu nv nw nx bi translated"><a class="ae ky" href="https://github.com/Caballerog/blog/tree/master/builder-pattern" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li></ul></div></div>    
</body>
</html>