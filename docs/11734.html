<html>
<head>
<title>The Power of Strategy Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中策略设计模式的力量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-strategy-design-pattern-in-javascript-df1a17bc2c72?source=collection_archive---------15-----------------------#2022-04-12">https://betterprogramming.pub/the-power-of-strategy-design-pattern-in-javascript-df1a17bc2c72?source=collection_archive---------15-----------------------#2022-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="96a4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建你的下一个策略</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f5f04085878c141b45e4e2abd940391c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5JKh2Fwz5h4QU_BnrRlkA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://jsmanifest.com" rel="noopener ugc nofollow" target="_blank"> jsmanifest </a></p></figure><p id="fb51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种以灵活性著称的语言。你可能听说过有人说这是JavaScript的弱点之一，甚至有人说完全相反。我更倾向于后者，因为我们倾向于利用这一点来做一些在很多年前几乎不可能的事情。</p><p id="6d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React已经是一个事实证明，支持这一点，因为此后发明了惊人的工具。还有为今天蓬勃发展的技术提供动力的<a class="ae ky" href="https://www.electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子</a>，比如<a class="ae ky" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code </a>和<a class="ae ky" href="https://www.figma.com/" rel="noopener ugc nofollow" target="_blank"> Figma </a>。</p><p id="53a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，每个JavaScript库都使用某种形式的设计模式，这也是现代JavaScript生态系统中的一个热门话题。在这篇文章中，我们将关注的一个设计模式是策略设计模式。因为JavaScript非常灵活，它使得像Strategy这样的设计模式变得健壮，正如我们将在本文中看到的。</p><p id="4eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将回顾战略设计模式。这是一个众所周知的模式，它封装了一个或多个<em class="lv">策略</em>(或<em class="lv">算法</em>)来完成任务。这些封装的策略都具有相同的签名，因此上下文(提供<em class="lv">接口</em>的那个)永远不知道它们何时处理相同或不同的对象(或<em class="lv">策略</em>)。这意味着每种策略都可以被交换多次，而我们的程序在应用程序的生命周期内不会意识到这一点。</p><h1 id="22d7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">涉及什么样的对象？</h1><p id="a590" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在策略模式中，总是涉及到这两个对象:</p><ol class=""><li id="384f" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><strong class="lb iu">上下文</strong></li><li id="3dfa" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu">策略</strong></li></ol><p id="22ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">上下文</em>必须始终有一个引用或指针指向正在使用的<em class="lv">当前策略</em>。这意味着如果我们有200个策略，那么其他199个策略是可选的。你可以认为他们是“不活跃的”。</p><p id="362e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">上下文</em>也为调用者提供接口<em class="lv">。<em class="lv">呼叫者</em>就是<em class="lv">客户</em>。<em class="lv">呼叫者</em>可以使用任何策略来执行他们的工作，并且他们还可以根据需要随时将当前策略切换为另一个策略。</em></p><p id="d199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际的<em class="lv">策略</em>为自己实现执行时将使用的执行逻辑。</p><h1 id="6139" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">强项</h1><p id="7412" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在正常的函数实现中，函数通常会做一些事情并返回一个值。在策略设计模式中，当有一个基类(<em class="lv"> Context </em>)和一个策略时，它就像是一个调用策略并返回结果的函数(换句话说就是相同的东西)。</p><p id="4c2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当有<em class="lv">两个</em>或者更多的策略时，重点是这个策略可以是呼叫者控制的众多策略中的一个。</p><p id="aaca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的主要好处是，我们可以定义<em class="lv">尽可能多的策略</em>，并根据需要在每一个策略之间进行交换，而不会对代码的行为造成任何改变，只要模式是按照它应该的方式编写的。</p><p id="9689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">策略的实现可以改变，但是只要它们保持与上下文所期望的相同的签名，就没有必要对代码进行不必要的修改。</p><p id="e831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是描述这一流程的图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/f3e9abe1b7e94b1ce8d305acbb7ecd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6beknHA5AY9wOdlt.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://jsmanifest.com" rel="noopener ugc nofollow" target="_blank"> jsmanifest </a></p></figure><h1 id="3a4e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">履行</h1><p id="ae50" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们的第一个实现将集中在获取上。我们将定义一个返回<em class="lv">接口</em>的<code class="fe ni nj nk nl b">createFetcher</code>函数来创建获取器。这些获取器可以由客户端产生，并且可以按照它们想要的方式实现<em class="lv">，只要它们接受一个URL，检索并返回它的响应</em>。</p><p id="78bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>请求库、节点的本机<a class="ae ky" href="https://nodejs.org/dist/latest-v16.x/docs/api/https.html" rel="noopener ugc nofollow" target="_blank"> https </a>模块和<a class="ae ky" href="https://github.com/node-fetch/node-fetch" rel="noopener ugc nofollow" target="_blank">节点获取</a>库来分别实现一个策略。</p><p id="dbc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们总共有3个策略:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f1a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe ni nj nk nl b">createFetcher</code>函数中，我们创建了这样一行:<code class="fe ni nj nk nl b">const _identifer = Symbol('_createFetcher_')</code></p><p id="936c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行很重要，因为我们希望确保创建的每个策略<em class="lv">实际上都是策略</em>，否则我们的程序会将任何传入的对象视为策略。把任何事情都当作一种策略听起来可能是一种积极的好处，但是我们会失去有效性，这使得我们的代码更容易出错，如果我们出错，这很容易阻碍我们的调试体验。</p><p id="6550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">Symbol</code>通过<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">定义</a>返回给我们一个唯一变量。它也隐藏在上下文的实现中，所以在我们的<code class="fe ni nj nk nl b">create</code>函数之外创建的对象不可能被视为策略。他们必须使用由<em class="lv">上下文</em>提供的<em class="lv">接口</em>公开的方法。</p><p id="e235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当客户端调用<code class="fe ni nj nk nl b">use</code>时，它提交<code class="fe ni nj nk nl b">axiosFetcher</code>作为当前策略，然后被绑定为参考，直到客户端通过<code class="fe ni nj nk nl b">use</code>换入另一个策略。</p><p id="2a15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有三种检索数据的策略:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="656f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万岁！我们现在已经看到了如何在代码中实现它。但是我们能想到在现实世界中我们需要这个的情况吗？实际上你可以想到很多！然而，如果这是你第一次读到这种模式，那么我理解，除非我们先在实践中看到一个场景，否则很难事先想到一个场景。</p><p id="6378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中的例子展示了模式的实现，但是任何阅读本文的人都会问“既然可以直接使用像axios这样的策略来获得响应并结束工作，为什么还要费心实现三个fetcher策略呢？”</p><p id="4eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的例子中，我们将讨论一个场景，其中战略设计模式是绝对需要的。</p><h1 id="208b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">处理不同的数据类型</h1><p id="30fa" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">策略模式最出彩的地方是当我们需要处理不同的数据类型时，比如进行排序。</p><p id="d017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，我们<em class="lv">并不真正关心</em>任何数据类型，因为我们只是想要一些响应。但是，当我们收到一些东西，需要做一些狭窄的任务，如分类，会发生什么呢？如果它们需要被正确分类怎么办？</p><p id="693e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们需要对几个集合进行排序时，其中每个集合都是另一种数据类型的集合，我们不能只对所有的集合使用原生的<code class="fe ni nj nk nl b">.sort</code>方法，因为每个值都可以根据“更小”和“更大”进行不同的处理。</p><p id="eaa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用策略模式，定义运行时可用的不同排序算法集，这样我们就可以根据需要互换使用它们。</p><p id="ed27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑这些集合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个<code class="fe ni nj nk nl b">Sort</code>策略类和一个<code class="fe ni nj nk nl b">Sorter</code>上下文类。</p><p id="0672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，它们不需要成为类。我们现在只是选择使用类来使实现稍微多样化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="059a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很简单。<code class="fe ni nj nk nl b">Sorter</code>保持对当前正在被<em class="lv">使用的<code class="fe ni nj nk nl b">Sort</code>的引用</em>。这是调用<code class="fe ni nj nk nl b">sort</code>时将被选中的排序功能。每个<code class="fe ni nj nk nl b">Sort</code>实例都是一个策略，并被传递给<code class="fe ni nj nk nl b">use</code>。</p><p id="eabe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">Sorter</code>对策略一无所知。它不知道有日期分类器、数字分类器等。它<em class="lv">只是调用排序的执行方法</em>。</p><p id="1fd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，客户端<em class="lv">知道</em>所有的<code class="fe ni nj nk nl b">Sort</code>实例，并控制策略以及<code class="fe ni nj nk nl b">Sorter</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d2ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，完全由我们(客户)来相应地处理这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d30c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了一个健壮的<em class="lv"> 15行函数</em>，可以对集合的<em class="lv"> 4种不同变体</em>进行排序！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/7a4bcab2c011f7dbab3536fe757f1155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9ieBeYLTTgzDE78X.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://jsmanifest.com" rel="noopener ugc nofollow" target="_blank"> jsmanifest </a></p></figure><p id="5ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是JavaScript中策略设计模式的强大之处。</p><p id="2966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于JavaScript将函数视为值的特性，这个代码示例将这种能力与其优势结合在一起，并与策略模式无缝协作。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="a6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本帖到此结束！我希望您发现这是有用的，并在未来继续关注更多有用的提示！！</p></div></div>    
</body>
</html>