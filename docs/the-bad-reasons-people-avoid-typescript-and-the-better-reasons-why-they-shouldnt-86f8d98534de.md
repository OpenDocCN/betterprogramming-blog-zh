# 开发人员避免使用 TypeScript 的 3 个借口——以及他们应该使用它的更好的理由

> 原文：<https://betterprogramming.pub/the-bad-reasons-people-avoid-typescript-and-the-better-reasons-why-they-shouldnt-86f8d98534de>

## 在了解 TypeScript 的好处之前，我们先了解一下为什么有人不喜欢它

![](img/44fcfda6349feb108de91a4905e8702b.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上[attendee](https://unsplash.com/@attentieattentie?utm_source=medium&utm_medium=referral)拍照

我最近给[写了一篇关于 JavaScript 和 Node.js 优势的文章](/its-time-we-admit-the-truth-about-javascript-98d197c0f1ec)，在这篇文章中，我提出了一个明显有争议的观点:由于更大的可伸缩性和改进的开发人员体验，开发人员应该更喜欢 TypeScript 而不是 JavaScript。

几个小时内，攻击 TypeScript(和我的文章)的愤怒回应开始淹没我的收件箱。这些回答中有许多认为类型系统的好处微不足道，这让我怀疑他们还没有在一个大型项目中使用过像样的类型脚本实现。

不用说，如果你没有使用过 TypeScript 或者只看到了一个很差的实现，我要求你在批评它之前完全用 TypeScript 编写一个大型应用程序。当您尝试它时，您可能会像许多 TS 开发人员一样，发现它的好处远远超过任何成本。

我稍后将更详细地讨论其中的一些好处。但是首先，我想解决一些反复提到的避免使用 TypeScript 的原因。

# “它使 JavaScript 更像 Java 和。净”

首先，我不确定这是真的。当然，Java 和 TypeScript 有类型，而 JavaScript 没有。除此之外，我不相信 TypeScript 真的与面向对象编程有任何关系——至少与 JavaScript 本身没有关系。

优秀的 JavaScript 开发人员会警告你避免使用面向对象的风格。这个建议同样适用于 TypeScript，类型系统的使用不应该影响设计模式。

但是，当然，让我们承认对于那些来自面向对象背景的人来说，TypeScript 感觉更熟悉。那又怎样？除非你蔑视 Java 开发人员(有些 JavaScript 开发人员可能如此)，否则更好的可访问性是我们应该欢迎的改进。

我怀疑一些提出这种对 TypeScript 的批评的人害怕被泛型和其他受面向对象语言启发的高级概念淹没。事实上，TypeScript 的开发是由领导 C#开发的同一位微软工程师领导的——但是工程师们小心翼翼地只借用那些对 TypeScript 也有意义的特性。

底线是: **TypeScript 没有改变 JavaScript，它只是增加了它**。不要因为架构的原因而避免使用 TypeScript，因为它对你的软件架构几乎没有影响。

# “它使代码变得不必要地冗长/复杂”

冗长是使用 TypeScript 的一项重要成本。不可否认的是，TypeScript 项目将比其等效的 JavaScript 代码有更多的行。

复杂性是一个完全不同的问题，一个更加主观的问题。是的，TypeScript 意味着更多的东西，但这些东西是元数据——它有助于描述你正在操作的数据，这总体上减少了认知负荷。

我经常用的一个比喻是试管。在 JavaScript 中，变量有名字(试管上的标签)，但很难洞察名字背后实际存储了什么(试管中的物质)。有了 TypeScript，我们不仅有了名字，还可以看到管子(类型)内部的物质。

想象一下，你被要求用不透明的试管进行实验。你必须写下描述性的标签，极其小心地混合正确的化学物质，并记录下你的所有步骤。类似地，开发一个复杂的 JavaScript 应用程序需要给变量起一个描述性的名字，并且在引用这些变量时需要手动检查(或记忆)类型。

如果你忘了试管里有什么呢？你必须原路返回才能弄清楚里面有什么。同样，如果您忘记了一个 JavaScript 变量的类型，您将不得不挖掘创建它的代码来确定类型。

所以你可以说，在某种意义上，使用透明试管让你的实验变得更加复杂。虽然这意味着需要理解和处理更多的信息，但 TypeScript 通过减少记忆和消除打开不相关文件来手动检查类型的需要，提高了开发速度。

# “这只是用来炒作的”

这是一个愚蠢的论点，我甚至不愿意反驳。但是因为数量惊人的回复包含了这种推理的一些变体，所以我决定简要地解决它。

例如，一个回答是，“太多的开发人员喜欢精英主义和为了能够而过度复杂的东西。”

除此之外，我没什么可说的了:如果你真的认为我(或任何有能力的软件工程师)使用类型系统来有意增加复杂性，目的是给其他人留下深刻印象，这在我看来，你更关心你作为工程师的外表，而不是你产品的质量。

无论如何，如果我真的想毫无理由地挑战自己，我会尝试编写一个没有 TypeScript 的复杂应用*。*

# 脚本不需要类型。应用程序有

如果你想用鼠标拖动一个 div，你可以写一个小的 JS 脚本。添加类型是没有意义的。在编写大多数脚本时——就我们的目的而言，简单的程序调用内置方法并处理很少的数据——JavaScript 通常就足够了，添加类型会不必要地增加冗长性。

对于较大的应用程序来说并非如此，在这些应用程序中，可伸缩的代码和资源的有效利用依赖于复杂的、定义良好的数据结构。随着应用程序变得越来越复杂，越来越多的开发人员为同一个代码库做出贡献，如果没有精确的定义，这些数据结构将变得难以管理。

TypeScript 允许我们将数据结构写下来，而不必记忆或手动引用数据结构。我们的 IDE 和编译器将捕捉我们所犯的任何错误，除了确保我们的代码不会在运行时由于意外或不兼容的类型而遇到错误。

这里有两个常见的例子来说明 TypeScript 是多么有用。

# 1.Vue:谜一般的"`payload"`

Vuex 商店为 Vue 应用程序提供了一个中央状态，帮助开发人员避免在组件之间随意传递道具。

为了修改存储的状态，我们定义了一个带有两个参数的变异函数:当前的`state`和一个`payload`，它包含了关于期望的变化的信息。

假设我们希望保留一个表示为 JavaScript 对象的待办事项的中央状态。我们可以用一个空数组初始化我们的状态，就像这样:

```
state = {
  todos: [],
}
```

现在我们可以定义一个变异，允许我们更新这个待办事项列表:

```
updateTodos: (state, payload) => {
  state.todos = payload;
}
```

很简单。但是我们必须从另一个模块调用这个突变，比如一个组件。没有显式类型，我们需要猜测(或回忆)一下`updateTodos`需要一个`Todo`对象的列表。不太好。

它不止于此。假设另一个开发人员加入了我们的团队，我们要求他们修改`updateTodos`变异，这样它也可以更新状态的另一部分，就像一个跟踪完整待办事项数量的变量(由`someTodo.isComplete`给出)。

为此，开发人员必须首先确定`payload`的类型，包括以下步骤:

1.  开发者必须假设`updateTodos`的当前版本是准确的(即`payload`的类型与`state.todos`的类型相同)。
2.  开发人员必须一直滚动到初始状态对象，以检查`todos`的类型(或者在代码中搜索已经使用了`updateTodos`变异的地方，如果是的话)。
3.  开发人员必须找出每个待办事项的结构，才能知道如何确定它是否完整。

在这一切之后，由于一路上所做的所有假设，开发人员除了测试之外，没有其他方法来检查解决方案的正确性。

通过定义一个`Todo`类型并将有效载荷的类型指定为`Todo[]`，我们解决了所有这些问题。

毫无疑问，至少在这种情况下，TypeScript 为开发团队提供了一个巨大的——也是有价值的——好处，它提高了准确性，减少了麻烦，加快了开发，降低了出错的几率。

# 2.键入 JSON 响应

许多 JavaScript 应用程序会向远程 API 发出网络请求来获取数据。通常，当使用这些 API 时，我们会在开发时知道我们期望收到的响应的结构。

例如，假设我们从后端应用程序获取数据。我们的后端团队已经编写了全面的文档，详细描述了每个请求和响应对象的形状。

它注意到每个响应具有以下结构:

```
{
  "status": "success" or "failure",
  "data": {
    ...
  }
}
```

这会产生以下 TypeScript 数据定义:

```
interface ApiResponse {
  status: "success" | "failure";
  data: any;
}
```

然后我们可以参数化`ApiResponse`来指定它的`data`字段的类型:

```
interface ApiResponse<T> {
  status: "success" | "failure";
  data: T;
}
```

现在，我们的 API 方法在返回类型上可以更加具体:例如，我们可以返回一个用户列表的`ApiResponse<User[]>`，而不是仅仅返回一个`ApiResponse`。

让我们来看看这是如何提高开发速度的。假设您有一些从后端获取用户列表的方法:

```
async function getUsers(): Promise<ApiResponse<User[]>> { 
  ... 
}
```

我们在组件中使用它来获取用户:

```
const users = await getUsers();
```

然后我们可以映射用户以获得他们的名字:

```
const userNames = users.map(u => u.name);
```

对吗？

不对。你发现错误了吗？可能没有，但是静态类型检查有。我们忘记了响应包含我们需要首先处理的`success`和`data`字段。多亏了 TypeScript，我们的 IDE 将立即捕捉到这个错误。

对于处理 API 响应的新 JavaScript 开发人员来说，这是一个常见的“陷阱”。

随着您获得 JavaScript 经验，您将养成每次都手动检查 API 客户端响应类型的习惯。但是，当 TypeScript 为您做这些时，为什么还要费心呢？它可以节省时间，防止疏忽。

现在想象一下，您正在从一个体育 API 中提取数据。您使用端点`/upcoming`来拉动即将到来的体育比赛。API 文档提供了以下响应结构:

```
{
  "id": 247283,
  "name": "New York Knicks at Atlanta Hawks",
  "date": "2021-05-23T02:00:00+00:00",
  "competitors": ["New York Knicks", "Atlanta Hawks"],
  "venue": "Madison Square Garden",
  ...
}
```

如果不使用 TypeScript，您将不得不不断地引用这些文档来了解响应中的字段及其类型。如果有多个团队成员在处理这个代码，你必须与你的团队共享这些文档。

这意味着更多的时间，更多的努力，以及更大的机会，有人在这个过程中犯错误。糟糕，糟糕，甚至更糟。

但是对于 TypeScript，只需添加一个类型定义:

```
interface SportsApiResponse {
  id: number;
  name: string;
  date: string;
  competitors: [string, string];
  venue: string;
}
```

现在，任何时候您使用`SportsApiResponse`时，您都会确切地知道哪些字段是可用的以及它们的类型。您将节省大量的时间，并将拼错字段名或将`string`误认为`number`的可能性降至最低。

是不是比较啰嗦？绝对的。但每多一个角色都值得。

## …以及更多更多

TypeScript 提供的生活质量改善只会随着应用程序的复杂性和团队规模的增加而增加。即使您在开始一个项目或处理一个小项目时觉得不太需要 TypeScript，但是如果您预计到未来的增长，您仍然应该使用它。

# 权力带来责任

像任何技术一样，误用 TypeScript 会导致代价太大，以至于无法证明其好处。许多对我最近的文章持批评态度的人回忆说，他们从事的项目的 TypeScript 实现很差，导致了极其冗长和混乱的代码。但是，我们应该把这归因于 TypeScript 的误用而不是它的缺点。

TypeScript 误用通常是由自信的开发人员编写的晦涩、不清楚或过于抽象的类型造成的，这些开发人员坚持使用“更好”的解决方案，这使不太舒服的 TypeScript 开发人员感到困惑。因此，这些开发人员需要更多的时间来掌握代码的复杂性，并且——当他们不可避免地被令人困惑的类型所淹没时——放弃他们的工作，回到他们的 JavaScript 舒适区。这会导致误用或未使用的类型，导致不一致和不准确的代码，并给所有人带来令人沮丧的体验。

幸运的是，如果你坚持下面的指导方针，你可以避免这些常见的陷阱。

## 使用一致且不言自明的类型名

给你的所有类型起一个有明显含义的名字。避免使用通用的、难以描述的词，如“数据”或“对象”如果你不能为一个类型产生一个简单且不言自明的名字，那么它可能根本就不应该是一个类型。

此外，注意确保类型名称之间的一致性。命名的一致性有助于团队中的其他成员(以及您)进行类比，并理解不同类型之间复杂的关系。

例如，在我的 React 项目中，我总是为组件的道具定义一个接口。对于名为`ComponentName`的组件，我严格遵守了`ComponentNameProps`的命名约定。

这样，当我看到一个名为`XYProps`的类型时，我——以及我团队中的其他人——可以确定这个类型定义了组件`XY`的道具。

## 不要指定推断类型

TypeScript 令人印象深刻的静态类型检查系统的一个基本特性是**类型推断**。TypeScript 根据每个变量的初始值以及任何重新分配或条件，推断出可以分配给每个变量的最具体的类型。

假设我们有`users`，一组`User`对象。然后，我们可以提取具有特定 ID 的用户:

```
const user = users.find(u => u.id === 1);
```

因为`users`是`User[]`类型的——并且基于`Array.find()`的签名——TypeScript 知道`user`将是`User`。因此键入它是多余的:

```
const user: User = users.find(u => u.id === 1);
```

当它不提供 TypeScript 任何附加信息时，请避免指定类型。这只会增加冗长，在某些情况下，会导致更多的混乱。

想检查变量的类型？如果您使用的是支持 TypeScript 的 IDE，只需将鼠标悬停在变量上，工具提示就会出现，显示类型。

## 避免不必要的抽象

抽象是可伸缩软件不可或缺的一部分，因为它们简化了模块的组成并减少了代码重复。

然而，许多新的软件工程师错误地认为这意味着抽象越多越好。过多的抽象导致类型和模块没有明确的目的，复杂的代码甚至会让有经验的开发人员感到困惑。

尽管抽象有助于保持代码的干爽，但你很少会为了重用代码而使用它们。它们应该服务于一些清晰的逻辑角色，比如表示一个通用的数据结构，或者为逻辑上不同的子任务提供可重用的层。

让我们回到上面我们对`ApiResponse<T>`的定义作为例子。我们可以为`data`属性定义一个类型，为`status`属性定义一个类型，并使用交集类型来定义`ApiResponse<T>`:

```
interface ApiResponseData<T> {
  data: T;
}interface ApiResponseStatus {
  status: "success" | "failure";
}type ApiResponse<T> = ApiResponseData<T> & ApiResponseStatus;
```

这实现了与上面相同的目的，增加了两种类型，我们现在可以在其他地方重用。这是好事，对吧？

不一定。没有对这些较小类型的明确使用，它们的定义只会使我们的类型定义变得复杂，并增加不熟悉代码库的开发人员的困惑。

简洁是编程的灵魂。仅定义具有清晰和明显目的的必要类型。也就是说，一般来说，您在应用程序中定义的每个变量都应该有一个特定的类型(除了`any`)。

不要把我对 TypeScript 的辩护误认为是对其无处不在的采用的支持。有一些令人信服的理由来避免它，正如任何决定一样，首席工程师应该权衡利弊。

然而，我们应该拒绝这样的观点，即 TypeScript 毫无理由地增加了冗长性，或者只是为了增加与面向对象语言的相似性。TypeScript 建立在 JavaScript 之上:例如，如果您编写函数式 JS 代码，您的类型应该补充它。

TypeScript 不应该影响架构决策或者任何 JavaScript 代码。相反，它应该提供帮助开发人员更好地理解代码的目的和结构所必需的最少的元数据。

像任何其他投资一样，随着应用程序和开发团队的增长，实现 TypeScript 的初始成本(有时令人沮丧)是值得的。如果使用得当，TypeScript 会产生提供卓越用户体验的软件，以及同样重要的开发人员实际上想要使用的代码。