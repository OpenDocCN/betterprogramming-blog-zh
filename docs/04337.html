<html>
<head>
<title>Redux State Management With Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用类型进行冗余状态管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/redux-state-management-with-types-3073b0fd0099?source=collection_archive---------21-----------------------#2020-04-06">https://betterprogramming.pub/redux-state-management-with-types-3073b0fd0099?source=collection_archive---------21-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bcf6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用打字稿更好的状态</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87e7002925d868e51b5d37eb39bcb6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HYVkG9GpwMCv-p7Ml-tsQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@lordesigner?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">洛伦佐·莫奇</a>在<a class="ae ky" href="https://unsplash.com/s/photos/management?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="c05f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">本帖首发于<a class="ae ky" href="https://leandrotk.github.io/tk/2020/04/consistent-state-management-in-react-and-redux/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="li iu"> <em class="mc"> TK的博客</em> </strong> </a>。</p><p id="6803" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这是我研究如何构建可持续和一致的软件的一部分。</p><p id="d274" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在本帖中，我们将讨论React和Redux环境下的状态管理。我将向你展示我试图解决的一个问题和我为工作提出的一个解决方案。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6caf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">问题是</h1><p id="c3e1" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">首先:问题！这部分真的很重要。我试图解决一个问题，而不是在我们的pwa上添加闪亮的技术。</p><p id="b1b3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在开发新的Originals清单时，我们从API获取数据来呈现页面。这个数据的一个重要部分是一个名为<code class="fe na nb nc nd b">specialConditions</code>的属性。它是一个房地产条件列表。</p><p id="563f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一份名单。是的，我们期望它总是一个列表，但是在代码库中的某个地方，我们分派了一个动作将这个值突变为一个<code class="fe na nb nc nd b">undefined</code>，导致了一个bug并需要一个bug修复。</p><p id="3dec" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">从那天开始，我就一直在寻找一个解决方案，让系统更加一致。如果它是一个列表，它将永远是一个列表。不管我们作为开发人员有多有创造力。</p><p id="40d1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">随着代码库的增长，这个问题变得非常普遍。因为很容易产生你自己都没有意识到的隐性影响。它伸缩性很差。</p><p id="dda7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">于是，我想到了输入Redux的整个生命周期。如果我们键入状态和每个Redux“生命周期代理”，我们可以使它具有弹性和一致性。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3c9a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案</h1><p id="5b1b" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">想法是通过输入状态、动作、减少器、处理程序和选择器，使PWA架构在Redux生命周期中显式、有弹性和一致。</p><p id="412e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">处理前端状态管理是复杂的。因为我们使用Redux作为几乎所有工作中的pwa的主要状态管理架构，所以构建一个框架来将类型化应用到Redux是一个很好的方法，可以制定一个带有最佳实践和约定的指南来扩展我们的pwa。</p><p id="315c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">约束是一个非常重要的概念，可以让我们避免犯简单的错误。通过键入我们的Redux生命周期，我们至少可以在编译时保护我们的主数据处理程序免受这类错误的影响。</p><p id="2a0a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">通过输入我们的初始状态、归约器和处理程序<a class="ae ky" href="https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python" rel="noopener ugc nofollow" target="_blank">,我们可以免费获得关于Redux生命周期的良好文档</a>,从而更容易推断出每一步的预期细节。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2d75" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">这个提议</h1><p id="6b50" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">本提案中的一个重要注意事项是，我们在创建it时考虑了问题和环境(当前的技术堆栈和工具、开发人员的接受度、我们的pwa中可以扩展的内容)。我们将谈论这些话题:</p><ul class=""><li id="777f" class="ne nf it li b lj lk lm ln lp ng lt nh lx ni mb nj nk nl nm bi translated">选择工具。</li><li id="2a09" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">Redux生命周期代理。</li><li id="0480" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">不可变的数据。</li><li id="c69f" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">使用我们的pwa之一进行概念验证。</li><li id="c1f0" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">赞成和反对。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5833" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">选择工具</h1><p id="e434" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">我们遇到了一些选择工具的问题:</p><ul class=""><li id="b739" class="ne nf it li b lj lk lm ln lp ng lt nh lx ni mb nj nk nl nm bi translated">真的解决问题了吗？</li><li id="8567" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">工作中的接纳。</li><li id="aa4f" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">技术社区中的工具。</li></ul><p id="9c78" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">可以解决问题的一些工具:<a class="ae ky" href="https://flow.microsoft.com/" rel="noopener ugc nofollow" target="_blank"> Flow </a>，<a class="ae ky" href="https://reasonml.github.io/" rel="noopener ugc nofollow" target="_blank"> ReasonML </a>，<a class="ae ky" href="https://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>，<a class="ae ky" href="https://clojurescript.org/" rel="noopener ugc nofollow" target="_blank"> ClojureScript </a>，TypeScript。(声明:ClojureScript来自LISP家族。它没有静态类型系统。但是它有一些很酷的特性，比如不可变的数据结构。)</p><p id="a221" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">想想我们的代码库，都是JavaScript。选择一种不同的语言，如ReasonML、Elm或ClojureScript，对于学习一种新的语言和拥有最佳实践和约定的指导方针来说是一个缺点。</p><p id="5fbb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">相反，Flow和TypeScript是JavaScript的包装器或者超集。与全新的语言相比，学习新的API更容易。即使我们喜欢学习和尝试新事物，我认为我们应该有一个平缓的学习曲线，并仍然解决主要问题。</p><p id="01dd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">TypeScript用于某些pwa。有些使用类型脚本模型(类、接口、类型)来键入API和app数据协定。其他人将数据提取器用于房屋、搜索和邻居。相反，在我们的PWAs中没有使用Flow。</p><p id="8a2e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">TypeScript是发展最快的语言之一，也是目前领先的编译到JavaScript语言。一些大公司——比如Airbnb——也在大规模采用这个工具。</p><p id="21ba" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以，我们从TypeScript开始做概念验证，看看效果如何。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9b59" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Redux生命周期代理</h1><p id="2d11" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">提议背后的想法是键入Redux代理。对于几乎所有的pwa，我们都需要输入动作、缩减器、处理程序和选择器。</p><ul class=""><li id="7957" class="ne nf it li b lj lk lm ln lp ng lt nh lx ni mb nj nk nl nm bi translated">动作:使用类型来键入动作契约——类型、承诺、元、<code class="fe na nb nc nd b">extraProperties</code>、属性等。</li><li id="422f" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">存储状态:为<code class="fe na nb nc nd b">initialState</code>签订合同，并使其在Redux生命周期中保持一致。</li><li id="4397" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">Reducers:通过使用处理程序，处理状态契约，只返回正确的类型契约——只改变数据，而不是类型。</li><li id="1be4" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">处理程序:负责外部交互生命周期和状态映射。强制最终状态将具有与预期相同的契约——商店状态契约。使用<a class="ae ky" href="https://github.com/lelandrichardson/redux-pack" rel="noopener ugc nofollow" target="_blank"> redux-pack </a>时，处理程序是一种常见的模式。</li><li id="0565" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">来自外部交互数据:来自API或Firestore或任何其他外部交互的数据合同。</li><li id="47ac" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">要存储状态:使用存储状态契约——基本上是reducer初始状态契约。</li><li id="a4ef" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">选择器:用<code class="fe na nb nc nd b">mapStateToProps</code>获取商店状态并映射到组件状态——props。</li><li id="84e9" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">类型:所有代理的类型库。</li></ul><p id="02e6" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以在容器组件文件夹中组织这些代理:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="8102" class="nw me it nd b gy nx ny l nz oa">__ containers<br/>    	|__ MyComponent<br/>    		|__ actions.ts<br/>    		|__ handlers.ts<br/>    		|__ reducer.ts<br/>    		|__ selectors.ts<br/>    		|__ types.ts</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2693" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">不可变数据</h1><h2 id="6cc0" class="nw me it bd mf ob oc dn mj od oe dp mn lp of og mp lt oh oi mr lx oj ok mt ol bi translated">不可变的. js</h2><p id="9d1d" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">不可变数据是<a class="ae ky" href="https://medium.com/javascript-scene/the-dao-of-immutability-9f91a70c88cd#.9g51h5stk" rel="noopener">的一个基本特性，使前端状态管理变得不那么复杂</a>。这是一个核心原则，使纯函数，一个数学函数的概念，给定的输入，它总是返回相同的输出，没有突变或副作用。</p><p id="1fb0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们目前使用<a class="ae ky" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> Immutable.js </a>来制作具有不可变数据结构的JavaScript。它为JavaScript提供了新的数据结构，用全新的API来处理不可变数据。</p><p id="4147" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">可预测性对于理解代码非常重要。但是不可变的. js并没有强迫我们总是在状态中使用它，所以我们不知道使用哪个API——不可变的还是JavaScript API——来获取选择器中的数据。</p><p id="a9d3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在商店里混合数据是很容易的。它的一部分是不可变的对象。另一个是普通的JavaScript对象。</p><p id="6072" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Redux docs <a class="ae ky" href="https://redux.js.org/recipes/using-immutablejs-with-redux/" rel="noopener ugc nofollow" target="_blank">提出了一些关于使用Immutable.js </a>的问题。Redux作者<a class="ae ky" href="https://www.reddit.com/r/javascript/comments/4rcqpx/dan_abramov_redux_is_not_an_architecture_or/d51g4k4/?utm_source=share&amp;utm_medium=web2x" rel="noopener ugc nofollow" target="_blank">建议避免在Redux </a>中使用Immutable.js。对于不可变的数据，<a class="ae ky" href="https://redux.js.org/style-guide/style-guide/#use-immer-for-writing-immutable-updates" rel="noopener ugc nofollow" target="_blank">他们强烈推荐使用Immer.js </a>。</p><p id="ae15" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了保持一致性和可预测性，如果我们在编译时和开发中使用<a class="ae ky" href="https://github.com/jonaskello/tslint-immutable" rel="noopener ugc nofollow" target="_blank"> lint </a>处理不可变数据，并且只使用一种语言API，而不需要推理语言——JavaScript和Immutable.js，会怎么样？</p><h2 id="ea2c" class="nw me it bd mf ob oc dn mj od oe dp mn lp of og mp lt oh oi mr lx oj ok mt ol bi translated">Typescript只读和TSLint不可变</h2><p id="60ee" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">Typescript有<a class="ae ky" href="https://mariusschulz.com/blog/read-only-properties-in-typescript" rel="noopener ugc nofollow" target="_blank">只读属性</a>来处理编译时的<a class="ae ky" href="https://stackoverflow.com/questions/55905801/can-typescripts-readonly-fully-replace-immutable-js/55906256#55906256" rel="noopener ugc nofollow" target="_blank">不可变数据。它们是:</a></p><ul class=""><li id="75a2" class="ne nf it li b lj lk lm ln lp ng lt nh lx ni mb nj nk nl nm bi translated"><code class="fe na nb nc nd b">readonly</code>:不可变的原始数据</li><li id="84db" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><code class="fe na nb nc nd b">Readonly</code>:不可变对象</li><li id="623e" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><code class="fe na nb nc nd b">ReadonlyArray</code>:不可变数组</li></ul><p id="2fdd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">只读</strong></p><p id="6a88" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为原始值添加不可变的特性，如数字、字符串、布尔值等。</p><p id="d05d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果我们将这个特性添加到类型定义中，我们就强制数据在编译时是不可变的。如果你用的是VS代码，你的代码会有错误<code class="fe na nb nc nd b">“Cannot assign to ‘your property here’ because it is a read-only property”</code>。</p><p id="b5fa" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">只读</strong></p><p id="87bd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为<a class="ae ky" href="https://stackoverflow.com/questions/41879327/deepreadonly-object-typescript/49670389#49670389" rel="noopener ugc nofollow" target="_blank">对象</a>添加不可变特征。</p><p id="808c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果您正在处理一个对象，您可能会使用readonly来使用映射类型将其所有属性标记为Readonly。</p><p id="537f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">只读数组</strong></p><p id="45fb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为列表添加不可变的特性。</p><p id="c423" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你尝试在只读数组中添加新的条目，你会遇到一个错误<code class="fe na nb nc nd b">“Property ‘push’ does not exist on type ‘readonly Readonly&lt;T&gt;[]”</code>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8191" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">基准测试:不可变. js与原生API</h1><p id="e76c" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">我们做了一些<a class="ae ky" href="https://github.com/leandrotk/javascript-immutable-data-benchmarks" rel="noopener ugc nofollow" target="_blank">基准来比较有和没有不可变的PWA。</a></p><p id="967a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第一个基准测试中，我们决定比较原生JavaScript和immutable . js API:get、get-in、set和set-in。并且理解用<code class="fe na nb nc nd b">fromJS</code>和<code class="fe na nb nc nd b">toJS</code>函数转换一个数据结构是什么样子。</p><h2 id="ca38" class="nw me it bd mf ob oc dn mj od oe dp mn lp of og mp lt oh oi mr lx oj ok mt ol bi translated"><a class="ae ky" href="https://github.com/leandrotk/javascript-immutable-data-benchmarks/blob/master/src/get.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">获取—对象和数组</strong> </a></h2><p id="312b" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">对于Immutable.js API来说，获取对象的第一个属性代价更高。以一百万周期和五百万周期运行七次(以毫秒为单位)。与那些API相比，获取数组的第一个元素更接近。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/42c6a46c6e287c1b8e723c7d2a6abfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUumIymbbrAzSXKCvpnZZA.png"/></div></div></figure><h2 id="85ae" class="nw me it bd mf ob oc dn mj od oe dp mn lp of og mp lt oh oi mr lx oj ok mt ol bi translated"><a class="ae ky" href="https://github.com/leandrotk/javascript-immutable-data-benchmarks/blob/master/src/getin.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">获取—对象和数组</strong> </a></h2><p id="2d04" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">对于Immutable.js API来说，获取对象的嵌套属性或数组的嵌套元素比获取原生属性的成本要高得多。一百万和五百万次循环。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/cb116f66ff72d96124da403a6a210186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofL_k3kS8FPDtBFdxEjN0A.png"/></div></div></figure><h2 id="ab41" class="nw me it bd mf ob oc dn mj od oe dp mn lp of og mp lt oh oi mr lx oj ok mt ol bi translated"><a class="ae ky" href="https://github.com/leandrotk/javascript-immutable-data-benchmarks/blob/master/src/set.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">集合—对象和数组</strong> </a></h2><p id="e1f4" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">为对象属性设置一个新值对于原生JavaScript API来说代价更高。</p><p id="b1c3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是使用set方法，我们仍然可以处理本地对象，并大大减少毫秒数。对于数组来说，比较接近，但是用set方法可以更好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/6b0fdd14d8d19c9ccbbccf80157f4a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOqf1uj2ELhefKyrD7O6Bw.png"/></div></div></figure><h2 id="a8c4" class="nw me it bd mf ob oc dn mj od oe dp mn lp of og mp lt oh oi mr lx oj ok mt ol bi translated"><a class="ae ky" href="https://github.com/leandrotk/javascript-immutable-data-benchmarks/blob/master/src/setin.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">设定-对象和数组</strong> </a></h2><p id="eee3" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">对于对象和数组，最好使用原生JavaScript API，而不是不可变的. js数据结构和方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/42f3f7c5f92b22ec47eacc5e29ab77aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NFx0LaEpBgkR3EaZxcBsQ.png"/></div></div></figure><h2 id="5146" class="nw me it bd mf ob oc dn mj od oe dp mn lp of og mp lt oh oi mr lx oj ok mt ol bi translated"><a class="ae ky" href="https://github.com/leandrotk/javascript-immutable-data-benchmarks/blob/master/src/fromJS.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> fromJS </strong> </a> <strong class="ak">和</strong> <a class="ae ky" href="https://github.com/leandrotk/javascript-immutable-data-benchmarks/blob/master/src/toJS.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> toJS </strong> </a></h2><p id="df9b" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">我们可以看到，在将原生JavaScript数据结构转换为不可变DS时，<code class="fe na nb nc nd b">fromJS</code>函数的开销会很大。</p><p id="6c0b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe na nb nc nd b">toJS</code>成本更低，但是每次我们需要获取一个值时，比如在选择器中，我们使用<code class="fe na nb nc nd b">toJS</code>，它会影响性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/6dbd87449b42b9ef769e2b60e8d90f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uvWjZk41cJIdlXGjDZcRuw.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9f55" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">类型化状态管理:生命周期</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/5422bdc2198dc6d2e6ae79e71cbb8180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QERgzuzphdQz4e0fNs1CFQ.gif"/></div></div></figure><p id="bcb7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">该组件使用缩减器中定义的初始状态进行渲染。它调度一个动作。该操作将有一个外部交互，因此它使用promise并发模型。</p><p id="efb8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">新数据作为动作的一部分到达reducer，它将动作传递给处理程序来处理外部交互生命周期，如果成功，就向状态添加新数据。有了更新后的状态，选择器将获取并将其作为道具传递给组件<code class="fe na nb nc nd b">mapStateToProps</code>。</p><p id="cf3c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">类型化状态管理的概念是确保这些代理之间的所有通信都具有一致且可预测的状态契约。</p><p id="e9b0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">从初始状态到外部交互后的更新状态，具有相同类型的契约。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e682" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">类型化状态管理PoC</h1><p id="534a" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">尝试将此概念作为Photos PWA概念验证:Photos PWA是由一个小团队维护的小应用程序，这就是我们选择它作为PoC的一部分的原因。我们需要在生产中验证这个想法，但是不要太复杂。</p><p id="8926" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们应用到这个概念的容器组件叫做<code class="fe na nb nc nd b">NotStartedPhotoSessions</code>。它获取一个API端点来获取照片会话，并将其列在摄影师的日程中。</p><p id="45f1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">第一件事是构建商店状态契约作为初始状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="cc63" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因此，在第一次呈现时，组件将访问这些值作为道具。在呈现中，它将分派一个新的类型化操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="76a3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">减速器将接收这个动作。并确保最终结果将具有与初始状态相同的状态契约:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="ff21" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">然后，reducer调用处理程序，并将API响应有效负载转换为存储状态。只是数据映射而已。</p><p id="0d3f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">既然存储状态已经更新，是时候让选择器获取新数据了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="e40a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们回到组件，将状态映射到道具并接收新数据。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="40a2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">利益</h1><ul class=""><li id="3ecb" class="ne nf it li b lj mv lm mw lp os lt ot lx ou mb nj nk nl nm bi translated">可预见性:类型检查使代码更可预见，反过来，也使代码更不容易出错。</li><li id="64bd" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">文档:在Redux生命周期中为每一个代理签订合同可以免费为我们提供良好的文档。</li><li id="7c7f" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">数据流的类型安全:因为我们的大部分数据流发生在Redux生命周期中，所以至少在编译时，我们的数据是类型安全的，这也是我们大多数错误的来源。</li><li id="71db" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">如果我们选择从store状态中移除Immutable.js ( <code class="fe na nb nc nd b">fromJS</code>和<code class="fe na nb nc nd b">toJS</code>)，我们仍然可以使用像<code class="fe na nb nc nd b"><a class="ae ky" href="https://immutable-js.github.io/immutable-js/docs/#/mergeDeep" rel="noopener ugc nofollow" target="_blank">mergeDeep</a></code>这样的很酷的函数，而不用不可变的map/array/DS，只使用Immutable.js版本4。</li><li id="9595" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">当移除不可变的以支持TypeScript readonly时的性能优化。</li><li id="710b" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/leandrotk/javascript-immutable-data-benchmarks" rel="noopener ugc nofollow" target="_blank">不可变vs. JS基准</a> : Get，get-in，set，set-in，<code class="fe na nb nc nd b">fromJS</code>，<code class="fe na nb nc nd b">toJS</code>。</li><li id="363d" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://developers.google.com/web/tools/lighthouse" rel="noopener ugc nofollow" target="_blank"> Google Lighthouse </a>:在没有Immutable.js的情况下运行Google Lighthouse时略有改善。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d38c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><ul class=""><li id="88a4" class="ne nf it li b lj mv lm mw lp os lt ot lx ou mb nj nk nl nm bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=TqfbAXCCVwE&amp;feature=emb_title" rel="noopener ugc nofollow" target="_blank">前端开发的约束</a></li><li id="a8c2" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python" rel="noopener ugc nofollow" target="_blank">我们对400万行Python进行类型检查的旅程</a></li><li id="6ffa" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b" rel="noopener">打字稿税</a></li><li id="3357" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=P-J9Eg7hJwE" rel="noopener ugc nofollow" target="_blank">大规模采用打字稿</a></li><li id="30ed" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/javascript-scene/the-dao-of-immutability-9f91a70c88cd#.9g51h5stk" rel="noopener">永恒之道</a></li><li id="86ba" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://redux.js.org/recipes/using-immutablejs-with-redux/" rel="noopener ugc nofollow" target="_blank">在Redux中使用Immutable.js的注意事项</a></li><li id="5ec6" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://www.reddit.com/r/javascript/comments/4rcqpx/dan_abramov_redux_is_not_an_architecture_or/d51g4k4?utm_source=share&amp;utm_medium=web2x" rel="noopener ugc nofollow" target="_blank">避免在Redux中使用Immutable.js】</a></li><li id="3cd4" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/better-programming/3-reasons-to-avoid-using-immutablejs-with-redux-b0109d0123e8" rel="noopener">避免在Redux中使用ImmutableJS的3个原因</a></li><li id="15a6" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://redux.js.org/style-guide/style-guide/#use-immer-for-writing-immutable-updates" rel="noopener ugc nofollow" target="_blank">使用Immer编写不可变更新</a></li><li id="8a01" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/jonaskello/tslint-immutable" rel="noopener ugc nofollow" target="_blank">ts lint-不可变</a></li><li id="06ba" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://mariusschulz.com/blog/read-only-properties-in-typescript" rel="noopener ugc nofollow" target="_blank">只读打字稿</a></li><li id="14fd" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://stackoverflow.com/a/55906256/11314146" rel="noopener ugc nofollow" target="_blank"> Typescript只读并不能完全取代不可变的</a></li><li id="87bb" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://stackoverflow.com/a/49670389/11314146" rel="noopener ugc nofollow" target="_blank">深层只读对象</a></li><li id="f362" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/leandrotk/javascript-immutable-data-benchmarks" rel="noopener ugc nofollow" target="_blank">原生JavaScript与不可变. js API</a></li><li id="4924" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> Io-ts </a></li><li id="4aec" class="ne nf it li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated"><a class="ae ky" href="https://klzns.github.io/how-to-use-type-script-and-jest-mocks/" rel="noopener ugc nofollow" target="_blank">打字稿和笑话模仿</a></li></ul></div></div>    
</body>
</html>