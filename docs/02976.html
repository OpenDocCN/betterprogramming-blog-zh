<html>
<head>
<title>Performance Optimization with React Hooks and Memo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩和备忘录进行性能优化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/performance-optimization-with-react-hooks-and-memo-e3186f7ff9ab?source=collection_archive---------5-----------------------#2020-01-13">https://betterprogramming.pub/performance-optimization-with-react-hooks-and-memo-e3186f7ff9ab?source=collection_archive---------5-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cbf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用功能组件提高应用程序性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f9d47051746c6556d837cb626aa0eaab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6Va3bq_bKq41BvsiKSj9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://en.wikipedia.org/w/index.php?title=User:DBSand&amp;action=edit&amp;redlink=1" rel="noopener ugc nofollow" target="_blank"> DBSand </a>在<a class="ae ky" href="https://en.wikipedia.org/wiki/Bottom-up_parsing#/media/File:Bottom-up_Parse_Tree_Order.svg" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>上的插图</p></figure><p id="e217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建一个有用的应用程序是一回事，让应用程序平稳快速地加载是完全不同的另一回事——而且，可以说，同样重要。</p><p id="db2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多方法可以优化React中应用程序以提高其性能。</p><p id="de1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始研究如何通过构建一个简单的应用程序并实现React Memo中包含的记忆技术来做到这一点之前，让我们回顾一下优化的过程。</p><p id="aa66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">优化</em>是根据初始模型衡量时最有效的过程。如果我们在没有初始测量进行比较的情况下，通过实施React Memo等工具过度抢先进行优化，我们就不再为自己提供所需的上下文来正确评估我们如何、何时以及在何处进行改进，从而无法提供正确的优化。</p><p id="b15c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">耐心和让流程流动是成功优化和平稳运行应用程序的关键，年轻的学徒。</p><p id="4380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对我们来说，比较性能测量的差异是很重要的。</p><p id="f6e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们将看一个利用React钩子的简单应用程序，并测量使用和不使用React Memo时的性能差异。</p><p id="ba88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意编码，甚至跟随底部的视频演示，或者只是观察下面文档中的差异。但首先，让我们进一步定义React Memo。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1b63" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">反应备忘录与纯组件</h1><p id="37c1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">React Memo是一个高阶组件，它包装了功能组件，并通过记忆它们来提高它们的性能。</p><p id="e141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个意义上说，<code class="fe na nb nc nd b">React.PureComponent </code>为基于类的组件提供的是功能组件的解决方案。</p><p id="95bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，每个功能都只是简单地介绍给它们的组件，如下所示:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="ed38" class="ni me it nd b gy nj nk l nl nm">// PureComponent Class Based:<br/>class Count extends React.PureComponent { }</span></pre><p id="2a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对比:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="8227" class="ni me it nd b gy nj nk l nl nm">// React.Memo Functional Component:<br/>const App = ({}) =&gt; {}</span><span id="8064" class="ni me it nd b gy nn nk l nl nm">export default React.memo(App)</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="30e4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">React Memo如何工作</h1><p id="967d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">React Memo通过仅在属性发生变化时渲染其包装组件来提高性能。但是，需要注意的是，默认情况下，React Memo只会浅浅地比较props对象中的复杂对象。</p><p id="e207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过查看生命周期方法<code class="fe na nb nc nd b">shouldComponentUpdate(nextProps, nextState)</code>的一个示例来进一步比较这是如何工作的。</p><p id="f0e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以利用<code class="fe na nb nc nd b">shouldComponentUpdate</code>来决定一个组件是否应该在渲染时更新，这是基于检查正在更新的<code class="fe na nb nc nd b">nextProps</code>是否等于当前的道具。</p><p id="f92b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个实现实际上和React Memo的工作原理相似，但是官方的reactor文档建议不要使用它来防止重新渲染——因为它可能会导致错误。相反，他们建议使用旨在更全面的功能，确保跳过的潜在必要步骤更少。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1834" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">反应应用示例</h1><p id="a61a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在，让我们检查一个基本的应用程序，并使用React Dev工具在使用<code class="fe na nb nc nd b">React.Memo</code>进行表情符号化之前和之后测量其性能。</p><p id="63c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个应用程序，它有两个基本组件:一个按钮，每次点击都会连续增加一个；一个天气组件，显示一个城市和该城市的天气。</p><p id="da0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，用下面的代码检查一个包含我们的<code class="fe na nb nc nd b">Weather</code>子组件的JavaScript文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="84e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的简单功能组件以被破坏的<code class="fe na nb nc nd b">weather</code>属性为道具，返回两个<code class="fe na nb nc nd b">p</code>标签，显示访问<code class="fe na nb nc nd b">city</code>和<code class="fe na nb nc nd b">temperature</code>的进一步点标记。</p><p id="4cf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在即将到来的测试中加入了一个<code class="fe na nb nc nd b">console.log(‘Render’)</code>来演示我们的应用程序渲染天气应用程序的次数。</p><p id="f8f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。好了，现在观察另一个JavaScript文件，它包含我们的按钮应用程序并保存我们的父状态，它将道具传递给我们的子<code class="fe na nb nc nd b">Weather</code>组件。我们将实现反作用钩子来存储我们的计数器并设置增量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们加载开发服务器并编译应用程序时，我们会显示一个按钮和一个<code class="fe na nb nc nd b">0</code>——以及<code class="fe na nb nc nd b">Miami</code>的城市和它在<code class="fe na nb nc nd b">80F</code>的温度。</p><p id="80ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还在Chrome DevTools控制台中注意到，我们从我们的<code class="fe na nb nc nd b">Weather</code>组件接收渲染的初始<code class="fe na nb nc nd b">console.log</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/58c330e6cae2fbd9da6fca915e94b55c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjteRP9syM0_of8_MI4sIQ.png"/></div></div></figure><p id="92dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们单击增量按钮时，此处的问题就会变得明显。</p><p id="816e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击增量按钮七次将返回以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/59311f6a001bb3f10e4079b5d85cfefc.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*P_Z0ExxMPGPjeGedyAg2rQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/56db2aef197996623403cf852aaf31ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xiZJEdHDRVNhTZZBal2G0g.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b605" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">实施反应。备忘录</h1><p id="272f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">虽然我们的按钮正在工作，我们的状态也在相应地更新和显示，但是我们的控制台现在显示我们的<code class="fe na nb nc nd b">Weather</code>组件已经被渲染了七次。</p><p id="24b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是无用的渲染发生在我们每次点击按钮的时候，因为我们的<code class="fe na nb nc nd b">Weather</code>组件的属性不需要在我们每次改变按钮状态的时候都改变，这就要花费我们额外的不必要的计算。</p><p id="5198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何解决这个问题呢？好吧，你猜对了……<code class="fe na nb nc nd b">React.memo</code>来解救！</p><p id="4a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的天气应用程序，我们可以将<code class="fe na nb nc nd b">React.memo</code>包装在导出的<code class="fe na nb nc nd b">Weather</code>周围，就像这样:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2ec6" class="ni me it nd b gy nj nk l nl nm">export default React.memo(Weather)</span></pre><p id="4fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么简单。现在，当我们刷新应用程序并再次单击增量按钮七次时。我们会注意到下面的重要变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/fe3fd5968da4b5367eff0909949972cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*frWK4jmYRXNwd0FD6idotg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/0a251526f5d4eec9d3feb63d245a6214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJq6qU2SMLDpWfHVg84Ngg.png"/></div></div></figure><p id="6679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们的按钮已经被渲染了七次，但是我们的<code class="fe na nb nc nd b">Weather</code>组件只被渲染了一次。通过成功实现记忆化，我们有效地增强了应用程序的性能。</p><p id="97dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进一步展示我们使用React开发工具进行优化的测量差异。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="70d6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">React开发人员工具分析器</h1><p id="cd28" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你还没有安装React开发者工具，你可以点击这里提供的链接<a class="ae ky" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击右上角的蓝色按钮，将扩展添加到Chrome。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/655f78bbf38088d7725267134878e105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psIlRBk9nt2uR2O5E--tkQ.png"/></div></div></figure><p id="337c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦添加了扩展，您现在就已经将React组件(包括Profiler)添加到控制台开发人员工具带上了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/3e5baf460f3d2d5cf9ce976970674d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIiW8_MYGW57e8oAc_eYqQ.png"/></div></div></figure><p id="f9c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Components选项将打开一个选项卡，我们可以在其中检查React应用程序中呈现在浏览器上的各个组件，就像Elements选项卡检查元素一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/8a491779beb412e2b6292ec6aff510c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5yvwMBvZs6FJ-L-6tV3qA.png"/></div></div></figure><p id="8438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe na nb nc nd b">Weather</code>组件现在在应用程序中向我们显示天气的属性。太好了。然而，出于演示的目的，让我们转到分析器来测量我们的渲染时间的性能。</p><p id="2cf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在浏览器中刷新应用程序。然后，在我们的Profiler选项卡中，如果我们单击record circle，我们现在正在记录组件的渲染时间。让我们点击增量按钮六次，然后再次点击记录按钮来记录我们的测量值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/f14c10370b4323aa4f71213c2619da9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZ6Raoh-2h1QZEL2nMJQ6A.png"/></div></div></figure><p id="64ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在看到我们的<code class="fe na nb nc nd b">Weather</code>组件，包装在<code class="fe na nb nc nd b">(Memo)</code>中，显示状态为“在概要文件会话期间没有呈现”</p><p id="af3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们再次重复同样的过程——只是这一次，我们将从子组件<code class="fe na nb nc nd b">Weather</code>中移除<code class="fe na nb nc nd b">React.memo</code>高阶组件。</p><p id="601a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将看到我们的<code class="fe na nb nc nd b">Weather</code>组件在每个应用程序渲染中的六次新渲染，平均每次渲染多一毫秒。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c711255d7f1bbc6ca67c5b47982ef8b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRRbQPYsJD4fbh1ZuiGDfQ.png"/></div></div></figure><p id="97f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过用React Developer Tools GUI测量我们的渲染差异，我们能够更深入地看到不同的结果。我们保留无用的渲染，利用<code class="fe na nb nc nd b">React.memo</code>进入我们的应用程序。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e830" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="31cf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">通过首先构建我们的应用程序，而不是先发制人地应用优化，而是有一个初始比较值，我们能够用我们自己的测试实现来测量我们的性能——以及引入有用的扩展，如React开发人员工具。</p><p id="cf04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些结果，我们就可以检查我们的应用程序的性能，并设计增强和优化的方法和功能。对照之前的结果进行测量，将引导我们更深入地研究我们的应用，并找到我们优化所需的最佳解决方案。</p><p id="7c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如需更多资源，请查看React Dev 2020上的性能优化部分，该部分激发了我将在下面链接的文档。</p><p id="8fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多关于记忆化的信息，你可以看看我之前写的一篇文章和例子，也是关于用Javascript回顾记忆化的。</p><p id="f46d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我还将链接到一个视频教程以及源代码。</p><p id="3430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。感谢您查看这篇文章，我希望您能从中得到一些帮助！</p><h2 id="e541" class="ni me it bd mf oa ob dn mj oc od dp mn li oe of mp lm og oh mr lq oi oj mt ok bi translated">资源</h2><ul class=""><li id="041e" class="ol om it lb b lc mv lf mw li on lm oo lq op lu oq or os ot bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=MQSav554YOQ&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">视频教程</a></li><li id="eb0c" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><a class="ae ky" href="https://github.com/01Clarian/react-memo-example" rel="noopener ugc nofollow" target="_blank">源代码</a></li><li id="d30f" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><a class="ae ky" href="https://www.udemy.com/course/the-complete-web-developer-zero-to-mastery/" rel="noopener ugc nofollow" target="_blank">2020年的完全网络开发者:零到精通</a></li><li id="9a52" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><a class="ae ky" href="http://JavaScript Memoization and Expensive Code" rel="noopener ugc nofollow" target="_blank">“JavaScript记忆化和昂贵的代码”</a></li></ul></div></div>    
</body>
</html>