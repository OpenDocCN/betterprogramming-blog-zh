<html>
<head>
<title>How to Build A Text Filtering, Log Simplifying Tool in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中建立一个文本过滤、日志简化工具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092?source=collection_archive---------15-----------------------#2022-08-08">https://betterprogramming.pub/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092?source=collection_archive---------15-----------------------#2022-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e857" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻松删除匹配的文本行。非常适合在调试时减少日志！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b64e71455b82cda0fd821785f2456061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aP5RBokkx5iQvC5e_iqRvA.jpeg"/></div></div></figure><p id="4a07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是四部分系列的第一部分(有些仍在进行中)。你可以在这里找到其他人:</p><ul class=""><li id="9e3d" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/@gourikabang1996/part-2-how-to-prepare-for-your-next-coding-interview-d048b188301e" rel="noopener">第2部分:添加正则表达式支持</a></li><li id="1677" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/benchmarking-in-go-substrings-vs-regular-expressions-a84de7f0eb02">第3部分:Go中的基准程序</a></li><li id="ef05" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/benchmarking-command-line-tools-7d00ed4813cc">第4部分:针对grep的命令行基准测试</a></li></ul><h1 id="ad3a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">我们在建造什么？</h1><p id="ab52" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在软件工程中，我们经常解析日志文件来了解程序的内部状态。在存在频繁但不相关的(嘈杂的)日志的情况下，这可能是乏味的，尤其是在作为分布式团队进行调试时。为此，我在Go中编写了一个简单的程序，删除包含子字符串(或一系列子字符串中的一个)的任何文本行，并生成一个包含除匹配以外的所有内容的新文件。多年来，这被证明是非常宝贵的——对我和那些从我停下的地方开始调试系统的人来说都是如此。</p><p id="0c7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">标准工具可以帮助过滤现有的日志行，但是这个程序允许你做相反的事情——遍历一个文件，删除你发现的有干扰的日志！</p><h1 id="cb72" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">设计工具</h1><p id="d716" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在我们开始编码之前，让我们考虑一下如何使用这个工具。鉴于这是一个相当技术性的产品，只需要一个简单的界面，命令行界面(CLI)似乎是合适的。</p><p id="4928" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输入呢？我们需要提供文件源、从该源中删除的关键短语，以及我们是否希望该文件被就地编辑。一个可选的增强可以是提供输出文件的路径(如果没有被就地编辑),或者使用输出文件路径的存在来确定就地编辑。</p><p id="4b28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们要送什么？我们可以为各种操作系统和架构构建和分发二进制文件，甚至可能部署它们(artifactory，有人知道吗？).同样，由于这是一个技术产品(而且是免费/开源的！)，我们应该可以交付带有构建和使用说明的<code class="fe mz na nb nc b">README.md</code>，并期望我们的用户制作他们自己的二进制文件。</p><h1 id="9155" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">构建工具</h1><p id="d8c6" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">接下来，我们将定义构建该工具所需的技术细节。在我们的简单例子中，我们需要以下组件:</p><ul class=""><li id="9310" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">标志解析(针对用户提供的选项)</li><li id="f5c6" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">帮助输出(如果工具使用不当)</li><li id="acaf" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">一种确定文本行是否匹配给定输入字符串的方法</li><li id="5285" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">要写入的输出/目标文件</li><li id="5440" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">从输入中剪切匹配文本行的方法</li><li id="b63f" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">一种替换“就地”编辑的原始文件的方法</li><li id="6c5e" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">基准/测试(我们将在另一篇文章中讨论)</li></ul><p id="1f78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从我们的主要运行循环开始。这将处理用户输入标志和编辑文本文件的基本逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bb92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们获取用户提供的参数来调整文件，然后执行调整(如果有任何错误，我们就退出)。</p><p id="18bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了获得用户提供的参数，我们将定义一个<code class="fe mz na nb nc b">config</code>结构，并使用标准库中的<a class="ae lw" href="https://pkg.go.dev/flag" rel="noopener ugc nofollow" target="_blank">标志包</a>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b891" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们定义<code class="fe mz na nb nc b">config</code>是为了方便我们自己和未来的读者——我们可以发送对<code class="fe mz na nb nc b">config</code>的引用，集中定义和任何可能的文档，而不是在函数之间传递三个或更多参数。如果我们决定扩展这个工具(提示，提示😉).</p><p id="7964" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们根据上面的要求定义输入——一个字符串表示输入文件路径，一个字符串表示要删除的关键短语，一个布尔值表示文件是否应该就地编辑。我们为每个标志定义名称、默认值和用法/助手解释器字符串。请注意，每个返回指针都指向所指示的类型(而不是所指示的类型本身)。<code class="fe mz na nb nc b">flags.Parse()</code>将来自<code class="fe mz na nb nc b">os.Args[1:]</code>的用户提供的标志解析成这些指针变量。在那里，我们验证是否适当地提供了标志，并将它们返回给调用者。</p><p id="f0b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来是转换输入的业务逻辑。下面，我们清理任何预先存在的临时输出文件，生成一个全部是<code class="fe mz na nb nc b">cfg.inputPath</code>的输出文件，没有任何行包含<code class="fe mz na nb nc b">cfg.keys</code>中的任何键，最后，替换原始文件(如果用户指定到位)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9e08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们构建实际的逻辑来解析输入文件，检查提供的任何键，并生成输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fe40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们首先打开所提供的输入文件(如果有任何问题，就退出)。注意，我们使用的是一个命名的错误返回参数——我们稍后会讨论这个问题。</p><p id="a5e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们正在处理文件，所以我们应该记得通过推迟<code class="fe mz na nb nc b">sourceFile.Close()</code>来清理自己的文件(从技术上讲，我们不需要为这里的readonly文件这样做，但是这仍然是一个很好的实践。你可以在这里深入了解更多<a class="ae lw" href="https://stackoverflow.com/questions/62986434/is-close-needed-for-a-file-opened-by-os-open" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="54d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们使用与源文件相同的文件前缀和目录创建或打开输出文件，使其可写。我们将推迟在成功时关闭它，但这里我们关心的是错误，因为它可能表明输出文件不完整。因此，如果之前没有错误，我们将把返回错误值设置为由<code class="fe mz na nb nc b">outFile.Close()</code>生成的任何错误。</p><p id="fd78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">日志文件可能非常大。因此，这段代码可能会执行许多小的写操作，影响性能。为了缓解这种情况，我们将使用<a class="ae lw" href="https://pkg.go.dev/bufio" rel="noopener ugc nofollow" target="_blank"> bufio </a>(另一个标准库包)来提供缓冲的I/O。本质上，这将把许多小的写操作批处理为更少但更大的写操作，这将导致更少的性能开销(您可以在这里阅读关于<code class="fe mz na nb nc b">bufio</code> <a class="ae lw" href="https://medium.com/golangspec/introduction-to-bufio-package-in-golang-ad7d1877f762" rel="noopener">的更多信息)。我们还将在源文件上使用缓冲阅读器。</a></p><p id="30f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开源文件和目标文件后，我们将生成一个缓冲的writer。为了避免最后丢失任何数据，我们将推迟一个<code class="fe mz na nb nc b">Flush()</code>调用来强制将缓冲区中的任何内容写入目标文件，并且我们将根据需要再次设置我们的返回错误参数。</p><p id="e071" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们在源文件上生成一个缓冲读取器，并逐行扫描内容。如果该行不包含任何作为子串的<code class="fe mz na nb nc b">keys</code>，我们将它写入缓冲的writer(最终将被写入我们的目标文件)。在所有行都被读完或推迟后开始。假设没有错误，我们将<code class="fe mz na nb nc b">Flush()</code>缓冲区以将任何剩余内容写入文件，关闭文件，并成功返回。</p><h1 id="7c4a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">使用工具</h1><p id="404e" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">使用该工具的形式如下:</p><p id="d907" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">go run main.go -file="&lt;path/to/src/file&gt;" -keys="&lt;keys to search for|with multiple separated by|pipes&gt;"</code>(和一个可选的<code class="fe mz na nb nc b">-inplace</code>，用输出替换源文件)。</p><p id="b1f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您克隆了<a class="ae lw" href="https://github.com/swayne275/lineremover" rel="noopener ugc nofollow" target="_blank">项目</a>，您可以在<code class="fe mz na nb nc b">example/input.txt</code>上测试一些修剪操作，如下所示:</p><p id="543e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nf">删除所有以“hello”为前缀的内容</em>:</p><p id="727c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">go run main.go -file="example/input.txt -keys="hello"</code></p><p id="b2b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nf">删除所有包含“世界”的内容</em>(即删除所有线条):</p><p id="0743" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">go run main.go -file="example/input.txt -keys="world"</code></p><p id="d21a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nf">删除包含“大”或“小”字样的所有内容:</em></p><p id="33be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">go run main.go -file="example/input.txt -keys="big|small"</code></p><p id="fd67" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以查看自述文件以了解更多信息，并进行试验，看看您能得出什么结论！</p><h1 id="fced" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">进一步的改进</h1><p id="a9ca" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我们一起构建了一个简单而有效的工具。尽管如此，仍有明显的改进余地。</p><p id="4c36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于子串搜索，最好采用正则表达式(regex)作为输入，而不是一个或多个键。你可以在这个系列的第二部分中找到。</p><p id="a425" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我计划写一篇后续文章来探讨这些选择。如果你还能想到什么，请在评论中告诉我。我也非常感谢任何命名建议或代码清晰度的改进！</p><p id="221f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我计划写一篇后续文章来讨论Go中的基本基准测试(你可能会在这个项目的<a class="ae lw" href="https://github.com/swayne275/lineremover" rel="noopener ugc nofollow" target="_blank"> GitHub repo中看到一些早期代码)。</a></p></div></div>    
</body>
</html>