<html>
<head>
<title>Advantages of Elixir vs. Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">长生不老药相对于Golang的优势</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advantages-of-elixir-vs-golang-11ac1a67bfe7?source=collection_archive---------0-----------------------#2020-03-30">https://betterprogramming.pub/advantages-of-elixir-vs-golang-11ac1a67bfe7?source=collection_archive---------0-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">两种较新的语言，我们来比较一下</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/085d9430cf03094753dbc655865a2910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5eVy4HM4Y6oih9E1SMGlA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jeroendenotter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">耶鲁安穴獭</a>在<a class="ae ky" href="https://unsplash.com/s/photos/comparison?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="c24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个潜在客户最近问我<a class="ae ky" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank">仙丹</a>比<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>有什么优势。</p><p id="45bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单的答案是<em class="lv">生产力</em>。你得到了两个世界的最好的东西:高级语言的生产力和成熟的Erlang平台的伸缩能力。</p><p id="0a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go是一种低级语言，性能很好，但是它缺乏现代语言的生产力特性。它是为谷歌规模的相对低级的服务开发的，例如HTTP路由基础设施。</p><p id="32cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你以他们的规模操作时，你需要性能，但是C++的复杂性很难处理。您需要并发，但是多线程网络编程容易出错。我花了几年时间用C++做VoIP应用，所以我知道这种痛苦。</p><p id="0cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是对智能C++和Java程序员创建抽象概念的趋势的一种反应，随着时间的推移，这些抽象概念会使系统更难维护。这些层次使得很难跳入一个大的代码库并解决问题。</p><p id="854d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于不仅仅是程序员的sre来说，这是一个特别的问题，他们还必须应对云基础架构、网络、存储等挑战。</p><p id="f1bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Python这样的高级脚本语言很难大规模操作。它们受到性能差和缺乏并发性的困扰。动态类型使得运行时很难避免错误，需要大量的测试。</p><p id="4b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖性使得它们很难部署，所以简单地将二进制文件复制到服务器的能力非常有吸引力。</p><p id="60be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go基本上是C++的简化版，c++是一种“蓝领”语言。<a class="ae ky" href="https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440" rel="noopener ugc nofollow" target="_blank">Go编程语言</a>是这样描述的:</p><blockquote class="lw lx ly"><p id="5371" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“Go项目包括语言本身、它的工具和标准库，最后但同样重要的是，一个彻底简单的文化议程。</p><p id="33c2" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">作为一门新兴的高级语言，Go具有后知之明，而且基础做得很好:它有垃圾收集、包系统、一流的函数、词法范围、系统调用接口和不可变的字符串，其中文本通常以UTF-8编码。</p><p id="6754" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">但它的功能相对较少，不太可能增加更多。例如，它没有隐式数字转换，没有构造函数或析构函数，没有运算符重载，没有默认参数值，没有继承，没有泛型，没有异常，没有宏，没有函数注释，没有线程本地存储。</p><p id="a175" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">这种语言是成熟和稳定的，并保证了向后兼容性:旧的Go程序可以用新版本的编译器和标准库编译和运行。"</p></blockquote><p id="8276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">围棋中有一种“抱残守缺”的态度。大规模部署大型系统很糟糕，所以我们选择简单的工具，这些工具将一直工作并解决问题。</p><p id="a83f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我能理解这种视角，但我没有那么愤世嫉俗。它忽略了我们可以通过现代编程语言特性获得的生产力和安全性的提高。</p><p id="2226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">爱立信在创建Erlang(长生不老药的基础)时也遇到了类似的问题。他们一直在用低级语言构建他们的电话交换机，这种情况正在失去控制。这些系统复杂、漏洞百出，而且开发成本高昂。</p><p id="2e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们的解决方案是将低级运行时与高级语言和框架相结合，以一劳永逸地处理网络和并发性问题，从而使编程更容易。</p><p id="f5fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Erlang的显著特点是并发性和容错性。轻量级流程模型使得创建可扩展到数百万有状态连接的系统变得简单，例如WhatsApp。</p><p id="5641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该平台拥有丰富的工具来创建、调试和管理大型生产系统。OTP框架标准化了用组件构建服务的模式。</p><p id="5511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该平台包括内存中的键/值存储、进程注册表等特性。，以及针对生产系统跟踪、大容量日志记录、警报和指标等问题的内置解决方案。</p><p id="241d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elixir从成熟的Erlang平台开始，并添加了强大的语言特性，如lisp风格的宏和协议。我们获得了面向对象语言的易用性，没有组件之间的紧密耦合。</p><p id="7c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程为我们提供了适用于所有数据的通用算法。模式匹配使逻辑更简单。二进制匹配语法使得以高性能可靠地实现网络协议变得容易。</p><p id="5757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不变性和无副作用使得系统更容易推理和调试。与学术函数式语言不同，如Haskell T1，这种语言专注于实用的工业编程，而不是类型理论。</p><p id="f3b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据结构简单易懂。每个人都在谈论并发性，因为它很特别，但是这种语言本身确实是一种编程乐趣。</p><p id="637b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个例子，Go <a class="ae ky" href="https://github.com/confluentinc/confluent-kafka-go" rel="noopener ugc nofollow" target="_blank">中的错误处理看起来像这样</a>:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="bcf9" class="mh mi it md b gy mj mk l ml mm">c, err := foo.Client()<br/>if err != nil {<br/>    panic(err)<br/>}<br/>msg, err := c.Request(foo, bar)<br/>if err == nil {<br/>    fmt.Printf("Message on %s: %s\n", msg.Topic, string(msg.Value))<br/>} else {<br/>    fmt.Printf("Client error: %v (%v)\n", err, msg)<br/>    break<br/>}</span></pre><p id="be55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elixir中的等价代码简单地说就是:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="4cc3" class="mh mi it md b gy mj mk l ml mm">{:ok, conn} = Foo.Client.connect()<br/>{:ok, result} = Foo.Client.request(conn, foo, bar)</span></pre><p id="30f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elixir的模式匹配让我们为成功案例编程。如果我们得到一个错误返回(例如<code class="fe mn mo mp md b">{:error, reason}</code>，那么未处理的匹配将失败，线程将退出。它会将调用的所有上下文写回日志，这样我们就可以在我们的开发环境中重现这个问题。</p><p id="7cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主管监控流程并管理所有错误，包括我们可能遗漏的错误。这不同于异常，因为它允许我们实际处理错误，例如，在连接超时时重试调用。</p><p id="274f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elixir正在借此机会重新思考和完善一个已建立的系统。成熟的语言是随着时间积累的。</p><p id="e393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，Java有多个日期-时间类(<code class="fe mn mo mp md b">java.util.Date</code>、<code class="fe mn mo mp md b">java.sql.Date</code>、<code class="fe mn mo mp md b">Calendar</code>)，我们必须在它们之间进行转换。函数有不同顺序的参数，所以我们必须继续查看文档。</p><p id="6eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当微软创造C#和。NET，他们受益于从Java中学习，这帮助他们快速创建一个完整的、一致的标准库和虚拟机。</p><p id="da7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elixir为Erlang做到了这一点，但也可以利用所有现有的Erlang库。</p><p id="12a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，很多Elixir社区来自Rails，因为Elixir的创建者José Valim是Rails的提交者。他从成熟的Rails系统开始，又做了一次，做得更好，专注于他在维护大型Rails项目时遇到的问题，这些项目随着时间的推移而发展。</p><p id="4097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该平台具有更好的性能和可靠性，但也在“魔法”上后退了一步，因为一些使简单项目变得容易的功能最终会在项目变大时引发问题。</p><p id="c02b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了标准的MVC，<a class="ae ky" href="http://phoenixframework.org/" rel="noopener ugc nofollow" target="_blank">凤凰网框架</a>提供了一个“通道”抽象，使得创建有状态的网络应用变得容易，例如，网络聊天系统。还有一个与Phoenix集成的GraphQL服务器。</p><p id="5d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和Ruby on Rails一样，程序员的生产力和易用性是社区关注的焦点。一切开箱即用，并且有标准的、集成良好的工具用于测试、资产管道、部署等。</p><p id="a7e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们从Ruby那里获得了他们喜欢的库，并在Elixir中实现了它们。还有来自学术界的用于静态分析和属性测试的尖端工具。</p><p id="690f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，Golang最有趣的应用是网络服务，它们需要非常快，也就是说，它们受CPU的限制。垃圾收集避免了一大类错误，使其更加安全。</p><p id="83fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go内置了使用CSP模型的并发性，它可以非常高效地调用C库。好的应用程序是像深度内容检查或运行机器学习模型这样的东西。</p><p id="3b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你在大规模运营时，硬件成本实际上开始比程序员的时间更重要。</p><p id="bd63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们中的大多数人并没有像Google那样编写应用程序，但是我们仍然需要有效地使用我们现有的硬件。要做到这一点，我们需要能够处理并发的语言，但当前的语言和平台面临着挑战。</p><p id="c68f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很难让现有的语言和库变得安全，因为它打破了程序员的假设。网络通信库需要重写为非阻塞的或者使用线程。</p><p id="49b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更糟糕的是，共享数据需要加锁来保护并发访问。这使得现有的脚本语言如Python、Ruby和PHP很难支持并发性。</p><p id="3b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js是围绕非阻塞IO构建的，但是如果没有像多进程这样的攻击，就无法利用多个CPU。暴露的机制太多，语言缺乏类型安全性。</p><p id="b3f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java使用与C++类似的基于线程的并发方法，但是普遍的面向对象给每个对象带来了潜在的锁定问题。</p><p id="486a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust有潜力作为C语言的安全替代品来进行系统编程，并具有并发性。但是，对于一般的应用程序开发效率来说，这个水平太低了。</p><p id="9dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elixir从第一天起就支持并发性，并且拥有30多年为Erlang开发的工具。虽然绝对性能不如编译语言，但并行化任务以利用机器是很容易的。</p><p id="68cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这还不够，我们可以将应用程序部署到一个服务器集群上，只需稍作修改。这就是<em class="lv">速度</em>和<em class="lv">扩展性</em>的区别。Go关注的是底层性能，依靠Kubernetes这样的系统进行扩展。不过，这也有它自己的复杂问题要处理。</p><p id="5ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Elixir中添加库来完成实际的web编程任务比让其他系统并发和可靠要容易得多。</p><p id="351c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在用它来构建大型系统，我们知道它是有效的。我们可以继续构建下一代系统，而不是为现有语言的并发性而奋斗。</p></div></div>    
</body>
</html>