<html>
<head>
<title>Composing Powerful TypeScript Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建强大的类型脚本接口</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/composing-powerful-typescript-interfaces-ba549ec6c49f?source=collection_archive---------3-----------------------#2022-01-29">https://betterprogramming.pub/composing-powerful-typescript-interfaces-ba549ec6c49f?source=collection_archive---------3-----------------------#2022-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="11ba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以游戏渲染场景为例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e82907c3a2a5252b216bc41b0c789f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*haDAJIK2omdE0RwI"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@frostroomhead?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rodion Kutsaev </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeScript通过接口从多种类型组合行为的能力是一个强大的功能。这些契约提供了一种抽象，只通过接口进行交互，而不考虑类。</p><p id="5309" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于类可以实现多个接口，这通过基类减轻了继承链的复杂性。</p><p id="f1d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口还定义了多态性，使多个类能够实施与实现无关的行为。实现相同接口的类可以互相替换。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="997d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">可用接口</h1><p id="a1bd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">。NET框架中关于能力接口的约定总能引起我的共鸣——像<code class="fe mw mx my mz b">IEquatable</code>或<code class="fe mw mx my mz b">IComparable</code>这样的东西通过添加“能力”后缀将接口的动作变成了一个形容词。</p><p id="4d5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您有一个由实体组成的绘图应用程序，这些实体将执行自己的谨慎呈现操作。</p><p id="7814" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe mw mx my mz b">render()</code>功能将存在于一个<code class="fe mw mx my mz b">IRenderable</code>接口中:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="2504" class="ne ma iq mz b gy nf ng l nh ni">export interface IRenderable {<br/>  render(): void;<br/>}</span></pre><p id="8f82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多个类可以实现这个接口，比如<code class="fe mw mx my mz b">Circle</code>和<code class="fe mw mx my mz b">Rectangle</code>:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="bf74" class="ne ma iq mz b gy nf ng l nh ni">export class Circle implements IRenderable {<br/>  render(): void {<br/>    console.log("Circle rendering code here...")<br/>  }<br/>}<br/><br/>export class Rectangle implements IRenderable {<br/>  render(): void {<br/>    console.log("Rectangle rendering code here...")<br/>  }<br/>}</span></pre><p id="8683" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这里的功能是通过接口类型消除对那些具体类的关注。例如，假设您想要引用单个形状:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="63ed" class="ne ma iq mz b gy nf ng l nh ni">const shape: IRenderable = new Circle();<br/>shape.render();</span></pre><p id="e87a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，将类实例更改为不同的类，该类强制执行接口指定的相同协定:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="0d84" class="ne ma iq mz b gy nf ng l nh ni">let shape: IRenderable;<br/><br/>shape = new Circle();<br/>shape.render();<br/><br/>shape = new Rectangle();<br/>shape.render();</span></pre><p id="11cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这方面的一个实际例子是将形状添加到集合中，稍后您将整个集合呈现到画布上:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="e692" class="ne ma iq mz b gy nf ng l nh ni">const shapes: IRenderable[] = [<br/>  new Circle(), <br/>  new Rectangle()<br/>];<br/><br/>for (let shape of shapes) {<br/>  shape.render();<br/>}</span></pre><p id="971e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个完整的例子，利用PIXI绘画:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="3a16" class="ne ma iq mz b gy nf ng l nh ni">export interface IRenderable {<br/>  render(graphics: PIXI.Graphics): void;<br/>}<br/><br/>export class Circle implements IRenderable {<br/>  public radius: number = 100;<br/><br/>  render(graphics: PIXI.Graphics): void {<br/>    graphics.drawCircle(0, 0, this.radius);<br/>  }<br/>}<br/><br/>export class Rectangle implements IRenderable {<br/>  public width: number = 100;<br/>  public height: number = 100;<br/><br/>  render(graphics: PIXI.Graphics): void {<br/>    graphics.drawRect(0, 0, this.width, this.height);<br/>  }<br/>}</span><span id="bdb2" class="ne ma iq mz b gy nj ng l nh ni">// Define shapes and graphics context to render upon<br/>const shapes: IRenderable[] = [new Circle(), new Rectangle()];<br/>const graphics = new PIXI.Graphics();<br/><br/>for (let shape of shapes) {<br/>  shape.render(graphics);<br/>}</span></pre><h1 id="7f28" class="lz ma iq bd mb mc nk me mf mg nl mi mj jw nm jx ml jz nn ka mn kc no kd mp mq bi translated">编写界面</h1><p id="ca31" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设你想用渲染引擎合成一个游戏场景——让我们看看Pixi的内置ticker vs一个自定义动画循环。</p><p id="a0f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的游戏场景界面将接受一个通用类型的引擎:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="04e2" class="ne ma iq mz b gy nf ng l nh ni">export interface IGameScene&lt;T&gt; {<br/>  engine: T;<br/>}</span></pre><p id="5cc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的引擎接口只需要一个<code class="fe mw mx my mz b">start()</code>函数来启动渲染引擎进程:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="fd7d" class="ne ma iq mz b gy nf ng l nh ni">export interface IEngine {<br/>  start(): void;<br/>}</span></pre><p id="fbe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的第一个引擎将使用Pixi提供的默认<code class="fe mw mx my mz b">Ticker</code>——我们称之为<code class="fe mw mx my mz b">TickerEngine</code>,它将实现<code class="fe mw mx my mz b">IEngine</code>接口:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="b077" class="ne ma iq mz b gy nf ng l nh ni">export class TickerEngine implements IEngine {<br/>  start(): void {<br/>    console.log("Starting ticker engine...");<br/>    const renderer = new PIXI.Renderer();<br/>    const scene = new PIXI.Container();<br/>    const ticker = new PIXI.Ticker();<br/><br/>    ticker.add(() =&gt; {<br/>      console.log("ticker frame handler");<br/>      renderer.render(scene);<br/>    }, PIXI.UPDATE_PRIORITY.LOW);<br/><br/>    ticker.start();<br/>  }<br/>}</span></pre><p id="1a1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的第二个引擎将使用一个定制的动画帧处理器——我们称之为<code class="fe mw mx my mz b">LoopEngine</code>,它也实现了<code class="fe mw mx my mz b">IEngine</code>接口:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="df90" class="ne ma iq mz b gy nf ng l nh ni">export class LoopEngine implements IEngine {<br/>  renderer = new PIXI.Renderer();<br/>  scene = new PIXI.Container();<br/><br/>  start(): void {<br/>    console.log("Starting loop engine...");<br/>    requestAnimationFrame(this.frameHandler);<br/>  }<br/><br/>  private frameHandler = () =&gt; {<br/>    console.log("loop frame handler");<br/>    this.renderer.render(this.scene);<br/>    requestAnimationFrame(this.frameHandler);<br/>  };<br/>}</span></pre><p id="bfda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是游戏场景——它将实现类型为<code class="fe mw mx my mz b">IEngine</code>的<code class="fe mw mx my mz b">IGameScene</code>接口。这使我们能够指定想要使用的引擎，并在构建时自动启动引擎:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="ee0f" class="ne ma iq mz b gy nf ng l nh ni">export class Scene implements IGameScene&lt;IEngine&gt; {<br/>  engine: IEngine;<br/><br/>  constructor(engine: IEngine) {<br/>    this.engine = engine;<br/>    this.engine.start();<br/>  }<br/>}</span></pre><p id="a606" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试一试，从ticker引擎开始:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="185d" class="ne ma iq mz b gy nf ng l nh ni">const scene = new Scene(new TickerEngine());</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e65de74bc11e4013a13dfc7d15cb08e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/1*Thb_JuXKmWznHVQyyKRMMA.gif"/></div></figure><p id="f08c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，自定义循环引擎:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="b257" class="ne ma iq mz b gy nf ng l nh ni">const scene = new Scene(new LoopEngine());</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/b62a25e7a3741f4d600aa351159757d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/1*VDmj2FtT9eThYi19AmuiYA.gif"/></div></figure><p id="e5be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法使我们能够将行为与公共契约组合在一起，建立熟悉的代码形式。</p><h1 id="77e9" class="lz ma iq bd mb mc nk me mf mg nl mi mj jw nm jx ml jz nn ka mn kc no kd mp mq bi translated">进一步封装</h1><p id="dade" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设您正在评估游戏的两个物理引擎，并希望在它们之间进行交换。在你的应用程序的动画帧处理器中，你想简单地调用<code class="fe mw mx my mz b">step()</code>来调用物理引擎计算的一个步骤。首先将您的API定义为:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="a0a2" class="ne ma iq mz b gy nf ng l nh ni">export interface IPhysicsEngine {<br/>  step(): void;<br/>}</span></pre><p id="20f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您找到了一个与您的图形框架一起工作的<a class="ae kv" href="https://github.com/kripken/box2d.js" rel="noopener ugc nofollow" target="_blank">盒子2D </a>物理引擎库——创建一个包装器来执行框架步骤:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="e13d" class="ne ma iq mz b gy nf ng l nh ni">export class Box2DPhysicsEngine implements IPhysicsEngine {<br/>  step(): void {<br/>    // Box 2D physics engine world step implementation<br/>  }<br/>}</span></pre><p id="1794" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许您想与<a class="ae kv" href="https://piqnt.com/planck.js/" rel="noopener ugc nofollow" target="_blank"> Planck </a>的Box2D的类型脚本重写进行比较，Box2D也适用于您的图形框架——创建一个包装器来执行框架步骤:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="9127" class="ne ma iq mz b gy nf ng l nh ni">export class PlanckPhysicsEngine implements IPhysicsEngine {<br/>  step(): void {<br/>    // Planck physics engine world step implementation<br/>  }<br/>}</span></pre><p id="e3f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你的游戏中，从你的包装器中实例化任何物理引擎，并简单地引用帧处理器中的接口<code class="fe mw mx my mz b">step()</code>:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="da58" class="ne ma iq mz b gy nf ng l nh ni">export class GameScene {<br/>  private physicsEngine: IPhysicsEngine;<br/><br/>  constructor(physicsEngine: IPhysicsEngine) {<br/>    this.physicsEngine = physicsEngine;<br/>  }<br/><br/>  private frameHandler = () =&gt; {<br/>    this.physicsEngine.step();<br/>    requestAnimationFrame(this.frameHandler);<br/>  };<br/>}</span></pre><p id="3e90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用Box2D试试你的游戏:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="cafb" class="ne ma iq mz b gy nf ng l nh ni">const game = new GameScene(new Box2DPhysicsEngine());</span></pre><p id="05cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，用普朗克的话说:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="22ac" class="ne ma iq mz b gy nf ng l nh ni">const game = new GameScene(new PlanckPhysicsEngine());</span></pre><p id="ba72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，根据依赖组件所需的API和意识，交换核心功能可能从复杂到不可能。通过bean风格的封装来探索JEE或Spring设计模式、控制反转以及与泛型和接口一致的依赖注入将会很有趣。</p><p id="4647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如通过两个不同的3D框架构建模型——我会在以后的文章中尝试一下。</p><h1 id="1162" class="lz ma iq bd mb mc nk me mf mg nl mi mj jw nm jx ml jz nn ka mn kc no kd mp mq bi translated">降低复杂性</h1><p id="6f0a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">用类型描述连接有助于简化代码，因为它只需要特定实现步骤所需的接口。</p><p id="b98b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一个小行星风格的游戏，多边形漂浮在欧几里得空间，由笛卡尔坐标和旋转映射。也许在点击测试后多边形的边数减少了。</p><p id="e49f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将保留<code class="fe mw mx my mz b">IRenderable</code>界面，因为这些多边形会自己渲染:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="d5b0" class="ne ma iq mz b gy nf ng l nh ni">export interface IRenderable {<br/>  render(graphics: PIXI.Graphics): void;<br/>}</span></pre><p id="ed1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的形状将有2D点的位置和旋转角度，我们将定义需要边数和半径的多边形。让我们将它们定义为独立的接口。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="5408" class="ne ma iq mz b gy nf ng l nh ni">export interface IPosition {<br/>  x: number;<br/>  y: number;<br/>}</span><span id="163c" class="ne ma iq mz b gy nj ng l nh ni">export interface IRotation {<br/>  angle: number;<br/>}</span><span id="d41b" class="ne ma iq mz b gy nj ng l nh ni">export interface IPolygon {<br/>  sides: number;<br/>  radius: number;<br/>}</span></pre><p id="61b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe mw mx my mz b">Shape</code>类将实现位置和旋转，而不考虑形状是如何呈现的:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="9a81" class="ne ma iq mz b gy nf ng l nh ni">export class Shape implements IPosition, IRotation {<br/>  x: number = 0;<br/>  y: number = 0;<br/>  angle: number = 0;<br/>}</span></pre><p id="e724" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具体的<code class="fe mw mx my mz b">Polygon</code>类将继承带有接口<code class="fe mw mx my mz b">IPosition</code>的<code class="fe mw mx my mz b">Shape</code>和带有<code class="fe mw mx my mz b">IRenderable</code>实现的<code class="fe mw mx my mz b">IRotation</code>添加<code class="fe mw mx my mz b">IPolygon</code>接口:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="073e" class="ne ma iq mz b gy nf ng l nh ni">export class Polygon extends Shape implements IPolygon, IRenderable {<br/>  sides: number;<br/>  radius: number;</span><span id="883f" class="ne ma iq mz b gy nj ng l nh ni">  constructor(sides: number, radius: number) {<br/>    super();<br/>    this.sides = sides;<br/>    this.radius = radius;<br/>  }</span><span id="0143" class="ne ma iq mz b gy nj ng l nh ni">  render(graphics: PIXI.Graphics): void {<br/>    let step = (Math.PI * 2) / this.sides;<br/>    let start = (this.angle / 180) * Math.PI;<br/>    let n, dx, dy;</span><span id="72b8" class="ne ma iq mz b gy nj ng l nh ni">    graphics.moveTo(<br/>      this.x + Math.cos(start) * this.radius,<br/>      this.y - Math.sin(start) * this.radius<br/>    );</span><span id="4eda" class="ne ma iq mz b gy nj ng l nh ni">    for (n = 1; n &lt;= this.sides; ++n) {<br/>      dx = this.x + Math.cos(start + step * n) * this.radius;<br/>      dy = this.y - Math.sin(start + step * n) * this.radius;<br/>      graphics.lineTo(dx, dy);<br/>    }<br/>  }<br/>}</span></pre><p id="30ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些多边形可以实例化为:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="4753" class="ne ma iq mz b gy nf ng l nh ni">const triangle = new Polygon(3, 100);<br/>const square = new Polygon(4, 100);<br/>const pentagon = new Polygon(5, 100)<br/>const hexagon = new Polygon(6, 100);</span></pre><p id="3a51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，定义为类:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="37a3" class="ne ma iq mz b gy nf ng l nh ni">export class Triangle extends Polygon {<br/>  constructor(radius: number) {<br/>    super(3, radius);<br/>  }<br/>}</span><span id="80e1" class="ne ma iq mz b gy nj ng l nh ni">export class Square extends Polygon {<br/>  constructor(radius: number) {<br/>    super(4, radius);<br/>  }<br/>}</span><span id="a6cd" class="ne ma iq mz b gy nj ng l nh ni">export class Pentagon extends Polygon {<br/>  constructor(radius: number) {<br/>    super(5, radius);<br/>  }<br/>}</span></pre><p id="7aa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经定义了这些接口，我们可以简单地忘记所有这些复杂性，专注于特定任务所需的契约。</p><p id="b2ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的渲染管道实际上只关心<code class="fe mw mx my mz b">IRenderable</code>接口:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="b70d" class="ne ma iq mz b gy nf ng l nh ni">const shapes: IRenderable[] = [triangle, square, pentagon, hexagon];<br/>const graphics = new PIXI.Graphics();</span><span id="357c" class="ne ma iq mz b gy nj ng l nh ni">for (let shape of shapes) {<br/>  shape.render(graphics);<br/>}</span></pre><p id="9ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许在点击测试函数中我们需要计算多边形的面积——我们可以使用<code class="fe mw mx my mz b">IPolygon</code>接口来访问<code class="fe mw mx my mz b">radius</code>和<code class="fe mw mx my mz b">sides</code>的相关属性:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="a536" class="ne ma iq mz b gy nf ng l nh ni">/** Calculate area of a polygon */<br/>export const area = (polygon: IPolygon): number =&gt; {<br/>  const r = polygon.radius;<br/>  const n = polygon.sides;</span><span id="e276" class="ne ma iq mz b gy nj ng l nh ni">  return (n * Math.pow(r, 2)) / (4 * Math.tan(Math.PI / n));<br/>};<br/></span><span id="022d" class="ne ma iq mz b gy nj ng l nh ni">const polygons: IPolygon[] = [<br/>  new Triangle(100),<br/>  new Square(100),<br/>  new Pentagon(100)<br/>];</span><span id="202b" class="ne ma iq mz b gy nj ng l nh ni">for (let polygon of polygons) {<br/>  console.log(`Area: ${area(polygon)}`);<br/>}</span></pre><p id="cc17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许多边形每被击中一次，边数就减少一个，直到被摧毁。如果命中成功，<code class="fe mw mx my mz b">IPolygon</code>接口提供所需的数据:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="ee39" class="ne ma iq mz b gy nf ng l nh ni">const hit = (shape: IPolygon) =&gt; {<br/>  shape.sides -= 1;</span><span id="2b42" class="ne ma iq mz b gy nj ng l nh ni">  if (shape.sides &lt; 3) {<br/>    console.log("Enemy destroyed!");<br/>  }<br/>};</span></pre><p id="91dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许鼠标点击只需要访问形状的位置——这可以通过<code class="fe mw mx my mz b">IPosition</code>界面实现:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="7ec0" class="ne ma iq mz b gy nf ng l nh ni">export const onMouseDown = (position: IPosition) =&gt; {<br/>  console.log(position.x, position.y);<br/>};</span></pre><p id="50f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鼠标坐标与<code class="fe mw mx my mz b">IPosition</code>接口有相似的形状，能够比较鼠标事件和形状位置之间的x，y坐标。</p><p id="57d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口有助于分离逻辑，简化和增加连接代码之间契约的清晰度。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="3469" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有什么是不可能的，但可能不值得投资。</p><blockquote class="nq nr ns"><p id="0fc0" class="kw kx nt ky b kz la jr lb lc ld ju le nu lg lh li nv lk ll lm nw lo lp lq lr ij bi translated">计算机科学中的所有问题都可以通过另一种间接方式来解决。<br/>–大卫·惠勒</p></blockquote></div></div>    
</body>
</html>