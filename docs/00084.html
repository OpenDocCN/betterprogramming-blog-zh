<html>
<head>
<title>Docker Tips : Development With Nodemon</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker提示:使用Nodemon进行开发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-in-development-with-nodemon-d500366e74df?source=collection_archive---------0-----------------------#2017-12-20">https://betterprogramming.pub/docker-in-development-with-nodemon-d500366e74df?source=collection_archive---------0-----------------------#2017-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c538" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实时跟踪变化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ed6041b64d28b5515ac7d76f54fe956d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUVBmdfAefy-ZNkbSu-e9w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jefflssantos" rel="noopener ugc nofollow" target="_blank">杰佛森·桑多斯</a>在<a class="ae ky" href="https://unsplash.com/photos/V9sv7QrDUgc" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="fe98" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="5c63" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在过去的几周里，我进行了几次码头工人培训，一些问题经常出现。例如:</p><p id="b888" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">问:在开发我的应用程序时，我如何让我的更改在容器中自动生效？</em></p><p id="b173" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个问题背后的想法是，对于开发人员来说，在他/她的本地IDE (Atom、Visual Studio代码、Eclipse、VI……)中进行更改，然后在运行的应用程序中实时查看这些更改。</p><p id="9184" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通常，我会回答:</p><p id="82a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms"> R:在开发过程中，您需要在服务的容器中挂载本地源代码，并通过nodemon之类的实用程序启动主进程，它将监视文件，并在观察到一些变化时重启应用程序。</em></p><p id="daf8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我意识到这个答案值得一些额外的细节和例子。这就是这篇文章的全部内容。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="e995" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">示例应用程序</h1><p id="f10a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们考虑一下<a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>投票应用程序。这个经常用于演示和演讲。</p><p id="737a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个应用程序遵循微服务架构。如下图所示，它由5个服务组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/42781883492d0eaaaa272040c939e90d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LaLpavOVZGWNiLI_."/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker的投票应用架构(<a class="ae ky" href="https://github.com/docker/example-voting-app" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/example-voting-app</a>)</p></figure><ul class=""><li id="6e2f" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated"><strong class="lt iu">投票</strong>:使用户能够在猫和狗之间进行选择的前端</li><li id="a855" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated"><strong class="lt iu"> redis </strong>:存储选票的数据库</li><li id="d91e" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">工作人员:从redis获取投票，并将结果存储在postgres数据库中</li><li id="b60b" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">数据库:存储投票结果的postgres数据库</li><li id="455b" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated"><strong class="lt iu">结果</strong>:前端显示投票结果</li></ul><p id="e9ee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们克隆投票应用程序库:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="30f7" class="nz la it nv b gy oa ob l oc od">git clone https://github.com/dockersamples/example-voting-app</span></pre><p id="912f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们所看到的，这里定义了几个Docker编写文件。在本文中，我们将使用默认名称<code class="fe oe of og nv b">docker-compose.yml</code>。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="b985" class="nz la it nv b gy oa ob l oc od">version: "3.3"<br/><br/>services:<br/>  vote:<br/>    build: ./vote<br/>    command: python app.py<br/>    volumes:<br/>     - ./vote:/app<br/>    ports:<br/>      - "5000:80"<br/>    networks:<br/>      - front-tier<br/>      - back-tier<br/><br/>  result:<br/>    build: ./result<br/>    command: nodemon server.js<br/>    volumes:<br/>      - ./result:/app<br/>    ports:<br/>      - "5001:80"<br/>      - "5858:5858"<br/>    networks:<br/>      - front-tier<br/>      - back-tier<br/><br/>  worker:<br/>    build:<br/>      context: ./worker<br/>    depends_on:<br/>      - "redis"<br/>    networks:<br/>      - back-tier<br/><br/>  redis:<br/>    image: redis:alpine<br/>    container_name: redis<br/>    ports: ["6379"]<br/>    networks:<br/>      - back-tier<br/><br/>  db:<br/>    image: postgres:9.4<br/>    container_name: db<br/>    volumes:<br/>      - "db-data:/var/lib/postgresql/data"<br/>    networks:<br/>      - back-tier<br/><br/>volumes:<br/>  db-data:<br/><br/>networks:<br/>  front-tier:<br/>  back-tier:</span></pre><h2 id="762c" class="nz la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">结果服务上的插图</h2><p id="c82e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们仔细看看这个文件中定义<strong class="lt iu">结果</strong>服务的方式。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="cc1a" class="nz la it nv b gy oa ob l oc od">result:<br/>  build: ./result<br/>  command: nodemon server.js<br/>  volumes:<br/>    - ./result:/app<br/>  ports:<br/>    - "5001:80"<br/>    - "5858:5858"<br/>  networks:<br/>    - front-tier<br/>    - back-tier</span></pre><p id="4c95" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里有几件有趣的事情:</p><ul class=""><li id="4290" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">本地的<code class="fe oe of og nv b">result </code>文件夹被绑定到<code class="fe oe of og nv b">/app</code>文件夹中</li><li id="a57c" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">用于运行服务的命令是<code class="fe oe of og nv b">nodemon server.js</code></li></ul><h2 id="eb9b" class="nz la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">绑定安装源文件夹</h2><p id="4cee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">本地源代码，也就是我们在最喜欢的IDE中不断修改的代码，将在服务的容器中按原样提供。换句话说，我们在本地所做的每一个改变都会反映到正在运行的应用程序中。但是，如果我们希望它被应用程序考虑，这个需要重新加载。输入<a class="ae ky" href="http://nodemon.io" rel="noopener ugc nofollow" target="_blank"> <em class="ms"> nodemon </em> </a>！</p><h2 id="2f5a" class="nz la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">使用nodemon运行服务</h2><p id="ec84" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Nodemon是一款很棒的软件。看一下官方的描述。</p><blockquote class="os ot ou"><p id="3b57" class="lr ls ms lt b lu mn ju lw lx mo jx lz ov mp mc md ow mq mg mh ox mr mk ml mm im bi translated">Nodemon是一个实用程序，它将监视源代码中的任何更改，并自动重启服务器。非常适合开发。— <a class="ae ky" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank">节点门</a></p></blockquote><p id="57a2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">换句话说，这个家伙在那里监督容器中运行的主进程，如果它检测到周围文件的一些变化，就重新启动它。</p><p id="3919" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">结果</strong>服务是用<a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>开发的，所以用Nodemon而不是缺省的node命令运行它非常容易。</p><p id="cb1b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们看到的，在<code class="fe oe of og nv b">docker-compose.yml</code>文件中定义的命令覆盖了docker文件中定义的命令。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="f507" class="nz la it nv b gy oa ob l oc od">// Command instruction in the Dockerfile<br/>CMD [“node”, “server.js”]</span><span id="6dc1" class="nz la it nv b gy oy ob l oc od">// Command instruction in the docker-compose.yml file<br/>command: nodemon server.js</span></pre><p id="47df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了让nodemon对位于<code class="fe oe of og nv b">views </code>文件夹中的html文件的更改做出反应，我们将对在<code class="fe oe of og nv b">docker-compose.yml</code>文件中指定的命令做一点修改，使它看起来像下面这样。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="ca2e" class="nz la it nv b gy oa ob l oc od">// Slight modification of the command instruction<br/>command: nodemon --watch views -e js,html server.js</span></pre><p id="f2f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，为了让结果服务从nodemon开始，我们需要让它在容器中可用。将其安装在<strong class="lt iu">结果</strong>服务的Dockerfile中的指令如下。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="0b7a" class="nz la it nv b gy oa ob l oc od">RUN npm install -g nodemon</span></pre><h2 id="9092" class="nz la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">不是Node.js应用？</h2><p id="c435" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Nodemon与Node.js应用程序集成得非常好，但是如果我们使用的应用程序是用另一种语言开发的呢？</p><p id="e6ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">没问题… nodemon可以运行几种类型的应用程序。它还提供了开箱即用的几个选项来观察特定文件夹的变化，并允许提供文件扩展名。让我们在<strong class="lt iu"> vote </strong>服务上演示一下，这是一个python flask应用程序。</p><ul class=""><li id="6e20" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">首先要做的是确保nodemon在服务的映像中是可用的。为此，我们首先通过添加以下指令来更改服务的Dockerfile:</li></ul><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="ce43" class="nz la it nv b gy oa ob l oc od"># Install nodemon<br/>RUN apk update &amp;&amp; apk add nodejs &amp;&amp; npm i -g nodemon</span></pre><p id="96df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注1:由于<a class="ae ky" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine </a> 3.8，npm没有安装Node.js，需要在上面的命令中<code class="fe oe of og nv b">nodejs</code>旁边添加<code class="fe oe of og nv b">nodejsnpm </code>包。感谢Omar Quiroz指出这一点。</p><p id="d916" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意2:由于生产映像中不需要nodemon，所以添加一个基于构建参数的条件会很好；它只能安装在dev中。</p><ul class=""><li id="9ba2" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">第二件事是覆盖用于运行服务的命令，以便它使用nodemon。<strong class="lt iu">投票</strong>服务的定义可以改为:</li></ul><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="280e" class="nz la it nv b gy oa ob l oc od">services:<br/>  vote:<br/>    build: ./vote<br/>    command: nodemon --watch template --exec "python" app.py<br/>    volumes:<br/>      — ./vote:/app<br/>    ports:<br/>      — "5000:80"<br/>    networks:<br/>      — front-tier<br/>      — back-tier</span></pre><p id="3a81" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们为nodemon提供了一些额外的选项</p><ul class=""><li id="a992" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">-exec“python”:表示我们需要运行的应用程序的类型</li><li id="e888" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">-观察模板:在app.py脚本运行的顶部，我们希望观察模板文件夹中所做的更改</li></ul><p id="f6df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">也可以通过一个<em class="ms"> -e </em>标志提供我们需要监视的扩展列表。<a class="ae ky" href="https://github.com/remy/nodemon#nodemon" rel="noopener ugc nofollow" target="_blank"> nodemon文档</a>提供了可用选项的列表。</p><h2 id="4fcd" class="nz la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">让我们测试一下</h2><p id="0b87" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们现在可以构建<strong class="lt iu"> vote </strong>服务，这样我们在Dockerfile中所做的更改就会生效，然后启动应用程序。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="bc2d" class="nz la it nv b gy oa ob l oc od">$ docker-compose build vote<br/>$ docker-compose up</span></pre><p id="0e62" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">端口5000上有<strong class="lt iu">表决</strong>接口，端口5001上有<strong class="lt iu">结果</strong>接口。</p><ul class=""><li id="479f" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">修改<strong class="lt iu">投票</strong>服务的源代码</li></ul><p id="a4d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们修改选择选项，将<code class="fe oe of og nv b">app.py </code>文件中的<strong class="lt iu">猫</strong>改为<strong class="lt iu">小猫</strong></p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="4e86" class="nz la it nv b gy oa ob l oc od">option_a = os.getenv(‘OPTION_A’, “Kitten”)<br/>option_b = os.getenv(‘OPTION_B’, “Dogs”)</span></pre><p id="f0fc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以在撰写日志中观察到<strong class="lt iu">投票</strong>的自动重新加载。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="0e40" class="nz la it nv b gy oa ob l oc od">vote_1 | * Detected change in ‘/app/app.py’, reloading<br/>vote_1 | * Restarting with stat<br/>vote_1 | * Debugger is active!<br/>vote_1 | * Debugger PIN: 161–189–800</span></pre><p id="799b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">重新加载web界面显示了更改</p><div class="kj kk kl km gt ab cb"><figure class="pb kn pc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/1a97e29472cc2510bbf87d3d1703f894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*XiT9GP61Hz2mhB3mWtSCag.png"/></div></figure><figure class="pb kn pc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/01e96736243c98bf225ebddfc548e529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*TJc-89xVxQ82EXPXyfb-Fw.png"/></div></figure></div><ul class=""><li id="f3e1" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">修改<strong class="lt iu">结果</strong>服务源代码</li></ul><p id="79b2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们也修改出现在<strong class="lt iu">结果</strong>服务的web界面中的标签。那些位于<code class="fe oe of og nv b">views/index.html</code>文件中。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="1214" class="nz la it nv b gy oa ob l oc od">&lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;title&gt;<strong class="nv iu">Kitten</strong> vs Dogs -- Result&lt;/title&gt;<br/>    ...<br/>&lt;/head&gt;<br/>&lt;body ng-controller="statsCtrl" &gt;<br/>  ...<br/>  &lt;div id="content-container"&gt;<br/>    &lt;div id="content-container-center"&gt;<br/>      &lt;div id="choice"&gt;<br/>        &lt;div class="choice cats"&gt;<br/>          &lt;div class="label"&gt;<strong class="nv iu">Kitten</strong>&lt;/div&gt;<br/>          &lt;div class="stat"&gt;{{aPercent | number:1}}%&lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="divider"&gt;&lt;/div&gt;<br/>      &lt;div class="choice dogs"&gt;<br/>      &lt;div class="label"&gt;Dogs&lt;/div&gt;<br/>      &lt;div class="stat"&gt;{{bPercent | number:1}}%&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;<br/>...</span></pre><p id="f234" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以在编写日志中观察到<strong class="lt iu">结果</strong>的自动重载。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="b11a" class="nz la it nv b gy oa ob l oc od">result_1 | [nodemon] restarting due to changes…<br/>result_1 | [nodemon] starting `node server.js`</span></pre><p id="ad60" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">重新加载web界面会显示更改。</p><div class="kj kk kl km gt ab cb"><figure class="pb kn pc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/2a52e07e56e488c9c1f71bad00660a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*1WwOrZf65GFCGXPTb7iO5A.png"/></div></figure><figure class="pb kn pc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/7402b9f76ff95a631ea5a89d4b205114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*MgMEirsaxbXUzoGjKcxDvA.png"/></div></figure></div></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="b5eb" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">摘要</h1><p id="cc96" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这篇文章中，我们看到了开发人员处理源代码所需的设置，并让它自动被应用到运行在容器中的应用程序中。</p><p id="99f5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦我们对代码更改感到满意，我们就可以使用docker-compose来构建图像并将其推送到注册中心，从而触发CI管道。</p></div></div>    
</body>
</html>