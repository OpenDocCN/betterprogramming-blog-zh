# Swift 中的可扩展网络

> 原文：<https://betterprogramming.pub/scalable-routing-in-swift-d584c9ff728b>

## *用洒落的联合收割机*

![](img/a95481eb85142f552b7c3407cbd21e3a.png)

照片由[绍洛·莫哈纳](https://unsplash.com/@saulomohana?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/app?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

自从 Codables 出现以来，我们已经逐渐接近一个内置于 Foundation 的完全类型化的网络解决方案。虽然我们的模型现在是安全的，但我们的请求本身通常仍然依赖于字符串和非常手动的参数，这使我们容易出现开发人员的错误。

老实说，即使是最优秀的人也会犯错。

在一个大型项目中，大量的时间可以花在调试这些错误上，这些时间可以更好地用在新功能上。为了降低这种风险，我们需要将路线数据转换成某种类型。

我一直使用的概念是，路由器执行一个`Route`，并将结果返回给需要它的服务或视图。以下将围绕这一点展开。

首先，我需要设定一些基本目标。这些是:

*   路由器唯一关心的应该是获取一个`Route`并通过`URLSession`执行它——这里我们不会使用任何 pod。
*   路由器应该能够取出传递给它的任何 **R** oute ，并且在没有任何额外逻辑的情况下执行。
*   路由应该包含路由器可能需要的任何信息。
*   转换成代码应该是自动的和无缝的。
*   添加新路线一定很容易。
*   最后，调用路线的代码必须干净、易读，并且对使用这种方法的项目新开发人员有意义。我们不想要大量的入职时间。

# 设计路由协议

API 路由通常使用几个简单的数据位来执行。路径、查询和正文。app 想要数据的那部分并不关心这个细节，它只知道自己想要的结果。

无论是响应还是请求，正文都可以用代码来表达。有时，这些应该是空的，所以我们需要一个占位符来处理。

基本路由协议。

`method`、`path`和 auth 需求是静态变量，因为它们将被定义一次，并且不会因路线的每个实例而改变。

至于实例变量，我们只需要一个可选的带有`path`和`query`参数的`requestObject`。`requestObject`是可选的，因为`GET`请求不会有它们，所以我们允许它完全为空。我们这里没有`responseObject`，因为我们希望路由器将它返回给我们。

是一个空的可编码对象，完全作为一个占位符，告诉路由器不要对该对象做任何事情，处理任何我们不想序列化的实例。

有了这些信息，我们就有了创建请求所需的一切。

# 构建请求

`toRequest`是允许路由器代码非常少的魔法。它处理将路由转换成`URLRequest`实例的所有逻辑。我们可以将它的一个基本实现定义为`Route`的扩展。

从我们的路线生成请求。

`toRequest`方法添加了我们的路径参数、查询项，并在需要时将主体序列化到 JSON 中。

您会注意到`queryParameters`和`pathParameters`在这个扩展中有一些默认的实现。这只是为了在我们不需要这些参数的地方保持路线最少。

一些路由可能需要改变这一点，比如在它们的主体中包含媒体而不是代码，但这仅仅意味着覆盖这个方法并添加一个特定的主体代码。

现在我们已经看到了它是如何工作的，我们可以看一个从 web 获取特定待办事项的示例路由。

提取待办事项的示例路径

让我们看一下这个例子，看看我们有什么。

*   我们没有请求体，所以我们将其设置为`Empty`。
*   响应是一个单一的待办事项，所以我们将其设置为`ResponseType`。
*   我们的`method`和`path`被设置为静态变量，因为它们不会改变。
*   默认的`requestObject`需要一个可选的`RequestObject`副本，在这里是空的，所以我们只有一个可选的`Empty`。
*   我们知道我们的查询参数总是空的，所以我们只是创建一个空数组。
*   我们拥有的唯一路径参数指定了我们正在寻找的具体待办事项，因此我们使用一个局部变量`Todo`并从中获取 ID。

# 执行路线

所有的细节都被抽象出来，我们的路线也准备好了，我们需要实际执行它们。

在构造了一个`GetTodoRoute`的实例后，我们只需将它传递给路由器。

就是这样。

TodoService

你可能认为路由器代码有点乱，但是因为有了`toRequest`方法，它实际上非常易读。

在返回发布者之前，路由器处理解码和映射任何潜在的错误。如果响应类型为空，我们有一个不同的`performRequest`方法来映射错误。

链中的最后一点是真正想要`Todo`的对象。这只是要求`TodoService`得到一个待办事项，并等待响应。

还有一些事情我没有考虑，比如增加认证重试，但是这将是一个很好的可扩展的设置。

在我当前的项目中有这样的网络已经导致了新路线的更快实施，留下了更多的时间来调试 SwiftUI。初始设置后节省的时间只会随着代码库的增加而增加。

感谢阅读！