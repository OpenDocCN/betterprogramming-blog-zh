<html>
<head>
<title>Kafka With Java, Spring, and Docker — Asynchronous Communication Between Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kafka与Java、Spring和Docker——微服务之间的异步通信</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kafka-with-java-spring-and-docker-asynchronous-communication-between-microservices-e1d00e120831?source=collection_archive---------0-----------------------#2022-04-03">https://betterprogramming.pub/kafka-with-java-spring-and-docker-asynchronous-communication-between-microservices-e1d00e120831?source=collection_archive---------0-----------------------#2022-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6ea1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入解释如何使用Kafka实现java微服务之间的消息传递</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bf0c878d13c00c5aff192d21a539eca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4G_rqTu6ngtQgZ35LEtag.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰佛森·桑多斯在<a class="ae kv" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="72f2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目录</h1><ol class=""><li id="0768" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">我们将要建造的东西</li><li id="5e69" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">《果壳中的卡夫卡》</li><li id="9527" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">主题</li><li id="1c2d" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">划分</li><li id="3d1e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">设置项目</li><li id="337c" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">卡夫卡的Docker环境</li><li id="cb8b" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">生产者微服务</li><li id="f65a" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">消费者微服务</li><li id="6f77" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">高级功能</li><li id="96b1" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">结论</li></ol></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="f010" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在本文中，我们将通过开发两个spring微服务来讨论Kafka作为消息代理是如何工作的，以及如何使用它在微服务之间进行通信。</p><h1 id="299c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.我们将要建造的东西</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/2a03fe993d86783a0c286629487f8f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BsN81p7EOBf-1L2BVgTCbQ.png"/></div></div></figure><p id="1b03" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这个想法是创建一个生产者微服务，它接收要创建的食品订单，并通过Kafka将它们传递给消费者微服务，以保存在数据库中。</p><h1 id="b3c5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.《果壳中的卡夫卡》</h1><p id="6826" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv ni mz na lx nj nc nd lz nk nf ng mb ij bi translated">Kafka集群具有高度的可伸缩性和容错性，这意味着如果它的任何一台服务器出现故障，其他服务器将接管它们的工作，以确保连续运行而不会丢失任何数据。</p><p id="adf6" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">事件记录了某件事情发生的事实，携带着一条消息，这条消息可以是任何东西，例如，一个字符串、一个数组或一个JSON对象。当你向Kafka读取或写入数据时，你是以那些事件的形式完成的。</p><p id="3371" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">生产者是向卡夫卡发布(写)事件的人，消费者是订阅(读和处理)这些事件的人。</p><h1 id="8537" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.主题</h1><p id="690d" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv ni mz na lx nj nc nd lz nk nf ng mb ij bi translated">事件被组织并持久地存储在主题中。主题类似于一个文件夹，这些事件就是该文件夹中的文件。主题是多生产者和多订户的，这意味着我们可以拥有零个、一个或多个。</p><p id="117f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">事件可以根据需要多次读取，与传统的消息传递系统不同，事件在使用后不会被删除。相反，你可以定义卡夫卡应该保留这些事件多长时间。</p><h1 id="4092" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">4.划分</h1><p id="413e" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv ni mz na lx nj nc nd lz nk nf ng mb ij bi translated">主题是分区的，这意味着一个主题分布在多个桶中。当一个新事件发布到一个主题时，它实际上被附加到主题的一个分区中。具有相同事件键的事件被写入同一个分区。Kafka保证给定主题分区的任何消费者将总是以与事件被写入时完全相同的顺序读取该分区的事件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/41512a6708681532378a96c10c36ec9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*9nIXPX_2BbGRBXLENwhLOg.png"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="0220" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">为了使您的数据具有容错性和高可用性，每个主题都可以被复制，甚至可以跨区域或数据中心复制，这样，总是有多个代理拥有数据的副本，以防出现问题(它们会出现)。</p><h1 id="58d8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">5.设置项目</h1><p id="09b6" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv ni mz na lx nj nc nd lz nk nf ng mb ij bi translated">转到<a class="ae kv" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> start.spring.io </a>并创建具有以下依赖项的项目</p><p id="84b8" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">生产者微服务:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/da60dd5b29a11a81941efcb8555968d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_LU_GCYh7lo2RwjaYOcPw.png"/></div></div></figure><p id="e08b" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nn">消费者微服务</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/1387d41f3dfba928b4b15c977521a29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfulJHSIFy-N5JsSDyqWag.png"/></div></div></figure><h1 id="d985" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><em class="no"> 6。卡夫卡的Docker环境</em></h1><p id="5be7" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv ni mz na lx nj nc nd lz nk nf ng mb ij bi translated">在其中一个项目的根目录下，创建一个<code class="fe np nq nr ns b">docker-compose.yml</code>文件，包含在Docker容器中运行Kafka、Kafdrop和Zookeeper所需的配置，这并不重要。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="036e" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在其中一个项目的根文件夹中，您可以在终端docker-compose up中运行。可以在<a class="ae kv" href="http://localhost:9000." rel="noopener ugc nofollow" target="_blank"> http://localhost:9000中访问Kafdrop，这是一个管理Kafka的web界面。</a></p><p id="b8b9" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在那里你可以看到你的主题，创建它们，删除它们，等等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/47f235328f0d8c70a0c53c75229ac483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DInNL3X58OmSamKsqtcwNg.png"/></div></div></figure><h1 id="e942" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">7.生产者微服务</h1><p id="caec" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv ni mz na lx nj nc nd lz nk nf ng mb ij bi translated">建筑:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/99bc6a39d2d4e72cc5d2d41d1b3e6f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*3zEEoVGnUTlZsC3nxSLuGQ.png"/></div></figure><p id="5406" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nn">步骤</em></p><ul class=""><li id="fb05" class="lo lp iq lq b lr mu lt mw lv nx lx ny lz nz mb oa md me mf bi translated">创建配置beans</li><li id="b74f" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb oa md me mf bi translated">创建一个食品订单主题</li><li id="56a3" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb oa md me mf bi translated">创建食品订单控制器、服务和生产者</li><li id="dbcf" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb oa md me mf bi translated">将订单转换成字符串格式的消息发送给代理</li></ul><p id="2478" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">要运行的API的环境变量和端口:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a92c" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe np nq nr ns b">Config</code> <em class="nn"> — </em>负责创建用于发送消息的<code class="fe np nq nr ns b">KafkaTemplate</code> bean，并创建食品订单主题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="09f5" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这里是<code class="fe np nq nr ns b">FoodOrder</code>的模型类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8502" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe np nq nr ns b">FoodOrderController</code> <em class="nn"> — </em>负责接收食品订单请求，并将其传递给服务层。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6bb4" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe np nq nr ns b">FoodOrderService</code> <em class="nn"> — </em>负责接收食品订单并将其传递给生产商。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="dd36" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe np nq nr ns b">Producer</code><em class="nn">——</em>负责接收食品订单，并作为消息发布给卡夫卡。</p><p id="0f02" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在第18行中，我们将<code class="fe np nq nr ns b">FoodOrder</code>对象转换成JSON格式的字符串，这样它就可以作为一个字符串在消费者微服务中被接收。</p><p id="13a4" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在第19行中，我们实际上发送了消息，将发布的主题(在第6行中称为环境变量)和订单作为消息传递。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="98be" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">运行应用程序时，我们应该能够看到在Kafdrop中创建的主题。当发送食品订单时，我们应该能够在日志中看到消息已被发送。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/38a6a79827136e295594068fe4e92137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEPdKbRKU_bLAw1ufdHaXg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/53913dec6594355b57c3091daf3b12fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*de-jms0X202691A9KB1ZYw.png"/></div></figure><p id="fbe2" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在，如果我们在Kafdrop中的<code class="fe np nq nr ns b">Topics</code> <strong class="lq ir"> </strong>部分下访问创建的t.food.order主题，我们应该能够看到该消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/f0fd1094c20f5b3aaf3bae4281b4ac39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*lDolPXpvSoOmHoZd19Qjrg.png"/></div></figure><h1 id="3d57" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">8.消费者微服务</h1><p id="490f" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv ni mz na lx nj nc nd lz nk nf ng mb ij bi translated">建筑:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c59fe7cd354b2771e23ef7709033b902.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*UhpG6vIHrLGIuB1Gi9Q2OQ.png"/></div></figure><p id="4aa4" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nn">步骤</em></p><ul class=""><li id="0998" class="lo lp iq lq b lr mu lt mw lv nx lx ny lz nz mb oa md me mf bi translated">为beans和组id创建配置</li><li id="f846" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb oa md me mf bi translated">创建数据库访问</li><li id="a800" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb oa md me mf bi translated">创建食品订单消费者和服务</li><li id="9dc3" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb oa md me mf bi translated">创建一个食物存取库</li></ul><p id="f509" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们将开始配置API运行的端口、要监听的主题、消费者的组id以及数据库配置</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="21f9" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe np nq nr ns b">Config</code> <em class="nn"> — </em>负责配置<code class="fe np nq nr ns b">ModelMapper</code> bean，这是一个库，用于将一个对象映射到另一个对象，例如，当使用DTO模式时，我们将在这里使用它</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1b7f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">以下是模型类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="127e" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe np nq nr ns b">Consumer</code> <em class="nn"> — </em>负责监听点餐话题，当有消息发布给它时，就消费它。我们将把监听到的消息转换成一个<code class="fe np nq nr ns b"><strong class="lq ir">FoodOrderDto</strong></code> <strong class="lq ir"> </strong>对象，该对象不包含与将被持久化的实体相关的所有内容，比如ID。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="dcc9" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe np nq nr ns b">FoodOrderService</code> <em class="nn"> — </em>负责将消费后的订单接收到<code class="fe np nq nr ns b">FoodOrder</code> <strong class="lq ir"> </strong>对象中，并传递给持久层进行持久化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="759e" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe np nq nr ns b">FoodOrderRepository</code>的代码是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="4d5a" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在只需运行消费者微服务，就可以从订单主题中消费已经发布的消息</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6f0fb262e0af736ecd0d6b143c1e3a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*ZTAlMh-1fZIcHZ_5yjwlYw.png"/></div></figure><p id="2f94" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这里需要注意的一个重要细节是，如果我们去Kafdrop并检查我们刚刚消费的消息，它仍然会在那里。举例来说，这是RabbitMQ不会发生的事情。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5f8372371d885854ce3afd7403dc0009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*TE0aGuUjezMYdDrlaFASRA.png"/></div></figure><h1 id="126d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">9.高级功能</h1><p id="0dda" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv ni mz na lx nj nc nd lz nk nf ng mb ij bi translated">我们可以通过使用调度来发送预定的消息。</p><p id="7c43" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">通过在生产者微服务的配置类中添加<code class="fe np nq nr ns b">@EnableScheduling</code>注释来启用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4386" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe np nq nr ns b">Scheduler</code> <em class="nn">是</em>负责以一定的速率发送消息，我们将以1000毫秒的固定速率发送它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ebdc" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">主题将被自动创建，但是我们可以像前面定义的那样定义bean。</p><p id="de83" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">输出将是</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/eeb91b194dba156a2e1052bb388721ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*Ugw_bvMdDw3GpewKqvwQ3w.png"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="152c" class="kw kx iq bd ky kz oi lb lc ld oj lf lg jw ok jx li jz ol ka lk kc om kd lm ln bi translated">10.结论</h1><p id="4597" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv ni mz na lx nj nc nd lz nk nf ng mb ij bi translated">这里的主要思想是介绍如何将Kafka与Java和Spring结合使用，这样您就可以在更复杂的系统中实现这个解决方案。</p><p id="bf1d" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">如果这篇文章对你有所帮助，可以考虑为它鼓掌，关注我并分享它。</p><p id="84a8" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">GitHub上的项目可以在这里找到<a class="ae kv" href="https://github.com/pedroluiznogueira/medium-microservices-kafka" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="49f9" class="on kx iq bd ky oo op dn lc oq or dp lg lv os ot li lx ou ov lk lz ow ox lm oy bi translated"><strong class="ak">参考文献</strong></h2><ol class=""><li id="33a4" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><a class="ae kv" href="https://kafka.apache.org/documentation" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡文档</a></li><li id="72ea" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://www.confluent.io/resources/kafka-the-definitive-guide/" rel="noopener ugc nofollow" target="_blank">卡夫卡权威指南</a>，奥赖利</li><li id="e825" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://link.springer.com/referenceworkentry/10.1007/978-3-319-63962-8_196-1" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡</a>，马蒂亚斯萨克斯</li></ol></div></div>    
</body>
</html>