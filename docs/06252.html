<html>
<head>
<title>TypeScript — Into the Unknown</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿——进入未知领域</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-into-the-unknown-4c19d913cb15?source=collection_archive---------12-----------------------#2020-09-14">https://betterprogramming.pub/typescript-into-the-unknown-4c19d913cb15?source=collection_archive---------12-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="96ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">未知类型介绍:更好的任何</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d289f1bbec5c922958b15c42a31cda38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T-2K8evAwtgZfmbm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼古拉斯·洛沃斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="123e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">世界各地的TypeScript代码到处都是<code class="fe lv lw lx ly b">any</code>类型，这让我简直要疯了。没有(有效的)理由在应用程序代码中使用它，并且您选择了静态类型系统的安全性。</p><p id="61fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多新手(或者对TypeScript不太陌生的)开发人员认为，当你不知道你将得到什么类型时，你应该用<code class="fe lv lw lx ly b">any</code>来键入它。<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html" rel="noopener ugc nofollow" target="_blank"> TypeScript的官方文档</a>也告诉你事实并非如此:</p><blockquote class="lz ma mb"><p id="62ed" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">“除非您正在将JavaScript项目迁移到TypeScript，否则不要使用<code class="fe lv lw lx ly b">any</code>作为类型。编译器有效地将<code class="fe lv lw lx ly b">any</code>视为“请关闭这个东西的类型检查”。这类似于在变量的每个用法周围加上一个<code class="fe lv lw lx ly b">@ts-ignore</code>注释。当您第一次将JavaScript项目迁移到TypeScript时，这非常有用，因为您可以将尚未迁移的内容的类型设置为<code class="fe lv lw lx ly b">any</code>，但是在完整的TypeScript项目中，您将对程序中使用它的任何部分禁用类型检查。”</p></blockquote><p id="37f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非您正在向开源JavaScript库添加类型定义，<em class="mc">不要使用</em>。如果你正在维护一个开源的JS库，那么我很感激你添加类型定义，并且理解你的时间限制。如果到处添加一个<code class="fe lv lw lx ly b">any</code>允许你在90%的API中添加类型，那么我认为这是一个有效的用例。希望有一天时间允许的时候都重构到<code class="fe lv lw lx ly b">unknown</code>。理想情况下，TypeScript社区的成员可以制作PRs并帮助您重构它们。</p><p id="f4ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我想接受任何东西或者不知道我会得到什么类型的东西怎么办？再次，<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#any" rel="noopener ugc nofollow" target="_blank"> TypeScript的文档</a>提供了帮助:</p><blockquote class="lz ma mb"><p id="eea6" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">“在你不知道你想要接受什么类型的情况下，或者当你想要接受任何东西，因为你将盲目地通过它而不与它交互时，你可以使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.typescriptlang.org/play/#example/unknown-and-never" rel="noopener ugc nofollow" target="_blank">unknown</a></code>。”</p></blockquote></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="3744" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">未知类型</h1><p id="d3f5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在TypeScript 3.0中，我们得到了<code class="fe lv lw lx ly b">unknown</code>类型，这让我们发出信号“这可以是任何值，所以在使用它之前，您<em class="mc">必须</em>执行一些类型检查。”与<code class="fe lv lw lx ly b">any</code>不同，您不能访问类型为<code class="fe lv lw lx ly b">unknown</code>的值的任何属性，也不能调用/构造它们。<code class="fe lv lw lx ly b">unknown</code>迫使我们安全地反思返回值。</p><h2 id="3353" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">简单的例子</h2><p id="8d4d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">您可以看到一个<code class="fe lv lw lx ly b">any</code>完全忽略类型检查器的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，如果我们将它输入为<code class="fe lv lw lx ly b">unknown</code>，我们确实会得到一个错误——尽管这个错误会让很多人感到困惑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="47d0" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">对象属于未知类型</h2><p id="5c45" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这个错误迷惑了很多人。与许多有用的TypeScript消息不同，这条消息并没有真正解释问题是什么(除非你理解<code class="fe lv lw lx ly b">unknown</code>类型)。早些时候，我提到过<code class="fe lv lw lx ly b">unknown</code>的一个更微妙的特性，在浏览文档时很容易被忽略:您不能访问类型为<code class="fe lv lw lx ly b">unknown</code>的值的任何属性。</p><p id="7019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript使我们将宽类型(<code class="fe lv lw lx ly b">unknown</code>)的范围缩小到更窄的类型。通常，您会希望做如下事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="3219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，虽然这段代码非常安全，但TypeScript(目前)不能用<code class="fe lv lw lx ly b">foo</code>扩展<code class="fe lv lw lx ly b">unknownFoo.prop2</code>的类型，尽管它是检查属性是否存在的有效保护子句。</p><p id="c030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多人被困在这里，放弃了。就个人而言，我很乐意花很多时间来解决这个问题。如果我们不能在大多数情况下使用它，那么这种新类型还有什么意义呢？我们需要创建一个小助手函数来获得正确的类型。以下要点显示了我们需要的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="7624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用上面的帮助器，我们将获得完全类型安全:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="7eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等……什么？怎么会？</p><p id="2c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的小实用函数利用了TypeScript中的<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>和<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates" rel="noopener ugc nofollow" target="_blank">类型谓词</a>的能力。</p><p id="020a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">泛型是这部分:<code class="fe lv lw lx ly b">&lt;X extends {}, Y extends PropertyKey&gt;</code>。我们希望确保第一个参数扩展了对象类型<code class="fe lv lw lx ly b">{}</code>，第二个参数扩展了<code class="fe lv lw lx ly b">PropertyKey</code>类型。<code class="fe lv lw lx ly b">PropertyKey</code>是<code class="fe lv lw lx ly b">Union</code>类型的字符串、数字和符号的内置别名。基本上，一个JS映射中有效的键类型:<code class="fe lv lw lx ly b">type PropertyKey = string | number | symbol</code>。</p><p id="87a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型谓词在TypeScript中非常强大，可以有条件地缩小类型范围。基本思想是，如果函数谓词返回<code class="fe lv lw lx ly b">true</code>，就将参数重新键入一个新类型。</p><p id="de95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，谓词是<code class="fe lv lw lx ly b">Object.hasOwnProperty.call(obj, prop)</code>。谓词只是布尔条件的一个花哨名称。基本上，如果我们的对象有这个属性，我们返回<code class="fe lv lw lx ly b">true</code>，它告诉类型谓词重新键入我们的值。</p><p id="a6a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的最后一块拼图是<code class="fe lv lw lx ly b">obj is X &amp; Record&lt;Y, unknown&gt;</code>。如果谓词返回<code class="fe lv lw lx ly b">true</code>，这是重新类型化我们的参数的部分。它说<code class="fe lv lw lx ly b">obj</code>(我们的第一个参数是<code class="fe lv lw lx ly b">hasOwnProperty</code> ) <em class="mc">是</em>(强制类型重铸)<code class="fe lv lw lx ly b">X &amp; Record&lt;Y, unknown&gt;</code>(我们的新类型)。</p><p id="16cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">X &amp; Record&lt;Y, unknown&gt;</code>只是一个<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types" rel="noopener ugc nofollow" target="_blank">交集类型</a>。它说它的<code class="fe lv lw lx ly b">X</code>与键<code class="fe lv lw lx ly b">Y </code>和值<code class="fe lv lw lx ly b">unknown</code>的<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeystype" rel="noopener ugc nofollow" target="_blank">记录</a>合并在一起。记录类型是TypeScript中的实用工具类型。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="dea7" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">野外不为人知</h1><p id="39d7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">unknown</code>一般发生在API边界的野外。我实在想不出有哪种情况是你不会在内部知道数据类型的。出于这个原因，我不太喜欢你看到的很多基本例子，比如这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="bd32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我认为上面的例子很好地强调了我们需要如何缩小类型范围来访问一个<code class="fe lv lw lx ly b">unknown</code>类型的属性，但是很难想象在现实生活中你会在哪里看到这种情况。</p><p id="1bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用<code class="fe lv lw lx ly b">unknown</code>的大多数情况是在API边界，它通常是在<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeystype" rel="noopener ugc nofollow" target="_blank">Record</a></code>实用程序类型中，看起来像这样:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="8d80" class="nk mo it ly b gy oc od l oe of"><em class="mc">const </em>parameterBag: <em class="mc">Record</em>&lt;<em class="mc">PropertyKey</em>, <em class="mc">unknown</em>&gt; = {<br/>  param1: 1,<br/>  param2: { foo: 'bar ' },<br/>  param3: 'Hello, World!',<br/>};</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="00dc" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">包扎</h1><p id="48cc" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">关于添加<code class="fe lv lw lx ly b">unknown</code>类型的最大抱怨之一是它使代码冗长且难以编写。对此，我唯一的回答是“这才是重点！”它的全部意义在于强迫你处理一个<code class="fe lv lw lx ly b">unknown</code> <strong class="lb iu"> <em class="mc"> </em> </strong>类型的每一种可能的情况。这自然会是一个冗长的过程。如果你的数据类型不是真正的<code class="fe lv lw lx ly b">unknown</code>，那么就不要这样输入。</p><p id="9b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免<code class="fe lv lw lx ly b">any</code>的危险，我建议使用eslint规则来纠正显式<code class="fe lv lw lx ly b">any</code>的使用错误，同时将<code class="fe lv lw lx ly b">tsconfig</code>改为隐式<code class="fe lv lw lx ly b">any</code>类型的错误。</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="32c3" class="nk mo it ly b gy oc od l oe of">//eslintrc.json<br/>"@typescript-eslint/no-explicit-any": ["error", {}],</span><span id="bfb7" class="nk mo it ly b gy og od l oe of">// tsconfig.json<br/>"noImplicitAny": true,</span></pre></div></div>    
</body>
</html>