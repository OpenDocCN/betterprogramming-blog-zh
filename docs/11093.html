<html>
<head>
<title>Deploy Microservices With Helm Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用舵操作员部署微服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deploy-microservices-with-helm-operators-a67e39b81765?source=collection_archive---------6-----------------------#2022-02-17">https://betterprogramming.pub/deploy-microservices-with-helm-operators-a67e39b81765?source=collection_archive---------6-----------------------#2022-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f429" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">库伯内特斯</h2><div class=""/><div class=""><h2 id="a700" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用helm operators通过单一Helm图表管理和部署您的微服务</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6b995a59ffd546350f9411510adf6dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vpe8t4awlV5aWPIL"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">德里克·欧文斯在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="c061" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated"><strong class="ak">简介</strong></h1><p id="2bd3" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">微服务架构是当今的一种趋势，许多公司都采用这种架构来构建和管理他们的服务。此外，工程师们更喜欢这种架构而不是单片架构，原因有几个，比如职责分离和遵循这种模式开发软件应用程序所获得的更高的可维护性。然而，每种架构都有其缺点和挑战。以下是微服务架构面临的三大挑战:</p><ul class=""><li id="254b" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">跟踪请求:单个应用程序通常在整体架构上处理传入的请求，这使得通过跟踪应用程序日志来跟踪请求变得很容易。另一方面，在微服务架构中，多个服务可能会对单个请求的响应做出贡献。因此，单个请求的日志将跨越几个应用程序，因此需要关联来自不同服务的请求日志。</li><li id="c297" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">管理共享源代码:尽管项目或用于开发服务的编程语言不同，微服务在大多数情况下共享相同的基本功能。例如，每个服务都需要写日志消息，为其API端点提供健康检查，以及许多其他功能。在服务级别上开发这些功能非常耗时，并且会在服务之间引入不一致性。维护共享代码的更好方法是尽可能使用库。</li><li id="31f4" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">部署配置和管道:很明显，部署遵循微服务架构的软件比部署单一应用程序更复杂，因为它涉及部署几个可能相互依赖的服务。</li></ul><h1 id="e337" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated"><strong class="ak">问题</strong></h1><p id="dece" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">将服务部署到Kubernetes集群需要为每个托管服务定义资源。以下是在Kubernetes中部署服务所需的一些资源列表:</p><ul class=""><li id="35b4" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">部署</li><li id="01c1" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">进入</li><li id="0270" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">配置映射</li><li id="fc0c" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">秘密</li></ul><p id="6483" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">逐个创建这些资源是一项耗时且容易出错的任务。这就是为什么我们有一个叫做<a class="ae lh" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>的工具，一个运行在Kubernetes上的服务的包管理器。Helm使我们能够用一个命令将一个应用程序部署到Kubernetes，而无需为该应用程序创建所有需要的Kubernetes资源。然而，假设您有几个服务(微服务架构就是这种情况)。在这种情况下，您需要为每个应用程序定义一个掌舵图，这将为部署服务和管理掌舵图带来大量工作，原因如下:</p><ul class=""><li id="9e3b" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">每个军种都需要自己的舵轮图。</li><li id="0fa7" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">更新标准部署配置可能会导致触及每一个图表。</li><li id="bf83" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">如果多个团队维护舵图，舵图可能会不一致，并且不遵循任何标准。</li></ul><h1 id="4335" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated"><strong class="ak">可用选项</strong></h1><p id="4bc1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">为了解决上面提到的问题，我们有几个可以遵循的选项:</p><ul class=""><li id="6d97" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">使用CICD工具，如<a class="ae lh" href="https://argo-cd.readthedocs.io/en" rel="noopener ugc nofollow" target="_blank"> Argo CD </a>来管理Kubernetes资源和部署。</li><li id="630f" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">构建一个部署工具来生成Kubernetes资源，并将它们部署到集群中。</li><li id="10cd" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">使用Helm操作员来管理和部署服务。</li></ul><p id="57ff" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">这篇博文将带你一步一步地构建一个可以部署多个微服务的Helm operator。</p><h1 id="c3c3" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated"><strong class="ak">建造舵操作员</strong></h1><p id="866b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><a class="ae lh" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank"> Kubernetes operators </a>是在Kubernetes集群中运行的软件应用程序，管理定制Kubernetes资源的生命周期。市场上有几种框架可以用来构建Kubernetes控制器，例如:</p><ul class=""><li id="8b3e" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated"><a class="ae lh" href="https://juju.is/" rel="noopener ugc nofollow" target="_blank">迷倒算子框架</a></li><li id="d616" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><a class="ae lh" href="https://book.kubebuilder.io/" rel="noopener ugc nofollow" target="_blank"> kubebuilder </a></li><li id="b915" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><a class="ae lh" href="https://buehler.github.io/dotnet-operator-sdk/" rel="noopener ugc nofollow" target="_blank"> KubeOps </a>(。网络运营商SDK)</li><li id="1ef8" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><a class="ae lh" href="https://kudo.dev/" rel="noopener ugc nofollow" target="_blank"> KUDO </a> (Kubernetes通用声明运算符)</li><li id="800d" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><a class="ae lh" href="https://metacontroller.github.io/metacontroller/intro.html" rel="noopener ugc nofollow" target="_blank">元控制器</a></li><li id="ed0f" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><a class="ae lh" href="https://operatorframework.io/" rel="noopener ugc nofollow" target="_blank">运营商框架</a></li></ul><p id="8257" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">构建Kubernetes操作符的最佳框架之一是<a class="ae lh" href="https://operatorframework.io/" rel="noopener ugc nofollow" target="_blank">操作符框架</a>。该框架使我们能够使用如下所述的三种不同方法来开发运算符:</p><ul class=""><li id="5b22" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">使用Go编程语言。</li><li id="6f48" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">使用Ansible</li><li id="13b2" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">使用舵图。</li></ul><p id="9c8a" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">与使用Go编程语言或其他框架开发Kubernetes操作符相比，使用舵图构建Kubernetes操作符是一项简单的任务。并且可以减少开发和维护Kubernetes操作符所需的工作。</p><p id="5e8e" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><a class="ae lh" href="https://operatorframework.io/" rel="noopener ugc nofollow" target="_blank">操作符框架</a>使我们能够创建Kubernetes操作符进行管理，只需定义一个部署和管理应用资源的掌舵图。构建操作符不需要额外的开发。本节将逐步引导您创建一个Helm图表，并基于该图表生成一个Kubernetes操作符。</p><p id="ad5e" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">在我们开始构建Kubernetes操作符之前，确保您有以下需求:</p><ul class=""><li id="86f7" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">拥有Kubernetes集群的集群管理权限的用户。</li><li id="8e46" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">一个可访问的图像注册表，如hub.docker.com<a class="ae lh" href="https://hub.docker.com/signup" rel="noopener ugc nofollow" target="_blank"/>。</li></ul><p id="81b9" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">一旦设置了上述要求，就可以继续执行以下步骤来构建操作符:</p><p id="27b8" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">首先，您需要在您的机器上安装<code class="fe np nq nr ns b">operator-sdk</code>命令行。您可以使用下面的命令在macOS上安装它</p><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="beb2" class="nx lj it ns b gy ny nz l oa ob">$&gt; <!-- -->brew install operator-sdk</span></pre><p id="8810" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">如果您使用其他操作系统，请查看本页中的<a class="ae lh" href="https://sdk.operatorframework.io/docs/installation/" rel="noopener ugc nofollow" target="_blank">了解安装说明。</a></p><p id="f148" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">接下来，我们需要为我们的操作员创建一个舵图。如果您已经有一个现有的舵图表，并希望基于它创建一个操作符，您可以跳过这一步。下面的命令将使用舵命令行创建一个新的舵图表。Helm chart将管理以下Kubernetes资源。</p><ul class=""><li id="0d44" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated"><strong class="mc jd"> ServiceAccount </strong>:定义部署使用的服务账户。</li><li id="77e6" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><strong class="mc jd">部署</strong>:定义一个Nginx部署对象。</li><li id="f5aa" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><strong class="mc jd">服务</strong>:定义一个服务对象来访问Nginx pods。</li><li id="e32f" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><strong class="mc jd"> Ingress </strong>:定义Ingress对象来公开Nginx服务。</li><li id="1bc3" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><code class="fe np nq nr ns b">HorizontalPodAutoscaler</code>:根据RAM和CPU资源水平扩展Nginx pods。</li></ul><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="b466" class="nx lj it ns b gy ny nz l oa ob">$&gt; mkdir microservice-operator &amp;&amp; cd microservice-operator<br/>$&gt; helm create microservice</span></pre><p id="4408" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">然后，使用以下命令初始化操作符(如果需要，替换域和项目标志):</p><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="11d3" class="nx lj it ns b gy ny nz l oa ob">$&gt; operator-sdk init --plugins=helm --domain wshihadeh.dev \<br/>   --project-name microservice-operator</span></pre><p id="5a7a" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">上面的命令将在本地创建一堆文件，下面是对其中最重要的文件的简要描述</p><ul class=""><li id="a7b2" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">Dockerfile:操作符dockerfile。</li><li id="01d2" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">Makefile:提供了一组用于管理操作者生命周期的命令，比如构建Docker映像和推送它。</li><li id="0428" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">Config:该文件夹包含部署操作员所需的所有Kubernetes资源。</li><li id="af8a" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">舵图:包含由操作员管理的舵图。</li></ul><p id="5fa3" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">接下来，使用下面的命令为操作员创建API资源(确保更新组、版本和舵图标志):</p><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="0cb6" class="nx lj it ns b gy ny nz l oa ob">$&gt; operator-sdk create api --group=deployments --version=v1 \<br/>   --helm-chart=./microservice</span></pre><p id="3e5b" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">现在，我们为操作员生成了所需的文件。我们可以为操作者构建docker映像，并使用下面的命令将其推送到注册中心。</p><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="f50f" class="nx lj it ns b gy ny nz l oa ob">$&gt; <!-- -->make docker-build docker-push \<br/>   IMG<strong class="ns jd">=</strong>"wshihadeh/<!-- -->microservice-operator<!-- -->:v0.1"</span></pre><p id="7c21" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">接下来，将操作员CRDs安装到<code class="fe np nq nr ns b">~/.kube/config</code>中指定的K8s集群中。</p><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="d831" class="nx lj it ns b gy ny nz l oa ob">$&gt; make install</span></pre><p id="406e" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">然后，将操作员部署到<code class="fe np nq nr ns b">~/.kube/config</code>中指定的K8s集群..</p><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="2619" class="nx lj it ns b gy ny nz l oa ob">$&gt; make deploy IMG=wshihadeh/microservice-operator:v0.1</span></pre><p id="5488" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">在这个阶段，操作员应该在Kubernetes集群中启动并运行，并准备好管理定制资源。您可以使用以下命令来验证安装过程:</p><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="2a3b" class="nx lj it ns b gy ny nz l oa ob">$&gt; kubectl get ns | grep microservice-operator-system<br/>$&gt; kubectl -n  microservice-operator-system get pods</span></pre><p id="1e41" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">最后，您可以使用Kubernetes <code class="fe np nq nr ns b">apply</code>命令开始向Kubernetes部署资源。您可以在目录<code class="fe np nq nr ns b">config/samples</code>下找到一个资源示例，您可以如下所示部署它:</p><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="206f" class="nx lj it ns b gy ny nz l oa ob">$&gt; kubectl apply -f config/samples/deployments_v1_microservice.yaml</span></pre><p id="737b" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">一旦您使用上面的命令创建了新的资源，运行的操作员将在集群上安装该版本。您可以使用以下命令之一来验证安装过程:</p><pre class="ks kt ku kv gt nt ns nu nv aw nw bi"><span id="a64a" class="nx lj it ns b gy ny nz l oa ob">$&gt; kubectl get pods<br/>$&gt; kubectl -n microservice-operator-system \<br/>   logs -f $conatiner manager</span></pre><h1 id="7ce8" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated"><strong class="ak">好处和限制</strong></h1><p id="be4b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">使用<a class="ae lh" href="https://operatorframework.io/" rel="noopener ugc nofollow" target="_blank">操作符框架</a>基于舵图构建Kubernetes操作符有以下好处</p><ul class=""><li id="27b9" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">开发很容易，因为它只涉及更新舵图，只需要标准的Kubernetes配置知识。</li><li id="48f8" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">使用CICD管道可以自动构建和部署操作符。</li></ul><p id="6286" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">另一方面，使用Helm和<a class="ae lh" href="https://operatorframework.io/" rel="noopener ugc nofollow" target="_blank">操作符框架</a>开发操作符的缺点是:</p><ul class=""><li id="4d42" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">操作员功能仅限于Helm中可用的功能和特性。</li></ul><h1 id="197b" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated"><strong class="ak">结论</strong></h1><p id="8222" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">管理实现微服务器架构的软件可能是一项复杂的任务，尤其是如果需要为每个服务单独完成几项例行任务。管理Kubernetes服务可能是复杂的任务之一。您可以使用Helm和Operator Framework快速构建一个安装和管理微服务的Kubernetes操作员。<a class="ae lh" href="https://operatorframework.io/" rel="noopener ugc nofollow" target="_blank">操作框架</a>允许我们将舵图转换为基于舵图模板部署资源的软件。</p></div></div>    
</body>
</html>