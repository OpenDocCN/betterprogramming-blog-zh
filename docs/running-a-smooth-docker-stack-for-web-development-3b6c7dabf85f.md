# 为 Web 开发运行一个平滑的 Docker 栈

> 原文：<https://betterprogramming.pub/running-a-smooth-docker-stack-for-web-development-3b6c7dabf85f>

## 一个关于分配容器相互通信和运行日常脚本的教程

![](img/a9ac8c0b74341ea71fc2bbd5993b0ebb.png)

由 [chuttersnap](https://unsplash.com/@chuttersnap?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

毫无疑问，Docker 是在云中构建、共享和运行应用程序的最佳方式。一旦配置好基础设施，您就可以在每个云提供商上运行。速度也快得惊人。难怪每个人都对这项技术着迷，并使用它来支持他们的关键业务服务。

想必你也听说过，并读到过，团队在他们的开发过程中使用 Docker。您可以启动并运行任何项目，而不必担心安装不同(或特定)版本的软件语言或您可能需要的任何其他依赖项。您只需简单地`docker-compose up`所有的服务/依赖项就会产生并准备好使用。一切都在一个孤立的容器中运行。

我使用 Docker 进行开发已经有两年多的时间了，我想和你分享一些技巧，让你在使用 Docker 时更加顺畅。但是在我把所有的知识转储给你之前，我们将慢慢开始，通过把我的最终实现的路径分解成小的部分，所以你能理解我的决定来自哪里。

我们开始吧，好吗？

*注意:所有的例子都是面向 web 开发的，但是我认为你可以根据你的具体情况进行推断。*

# 第一部分:伟大的档案意味着伟大的责任

如果您正在寻找 Docker 或 Dockerfiles 的介绍，我们不打算在这里讨论它。相反，我建议查看官方[文档](https://docs.docker.com/engine/reference/builder/)以获得关于它的深入信息。但是，我要告诉你的是:Dockerfiles 包含额外的命令(步骤),调用这些命令可以将 Docker 映像与配置、依赖项和运行容器可能需要的其他东西组装在一起。但是，您应该尽可能长时间地避免使用它们。

这并不是因为这些文件很复杂，而是因为一旦创建了 Dockerfile 文件，您就要负责管理特定的图像定义。这不是一个你可以轻易做出的决定。Dockerfiles 和其他同类系统一样，需要不时地重新访问和更新，因为，例如，您添加的库可能有新版本。

为了避免这种责任，你应该首先在 [Docker Hub](https://hub.docker.com/) 上查看官方图片！让其他人去担心依赖管理和更新。你想用你的时间来产生价值，而不是担心依赖版本过时，甚至是担心那些依赖上的漏洞。Docker Hub 有很多图片供你使用。它不仅有许多由社区成员创建的图像，还包含由开发底层依赖项的公司和团体支持的官方图像。例如，你可以找到 NGINX、PHP、Composer、Yarn、NodeJS 等的官方图片。

但是，对于那些必须创建的情况，尽量少用它。下一节将向您展示如何操作。

## 明智地选择基础图像

docker 文件要求您定义一个基础映像来应用您的更改。这可以是一个 OS 版本(Ubuntu 19.10，Debian 9，Fedora，Mint 等。)或者已经安装了依赖项的镜像(PHP 7.3，NGINX，MySQL 等。)具有底层操作系统定义和运行该依赖项所需的所有配置。

例如，当创建一个 PHP Dockerfile 文件时，我会尽量使用我的情况所需要的最新的、稳定的版本。因此，假设我需要使用 PHP 7.2 (CLI)，我将用以下代码开始我的 Dockerfile 文件:

```
FROM php:7.2-cli
```

从现在开始，我添加的每个命令都将在这个 PHP 7.2 映像上运行，并且所有必需的依赖项都将顺利运行。

通过使用已经拥有我所需要的几乎所有东西的基础映像，我限制了我的责任。我不必担心安装 PHP 的多个命令，也不必担心管理或更新它。如果碰巧有基础映像的新版本，我所要做的就是运行 docker build 命令来获取所有与基础映像直接相关的可用更新。

## 尽可能多地压缩命令

要执行命令，在定义基础映像后使用`RUN`指令。这会在编译最终映像时，在映像构建过程中运行给定的命令，并对应于一个层。每一层在执行时都被缓存。这防止了`docker build`进程在您每次执行命令时都运行每个命令，节省了您(有时是大量)的计算时间。

因此，如果每个`RUN`指令都可以对应一个缓存层，那么为了加快编译速度，使用尽可能少的指令应该是有意义的。嗯，没那么快！您需要小心使用它，因为每次您更改语句时，构建过程都会重新执行整个修改过的`RUN`指令，即使您只更改了参数的顺序。因此，如果你有一个“大的”`RUN`命令，并改变它，缓存是无效的，你必须等待，直到它完成所有的工作定义在修改后的`RUN`指令和每一个。

为了避免这个问题，你必须在`RUN`指令的数量和每个指令的工作量之间找到一个平衡点。我倾向于把矿分成三个部分:包安装，包配置和包激活。

## 节食保持你的形象

使用 Docker 的目的是将依赖性降到最低，并与您的主机计算机分离。然而，这种思路不仅适用于容器。它应该被应用到你的 docker 文件中，至少是关于保持依赖性最小化的部分。图像是 Docker 设置中非常重要的一部分:没有图像，就没有容器！它们是一个整体的两个部分:你的图像越大，容器就越大。

请记住，您的主机和容器唯一共享的是内核。您安装或复制到您的映像上的所有内容都会增加到其最终大小。每一个带有包安装命令(`apt-get install`或`apk install`)的`RUN`指令都将被保存在映像上。如果你不小心，你的形象会很快变得非常沉重。你甚至可能没有安装那么多东西，仍然可以看到你的图像达到 1gb 或更多。

造成这种情况的主要原因之一是软件包管理器的缓存系统。你看，当你必须安装软件时，通常需要运行`apt-get update`(假设你运行 Ubuntu 作为基础映像)，然后运行命令安装你需要的软件。这是因为`apt-get update`负责下载所有软件包的信息列表，该列表在操作系统上注册的每个存储库中都可用。该列表包含软件所在的存储库，以便软件包管理器可以下载并安装它。真正的问题是，下载这些信息后，它们会被缓存起来。

如果您在您的主机上运行以避免每次尝试更新系统时都必须下载信息，那么这种行为是受欢迎的，但是在 Docker 映像的上下文中，这是没有用的！在你安装了你需要的软件后，缓存只占用了宝贵的空间，因为它不需要运行已经安装的软件。通过删除缓存信息，您可以节省大量空间。

# 第二部分。容器和网络

联网可能很棘手，但是您必须对容器如何联网有一个大致的了解。如果你正在寻找一个介绍，我再次建议你看一下官方的[文档](https://docs.docker.com/network/)以获得更深入的信息。

当你通过`docker run`生成一个容器时，你可以通过添加`--network={your-network-name-here}`(或者快捷方式`-n`)来定义一个网络。这将配置指定网络对此新容器的访问。这意味着该容器将可以访问所有其他也可以连接到同一网络的容器。但是，如果您在没有定义显式网络的情况下生成一个容器呢？嗯，有人可能会认为这个容器不会访问任何东西，它会完全孤立地运行，但事实并非总是如此。

所有没有网络定义的容器都自动连接到默认的`bridge`网络。所以，事实上，如果你启动两个没有定义网络的容器，这些容器将能够通过默认的`bridge`网络相互通信。然而，与支持服务发现的用户生成的网络(通过定义的名称调用其他容器)相反，这两个容器只能通过它们的 IP 地址进行通信。

这种细微差别非常方便，如果您考虑用它来连接数据库实例，那就更有趣了！只要您暴露的端口不冲突，您就可以使用默认的本地主机端口(0.0.0.0 或 127.0.0.1)，指定暴露的、映射到主机的端口，并通过 DBMS (pgAdmin、DBeaver、MySQL Workbench 或您喜欢的任何其他端口)连接到您的数据库。相当整洁！您可以旋转两个容器，一个包含您的数据库实例，另一个包含您的应用程序，让它们一起工作，甚至不需要考虑创建用户定义的网络，也不需要任何`docker-compose`文件和任何其他类型的编排方法。

但是当你使用一个`docker-compose`文件时，你可以做更多有趣的事情。您可以定义许多网络、它们的驱动程序、强制 IP 地址、将不同的服务分组到不同的网络中，甚至为不同网络上的相同实例定义别名。因此，一个 NGINX 容器可以在一个网络上被称为`load-balancer`，而在另一个网络上被称为`nginx-lb`。这是完全相同的实例，但是在每个网络上有不同的名称。

# 第三部分。权限和用户/组映射

通过容器运行命令确实有些不方便。默认情况下，创建的任何文件都与用户和组 0 相关联(`root`用户/组映射)。这意味着，如果不使用`sudo`或运行`chown`命令将文件权限重新映射到您自己的用户，您就无法在您的主机上编辑或删除它们。这听起来可能不是很重要，但是因为我用 PHP 开发了很多东西，使用`composer`可能会变得混乱，因为`vendor`目录完全被`root`拥有。

你可能认为这没什么，因为毕竟,`composer`是一个包管理器，外部的第三方包不能在本地编辑。好吧，这很公平，但是想象一下你使用一个生成 PHP 类的脚本。比方说，像我一样，您使用 Laravel，它有`artisan`命令行工具，不仅可以帮助我生成类，还可以生成更多的资源文件来加速您的工作。我一运行`php artisan make:controller SomeController`就无法编辑它，除非首先执行`sudo chown {your username}: SomeController`来授予对该文件的写权限。很不方便，对吧？幸运的是，这很容易避免！

Docker 支持个性化用户/组的映射，容器将作为！我们可以在运行`docker run`时将其作为命令参数。该参数的名称签名是`--user {user}:{group}`，通过添加它，我们明确地表示该命令是由该用户在该组下运行的。这样，如果我们映射到我们自己的用户/组值，它会将文件关联到我们的帐户，使我们能够完全使用它们，就像它们是直接在我们的主机上生成的一样。

然而，有一个问题。或者两个，在这种情况下:

1.  它只需要用户和组的号码，所以你必须事先知道，什么是你的
2.  它对这些数字没有任何验证，所以从技术上来说，你可以对`user:group`使用任何数字组合，并且仍然让容器工作。然而，这与作为`root`运行的结果是一样的，因为如果没有提升的访问权限，您将无法编辑。

放心吧！有一种简单的方法可以不用考虑就能正确使用它。如果您检查机器上可用的`id`命令，您会注意到您有两个选项来获取当前登录的用户帐户的 ID 和组。您可以使用它以编程方式获得正确的值。

因为 bash 命令可以接受子命令并首先评估它们，所以在执行主`docker run`命令之前，可以使用`id -u`获取用户，使用`id -g`获取组。因此，您可以使用您的`user:group`映射运行任何 docker 容器，并使用下面的部分:`docker run --user $(id -u):$(id -g) {the rest of your command here}`。

现在，您可以运行`composer`、`artisan`或任何其他命令，并将所有生成的文件与您的用户/组正确关联。你再也不需要在你选择的 IDE 或者代码编辑器中编辑这些文件了。

# 让我们来玩吧！

你以为我忘了你为什么读这篇文章了吗？当然不是！让我们看看如何在我们的计算机上安装和配置一个平滑的 docker 堆栈。

## 从基础架构开始

像每一个新的技术项目一样，特别是与基础设施相关的项目，我们需要首先考虑我们应该如何构建事物。当我开始使用 Docker 时，我想我应该在我的项目的根目录下使用一个简单的 docker-compose 文件，然后完成它。基础设施是受项目限制的，它与 it 紧密相关，因此以这种方式管理基础设施是有意义的。这似乎也很简单。

然而，我没有考虑如何处理 docker 文件，以及与服务相关的配置文件(例如:NGINX conf 文件或 PHP 的模块)。ini 文件)。为了处理这种噪音，我开始使用一个`.docker`文件夹，其中包含所有内容，除了 docker-compose 文件，它保留在项目根目录下。这听起来像是一个很好的方法，可以将我所有的 docker 相关文件从我的项目文件中分离出来，但是它仍然可以用后者来进行版本控制。尽管有更多的文件需要管理，但我只需要担心一次，所以它仍然“足够简单”。

一切都很好，直到我开始部署东西。我所有的基础设施相关文件都附加在我的代码上。某种形式的开始正在进行，我正在创建一个堆栈，它将部署一个应用程序，其中也有所有基础设施相关的文件。我认为，虽然在项目存储库上有基础设施定义看起来像是我在帮助其他人更快地部署和测试我的工作，但事实是我假设他们也会使用 Docker。

他们可以使用其他开发环境，如虚拟机，甚至在主机上安装所有的依赖项，但他们仍然需要下载我的所有基础架构文件。感觉不太干净，所以我决定将我的基础设施文件与我的项目文件完全分开，并开始考虑如何以简单、有说服力的方式管理它。我需要找到一个易于维护和版本控制的解决方案，同时如果必要的话，该解决方案要足够简单，可以在另一台计算机上重新构建。

我发现自己在我的系统帐户的主目录(在 Linux 中是`/home/{username}`)中创建了一个名为`Infrastructure`的专用文件夹。在这个文件夹里，我有:

1.  每个不同的，个性化的，Docker 图像的文件夹(PHP，NGINX 和其他我需要适应我的需求)；
2.  一个名为`Stacks`的文件夹，包含专用的`docker-compose`文件，每个文件对应一个项目；
3.  一个名为`Volumes`的文件夹，包含了我需要从运行的容器中持久保存的所有数据(比如数据库容器的数据)；
4.  名为`Scripts`的文件夹，包含通过控制台运行容器命令的实用程序脚本(例如，运行 Composer 或 PHP)。

以下是文件夹的树描述:

这种结构允许我对整个文件夹进行版本控制，除了`Volumes`文件夹(数据库数据不应该进行版本控制),这样我可以在另一台计算机上快速检查它，运行`install.sh`脚本，并在很短的时间内获得完全相同的结构和脚本。该文件有五个执行步骤:

1.  创建我的堆栈使用的所有 Docker 网络；
2.  从 Docker HUB 获取我的容器使用的所有最新图像版本；
3.  将 Scripts 文件夹的脚本复制到我的`/usr/local/bin`文件夹，允许我在我的计算机上全局使用它们；
4.  安装全局需要的 composer 包，如 PHPUnit、PHP-CS-Fixer 等；
5.  引导充当反向代理的 NGINX 容器。

## 一个 NGINX 容器来管理它们

关于我的基础设施配置的另一个细节是，我只使用一个 NGINX 容器来服务我所有的 web 项目。如果你在网上读过任何关于使用 Docker 进行开发的教程，你会记得在项目的 docker-compose 文件中声明的 HTTP 服务器(NGINX、Apache 或 Caddy)的服务定义。没必要这样，真的。

事实是，如果您遵循这些教程的建议，您将会通过在您的每个项目上复制和粘贴相同的服务器配置来一遍又一遍地重复您自己。除非您有非常特殊的需求，否则您最有可能为您工作的每个项目使用相同配置的相同 HTTP 服务器。

这里有一个更好的方法:使用一个持久容器。我所指的“持久”是一个容器，它具有对`unless-stopped`的`restart`指令属性。这将容器标记为永久启动，即使发生错误或计算机断电。Docker 守护进程在无意中停止后总是会尝试尽快重启容器。

以下面的 NGINX docker-compose 定义为例:

有了这个配置，我需要做的就是在`conf`文件夹中创建一个新的配置文件(映射在卷部分)并重启容器。在这之后，NGINX 将把我的新项目的所有后续请求路由到适当的项目容器中进行处理。

*如果您注意到我的整个* `*Code*` *文件夹的卷映射，那是因为 NGINX 本身的限制，需要首先读取文件来解释配置规则，并计算将请求路由到哪个服务器/位置块。*

## 旋转项目的容器

拥有我们的反向代理设置很好，但是我们仍然缺少项目容器实例，以便处理请求。下面是一个用于旋转项目容器的 docker-compose 文件示例:

与您可能在各种在线文章中找到的相反，没有 HTTP 服务器服务定义。正如我所说，没有必要，因为我们已经准备好处理许多项目。

但是让我们打破这个文件，好吗？这个文件定义了我们将有一个 PHP 7.2 容器，它将在系统 ID/GROUP 1000 内的映射用户下执行(还记得前面的这些部分吗？)，它将端口 9000 暴露给主机。此外，它将主机的`Code`文件夹映射到容器的`/var/www/html`文件夹(你的代码将存在于此)，将总是重启，除非我们发出命令停止它(自愿地)，并且可以访问两个网络:`web`和`app`。

花一点时间来理解这一点…

您是否想知道为什么它定义了两个网络？这是为了分离和隔离对只涉及该堆栈的服务的访问。例如，数据库容器不应该在`web`网络上，因为有另一个容器 NGINX 也可以访问该网络。把它们都放在同一层有意义吗？不。我们只是在这里谈论一个开发环境，但是不难想象一个类似的堆栈部署在生产环境中。让不相关的服务访问同一个网络是一个坏习惯，因为任何访问 NGINX 容器的人都可以访问数据库容器。

考虑服务的适当界限并在不需要的地方限制访问是一个好习惯。因此，`web`网络允许 NGINX 容器与这个 PHP 容器通信，`app`网络允许这个 PHP 容器访问其他更多的保留服务(比如数据库)。您可以根据需要添加任意数量的网络。此外，由于`app`网络没有被标记为`external`，Docker 将它命名为这个堆栈，即使你在任何其他项目上有相同的名称，他们也不能访问彼此的服务。这是一个简洁的安全特性，内置在 Docker 中。

# 所有人一起，现在！

好了，现在我们已经有了反向代理和项目的容器，我们需要理解它们是如何组合在一起的，并在两个服务之间实现通信。

当一个请求到达 NGINX 时，它将扫描它，以确定需要哪个域将请求路由到正确的容器。这发生在 NGINX 所谓的“服务器阻塞”上。这就是为什么我在 NGINX 容器上映射了一个`conf`文件夹:这个文件夹将包含所有专用项目配置文件。以下是此类文件的一个示例:

如您所见，这个服务器块配置文件被设置为处理对一个`awesome-project.test`域的请求。因此，当一个请求来自那个域时，NGINX 容器将在定义的根文件夹中查找任何匹配第一个`location`定义的文件。假设它找到了一个与模式集匹配的，那么它将扫描所有剩余的`location`定义(在这个示例文件中，还有一个),如果它能匹配模式(寻找任何以`.php`结尾的文件),那么它将执行相应的块指令。就在这第二个`location`街区，所有的奇迹发生了。

首先，我们在变量`$upstream`中设置了一个`container:port`映射。这是配置的一个非常重要的部分，它可以避免 NGINX 出现故障，并在容器碰巧还没有启动时进入重启循环。如果发生这种情况，它负责处理的所有其他项目都不会被处理！

在计算并成功解析项目的容器后，NGINX 编译路径信息和请求，通过定义的端口将其传递给目标容器。在这之后，PHP 容器将获取调用，执行代码并将响应返回给 NGINX 以输出给用户。

# 额外要点:日常使用的实用程序脚本

还记得`Scripts`文件夹吗？正如我之前所说，该文件夹包含几个脚本，用于执行我日常工作中的许多常见任务。通过将它们复制到一个`bin`文件夹，我可以模拟任何程序的行为，就好像它安装在我的计算机上一样，但事实上，我是通过 Docker 容器隔离运行它们的。

例如，运行 Composer(PHP 的依赖项管理器)的命令如下:

有了它，我可以运行任何 composer 命令，就像我在我的计算机上安装它一样，但不需要安装 PHP 和它所需的所有依赖项。我只要做`composer install`或`composer update`，任务就完成了。这个脚本甚至可以访问我的 SSH 密钥来验证私有存储库上的请求。

下面是另一个例子，这次是运行 Yarn，一个基于 Javascript 的项目的依赖管理器:

我用一个简单的`yarn {my command here}`来运行它。

这绝对完美，没有任何麻烦。如果我不再需要一个脚本，我可以用一个简单的`rm {script file path}`把它从我的电脑上删除！我的电脑上没有不必要的依赖。

# 就是这样！

干得好！现在，您已经掌握了创建顺畅基础架构的必要知识！您已经学习了如何分配不同的容器来相互通信，如何使用单个 NGINX 容器来反向代理和服务您需要的多个项目，此外，您还学习了可以使用容器来运行您的日常脚本，而不必担心它是否安装在您当前工作的计算机上。

我希望你喜欢这篇文章。如果您有任何问题，请随时通过推特[联系我。我非常乐意在应用本文中的知识时，帮助您解决您面临的任何困难。](https://twitter.com/josepostiga)