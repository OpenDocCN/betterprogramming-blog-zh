<html>
<head>
<title>Write Readable, Robust, and Reliable Unit Tests for iOS Applications With Swift and XCTest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift和XCTest为iOS应用编写可读、健壮和可靠的单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-readable-robust-and-reliable-unit-tests-for-ios-applications-with-swift-and-xctest-b4c1cc70d35a?source=collection_archive---------9-----------------------#2022-09-08">https://betterprogramming.pub/writing-readable-robust-and-reliable-unit-tests-for-ios-applications-with-swift-and-xctest-b4c1cc70d35a?source=collection_archive---------9-----------------------#2022-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1b2d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何像专业人士一样在Swift中实现单元测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4d785fbd47558c2504ffdd50f5ab6800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xwj1uXpSfvqE8Mym-VOH3g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/photos/dsOvZnqGawg" rel="noopener ugc nofollow" target="_blank"> AltumCode </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9ed3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单元测试在软件产品的质量中是至关重要的，因为它们允许我们在功能对用户可用之前识别和修复错误，并且在将来的修改中保护我们的流程。</p><p id="90bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，我们并不总是像投资生产代码的质量一样关心测试代码的质量，这最终会产生不可读或不可靠的测试用例。</p><p id="829f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以提到的“不受欢迎的测试”包括:</p><ul class=""><li id="a849" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">弱测试:</strong>在没有正确测试功能的情况下成功通过的测试用例，产生了一种虚假的安全感，而它们实际上并没有测试任何东西；</li><li id="49b5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">使用大量断言的测试:</strong>它们违反了单一责任原则(SRP)，并且由于冗长使得代码难以阅读。</li></ul><p id="50fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我介绍了一种方法，我在我的iOS项目中使用这种方法来获得具有更好可读性、健壮性和可靠性的测试，避免弱测试和具有大量断言的测试。</p><h1 id="fecf" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">被测系统</h1><p id="9f46" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">让我们考虑一个基于MVVM模式构建的简单待办事项列表，它的初始代码可以通过检查<a class="ae kv" href="https://github.com/gabrielmoreira-dev/task-list-ios/tree/initial" rel="noopener ugc nofollow" target="_blank">初始分支</a>从<a class="ae kv" href="https://github.com/gabrielmoreira-dev/task-list-ios/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得。业务规则在视图模型层，所以这就是我们想要测试的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9e7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，我们有一个<code class="fe nf ng nh ni b">loadTaskList</code>函数来启用加载状态，加载必要的数据，并通过一个委托将其呈现在屏幕上。代理有三个功能:<code class="fe nf ng nh ni b">displayLoadingState</code>、<code class="fe nf ng nh ni b">displayTaskList</code>和<code class="fe nf ng nh ni b">displayError</code>。</p><h1 id="5144" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">以最常见的方式进行测试</h1><p id="14e0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">假设我们想为加载任务列表的成功案例编写一个测试。最初，我们需要为委托定义一个Spy，以便观察视图模型发送给这个元素的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="613f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以编写期望的测试用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d47e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行测试，我们可以验证它是否成功通过。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5a565ca8012f3f1b058e2a516acb3ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*xZWI-BqJ3dbPyPxcAP81JA.png"/></div></figure><p id="07a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然没问题。</p><p id="7e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我在许多项目中看到的一种方法，也是我们最初学习创建单元测试的最常见的方法。如果我们在YouTube上搜索，我们会发现几个遵循这种方法的测试示例。</p><p id="1834" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果我们想在开发人员的职业生涯中发展并达到更高的资历水平，我们需要不断改进我们的技术，使我们的代码越来越专业。</p><p id="f8ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到这一点，让我们讨论一下这种方法会降低测试质量的一些问题。</p><h1 id="7c79" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">这种方法的问题</h1><p id="873d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">让我们通过添加对<code class="fe nf ng nh ni b">displayError</code>函数的调用来尝试修改视图模型的行为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9e28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们再次运行测试，我们将看到它仍然成功通过(！！！).</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5a565ca8012f3f1b058e2a516acb3ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*xZWI-BqJ3dbPyPxcAP81JA.png"/></div></figure><p id="b7f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们引入了一些不想要的行为，测试无法识别错误，所以这是一个<strong class="ky ir">脆弱测试</strong>。</p><p id="39d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，读者可能会想:<em class="nk">“但是，只要添加新的断言来确保不调用其他函数就能解决问题！”</em>。</p><p id="7adf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这种配置不能很好地伸缩，因为它违反了单一责任原则，为同一个测试用例引入了多个责任。不难意识到，在更复杂的类中，所需的断言数量达到数十个，这使得测试代码非常难以阅读。</p><p id="1f9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们不会涵盖所有可能的情况。现在让我们试着以相反的顺序调用正确的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="304e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当运行测试时，我们验证它仍然通过。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5a565ca8012f3f1b058e2a516acb3ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*xZWI-BqJ3dbPyPxcAP81JA.png"/></div></figure><p id="3974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发生这种情况是因为我们从来不检查函数调用的顺序，这就产生了间隙，从而引入了本例中的意外行为。</p><p id="b0c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如何在不破坏SRP的情况下使我们的测试更有弹性呢？</p><h1 id="eeea" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">解决方案:消息模式</h1><p id="e78f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">好消息是有一个非常简单的方法适合这种情况:<strong class="ky ir">消息模式</strong>。</p><p id="bf59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它基本上包括在Spy类中定义一个消息枚举和一个数组，该数组负责存储Spy收到的所有动作的“消息”。因此，我们确切地知道执行了哪些操作及其顺序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="23b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Swift中应用这种模式的好处是，它允许我们存储与案例相关的值，这在有参数的函数中非常有用，比如在<code class="fe nf ng nh ni b">displayTaskList</code>的案例中。</p><p id="d9c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在重新运行测试时，我们看到它现在失败了，这是预期的行为。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/aa2e23e850c3e69a8524d1e0481b4438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*Lr4E5keAxsfzcKE4vvhqvA.png"/></div></figure><p id="da4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果我们将函数的行为调整到正确的状态，我们会看到测试现在通过了，因此我们有了一个更加可靠的测试，能够指示意外行为的存在。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/339f2dd2df1837fe1b9e96ac213b408e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*qjJCLdAmFpk9f1X-hnRBeg.png"/></div></figure><h1 id="ef91" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="972d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">编写好的单元测试是对代码质量的重视，所以我们需要小心对待它们，避免实现脆弱的测试或难以阅读和理解的测试。</p><p id="a9c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文介绍了一种为MVVM架构中的视图模型层编写测试的模式，但是同样的方法也可以适用于其他更健壮的架构，比如VIP和Clean Swift，只需调整每个架构模式固有的结构。</p><p id="9d2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！如有疑问，欢迎留言回复。</p><h1 id="1ecc" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">资源</h1><p id="d8b5" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/gabrielmoreira-dev/task-list-ios/" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></p></div></div>    
</body>
</html>