<html>
<head>
<title>Tips for Using React’s UseEffect Effectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效使用React的使用效果的提示</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tips-for-using-reacts-useeffect-effectively-dfe6ae951421?source=collection_archive---------0-----------------------#2020-06-10">https://betterprogramming.pub/tips-for-using-reacts-useeffect-effectively-dfe6ae951421?source=collection_archive---------0-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="535c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">依赖数组、代码优化、useCallback等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f18e907b4a0d2abc1995bbc736cd5870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUi3vkj06Vqp_sXeiI-UbQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹姆斯·哈里森在<a class="ae ky" href="/s/photos/developer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子是从一个功能组件访问React的状态和生命周期方法的好方法。<code class="fe lv lw lx ly b">useEffect</code>钩子是一个函数(<code class="fe lv lw lx ly b">effect</code>)，在渲染之后和每次DOM更新时运行。</p><p id="c937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论一些更好地使用<code class="fe lv lw lx ly b">useEffect</code>钩子的技巧。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8957" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.儿童特效先开火</h1><p id="01ae" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">把<code class="fe lv lw lx ly b">useEffect</code>钩子想象成<code class="fe lv lw lx ly b">componentDidMount</code>、<code class="fe lv lw lx ly b">componentDidUpdate</code>和<code class="fe lv lw lx ly b">componentWillUnmount</code>的组合。</p><p id="34e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此<code class="fe lv lw lx ly b">useEffect</code>钩子的行为类似于类生命周期方法。需要注意的一个行为是，子回调在父回调之前被触发<em class="nd">。你可以在这里检查这个行为<a class="ae ky" href="https://codesandbox.io/s/autumn-monad-p3wdo?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">。</a></em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您必须自动触发支付。这段代码写在render之后运行的子组件中，但是实际的细节(总金额、折扣等。)是在父组件的效果中获取的。在这种情况下，由于支付是在设置所需的详细信息之前触发的，所以不会成功。</p><p id="2641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住这一点，并相应地构建您的代码。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5d58" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.依赖数组</h1><p id="3997" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们从基础开始。<code class="fe lv lw lx ly b">useEffect</code>钩子接受第二个参数，称为依赖数组，来控制回调何时触发。</p><h2 id="e631" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">在每次DOM更新时运行效果</h2><p id="f86a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">不传入依赖数组将在每次DOM更新时运行回调。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="2639" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">初始渲染时运行效果</h2><p id="45eb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">传入一个空数组只会在初始渲染后运行效果。此时，状态用其初始值更新。DOM中的进一步更新不调用这个效果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这类似于<code class="fe lv lw lx ly b">componentDidMount</code>和<code class="fe lv lw lx ly b">componentWillUnmount</code>(在<code class="fe lv lw lx ly b">return</code>上)生命周期方法。</p><p id="0649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是添加页面所需的所有侦听器和订阅的地方。</p><h2 id="4edb" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">特定道具变化的运行效果</h2><p id="2931" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设您必须根据用户对哪个产品感兴趣来获取数据(产品细节)——例如，所选产品有一个<code class="fe lv lw lx ly b">productId</code>。我们需要在每次<code class="fe lv lw lx ly b">productId</code>改变时运行回调——不仅仅是在初始渲染或每次DOM更新时。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cfe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上复制了<code class="fe lv lw lx ly b"><em class="nd">componentDidUpdate</em></code>生命周期方法。</p><p id="f511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以向依赖数组传递多个值。</p><p id="cd6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个经典的反例将帮助我们更好地理解这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nf l"/></div></figure><p id="edc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，<code class="fe lv lw lx ly b">counter1</code>或<code class="fe lv lw lx ly b">counter2</code>的更新会触发下面的效果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="24b8" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated"><strong class="ak">传递依赖数组中的对象</strong></h2><p id="bc79" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，如果你的回调依赖于一个对象。如果你这样做，我们的效果会成功吗？：</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="28af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是否定的——因为对象是引用类型。依赖数组不会注意到对象属性的任何变化，因为只检查引用，而不检查里面的值。</p><p id="363a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以用来在对象中执行深度比较。</p><ul class=""><li id="8eec" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">JSON.stringify</code>对象:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="32e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的效果可以检测到对象的属性何时改变并按预期运行。</p><ul class=""><li id="39ab" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">useRef</code>与Lodash进行比较:</li></ul><p id="3786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用<code class="fe lv lw lx ly b">useRef</code>编写自己的自定义函数进行比较。它用于在组件的整个生命周期中在其<code class="fe lv lw lx ly b">current</code>属性中保存可变值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉它，你可以阅读更多关于useRef的内容。</p><ul class=""><li id="2a9a" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">外部包装</li></ul><p id="8fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的对象太复杂，无法自己进行比较，您可以使用npm包来进行比较。一个流行的建议是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.npmjs.com/package/use-deep-compare-effect" rel="noopener ugc nofollow" target="_blank">use-deep-compare-effect</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1a8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当对象<code class="fe lv lw lx ly b">obj</code>发生变化时，<code class="fe lv lw lx ly b">useDeepCompareEffect</code>才会进行深度比较并运行回调。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0064" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.清洁剂代码的多个<code class="fe lv lw lx ly b">useEffect</code></h1><p id="7416" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">既然我们已经知道了依赖数组，我们可能需要分离效果，以便在组件的不同生命周期事件上运行，或者只是为了代码更简洁。</p><p id="cdba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如在前面的<a class="ae ky" href="https://codesandbox.io/s/snowy-flower-9elps?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">演示</a>中已经看到的，在单个组件中编写多个<code class="fe lv lw lx ly b">useEffect</code>是可能的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4e03" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.处理函数中的依赖关系</h1><p id="c82d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设您想将代码分解成更小的函数，并从effect调用它，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不会给我们预期的行为— <code class="fe lv lw lx ly b">doSomething</code>依赖于不包含在<code class="fe lv lw lx ly b">useEffect</code>数组中的<code class="fe lv lw lx ly b">data</code>。对数据的任何更新都不会触发我们的回调。</p><p id="8d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么React建议我们在<code class="fe lv lw lx ly b">useEffect</code>中使用这个函数，因为它更容易跟踪依赖关系。</p><p id="81ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你想写可重用的函数呢？还是从一个父组件传下来？</p><p id="f964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您想要将一个函数作为道具传递给它的子组件时，您需要将该函数添加到子组件效果中的依赖数组中。但是每当parent中发生变化时，就会创建这些函数的新实例，并触发我们的回调函数。这是低效的。</p><p id="3763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这样的场景，<code class="fe lv lw lx ly b">useCallback</code> <strong class="lb iu"> </strong>就来救援了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe lv lw lx ly b">useEffect</code>,<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">useCallback</a></code><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"/>接受一个回调和一个依赖数组。它将返回一个内存化版本的回调函数，只有当任何依赖关系发生变化时，它才会改变自己的标识，从而确保我们不会在每次父对象重新呈现时都创建一个新的函数实例。</p><p id="5962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里用上面的<a class="ae ky" href="https://codesandbox.io/s/currying-shape-2dv3l?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">做实验</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="59f7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.总是在顶层调用钩子</h1><p id="7a2a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">不能在条件、循环或嵌套函数中调用<code class="fe lv lw lx ly b">useEffect</code>(或任何钩子)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以阅读更多关于<a class="ae ky" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">钩子</a>的规则。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b30b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="5b2e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">上面讨论的所有要点都在<a class="ae ky" href="https://codesandbox.io/s/cool-cloud-jmlrx?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">这个</a>代码中。你可以拿着它到处玩。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="ffb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。编码快乐！</p></div></div>    
</body>
</html>