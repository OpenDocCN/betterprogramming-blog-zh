<html>
<head>
<title>The Power of Extension Methods for C# Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#开发人员扩展方法的力量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-extension-methods-b3b1962475c4?source=collection_archive---------10-----------------------#2021-10-12">https://betterprogramming.pub/the-power-of-extension-methods-b3b1962475c4?source=collection_archive---------10-----------------------#2021-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dc2c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及为什么你不应该害怕使用它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9cbbc604fb31f1312a75a46775821a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FWohaERnEU4L0YL-BXBHw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@austindistel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>在<a class="ae kv" href="https://unsplash.com/s/photos/software?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b163" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有感觉到你的软件开发伙伴害怕使用任何静态的东西？据说，抽象层的缺失会降低代码库的可测试性。虽然在某种程度上这是真的，但是当正确实现时，扩展方法(或者任何静态方法)可以极大地改进您的代码库！</p><p id="8a38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解释扩展方法的好处或能力是什么，让我们首先深入到扩展方法本身；什么是扩展方法，如何使用它们，有哪些用例。</p><h1 id="a5de" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">解释扩展方法</h1><p id="4777" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">顾名思义，扩展方法是扩展特定类型的方法。通常，扩展方法用于向类型“添加”一个方法或一部分功能，而无需对类型本身进行任何修改或创建新的派生类型。扩展方法总是静态方法，但是调用它们时就好像它们是扩展类型的实例方法一样。</p><p id="2d1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">扩展方法可以通过两种方式识别:</p><ul class=""><li id="1c21" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">方法是<code class="fe mz na nb nc b">static</code></li><li id="ed8a" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">该方法的第一个参数前面是关键字<code class="fe mz na nb nc b">this</code></li></ul><h1 id="ea9a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">基本扩展方法</h1><p id="b691" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">假设我们有一个简单的存储库接口，它定义了您可以对一个实体进行的所有最基本的修改的契约；CRUD操作:</p><ul class=""><li id="d45f" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><em class="ls">创建— </em>在底层数据层创建一个实体</li><li id="3e32" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><em class="ls"> Read </em> —查找与指定模式匹配的所有实体</li><li id="9213" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><em class="ls">更新</em> —根据指定实体的标识符更新单个实体</li><li id="61c0" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><em class="ls">删除</em> —删除所有匹配指定模式的实体</li></ul><p id="2c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个接口可能看起来像这样——其中<code class="fe mz na nb nc b">IEntity</code>只定义了一个名为<code class="fe mz na nb nc b">Identifier</code>的属性(它有一个<code class="fe mz na nb nc b">long</code>数据类型):</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="a8e4" class="nm lu iq nc b gy nn no l np nq">public interface IRepository&lt;TEntity&gt;<br/>    where TEntity : class, IEntity<br/>{<br/>    void Create(TEntity entity);<br/><br/>    IEnumerable&lt;TEntity&gt; Read(Func&lt;TEntity, bool&gt; match);<br/><br/>    void Update(TEntity entity);<br/><br/>    void Delete(Func&lt;TEntity, bool&gt; match);<br/>}</span></pre><p id="aaab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，在许多情况下，这些简单的CRUD操作是不够的。</p><p id="7cf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您只期望一个结果而不是多个实体时，能够找到单个实体是非常有用的。</p><p id="733b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，当基于唯一的属性值(如标识符)查找实体时。</p><p id="0490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是扩展方法派上用场的地方:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="bfe9" class="nm lu iq nc b gy nn no l np nq">public static TEntity GetSingle&lt;TEntity&gt;(<br/>        this IRepository&lt;TEntity&gt; repository,<br/>        Func&lt;TEntity, bool&gt; match)<br/>        where TEntity : class, IEntity<br/>{<br/>    return repository<br/>        .Read(match)<br/>        .Single();<br/>}</span></pre><p id="6027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，您可以在您的存储库上调用<code class="fe mz na nb nc b">GetSingle</code>扩展方法，而不会污染您的存储库本身:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="0bdb" class="nm lu iq nc b gy nn no l np nq">repository.GetSingle(e =&gt; e.Identifier == entityIdentifier);</span></pre><p id="f37a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，更进一步，您可以定义一个扩展方法，专门过滤特定的属性，比如标识符:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="3ae1" class="nm lu iq nc b gy nn no l np nq">public static TEntity GetSingle&lt;TEntity&gt;(<br/>    this IRepository&lt;TEntity&gt; repository,<br/>    long identifier)<br/>    where TEntity : class, IEntity<br/>{<br/>    return repository<br/>        .Read(e =&gt; e.Identifier == identifier)<br/>        .Single();<br/>}</span></pre><p id="0636" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用相同的原则来定义一个<code class="fe mz na nb nc b">TryGetSingle</code>扩展方法，当没有找到实体时，它不会抛出异常。</p><p id="06c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，它返回一个默认值:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="c473" class="nm lu iq nc b gy nn no l np nq">public static TEntity TryGetSingle&lt;TEntity&gt;(<br/>    this IRepository&lt;TEntity&gt; repository,<br/>    long identifier)<br/>    where TEntity : class, IEntity<br/>{<br/>    return repository<br/>        .Read(e =&gt; e.Identifier == identifier)<br/>        .SingleOrDefault();<br/>}</span></pre><p id="cdbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们对这些扩展方法所做的就是利用我们简单的<code class="fe mz na nb nc b">IRepository</code>接口，并扩展它，这样所有实现该接口的类都不需要单独定义它们自己的<code class="fe mz na nb nc b">GetSingle</code>和<code class="fe mz na nb nc b">TryGetSingle</code>方法。</p><p id="8ce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得我们的接口及其实现类更加干净。我们还为扩展方法定义了一个单点定义:它们都在一个类中定义:<code class="fe mz na nb nc b">RepositoryExtensions</code>。</p><p id="69e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以只在一种特定类型上定义无限数量的扩展方法(当然，不建议这样做)。</p><h1 id="fbc5" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">链接方法</h1><p id="ad16" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">扩展系列的下一站是方法链接。当涉及到链接方法(例如大多数LINQ方法)时，扩展方法可能是一个非常强大的工具。</p><p id="7477" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">链接方法通常在扩展时返回相同的类型，这使得它可以链接多个扩展方法——这就是术语“链接方法”的由来。</p><p id="5a65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个可能的例子。我们可以定义一个<code class="fe mz na nb nc b">Employee</code>类型，带有几个属性(名、姓、雇员号和出生日期)。</p><p id="3f91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还在类型上定义了几个简单的扩展方法——用于设置<code class="fe mz na nb nc b">Employee</code>类型的特定属性:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="a994" class="nm lu iq nc b gy nn no l np nq">public static Employee WithFirstName(<br/>    this Employee employee,<br/>    string firstName)<br/>{<br/>    employee.FirstName = firstName;<br/><br/>    return employee;<br/>}</span></pre><p id="0da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下该类型的每个属性都有一个扩展方法。我们现在可以这样实例化一个新雇员:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="c39a" class="nm lu iq nc b gy nn no l np nq">var employee = new Employee();<br/><br/>employee<br/>    .WithFirstName("John")<br/>    .WithLastName("Doe")<br/>    .WithEmployeeNumber("MLG420")<br/>    .WithBirthdate(birthdate);</span></pre><p id="b819" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，不仅扩展方法非常有用，您的<code class="fe mz na nb nc b">Employee</code>类中的静态<code class="fe mz na nb nc b">Create</code>方法可以使它更具可读性:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="300c" class="nm lu iq nc b gy nn no l np nq">public static Employee Create()<br/>{<br/>    return new Employee();<br/>}</span></pre><p id="a04f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">Employee</code>实例化现在看起来像这样:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="0a25" class="nm lu iq nc b gy nn no l np nq">var employee = Employee.Create()<br/>    .WithFirstName("John")<br/>    .WithLastName("Doe")<br/>    .WithEmployeeNumber("MLG420")<br/>    .WithBirthdate(birthdate);</span></pre><p id="2b8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然扩展链在这样简单的情况下可能不会增加额外的价值，但在更复杂的情况下，它肯定会增加价值，在这种情况下，您不仅需要在类型上设置简单的属性值。想象一下可能性！</p><h1 id="4883" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">高级链接方法</h1><p id="7385" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我曾经为运行集成测试创建了自己的测试环境构建平台，只是为了好玩。</p><p id="2398" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，集成测试需要某种上下文，但是您仍然希望它们是幂等的——这意味着，无论您运行测试多少次，测试都不应该依赖于现有的上下文，也不应该依赖于任何现有的数据。</p><p id="d4cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着应用链接方法来构建特定的测试环境是非常有用的。为了演示这一点，我创建了一个<code class="fe mz na nb nc b">TestContext</code>类，它包含一个需要出现在我们的测试用例中的<code class="fe mz na nb nc b">Employees</code>列表。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="6b28" class="nm lu iq nc b gy nn no l np nq">public static (TestContext, Employee) AddEmployee(<br/>    this TestContext context)<br/>{<br/>    var employee = Employee.Create();<br/><br/>    return (context, employee);<br/>}<br/><br/>public static (TestContext, Employee) WithName(<br/>    this (TestContext, Employee) input,<br/>    string firstName,<br/>    string lastName)<br/>{<br/>    var (context, employee) = input;<br/><br/>    employee.FirstName = firstName;<br/>    employee.LastName = lastName;<br/><br/>    return (context, employee);<br/>}</span><span id="310e" class="nm lu iq nc b gy nr no l np nq">public static TestContext Save(<br/>    this (TestContext, Employee) input)<br/>{<br/>    var (context, employee) = input;<br/>    <br/>    context.Employees.Add(employee);<br/><br/>    return context;<br/>}</span></pre><p id="683a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们没有返回扩展类型的实例，而是返回一个值元组，其中包含我们的<code class="fe mz na nb nc b">TestContext</code>实例以及我们将要添加的<em class="ls">雇员</em>。</p><p id="2991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">Save</code>方法最后将实例化和修改后的<code class="fe mz na nb nc b">Employee</code>添加到实际的测试上下文中，返回<code class="fe mz na nb nc b">TestContext</code>本身以使其可用于进一步的链接。</p><p id="98a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种用法可能如下所示:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="ad0c" class="nm lu iq nc b gy nn no l np nq">TestContext.Create()<br/>    .AddEmployee()<br/>    .WithName("John", "Doe")<br/>    .WithBirthdate(birthdate)<br/>    .WithEmployeeNumber("MLG420")<br/>    .Save();</span></pre><p id="54b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者更进一步说:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="0f8b" class="nm lu iq nc b gy nn no l np nq">TestContext.Create()<br/>    .AddEmployee()<br/>    .WithName("John", "Doe")<br/>    .WithBirthdate(birthdate)<br/>    .WithEmployeeNumber("MLG420")<br/>    .Save()<br/>    .AddEmployee()<br/>    .WithName("Jane", "Doe")<br/>    .WithEmployeeNumber("MLG024")<br/>    .Save();</span></pre><p id="e2d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像这样使用链接方法的一个好处是，特别是当涉及到测试用例时，您不需要总是设置employee类型的每个属性。</p><p id="5c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，当您的测试用例中不需要出生日期时，就不要调用<code class="fe mz na nb nc b">WithBirthdate</code>扩展方法。您只需显式地设置测试用例所需的所有属性。不管你想在你的类型上设置什么属性，也不管你想实例化多少类型，你都可以在一行可读的代码中完成！</p><p id="f799" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成<code class="fe mz na nb nc b">TestContext</code>的设置后，您可以轻松地访问<code class="fe mz na nb nc b">Employees</code>的列表——以及您在上下文中定义的任何其他列表——这些列表是您在设置中添加的，例如使用它们来模仿<code class="fe mz na nb nc b">EmployeeRepository</code>。</p><h1 id="0987" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">用扩展方法测试</h1><p id="66eb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如前所述，扩展方法可能非常强大，但是大多数开发人员都避免使用它们，因为扩展方法没有提高代码库的可测试性——因为缺少抽象层。</p><p id="0e95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此——抽象层不存在——扩展方法本身非常容易测试。这是因为它们通常只变异一个或两个指定类型的实例。</p><p id="13fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以定义一个简单的输入输出单元测试来测试一个扩展方法做什么！这使得扩展方法更加可靠！这也意味着，因为它们是如此的不可思议的可靠，假设扩展方法做了它们应该做的事情，你可以测试你的代码库的其余部分。你甚至不再需要<em class="ls">来‘抽象’它们了！</em></p><h1 id="d039" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">扩展方法的好处</h1><p id="2cfa" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">尽管本文中的例子在现实生活中可能不那么有用，但是使用扩展方法的原则是相同的。如果实施得当，它们可以:</p><ul class=""><li id="b9b2" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">保持你的类型定义非常干净；一个存储库类只需要包含最基本的修改操作。</li><li id="b98f" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">提高代码库的可读性；单独设置许多属性比一系列命名良好的扩展方法可读性差；</li><li id="c207" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">有单一的责任；</strong>像编辑指定类型的属性值；</li><li id="0a1f" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">是幂等的；</strong>因为它们是静态的，有一个责任，所以对于指定的输入，输出总是相同的；</li><li id="c320" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">是小的、非常好测试的代码片段；这使得他们非常可靠；</li><li id="e69b" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">帮助编写符合开放/封闭原则的代码；扩展类型防止它们在不应该被修改的时候被修改，从而防止类变得臃肿；</strong></li></ul><p id="d80b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于它们的单一责任、小尺寸、可靠性和等幂性，当测试你的代码库的其余部分时，扩展方法不需要被抽象。你可以依靠他们(和他们的单元测试)在相同的环境下总是做完全相同的事情。</p><h1 id="ccfd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">权力越大，责任越大</h1><p id="bfd1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">像这样使用扩展方法伴随着巨大的责任，并不一定是所有开发人员的首选。不言而喻，扩展方法也不总是可行的。</p><p id="ef15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<em class="ls">如果你使用它们，你需要保持你扩展的类型尽可能的干净，并且遵守单一责任模式——对于你的类型定义和扩展方法本身。</em></p><p id="b720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用扩展方法不仅<em class="ls">需要</em>这样做，而且<em class="ls">也刺激</em>这样做，因为扩展方法遵循开放/封闭原则(对扩展开放，对修改关闭)。</p><h1 id="4a22" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="5815" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">所以，现在你知道了——如果你还不知道的话——扩展方法的威力是什么。</p><p id="7ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，它们并不适合每个人、你正在做的每个项目或你所处的每种情况。</p><p id="f00d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们不是你必须使用的圣杯，但是请问问你自己它们是否以及如何能帮助你或者你正在做的项目。</p><p id="40e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>