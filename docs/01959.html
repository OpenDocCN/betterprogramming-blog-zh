<html>
<head>
<title>A Guide to Object-Oriented Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面向对象编程指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/object-oriented-programming-in-javascript-b3bda28d3e81?source=collection_archive---------0-----------------------#2019-10-27">https://betterprogramming.pub/object-oriented-programming-in-javascript-b3bda28d3e81?source=collection_archive---------0-----------------------#2019-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd15" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对象、类、封装、多态等等！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fd72c2b38c3e5aa8ac24db6c03d23148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAWXQo-j9M9mKvk22a9Y6g.png"/></div></div></figure><p id="61ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切都从一个物体开始。</p><p id="2ea1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对象是我们与之交互的东西，它有属性和方法。对象是面向对象编程的核心，不仅对JavaScript如此，对Java、C、C++和其他语言也是如此。停止考虑单个变量和函数，开始考虑自给自足的对象。</p><p id="8c9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里列出了在谈论面向对象编程(OOP)时最常用的概念:</p><ul class=""><li id="848b" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">对象、属性和方法</li><li id="ac88" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">班级</li><li id="1537" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">包装</li><li id="a480" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">抽象</li><li id="51b3" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">可重用性/继承性</li><li id="7ec6" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">多态性</li><li id="a495" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">联合</li><li id="b94d" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">聚合</li><li id="837b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">作文</li></ul><h1 id="25fc" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">对象、属性和方法</h1><h2 id="8be8" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated"><strong class="ak">对象文字</strong></h2><p id="5c94" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">通过在花括号内设置属性，在JavaScript中创建新对象。对象文字属性值可以是任何数据类型，如函数文字、数组、字符串、数字或布尔值。</p><p id="0906" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用一本书创建一个对象，属性包括作者、出版年份、标题和一个方法— <code class="fe nn no np nq b">summary</code>。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="a923" class="mw mf it nq b gy nv nw l nx ny">const book = {<br/>   title: "Hippie",    <br/>   author: "Paulo Coelho",  <br/>   year: "2018"<br/>}</span></pre><p id="9117" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在创建一个对象后，你可以用点符号得到它的值。比如我们可以用<code class="fe nn no np nq b">book.title</code>得到标题的值。<em class="nz"> </em>我们也可以用方括号访问属性:<code class="fe nn no np nq b">book[‘title’]</code> <em class="nz">。</em></p><h2 id="93e7" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated"><strong class="ak">对象构造器</strong></h2><p id="ffee" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">对象构造函数与常规函数相同。每次创建对象时都会调用它。我们可以用关键字<code class="fe nn no np nq b">new</code>来使用它们。当我们想要创建多个具有相同属性和方法的对象时，对象构造函数非常有用。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="f1d7" class="mw mf it nq b gy nv nw l nx ny">const book = {<br/>   title: "Hippie",    <br/>   author: "Paulo Coelho",  <br/>   year: "2018"<br/>}</span><span id="2b94" class="mw mf it nq b gy oa nw l nx ny">const book1 = {<br/>   title: "The Alchemist",    <br/>   author: "Paulo Coelho",  <br/>   year: "1988", <br/>}</span></pre><p id="cd15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想要创建多个book对象，我们必须为每本书复制代码。我们可以继续创建书籍，但这有点痛苦——对象构造函数帮助我们重用对象文字。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ff3b" class="mw mf it nq b gy nv nw l nx ny">function Book(title, author, year) { <br/>   this.title = title; <br/>   this.author = author; <br/>   this.year = year;<br/>}</span><span id="231b" class="mw mf it nq b gy oa nw l nx ny">const book1 = new Book ('Hippie', 'Paulo Coelho', '2018');</span><span id="628f" class="mw mf it nq b gy oa nw l nx ny">console.log(book1);<br/>&gt; Book {<br/>     title: "Hippie", <br/>     author: "Paulo Coelho", <br/>     year: "2018"<br/>  }</span><span id="87fb" class="mw mf it nq b gy oa nw l nx ny">// if we want to create more than one book just we call function book with new keyword.</span><span id="4523" class="mw mf it nq b gy oa nw l nx ny">const book2 = new Book ('The Alchemist', 'Paulo Coelho', '1988');</span></pre><p id="3fde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nn no np nq b">book1</code>和<code class="fe nn no np nq b">book2</code>创建一个<code class="fe nn no np nq b">Book</code>的实例，并将其赋给一个变量。确定一个对象是否是另一个对象的实例。我们可以用<code class="fe nn no np nq b">instanceof</code>。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="c424" class="mw mf it nq b gy nv nw l nx ny">book1 instanceof Book<br/>&gt; true</span></pre><h2 id="677e" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated"><strong class="ak"> Object.create() </strong></h2><p id="cbc4" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">JavaScript中的每个对象都将从主对象<code class="fe nn no np nq b">Object</code>创建。每当我们使用带大写字母“O”的对象时，它指的是主对象。我们可以在控制台中打印主对象。主对象有许多方法，这里我们将看到<code class="fe nn no np nq b">Object.create()</code>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/eb7f3f60ecc2ae4d78d77232b4ff2354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6p1BbUTdn1BjQbwcEmZFow.png"/></div></div></figure><p id="c26e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nn no np nq b">Object.create()</code>方法创建一个新的对象，使用一个现有的对象作为原型。下面是基本语法:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="8388" class="mw mf it nq b gy nv nw l nx ny">Object.create(proto, [propertiesObject])</span></pre><p id="046d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nn no np nq b">proto</code>是新创建对象的原型。<code class="fe nn no np nq b">propertiesObject</code>是可选的。</p><p id="9cc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们举一个简单的例子:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="8a5f" class="mw mf it nq b gy nv nw l nx ny">const Book = { <br/>   summary : function() { <br/>      console.log(`${this.title} is written by ${this.author}.`)<br/>   }<br/>}</span><span id="0831" class="mw mf it nq b gy oa nw l nx ny">const book1 = Object.create(Book);<br/>book1.author = "Paulo Coelho";<br/>book1.title = "Hippie";</span><span id="ee64" class="mw mf it nq b gy oa nw l nx ny">console.log(book1.summary());<br/>&gt; Hippie is written by Paulo Coelho.</span></pre><p id="013d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，我们创建了一个原型对象<code class="fe nn no np nq b">book1</code>，并为author和title赋值。我们可以看到proto对象内部的汇总函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/e8840717b13df050a7243918748fd797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eMEgdErcAYPJvfqM4N_b7w.png"/></div></div></figure><p id="3646" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面我们将详细看看<code class="fe nn no np nq b">Object.create()</code>方法。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="32e5" class="me mf it bd mg mh ok mj mk ml ol mn mo jz om ka mq kc on kd ms kf oo kg mu mv bi translated">班级</h1><p id="b481" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">类不是对象——它是对象的<em class="nz">蓝图。类是特殊的函数。您可以使用函数表达式和声明来定义函数，也可以用这种方式定义类。我们可以使用蓝图创建对象的数量。</em></p><p id="2c92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用class关键字和类名。语法类似于Java。</p><p id="cebc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类语法是使用面向对象编程和管理原型的好方法:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="01d1" class="mw mf it nq b gy nv nw l nx ny">let Book = function(name) { <br/>   this.name = name<br/>}</span><span id="dc92" class="mw mf it nq b gy oa nw l nx ny">let newBook = function(name) {<br/>   Book.call(this, name)<br/>} </span><span id="3c49" class="mw mf it nq b gy oa nw l nx ny">newBook.prototype = Object.create(Book.prototype);<br/>const book1 = new newBook("The Alchemist");</span></pre><p id="53cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是使用ES6类语法:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="5219" class="mw mf it nq b gy nv nw l nx ny">class Book {<br/>   constructor(name) {<br/>      this.name = name<br/>   }<br/>}</span><span id="ada8" class="mw mf it nq b gy oa nw l nx ny">class newBook extends Book { <br/>   constructor(name) {<br/>      super(name);<br/>   }<br/>}</span><span id="cbf8" class="mw mf it nq b gy oa nw l nx ny">const book1 = new newBook("The Alchemist");</span></pre><p id="27f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类语法是语法糖——在幕后，它仍然使用基于原型的模型。类是函数，函数是JavaScript中的对象。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="c413" class="mw mf it nq b gy nv nw l nx ny">class Book {<br/>   constructor(title, author){ <br/>      this.title = title;<br/>      this.author = author;<br/>   } <br/>   summary() {<br/>      console.log(`${this.title} written by ${this.author}`);<br/>   }<br/>}</span><span id="8945" class="mw mf it nq b gy oa nw l nx ny">const book1 = new Book("", "");</span><span id="dd23" class="mw mf it nq b gy oa nw l nx ny">console.log(typeof Book); <br/>&gt; "function"</span><span id="3895" class="mw mf it nq b gy oa nw l nx ny">console.log(typeof book1);<br/>&gt; "object"</span></pre></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="f06a" class="me mf it bd mg mh ok mj mk ml ol mn mo jz om ka mq kc on kd ms kf oo kg mu mv bi translated"><strong class="ak">封装</strong></h1><p id="8cc4" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">封装意味着隐藏信息或数据。它指的是对象执行其功能而不向调用者透露任何执行细节的能力。换句话说，私有变量仅对当前函数可见，对全局范围或其他函数不可访问。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ff22" class="mw mf it nq b gy nv nw l nx ny">const Book = function(t, a) {<br/>   let title = t; <br/>   let author = a; <br/>   <br/>   return {<br/>      summary : function() { <br/>        console.log(`${title} written by ${author}.`);<br/>      } <br/>   }<br/>}<br/>const book1 = new Book('Hippie', 'Paulo Coelho');</span><span id="5610" class="mw mf it nq b gy oa nw l nx ny">book1.summary();<br/>&gt; Hippie written by Paulo Coelho.</span></pre><p id="cae6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，标题和作者只在函数<code class="fe nn no np nq b">Book</code>的范围内可见，方法<code class="fe nn no np nq b">summary</code>对<code class="fe nn no np nq b">Book</code>的调用者可见。所以标题和作者都封装在<code class="fe nn no np nq b">Book</code>里面。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="11cd" class="me mf it bd mg mh ok mj mk ml ol mn mo jz om ka mq kc on kd ms kf oo kg mu mv bi translated">抽象</h1><p id="ba35" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">抽象意味着实现隐藏。这是一种隐藏实现细节的方式，只向调用者显示基本特性。换句话说，它隐藏了不相关的细节，只显示了对外部世界必要的东西。缺乏抽象会导致代码可维护性的问题。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1297" class="mw mf it nq b gy nv nw l nx ny">const Book = function(getTitle, getAuthor) { <br/>   <!-- -->// Private variables / properties<!-- -->  <br/>   let title = getTitle; <br/>   let author = getAuthor;</span><span id="bdfb" class="mw mf it nq b gy oa nw l nx ny">// Public method <br/>   this.giveTitle = function() {<br/>      return title;<br/>   }<br/>   <br/>   // <!-- -->Private method<br/>   const summary = function() {<br/>      return `${title} written by ${author}.`<br/>   }</span><span id="5e91" class="mw mf it nq b gy oa nw l nx ny">// Public method that has access to private method.<br/>   this.giveSummary = function() {<br/>      return summary()<br/>   } <br/>}</span><span id="4ab2" class="mw mf it nq b gy oa nw l nx ny">const book1 = new Book('Hippie', 'Paulo Coelho');</span><span id="e453" class="mw mf it nq b gy oa nw l nx ny">book1.giveTitle();<br/>&gt; "Hippie"</span><span id="bb2d" class="mw mf it nq b gy oa nw l nx ny">book1.summary();<br/>&gt; Uncaught TypeError: book1.summary is not a function</span><span id="11b1" class="mw mf it nq b gy oa nw l nx ny">book1.giveSummary();<br/>&gt; "Hippie written by Paulo Coelho."</span></pre></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="38d4" class="me mf it bd mg mh ok mj mk ml ol mn mo jz om ka mq kc on kd ms kf oo kg mu mv bi translated"><strong class="ak">可重用性/继承性</strong></h1><p id="1a25" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">JavaScript继承是一种允许我们使用现有类创建新类的机制。这意味着子类继承了父类的所有属性和行为。</p><p id="1782" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，JavaScript不是基于类的语言。关键字<em class="nz"> class </em>是在ES6中引入的，但在语法上是糖，JavaScript仍然是基于原型的。在JavaScript中，继承是通过使用原型实现的。这种模式被称为<em class="nz">行为委托模式</em>或原型继承。</p><p id="ac79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们考虑一下我们的书的例子:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="4369" class="mw mf it nq b gy nv nw l nx ny">function Book(title, author, year) { <br/>   this.title = title; <br/>   this.author = author; <br/>   this.year = year;<br/>   this.summary = function() { <br/>      console.log(`${this.title} is written by ${this.author}.`)<br/>   }<br/>}<br/>const book1 = new Book ('Hippie', 'Paulo Coelho', '2018');</span><span id="b9a0" class="mw mf it nq b gy oa nw l nx ny">const book2 = new Book ('The Alchemist', 'Paulo Coelho', '1988');</span></pre><h2 id="f1c3" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated"><strong class="ak">原型继承</strong></h2><p id="9670" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">对于每个<code class="fe nn no np nq b">Book</code>实例，我们为基类的方法重新创建内存。这些方法必须在所有实例间共享——它们不应该是特定于实例的。这里，原型出现了:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="fc9e" class="mw mf it nq b gy nv nw l nx ny">let Corebook = function(title) {<br/>  this.title = title<br/>}</span><span id="7fdb" class="mw mf it nq b gy oa nw l nx ny">Corebook.prototype.title = function() {<br/>  console.log(`name of the book is ${this.title}`);<br/>}</span><span id="4d2e" class="mw mf it nq b gy oa nw l nx ny">Corebook.prototype.summary = function(author) {<br/>  console.log(`${this.title} is written by ${this.author}`);<br/>}</span><span id="2042" class="mw mf it nq b gy oa nw l nx ny">let Book = function(title, author) {<br/>  Corebook.call(this, title, author)<br/>}</span><span id="7bae" class="mw mf it nq b gy oa nw l nx ny">Book.prototype = Object.create(Corebook.prototype);</span><span id="354a" class="mw mf it nq b gy oa nw l nx ny">let book1 = new Book('The Alchemist', 'Paulo Coelho');</span><span id="0e42" class="mw mf it nq b gy oa nw l nx ny">book1.title();<br/>&gt; name of the book is The Alchemist</span><span id="3b22" class="mw mf it nq b gy oa nw l nx ny">book1.summary();<br/>&gt; The Alchemist is written by Paulo Coelho</span></pre><p id="627f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，<code class="fe nn no np nq b">Book</code>的实例有一个原型的副本，它链接到<code class="fe nn no np nq b">Book</code>的原型，后者又链接到<code class="fe nn no np nq b">Corebook</code>的原型。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="531e" class="me mf it bd mg mh ok mj mk ml ol mn mo jz om ka mq kc on kd ms kf oo kg mu mv bi translated"><strong class="ak">多态性</strong></h1><p id="ed1d" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">对不同的对象调用相同的方法并让每个对象以自己的方式响应的能力被称为多态性。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="be54" class="mw mf it nq b gy nv nw l nx ny">let book1 = function () {}<br/>book1.prototype.summary = function() {<br/>   return "summary of book1"<br/>}</span><span id="eaa1" class="mw mf it nq b gy oa nw l nx ny">let book2 = function() {}<br/>book2.prototype = Object.create(book1.prototype);<br/>book2.prototype.summary = function() {                 <br/>   return "summary of book2"<br/>}</span><span id="82d6" class="mw mf it nq b gy oa nw l nx ny">let book3 = function() {}<br/>book3.prototype = Object.create(book1.prototype);<br/>book3.prototype.summary = function() {<br/>   return "summary of book3"<br/>}<br/>   <br/>var books = [new book1(), new book2(), new book3()];<br/>books.forEach(function(book){<br/>   console.log(book.summary());<br/>});</span><span id="7d73" class="mw mf it nq b gy oa nw l nx ny">&gt; summary of book1<br/>&gt; summary of book2<br/>&gt; summary of book3</span></pre></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="20f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对象之间的关系将通过关联、聚合和组合来定义。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="07a8" class="me mf it bd mg mh ok mj mk ml ol mn mo jz om ka mq kc on kd ms kf oo kg mu mv bi translated">联合</h1><p id="8721" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">关联是两个或多个对象之间的关系。每个<code class="fe nn no np nq b">Object</code>都是独立的。换句话说，关联定义了对象之间的多重性:一对一、一对多、多对一、多对多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/29c5f730fc800326634b461f792b5f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*skSqayBpHeBnO_dF13OY5w.jpeg"/></div></figure><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="0d02" class="mw mf it nq b gy nv nw l nx ny">function Book(title, author) { <br/>   this.title = title; <br/>   this.author = author; <br/>}</span><span id="372a" class="mw mf it nq b gy oa nw l nx ny">const book1 = new Book ('Hippie', 'Paulo Coelho');</span><span id="ea20" class="mw mf it nq b gy oa nw l nx ny">const book2 = new Book ('The Alchemist', 'Paulo Coelho');</span><span id="4f22" class="mw mf it nq b gy oa nw l nx ny">book2.multiplicity = book1</span></pre><p id="3631" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nn no np nq b">book1</code>被赋予多重性的属性给对象<code class="fe nn no np nq b">book2</code>。它显示了对象<code class="fe nn no np nq b">book1</code>和<code class="fe nn no np nq b">book2</code>之间的关系。两者都可以独立添加和删除。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/e1f862fc58f7a75d6a879d738e22d303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIxjO_62wDCqy86LanSgVw.png"/></div></div></figure></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="5823" class="me mf it bd mg mh ok mj mk ml ol mn mo jz om ka mq kc on kd ms kf oo kg mu mv bi translated">聚合</h1><p id="1f31" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">聚合是关联的一个特例。在两个对象之间的关系中，一个对象可能比另一个对象具有更重要的作用。换句话说，当一个对象比另一个对象拥有更多所有权时，这就是聚合。所有者对象通常被称为集合，拥有的对象被称为组件。聚合也称为“有-有”关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/635e35e29591a5ed83e14a599b1a0fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*OIlTEcX2jPrA6AWG4VmIAw.jpeg"/></div></figure><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="d34c" class="mw mf it nq b gy nv nw l nx ny">function Book(title, author) { <br/>   this.title = title; <br/>   this.author = author; <br/>}</span><span id="4890" class="mw mf it nq b gy oa nw l nx ny">const book1 = new Book ('Hippie', 'Paulo Coelho');</span><span id="06ed" class="mw mf it nq b gy oa nw l nx ny">const book2 = new Book ('The Alchemist', 'Paulo Coelho');</span><span id="7fc1" class="mw mf it nq b gy oa nw l nx ny">let publication = {<br/>   "name": "new publication Inc", <br/>   "books": []<br/>}</span><span id="77fb" class="mw mf it nq b gy oa nw l nx ny">publication.books.push(book1);<br/>publication.books.push(book2);</span></pre><p id="766b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nn no np nq b">book1</code>和<code class="fe nn no np nq b">book2</code>被添加到出版对象下的书籍中。如果发布对象在<code class="fe nn no np nq b">book1</code>和<code class="fe nn no np nq b">book2</code>可用之前被删除，那么<code class="fe nn no np nq b">Book</code>和<code class="fe nn no np nq b">publication</code>都独立存在。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/5ca5a6cf6c772ec03c693073883c7a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*9ZCsb-pNJcVeEVWyHyoeYg.png"/></div></figure></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="ae03" class="me mf it bd mg mh ok mj mk ml ol mn mo jz om ka mq kc on kd ms kf oo kg mu mv bi translated"><strong class="ak">作文</strong></h1><p id="4a54" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">合成是聚合的一个特例。组合是指一个对象包含另一个对象，而被包含的对象离不开容器对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/10e9b2c72cdbe2393037a3b4a0268b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*kflHP6jyCELljR5GvCnIsA.jpeg"/></div></figure><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1a91" class="mw mf it nq b gy nv nw l nx ny">let Book = {<br/>   "title": "The Alchemist", <br/>   "author": "Paulo Coelho",<br/>   "publication": {<br/>      "name": "new publication Inc",<br/>      "address": "chennai"<br/>   }<br/>}</span></pre><p id="47bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里属性publication与<code class="fe nn no np nq b">Book</code>对象严格绑定，publication离不开<code class="fe nn no np nq b">Book</code>对象。如果删除了<code class="fe nn no np nq b">Book</code>对象id，那么发布也将被删除。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="bf53" class="me mf it bd mg mh ok mj mk ml ol mn mo jz om ka mq kc on kd ms kf oo kg mu mv bi translated">继承之上的组合</h1><p id="b3af" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">继承是指一个对象基于另一个对象。例如，book1继承了图书的属性和方法，如标题、作者和摘要。于是就产生了<code class="fe nn no np nq b">book1</code> <strong class="kw iu"> <em class="nz">是- </em>一本</strong>的关系。</p><p id="011c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组合就是收集简单的对象，然后将它们组合起来，构建更复杂的对象。为了建造，我们需要方法，像纸和笔。因此它创建了一个关系，即book1 <strong class="kw iu"> <em class="nz">拥有- </em>一张</strong>纸和一支笔:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="3f01" class="mw mf it nq b gy nv nw l nx ny">const getTitle = (data) =&gt; ({<br/>   title : () =&gt; console.log(`title : ${data.title}`)<br/>});</span><span id="dd63" class="mw mf it nq b gy oa nw l nx ny">const getAuthor = (data) =&gt; ({<br/>   author : () =&gt; console.log(`author: ${data.author}`)<br/>});</span><span id="ff25" class="mw mf it nq b gy oa nw l nx ny">const getSummary = () =&gt;  ({<br/>   summary :() =&gt; console.log(`book summary need to update.`)<br/>});</span><span id="7f2a" class="mw mf it nq b gy oa nw l nx ny">const Book = (title, author) =&gt; {<br/>   const data = { <br/>      title, <br/>      author  <br/>   }<br/>   <br/>   return Object.assign({},<br/>             getTitle(data), <br/>             getAuthor(data), <br/>             getSummary()<br/>   )<br/>}</span><span id="7587" class="mw mf it nq b gy oa nw l nx ny">let book1 = Book('The Alchemist', 'Paulo Coelho');</span><span id="053b" class="mw mf it nq b gy oa nw l nx ny">book1.title();<br/>&gt;   "title : The Alchemist"</span></pre></div></div>    
</body>
</html>