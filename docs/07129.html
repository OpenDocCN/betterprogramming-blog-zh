<html>
<head>
<title>8 Things to Know to Master Python Function Arguments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Python函数参数需要知道的8件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-things-to-know-to-master-python-function-arguments-75ed7597463e?source=collection_archive---------9-----------------------#2020-12-09">https://betterprogramming.pub/8-things-to-know-to-master-python-function-arguments-75ed7597463e?source=collection_archive---------9-----------------------#2020-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="09cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">要编写可读的Python函数，您只需知道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5e621ceb2d755376c148d1423407352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I5MDkRfRN-CsC0eV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马克·马沙尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="358a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们总是在项目中使用函数——不管我们的项目是关于什么的。当我们调用他人编写的函数时，我们需要理解函数签名(即，我们应该传递什么参数来获得期望的函数输出)。有时，当我们应该清楚期望的用例而不引起任何歧义时，我们需要编写函数供其他人调用。无论哪种情况，都不是最轻松的工作。</p><p id="4320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将提供Python函数中参数的全面概述。具体来说，我指的是输入参数。我希望这篇文章可以消除您在调用他人的函数或定义自己的函数时可能遇到的任何问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac67" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.位置和关键字参数</h1><p id="7d02" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，有两种输入参数:位置参数和关键字参数。根据<a class="ae ky" href="https://docs.python.org/3.8/glossary.html" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="mz"><p id="3593" class="na nb it bd nc nd ne nf ng nh ni lu dk translated"><em class="nj">关键字参数</em>:函数调用<br/> <em class="nj">中标识符(如<code class="fe nk nl nm nn b">name=</code>)前的参数位置参数</em>:不是关键字参数的参数。</p></blockquote><p id="b199" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">下面是内置<code class="fe nk nl nm nn b">open</code>函数的函数签名:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="2baa" class="nx md it nn b gy ny nz l oa ob">open<!-- -->(<em class="oc">file</em>, <em class="oc">mode='r'</em>, <em class="oc">buffering=-1</em>, <em class="oc">encoding=None</em>, <em class="oc">errors=None</em>, <em class="oc">newline=None</em>, <em class="oc">closefd=True</em>, <em class="oc">opener=None</em>)</span></pre><p id="c8be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，文件参数是位置性的，而所有其他参数都是关键字，因为每个参数都有一个标识符(即关键字)。我们可以调用如下所示的函数。在该调用中，<code class="fe nk nl nm nn b">“hello.txt”</code>将被设置为<code class="fe nk nl nm nn b">file</code>参数，而<code class="fe nk nl nm nn b">“w”</code>将被设置为<code class="fe nk nl nm nn b">mode</code>参数。</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="4224" class="nx md it nn b gy ny nz l oa ob">open(<strong class="nn iu">"hello.txt"</strong>, mode=<strong class="nn iu">"w"</strong>)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="846d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.仅关键字参数</h1><p id="5f37" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在示例abive中，我们将<code class="fe nk nl nm nn b">“w”</code>显式设置为适用的关键字参数。但是，在现实中，我们可以根据位置隐式设置关键字参数，如下所示:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="bc44" class="nx md it nn b gy ny nz l oa ob">open(<strong class="nn iu">"hello.txt"</strong>, <strong class="nn iu">"w"</strong>)</span></pre><p id="1eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，如果我们自己定义一个函数，关键字参数可以通过它们对应的位置来设置。下面显示了一个简单的例子，与内置的<code class="fe nk nl nm nn b">open</code>函数的调用一致:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">关键字参数</p></figure><p id="85df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们有多个关键字参数时(为了简单起见，我们的例子只包括一个关键字参数)，很难判断这些参数是否由位置设置。因此，为了明确起见，我们可以只定义关键字参数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仅关键字参数</p></figure><ul class=""><li id="a858" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">函数签名在<code class="fe nk nl nm nn b">multiplier</code>参数前包含一个星号(即星号)。这意味着在星号之后，所有的参数都必须由关键字来设置。这些参数只能通过指定关键字来设置，称为仅关键字参数。</li><li id="c038" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">与意图一致，当我们调用函数而没有为第二个参数指定关键字时，我们得到一个<code class="fe nk nl nm nn b">TypeError</code>。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4764" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.仅位置参数</h1><p id="9d09" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们刚刚学习了如何定义只有关键字的参数。你可能会想，“他们的位置论点对应的怎么样？”您的直觉是正确的——我们也可以定义仅位置参数(Python 3.8+)。</p><p id="cc86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不使用星号，而是使用斜线符号(<code class="fe nk nl nm nn b">/</code>)来表示斜线之前的所有参数都是严格位置性的。换句话说，不能通过指定它们的标识符或关键字来设置它们。以下代码片段向您展示了这种用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仅位置参数</p></figure><ul class=""><li id="e5a5" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">我们定义了两个函数:<code class="fe nk nl nm nn b">custom_sum</code>和<code class="fe nk nl nm nn b">custom_sum_pos</code>。</li><li id="409c" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">在<code class="fe nk nl nm nn b">custom_sum</code>函数中，<code class="fe nk nl nm nn b">iterable</code>参数可以指定为位置参数或关键字参数。</li><li id="e4c2" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">然而，在<code class="fe nk nl nm nn b">custom_sum_pos</code>函数中，<code class="fe nk nl nm nn b">iterable</code>参数只能被指定为位置参数。如您所见，如果我们为函数调用提供标识符，它会引发一个<code class="fe nk nl nm nn b">TypeError</code>。换句话说，<code class="fe nk nl nm nn b">iterable</code>参数是位置唯一的，这意味着它只能通过在所需位置传递参数来设置。</li></ul><p id="4677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，我们可以在同一个函数定义中组合使用星号和斜杠，这将导致只有位置和只有关键字的参数。注意下面的<code class="fe nk nl nm nn b">TypeError</code>。这是预料中的事，因为<code class="fe nk nl nm nn b">arg1</code>在斜线符号之前:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仅位置和仅关键字参数</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2338" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.可变数量的位置参数(*args)</h1><p id="799f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数声明中另一个有用的特性是可变数量的位置参数的定义。让我们快速看一下<code class="fe nk nl nm nn b">print</code>函数的函数签名:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="5c32" class="nx md it nn b gy ny nz l oa ob">print<!-- -->(<em class="oc">*objects</em>, <em class="oc">sep=' '</em>, <em class="oc">end='\n'</em>, <em class="oc">file=sys.stdout</em>, <em class="oc">flush=False</em>)</span></pre><p id="8dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<code class="fe nk nl nm nn b">print</code>功能时，我们可以做不同的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打印功能的使用</p></figure><p id="2e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们可以为<code class="fe nk nl nm nn b">print</code>函数传递多个对象。神奇的是，这些单独的对象被打包成一个元组，并作为一个整体分配给<code class="fe nk nl nm nn b">objects</code>参数。如果您仍然感到困惑，让我们考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">*参数的示例</p></figure><p id="f82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的<code class="fe nk nl nm nn b">greet</code>函数中，我们包含了一个名为<code class="fe nk nl nm nn b">*persons</code>的参数。根据函数调用的打印输出消息，您可以了解到多个名称确实被打包到一个元组对象中，并被发送给<code class="fe nk nl nm nn b">persons</code>参数以供使用。</p><p id="e80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可变数量的位置参数是保持函数签名简洁的一个巧妙技巧，同时允许传递多个对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf00" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.可变数量的关键字参数(**kwargs)</h1><p id="3457" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与<code class="fe nk nl nm nn b">*args</code>(即可变数量的位置参数)相对应的是<code class="fe nk nl nm nn b">**kwargs</code>，它表示可变数量的关键字参数。它的用法并不少见。看看<code class="fe nk nl nm nn b">dict</code>构造函数的函数签名:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="1387" class="nx md it nn b gy ny nz l oa ob"><em class="oc">class </em>dict<!-- -->(<em class="oc">**kwarg</em>)</span></pre><p id="1546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用这个构造函数，我们可以做以下事情。本质上，我们通过设置一系列关键字参数来创建字典:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">词典的创建</p></figure><p id="bab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与内置的<code class="fe nk nl nm nn b">dict</code>构造函数类似，我们可以使用可变数量的关键字参数特性来定义自己的函数，如下面的代码片段所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">**kwargs示例</p></figure><ul class=""><li id="2402" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">我们使用<code class="fe nk nl nm nn b">**grades</code>来表示函数声明中关键字参数的可变数量。</li><li id="c7e5" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">在函数调用中，我们使用学生的名字作为标识符，传递带有成绩的学生列表。</li><li id="84e6" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">从打印输出中，您可以注意到这些带有等级的名称被打包到一个字典对象中(即<code class="fe nk nl nm nn b">grades</code>参数)。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b5c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.默认可变参数</h1><p id="3b16" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们声明Python函数时，我们可以为参数设置默认值。例如，前面的一个例子(<code class="fe nk nl nm nn b">custom_sum</code>函数)用一个<code class="fe nk nl nm nn b">start</code>值计算一个iterable的总和。在函数中，我们将start参数的默认值设置为<code class="fe nk nl nm nn b">0</code>。然而，如果我们要处理一个可变的论点，这就变得更棘手了。考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可变参数:默认值</p></figure><ul class=""><li id="a5cf" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated"><code class="fe nk nl nm nn b">append_score</code>函数包括一个作为列表对象的参数(<code class="fe nk nl nm nn b">scores</code>)。在声明中，我们将其指定为空列表。</li><li id="c6fc" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">当我们在没有设置<code class="fe nk nl nm nn b">scores</code>参数的情况下调用这个函数时，我们希望分数被附加到一个空列表中。第一次调用(即<code class="fe nk nl nm nn b">append_score(98)</code>)时，这种情况会如期发生。然而，它不会发生第二次(即<code class="fe nk nl nm nn b">append_scored(94)</code>)。</li><li id="b670" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">正如你可能注意到的，当我们没有为<code class="fe nk nl nm nn b">scores</code>参数指定列表对象时，我们有相同的列表对象，如为<code class="fe nk nl nm nn b">scores</code>列表显示的相同内存地址(即<code class="fe nk nl nm nn b">id()</code>函数调用)。这意味着当调用不提供<code class="fe nk nl nm nn b">scores</code>参数时，函数使用相同的列表对象。</li></ul><p id="cd67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是当我们声明<code class="fe nk nl nm nn b">append_score</code>函数时，Python已经对函数声明进行了求值，并为我们创建了list对象。以下代码向您展示了我们如何检索默认列表。如您所见，这个默认对象是相同的列表对象(即相同的内存地址)，如上面的函数调用所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可变参数的默认对象</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2a2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.类型注释</h1><p id="a634" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管Python是一种动态类型的编程语言，我们在创建变量时不需要指定对象类型，但它的版本已经包含了注释变量类型的特性。这个特性也可以用于函数参数。用法非常简单——我们可以简单地将类型放在参数名之后，同时保持其他一切不变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/9fb5fc9a22d06adbc7fe1f87cdc842ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEtR9r5-IRw4JyQ53vpvkQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/762def9c90c74d32925d0bfe1355647a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJfKM_49-FQdLF6XMQpe-w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参数的类型注释</p></figure><ul class=""><li id="e76e" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated"><code class="fe nk nl nm nn b">dispense_salary_typed</code>函数的参数已输入。</li><li id="e8d8" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">显而易见的优点是，当您使用IDE(例如PyCharm)编写Python代码时，您会得到通过指定正确的数据类型来调用函数的提示。对比见上面截图。</li></ul><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="5a5a" class="nx md it nn b gy ny nz l oa ob">&gt;&gt;&gt; def dispense_salary_typed(employee: str, amount: float):<br/>...     pass<br/>... <br/>&gt;&gt;&gt; dispense_salary_typed(1, "amount")</span></pre><ul class=""><li id="c3da" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">应该注意的是，当您调用函数时，类型注释本身不会强制进行类型检查。如上所示，您仍然可以毫无问题地调用该函数。这就是我们称之为注释的原因。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bd54" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.参数的文档字符串</h1><p id="79f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们不必为我们定义的所有函数编写docstrings，我相信在许多情况下代码应该很好地解释自己。但是，如果您为其他Python用户准备API，最好的做法是拥有可读的文档字符串(在本例中，是您的函数的文档字符串)。因为我们讨论的是函数参数，所以我将简单地关注参数的文档字符串中应该有哪些元素。</p><ul class=""><li id="de1b" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">第一个元素是参数的预期类型。</li><li id="a6d6" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">第二个要素是对论点预期用途的解释。换句话说，阐明该参数将如何在函数中使用。</li><li id="74dd" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">如果参数包括一个默认值，你要把它说清楚，必要时解释默认行为。</li></ul><p id="be47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段显示了Python函数的文档字符串的一个简单示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参数的文档字符串</p></figure><p id="ac14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用function对象的<code class="fe nk nl nm nn b">__doc__</code>特殊方法，可以方便地检索文档字符串，如下所示:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="cedc" class="nx md it nn b gy ny nz l oa ob">&gt;&gt;&gt; print(dispense_salary_typed.__doc__)<br/>    Dispense the salary to the employee<br/>    :param employee: str, the name of the employee<br/>    :param amount: float, the amount of the salary (default 1000.0)<br/>    :return: None</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7eef" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="8573" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了与Python函数参数相关的八件事。以下是使用这些功能时的一些重点和注意事项。</p><ul class=""><li id="6da6" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">Python有位置参数和关键字参数，前者由位置指定，后者由关键字指定。</li><li id="9d27" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">使用<code class="fe nk nl nm nn b">*args</code>(可变数量的位置参数)和<code class="fe nk nl nm nn b">**kwargs</code>(可变数量的关键字参数)可以方便地编写更简洁的函数签名。然而，滥用它实际上会降低代码的可读性。</li><li id="7292" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">如果参数名称很复杂，那么仅位置参数会很有用。如果您以后更新您的API，它还有一个好处。如果您更改参数名，您的API不会中断，因为仅位置参数的调用不涉及调用参数名。</li><li id="fdb0" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">当您希望代码的用户明确了解特定意图时，仅关键字参数特别有用。您可能已经体验过，过多的位置参数会使函数调用难以阅读。因此，函数调用中只有关键字的参数可读性会更好。</li></ul></div></div>    
</body>
</html>