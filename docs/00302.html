<html>
<head>
<title>The Universal Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通用函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-universal-function-2e3b3fa063e6?source=collection_archive---------0-----------------------#2019-03-11">https://betterprogramming.pub/the-universal-function-2e3b3fa063e6?source=collection_archive---------0-----------------------#2019-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8707" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于JavaScript、函数和函数式编程的思考</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c96af72e1268e69146dc2e610aac5f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EXLsMWPwp24mbhFa_rp2Pw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/photos/fCEJGBzAkrU" rel="noopener ugc nofollow" target="_blank">杰佛森·桑多斯</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码块的层次之上——在代码块中，使用循环和条件语句(如<code class="fe lv lw lx ly b">for()</code>和<code class="fe lv lw lx ly b">if()</code>规则)进行流控制——是函数。</p><p id="734a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像吉他弹奏中的和弦一样，理解函数既是基本编码的入口，也是掌握的关键。</p><p id="ea9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数是如此重要，因为它是我们在软件开发中如何应对复杂性的最基本的表现。</p><p id="13b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将把这个基本的东西叫做<em class="lz">外壳和接口</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f56be0f05356570df512b955d39cc56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*D342seAIohYr4zUNEZmVpw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">外壳和接口</p></figure><p id="4ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种结构在整个堆栈、分层和微服务架构、系统和开发运维中反复出现。无论你走到哪里，当我们面对复杂性时，它都会突然出现。</p><p id="b299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这是将解决方案分解成包含其内部复杂性的更小的离散元素，然后通过接口相互交互来解决更大问题的本质。</strong></p><h2 id="af85" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">函数式编程</h2><p id="2751" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们考虑<em class="lz">函数式编程</em> (FP)时，那么，简单的问题应该是:如何最好地使用函数来分解系统以管理复杂性？</p><p id="9f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信关键是始终记住(当我们写代码和考虑设计方法时)我们在使用功能时应用基本的软件设计。</p><p id="10c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能是一个<em class="lz">工具</em>来应用可靠的软件设计原则。</p><p id="db40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，也就是说，工具<em class="lz">服务于</em>原理。(通过掌握这一点，我们可以掌握FP的工具，而不会被时尚所吸引。)</p><p id="46fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种技能在我们构建软件时会接触到的所有东西中都有体现:函数、对象、包、模块、远程API。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="a87d" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">内部设计，外部架构</h1><p id="16b4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数允许我们把软件分成内部和外部。这是普遍的功能。</p><p id="2871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数是我们如何在软件开发中解决复杂性的一些基本问题的表现。</p><p id="fc37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们可以孤立的思考一下功能的<em class="lz">内部设计</em>，然后再到更高的层次，把功能的关系当做<em class="lz">外部架构来思考。</em></p><p id="3ce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界的应用程序中，函数之间的相互关系是复杂的。您希望能够在尽可能远离实现的逻辑层次上考虑该架构。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="2db8" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">外壳和接口</h1><p id="dd31" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数的基础很简单:它是一段可调用的代码，接受0-n个参数，并可能返回值。</p><p id="b336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在那个简单的想法里是<em class="lz">外壳的力量。</em>函数内部的代码与其他代码隔离，对代码的访问通过其签名(又名，其API，又名，其<em class="lz">接口)来控制。</em></p><p id="705d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，这与我们使用对象(封装称为封装)、模块/包以及远程API(如RESTful服务)的目的是一样的。</p><p id="b279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在考虑设计时，这个概念有时被称为<em class="lz">关注点分离。</em>有了这个想法，我们将重点放在概念复杂性的管理上。这个概念框架在函数中表现为可变上下文的隔离。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="5dc4" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">能见度</h1><p id="2299" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在JavaScript中，术语<em class="lz">上下文</em>和<em class="lz">范围</em>被明确定义为<em class="lz">。</em>想法是这样的:哪些变量是可见的(作用域)，解析<code class="fe lv lw lx ly b">this</code>关键字的对象是什么(上下文)？</p><p id="af2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(当我指“范围”时，我经常使用“上下文”哦好吧。重要的是理解这些东西是如何工作的。)</p><p id="d45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">归结起来就是<em class="lz">可变能见度。</em></p><p id="c533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可变可见性有两个关键方面:</p><ul class=""><li id="ebdf" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">信息隐藏:我在函数中声明的东西只有在那里才是可见的。</li><li id="ddfc" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu">变量范围:</strong>在我的函数中，总共有哪些变量是可见的？</li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="6901" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">信息隐蔽</h1><p id="b528" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除了推入全局范围的未修改的变量(没有显式声明的变量名)之外，我们在函数中定义的所有内容仅对该函数及其嵌套的子级可见。</p><p id="4200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JS中，我们有三种选择:var、let和const。我这里大概要追那只兔子四段。</p><p id="96de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">var</code>声明被“提升”到函数参考框架，也就是说，无论在哪里声明，它们对整个函数都是可见的。这是最不可取的，因为在编写代码时，我们想要尽可能小的内存占用，但仍能实现目标。</p><p id="a8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(话虽这么说，我还是用var，我觉得还好。通常，一个变量确实存在于整个函数体中——通常，在函数的头部定义这些变量。</p><p id="c44b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">let</code>声明包含在当前代码块中。所以，我们可以用<code class="fe lv lw lx ly b">let</code>把变量的范围细化到循环或者if块之类的。这很好，因为它保持了较小的影响范围。</p><p id="6c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">const</code>在影响区域方面的行为类似于<code class="fe lv lw lx ly b">let</code>，但是增加了不允许变量被重新赋值的额外限制。常量是一个很好的选择，因为它进一步约束了变量，并在考虑代码如何工作时限制了变量。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="a6b2" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">可变地平线</h1><p id="4c83" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们知道我们定义的变量在函数及其块中是如何可见的。函数的变量范围中还有另外两个重要的特性:全局变量和“词法范围”变量。</p><p id="0f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">全局变量是不言自明的:它们存在于应用程序的任何地方。通常，它们只是一个错误或一个坏主意。然而，在某些情况下(比如在React/Angular/Vue中提供一个中央存储)，它们是值得的。</p><p id="ea95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何情况下，你的函数都可以看到全局变量。小心名称冲突！</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="7766" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">词法范围的变量</h1><p id="45d3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我对“词法范围”这个名字很失望，因为它看起来很复杂，会让人无法理解。这确实是JS函数的一个简单但重要的特性——在另一个函数中声明的函数可以访问包含的函数变量。</p><p id="560f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢“嵌套函数可见性”这个名字(但是没人问我)。</p><p id="9546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">词法范围非常有用。它的基本含义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">词汇范围</p></figure><p id="111a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这对于具有高阶函数(尤其是作为参数的函数)和匿名内联函数的函数式编程有着更重要的意义。让我们深入研究一下。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="6520" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">函数式编程</h1><p id="b294" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数式编程(FP)实际上仅仅意味着考虑软件的结构，强调功能作为排序原则。就对象而言，这类似于面向对象的编程。</p><p id="e32e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程的细节围绕着如何最好地部署函数作为组织原则。</p><p id="7c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这主要意味着将函数作为可以传递的离散功能块来使用，从而强调编程中所谓的<em class="lz">声明性</em>方面。</p><p id="327a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，FP没有定义对集合进行操作的循环，而是定义了一个应用于集合的函数。</p><p id="a219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这通常会减少代码行的数量，并且可以(<em class="lz"> can) </em>提高可读性，因为与“命令式”循环修改代码相比，使用类似<code class="fe lv lw lx ly b">myCollection.reduce(x =&gt; x &gt; 10)</code>的调用确实非常简洁。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="dbf2" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">一级功能:JS超能力</h1><p id="6973" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JS如此成功的一个重要原因是它在功能上的灵活性。它从一开始就支持函数引用(即作为“数据”的函数)和匿名函数。</p><p id="ce6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程最明显的例子是将匿名函数作为参数传递。</p><p id="6dcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">foo(function(x){ return x+10 }</code></p><p id="1196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们调用了<code class="fe lv lw lx ly b">foo()</code>函数，并传入了另一个内联定义的函数。这是一种有效的编码形式，因为它允许代码的作者和读者将功能组合到语句中。</p><p id="7345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正是这种事情刺激了“胖箭头”语法的引入。</p><p id="847a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">foo(x =&gt; x+10)</code></p><p id="7d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成同样的事情。</p><p id="1cf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有情况下，匿名函数都可以访问作用域内的父函数变量。</p><p id="0e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">粗箭头语义<em class="lz"> </em>在携带词法范围<code class="fe lv lw lx ly b">this</code>方面也有所不同——这有时是一个非常有用的特性。(我认为这一特点在这一点上已经得到了很好的理解和利用。)</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="9457" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">胖箭头匿名函数:函数式编程的明星</h1><p id="7a5c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当人们说“函数式编程”时，最突出的意思可能是使用匿名函数作为参数，如上所述。尤其是有趣的新胖箭头语法。</p><p id="8e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些东西<em class="lz">爽！</em></p><p id="20f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(顺便说一句，任何时候软件行业有什么很酷的东西，<em class="lz">当心。</em>)</p><p id="e414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能是应用可靠的软件设计原则的工具。你在Angular和它对RxJS的大量使用中看到了它:</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="fa7b" class="mb mc it ly b gy ol om l on oo">Observable.from(movieLists)<br/>  .map(movie =&gt; movie.videos)<br/>  .concatAll()<br/>  .map(movie =&gt; movie.id);</span></pre><p id="839d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在Vue中看到:</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="e932" class="mb mc it ly b gy ol om l on oo">export default {<br/>  // ...<br/>  computed: mapState({<br/>    count: state =&gt; state.count</span></pre><p id="3557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应过来(来自<a class="ae ky" href="https://medium.com/silesis/handle-events-in-react-with-arrow-functions-ede88184bbb" rel="noopener">本中文章</a>):</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="d472" class="mb mc it ly b gy ol om l on oo">render() {<br/>   return(&lt;MyInput onChange={ (e) =&gt; this.handleOnChange(e) } /&gt;)<br/>}</span></pre><p id="974a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些用法通常是有效的。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="4139" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">简洁与模糊</h1><p id="51fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">匿名函数的美妙之处在于允许思想/代码的流动不间断地进行。(换句话说:它对<em class="lz">内部设计的好处，</em>多于<em class="lz">外部架构</em>。)</p><p id="e01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">危险在于过度压缩代码——而您不想压缩代码，这可能会很痛苦。</p><p id="cac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严肃地说，简洁的代码是伟大的，直到它开始看起来像Perl。</p><p id="1421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是简洁是否变成了混淆？</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="f6aa" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">高阶函数</h1><p id="5c31" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">FP提倡使用“高阶函数”——即返回其他函数或接受它们作为参数的函数。(在后一种情况下，我称它们为元函数或函数工厂。)</p><p id="7869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是工具(函数)有时会压倒原则(组织良好且可读的代码)的另一个领域。</p><p id="5d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码库中，有几次我不得不拆开紧密嵌套的高阶函数，用箭头函数来使事情更清楚并识别逻辑错误。</p><p id="a765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以听到编码人员在想:“这太简单明了了，我需要使用一个返回另一个函数的函数，并在其上使用一个粗箭头。这些都是很受欢迎的新想法和语法，它们肯定是最好的方法。”</p><p id="e28b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在哪里见过这种密集的功能链接被描述为诗歌。好像这就是代码的理想。不是真的！</p><p id="d048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码应该是简洁的散文，而不是诗歌！</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="ac68" class="ng mc it bd md nh ni nj mg nk nl nm mj jz nn ka mm kc no kd mp kf np kg ms nq bi translated">结果</h1><p id="77b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个函数的内部应该努力达到清晰的理想状态。函数的外部形式(它的签名或接口)应该尽可能的小，并且不特定于实现。</p><p id="71b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，我们可以考虑函数的参数和目的，只考虑它的设计目的，忽略它所处的更广泛的环境。</p><p id="6906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它公开的接口表面应该尽可能小，以允许客户端代码将该函数视为执行服务的黑盒，并暗示实现该服务的最小依赖量。</p><p id="d5fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些原则同样适用于对象、模块和库中的函数集合，以及公开远程API。</p><p id="cf92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住我们想要达到的目标(可读的、有组织的和可维护的代码)将有助于我们避免使用中的不平衡，同时利用它们有意义的地方。</p><p id="8dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这确实是一个普遍的功能。</p></div></div>    
</body>
</html>