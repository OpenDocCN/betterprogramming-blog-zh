<html>
<head>
<title>TypeScript: Generic Function-Parameter Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:泛型函数参数类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-generic-objects-1eecc13dca93?source=collection_archive---------1-----------------------#2019-12-02">https://betterprogramming.pub/typescript-generic-objects-1eecc13dca93?source=collection_archive---------1-----------------------#2019-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1ef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何修改TS中的对象属性，同时保持参数的通用性和函数的可重用性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4b36b252c144180687de9a2d14c75b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QwRdAxb9Q8wejjQJiFJsQ.png"/></div></div></figure><p id="67d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在这里捆绑了一些lovley示例代码<a class="ae lq" href="https://github.com/vleandersson/example-typescript-generics" rel="noopener ugc nofollow" target="_blank"/></p><p id="5781" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在TypeScript/JavaScript中修改对象属性是我们作为程序员首先要学习的东西。我们可以直接修改属性(<code class="fe lr ls lt lu b">foo.bar = ‘test’</code>)或者创建一个浅拷贝(<code class="fe lr ls lt lu b">const shallowFoo = {…foo, bar: ‘test’}</code>)。</p><p id="c25e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">快速思考一下就会发现，大多数情况下，像这样修改对象背后都有某种业务逻辑。毕竟，我们希望更新对象属性是有原因的。</p><p id="232d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将这种逻辑转移到一个助手函数中，我们可以轻松地测试和重用代码以保持干燥(<em class="lv">不要重复自己— </em>源自安迪·亨特和迪夫·托马斯的《实用程序员》中的一句口头禅)。但是一个新的挑战出现了:我们如何保持这些助手函数的通用性，同时给它们一个单一的、清晰的目的？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="628b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">问题是</h1><p id="ca26" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated"><a class="ae lq" href="https://github.com/vleandersson/example-typescript-generics" rel="noopener ugc nofollow" target="_blank">参见示例代码</a>中的示例A1。</p><p id="e23c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地描述这个问题，本文将使用一个虚构的例子，在这个例子中，我们将修改传入对象的id。</p><p id="e4c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个例子将为来自API的所有id添加一个前缀，以便将它们与我们的应用程序正在使用的框架生成的id区分开来。在这个例子中，我们将使用的接口描述包含两个属性的产品:<code class="fe lr ls lt lu b">id</code>和<code class="fe lr ls lt lu b">price</code>。</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="0884" class="ne me it lu b gy nf ng l nh ni">interface ProductData {<br/>  id: string;<br/>  price: number;<br/>}</span></pre><p id="2e90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检索数据并将前缀<code class="fe lr ls lt lu b">product-id:</code> <em class="lv"> </em>添加到<code class="fe lr ls lt lu b">id</code>属性中:</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="582b" class="ne me it lu b gy nf ng l nh ni">const productData: ProductData = {id: '123', price: 10};</span><span id="01eb" class="ne me it lu b gy nj ng l nh ni">const mappedProductData = {<br/>  ...productData,<br/>  id: `product-id: ${productData.id}`<br/>};</span></pre><p id="4af0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">`product-id: ${productData.id}`</code>是字符串文字。点击此处了解更多信息。</p><p id="5502" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这成功地将<code class="fe lr ls lt lu b">ProductData</code>映射到它的首选格式。乍一看，这看起来相当不错。但是这个功能是不可重用的，并且鼓励复制过去的行为，打破了枯燥的咒语。这可以通过将业务逻辑分解成一个单独的功能来解决，使代码更具可重用性。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="acdd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">基本可重用功能</strong></h1><p id="a56a" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated"><a class="ae lq" href="https://github.com/vleandersson/example-typescript-generics" rel="noopener ugc nofollow" target="_blank">参见示例代码</a>中的示例A2。</p><p id="a743" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将逻辑分解成一个独立的函数，使代码变得易于重用，我们程序员可以向产品所有者保证,<code class="fe lr ls lt lu b">id</code>属性总是以同样的方式变化。</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="05b4" class="ne me it lu b gy nf ng l nh ni">function mapProductData(productData: ProductData) {<br/>  return {<br/>    ...productData,<br/>    id: `product-id: ${productData.id}`<br/>  };<br/>}</span></pre><p id="a187" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以调用这个函数:</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="d12e" class="ne me it lu b gy nf ng l nh ni">const mappedProductData = mapProductData({id: '123', price: 10});</span></pre><p id="4113" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这创建了一个可重用的函数，它只有一个明确的目的——给<code class="fe lr ls lt lu b">id</code>属性添加一个前缀。但是这个解决方案有几个问题。首先，对象类型<code class="fe lr ls lt lu b">ProductData</code>丢失，函数返回带有未命名接口的对象:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/b15887d6a0d7312cf48dca1c3667a314.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*BMAAgdL6I3pqtAOactjNXw.png"/></div></figure><p id="5759" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其次，函数被强制总是使用<code class="fe lr ls lt lu b">ProductData</code>形状作为参数类型。否则，TypeScript可能会给你一个林挺错误。或者更糟:我们与我们的界面失去了同步。(参见示例代码中的<a class="ae lq" href="https://github.com/vleandersson/example-typescript-generics" rel="noopener ugc nofollow" target="_blank">示例A3 </a>。)</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e01d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案</h1><p id="2538" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated"><a class="ae lq" href="https://github.com/vleandersson/example-typescript-generics" rel="noopener ugc nofollow" target="_blank">参见示例代码</a>中的示例A4。</p><p id="dc97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了继续，我们必须重新考虑函数参数的方法。到目前为止，我们使用了一个固定类型的参数:一个同时需要<code class="fe lr ls lt lu b">id</code>和<code class="fe lr ls lt lu b">price</code> <em class="lv"> </em>属性的对象。</p><p id="7c9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是所执行的映射只需要知道<code class="fe lr ls lt lu b">id</code> <em class="lv"> </em>属性。通过在TypeScript中描述这种所需的最小形状，可以为函数创建更精确的契约。这可以描述为:</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="8af1" class="ne me it lu b gy nf ng l nh ni">interface MinimumProductData {<br/>  id: string;<br/>}</span></pre><p id="359e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使映射函数更加通用，该函数必须接受任何至少满足<code class="fe lr ls lt lu b">MinimumProductData</code>的对象。我们可以通过使用TypeScript的泛型类型来做到这一点。</p><p id="e906" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是事情变得有点棘手的地方。让我们先快速复习一下关于泛型的知识。在函数减速中，泛型在函数名后定义为:<code class="fe lr ls lt lu b">&lt;T&gt;</code>。</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="0d8f" class="ne me it lu b gy nf ng l nh ni">function foo&lt;T&gt;() {<br/>  ...logic goes here<br/>}</span></pre><p id="f41f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lv"> T </em>现在可以在函数本身、其参数和/或返回其类型内使用。为了自动将<em class="lv"> T </em>分配给一个类型，我们将我们的参数定义为类型<em class="lv"> T </em>。然后，TypeScript将自动从函数参数中获取类型，并将其分配给<em class="lv"> T </em>。</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="0c41" class="ne me it lu b gy nf ng l nh ni">function foo&lt;T&gt;(input: T) {<br/>  ...logic goes here<br/>}</span></pre><p id="3fe8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以无论调用foo时参数的类型是什么，<em class="lv"> T </em>都会假设。字符串类型的输入将强制<em class="lv"> T </em>成为字符串类型。类型对象和<em class="lv"> T </em>的输入将是类型对象。诸如此类…</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="adfa" class="ne me it lu b gy nf ng l nh ni">foo('bar'); // <!-- -->And T will be of type string.</span></pre><p id="fc38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到我们的例子:我们不想接收映射函数<code class="fe lr ls lt lu b">mapProductData</code>的字符串。我们甚至不想要一个通用对象。我们想要一个至少具有<code class="fe lr ls lt lu b">MinimumProductData</code>形状的对象(属性为<code class="fe lr ls lt lu b">id</code>)。</p><p id="4ba9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们要利用TypeScripts的关键字<code class="fe lr ls lt lu b">extends</code>的地方。<code class="fe lr ls lt lu b">extends</code>将确保我们的泛型类型至少是给定的形状。对于<code class="fe lr ls lt lu b">mapAnyProductData</code>，我们希望泛型类型至少包含<code class="fe lr ls lt lu b">MinimumProductData</code>。让我们命名为通用的<code class="fe lr ls lt lu b">TProduct</code>。这给了我们<code class="fe lr ls lt lu b">&lt;TProduct extends MinimumProductData&gt;</code>，函数可以接受任何输入对象，只要我们能在其上找到属性<code class="fe lr ls lt lu b">id</code>。</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="5ef9" class="ne me it lu b gy nf ng l nh ni">function mapAnyProductData&lt;TProduct extends MinimumProductData&gt;(anyProductData: TProduct) {<br/>  return {<br/>    ...anyProductData,<br/>    id: `product-id: ${anyProductData.id}`<br/>  };<br/>}</span></pre><p id="109e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且用法和以前完全一样:</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="ddc8" class="ne me it lu b gy nf ng l nh ni">const mappedProduct = mapAnyProductData({id: '123', price: 10});</span></pre><p id="c2c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，返回类型为空。键入返回可能很有诱惑力，但懒惰似乎是这里的最佳选择。TypeScript将为您完成这项工作并键入返回。这删除了不必要的代码，使它稍微容易阅读，特别是当我们进入更复杂的扩展时。</p><p id="a511" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，我们可以在整个应用程序中重用这个逻辑，不仅仅是针对特定的对象类型，而是针对包含属性<code class="fe lr ls lt lu b">id</code>的所有对象。所以…</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="61b7" class="ne me it lu b gy nf ng l nh ni">const mappedProduct = mapAnyProductData({<br/>  id: '123', <br/>  cost: 10, <br/>  type: 'horse', <br/>  currency: '£',<br/>});</span></pre><p id="4511" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">…同样有效。问题解决了！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a96e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">扩展不可变对象</h1><p id="4f0e" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated"><a class="ae lq" href="https://github.com/vleandersson/example-typescript-generics" rel="noopener ugc nofollow" target="_blank">参见示例代码</a>中的示例B1。</p><p id="3db4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，如果我们有一个不可变的对象，我们想添加extend，该怎么办呢？我们可以使用同样的方法。</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="c0eb" class="ne me it lu b gy nf ng l nh ni">interface <strong class="lu iu">MinimumProductData</strong> {<br/>  price: number;<br/>}</span><span id="dafc" class="ne me it lu b gy nj ng l nh ni">function <strong class="lu iu">mapProductData</strong>&lt;TProduct extends MinimumProductData&gt;(productData: TProduct) {<br/>  return {<br/>    ...productData,<br/>    <strong class="lu iu">priceWithVat</strong>: productData.price * 1.2<br/>  };<br/>}</span><span id="c44d" class="ne me it lu b gy nj ng l nh ni">const mappedProductData = <strong class="lu iu">mapProductData</strong>({price: <strong class="lu iu">10, </strong>type: 'car'});<br/><strong class="lu iu">console</strong>.log(mappedProductData.priceWithVat); // 12</span></pre><p id="c9f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里唯一的区别是返回的形状将被定义为:</p><pre class="kj kk kl km gt na lu nb nc aw nd bi"><span id="6b34" class="ne me it lu b gy nf ng l nh ni"><strong class="lu iu">MinimumProductData</strong> {<br/>  price: number;<br/>  type: string;<br/>} &amp; {<br/>  priceWithVat: number;<br/>}</span></pre><p id="6745" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数现在可以接受任何类型的对象，只要它包含<code class="fe lr ls lt lu b">price</code>属性，并且它将返回扩展名为<code class="fe lr ls lt lu b">priceWithVat</code>的相同类型。<strong class="kw iu"> <em class="lv"> </em> </strong>这成功地展示了一种扩展对象的方式，完整地包含了业务逻辑，并且消除了重复的需要。当在TypeScript中构建可伸缩的产品时，这是一个很好的发展方向。</p><p id="886f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，在检查TypeScript时，它会用&amp;符号(<code class="fe lr ls lt lu b">&amp;</code>)将原始类型和扩展类型分开。这简单地回到了<code class="fe lr ls lt lu b">mapProductData</code>获得了一个未命名的返回类型这一事实。但是如果我们要经历输入函数的麻烦，我们需要知道传入对象的完整大小，因此，函数不再是泛型的。</p><p id="d175" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只需坚持这样一个事实，即这是在我们的应用程序中查看扩展类型的一种新方式。在我看来，这是一个小的折衷，以实现可重用的、修改对象的单一用途的功能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1257" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><p id="dc15" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">因此，本文介绍了如何使用类型脚本的泛型类型来修改定义的对象。</p><p id="8eb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经介绍过，<code class="fe lr ls lt lu b">extends</code>关键字可以在TypeScript中描述函数参数<em class="lv"> </em>的最小形状。</p><p id="7383" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经表明，将业务逻辑分解成可重用的、单一用途的功能有助于创建更具可伸缩性的应用程序。</p></div></div>    
</body>
</html>