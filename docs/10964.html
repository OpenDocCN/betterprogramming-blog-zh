<html>
<head>
<title>The Principle Behind the Practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实践背后的原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-3-software-engineering-principles-and-practices-330f2fdbecc7?source=collection_archive---------15-----------------------#2022-02-07">https://betterprogramming.pub/exploring-3-software-engineering-principles-and-practices-330f2fdbecc7?source=collection_archive---------15-----------------------#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3dba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解我们为什么做这些事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34f7f9dcf78864eef31c45ffda7eb2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zK8o2N1IGWdh1gCi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·西门子在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有原则，也有实践。原则是放之四海而皆准的普遍真理。实践是一个原则的具体实现，可以根据情况而变化。</p><p id="5398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解两者之间的区别是变得明智的重要一步。当你理解了实践背后的原则，你就理解了我们为什么要做这些事情。你了解规则，也知道何时打破规则。理解实践背后的原理有助于你更加灵活，并在日常决策中运用良好的判断力。</p><p id="1fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探索软件工程世界中的一些原则和实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b3c9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试和验证</h1><p id="9fb1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为你的代码编写测试是一个公认的好习惯。如果我们同意应该编写测试，一些后续问题可能是:</p><ol class=""><li id="811b" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">多少代码覆盖率是足够的？</li><li id="e1af" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我应该在什么水平写我的测试？单元、集成还是端到端？</li><li id="5dd0" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">什么时候<em class="nn">不</em>写测试可以？</li></ol><p id="a949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是好问题。行业专家发表了他们的观点，我有我的观点，我相信你也有你自己的观点。根据一般经验，我对这三个问题的回答是:</p><ol class=""><li id="053c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/clean-code-with-unit-tests-5f28020828a5">争取100%的代码覆盖率</a>，但不要对此狂热。有时获得最后5%的覆盖率不值得投资回报。但是如果你不打算测试什么，你应该有一个很好的理由来证明为什么不这样做。</li><li id="1e30" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/when-to-write-end-to-end-tests-246d43b166d0">尽可能将测试放在测试金字塔的底层</a>。大多数事情都可以在单元和集成测试级别进行测试，这些测试的好处是易于编写和快速运行。像在电子商务网站结账或登录web应用程序这样的关键工作流应该通过端到端测试进行验证。</li><li id="6868" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://dev.to/thawkin3/comment/1ljli" rel="noopener ugc nofollow" target="_blank">在某些情况下，不为您的代码编写测试可能是合理的</a>。例如，如果您有一个单行CSS补丁，除了通过查看UI进行快速手动验证之外，可能没有其他好的方法来测试它。如果您在没有任何现有测试基础设施的情况下，在遗留代码库中进行小的更改，并且该库中的代码很少更改，那么您可能不需要编写自动化测试。</li></ol><p id="803a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这些是一些关于测试的一般实践和我对此事的简短想法，但是这些实践背后的原则是什么呢？我想到的一些，没有特定的顺序，是:</p><ol class=""><li id="5e31" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">我们应该将部署的风险降至最低。(编写自动化测试，拥有高测试覆盖率，做代码评审，实现持续集成管道就是我们实现这个原则的方式。)</li><li id="54be" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">我们更喜欢自动化重复的任务，而不是手动完成。(编写自动化测试是我们实现这个原则的方式。)</strong></li><li id="505a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">我们应该更喜欢快速反馈循环，这样我们就能很快知道自己做错了什么。</strong>(编写自动化测试，将测试推下测试金字塔，使用持续集成管道是我们实现这个原则的方式。)</li><li id="550f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我们应该通过只在最重要的事情上花费时间来最大化业务价值。(选择不狂热地追求100%的测试覆盖率，或者做出判断，不为难以验证的小变化编写测试，这可能是我们实现这个原则的方式。)</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="51b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">特征分支</h1><p id="03a0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与大量开发人员一起处理代码库的一个典型策略是使用特性分支。主分支充当代码库的真实来源，开发人员在编写新代码时从主分支创建特性分支。当开发人员准备将他的代码合并回主分支时，他创建一个合并请求，获得代码审查，根据需要的反馈进行更新，然后合并他的代码。</p><p id="43e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建合并请求时，一个好的做法是确保您的特性分支与来自master的最新代码保持同步。例如，如果您有一个比主功能晚10次提交的功能分支，那么这10次提交中的更改可能会影响您正在处理的功能。</p><p id="0854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，如果其他人也接触了您已经更改的相同代码行，您将会看到一个合并冲突，并且无论如何都必须将最新的内容从master加载到您的分支中来解决这些冲突。</p><p id="5cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但有时问题可能比这更隐蔽，在没有直接修改您已经处理的文件或导致合并冲突的情况下，一些影响您的功能的更改。如果您在仍然落后于master 10次提交的情况下合并代码，一旦两组更改都在master分支中，您可能会遇到功能中断或测试中断的问题。</p><p id="bfc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您的特性分支落后了几个提交，这总是一个问题吗？不一定。如果丢失的提交没有触及您正在处理的相同代码区域，那么即使您稍微落后于主分支，您也应该可以进行合并。或者，如果您正在开发一个由整个工程组织共享的大型构件，开发人员每天都要对其进行数百次承诺，那么保持最新代码的更新将是一件徒劳的事情。只要您在合并时合理地保持最新状态，就应该没问题。</p><p id="9809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们再来看看实践背后的原则。为什么我们要用master的最新版本来更新我们的特征分支？一些原则包括:</p><ol class=""><li id="f8d5" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">我们应该将部署的风险降至最低。(这与上一节的第一个原则相同。确保我们的特性分支也包含当前主分支中的其他变更有助于我们避免意外，并且是我们可以实现这一原则的一种方式。)</li><li id="97b2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">我们应该避免容易预防的错误。</strong>(我们不想对两个单独的分支出现的问题进行故障诊断，这两个分支单独运行良好，但在一起使用时会出现问题。我们也不希望在我们可以很容易地提前发现问题的时候，不得不与合并到master中的破损功能进行斗争。让我们的特征分支保持最新是我们实现这个原则的一种方式。)</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ae0f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">交流和宽松的礼仪</h1><p id="9e41" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们再看一个例子。这一次我们将讨论一个不太专业但对组织中的个人如何合作很重要的话题:沟通。</p><p id="7a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多公司使用Slack进行即时通讯。Slack允许您在公共渠道、私有渠道或直接消息中发送消息。公共通道中的消息每个人都可以查看，私有通道中的消息只有被邀请到该通道的人可以查看，而直接消息只有参与交换的两个人可以查看。</p><p id="a8e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个问题要问另一个团队，关于您遇到的一个问题。你把你的信息发送到哪里？</p><p id="46c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，你应该<a class="ae ky" href="https://levelup.gitconnected.com/slack-etiquette-ae65c35fa27b" rel="noopener ugc nofollow" target="_blank">更喜欢使用公共渠道而不是私人渠道和直接消息</a>。</p><p id="3952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在公共渠道发布消息有几个好处。它允许任何感兴趣的人参与对话。它确保了正确的人被包括在内，并减少了在各种私人渠道和直接消息中与多个不同人群进行多次相同对话的需要。它还通过与整个团队分享问题来减轻回答问题的负担，而不是只有一个人知道有问题。作为额外的奖励，Slack的搜索功能将允许其他人在未来搜索这个相同的问题，并找到他们需要的答案。</p><p id="6052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，不是每条信息都应该在公共频道。有些对话可能更私密，比如讨论招聘决定或薪酬变动。或者它们可能在本质上更加个人化。私人渠道和直接消息更适合这些类型的消息。</p><p id="54d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们应该在可能和适当的时候在公共渠道发布。惯例就是这样。现在让我们来看看实践背后的原则:</p><ol class=""><li id="6e07" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">我们应该让合适的人参与任何特定的对话。(如果你直接给一个人发信息，你可能会花一些时间从一个人转到另一个人，直到你找到合适的人或群体来交谈。或者，即使你已经找到了可以帮忙的人，团队的其他成员可能也需要了解正在发生的事情。在公共渠道发布问题是让每个人都了解情况并贯彻这一原则的一种方式。)</li><li id="7a7f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">我们应该尊重同事的时间。</strong>(如果你直接给某人发信息，你现在已经把回复的责任放在了他们身上。这个人可能很忙，他们可能不在办公室，或者他们甚至不知道答案。在公共渠道发布问题，让有能力且有空的团队成员回答，这是贯彻这一原则的一种方式。)</li><li id="6a78" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">我们应该有效和高效地沟通。</strong>(我说不清有多少次，我和四组不同的人连续四次进行同样的对话，直到我们最终进入同一个频道一起协调。在公共渠道张贴问题消除了这种冗余，是落实这一原则的一种方式。)</li><li id="285b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我们应该让人们容易找到相关信息。 (Slack的搜索功能把Slack变成了一个很棒的非正式文档工具。使用Slack和wiki页面是实现这一原则的两种方法。)</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7a31" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">避免货物崇拜</h1><p id="5e56" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在已经探索了一些实践和实践背后的原则。如果这些做法对你不起作用，那也没关系！</p><p id="e9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实践的好处在于它们本质上是灵活的。它们可能因公司、国家或文化而异。但是如果你重视并理解这些实践背后的原则，你将能够开发出适合你独特情况的实践。</p><p id="a63d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，要警惕那些跟随实践却不理解其背后原因的人。对软件开发策略或设计模式的教条主义导致不灵活、无效和<a class="ae ky" href="https://en.wikipedia.org/wiki/Cargo_cult_programming" rel="noopener ugc nofollow" target="_blank">货物邪教编程</a>。你应该总是能够解释你为什么做你所做的事情。</p><p id="eecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实践在变，但原则永存。理解差异是需要掌握的一项重要技能。</p></div></div>    
</body>
</html>