<html>
<head>
<title>Functional Programming Explained in Python, JavaScript, and Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python、JavaScript和Java解释函数式编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-explained-in-python-javascript-and-java-2dbf875046a9?source=collection_archive---------10-----------------------#2020-11-04">https://betterprogramming.pub/functional-programming-explained-in-python-javascript-and-java-2dbf875046a9?source=collection_archive---------10-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8db0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习函数式编程，不管你的语言背景如何</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4285518cbe2d2bbd19dc4714d16a8a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWuM2vAxWNcitQStHD7eUg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="c1a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数式编程(FP)是通过组合纯函数来构建软件的过程。如今，雇主正在寻找能够利用多种范例来解决问题的程序员。函数式编程由于其解决现代问题的效率和可伸缩性而特别受欢迎。</p><p id="7873" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是你如何从OOP跳到FP呢？</p><p id="c632" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将探索函数式编程的核心概念，并向您展示如何用Python、JavaScript和Java实现它们。</p><p id="800d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们今天要讲的内容:</p><ul class=""><li id="ba87" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">什么是函数式编程？</li><li id="cfbb" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">函数式编程语言</li><li id="65e8" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">函数式编程的概念</li><li id="7ed5" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">用Python进行函数式编程</li><li id="f319" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">JavaScript函数式编程</li><li id="6153" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">用Java进行函数式编程</li><li id="7985" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">接下来学什么</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="8d7a" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">什么是函数式编程？</h1><p id="441a" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><em class="nj">函数式编程</em>是一种声明式编程范式，通过应用顺序函数而不是语句来创建程序。</p><p id="ce18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个函数接受一个输入值，并返回一致的输出值，而不会改变程序状态，也不受程序状态的影响。</p><p id="45f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些函数完成单个操作，并且可以按顺序组合来完成复杂的操作。函数范式导致高度模块化的代码，因为函数可以在程序中重用，可以被调用、作为参数传递或返回。</p><p id="1c56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nj">纯函数</em>不会产生副作用，也不依赖于全局变量或状态。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/07ceb65e40a2216ec65b3c7da9679e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Se-OXiNwp2jEA8N9S5x2Dg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可视化FP函数</p></figure><p id="6737" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当解决方案很容易用函数来表达并且没有什么物理意义时，就使用函数式编程。虽然面向对象的程序模仿真实世界的对象来建模代码，但是函数式编程擅长于中间值或最终值没有物理相关性的数学函数。</p><p id="805e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数式编程的一些常见用途是人工智能设计、最大似然分类算法、金融程序或高级数学函数模型。</p><p id="4895" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">简化:</strong>函数式程序依次执行许多纯的、单一用途的函数，以解决复杂的数学或非物理问题。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="c76c" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">函数式编程的优势</h1><ul class=""><li id="b9ff" class="lr ls iq kx b ky ne lb nf le nl li nm lm nn lq lw lx ly lz bi translated"><strong class="kx ir">易调试</strong>:纯函数和不可变数据，很容易找到变量值设置在哪里。纯函数受影响的因素较少，因此能让你更容易找到有问题的部分。</li><li id="9eee" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">懒惰评估</strong>:函数式程序只在需要的时候评估计算。这允许程序重用以前计算的结果并节省运行时间。</li><li id="1015" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">模块化:纯函数不依赖于外部变量或状态来运行，这意味着它们很容易在程序中重用。此外，函数将只完成一个操作或计算，以确保您可以重用该函数，而不会意外地导入额外的代码。</li><li id="77be" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">增强的可读性</strong>:函数式程序易于阅读，因为每个函数的行为都是不可变的，并且与程序的状态相隔离。因此，您通常只需通过名称就可以预测每个函数将做什么。</li><li id="e276" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">并行编程</strong>:用函数式编程方法更容易创建并行程序，因为不可变的变量减少了程序中的变化量。每个函数只需要处理用户输入，并且可以相信程序状态将保持不变。</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="9d47" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">函数式编程语言</h1><p id="9969" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">并非所有的编程语言都支持函数式编程。有些语言，如Haskell，被设计成函数式编程语言。，其他语言像JavaScript有函数能力和OOP能力，还有的根本不支持函数编程。</p><h2 id="c081" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">函数式编程语言</h2><ul class=""><li id="5486" class="lr ls iq kx b ky ne lb nf le nl li nm lm nn lq lw lx ly lz bi translated"><a class="ae oa" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Haskell </strong> </a>:这显然是函数式编程最喜欢的语言。它是内存安全的，具有出色的垃圾收集能力，并且由于早期的机器码编译而很快。Haskell丰富的静态类型系统让您可以访问独特的代数和多态类型，这使得函数式编程更高效、更易读。</li><li id="f2a1" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae oa" href="https://www.erlang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Erlang </strong> </a>:这种语言及其派生语言Elixir已经成为并发系统的最佳函数式语言。虽然不如Haskell流行或广泛使用，但它通常用于后端编程。Erlang最近获得了WhatsApp和Discord等可扩展消息应用的支持。</li><li id="73fe" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae oa" href="https://clojure.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Clojure </strong> </a>:这种语言是在Java虚拟机(JVM)上使用的Lisp的功能优先方言。它是一种占主导地位的函数式语言，支持可变和不可变的数据结构，但不如这里的其他语言那么严格。如果你喜欢Lisp，你会喜欢Clojure。</li><li id="58f6" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae oa" href="https://fsharp.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> F# </strong> </a> : F#类似于Haskell(他们在同一个语言群中)，但是没有那么高级的特性。它也很少支持面向对象的结构。</li></ul><h2 id="bdf2" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">功能语言</h2><ul class=""><li id="815e" class="lr ls iq kx b ky ne lb nf le nl li nm lm nn lq lw lx ly lz bi translated"><a class="ae oa" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">Scala</strong></a><strong class="kx ir">:</strong>Scala同时支持OOP和函数式编程。它最有趣的特性是类似Haskell的强大的静态类型系统，有助于创建强大的函数式程序。Scala是为解决Java批评而设计的，因此对于想要尝试函数式编程的Java开发人员来说，它是一种很好的语言。</li><li id="bbac" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">JavaScript :虽然不是函数优先，但JS因其异步特性而在函数编程中脱颖而出。JavaScript还支持基本的函数式编程特性，如lambda表达式和析构。这些属性共同标志着JS是其他多范例语言中函数式编程的顶级语言。</li><li id="2693" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir"> Python、PHP、C++ </strong>:这些多范式语言支持函数式编程，但相对于Scala和JavaScript来说支持不完全。</li><li id="a226" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Java  : Java是一种通用语言，但它领先于基于类的OOP。lambda表达式的添加允许您以有限的方式追求更具功能性的风格。Java最终是一种OOP语言，它可以实现函数式编程，但是缺少一些关键的特性，所以这种转变是值得的。</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="e730" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">函数式编程的概念</h1><p id="916c" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">函数式程序是根据一些核心概念设计的。</p><h2 id="9186" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">变量和函数</h2><p id="5eae" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">函数式程序的核心构件是变量和函数，而不是对象和方法。你应该避免全局变量，因为易变的全局变量会使程序难以理解并导致不纯的函数。</p><h2 id="f23b" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">纯函数</h2><p id="28b2" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">纯函数有两个属性:</p><ul class=""><li id="aaa1" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">它们不会产生副作用。</li><li id="59a1" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">如果给定相同的输入，它们总是产生相同的输出。</li></ul><p id="3280" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一个函数改变了程序状态，覆盖了一个输入变量，或者在生成输出的同时做了一些改变，就会产生副作用。纯函数问题较少，因为副作用会使程序状态复杂化。</p><p id="f3e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">引用透明意味着任何函数输出都可以用它的值替换，而不会改变程序的结果。这个概念确保您创建的函数只完成单个操作并获得一致的输出。</p><p id="5a59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只有当函数不影响程序状态或者通常试图完成多个操作时，引用透明才是可能的。</p><h2 id="f7be" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">不变性和状态</h2><p id="f208" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">不可变的数据或状态一旦被设置就不能被改变，并且允许函数输出的稳定环境是恒定的。不管程序状态如何，对每个函数进行编程以产生相同的结果是最佳实践。如果它依赖于一个状态，这个状态必须是不可变的，以确保函数输出保持不变。</p><p id="a254" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数式编程方法通常避免共享状态函数(多个函数依赖于同一个状态)和可变状态函数(函数依赖于可变函数)，因为它们会降低程序的模块化程度。如果您必须使用共享状态函数，请将其设为不可变状态。</p><h2 id="305b" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">递归</h2><p id="df0c" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">面向对象编程和函数式编程的一个主要区别是，函数式程序避免了像if-else语句或循环这样的结构，这些结构会在每次执行时产生不同的输出。</p><p id="d4fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数式程序使用递归来代替所有迭代任务的循环。</p><h2 id="7c5c" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">一流的功能</h2><p id="8d11" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">函数式编程中的函数被视为一种数据类型，可以像任何其他值一样使用。例如，我们用函数填充数组，将它们作为参数传递，或者将它们存储在变量中。</p><h2 id="d9b3" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">高阶函数</h2><p id="6be8" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">高阶函数可以接受其他函数作为参数或返回函数作为输出。高阶函数允许我们更灵活地调用函数和抽象动作。</p><h2 id="0e08" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">操作组合</h2><p id="adce" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">可以顺序执行函数来完成复杂的操作。每个函数的结果作为参数传递给下一个函数。这允许你用一个函数调用来调用一系列的函数。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="7dfd" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">用Python进行函数式编程</h1><p id="b335" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">Python作为一种多范式语言，部分支持函数式编程。数学程序的一些Python解决方案可以用函数方法更容易地实现。</p><p id="1e2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当你开始使用函数式方法时，最困难的转变是减少你使用的类的数量。Python中的类具有可变属性，这使得创建纯粹的、不可变的函数变得困难。</p><p id="75a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，尽量将大部分代码放在模块级别，只有在需要时才切换到类。</p><p id="eca6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来看看如何在Python中实现纯的、不可变的函数和一级函数。然后，我们将学习构造函数的语法。</p><h2 id="df55" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">纯函数和不可变函数</h2><p id="3073" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">默认情况下，Python的许多内置数据结构是不可变的:</p><ul class=""><li id="a821" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">整数</li><li id="700e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">漂浮物</li><li id="93de" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">布尔型</li><li id="83ce" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">线</li><li id="ac91" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">统一码</li><li id="dbb6" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">元组</li></ul><p id="cd5c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">元组作为数组的不可变形式特别有用。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="35cb" class="no mn iq oc b gy og oh l oi oj"># Python code to test that  <br/># tuples are immutable  </span><span id="872b" class="no mn iq oc b gy ok oh l oi oj">tuple1 = (0, 1, 2, 3)  <br/>tuple1[0] = 4<br/>print(tuple1)</span></pre><p id="1eee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码导致了一个错误，因为它试图重新分配一个不可变的元组对象。函数式Python程序应该经常使用这些不可变的数据结构来实现纯函数。</p><p id="df6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是一个纯函数，因为它没有副作用，并且将始终返回相同的输出:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="2571" class="no mn iq oc b gy og oh l oi oj">def add_1(x):<br/>    return x + 1</span></pre><h2 id="dd1b" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">一流的功能</h2><p id="1390" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">在Python中，函数被视为对象。以下是我们关于如何在Python中使用函数的快速指南:</p><p id="5af1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">作为对象的功能</strong></p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="cb97" class="no mn iq oc b gy og oh l oi oj">def shout(text): <br/>    return text.upper()</span></pre><p id="1c96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">将函数作为参数传递</strong></p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="7c50" class="no mn iq oc b gy og oh l oi oj">def shout(text): <br/>    return text.upper() </span><span id="d6a9" class="no mn iq oc b gy ok oh l oi oj">def greet(func): <br/>    # storing the function in a variable <br/>    greeting = func("Hi, I am created by a function passed as an argument.") <br/>    print greeting  </span><span id="31a0" class="no mn iq oc b gy ok oh l oi oj">greet(shout)</span></pre><p id="e98b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">从另一个函数返回函数</strong></p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="d646" class="no mn iq oc b gy og oh l oi oj">def create_adder(x): <br/>    def adder(y): <br/>        return x+y </span><span id="ce66" class="no mn iq oc b gy ok oh l oi oj">    return adder</span></pre><h2 id="1aa8" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">操作组合</h2><p id="3eb3" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">为了用Python编写函数，我们将使用一个<code class="fe ol om on oc b">lambda function</code>调用。这允许我们在一次调用中调用任意数量的参数。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="59fd" class="no mn iq oc b gy og oh l oi oj">import functools</span><span id="9503" class="no mn iq oc b gy ok oh l oi oj">def compose(*functions):<br/>    def compose2(f, g):<br/>        return lambda x: f(g(x))<br/>    return functools.reduce(compose2, functions, lambda x: x)</span></pre><p id="d3f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir">第4行</strong>，我们将定义一个函数<code class="fe ol om on oc b">compose2</code>，它将两个函数作为参数<code class="fe ol om on oc b">f</code>和<code class="fe ol om on oc b">g</code>。<br/>在<strong class="kx ir">第5行</strong>，我们返回一个新函数，表示<code class="fe ol om on oc b">f</code>和<code class="fe ol om on oc b">g</code>的组合。</p><p id="72c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，在<strong class="kx ir">第6行</strong>，我们返回复合函数的结果。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="56c0" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">JavaScript中的函数式编程</h1><p id="53fa" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">由于支持一级函数，JavaScript长期以来一直提供函数功能。函数式编程最近在JavaScript中变得更加流行，因为它在Angular和React这样的框架中使用时可以提高性能。</p><p id="cb84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看如何使用JavaScript实现不同的功能概念。我们将关注如何创建核心概念；纯函数，一级函数，函数合成。</p><h2 id="16de" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">纯函数和不可变函数</h2><p id="d2bd" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">为了开始在JavaScript中创建纯函数，我们必须使用普通行为的替代函数，比如<code class="fe ol om on oc b">const</code>、<code class="fe ol om on oc b">concat</code>和<code class="fe ol om on oc b">filter()</code>。</p><p id="e4ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关键字<code class="fe ol om on oc b">let</code>设置一个可变变量。相反，用<code class="fe ol om on oc b">const</code>声明保证了变量是不可变的，因为它防止了重新赋值。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="072e" class="no mn iq oc b gy og oh l oi oj">const heightRequirement = 46;</span><span id="e065" class="no mn iq oc b gy ok oh l oi oj">function canRide (height){<br/>    return height &gt;= heightRequirement;<br/>}</span></pre><p id="62d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还需要使用替代函数来操作数组。<code class="fe ol om on oc b">push()</code>方法是将元素追加到数组中的常用方法。不幸的是，<code class="fe ol om on oc b">push()</code>修改了原始数组，因此是不纯的。</p><p id="0819" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，我们将使用功能对等物<code class="fe ol om on oc b">concat()</code>。该方法返回一个包含所有原始元素和新添加元素的新数组，使用<code class="fe ol om on oc b">concat()</code>时原始数组不被修改。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="2a52" class="no mn iq oc b gy og oh l oi oj">const a = [1, 2]<br/>const b = [1, 2].concat(3)</span></pre><p id="d49a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要从数组中移除一个项目，我们通常使用<code class="fe ol om on oc b">pop()</code>和<code class="fe ol om on oc b">slice()</code>方法。但是，这些功能不起作用，因为它们会修改原始数组。相反，我们将使用<code class="fe ol om on oc b">filter()</code>来创建一个新数组，其中包含所有通过条件测试的元素。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="dd10" class="no mn iq oc b gy og oh l oi oj">const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];</span><span id="d8d4" class="no mn iq oc b gy ok oh l oi oj">const result = words.filter(word =&gt; word.length &gt; 6);</span></pre><h2 id="f497" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">一流的功能</h2><p id="5827" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">JavaScript默认支持一级函数。这里有一个在JavaScript中我们可以做什么的快速指南。</p><p id="98ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">将函数分配给变量</strong></p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="2c45" class="no mn iq oc b gy og oh l oi oj">const f = (m) =&gt; console.log(m)<br/>f('Test')</span></pre><p id="2c61" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">向数组添加函数</strong></p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="41ad" class="no mn iq oc b gy og oh l oi oj">const a = [<br/>  m =&gt; console.log(m)<br/>]<br/>a[0]('Test')</span></pre><p id="e143" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">将函数作为参数传递</strong></p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="1bd7" class="no mn iq oc b gy og oh l oi oj">const f = (m) =&gt; () =&gt; console.log(m)<br/>const f2 = (f3) =&gt; f3()<br/>f2(f('Test'))</span></pre><p id="11a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">从另一个函数返回函数</strong></p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="6460" class="no mn iq oc b gy og oh l oi oj">const createF = () =&gt; {<br/>  return (m) =&gt; console.log(m)<br/>}<br/>const f = createF()<br/>f('Test')</span></pre><h2 id="01be" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">操作组合</h2><p id="5022" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">在JavaScript中，我们可以用链式函数调用来组合函数:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="8185" class="no mn iq oc b gy og oh l oi oj">obj.doSomething()<br/>   .doSomethingElse()</span></pre><p id="0647" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者，我们可以将一个函数的执行传递给下一个函数:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="d8e3" class="no mn iq oc b gy og oh l oi oj">obj.doSomething(doThis())</span></pre><p id="82e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想组合更多的函数，我们可以使用<code class="fe ol om on oc b">lodash</code>来简化组合。具体来说，我们将使用<code class="fe ol om on oc b">compose</code>特性，它先给出一个参数，然后给出一个函数列表。</p><p id="6d2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">列表中的第一个函数使用原始参数作为其输入。后面的函数从它前面的函数的返回值继承输入参数。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="2892" class="no mn iq oc b gy og oh l oi oj">import { compose } from 'lodash/fp'</span><span id="e0b9" class="no mn iq oc b gy ok oh l oi oj">const slugify = compose(<br/>  encodeURIComponent,<br/>  join('-'),<br/>  map(toLowerCase),<br/>  split(' ')<br/>)</span><span id="7c35" class="no mn iq oc b gy ok oh l oi oj">slufigy('Hello World') // hello-world</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="ab95" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">Java中的函数式编程</h1><p id="90ac" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">Java并不像Python或JavaScript那样真正支持函数式编程。然而，我们可以通过使用lambda函数、流和匿名类来模仿Java中的函数式编程行为。</p><p id="aff3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终，Java编译器没有考虑到函数式编程，因此不能获得函数式编程的许多好处。</p><h2 id="ad61" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">纯函数和不可变函数</h2><p id="7636" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">Java的几个内置数据结构是不可变的:</p><ul class=""><li id="bc32" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">整数</li><li id="d4f2" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">布尔型</li><li id="79a3" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">字节</li><li id="2206" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">短的</li><li id="a5b6" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">线</li></ul><p id="7c02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你也可以用<code class="fe ol om on oc b">final</code>关键字创建你自己的不可变类。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="1ec7" class="no mn iq oc b gy og oh l oi oj">// An immutable class <br/>public final class Student <br/>{ <br/>    final String name; <br/>    final int regNo; </span><span id="1ba4" class="no mn iq oc b gy ok oh l oi oj">    public Student(String name, int regNo) <br/>    { <br/>        this.name = name; <br/>        this.regNo = regNo; <br/>    } <br/>    public String getName() <br/>    { <br/>        return name; <br/>    } <br/>    public int getRegNo() <br/>    { <br/>        return regNo; <br/>    } <br/>}</span></pre><p id="8587" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类上的关键字<code class="fe ol om on oc b">final</code>阻止了子类的构造。<code class="fe ol om on oc b">name</code>和<code class="fe ol om on oc b">regNo</code>上的<code class="fe ol om on oc b">final</code>使得对象构建后无法更改值。</p><p id="fa0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个类也有一个参数化的构造函数，所有变量的getter方法，没有setter方法，这都有助于使这个类成为一个不可变的类。</p><h2 id="d3ec" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">一流的功能</h2><p id="ae44" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">Java可以用lambda函数实现一级函数。Lambda像方法一样接受表达式列表，但不需要名称或预定义。</p><p id="d165" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用lambda表达式来代替函数，因为它们被视为可以传递或返回的标准类对象。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="649f" class="no mn iq oc b gy og oh l oi oj">// FIRST-CLASS<br/>Supplier&lt;String&gt; lambda = myObject::toString;<br/>// HIGHER-ORDER<br/>Supplier&lt;String&gt; higherOrder(Supplier&lt;String&gt; fn) {<br/>    String result = fn.get();<br/>    return () -&gt; result;<br/>}</span></pre><h2 id="5341" class="no mn iq bd mo np nq dn ms nr ns dp mw le nt nu my li nv nw na lm nx ny nc nz bi translated">操作组合</h2><p id="c90b" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">Java包含一个接口<code class="fe ol om on oc b">java.util.function.Function</code>，它给出了函数组合的方法。<code class="fe ol om on oc b">compose</code>方法首先执行传递的函数(<code class="fe ol om on oc b">multiplyByTen</code>)，然后将返回传递给外部函数(<code class="fe ol om on oc b">square</code>)。<br/><code class="fe ol om on oc b">andThen</code>方法首先执行外部函数<em class="nj">，然后执行其参数内的函数</em>。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="6203" class="no mn iq oc b gy og oh l oi oj">Function&lt;Integer, Integer&gt; square = (input) -&gt; input * input;<br/>Function&lt;Integer, Integer&gt; multiplyByTen = (input) -&gt; input * 10;</span><span id="5d66" class="no mn iq oc b gy ok oh l oi oj">// COMPOSE: argument will be run first<br/>Function&lt;Integer, Integer&gt; multiplyByTenAndSquare = square.compose(multiplyByTen);</span><span id="3742" class="no mn iq oc b gy ok oh l oi oj">// ANDTHEN: argument will run last<br/>Function&lt;Integer, Integer&gt; squareAndMultiplyByTen = square.andThen(multiplyByTen);</span></pre><p id="8083" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir">第1行和第2行</strong>，我们首先创建两个函数<code class="fe ol om on oc b">square</code>和<code class="fe ol om on oc b">multiplyByTen</code>。<br/>接下来在<strong class="kx ir">第5行和第8行</strong>，我们创建两个复合函数<code class="fe ol om on oc b">multiplyByTenAndSquare</code>和<code class="fe ol om on oc b">squareAndMultiplyByTen</code>，每个函数都有两个参数(以满足<code class="fe ol om on oc b">square</code>)。</p><p id="4a59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些复合函数各自完成两个原始函数，但顺序不同。现在，您可以调用复合函数在同一个输入上执行两个原始函数。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="0d5e" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">接下来学什么</h1><p id="9d33" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">今天，我们回顾了一些通用的函数式编程概念，并探索了这些核心概念是如何出现在Python、JavaScript和Java中的。</p><p id="5593" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Scala是复兴的顶级函数式编程语言之一。Twitter和脸书等许多科技巨头已经采用了Scala，并在他们的应用程序中寻找它。你的下一步是学习Scala的基础知识，作为函数式语言的入门。</p><p id="5a25" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nj">快乐学习！</em></p></div></div>    
</body>
</html>