<html>
<head>
<title>Build Your Pokédex: Part 1 — Introduction to NgRX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您的Pokédex:第1部分NgRX简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-pok%C3%A9dex-part-1-introduction-to-ngrx-a89c3be0ea10?source=collection_archive---------9-----------------------#2019-07-10">https://betterprogramming.pub/build-your-pok%C3%A9dex-part-1-introduction-to-ngrx-a89c3be0ea10?source=collection_archive---------9-----------------------#2019-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0249" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">角度教程— NgRX一步步</h2></div><p id="57d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章是一系列文章的一部分，在这些文章中，我描述了从初学者到忍者如何使用NGRX构建你的Pokédex。想了解更多，可以看以下帖子:</p><ol class=""><li id="ca57" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><a class="ae ln" href="https://medium.com/p/a89c3be0ea10/" rel="noopener">第一部分。构建你的pokédex:NGRX简介</a></li><li id="4ad7" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld lj lk ll lm bi translated"><a class="ae ln" href="https://medium.com/better-programming/build-your-pok%C3%A9dex-part-2-ngrx-entity-6e9d7256e6a8" rel="noopener">第二部分。构建您的Pokédex: @ngrx/entity </a></li><li id="b7cc" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld lj lk ll lm bi translated">第三部分。构建你的Pokédex:使用create*函数改进NgRX】</li><li id="b4f1" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld lj lk ll lm bi translated">第四部分。构建你的Pokédex: <a class="ae ln" href="http://twitter.com/ngrx/data" rel="noopener ugc nofollow" target="_blank"> @ngrx/data </a></li><li id="2f0e" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld lj lk ll lm bi translated">第五部分。构建您的Pokédex:测试NgRX</li></ol><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/c19442d8e818b7682795ae59e523a8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0Y5OTBWR-YCcfel5.png"/></div></div></figure><p id="d076" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将使用<a class="ae ln" href="http://angular.io" rel="noopener ugc nofollow" target="_blank"> Angular </a>框架和<a class="ae ln" href="https://ngrx.io" rel="noopener ugc nofollow" target="_blank"> NgRX </a>作为状态管理库来开发一个<strong class="kk iu"> pokédex </strong>。</p><p id="2d90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了正确理解这篇文章，你应该知道如何在中级水平上管理Angular，并知道什么是状态管理库，因为在这个系列中，我们将展示一个具体的例子是如何开发的(Pokédex)，这可以作为你NgRX学习的补充。</p><p id="bc64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，下面的GIF展示了我们根据这些帖子构建的结果。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mf"><img src="../Images/3b14382535217a9bd1569434c9afc07b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jxpofLFJ9V7UzSWL.gif"/></div></div></figure><p id="aaf6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们项目的目录结构如下所示(你可以从<a class="ae ln" href="https://angular-academy.com/angular-architecture-best-practices/" rel="noopener ugc nofollow" target="_blank"> AngularAcademy </a>阅读关于Angular架构的帖子):</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/1a10763bab07a8502f31c9be5cafc859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/0*EFDizQq0VPrpGQYR.png"/></div></figure><p id="e521" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应用程序的结构分为两个明显不同的部分:</p><ul class=""><li id="047e" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated"><strong class="kk iu">共享</strong>。在这里，我们将放置在每个模块之间共享的所有元素，例如管道、指令、服务、模型和状态。</li><li id="80c6" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">状态</strong>。状态又分为子状态，允许我们管理存储应用程序状态的数据结构。在我们的应用程序中，我们将只有一个名为神奇宝贝的状态，其中存储了与神奇宝贝相关的信息。</li><li id="f39e" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">观点</strong>。在这里，您将找到应用程序的视图/页面。该应用程序由模块构成:</li><li id="3b8b" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">核心模块</strong>。对应用程序来说必不可少的服务，需要在最初进行实例化。</li><li id="5454" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">共享模块</strong>。所有功能模块共享的模块。</li><li id="3ed1" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">功能模块</strong>。按应用程序中的功能组织的模块。在我们的具体应用程序中，我们将只有一个功能模块(PokemonModule)。</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mi"><img src="../Images/0596d306bbd6d626280ab6eee0f89e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*toOjyh6kpM16SsMg.png"/></div></div></figure><p id="44a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">教程的第一步是使用CLI创建新的角度项目。然后，显示创建我们的项目的结果和正在使用的具体版本。</p><pre class="lu lv lw lx gt mj mk ml mm aw mn bi"><span id="5bdf" class="mo mp it mk b gy mq mr l ms mt">ng new ngrx-pokedex</span></pre><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="cfc2" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">tsconfig.json &amp;&amp;环境</h1><p id="e6df" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">在我使用TypeScript的项目中，我喜欢配置<code class="fe nz oa ob mk b">path</code>来访问<code class="fe nz oa ob mk b">shared</code>的子目录，而不必使用几级向后缩进(<code class="fe nz oa ob mk b">../../ ..</code>)。<code class="fe nz oa ob mk b">tsconfig.json</code>文件允许您轻松地为路线配置这些别名。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="daa7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，我认为在开发过程中尽快配置环境变量是很重要的，这样可以避免在你决定从开发进入生产后不得不进行配置。因此，我们开发的伪后端的路径将在如下所示的<code class="fe nz oa ob mk b">environment.ts</code>文件中定义:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fc31" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将使用<code class="fe nz oa ob mk b">in-memory-web-api</code>模块，而不是开发一个在数据库或内存上执行CRUD操作的后端。这允许我们模拟REST上的操作。</p><p id="8ab0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个模块拦截Angular <code class="fe nz oa ob mk b">Http</code>和<code class="fe nz oa ob mk b">HttpClient</code>请求，否则这些请求会发送到远程服务器，并将它们重定向到您控制的内存数据存储中。</p><p id="e93b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个实现<code class="fe nz oa ob mk b">InMemoryDbService</code>的<code class="fe nz oa ob mk b">InMemoryDataService</code>类。</p><p id="6190" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至少，我们必须实现一个<code class="fe nz oa ob mk b">createDb</code>方法来创建一个“数据库”散列，其键是集合名称，其值是要返回或更新的集合对象的数组。此外，我还实现了<code class="fe nz oa ob mk b">genId</code>方法，它为来自假服务器的每个新神奇宝贝生成一个唯一的ID。</p><pre class="lu lv lw lx gt mj mk ml mm aw mn bi"><span id="d66f" class="mo mp it mk b gy mq mr l ms mt">npm i angular-in-memory-web-api</span></pre><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a0dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据来自具有以下结构的模拟文件:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b5a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，服务器中会为每个神奇宝贝存储一个静态图像。这些图像存储在使用<code class="fe nz oa ob mk b">photo</code>字段识别的<code class="fe nz oa ob mk b">assets/images/pokemon/</code>路径中。</p><p id="8488" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用根<code class="fe nz oa ob mk b">AppModule.imports</code>中的<code class="fe nz oa ob mk b">HttpClientInMemoryWebApiModule</code>注册您的数据存储服务实现，用这个服务类和一个可选的配置对象调用<code class="fe nz oa ob mk b">forRoot</code>静态方法:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3801" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个内存中的web api服务处理一个HTTP请求，并以RESTy web api的方式返回一个可观察的HTTP响应对象。它以<code class="fe nz oa ob mk b">:base/:collectionName/:id?</code>的形式处理URI模式</p><p id="fc8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><p id="656a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nz oa ob mk b">//</code>用于请求从<em class="oc">英雄</em>集合<br/> <code class="fe nz oa ob mk b">GET api/heroes //</code>所有英雄<br/><code class="fe nz oa ob mk b"> GET api/heroes/42 //</code>id = 42<br/><code class="fe nz oa ob mk b">GET api/heroes?name=^j //</code>【j】的英雄是一个正则表达式；返回名字以‘J’或‘J’开头的英雄<br/> <code class="fe nz oa ob mk b"> GET api/heroes.json/42 //</code>忽略<code class="fe nz oa ob mk b">.json</code></p><p id="73a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">内存中的web api服务根据您在设置过程中定义的一个数据库<em class="oc">处理这些请求。</em></p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="77e7" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">@ngrx/store</h1><p id="bb67" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated"><em class="oc"> Store </em>是RxJS供电的状态管理，用于角度应用，灵感来自Redux。Store是一个受控状态容器，旨在帮助在Angular之上编写高性能和一致的应用程序。</p><p id="1f7b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键概念:</p><ul class=""><li id="e159" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated"><strong class="kk iu">动作</strong>描述了从组件和服务分派的独特事件。</li><li id="6b97" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">状态变化</strong>由称为reducers的纯函数处理，它采用当前状态和最新动作来计算新状态。</li><li id="7eda" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">选择器</strong>是用于选择、导出和组合状态片段的纯函数。</li><li id="0229" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">状态访问</strong>与存储，一个可观察的状态和一个观察的行动。</li></ul><p id="90ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您只需要安装以下软件包:</p><pre class="lu lv lw lx gt mj mk ml mm aw mn bi"><span id="6c62" class="mo mp it mk b gy mq mr l ms mt">npm install @ngrx/store</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="9d81" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">@ngrx/effects</h1><p id="9d09" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">Effects是一个RxJS驱动的商店副作用模型。Effects使用流来提供新的动作源，以减少基于外部交互(如网络请求、web套接字消息和基于时间的事件)的状态。</p><h2 id="39a1" class="mo mp it bd ne od oe dn ni of og dp nm kr oh oi no kv oj ok nq kz ol om ns on bi translated">介绍</h2><p id="8722" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">在基于服务的角度应用程序中，组件负责直接通过服务与外部资源进行交互。相反，Effects提供了一种与这些服务进行交互的方式，并将它们与组件隔离开来。Effects是您处理任务的地方，比如获取数据、产生多个事件的长时间运行的任务，以及其他外部交互，在这些交互中，您的组件不需要这些交互的明确知识。</p><h2 id="6b9b" class="mo mp it bd ne od oe dn ni of og dp nm kr oh oi no kv oj ok nq kz ol om ns on bi translated">关键概念</h2><ul class=""><li id="d282" class="le lf it kk b kl nu ko nv kr oo kv op kz oq ld mh lk ll lm bi translated">Effects将副作用从组件中分离出来，允许更纯粹的组件选择状态和分派动作。</li><li id="a5bc" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated">Effects运行长期运行的服务，监听从商店发出的每个可观察的动作。</li><li id="7089" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated">效果根据他们感兴趣的动作类型过滤这些动作。这是通过使用运算符来完成的。</li><li id="8142" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated">Effects执行同步或异步任务，并返回一个新动作。</li></ul><p id="cb4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您只需要安装以下软件包:</p><pre class="lu lv lw lx gt mj mk ml mm aw mn bi"><span id="1470" class="mo mp it mk b gy mq mr l ms mt">npm install @ngrx/effects</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="26f1" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">@ngrx/store-devtools</h1><p id="5a47" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">Store Devtools为Store提供开发人员工具和工具。</p><p id="3193" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">配置该工具的步骤如下:</p><ol class=""><li id="3960" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">安装包:<code class="fe nz oa ob mk b">npm install @ngrx/store-devtools</code>。</li><li id="1cf7" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld lj lk ll lm bi translated">安装<a class="ae ln" href="https://chrome.google.com/webstore/detail/redux-devtools/" rel="noopener ugc nofollow" target="_blank">Chrome</a>/<a class="ae ln" href="https://addons.mozilla.org/es/firefox/addon/reduxdevtools/" rel="noopener ugc nofollow" target="_blank">Firefox</a>扩展。</li><li id="1712" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld lj lk ll lm bi translated">在您的<code class="fe nz oa ob mk b">AppModule</code>中，使用<code class="fe nz oa ob mk b">StoreDevtoolsModule.instrument</code>向模块导入添加插装:</li></ol><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e68d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这些步骤之后，当您打开web浏览器元素检查器时，您将获得一个新的redux选项卡。在这个新选项卡中，您可以看到已经触发的操作和应用程序的状态。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi or"><img src="../Images/128f3fa9bb254a2d9eb7ea6e10a17a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yhTYwWcbrE-tib8u.png"/></div></div></figure><p id="a2c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按照<a class="ae ln" href="https://angular.io/guide/architecture" rel="noopener ugc nofollow" target="_blank"> Angular团队构建Angular应用架构</a>的指示，将定义两个模块:</p><ul class=""><li id="8b19" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated"><strong class="kk iu">共享模块</strong>。该模块导入和导出功能模块中共享的模块。注意，已经导入了一组属于<code class="fe nz oa ob mk b">@angular/material</code>的模块，这些模块可以在一个名为<code class="fe nz oa ob mk b">shared.material.module</code>的特定模块中导入和导出。但是，为了简化问题，它已经直接从<code class="fe nz oa ob mk b">SharedModule</code>模块导出。有必要导入<code class="fe nz oa ob mk b">StoreModule</code>模块，因为它负责加载应用程序中的存储。最后，导入与表单相关的模块，以构建用户界面。</li><li id="e8fc" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">核心模块。</strong>在此模块中，使用<code class="fe nz oa ob mk b">StoreModule</code>和<code class="fe nz oa ob mk b">EffectsModule</code>模块初始化减压器和效果。</li></ul><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fec0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">角形材料的安装非常简单，因为我们只需要安装以下软件包:</p><pre class="lu lv lw lx gt mj mk ml mm aw mn bi"><span id="ae8a" class="mo mp it mk b gy mq mr l ms mt">npm install @angular/material <br/>npm install @angular/flex-layout <br/>npm install @angular/cdk</span></pre><p id="2c37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们必须使用NgRX服务时，我们减去了所有与应用程序状态相关的逻辑。传统上，当您在Angular中开发服务时，您有一组属性来建模应用程序的子状态。</p><p id="624d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用NgRX，这个问题大大减少了，因为所有与状态管理相关的逻辑都被委托给了商店，因此从服务中消失了。事实上，我们的<code class="fe nz oa ob mk b">Pokemon.service</code>服务可以被认为是一个更大的服务，它封装了与<code class="fe nz oa ob mk b">HttpClient</code>服务相关的逻辑，因为它唯一的任务就是与b。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="137f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您不打算包含与数据相关的方法时，没有必要构建一个类。因此，我们决定创建一个界面，其中每个神奇宝贝的属性都按照如下所示进行建模。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a78f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NgRx是一个在Angular中构建反应式应用程序的框架。NgRx提供了状态管理、副作用隔离、实体集合管理、路由器绑定、代码生成和开发人员工具，这些工具可以增强开发人员在构建许多不同类型的应用程序时的体验。</p><p id="2b75" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NgRX由以下概念组成:</p><ul class=""><li id="d25b" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated"><strong class="kk iu">状态</strong>。我们想要建模的<code class="fe nz oa ob mk b">state</code>在这里定义。理想情况是设计组成完整状态的子状态。</li><li id="fa03" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">动作</strong>。可对商店执行或有影响的操作列表。</li><li id="26f9" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">减速器</strong>。转换状态的方法(因为使用了不变性，所以创建了一个新状态)。</li><li id="297e" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">选择器</strong>。允许您在存储的子状态上创建可观察对象的方法。选择器非常有用，因为它们允许我们只在每个组件中感兴趣的片段上创建可观察的东西，而不需要观察整个商店。</li><li id="a2ca" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">效果</strong>。那些不改变悬挂物的方法在这里被合并。在我们的例子中，我们将使用它来创建操作执行是否令人满意的通知。此外，在服务的操作执行得令人满意或不正确的情况下，这些效果用于触发操作。</li></ul><p id="e628" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe nz oa ob mk b">@shared/state/pokemon</code>目录由以下文件组成:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi os"><img src="../Images/6bcec02ca00f522d13f26ce0bc39246b.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*vqPFGhhZwfFyMf_U.png"/></div></figure><p id="224a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nz oa ob mk b">index.ts</code>文件仅用于提高神奇宝贝目录中导入的详细程度。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="3b46" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">状态模型</h1><p id="6423" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">我们现在在<code class="fe nz oa ob mk b">pokemon</code>文件中创建一些状态模型。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d95e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nz oa ob mk b">pokemon</code>状态由下面定义的两个属性组成:</p><ul class=""><li id="8442" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated"><strong class="kk iu"> ids </strong>。这是一个数字数组，包含了按一定顺序排列的对象的键。在第一篇文章中，我们不会使用这个数组，它是由我们将在下一篇文章中解释的<code class="fe nz oa ob mk b">@ngrx/entity</code>模块提供的。</li><li id="ec1d" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">实体</strong>。这是一个键值对象，其中的键是一个字符串，对应于每个神奇宝贝的ID。这样，我们可以通过每个神奇宝贝的键直接访问它，而不必在数组中搜索。</li></ul><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="68f4" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">行动</h1><p id="ca1e" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">我们必须定义的第一件事是可以对商店执行的一组操作。</p><p id="7e88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传统的操作是那些组成众所周知的缩写CRUD的操作。每个操作由两个额外的操作来补充:<code class="fe nz oa ob mk b">XX_SUCCESS</code>和<code class="fe nz oa ob mk b">XX_FAILED</code>。</p><p id="297b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，不带后缀的操作被用作服务执行的触发器，服务与后端通信。</p><p id="63d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据服务返回的值，将触发成功或失败的操作。</p><p id="6ee8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果触发了成功操作，将执行修改存储的相关缩减器和带有操作已成功执行的消息的通知。另一方面，当执行失败的操作时，我们不需要修改存储，但是会有一个通知指出发生了错误。</p><p id="05e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们定义的一组动作及其对应的名称空间<code class="fe nz oa ob mk b">[Pokemon]</code>如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0985" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现<code class="fe nz oa ob mk b">Action</code>接口的类用于构建NgRX生态系统中的每个动作。在每个类的构造函数方法中都指定了<code class="fe nz oa ob mk b">payload</code>。这个<code class="fe nz oa ob mk b">payload</code>是减速器的参数，它修改状态。</p><p id="b43f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子显示了<code class="fe nz oa ob mk b">AddSuccess</code>类。<code class="fe nz oa ob mk b">type</code>属性用于定义该类对应的动作类型。最后，与这个动作相关联的<code class="fe nz oa ob mk b">payload</code>是来自后端的一个<code class="fe nz oa ob mk b">Pokemon</code>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1821" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nz oa ob mk b">pokemon.actions.ts</code>文件如下所示:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="79f2" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">还原剂</h1><p id="0e84" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">NgRx中的Reducers负责处理应用程序中从一个状态到下一个状态的转换。Reducers函数通过基于动作的类型确定要处理的动作来处理这些转换。</p><p id="73ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在NgRX生态系统中，只需要导出一个函数还原到<code class="fe nz oa ob mk b">CoreModule</code>。在我们的具体问题中，这个函数是<code class="fe nz oa ob mk b">pokemonReducer</code>。状态变化在函数缩减器中定义。</p><p id="ad57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数具有以下特征:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c4da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中接收到两个参数:</p><ul class=""><li id="84bc" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated"><strong class="kk iu">状态</strong>。修改前的当前状态。如果没有当前状态，将使用函数中定义的初始状态。</li><li id="3d38" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">动作</strong>。将对状态执行的操作。</li></ul><p id="e703" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">reduce函数由一个<code class="fe nz oa ob mk b">switch</code>组成，其中必须返回一个新的<code class="fe nz oa ob mk b">PokemonState</code>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="85d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，修改状态的情况是“成功”,其中使用了<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>来构建新状态。</p><p id="f90c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，<code class="fe nz oa ob mk b">ADD_SUCCESS</code>案例返回一个新的对象，其中组合了当前状态(<code class="fe nz oa ob mk b">... state</code>)和对<code class="fe nz oa ob mk b">entities</code>属性的修改。<code class="fe nz oa ob mk b">entities</code>属性是由旧的<code class="fe nz oa ob mk b">state.entities</code>组合而成的新对象，其中<code class="fe nz oa ob mk b">action.pokemon.id</code>位置被新的<code class="fe nz oa ob mk b">action.pokemon</code>修改。</p><p id="7606" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得注意的是，在接收到的有效负载对象中将有一个名为<code class="fe nz oa ob mk b">pokemon</code>的属性，它是作为参数从创建的动作传递过来的对象。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8337" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nz oa ob mk b">pokemon.reducer.ts</code>文件如下所示。<code class="fe nz oa ob mk b">arrayToObject</code>函数是将数组转换成对象的辅助函数。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="0403" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">选择器</h1><p id="6a40" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">选择器为<a class="ae ln" href="https://www.carloscaballero.io/understanding-javascript-typescript-memoization/" rel="noopener ugc nofollow" target="_blank">纯函数</a>，用于获取存储状态的切片。@ngrx/store提供了一些帮助函数来优化这个选择。在选择状态片段时，选择器提供了许多功能。</p><p id="d1d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NgRX提供了两个函数来创建选择器:</p><ul class=""><li id="6235" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated"><strong class="kk iu">创建特征选择器</strong>。这个函数允许我们为子状态创建一个选择器。</li><li id="4817" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated">创造选举人。这个函数允许我们使用两个参数创建选择器:1。选择器；2.定义我们想要选择什么值的函数。</li></ul><p id="c4e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的Pokédex中，我们只需要一个选择器(全部加载)。如果我们有一个包含每个神奇宝贝详细信息的页面，我们可以创建一个名为<code class="fe nz oa ob mk b">selectById</code>的特定选择器。</p><p id="5f0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nz oa ob mk b">pokemon.selector.ts</code>文件如下所示。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="5bc4" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">效果</h1><p id="4620" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">这些效果是我们实现Pokédex的一个基本部分，因为我们已经委派了决定为此目的分派哪个动作的责任。以下是与载入神奇宝贝相关的效果示例。</p><p id="b9e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nz oa ob mk b">loadAllPokemon $</code>正在监听<code class="fe nz oa ob mk b">LOAD_POKEMONS</code>动作的出现(将从组件中调度)。从这一点开始，NgRX需要对<a class="ae ln" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS库</a>有最基本的了解，因为它将处理可观察的流。</p><p id="3d65" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，使用了<code class="fe nz oa ob mk b">switchMap</code>操作符，它允许您丢弃来自发布者的值序列，只在每个时刻管理一个流。这就是使用<code class="fe nz oa ob mk b">PokemonService</code>服务的地方，它从后端返回一个<code class="fe nz oa ob mk b">Observable&lt;Pokemon[]&gt;</code>。如果后端的操作成功，则触发<code class="fe nz oa ob mk b">LoadPokemonSuccess</code>动作，其中有效载荷是<code class="fe nz oa ob mk b">pokemon</code>数组。另一方面，如果后端发生错误，则触发<code class="fe nz oa ob mk b">LoadPokemonFailed</code>动作，其中有效载荷是服务器错误消息。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="98c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，通过创建两个监听成功和失败操作的效果，这个问题被简化了。在这两种效果中，总是显示相同的通知消息。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2c80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得注意的是，参数<code class="fe nz oa ob mk b">dispatch: false</code>已经被指示给<code class="fe nz oa ob mk b">Effect</code>装饰器，因为每个效果默认触发一个动作；如果没有定义，它会在最后触发相同的操作，这可能会导致无限循环。</p><p id="897f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两种效果都监听特定类型的动作(<code class="fe nz oa ob mk b">POKEMON_ACTIONS_SUCCESS</code>或<code class="fe nz oa ob mk b">POKEMON_ACTIONS_FAILED</code>)，并使用Angular Material的<code class="fe nz oa ob mk b">snackBar</code>服务触发通知。</p><p id="0034" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要等待存储被修改的成功动作的效果，因为这正是我们先前定义的reducer所执行的任务。</p><p id="eeff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，<code class="fe nz oa ob mk b">pokemon.effects.ts</code>文件如下所示。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="3a24" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">根.减速器</h1><p id="baa9" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">最后，同样重要的是，我们需要一个<code class="fe nz oa ob mk b">root.reducer</code>文件，从中可以加载应用程序的所有子状态。在我们的特例中，我们只有<code class="fe nz oa ob mk b">pokemon.reducer</code>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c923" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们将开始构建应用程序的可视化部分。请记住，应用程序状态的所有管理都委托给了NgRX，因此我们不需要担心更改任何组件的状态。</p><p id="8d81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个事实大大简化了页面/视图，因为我们只需定义两种类型的组件:</p><ul class=""><li id="47cf" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated"><strong class="kk iu">智能组件</strong>。将通过<code class="fe nz oa ob mk b">dispatch</code>方法或使用选择器执行商店任务的组件。</li><li id="3a5e" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated"><strong class="kk iu">dummy组件</strong>。只需向SmartComponent显示数据和管理事件的组件。</li></ul><p id="47cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该架构在<a class="ae ln" href="https://www.carloscaballero.io/p/8f9dc168-b63b-4ea1-9e4e-bd2f67081a79/(https://www.ng-conf.org/2019/angular-architecture-specific-layers/)" rel="noopener ugc nofollow" target="_blank"> ng-conf </a>中以稳定架构的形式出现。下图显示了所使用的架构，其中我们省略了<a class="ae ln" href="https://www.carloscaballero.io/design-patterns-facade/" rel="noopener ugc nofollow" target="_blank"> Facade模式</a>，因为它对于我们的具体问题来说是不必要的，因为我们只有一个模块。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/a473d21dbf0f8871e24cfbea6c66733a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*gUJK8yNbyTdlT_b5.png"/></div></figure><p id="6c08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">视图目录的结构如下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/1f66a51c71cc5e380e0ff861a2fbd962.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/0*X_sgjaPZpa2FeiiI.png"/></div></figure><p id="8c93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到我们的具体问题(Pokédex)，PokemonComponent是智能组件。另一方面，与列表和表单相关的组件是虚拟组件。</p><p id="fccc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的神奇宝贝模块的启动器是<code class="fe nz oa ob mk b">app.component</code>，它非常简单，我接下来将向您展示。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="88d0" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">口袋妖怪模块</h1><p id="3c8a" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">Pokémon模块只负责加载组成应用程序的三个组件，当然还有如下所示的SharedModule。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="7410" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">口袋妖怪组件(智能组件)</h1><p id="7775" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">神奇宝贝组件通过<code class="fe nz oa ob mk b">dispatch</code>方法和选择器与状态交互。通过属性<code class="fe nz oa ob mk b">[pokemon]</code>和事件<code class="fe nz oa ob mk b">onUpdate</code>、<code class="fe nz oa ob mk b">onAdd</code>、<code class="fe nz oa ob mk b">onDelete</code>和<code class="fe nz oa ob mk b">onSelect</code>完成与组件虚拟对象的通信。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="83a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nz oa ob mk b">app-pokemon-list</code>组件通过<code class="fe nz oa ob mk b">selectAll</code>选择器接收持续订阅商店的神奇宝贝列表。管道<code class="fe nz oa ob mk b">async</code>是为神奇宝贝执行<code class="fe nz oa ob mk b">subscribe</code>和<code class="fe nz oa ob mk b">unsubscribe</code>任务的管道，因此组件dummy接收神奇宝贝列表，并且只专注于执行正确显示它们的任务。</p><p id="30b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该组件的构造函数负责使用代码中所示的<code class="fe nz oa ob mk b">LoadPokemon</code>动作加载所有神奇宝贝:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b194" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CRUD操作以非常简单的方法执行:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6cbc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该组件的代码如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c357" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">PokemonForm组件专注于执行操作<code class="fe nz oa ob mk b">add</code>和<code class="fe nz oa ob mk b">update</code>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="884e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该组件只需要关注与视图相关的内容:<strong class="kk iu">表单验证</strong>。</p><p id="bf74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组件之间的通信使用<code class="fe nz oa ob mk b">EventEmitter</code>完成。另一方面，这个组件从<code class="fe nz oa ob mk b">smartComponent</code>接收一个神奇宝贝，因为你可以从<code class="fe nz oa ob mk b">PokemonList</code>选择一个神奇宝贝进行编辑。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="130f" class="nd mp it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">口袋妖怪列表组件(删除/选择口袋妖怪)</h1><p id="0cb1" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">最后，<code class="fe nz oa ob mk b">PokemonList</code>组件的任务是与<code class="fe nz oa ob mk b">smartComponent</code>通信，以执行<code class="fe nz oa ob mk b">delete</code>和<code class="fe nz oa ob mk b">select</code>操作。这个组件与上一个组件非常相似。在这种情况下，我们应该只关注显示神奇宝贝的列表，而不必担心应用程序的状态。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="102b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们使用Flex-Layout和Angular材质设计了这个应用程序，使用了从Angular的<code class="fe nz oa ob mk b">styles.css</code>文件配置的<code class="fe nz oa ob mk b">Indigo-pink</code>主题。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="58a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，我们构建了一个小示例，其中展示了大型SPA应用程序架构的基本要点:</p><ul class=""><li id="478f" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated">分离可视组件的状态管理。</li><li id="0852" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated">高效、轻松地创建管理状态的元素。</li><li id="4a4c" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated">创建关注相关的组件:<strong class="kk iu">视图</strong>。</li><li id="54bb" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated">根据组件是否会与应用程序的状态进行通信，组件被分类到SmartComponent和DummyComponent中。</li></ul><p id="86fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本系列中的以下帖子将涵盖有趣的主题，例如:</p><ul class=""><li id="1303" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mh lk ll lm bi translated">自动创建状态，因为使用@ngrx/entity非常重复。</li><li id="cfd0" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated">通过<code class="fe nz oa ob mk b">@ngrx/data</code>包使用外观模式。</li><li id="1815" class="le lf it kk b kl lo ko lp kr lq kv lr kz ls ld mh lk ll lm bi translated">测试应用程序的状态。</li></ul><p id="9b25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">真正重要的是概念，而不是使用的技术或库。因此，对于那些开始有大角度应用并需要应用架构原则的人来说，这篇文章应该作为一个指南。</p><p id="2c5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">这里是本帖的</strong> <a class="ae ln" href="https://github.com/Caballerog/ngrx-pokedex/tree/ngrx-part1" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> GitHub分支</strong> </a> <strong class="kk iu">。</strong></p></div></div>    
</body>
</html>