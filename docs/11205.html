<html>
<head>
<title>Sync, Async, and Multi-thread in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的同步、异步和多线程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sync-async-and-multi-thread-9bb2be072942?source=collection_archive---------0-----------------------#2022-02-27">https://betterprogramming.pub/sync-async-and-multi-thread-9bb2be072942?source=collection_archive---------0-----------------------#2022-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="db27" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">停止错误地使用异步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/04cc8754cec18dcf4aefe8fa96c24ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHKApWKrytKFpAoL3y5RzQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://pixabay.com/pt/users/monoar_cgi_artist-2240009/" rel="noopener ugc nofollow" target="_blank">monar CGI艺术家</a>在<a class="ae ky" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄的照片</p></figure><p id="78c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管对于大多数开发人员来说，同步、异步和多线程之间的区别非常清楚，但在实践方面，这可能会产生一些疑问。</p><p id="682e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">async-await操作符为列表增加了一个场景，在某些情况下这可能会很棘手。</p><p id="b790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始谈论棘手的情况之前，我将简要解释几个基本概念。</p><h1 id="2f2e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">过程</h1><p id="b68e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当一个计算机程序启动时，操作系统会创建一个进程来执行该程序，通常，你可以在操作系统的应用程序管理器上看到这个进程的id，当关闭这个进程时，你的应用程序就完成了。</p><h1 id="f6a2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">线</h1><p id="013c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个<em class="ms">线程</em>是一个<em class="ms">进程</em>的子集，用于执行应用的代码指令，通常一个<em class="ms">进程</em>从一个单独的<em class="ms">线程</em>开始，但是<em class="ms">进程</em>可以创建并完成另外的<em class="ms">线程</em>。</p><p id="e16d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当关闭一个<em class="ms">进程</em>时，所有相关的<em class="ms">线程</em>完成。</p><h1 id="7033" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">阻塞线程</h1><p id="db05" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有些任务执行起来要比其他任务花费更多的时间，例如读写一个大文件，访问网络资源，或者连接和执行针对数据库的命令。</p><p id="b9cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动应用程序时，会创建一个新线程，它开始执行所有代码指令，如显示用户界面、呈现内容以及加载按钮和文本框等可视组件。</p><p id="9a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，当单击一个按钮时，应用程序需要读取和处理一个大文件，在这种情况下，当线程忙于读取和处理文件时，用户界面将被阻塞，无法接受任何用户命令，如单击或滚动</p><p id="5797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的情况也可能发生在没有像API这样的用户界面的应用程序上，当线程执行一个任务时，所有其他指令都必须等待。</p><h1 id="8ed4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">多线程</h1><p id="d026" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">解决这个问题的答案非常简单，我们只需要创建一个额外的线程来执行长流程任务，然后主线程可以执行其他指令，比如让用户点击另一个按钮、滚动屏幕等等。</p><p id="edd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当长进程完成执行时，附加线程被关闭，应用程序从他等待的点继续执行。</p><h1 id="4490" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">异步ˌ非同步(asynchronous)</h1><p id="4d0a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">事实上，大多数长时间的处理任务都是由操作系统而不是应用程序来管理的，这表明创建一个新线程来等待操作系统来管理这些任务是不明智的。</p><p id="a534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是异步来党的地方。</p><p id="dead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步方法将任务委托给操作系统，不会阻塞主线程，当操作系统完成处理时，它将作为回调返回到调用点。</p><p id="32e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">聪明多了，不是吗？</p><h1 id="d369" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">差异</h1><p id="6264" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面我们可以看到同步、异步和多线程之间的执行差异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/357c51348a3ec96f82ee6270902c588b.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*ycHMBXccjBbctUSkS16qnw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同步通话。作者图表</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/811a2f3c4480bf190017d40f580c9f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*lnT-olvr0iAwPpdMOCzNEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异步调用。作者图表</p></figure><h1 id="e506" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">等待操作符</h1><p id="817a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有时需要一个长任务的结果来执行程序中的下一步，所以当任务正在被操作系统执行时，程序不能继续执行其他指令，在这种情况下，我们可以使用await操作符，它将一直等待，直到任务完成并返回来执行下一条指令</p><blockquote class="mv mw mx"><p id="3770" class="kz la ms lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">重要提示:使用await不会阻塞主线程，这意味着在执行任务时应用程序不会没有响应</p></blockquote><h1 id="c737" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">棘手的情况。</h1><p id="0eb5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用async-await使开发人员的体验非常接近sync方法，但实际上并非如此。</p><p id="76c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个不完全了解它如何工作的开发人员将总是使用async-await，而不考虑实际发生了什么，当我们处理多个任务时，我们可以优化并行运行它们的应用程序。</p><p id="383d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解它，请看下面的问题</p><h1 id="28dc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题是</h1><p id="3aee" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我需要调用三个方法，这将需要很长时间来执行，我只能在所有任务完成后返回到调用者。</p><p id="e031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将演示两种方法，并测量每种方法执行所花费的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AwaitingTest类</p></figure><h1 id="21c8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">非优化方法</h1><p id="a8e1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这里，我异步调用所有方法，并按顺序等待它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动排序法</p></figure><h1 id="eff0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">优化方法</h1><p id="0d96" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，我首先创建所有的任务，然后等待它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">awaitin并行方法</p></figure><h1 id="5aea" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结果</h1><p id="9484" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">调用这两个方法会产生非常不同的结果</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">程序类</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6cc0aadd6de3679fe455e4585ad1ba10.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*fx-EUQom5kA5R49hclP0xg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行结果</p></figure><p id="0c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种方法在15秒后完成，而第二种方法只花了5秒，因为它并行运行所有的调用。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="7f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管async-await模型与sync模型非常相似，但它们并不相同，区别可能很微妙。</p><p id="6c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章能帮助你和你的团队更好的理解，下次再见，感谢阅读。</p></div></div>    
</body>
</html>