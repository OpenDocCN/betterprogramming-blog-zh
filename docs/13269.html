<html>
<head>
<title>How To Create Beautiful Command Line Interactions With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js创建漂亮的命令行交互</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-beautiful-command-line-interactions-with-node-js-2fcdfbbac62c?source=collection_archive---------3-----------------------#2022-08-12">https://betterprogramming.pub/how-to-create-beautiful-command-line-interactions-with-node-js-2fcdfbbac62c?source=collection_archive---------3-----------------------#2022-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d34c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Inquierer.js，一个必须知道的Node.js库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/69b2ac9ea3aefd514fd613c31ac34561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBo_lJ6N6qevDiBlPK-0MA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4027" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Node.js最近遇到了很多竞争。一段时间以来，最知名的竞争对手是Deno。最近，它已经看到了Bun如何获得了大量的牵引力和受欢迎程度。但是，不要误以为Node.js已经死了。它一直有很多问题和争议，但截至今天，它仍然是一个很好的选择。</p><p id="4ea5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Deno仍有许多工作要做。它最初的大肆宣传似乎已经降温。Node.js的生态系统是巨大的，Deno的成熟和习惯还需要一点时间。另一方面，Bun还不能用于生产。虽然我是Bun的忠实粉丝，但Node.js还会存在一段时间。</p><p id="d26d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我想通过查看创建命令行交互式用户界面是多么简单来举例说明Node.js生态系统的丰富性。我们如何实现这一目标？通过使用<code class="fe lu lv lw lx b">Inquirer.js</code>。你一定很可能遇到过。像<code class="fe lu lv lw lx b">Remix</code>或<code class="fe lu lv lw lx b">NextJs</code>这样的流行图书馆在幕后使用它。</p><h1 id="a432" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">装置</h1><p id="b71b" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">它是一个<code class="fe lu lv lw lx b">npm</code>依赖项，因此只需执行以下操作即可轻松安装:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="648c" class="mz lz it lx b gy na nb l nc nd">npm install --save inquirer</span></pre><p id="5e3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管<code class="fe lu lv lw lx b">commonjs</code>模块多年来一直是node的主流，但<code class="fe lu lv lw lx b">v9</code>版本和更高版本都是建立在原生<code class="fe lu lv lw lx b">esm</code>模块之上的。从版本<code class="fe lu lv lw lx b">12</code>开始，节点就一直支持<code class="fe lu lv lw lx b">esm</code>模块。</p><p id="5210" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您需要它在旧版本的节点上运行，您可以使用最新版本的<code class="fe lu lv lw lx b">8</code>来安装它。</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="aea8" class="mz lz it lx b gy na nb l nc nd"><em class="ne">// will install the latest 8 versions</em><br/>npm install --save inquirer@^8.0.0</span></pre><p id="1404" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开始使用这个库所需要做的就是简单地导入它。下面是实现这一点的代码:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="69ca" class="mz lz it lx b gy na nb l nc nd"><em class="ne">// v8 and lower</em><br/>const inquirer = require('inquirer');</span><span id="da02" class="mz lz it lx b gy nf nb l nc nd"><em class="ne">// v9 an higher</em><br/>import inquirer from 'inquirer';</span></pre><h1 id="dab0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">提示</h1><p id="9a47" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这个API非常直观。都是围绕<code class="fe lu lv lw lx b">Promises</code>展开的，超级好用，推理。或者，我们可以使用<code class="fe lu lv lw lx b">Rx.Observales</code>，在他们的文档中称为<code class="fe lu lv lw lx b">React Interface</code>。在本文中，我们将关注基于承诺的接口。</p><p id="71f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我们如何把东西打印到屏幕上。API非常简单:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="85b1" class="mz lz it lx b gy na nb l nc nd">inquirer.prompt(questions) -&gt; promise</span></pre><ul class=""><li id="6e3a" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">param</code> —问题:问题对象的数组。问题将按照与数组中相同的顺序显示。</li><li id="e63b" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">returns:带有一系列响应的承诺。</li></ul><p id="731b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于复杂的用例，可以使用<code class="fe lu lv lw lx b">inquirer.registerPrompt</code>创建插件，或者使用<code class="fe lu lv lw lx b">inquirer.createPrompModule</code>将逻辑封装在一个自包含的模块中。</p><h1 id="a13e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">问题对象类型</h1><p id="c384" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这就是将要提供给<code class="fe lu lv lw lx b">inquirer.prompt</code>方法的内容。这是您如何定义提示给用户的问题。</p><p id="f4d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个问题对象可以定义多种处理程序。让我们来看看最有用的:</p><ul class=""><li id="fdaa" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">validate</code>:接收用户输入的函数，必须返回<code class="fe lu lv lw lx b">true</code>或<code class="fe lu lv lw lx b">false</code>。我也可以通过在主体内部使用<code class="fe lu lv lw lx b">this.async()</code>方法来实现异步。</li><li id="b960" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">filter</code>:过滤用户输入的方法。</li><li id="c9d4" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">transform</code>:转换用户输入的方法。</li><li id="bd1d" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">default</code>:返回问题默认值的值或函数。如果用户输入回车，它将默认为这个。</li><li id="6e19" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">when</code>:有条件隐藏/显示问题的功能。稍后会详细介绍。</li></ul><p id="edc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最重要的<code class="fe lu lv lw lx b">key</code>就是<code class="fe lu lv lw lx b">type</code>那个。如果省略，则默认为<code class="fe lu lv lw lx b">input</code>。让我们看看可以使用的不同类型:</p><h2 id="9582" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">1.投入</h2><p id="a29b" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">它只是最基本的一个。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4d73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/034f1757260c75f3bd8c400f3468c742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1xfFMThqTKneV_gn6-oMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Node.js中执行上述代码的屏幕截图</p></figure><h2 id="db4d" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">2.目录</h2><p id="eee1" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">要使用<code class="fe lu lv lw lx b">list</code>类型，我们需要设置<code class="fe lu lv lw lx b">type: 'list'</code>并提供一个<code class="fe lu lv lw lx b">choices</code>数组列表。我们可以显示<code class="fe lu lv lw lx b">disabled</code>选项，并通过使用<code class="fe lu lv lw lx b">new inquirer.Separator</code>使用分隔符来设计我们的布局。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8e94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/14c4016253d070e1e56d404c27b79d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sokVHd0ytPm0siqI2rxBmg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Node.js中执行上述代码的屏幕截图</p></figure><h2 id="5ed4" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">2.罗尔斯主义者</h2><p id="088a" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这个<code class="fe lu lv lw lx b">type</code>只是对<code class="fe lu lv lw lx b">list</code>的简化。它不接受选择数组中的对象，只接受字符串。它让我们使用光标或直接输入选项编号来回复。它将验证输入索引。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="498e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/c739709d7f54c2150c7cc8a76299c88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRGoEqlNSH_s2qtpegTwCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Node.js中执行上述代码的屏幕截图</p></figure><h2 id="cb1f" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">2.发展</h2><p id="3a99" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">扩展的类型与前一个类似，只是它将隐藏所有选项，以获得一个不太冗长的界面。它将只暴露每个选择的<code class="fe lu lv lw lx b">key</code>绑定。默认选项将是大写的。</p><p id="c994" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">答案总是与<code class="fe lu lv lw lx b">display all the options</code>联系在一起。建议将默认选项留空，这样，如果用户键入enter，他们将获得显示给他们的选项列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ede3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2a0186fca51149736e001f979391b2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*V5GZtkXKBpm5EHcXRsdpIg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Node.js中执行上述代码的屏幕记录</p></figure><p id="f65b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意上面的gif图，该设置是如何变得具有响应性和交互性的。它突出显示选中的选项，并在每次击键时给出反馈。这导致了终端上出色的UX。</p><h2 id="d7ae" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">3.检验盒</h2><p id="04ff" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">复选框的特殊性在于，要有默认值，我们必须将其标记为<code class="fe lu lv lw lx b">check: true</code>是选项的数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="95d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/5f0e522f5023c9aa40827ba9a2ecff9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlj0j6nq4pDWJDmE-HadDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Node.js中执行上述代码的屏幕截图</p></figure><h2 id="c0bd" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">4.确认</h2><p id="a993" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">还实现了确认模式。这是许多应用程序中使用的一种常见模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="51a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/dd5e043bda34c8d31a4b4c59ad5a9e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWbiTxqKAdGDIYYLIB3vtw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Node.js中执行上述代码的屏幕截图</p></figure><h2 id="0681" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">6.编者ˌ编辑</h2><p id="80d5" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">编辑器将启动默认的终端编辑器，以便更舒适地输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="32ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/3fb6eef224f6be6307687073081d1239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhFSLQW0JBwwPa3YJUkL6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Node.js中执行上述代码的屏幕截图</p></figure><h2 id="bd4b" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">7.密码</h2><p id="662f" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">还有一种输入敏感数据的类型。这将完全隐藏输入(就像输入sudo密码时一样)或者用我们喜欢的字符屏蔽输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="aebc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/bf63986cf0bd438c0b4b96312deffe0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yz4F3rluro1-0UnhtueTZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Node.js中执行上述代码的屏幕截图</p></figure><h1 id="2de0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">问题相关性</h1><p id="d2f4" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">在某些情况下，您可能希望根据以前的回答包含或删除问题。有两种方法可以解决这个问题:</p><ul class=""><li id="cc10" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">使用<code class="fe lu lv lw lx b">when</code>函数:方法返回true时显示问题，返回false时隐藏问题。</li><li id="963b" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">嵌套提示:用另一个提示将承诺的结果与前面的答案嵌套。</li></ul><h2 id="6eeb" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">使用时间</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="da9c" class="mz lz it bd ma nu nv dn me nw nx dp mi lh ny nz mk ll oa ob mm lp oc od mo oe bi translated">嵌套提示</h2><p id="d816" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">嵌套提示很容易，让我们对想要做的事情有更多的了解。当我们得到所有问题的答案时，我们只需要调用<code class="fe lu lv lw lx b">inquirer.prompt</code>。</p><p id="0548" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="1e04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码片段产生了相同的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/7c2a44b4ad3a55cbbce8f31f231dd912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qdh1PofygDSmpo5fCo8mkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Node.js中执行上述两个代码的屏幕截图</p></figure><h1 id="825b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">包裹</h1><p id="bd46" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">在Node.js中,<code class="fe lu lv lw lx b">Inquirer</code>库使任何基于过程的设置变得有趣而简单。它提供了对我们想要显示的内容的许多控制和粒度。有很多定制，代码干净易读。</p><p id="9f17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一个吸引人且简单的设置过程可能是成功的关键。<code class="fe lu lv lw lx b">Inquirer</code>从我们这里拿走所有的重担，这样我们就可以专注于真正重要的事情。</p><p id="ab3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有兴趣了解更多，请在这里查看图书馆<a class="ae ok" href="https://github.com/SBoudrias/Inquirer.js#documentation" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>