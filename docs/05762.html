<html>
<head>
<title>Designing Highly Available Container Applications on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上设计高可用性容器应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/designing-highly-available-container-applications-on-kubernetes-50455716b76f?source=collection_archive---------8-----------------------#2020-08-04">https://betterprogramming.pub/designing-highly-available-container-applications-on-kubernetes-50455716b76f?source=collection_archive---------8-----------------------#2020-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="59b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">与pod中断预算和反亲和</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/268a62ea31692c205503a3d440ce0423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BAhglWQXDtTQ2o9L"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>拍摄。</p></figure><p id="b626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个多节点的Kubernetes集群在设计上是高度可用的。然而，这并不意味着如果集群发生了可怕的事情，您的容器应用程序不会被中断。</p><p id="ed74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes根据几个因素为节点分配一个pod，这些因素包括资源可用性、节点可用性、污点、容忍度以及相似性和反相似性规则。在默认设置中，Kubernetes可以在满足这些约束的任何节点上安排一个pod。</p><p id="b8af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，Kubernetes不会尝试应用程序的高可用性。如果您旋转pod的三个副本，不一定会将它们分布在所有工作节点上。Kubernetes将尽可能地覆盖这一点，但如何传播取决于上述因素。</p><p id="e071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不意味着你不能告诉Kubernetes做你想要的。在设计高可用性时，您自然希望您的实例分布在多个区域中，但是这是以您可能希望避免的延迟和出口费用为代价的。因此，您需要平衡您的需求和实用的设计决策。</p><p id="6050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，让我们关注高可用性设计。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bd62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Pod中断预算</h1><p id="c31b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Pod中断预算是一个Kubernetes对象，它确保复制的应用程序在任何给定的时间点仍然保持一定数量的健康副本。</p><p id="7d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，一个名为web-app的应用程序运行三个副本，pod中断预算为2，如果有任何自愿中断，则在给定时间至少会有两个实例运行。</p><p id="9a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望确保您的客户在修补和升级集群时面临尽可能少的中断，这一点尤其有用。您还可以在需要法定人数才能运行的应用程序中使用pod中断预算。</p><p id="3ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您应该仅在运行多个复制副本的应用程序上指定pod中断预算。如果您在具有单个所需副本的应用程序上指定中断预算，Kubernetes将不会在计划内停机的情况下从集群中驱逐pod。</p><p id="35b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然使用pod中断预算是一种最佳做法，但您需要确保在考虑pod中断预算的情况下耗尽节点。这意味着您不应该一次耗尽多个节点。相反，您应该等待Kubernetes将被驱逐的pod重新安排到新节点，然后再尝试排出另一个。</p><p id="2b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以指定pod中断预算:按百分比或pod数量。例如，如果您将<code class="fe mz na nb nc b">minAvailable</code>指定为2，那么Kubernetes允许驱逐，前提是一次至少有两个pod是健康的。如果您将<code class="fe mz na nb nc b">minAvailable</code>指定为30%，这意味着如果一次有30%的所需副本是健康的，Kubernetes将允许驱逐。</p><p id="5666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe mz na nb nc b">minAvailable</code>或<code class="fe mz na nb nc b">maxUnavailable</code>标志来控制这种行为。这取决于您的具体使用情况。在大多数用例中，推荐使用<code class="fe mz na nb nc b">minAvailable</code>。</p><p id="abfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为NGINX部署配置一个pod中断预算，然后自己看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在让我们创建一个NGINX部署:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="19d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看部署状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署已启动并正在运行，所有四个副本都运行良好且可用。</p><p id="4aa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们尝试清空<code class="fe mz na nb nc b">gke-cluster-1-default-pool-bf356567-mrnh</code>节点，因为两个NGINX实例正在该节点上运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="aedc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你查看日志，你会发现驱逐其中一个pod(<code class="fe mz na nb nc b">nginx-5ffb5df89f-ctv4c</code>)的错误，因为它会违反pod中断预算。但是，它会删除另一个pod，并且只有在另一个pod在另一个节点上被成功调度并且运行良好之后才会驱逐<code class="fe mz na nb nc b">nginx-5ffb5df89f-ctv4c</code>。</p><p id="ae5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看分离舱被驱逐后我们会得到什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，Kubernetes已经重新安排了其他节点上的pod，它们已经启动并运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a5f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Pod亲和力和反亲和力</h1><p id="b92e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Pod亲合性和反亲合性是确保高可用性的另一种方法，它尽可能将容器安排在不同的节点上。默认的Kubernetes调度器根据资源需求选择一个节点，默认情况下不保证将您的pod放在不同的节点中。</p><p id="4b43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以强制Kubernetes使用pod反亲缘关系来安排您的pod，使它们尽可能分散。万一您失去一个数据中心或一个节点，这对于确保高可用性非常有帮助。</p><p id="c699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以一次规划一个节点的修补和升级，并确保该过程中的中断最小。如果您的所有pod都出现在一个节点中，这将成为一个问题。</p><p id="77b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pod反相似性主要以两种方式工作，每种方式提供一个硬<code class="fe mz na nb nc b">(requiredDuringSchedulingIgnoredDuringExecution)</code>或一个软检查<code class="fe mz na nb nc b">(preferredDuringSchedulingIgnoredDuringExecution)</code>。</p><p id="58de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种场景都有其用例。硬检查的一个用例是在每个节点上提供一个复制的Redis缓存。这将有助于应用程序在本地与Redis交互，从而提高性能。</p><p id="30ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以对无状态前端应用程序进行软检查，这将考虑资源可用性和其他需求。软条件的想法是使应用程序尽可能高可用，让Kubernetes决定什么是最好的，而不是在不需要的时候超载资源。</p><p id="3a5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试在每个Kubernetes节点上部署一个带有硬检查的Redis缓存。因为我们有三个节点在运行，所以我们将创建Redis的三个副本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="87e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们去拿豆荚，看看发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="58ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，发生什么事了？为什么有一个pod待定？如果您还记得的话，我们已经清空了其中一个节点，但它仍未准备好进行调度。</p><p id="9a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这个节点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="dd03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们打开节点，允许在其中进行调度，看看会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们一取消对节点的授权，Redis pod就开始运行。到目前为止，一切顺利！</p><p id="aba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们修改NGINX部署，以便Kubernetes将pod分散到各个节点上。目前，每个节点上运行两个pods，最近未授权的节点上没有运行pods。让我们应用软反亲和规则，看看我们会得到什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们去拿豆荚，看看我们能得到什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们看到的，所有的豆荚都分布在节点上。</p><p id="03fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将部署扩展到六个单元，并看看Kubernetes在哪里部署单元:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，Kubernetes在空节点中创建了两个新的pod，每个节点创建了两个pod。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="09ac" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="28fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然有其他方法可以确保您的Kubernetes集群的高可用性，但pod中断预算和pod反关联性是使您的应用程序在任何时候都具有高可用性的最佳方法。当然，为了实现高可用性，您还应该确保您的集群也是高可用性的。例如，您的节点应该分布在一个区域的多个分区中，或者分布在一个内部部署的多个数据中心中。</p><p id="609e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>