<html>
<head>
<title>Embrace Dependency Injection With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React拥抱依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/embrace-dependency-injection-for-react-e45ea58ca4f2?source=collection_archive---------12-----------------------#2020-01-08">https://betterprogramming.pub/embrace-dependency-injection-for-react-e45ea58ca4f2?source=collection_archive---------12-----------------------#2020-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e2c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本文中，我们将讨论如何在React库中有效地利用依赖注入</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/96de2ae4bc58f73e9fac6094c3b7012c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JVML-SfxUuWU0lWU"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">伊琳娜·伊里斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="24e0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="81a2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在设计和实现库时，可重用性和可组合性是主要的设计目标。理想情况下，一个共享的组件应该有一个明确的、狭窄的目的，这样它就可以用于几种不同的用例(做一件事，但是要做好)。</p><p id="5e40" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">实际上，这样的模块化组件通常不是完全独立的，而是需要外部服务。一个常见的例子是日志记录。</p><p id="d864" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">共享组件可以通过多种方式来决定使用什么服务来实现特定功能，例如，使用什么日志框架。</p><h2 id="7582" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">紧密结合</h2><p id="63f8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最简单的方法是紧耦合。共享组件只是做出一个决定，并显式地引入一个特定的服务或日志框架。</p><p id="c39e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一方面，这种方法也是组件消费者最不希望看到的，因为它会导致引入大量的外部依赖项。如果使用来自不同来源的共享组件，依赖关系甚至会变得不兼容，或者为逻辑上相同的功能引入不同的实现。</p><h2 id="c006" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">松耦合</h2><p id="4b43" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Service_locator_pattern" rel="noopener ugc nofollow" target="_blank">服务定位器模式</a>，我们可以实现组件的松耦合形式<em class="nb"> </em>。组件根据服务的抽象(接口)向服务定位器请求实现，而不是引入显式实现。</p><p id="810f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，实际的实现可以在运行时由应用程序提供，该应用程序将所有组件集合在一起。虽然这种模式提供了强大的模块化，但它仍然将服务注册中心作为访问的中心点，所有组件都需要使用同一个服务注册中心。</p><h2 id="4d53" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">依赖注入</h2><p id="5fdf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>模式是松散耦合的一种不同方法。我们不是让组件查找特定的服务，而是将该服务的实现传递给组件。</p><p id="a350" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这使得共享组件可以独立实现，而不需要任何对中心服务的显式引用，例如服务注册。</p><p id="438a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以日志记录器为例，共享组件将只定义一个日志记录器接口，并将其留给调用者来提供实现。</p><p id="954e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将探索如何使用DI模式来实现模块化的<a class="ae kv" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank"> React </a>组件。</p><p id="0ea9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">虽然竞争框架，如<a class="ae kv" href="https://angular.io/guide/dependency-injection" rel="noopener ugc nofollow" target="_blank"> Angular </a>，已经内置了DI，但在React中没有对它的明显支持。原因是您可以将<a class="ae kv" href="https://marmelab.com/blog/2019/03/13/react-dependency-injection.html" rel="noopener ugc nofollow" target="_blank"> JSX组合</a>模式视为一个合适的DI容器。依赖关系可以作为属性从一个组件传递到另一个组件。所以不需要额外的实现。</p><p id="1769" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，在较大的系统中，通过属性传递依赖关系很容易变得麻烦，因为依赖关系的数量通常随着系统的大小而增长。</p><p id="81de" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">和依赖关系会出现在父链上的组件的属性中。这也是React为什么会有c <a class="ae kv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> <em class="nb"> ontext </em> </a>的概念。这样的上下文允许我们向JSX树中的组件提供服务，而不必通过组件的属性传递它们。这是实现DI的一种非常方便的方式，它作为React核心的一部分得到支持，不需要额外的库。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="4ab2" class="kw kx iq bd ky kz nj lb lc ld nk lf lg jw nl jx li jz nm ka lk kc nn kd lm ln bi translated">要解决的挑战</h1><p id="140a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我们考虑如何提供上下文时，使用上下文的挑战(我们将在本文中解决)就出现了。由于系统是基于嵌套的JSX组件，我们需要为每个提供的上下文提供一个嵌套层次。并且这种嵌套需要以正确的依赖顺序出现。</p><p id="4c60" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以一个提供两种服务的系统为例:日志服务和数据服务(通过REST获取数据)。我们的组件需要这两种服务，因为它们需要获取数据，还需要记录日志。然而，数据服务也需要日志服务来进行自己的日志记录。</p><p id="646b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这意味着我们必须在提供数据服务之前提供记录器服务，因为我们需要记录器来实例化它。</p><p id="fdc3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">虽然这对于两个服务来说很简单，但是如果涉及更多的服务，就会变得非常复杂并且容易出错。我们基本上必须按照与。他们的依赖。没有内置的方法来帮助我们完成这项任务。</p><h2 id="51f9" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated"><strong class="ak">总结</strong></h2><p id="47ce" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">DI是分离可重用组件的一种强有力的方法——例如，对于库。有了上下文的概念，React提供了一种便利的方式来<em class="nb">消费</em>这些上下文，但是没有一种便利的方式来<em class="nb">以正确的顺序在一个非平凡的系统中提供</em>它们。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="e342" class="kw kx iq bd ky kz nj lb lc ld nk lf lg jw nl jx li jz nm ka lk kc nn kd lm ln bi translated">依赖性声明</h1><p id="30b2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了简化上下文的提供，我们将引入一个数据结构来声明具有以下字段的上下文提供者的依赖性:</p><ul class=""><li id="4027" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated"><code class="fe nx ny nz oa b">provides: Context&lt;T&gt;</code>是结构提供的上下文</li><li id="bbb4" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated"><code class="fe nx ny nz oa b">dependencies?: Array&lt;Context&lt;any&gt;&gt;</code>是所需上下文的数组</li><li id="bf15" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated"><code class="fe nx ny nz oa b">optionalDependencies?: Array&lt;Context&lt;any&gt;&gt;</code>是一组可选的上下文</li><li id="a173" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated"><code class="fe nx ny nz oa b">module</code>是实际提供上下文的<a class="ae kv" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank"> React组件</a>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于声明提供者之间关系的数据结构</p></figure><p id="bbff" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有了这个结构，我们可以知道在使用<code class="fe nx ny nz oa b">module</code>组件之前必须提供必需的和可选的上下文(它提供了由这个结构描述的上下文)。</p><p id="5597" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们区分可选依赖项和必需依赖项，以便更容易引导组件，因为只需要提供必需的依赖项。</p><p id="d5ec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">可选依赖项的一个很好的例子是日志服务。在没有记录器服务的情况下，模块总是可以回退到无操作记录器。但是，如果消费者决定使用日志记录，它可以将日志记录器作为一个依赖项提供——该模块在两种情况下都可以工作。</p><p id="5dc7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">提供上下文的模块的实现是一个简单的JSX组件，它首先使用必需的和可选的依赖项，然后使用它们来提供服务，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">vanilla React中的服务实现</p></figure><p id="5bfc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">重要的是实现使用<a class="ae kv" href="https://reactjs.org/docs/react-component.html#props" rel="noopener ugc nofollow" target="_blank">子</a>属性来允许嵌套。</p><p id="5902" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">服务依赖项的声明将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务提供者及其依赖项的声明</p></figure><p id="062e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最终使用记录器和服务的JSX UI组件将是(使用<a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用依赖项的UI组件</p></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="b411" class="kw kx iq bd ky kz nj lb lc ld nk lf lg jw nl jx li jz nm ka lk kc nn kd lm ln bi translated">找到正确的顺序</h1><p id="5cb1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">给定依赖关系的声明性描述，我们所要做的就是按照<a class="ae kv" href="https://en.wikipedia.org/wiki/Topological_sorting" rel="noopener ugc nofollow" target="_blank">拓扑顺序</a>对它们进行排序，然后按照该顺序创建提供者的嵌套层次结构。</p><p id="0d6c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于我们这个简单的例子，渲染顺序应该是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">vanilla React中的引导依赖项</p></figure><p id="d358" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们注意到，每个提供的服务需要一个嵌套层次，嵌套的顺序是拓扑顺序。根据我们在应用程序中使用的依赖项的数量，这种嵌套可能会变得很深，我们希望自动执行它的引导过程。</p><p id="8ce6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用我们的依赖声明，我们已经有了足够的信息来自动和通用地实现嵌套——例如，通过使用引用实现<a class="ae kv" href="https://www.npmjs.com/package/rx-react-component" rel="noopener ugc nofollow" target="_blank">createModuleFromProvider</a>。</p><p id="3d18" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该方法接受一个未排序的<code class="fe nx ny nz oa b">ReactProvider</code>数据结构列表，按照拓扑顺序对它们进行排序，并创建一个实现所需嵌套的JSX组件。另外，如果没有提供所需的依赖项，这个实现还会警告我们。</p><p id="14c1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于我们的例子，我们使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用动态创建的组件引导依赖关系</p></figure><p id="0dba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意，排序和嵌套完全隐藏在动态生成的JSX组件<code class="fe nx ny nz oa b">Module</code>的实现中。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="c9ce" class="kw kx iq bd ky kz nj lb lc ld nk lf lg jw nl jx li jz nm ka lk kc nn kd lm ln bi translated">简化提供者组件的创建</h1><p id="5cc0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">提供者组件的实现总是遵循相同的模式:</p><ul class=""><li id="d550" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated">解析实现提供程序所需的依赖项(如果缺少所需的依赖项，可以选择紧急援助或警告)</li><li id="8a8e" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated">实例化所提供的服务</li><li id="6105" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated">使用<a class="ae kv" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank">上下文提供者</a>提供服务</li></ul><p id="087d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">就像我们上面的示例服务一样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="0110" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些步骤是重复的，也容易出错，因为我们需要确保实现中使用的上下文是那些在我们的<code class="fe nx ny nz oa b">ReactProvider</code>中声明为依赖的上下文，并且组件实际上提供了声明的上下文。</p><p id="7da1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以为了简化和安全起见，我们引入了助手函数<a class="ae kv" href="https://www.npmjs.com/package/rx-react-component" rel="noopener ugc nofollow" target="_blank">createInjectableReactProvider</a>。该函数接受以下参数:</p><ul class=""><li id="7e66" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated"><code class="fe nx ny nz oa b">provides: Context&lt;T&gt;</code>:要提供的上下文</li><li id="6773" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated"><code class="fe nx ny nz oa b">dependencies?: Array&lt;Context&lt;any&gt;&gt;</code>:一组必需的上下文</li><li id="5e3d" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated"><code class="fe nx ny nz oa b">optionalDependencies?: Array&lt;Context&lt;any&gt;&gt;</code>:可选上下文的数组</li><li id="7dd5" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated"><code class="fe nx ny nz oa b">fct: Function</code>:接受已解析的依赖关系并返回所提供服务的工厂函数。在TypeScript中，我们可以表达函数的签名，以便解析的依赖项的类型与声明的上下文的类型相匹配，这样编译器就可以确保声明和实现是同步的。</li></ul><p id="f625" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nx ny nz oa b">createInjectableReactProvider</code>的结果是一个<code class="fe nx ny nz oa b">ReactProvider</code>结构。<code class="fe nx ny nz oa b">module</code>字段——例如，JSX组件——是一个动态生成的组件，它将首先收集依赖项，然后调用工厂函数，然后提供结果。</p><p id="f2af" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面的例子简化为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7eb2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意<code class="fe nx ny nz oa b">createService</code>工厂函数使用<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring" rel="noopener ugc nofollow" target="_blank"> ES6数组析构</a>作为一种简短且类型安全的方式来访问它的依赖项。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="c788" class="kw kx iq bd ky kz nj lb lc ld nk lf lg jw nl jx li jz nm ka lk kc nn kd lm ln bi translated">作为注入依赖项的JSX UI组件</h1><p id="263b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">到目前为止，我们已经使用DI来注入服务——例如，在我们的例子中，日志服务或数据服务。然而，我们可以完全接受这种模式，也可以考虑我们的UI组件服务。</p><p id="e781" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">问:我们为什么要这么做？答:关注点分离！</p><p id="f5fd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">到目前为止，我们使用服务的UI组件如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="2eff" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个实现混合了两个问题，因为它将依赖关系作为组件的呈现<strong class="lq ir"> </strong>过程的一部分来解决。</p><p id="8e7f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，从概念上讲，我们并不期望依赖关系会随着每一次渲染而改变——这与我们组件的潜在<a class="ae kv" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">属性</a>形成对比，这些属性对渲染有直接的影响。如果我们要将组件表示为一个类，我们的依赖关系最好流入构造函数，而不是render方法。</p><p id="69a8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过使用<code class="fe nx ny nz oa b">createInjectableReactProvider</code>和工厂函数动态生成组件类，我们可以更清晰地分离这些关注点，并引入性能优化。</p><p id="8bf8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">依赖关系只有在组件类通过工厂构建时才能解决，而不是在渲染时。这样做的性能优势在于，我们可以在构建时实现一次只依赖于依赖关系的计算，而不是在渲染时实现多次。使用这种模式，我们的组件将是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3876" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，这个提供者可以和<code class="fe nx ny nz oa b">createModuleFromProvider</code>一起使用，不仅提供服务，还按照正确的拓扑顺序提供UI组件。当然，如果一个UI组件使用另一个UI组件，它会让系统注入那个组件，从而实现UI组件之间的完全解耦。</p><p id="4e87" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，后者并不总是必需的——特别是，如果我们知道一个UI组件没有依赖关系并且不是动态的，就没有必要把它表示为一个动态的、可注入的组件。但这也不会造成伤害。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="1b2e" class="kw kx iq bd ky kz nj lb lc ld nk lf lg jw nl jx li jz nm ka lk kc nn kd lm ln bi translated">摘要</h1><p id="dcbb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们认为DI是创建模块化UI组件的一种有价值的模式，尤其是在图书馆中使用时。React提供了一种合适的方法来消费依赖项，但是缺少一种简单的方法来为重要的场景提供依赖项。</p><p id="7ef2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们引入一个概念和一个参考实现来声明可注入依赖之间的关系，并展示如何使用它们来创建模块化的组件和服务，只需要几行代码。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="ebab" class="kw kx iq bd ky kz nj lb lc ld nk lf lg jw nl jx li jz nm ka lk kc nn kd lm ln bi translated">资源</h1><ul class=""><li id="6dbf" class="no np iq lq b lr ls lu lv lx oi mb oj mf ok mj nt nu nv nw bi translated"><a class="ae kv" href="https://www.npmjs.com/package/rx-react-component" rel="noopener ugc nofollow" target="_blank">参考文献实现</a></li><li id="313f" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated"><a class="ae kv" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank"> React文档</a></li><li id="5e8c" class="no np iq lq b lr ob lu oc lx od mb oe mf of mj nt nu nv nw bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入模式</a></li></ul></div></div>    
</body>
</html>