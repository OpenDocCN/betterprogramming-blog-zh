<html>
<head>
<title>What is StrictMode in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的StrictMode是什么</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-strictmode-is-your-lifeline-for-the-future-1f73064d3bf8?source=collection_archive---------4-----------------------#2021-05-04">https://betterprogramming.pub/react-strictmode-is-your-lifeline-for-the-future-1f73064d3bf8?source=collection_archive---------4-----------------------#2021-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3edb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于React你需要知道的一切。严格模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/edad6dff4584e8803c93f11a13da72ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HwcCW9QF4x_4oCwd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@heftiba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Toa Heftiba </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的funPhoto。</p></figure><p id="9c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常当我回头看我很久以前写的一段代码时，我认为我可以写得更好100倍。我确信我不是这条船上唯一的人。随着我们获得更多的经验，我们不断发展我们的编码实践和设计模式。React也是这种情况。</p><p id="2e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React也经历了许多转变，随着它的发展，过去被认为是好的某些实践不再适合未来的路线图。随着v16的发布，发生了一个重大变化，它对React Fiber的架构进行了重写。主要关注的是时间安排(即，决定何时应该执行一项工作，同时记住不同任务(如动画、UI更新等)的优先级)。</p><p id="6c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎与此同时，React中添加了一个新的上下文API。</p><p id="b096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，为了在未来版本中提供并发模式，渲染阶段被分成多个部分，已经发生了很多变化。它的开始见证了React钩子的引入，某些生命周期方法的废弃，等等。</p><p id="fb2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看看React中的<code class="fe lv lw lx ly b">StrictMode</code>帮助我们识别的所有不推荐使用的模式。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d1ff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是反应。StrictMode以及如何使用它？</h1><p id="d5cd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.StrictMode</code>是一个突出应用程序中潜在问题的工具。它的工作方式是将应用程序呈现为一个组件，封装应用程序的一部分或整个应用程序。<code class="fe lv lw lx ly b">StrictMode</code>不在DOM中呈现任何可见的元素，但是在开发模式下启用某些检查并提供警告。</p><p id="cc15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nd">注意:</em> <code class="fe lv lw lx ly b"><em class="nd">StrictMode</em></code> <em class="nd">在生产模式下不运行任何检查或显示警告。</em></p><p id="3255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以像这样为整个应用程序启用<code class="fe lv lw lx ly b">React.StrictMode</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="11b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过用<code class="fe lv lw lx ly b">&lt;React.StrictMode&gt;</code>包装它，您可以在应用程序的一部分中类似地启用它。</p><p id="68de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从React的v17开始，<code class="fe lv lw lx ly b">StrictMode</code>支持以下功能:</p><ul class=""><li id="0f51" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">识别传统字符串引用。</li><li id="5a61" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">检测已弃用的<code class="fe lv lw lx ly b">findDOMNode</code>方法。</li><li id="5f6c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">检测旧上下文API的使用。</li><li id="d92b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">检测已被React否决的不安全的生命周期方法。</li><li id="c484" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">检测React组件中的意外副作用。</li></ul><h2 id="aba5" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">1.识别传统字符串引用</h2><p id="7c94" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">React最初版本中的Refs是使用字符串进行赋值的。然而，正如Dan Abramov在<a class="ae ky" href="https://github.com/facebook/react/pull/8333#issuecomment-271648615" rel="noopener ugc nofollow" target="_blank">本期Github</a>中指出的那样，它也存在许多问题:</p><blockquote class="og oh oi"><p id="57bb" class="kz la nd lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">“它要求React跟踪当前呈现的组件(因为它不能猜测<code class="fe lv lw lx ly b">this</code>)。这使得反应有点慢。</p><p id="e091" class="kz la nd lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">它并不像大多数人期望的那样使用“渲染回调”模式(例如<code class="fe lv lw lx ly b">&lt;List renderRow={this.renderRow} /&gt;</code>)，因为由于上述原因，ref将被放置在<code class="fe lv lw lx ly b">List</code>上。</p><p id="f515" class="kz la nd lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">它是不可组合的，也就是说，如果一个库在传递的子对象上放置了一个引用，用户就不能在其上放置另一个引用。回调引用是完全可组合的。"</p></blockquote><p id="3950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这些原因以及许多其他原因，例如在需要强制转换引用的TypeScript中键入引用的问题，为类组件引入了更好的替代方法:</p><ul class=""><li id="6777" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">回调参考</li><li id="da88" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">React.createRef</code></li></ul><h2 id="fbbe" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">2.检测不推荐使用的<code class="fe lv lw lx ly b">findDOMNode</code>方法</h2><p id="df03" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在给定类实例的情况下，之前使用了<code class="fe lv lw lx ly b">ReactDOM.findDOMNode</code>方法来获取DOM节点。通过直接向DOM元素而不是类实例添加一个ref，可以避免使用<code class="fe lv lw lx ly b">findDOMNode</code>。</p><p id="45e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">findDOMNode</code> API有两个主要问题:</p><ul class=""><li id="2a1a" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">这将只返回类组件实例中的第一个子级。但是，随着v16中片段的引入，您可能会从一个组件实例中返回多个元素，这可能会导致一个问题，因为您可能希望将所有元素的包装器或返回的元素列表中的特定元素作为目标。</li><li id="9874" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">findDOMNode</code> API是一个只接受请求的API(即当它被调用时，它将评估并返回结果)。例如，如果所呈现的元素在子元素中被有条件地改变，父元素可能不知道。</li></ul><p id="a4d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">findDOMNode</code>的替代方法是使用<code class="fe lv lw lx ly b">React.forwardRef</code>并将ref传递给子组件中所需的元素，或者通过单独的名称(如<code class="fe lv lw lx ly b">innerRef</code>)传递ref，并从子组件的props中使用它来设置所需元素的ref。</p><h2 id="eb7f" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">3.传统上下文API</h2><p id="b319" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">React版本引入了新的上下文API。在此之前，使用了旧的易错API，如果父层次结构中的某个组件通过实现<code class="fe lv lw lx ly b">shouldComponentUpdate</code>停止了子元素的重新呈现，将导致消费者无法更新。</p><p id="b836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使React继续支持v16.x中的旧API，<code class="fe lv lw lx ly b">StrictMode</code>也会通过显示警告来指出旧的上下文API的用法，以便可以将它们移动到最新版本。</p><h2 id="c3a3" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">4.检测不安全的生命周期方法</h2><p id="e99b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在React的v16.3.0中，对React APIs进行了一些突破性的更改。其中一个变化是生命周期方法如<code class="fe lv lw lx ly b">componentWillMount</code>、<code class="fe lv lw lx ly b">componentWillReceiveProps</code>和<code class="fe lv lw lx ly b">componentWillUpdate</code>的废弃。新的生命周期也被加入，比如<code class="fe lv lw lx ly b">getDerivedStateFromProps</code>和<code class="fe lv lw lx ly b">getSnapShotBeforeUpdate</code>。</p><p id="111e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这些生命周期方法在React的后续版本中仍然可用，并且在重命名时添加了前缀<code class="fe lv lw lx ly b">UNSAFE_</code>, React可能会在未来的版本中完全删除它们。</p><p id="0439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这些生命周期方法被否决了？</p><p id="9c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，我们必须首先知道React通常分两个阶段工作:</p><ul class=""><li id="a0c2" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">呈现阶段:在这个阶段，React检查需要对DOM进行哪些更改。React在这个阶段调用一个<code class="fe lv lw lx ly b">render</code>函数，并将结果与之前的渲染进行比较。渲染阶段生命周期包括<code class="fe lv lw lx ly b">componentWillMount</code>、<code class="fe lv lw lx ly b">componentWillReceiveProps</code>、<code class="fe lv lw lx ly b">componentWillUpdate</code>和<code class="fe lv lw lx ly b">render</code>。</li><li id="9cdf" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">提交阶段:<strong class="lb iu"> </strong>这是React实际提交对DOM的更改并调用提交阶段生命周期(如<code class="fe lv lw lx ly b">componentDidMount</code>和<code class="fe lv lw lx ly b">componentDidUpdate</code>)的阶段。</li></ul><p id="9ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提交阶段很快，但是呈现阶段可能很慢。为了用并发模式的愿景来优化它，React决定将渲染分成几部分，暂停并恢复工作，以避免阻塞浏览器。</p><p id="d8a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当他们这样做时，渲染阶段的生命周期可能会被调用多次，如果这些包含副作用或不正确的做法，它们可能会导致应用程序的行为不一致。此外，这些生命周期中的一些会鼓励糟糕的开发实践。其中包括:</p><ul class=""><li id="ff21" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">componentWillMount</code></li><li id="f5ce" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">componentWillReceiveProps</code></li><li id="01d1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">componentWillUpdate</code></li></ul><p id="cfd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看其中的一些做法。</p><h2 id="9184" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">在componentWillMount中调用setState</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始化状态的正确和不正确方式</p></figure><p id="cd6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在上面的代码片段中看到的，<code class="fe lv lw lx ly b">componentWillMount</code>用于在初始渲染之前设置状态，但是通过在构造函数中设置初始状态或者使用<code class="fe lv lw lx ly b">state</code>作为类属性，可以很容易地重构它。</p><h2 id="ddff" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">组件WillMount中的异步请求</h2><p id="391c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在<code class="fe lv lw lx ly b">componentWillMount</code>中有一个异步获取请求对于服务器端渲染和即将到来的并发模式都是有问题的。使用服务器端渲染，将不会使用在<code class="fe lv lw lx ly b">componentWillMount</code>中获取的数据。对于异步渲染，提取请求可能会进行多次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在React类组件中获取数据的不正确和正确方法</p></figure><p id="82de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一种普遍的误解，认为在初始渲染之前，在<code class="fe lv lw lx ly b">componentWillMount</code>中获取的任何数据都是可用的。这是不正确的，您应该使用加载状态来避免使用初始渲染中的数据，并进行API调用来获取<code class="fe lv lw lx ly b">componentDidMount</code>中的数据。</p><h2 id="df2a" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">在组件WillMount中添加订阅或侦听器</h2><p id="3f28" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在<code class="fe lv lw lx ly b">componentWillMount</code>中添加订阅/监听器有两个问题:</p><ul class=""><li id="d0d5" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">使用服务器端渲染，服务器上不会调用<code class="fe lv lw lx ly b">componentWillUnmount</code>函数，因此不会进行清理，并可能导致内存泄漏。</li><li id="a0d7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">使用异步呈现，可以附加多个订阅，因为呈现阶段生命周期可能被调用多次。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加和删除监听器的正确方法是将<code class="fe lv lw lx ly b">componentDidMount</code>和<code class="fe lv lw lx ly b">componentWillUnmount</code>生命周期方法配对。</p><h2 id="c897" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">更新状态或调用属性更改的副作用</h2><p id="cfc6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">以前，<code class="fe lv lw lx ly b">componentWillReceiveProps</code>生命周期用于在父道具改变时更新状态或调用子道具中的副作用。虽然没有太大的问题，但是开发人员中有一个误解，认为这个生命周期只有在道具更新时才会被调用。</p><p id="5468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，每当重新渲染父属性时，它就会被调用。</p><p id="31b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在比较了以前和当前的属性后，如果没有正确执行，任何函数调用或状态更新都可能会有不一致的行为。</p><h2 id="7496" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">更新前读取DOM属性</h2><p id="d5b8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时，您可能希望保存某些DOM属性，例如更新前的滚动位置，以便在应用更新时将其还原，从而防止在添加或删除新项目时用户当前查看的项目从视图中消失。</p><p id="23f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前，您会在<code class="fe lv lw lx ly b">componentWillUpdate</code>生命周期方法中这样做。然而，使用异步呈现，调用<code class="fe lv lw lx ly b">componentWillUpdate</code>和调用<code class="fe lv lw lx ly b">componentDidUpdate</code>的时间之间可能会有间隙，如果用户以实际改变滚动位置的方式与DOM交互，例如调整窗口大小或实际滚动更多内容，这可能会导致不一致。由于这个原因，<code class="fe lv lw lx ly b">getSnapshotBeforeUpdate</code>被建议作为<code class="fe lv lw lx ly b">componentWillUpdate</code>的替代，因为它正好在DOM发生突变之前被调用。</p><p id="da2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经讨论了一些为什么要删除这些用法的原因，让我们回到正题上来。</p><p id="0044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能会想，“为什么我们甚至需要一些实用程序来指出不安全的函数呢？我们可以简单地搜索并使用推荐的实践更新它们。”</p><p id="b265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然您是正确的，并且可以在您自己的代码库中这样做，但是您将无法容易地识别出在您的代码库中用作依赖项的<em class="nd">不安全的</em>生命周期。<code class="fe lv lw lx ly b">StrictMode</code>也将帮助您指出它们，以便您可以更新它们(或者如果最新版本不兼容，用替代版本替换它们)。</p><h2 id="31a0" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">5.检测意外的副作用</h2><p id="57b4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">正如我们在上一节中确定的，React希望在即将到来的并发模式中优化呈现阶段，它决定分解呈现阶段。因此，渲染阶段生命周期可以被多次调用，如果在其中使用了副作用，会导致意外的行为。</p><p id="3d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React的最新版本中，这些功能包括:</p><ul class=""><li id="8417" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">constructor</code></li><li id="9214" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">getDerivedStateFromProps</code></li><li id="0139" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">shouldComponentUpdate</code></li><li id="9322" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">render</code></li><li id="215a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">setState</code>类和功能组件中的更新器功能</li><li id="c0df" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">传递给<code class="fe lv lw lx ly b">useMemo</code>、<code class="fe lv lw lx ly b">useState</code>、<code class="fe lv lw lx ly b">useReducer</code>的功能</li></ul><p id="82c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然副作用是不确定的，但是<code class="fe lv lw lx ly b">StrictMode</code>通过两次调用上面的函数，使副作用对开发人员来说更加确定。这样，如果在渲染阶段函数中错误地编写了任何副作用，由于它所呈现的明显的不一致性，它本身就可能处于开发模式中。</p><p id="ea0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果在一个<code class="fe lv lw lx ly b">constructor</code>函数中建立一个WebSocket连接，那么在开发模式中两次调用<code class="fe lv lw lx ly b">constructor</code>会有助于更容易发现，因为将会建立两个连接。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="be2d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">关键要点</h1><ul class=""><li id="bfee" class="ng nh it lb b lc my lf mz li om lm on lq oo lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">React.StrictMode</code>可以为部分或整个应用程序启用。</li><li id="8f1d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">它只在开发模式下运行，为遗留ref用法、废弃的<code class="fe lv lw lx ly b">findDOMNode</code>方法、遗留上下文API、不安全的生命周期和意外的副作用提供警告。</li><li id="cfb7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">StrictMode</code>导致渲染阶段生命周期和函数的有意双重调用，以便更容易发现这些函数中实现的意外副作用。</li></ul></div></div>    
</body>
</html>