<html>
<head>
<title>The Power of Interpreter Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中解释器设计模式的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-interpreter-design-pattern-in-javascript-4ddd449c20e9?source=collection_archive---------4-----------------------#2022-06-28">https://betterprogramming.pub/the-power-of-interpreter-design-pattern-in-javascript-4ddd449c20e9?source=collection_archive---------4-----------------------#2022-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecf4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释是必要的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6216cee5c74e62116d7face8557904a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nz9TTcOznuSNlIIE.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7dff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将讨论JavaScript中的解释器设计模式。我们将实现一个解释器以及源代码的基本语法表示。我们将创建一个供客户端代码使用的接口(例如解析器)。</p><p id="ef2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设计模式分为三类:行为模式、创造模式和结构模式。解释者属于行为组。在所有的模式中，解释者似乎是最让人困惑的，但在我的经验中，从更高层次的角度(跳出框框)思考，将有助于让我们头脑中的那个灯泡突然亮起来。</p><h1 id="5092" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">我们什么时候需要应用解释器模式？</h1><p id="2363" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">有时我们可能会遇到这样的情况，我们需要一些接口来告诉解释器如何根据特定的上下文进行解释。这种模式也广泛用于SQL解析、符号处理引擎等。</p><p id="7a95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以认为这有点像创建一种脚本“语言”</p><p id="21ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，数组可以在其包含更多数组的索引中包含更多数组，等等。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c80f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目标是创建某种在大多数情况下能够递归的“语法”表示。</p><p id="398b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们看它的结构时，语法表示中的每个部分要么是一个复合体，要么是一棵树的一片叶子。从更高层次的角度来看，请注意这些语法表示是如何形成复合设计模式的结构的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/3f9af19e9fc1c5524fed1da55f717b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sTFTJX8IzurkQhmM.png"/></div></div></figure><p id="bdc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，有些子节点包含更多的子节点，深度根据需要增加。这就是递归至关重要的地方，它在遍历算法中变得必不可少。</p><p id="e6fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种模式的主要参与者是解释器本身。</p><h2 id="642a" class="mu lv it bd lw mv mw dn ma mx my dp me lh mz na mg ll nb nc mi lp nd ne mk nf bi translated">实现解释器和语法表示</h2><p id="29fa" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">让我们继续创建解释器。解释器将有一个<code class="fe ng nh ni nj b">interpret</code>方法，负责运行我们的代码并从中产生标记。这些标记将包含解释器创建组合表达式所需的规则，以便解析器等客户端代码能够理解:</p><p id="a1b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一下第一行(我们将把它初始化为一个空数组，以便于理解):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9487" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在代码中通读这一行，我们如何将名字<code class="fe ng nh ni nj b">items</code>转换成<code class="fe ng nh ni nj b">collection</code>？</p><p id="d43f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以一行一行地读，然后像这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="466e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这不是很有效，因为没有一种可靠的方法来查看前一个/后一个索引，以及能够判断哪一行或哪一列以特定的表达式、声明等开始。我们也没有办法做一些有用的事情，比如更新声明符的类型(<code class="fe ng nh ni nj b">var</code>、<code class="fe ng nh ni nj b">let</code>、<code class="fe ng nh ni nj b">const</code>)。</p><p id="516b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们利用解释器模式时，我们创建了一个实际的接口，该接口将接受代码，将表示语法部分的相关对象连接在一起，并指示解释器如何处理它们。请记住，这些对象中的每一个都有自己的规则来指导解释器，它们产生的输出可以被客户机代码理解，就像解析器一样。</p><p id="448f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，回到这一行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f971" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以创建一个接口。请记住，这个接口是这个模式中最强大的部分，因为我们可以定制每个类来做我们想做的任何事情，比如覆盖默认的<code class="fe ng nh ni nj b">toString</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b208" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完美！这是解释器设计模式在起作用！我们现在有了一些语法的表示法。</p><p id="f161" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种模式非常强大。有了这个接口，我们可以看到我们将每个类上所有默认的<code class="fe ng nh ni nj b">toString</code>方法都重写为<code class="fe ng nh ni nj b">structure for our domain</code>。</p><p id="ed47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们需要一个解释器来接收源代码并通读它们。我们的解释器将是在实际实践中使用的更加简化的版本。为了这篇文章的缘故，我只包括了完全代表我们的一行程序所必需的部分，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0c49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，客户端代码就可以利用我们的解释器并操作我们的代码行，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="1f96" class="mu lv it bd lw mv mw dn ma mx my dp me lh mz na mg ll nb nc mi lp nd ne mk nf bi translated">语境</h2><p id="bfe5" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">上下文对象通常用在连接解释器中。如果我们可以在所有的语法表示对象中覆盖<code class="fe ng nh ni nj b">toString</code>，我们肯定可以通过在一个名为<code class="fe ng nh ni nj b">context</code>的对象中输入有用的状态信息来提高解释器的能力。</p><p id="769f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可以让客户端代码在构造数组表达式输出时能够跳过<code class="fe ng nh ni nj b">undefined</code>值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2bc40d07fa432c382a55af64c9113602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1GvkAn8TMf1D5Hrp.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/6bba3c731c5100a5e872dad5a1ed9ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BsnMo6Awa2joxVoO.png"/></div></div></figure><h1 id="0cfb" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">其他模式的提示</h1><ul class=""><li id="d89c" class="nm nn it la b lb mm le mn lh no ll np lp nq lt nr ns nt nu bi translated">解释器模式在处理复合结构时是最强大的。换句话说，在处理复合结构时，必须将复合模式与解释器模式结合起来。</li><li id="a64d" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">在构建器模式中，构建器可以用来创建语言的语法表示形式的层次结构，并允许客户机在解释器模式中使用它们。</li><li id="dd94" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">抽象工厂可以用来创建复杂的对象(例如在javascript中，这可能是一个很长的函数返回语句，包含大量的二进制表达式)</li><li id="57b3" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">像复合模式一样，访问者和迭代器模式在解释器方面也很强大。访问者通常用递归遍历算法实现，该算法本身实现迭代器模式。解释器可以利用访问者来遍历复合树。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/e57a2f348bdca2f3a2d032847c36fb60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*txQITFeA1Btb4Day.png"/></div></div></figure><h1 id="2086" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="df3d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">感谢您的阅读，期待以后有更多来自我的优质帖子！</p></div></div>    
</body>
</html>