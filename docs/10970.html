<html>
<head>
<title>Communicate Between Flutter and Native iOS Code Using Platform Channel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用平台通道在Flutter和本机iOS代码之间进行通信</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/communicate-between-flutter-and-native-android-and-ios-code-using-platform-channel-7932f46b6aee?source=collection_archive---------4-----------------------#2022-02-08">https://betterprogramming.pub/communicate-between-flutter-and-native-android-and-ios-code-using-platform-channel-7932f46b6aee?source=collection_archive---------4-----------------------#2022-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e69b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在颤振中使用平台通道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/69d0fec28b73509e762e300b9fdaa617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_7VPqRdecjj0eKce.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@windows" rel="noopener ugc nofollow" target="_blank">车窗</a>上的<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">挡泥板</a>拍摄</p></figure><p id="2c52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编写flutter应用程序时，您发现有一个操作需要本机平台的帮助，您需要编写一个方法来使用本机API，在flutter和本机之间建立连接，并允许数据在我们使用的方法通道之间来回流动</p><p id="2018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">我在这篇文章中多次提到“本土”。我说的“原生”是指iOS和Android平台。</em></p><p id="8154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个用例是，当您向本机应用程序(flutter addToApp)添加一个Flutter模块时，在这种情况下，您希望调用一些本机方法来获取您的Flutter模块中的一些信息，您可以使用方法通道。</p><p id="6d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多Flutter插件内部使用平台通道。</p><p id="94ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个架构概述:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/6223c266cb4736b7e9e36ec1f8376923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*it3tRNmlLMecPMK5.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://docs.flutter.dev/development/platform-integration/platform-channels" rel="noopener ugc nofollow" target="_blank">扑官方文件</a></p></figure><p id="8162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们已经看到了一些用例，所以让我们用一些代码深入研究方法通道的细节。</p><p id="5a82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将如下初始化方法通道:</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="a3f9" class="lz ma iq lv b gy mb mc l md me">static const <em class="ls">platformChannel </em>= MethodChannel('test.flutter.methodchannel/iOS');</span></pre><p id="1fe3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以如果你把它粘贴到你的IDE中，你可能会得到一些错误。在调查的同时，你会发现它无法识别<code class="fe mf mg mh lv b">MethodChannel</code>，所以为了使用Platform，我们需要导入<code class="fe mf mg mh lv b">service</code>包。</p><p id="224b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在方法通道初始化器中使用了一个<em class="ls">字符串</em>，它是方法通道名，你可以传递任何你喜欢的字符串，但是为了标准化，建议使用反向<a class="ae kv" href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation" rel="noopener ugc nofollow" target="_blank">反向域名表示法</a>。</p><p id="7c0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了必需的<em class="ls"> name </em>参数之外，初始化器还接受两个参数:</p><ul class=""><li id="d441" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated"><code class="fe mf mg mh lv b">codec</code> — <br/>如果该区域没有提供值，则使用<code class="fe mf mg mh lv b">StandardMethodCodec</code>。</li></ul><blockquote class="mr ms mt"><p id="4a53" class="kw kx ls ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">“标准平台通道使用标准消息编解码器，该编解码器支持简单JSON类值的有效二进制序列化，如布尔值、数字、字符串、字节缓冲区以及列表和映射。这些值的序列化和反序列化也会在您发送和接收值时自动发生。—正式文件</p></blockquote><ul class=""><li id="a44e" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated"><code class="fe mf mg mh lv b">binaryMessenger(Optional)</code> — <br/> <code class="fe mf mg mh lv b">BinaryMessenger</code>帮助将二进制数据发送到本地平台，<br/>如果我们不传递它使用的任何东西<code class="fe mf mg mh lv b">defaultBinaryMessenger</code>，如果你对此感到好奇，它被定义在<code class="fe mf mg mh lv b">binding.dart</code>文件中。</li></ul><p id="2191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，<code class="fe mf mg mh lv b">binaryMessenger</code>用于在本地平台之间传递二进制数据，而<code class="fe mf mg mh lv b">codec</code>用于这些值的序列化和反序列化。</p><p id="b4e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将编写一个方法来获取iOS设备模型，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3c6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们浏览一下代码；这很简单。</p><ol class=""><li id="1532" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mz mo mp mq bi translated">我们在平台频道上调用<code class="fe mf mg mh lv b">invokeMethod</code>。<br/>这个方法接受方法名和一个参数列表，在上面的例子中我们省略了参数列表。<br/>注意方法名，因为我们必须在本机平台中使用它。</li><li id="87c4" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">平台可能会抛出一些异常，所以为了安全起见，我们将退回到catch块。<br/> <strong class="ky ir">注意</strong>:在某些特定于平台的异常情况下，抛出PlatformException。</li><li id="572e" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">我们做<code class="fe mf mg mh lv b">setState</code>，它将重新构建UI来显示设备模型。</li></ol><p id="a918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经完成了颤振方面的工作，将研究iOS方面的实现。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="1329" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在flutter工作区中有一个iOS和Android文件夹，默认情况下它与lib文件夹在同一级别，我们将使用这些来编写平台特定的代码。</p><p id="6a37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Xcode中打开iOS模块，并按照以下步骤操作:</p><ul class=""><li id="9d57" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">在finder中找到您的项目。</li><li id="bc72" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mn mo mp mq bi translated">转到ios文件夹，如果你的项目名是<code class="fe mf mg mh lv b">simple_platform_channel</code>，那么<code class="fe mf mg mh lv b">simple_platform_channel &gt; ios</code>。</li><li id="0a96" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mn mo mp mq bi translated">在iOS文件夹中打开<code class="fe mf mg mh lv b">runner.xcworkspace</code></li></ul><p id="199c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">非iOS开发人员注意</strong> : <code class="fe mf mg mh lv b">Runner.xcodeproj</code>是项目文件，但是作为一个Flutter项目模板，默认情况下使用Cocopods作为依赖项管理器，它创建一个嵌入依赖项的工作空间文件。</p><p id="5779" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们编写本机方法，但是我们要编写它吗？<br/>这里是路径:</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="e267" class="lz ma iq lv b gy mb mc l md me">Runner &gt; Runner &gt; AppDelegate</span></pre><p id="ae64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会看到一些代码已经存在。在做任何修改之前，我们会了解它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="220f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个用<code class="fe mf mg mh lv b">@UIApplicationMain,</code> <strong class="ky ir"> </strong>标注的<code class="fe mf mg mh lv b">AppDelegate</code>类，所以基本上从这个程序执行开始，就相当于在Flutter中void <code class="fe mf mg mh lv b">main()</code>。</p><p id="e137" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们看到类中有一个带参数<code class="fe mf mg mh lv b">didFinishLaunchingWithOptions</code>的方法<code class="fe mf mg mh lv b">application</code>，因为它的名字表明这个方法在应用程序启动时就被执行。我们将对此方法进行修改。</p><blockquote class="mr ms mt"><p id="2dcb" class="kw kx ls ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">注意:AppDelegate使用方法重载，所以有很多名为<code class="fe mf mg mh lv b">application</code>的方法，但是每个方法都有不同的参数列表。</p></blockquote><p id="b43c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在将使用我们在颤振中定义的平台通道。</p><p id="2675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是代码。看起来吓人也不用担心；我们将一步一步来看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="bb3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来理解上面的片段:</p><ol class=""><li id="6229" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mz mo mp mq bi translated">我们正在尝试获取<code class="fe mf mg mh lv b">FlutterViewController</code>，如果你想知道窗口是从哪里进入场景的，它基本上是在<code class="fe mf mg mh lv b">FlutterAppDelegate</code>中定义的，由<code class="fe mf mg mh lv b">AppDelegate</code>扩展，<code class="fe mf mg mh lv b">FlutterViewController</code>被设置为<code class="fe mf mg mh lv b">rootViewController</code>，所以我们正在尝试访问它。</li><li id="d2f9" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">为什么我们又要创建一个方法通道？<br/>当我们试图在两个框架之间进行交互时，应该在双方都建立连接。<br/> <strong class="ky ir">注意</strong> : <br/> -为了建立连接，我们需要拥有与我们在Flutter中定义的相同的通道名。<br/> - <code class="fe mf mg mh lv b">binaryMessenger</code>。我们使用的是<code class="fe mf mg mh lv b">FlutterViewController</code>提供的默认二进制信使。这就是我们拔出<code class="fe mf mg mh lv b">FlutterViewController</code>的原因。</li><li id="e8aa" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">这里，我们正在准备方法处理程序。它将处理在方法通道上调用的任何方法调用。</li><li id="f0d2" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">我们附加了一个方法回调处理程序，并传递了一个闭包(如果你想知道那是什么，它只是一个匿名函数。如果你在flutter中用过<code class="fe mf mg mh lv b">List.forEach</code>，那么你已经知道了)。<br/>匿名函数有两个参数:<br/>-call(FlutterMethodCall)——它提供方法调用的细节，比如方法名及其参数。<br/>-result(flutteresult)—这是您将返回给flutter模块的结果，它被表示为@escaping，这意味着它是一个异步调用，因此您可以执行一些耗时的操作，然后调用结果。</li><li id="cfad" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">只是检查被调用的方法名是否是<code class="fe mf mg mh lv b">getDeviceModel</code>。这里检查没有太大意义，但是当有多个方法的时候你需要检查来区分它们。</li><li id="af9e" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">调用另一个方法来获取设备模型。</li><li id="848c" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">我们已经使用iOS <code class="fe mf mg mh lv b">device</code> API得到了结果。</li><li id="1306" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">用数据调用<code class="fe mf mg mh lv b">result</code>，这有助于将数据传回颤振模块。</li><li id="f064" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">如果我们从Flutter端调用一些本地没有实现的方法，我们抛出<code class="fe mf mg mh lv b">FlutterMethodNotImplemented</code>。</li></ol><p id="46ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单不是吗！</p><p id="9349" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们来看看围绕平台渠道的一些重要问题。</p><p id="98ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何将一些数据从Flutter传递到iOS，同时调用一个方法？</p><p id="e239" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住，我们讨论了接受动态参数数组的invokeMethod。让我们看一个例子:</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="c87a" class="lz ma iq lv b gy mb mc l md me"><em class="ls">platformChannel</em>.invokeMethod('getDeviceModel',<br/>    {"flutterAppVersion": "0.0.1", "developerName": "XYZ"});</span></pre><p id="2f88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何将数据传回颤振模块？</p><p id="0dd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在结果中传递任何数据。例如:</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="69af" class="lz ma iq lv b gy mb mc l md me">result( ------ )</span></pre><p id="b927" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为了简单一点，Flutter提供了<code class="fe mf mg mh lv b">invokeMethod</code>的其他选择:</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="8ed4" class="lz ma iq lv b gy mb mc l md me">1. Future&lt;T?&gt; invokeMethod&lt;T&gt;(String method, [ dynamic arguments ])<br/>2. Future&lt;Map&lt;K, V&gt;?&gt; invokeMapMethod&lt;K, V&gt;(String method, [ dynamic arguments ])<br/>3. Future&lt;List&lt;T&gt;?&gt; invokeListMethod&lt;T&gt;(String method, [ dynamic arguments ])</span></pre><p id="9c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管传递给这个方法的参数是相同的，但是返回类型是不同的，所以如果我们想要在结果中返回一个映射，我们可以使用<code class="fe mf mg mh lv b">invokeMapMethod</code>。</p><h1 id="bca1" class="nm ma iq bd nn no np nq nr ns nt nu nv jw nw jx nx jz ny ka nz kc oa kd ob oc bi translated">摘要</h1><p id="efcd" class="pw-post-body-paragraph kw kx iq ky b kz od jr lb lc oe ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">通过五个简单的步骤，您可以在Flutter中运行特定于平台的代码:</p><ol class=""><li id="7691" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mz mo mp mq bi translated">在Flutter中创建一个方法通道。</li><li id="4274" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">调用通道上的方法并等待结果。</li><li id="841e" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">在iOS中创建一个FlutterMethodChannel，在application方法中使用didFinishLaunchingWithOptions。</li><li id="124e" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">在通道上设置回调处理程序。</li><li id="c416" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mz mo mp mq bi translated">使用本地API执行一些操作并返回结果。</li></ol><h1 id="0e78" class="nm ma iq bd nn no np nq nr ns nt nu nv jw nw jx nx jz ny ka nz kc oa kd ob oc bi translated">资源</h1><p id="b20a" class="pw-post-body-paragraph kw kx iq ky b kz od jr lb lc oe ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">平台渠道上的一些有用资源:</p><ul class=""><li id="548d" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated"><a class="ae kv" href="https://docs.flutter.dev/development/platform-integration/platform-channels?tab=type-mappings-swift-tab#codec" rel="noopener ugc nofollow" target="_blank">不同平台支持的数据</a></li><li id="2791" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mn mo mp mq bi translated"><a class="ae kv" href="https://docs.flutter.dev/development/platform-integration/platform-channels" rel="noopener ugc nofollow" target="_blank">平台渠道:官方文件</a></li><li id="f0b7" class="mi mj iq ky b kz na lc nb lf nc lj nd ln ne lr mn mo mp mq bi translated"><a class="ae kv" href="https://docs.flutter.dev/development/platform-integration/platform-channels?tab=type-mappings-swift-tab#step-3-add-an-android-platform-specific-implementation" rel="noopener ugc nofollow" target="_blank"> Android平台实现</a></li></ul></div></div>    
</body>
</html>