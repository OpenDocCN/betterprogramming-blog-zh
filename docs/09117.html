<html>
<head>
<title>4 Useful Advanced Features in Locust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蝗虫的4个有用的高级功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-useful-advanced-features-in-locust-ea3b63df415e?source=collection_archive---------2-----------------------#2021-07-16">https://betterprogramming.pub/4-useful-advanced-features-in-locust-ea3b63df415e?source=collection_archive---------2-----------------------#2021-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="170a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">加强您的负载测试游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/744f48b5c18b37f7889753e935d990a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_STL39K84-YT2DxpqzAJg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@centelm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Clément Falize </a>在<a class="ae ky" href="https://unsplash.com/s/photos/swarm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前，我已经在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-locust-an-open-source-load-testing-tool-in-python-2b2e89ea1ff">Locust简介:Python中的一个开源负载测试工具</a>中介绍过<a class="ae ky" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank"> Locust </a>的初学者指南。在本文中，让我们更深入地了解Locust中的四个有用的高级特性:</p><ul class=""><li id="de18" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">顺序执行任务</li><li id="17a2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">生成自定义负载形状(基于时间的阶段)</li><li id="8966" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用其他自定义客户端</li><li id="38a1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">并行运行任务</li></ul><p id="7cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，上面提到的所有特性都不是新的，在Locust包中已经存在很长时间了。了解这些特性有助于改进您的负载测试，并使您的生活更加轻松。</p><p id="8827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续下一节，开始安装必要的Python包。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a9d6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设置</h1><p id="5ad6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Locust的安装步骤现在简单多了，但它需要Python及以上版本。强烈建议您在继续安装过程之前创建一个新的虚拟环境。</p><h2 id="5cab" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">蝗虫</h2><p id="ff68" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">激活虚拟环境并运行以下命令来安装Locust:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="acfc" class="nn mr it oa b gy oe of l og oh">pip install locust</span></pre><p id="93a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用以下命令(大写V)验证您的安装:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="a2ac" class="nn mr it oa b gy oe of l og oh">locust -V</span></pre><p id="3251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到版本号，如下所示:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="7f0a" class="nn mr it oa b gy oe of l og oh">locust 1.6.0</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="126c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">顺序执行任务</h1><p id="37f6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">默认情况下，每个生成的用户将:</p><ol class=""><li id="88b5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oi mb mc md bi translated">随机选择一个任务</li><li id="875a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oi mb mc md bi translated">执行它</li><li id="7602" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oi mb mc md bi translated">基于<code class="fe oj ok ol oa b">wait_time</code>睡一会儿</li><li id="5de3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oi mb mc md bi translated">冲洗并重复</li></ol><p id="1608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在测试一个有序的或者层次化的网站或者应用程序，你将不得不依靠循环和控制语句来完成。</p><p id="9e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，你可以利用<code class="fe oj ok ol oa b">SequentialTaskSet</code>来帮你。你需要做的就是导入<code class="fe oj ok ol oa b">SequentialTaskSet</code>并在你的<code class="fe oj ok ol oa b">User</code>类中创建一个继承它的类。看看下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="bc6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将按顺序运行所有任务，从<code class="fe oj ok ol oa b">first_task</code>开始，然后是<code class="fe oj ok ol oa b">second task</code>。</p><p id="2be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，您可以通过任务装饰器指定weightage来多次执行任务。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="88f4" class="nn mr it oa b gy oe of l og oh"># execute once<br/>@task</span><span id="971f" class="nn mr it oa b gy oo of l og oh"># execute 5 times<br/>@task(5)</span></pre><p id="fbfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您的代码中有以下结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="81f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将依次执行以下命令:</p><ul class=""><li id="28b5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe oj ok ol oa b">first_task</code>曾经</li><li id="a045" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oj ok ol oa b">second_task</code>五次</li><li id="5745" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oj ok ol oa b">third_task</code>曾经</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="40c2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">生成自定义负载形状</h1><p id="322f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">有时候，您可能希望在某个时间增加或减少用户数量，以模拟不同类型的测试，比如峰值测试。在这种情况下，您不能仅仅通过更改用户数和种子率来实现这一点。幸运的是，Locust提供了一个<code class="fe oj ok ol oa b">LoadTestShape</code>类，可以根据您的需要来控制用户数量和产卵率。</p><p id="a03c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您所需要做的就是创建一个继承<code class="fe oj ok ol oa b">LoadTestShape</code>的新类，并定义一个名为<code class="fe oj ok ol oa b">tick</code>的函数，该函数返回一个包含以下项目的元组:</p><ul class=""><li id="8d02" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用户计数</li><li id="f963" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">产卵率</li></ul><p id="a80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以返回<code class="fe oj ok ol oa b">None</code>停止测试。看看下面的示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="b209" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">基于时间的阶段</h2><p id="0d59" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">除了Locust，我过去还介绍过另一个叫做<a class="ae ky" href="https://k6.io/docs/" rel="noopener ugc nofollow" target="_blank"> k6 </a>的负载测试工具。</p><ul class=""><li id="4a9c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/an-introduction-to-k6-an-api-load-testing-tool-132a0d87827d">K6介绍:一个API负载测试工具</a></li><li id="ee31" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/load-testing-websockets-with-k6-feb99bf75798">用k6 </a>负载测试WebSockets</li></ul><p id="ea05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进行测试时，它提供了基于时间的阶段，允许您执行不同类型的测试:</p><ul class=""><li id="b70c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">烟气试验</li><li id="5cd1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">负荷试验</li><li id="7274" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">尖峰测试</li><li id="5248" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">负荷试验</li><li id="9897" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">浸泡试验</li></ul><p id="8344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以模拟相同的基于时间的阶段功能，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="716a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这里的持续时间代表一个时间戳(进入下一阶段已经过去了多少秒)，而不是持续时间长度。在这种情况下，它将:</p><ul class=""><li id="0fbf" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">从0个用户开始，产卵率为10，直到第5秒</li><li id="e9ab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">继续以10个用户的速度繁殖，直到15秒达到50个用户</li><li id="4e5b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">继续以10个用户的速度繁殖，直到25秒达到100个用户</li><li id="f43b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">结束阶段并下降到0用户</li></ul><p id="b9a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行以下命令来测试上面的脚本:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="81c5" class="nn mr it oa b gy oe of l og oh">locust -f &lt;file_name&gt;.py</span></pre><p id="f6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">web用户界面可在以下位置访问:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="1840" class="nn mr it oa b gy oe of l og oh">http://localhost:8089</span></pre><p id="67fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于具有自定义加载形状的脚本，禁用总用户数和填充率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9a73f3f6e87329fb61aa96d4d71a4a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*h0XJRPwfEX1-C4v7CpMoQg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击“开始群集”按钮后，您应该会得到以下输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/ed97b743ce7117ea952d08f0c7dc7f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZVuayoVoU3ukkXS3jtanQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与持续运行的普通负载测试不同，一旦脚本完成所有阶段，它将自行停止。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/2e9ee71cd0338ef10ff0b5fd01006e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDo8W-jJWKECj9ketDZ8fw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二张图中的请求总数应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/becedaac971ee887d1d06f6c18b50a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZN77IgBTWDAOciqQcRkzg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下用户数量图，它表明用户在特定的时间间隔内如预期的那样增加了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/769d6f510be7ed9634ed7ffa42302af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ov6o5uFoUdUqSh_d-F2WIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="40a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在官方的GitHub库找到更多的例子。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8292" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用其他自定义客户端</h1><p id="0e67" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Locust中的一个核心客户端是<code class="fe oj ok ol oa b">HTTPUser</code>类，这意味着通过HTTP进行负载测试API。它基于请求模块。事实上，您可以扩展它来测试其他系统。话虽如此，你必须使用<a class="ae ky" href="http://www.gevent.org/" rel="noopener ugc nofollow" target="_blank"> gevent </a>友好的库，否则它会阻塞正在运行的蝗虫进程。</p><p id="0ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，Locust不支持标准的Python异步。因此，您必须对其进行修补，以使用gevent，而不是asyncio等基于异步的模块。看看官方文档提供的以下gRPC客户端示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="42cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要基于HTTPX包创建一个新的<code class="fe oj ok ol oa b">User</code>类来加载测试HTTP/2 API。你需要做的就是创建相应的<a class="ae ky" href="https://github.com/locustio/locust/blob/55525a50240704fcb48bc24fb8e7ba417995af09/locust/clients.py" rel="noopener ugc nofollow" target="_blank"> HttpxClient </a>和<a class="ae ky" href="https://github.com/locustio/locust/blob/55525a50240704fcb48bc24fb8e7ba417995af09/locust/user/users.py" rel="noopener ugc nofollow" target="_blank"> HttpUser </a>用<code class="fe oj ok ol oa b">httpx</code>替换<code class="fe oj ok ol oa b">requests</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8ce3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">并行运行任务</h1><p id="d05f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在Locust中并行运行任务不是那么简单，因为它不支持标准的异步。如果您正在寻找并行运行任务的解决方案，您可以利用gevent的<code class="fe oj ok ol oa b">Pool</code>或<code class="fe oj ok ol oa b">Group</code>为您创建<code class="fe oj ok ol oa b">greenlet</code>。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="32e4" class="nn mr it oa b gy oe of l og oh">from gevent.pool import Group</span><span id="0707" class="nn mr it oa b gy oo of l og oh">group = Group()<br/>group.spawn(lambda: print("1"))<br/>group.spawn(lambda: print("2"))<br/>group.join()</span></pre><p id="e523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://www.gevent.org/api/gevent.html#creating-greenlets" rel="noopener ugc nofollow" target="_blank"> gevent的spawn函数</a>接受:</p><ul class=""><li id="abfc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一个可调用的函数(你也可以使用lambda表达式。)</li><li id="142d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个参数名</li><li id="8786" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">夸尔斯</li></ul><p id="e738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段说明了如何并行执行两个调用来测试HTTP API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c87c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="f889" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们回顾一下你今天所学的内容。</p><p id="023b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文首先介绍了蝗虫包中的四个高级特性。</p><p id="ad97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它继续通过<code class="fe oj ok ol oa b">pip install</code>安装所有需要的Python包。</p><p id="92f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，它进入了实施过程。它展示了一些按顺序执行任务的代码片段示例。除此之外，它还详细解释了如何生成定制的负载形状，比如基于时间的阶段测试。</p><p id="0704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，本文还讨论了如何为gRPC实现您自己的定制客户端。最后，它提供了一个通过gevent运行任务的简单解决方案。</p><p id="8e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读这篇文章！请查看我的其他文章，了解更多与负载测试相关的教程。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d95c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">参考</h1><ol class=""><li id="816e" class="lv lw it lb b lc ni lf nj li ou lm ov lq ow lu oi mb mc md bi translated"><a class="ae ky" href="https://docs.locust.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Locust.io —文档</a></li><li id="aca3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oi mb mc md bi translated"><a class="ae ky" href="https://docs.locust.io/en/stable/tasksets.html#sequentialtaskset-class" rel="noopener ugc nofollow" target="_blank">locust . io—sequential taskset</a></li><li id="8393" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oi mb mc md bi translated"><a class="ae ky" href="https://www.python-httpx.org/" rel="noopener ugc nofollow" target="_blank"> Httpx —文档</a></li><li id="9e1e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oi mb mc md bi translated"><a class="ae ky" href="https://github.com/locustio/locust/issues/264" rel="noopener ugc nofollow" target="_blank"> GitHub —针对HTTP/2服务器的蝗虫支持测试</a></li><li id="2f4d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oi mb mc md bi translated"><a class="ae ky" href="https://github.com/locustio/locust/blob/master/examples/custom_shape/stages.py" rel="noopener ugc nofollow" target="_blank"> GitHub —蝗虫阶段示例</a></li><li id="f48d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oi mb mc md bi translated"><a class="ae ky" href="https://github.com/locustio/locust/issues/198" rel="noopener ugc nofollow" target="_blank"> GitHub —蝗虫并行任务</a></li></ol></div></div>    
</body>
</html>