<html>
<head>
<title>JavaScript Omni-Packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript全包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2020-021-javascript-omni-packages-bae42d446d6c?source=collection_archive---------9-----------------------#2020-08-28">https://betterprogramming.pub/2020-021-javascript-omni-packages-bae42d446d6c?source=collection_archive---------9-----------------------#2020-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="37b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何打包JavaScript库以实现从遗留模块到标准模块的平稳过渡</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f39b896f64210225b96d95336f834326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nm-2nPwCQ6TOkQ7habgZdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="919d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript已经为包装革命做好了准备。现在，所有主流浏览器和服务器端Node.js软件都支持新的ESNext模块。这是好消息。</p><p id="cf24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是CommonJS模块的遗产将伴随我们很长一段时间。每个想要利用标准<code class="fe lu lv lw lx b">import/export</code>语法的新JavaScript项目都需要考虑新的模块加载器是否能满足它们所有的依赖关系。与此同时，每个包开发者都需要考虑他们是要支持遗留消费者(CommonJS)还是基于标准的消费者(ESNext)或者两者都支持。</p><p id="f866" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是一个小问题，而且不会很快消失。Python开发人员经历了类似的转变，历时12年才完成。Python3于2008年发布，但不兼容的Python2系统直到2020年4月才最终冻结。</p><p id="343e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最好的策略是设计和发布全包，允许开发者和消费者逐渐从旧的过渡到新的。让我们看看如何做到这一点。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="48c0" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">模块化装载基础</h1><p id="ef57" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">大多数JavaScript开发人员已经掌握了导入/导出的语法，所以我们不需要再重复一遍。但是并不是每个人对JavaScript如何查找和加载模块都有相同的熟悉程度。所以让我们从建立一些共同点开始。</p><p id="45e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装载机的工作主要有四个方面:</p><ol class=""><li id="a24c" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated">确定模块依赖关系</li><li id="631e" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">确定在哪里可以找到模块</li><li id="d324" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">维护已下载模块的列表</li><li id="a650" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">捕捉循环依赖关系</li></ol><p id="9612" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些都不是微不足道的任务，谢天谢地，我们都可以依靠已经为我们完成的工作。</p><p id="86bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在ESNext中，模块加载器是语言规范本身的一部分，所以为了使用<code class="fe lu lv lw lx b">import/export</code>语法，不需要额外的解析和执行。</p><p id="9e8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于CommonJS，模块加载器只是JavaScript的另一部分。因此，为了在代码中的任何地方使用<code class="fe lu lv lw lx b">require/exports</code>语法，我们的脚本必须首先指示JavaScript解释器解析并加载处理该语法的函数。在前端，这是构建工具和捆绑器的工作，如<a class="ae nq" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank"> Browserify </a>、<a class="ae nq" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>和<a class="ae nq" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>。在后端，这由Node.js系统无缝处理，我们不需要做任何额外的工作。</p><p id="259d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在实践中，通常使用较新的ESNext语法来定位较旧的CommonJS加载器。为了实现这一点，我们使用了一个类似<a class="ae nq" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>的编译器，它将<code class="fe lu lv lw lx b">import</code>语句重写为<code class="fe lu lv lw lx b">require</code>语句，将<code class="fe lu lv lw lx b">export</code>语句重写为<code class="fe lu lv lw lx b">module.exports</code>语句。</p><p id="41cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CommonJS加载器同时执行它们的工作。这意味着在开始执行时，一切都被解析并准备好立即使用。另一方面，新的ESNext加载器异步地按需执行工作。这意味着只有在需要的时候，模块才会通过网络传输。当使用适当的HTTP缓存时，这种优化会得到进一步增强。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="5c02" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">四种执行途径</h1><p id="dc25" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我们的代码可以遵循四条路径:两条用于前端和后端，两条用于ESNext和CommonJS。</p><h2 id="70ee" class="nr mg it bd mh ns nt dn ml nu nv dp mp lh nw nx mr ll ny nz mt lp oa ob mv oc bi translated">1.使用CommonJS的前端</h2><p id="b864" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">为此，我们使用捆绑器将模块加载器和我们自己的代码打包成一个文件。此外，如果我们已经使用新的语法编写了代码，我们需要指示我们的bundler也调用transpiler。为了在浏览器中使用它，我们在HTML中添加了一个<code class="fe lu lv lw lx b">&lt;script&gt;</code>标签，如下所示:</p><pre class="kj kk kl km gt od lx oe of aw og bi"><span id="2a3b" class="nr mg it lx b gy oh oi l oj ok">&lt;script src=index.js type=text/javascript <strong class="lx iu">nomodule</strong>&gt;&lt;/script&gt;</span></pre><p id="19ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于加载了<code class="fe lu lv lw lx b">nomodule</code>属性的浏览器脚本，代码应该用<code class="fe lu lv lw lx b">require</code>语句编写。如果我们用<code class="fe lu lv lw lx b">import</code>语句编写它们，它们在被发送到浏览器之前必须由构建器或捆绑器进行编译。</p><h2 id="883f" class="nr mg it bd mh ns nt dn ml nu nv dp mp lh nw nx mr ll ny nz mt lp oa ob mv oc bi translated">2.使用ESNext的前端</h2><p id="73af" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">为此，我们简单地标识我们的源代码文件并添加一个带有<code class="fe lu lv lw lx b">type=module</code>的<code class="fe lu lv lw lx b">&lt;script&gt;</code>标签。</p><pre class="kj kk kl km gt od lx oe of aw og bi"><span id="bfb7" class="nr mg it lx b gy oh oi l oj ok">&lt;script src=index.js <strong class="lx iu">type=module</strong>&gt;&lt;/script&gt;</span></pre><p id="6fb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用<code class="fe lu lv lw lx b">type=module</code>加载的浏览器脚本可以安全地依赖JavaScript的原生加载器，并且毫不费力地使用标准的<code class="fe lu lv lw lx b">import</code>语句。这是我们都应该为之奋斗的目标。</p><h2 id="b7f9" class="nr mg it bd mh ns nt dn ml nu nv dp mp lh nw nx mr ll ny nz mt lp oa ob mv oc bi translated">3.使用CommonJS的后端</h2><p id="9d9d" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">为此，我们创建一个具有值为<code class="fe lu lv lw lx b">"commonjs"</code>的<code class="fe lu lv lw lx b">"type"</code>属性的<code class="fe lu lv lw lx b">package.json</code>文件，Node.js将为所有<code class="fe lu lv lw lx b">require</code>语句使用其内置的CommonJS加载器。</p><pre class="kj kk kl km gt od lx oe of aw og bi"><span id="fb38" class="nr mg it lx b gy oh oi l oj ok">// package.json<br/>{<br/>  "type": "commonjs"<br/>}</span></pre><p id="513c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Node.js定位并读取最近的<code class="fe lu lv lw lx b">package.json</code>文件，以便发现如何加载子模块。虽然我们通常认为<code class="fe lu lv lw lx b">package.json</code>是一个指定发布规则的文件，但现在它作为<code class="fe lu lv lw lx b">"type": "commonjs"</code>或<code class="fe lu lv lw lx b">"type": "module"</code>的运行时说明符发挥了双重作用。</p><h2 id="24cc" class="nr mg it bd mh ns nt dn ml nu nv dp mp lh nw nx mr ll ny nz mt lp oa ob mv oc bi translated">4.使用ESNext的后端</h2><p id="fb4d" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">为此，我们创建一个具有值为<code class="fe lu lv lw lx b">"module"</code>的<code class="fe lu lv lw lx b">"type"</code>属性的<code class="fe lu lv lw lx b">package.json</code>文件，Node.js将依赖JavaScript的本地加载器来处理所有的<code class="fe lu lv lw lx b">import</code>语句。</p><pre class="kj kk kl km gt od lx oe of aw og bi"><span id="bbe6" class="nr mg it lx b gy oh oi l oj ok">// package.json<br/>{<br/>  "type": "module"<br/>}</span></pre><p id="824d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于任何尝试使用Deno的人来说，这是一个好消息:他们可以免费使用Deno，因为Deno原生支持es next——不需要任何特殊的<code class="fe lu lv lw lx b">package.json</code>文件。</p><p id="11f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那些一直关注这个主题的人会记得早期的讨论，其中介绍了对CommonJS文件使用文件扩展名<code class="fe lu lv lw lx b">.cjs</code>和对ESNext文件使用文件扩展名<code class="fe lu lv lw lx b">.mjs</code>的想法。这只是Node.js曾经支持过的，从未被浏览器厂商正式采用过。今天的最佳实践是坚持使用<code class="fe lu lv lw lx b">.js</code>扩展。如果我们想创造一个只有一个真实来源的全方位包，这是很重要的。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="e2c3" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">全方位包装</h1><p id="bd36" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">让我们为全包定义我们的目标。它们应满足以下要求:</p><ul class=""><li id="ca84" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt ol ni nj nk bi translated">包应该可以在所有四个可执行路径中使用。</li><li id="647c" class="nc nd it la b lb nl le nm lh nn ll no lp np lt ol ni nj nk bi translated">应该有一组文件作为“事实的来源”</li><li id="58e2" class="nc nd it la b lb nl le nm lh nn ll no lp np lt ol ni nj nk bi translated">程序包文件应该用未混淆的、完全注释的源代码进行调试和测试。</li><li id="cee1" class="nc nd it la b lb nl le nm lh nn ll no lp np lt ol ni nj nk bi translated">软件包文件应该由用户使用最少的代码来分发和安装。</li><li id="4cdb" class="nc nd it la b lb nl le nm lh nn ll no lp np lt ol ni nj nk bi translated">包应该在一个公共名称下发布和版本化。</li></ul><p id="0e18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过一个类似于经典的"<code class="fe lu lv lw lx b">src</code>、<code class="fe lu lv lw lx b">dbg</code>、<code class="fe lu lv lw lx b">dist</code>"模式的修改过的组织树来完成这些目标，许多项目已经在使用这种模式。但是omni-package布局中没有三个顶级目录，而是有四个:<code class="fe lu lv lw lx b">esmodule</code>、<code class="fe lu lv lw lx b">esm</code>、<code class="fe lu lv lw lx b">commonjs</code>和<code class="fe lu lv lw lx b">cjs</code>。每个文件都有一套完整的原始文件，使用相同的子目录布局和相同的文件名。</p><p id="7614" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">esmodule</code>目录是真实的原始来源。开发人员只能在这个树中进行更改。使用任一ESNext执行路径调试和测试包的工作都是直接使用该树中的文件完成的。它保存在回购中，但通常不会分发给包装消费者。</p><p id="392d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">esm</code>目录是<code class="fe lu lv lw lx b">esmodule</code>的缩小版。它随软件包一起分发，可以在浏览器中使用，HTML语句如下:</p><pre class="kj kk kl km gt od lx oe of aw og bi"><span id="1284" class="nr mg it lx b gy oh oi l oj ok">&lt;script src=/node_modules/my-package/<strong class="lx iu">esm</strong>/index.js <strong class="lx iu">type=module</strong>&gt;&lt;/script&gt;</span></pre><p id="1989" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者可以在Node.js项目中使用如下的导入语句:</p><pre class="kj kk kl km gt od lx oe of aw og bi"><span id="a45a" class="nr mg it lx b gy oh oi l oj ok">import MyPackage from 'my-package/<strong class="lx iu">esm</strong>/index.js'</span></pre><p id="1f8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">commonjs</code>目录是<code class="fe lu lv lw lx b">esmodule</code>的通天塔编译版本。使用任何一个CommonJS执行路径调试和测试包的工作都是使用这个树中的transpiled文件来完成的。它通常不会分发给包装消费者。</p><p id="75c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">cjs</code>目录是<code class="fe lu lv lw lx b">commonjs</code>的缩小版。它随软件包一起分发，可以在浏览器中使用，HTML语句如下:</p><pre class="kj kk kl km gt od lx oe of aw og bi"><span id="4759" class="nr mg it lx b gy oh oi l oj ok">&lt;script src=/node_modules/my-package/<strong class="lx iu">cjs</strong>/index.js <strong class="lx iu">nomodule</strong>&gt;&lt;/script&gt;</span></pre><p id="2abb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者可以在Node.js项目中使用如下的导入语句:</p><pre class="kj kk kl km gt od lx oe of aw og bi"><span id="8bbd" class="nr mg it lx b gy oh oi l oj ok">import MyPackage from 'my-package/<strong class="lx iu">cjs</strong>/index.js'</span></pre><p id="55dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">提醒一下，为了让Node.js正确地从<code class="fe lu lv lw lx b">esm</code>和<code class="fe lu lv lw lx b">cjs</code>加载文件，如上所述，这两个顶级目录必须有一个带有<code class="fe lu lv lw lx b">"type": "module"</code>或<code class="fe lu lv lw lx b">"type": "commonjs"</code>的<code class="fe lu lv lw lx b">package.json</code>文件。(在前端，浏览器会完全忽略这些<code class="fe lu lv lw lx b">package.json</code>文件。)</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="a251" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">出版和发行</h1><p id="c24b" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">出于发布和分发的目的，四个顶级目录被放在一个外部项目目录中，连同通常的许可证和自述文件，加上一个项目级的<code class="fe lu lv lw lx b">package.json</code>文件，如下所示(没有<code class="fe lu lv lw lx b">"type"</code>属性):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="fd6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Omni-packages是JavaScript过渡期的最佳方式。它们允许包开发者和包消费者以他们自己的速度从遗留模块迁移到新的ECMAScript标准模块，而没有混乱的“停止世界”中断。</p></div></div>    
</body>
</html>