<html>
<head>
<title>Deploy and Configure Kustomize and MongoDB for Kubernetes Stateful Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Kubernetes有状态应用程序部署和配置Kustomize和MongoDB</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-ci-cd-pipeline-for-kubernetes-stateful-applications-2d6676713397?source=collection_archive---------13-----------------------#2022-02-03">https://betterprogramming.pub/how-to-build-a-ci-cd-pipeline-for-kubernetes-stateful-applications-2d6676713397?source=collection_archive---------13-----------------------#2022-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b00c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第2部分:让我们在CI/CD管道中安装MongoDB操作符和Ondat</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cfc5d758970aecf4ee8817d2ce4a1ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lj1pwCc4CryEXNdF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@vladhilitanu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vlad Hilitanu </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="363e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是系列文章的第二篇。第一个是可用的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-ci-cd-pipeline-for-kubernetes-stateful-applications-aef6c8c5edc2?sk=9e7aa51f55483fd0e8cbf8e38db94430">这里是</a>，在这里我们展示了一些工具，允许我们创建一个Kubernetes友好的自动化环境，用于开发基于Flask、MongoDB、Pymongo和漫威API的web应用程序。在第二部分中，我们部署和配置Kustomize、MongoDB和Ondat。</p><h1 id="2de8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装和配置Kustomize</h1><p id="3685" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如在上一篇文章中提到的，有2种方法可以使用Kustomize。您可以本机使用<code class="fe ms mt mu mv b">kubectl -k</code>或安装二进制文件。对于后者，您可以使用以下命令自动检测您的操作系统并安装Kustomize:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5aee" class="na lw it mv b gy nb nc l nd ne">curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh"  <strong class="mv iu">|</strong> bash</span></pre><p id="80f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这个脚本不适用于基于ARM的架构。或者，导航到<a class="ae ky" href="https://github.com/kubernetes-sigs/kustomize/releases" rel="noopener ugc nofollow" target="_blank">发布页面</a>，为您的发行版选择正确的二进制文件，并将其移动到您的<code class="fe ms mt mu mv b">$PATH</code>中。</p><p id="27da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试Kustomize是否按预期工作，您可以从<a class="ae ky" href="https://github.com/vfiftyfive/CFD12-Demo-Manifests" rel="noopener ugc nofollow" target="_blank">https://github.com/vfiftyfive/CFD12-Demo-Manifests</a>下载应用程序清单并生成开发清单。为此，运行以下命令:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="358b" class="na lw it mv b gy nb nc l nd ne">$ git clone <a class="ae ky" href="https://github.com/vfiftyfive/CFD12-Demo-Manifests" rel="noopener ugc nofollow" target="_blank">https://github.com/vfiftyfive/CFD12-Demo-Manifests</a> &amp;&amp; cd CFD12-Demo-Manifests<br/>Cloning into 'CFD12-Demo-Manifests'...<br/>remote: Enumerating objects: 164, done.<br/>remote: Counting objects: 100% (164/164), done.<br/>remote: Compressing objects: 100% (96/96), done.<br/>remote: Total 164 (delta 80), reused 136 (delta 52), pack-reused 0<br/>Receiving objects: 100% (164/164), 15.02 KiB | 3.75 MiB/s, done.<br/>Resolving deltas: 100% (80/80), done.</span><span id="58ed" class="na lw it mv b gy nf nc l nd ne">$ kustomize build overlay/dev <br/>allowVolumeExpansion: true<br/>apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/>  name: ondat<br/>parameters:<br/>  csi.storage.k8s.io/controller-expand-secret-name: csi-controller-expand-secret<br/>  csi.storage.k8s.io/controller-expand-secret-namespace: kube-system<br/>  csi.storage.k8s.io/controller-publish-secret-name: csi-controller-publish-secret<br/>  csi.storage.k8s.io/controller-publish-secret-namespace: kube-system<br/>  csi.storage.k8s.io/fstype: ext4<br/>  csi.storage.k8s.io/node-publish-secret-name: csi-node-publish-secret<br/>  csi.storage.k8s.io/node-publish-secret-namespace: kube-system<br/>  csi.storage.k8s.io/provisioner-secret-name: csi-provisioner-secret<br/>  csi.storage.k8s.io/provisioner-secret-namespace: kube-system<br/>  storageos.com/replicas: "1"<br/>provisioner: csi.storageos.com</span><span id="b0a3" class="na lw it mv b gy nf nc l nd ne">...</span></pre><p id="1900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们截断了输出，但是该命令生成了将应用程序部署到dev集群所需的所有清单。你还可以注意到在<code class="fe ms mt mu mv b">base</code>和<code class="fe ms mt mu mv b">dev</code>文件夹中有一个名为<code class="fe ms mt mu mv b">kustomization.yaml</code>的附加文件。Kustomize需要这些文件来了解要呈现哪些清单以及如何呈现。位于<code class="fe ms mt mu mv b">base</code>文件夹中的定制文件包含以下代码:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="22b8" class="na lw it mv b gy nb nc l nd ne">apiVersion: kustomize.config.k8s.io/v1beta1<br/>kind: Kustomization<br/>resources:<br/>- ondat_sc.yaml<br/>- mongo_sts.yaml<br/>- marvel_deploy.yaml<br/>- job.yaml<br/>- marvel_svc.yaml</span></pre><p id="bb12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦Kustomize查看了<code class="fe ms mt mu mv b">base</code>文件夹，它就将定制应用于在<em class="ng"> resources </em>下的文件中描述的所有子YAML资源。</p><p id="f037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ng"> dev </em>文件夹还包含一个<code class="fe ms mt mu mv b">kustomization.yaml</code>文件，该文件详细描述了呈现最终版本清单所需的特定更改。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d039" class="na lw it mv b gy nb nc l nd ne">apiVersion: kustomize.config.k8s.io/v1beta1<br/>kind: Kustomization<br/>patchesStrategicMerge:<br/>- ondat_sc.yaml<br/>- marvel_deploy.yaml<br/>- mongodbcommunity_cr.yaml<br/>- job.yaml<br/>resources:<br/>- ../../base<br/>configMapGenerator:<br/>- name: mongo-config<br/>  literals:<br/>  - MONGO_SEED0=mongodb-0.mongodb.default.svc.cluster.local<br/>  - MONGO_SEED1=mongodb-1.mongodb.default.svc.cluster.local<br/>  - MONGO_SEED2=mongodb-2.mongodb.default.svc.cluster.local<br/>  - OFFSET=600<br/>  - MONGO_USERNAME=admin<br/>secretGenerator:<br/>- name: admin-password<br/>  literals:<br/>  - password=mongo<br/>configurations:<br/>- name_reference.yaml</span></pre><p id="9a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看不同的部分:</p><ul class=""><li id="a59c" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">列出了Kustomize在构建目标清单时应该查看的文件。这些文件位于<em class="ng"> dev </em>文件夹下，描述了应用于位于<em class="ng"> base </em>文件夹中的清单的修改。这些文件可以在git repo中访问，下面是它们描述的更改的摘要:</li><li id="c9f9" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe ms mt mu mv b">ondat.sc.yaml</code> <em class="ng"> : </em>使用<code class="fe ms mt mu mv b">StorageClass</code>为所有卷创建1个副本，并启用加密。</li><li id="61ef" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe ms mt mu mv b">marvel_deploy.yaml</code> <em class="ng"> : </em>设置副本数量为2，从Kustomize <code class="fe ms mt mu mv b">Secret</code>生成器注入MongoDB密码，从<code class="fe ms mt mu mv b">configMap</code>生成器添加环境变量。</li><li id="f64c" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe ms mt mu mv b">mongodbcommunity_cr.yaml</code>:设置MongoDB版本为5.0.5，设置admin用户，使用Ondat <code class="fe ms mt mu mv b">StorageClass</code>配置带有<code class="fe ms mt mu mv b">volumeClaimTemplate</code>的Kubernetes <code class="fe ms mt mu mv b">StatefulSet</code>，设置数据和日志卷大小。</li><li id="fde7" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe ms mt mu mv b">job.yaml</code> <em class="ng"> : </em>从Kustomize <code class="fe ms mt mu mv b">Secret</code>生成器注入MongoDB密码，从<code class="fe ms mt mu mv b">configMap</code>生成器注入环境变量。</li></ul><p id="0c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其余部分，我们有:</p><ul class=""><li id="21bb" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe ms mt mu mv b">resources</code>，定义基本清单的位置。</li><li id="7cfd" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe ms mt mu mv b">configMapGenerator</code>，每次Kustomize运行时都会生成一个具有唯一名称的<code class="fe ms mt mu mv b">configMap</code>。您可以使用文字或文件来定义变量。</li><li id="586f" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe ms mt mu mv b">secretGenerator</code>，Kustomize每次运行时都会生成一个唯一名称的<code class="fe ms mt mu mv b">Secrets</code>。您可以使用文字或文件来定义您的秘密。</li><li id="0ce4" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe ms mt mu mv b">configurations</code>，指定Kustomize用来修改或插入特定值的自定义对象路径。例如，在我们的场景中，Kustomize动态配置对MongoDB定制资源中秘密的引用。由于它是一个定制资源，Kustomize不知道在哪里可以找到等价的秘密名称参数。相反，我们在文件<code class="fe ms mt mu mv b">name_reference.yaml</code>中定义它:</li></ul><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3cbe" class="na lw it mv b gy nb nc l nd ne">nameReference:<br/>- kind: Secret<br/>  fieldSpecs:<br/>  - kind: MongoDBCommunity<br/>    path: spec/users/passwordSecretRef/name</span></pre><p id="9dfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，每次调用Kustomize时，都会在这个位置添加一个由初始的<code class="fe ms mt mu mv b">Secret</code>名和一个随机字符串组成的唯一的<code class="fe ms mt mu mv b">Secret</code>名。Kustomize还将替换相关资源中本地对象YAML定义内的所有秘密。这些是您在<code class="fe ms mt mu mv b">kustomization.yaml</code>文件中定义的资源。</p><h1 id="e29e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装并配置MongoDB操作符</h1><p id="8b65" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于本文，我们使用了<a class="ae ky" href="https://github.com/mongodb/mongodb-kubernetes-operator" rel="noopener ugc nofollow" target="_blank"> MongoDB社区操作符</a>，因为它免费且易于使用。但是，对于生产环境，我们建议使用企业版的操作器，或者准备好自己支持它并从社区获得帮助。有多种选项可用，比如<a class="ae ky" href="https://docs.mongodb.com/kubernetes-operator/master/" rel="noopener ugc nofollow" target="_blank"> MongoDB企业操作符</a>、<a class="ae ky" href="https://github.com/percona/percona-server-mongodb-operator" rel="noopener ugc nofollow" target="_blank"> Percona操作符</a>或<a class="ae ky" href="https://kubedb.com/docs/0.8.0-beta.0/guides/mongodb/overview/" rel="noopener ugc nofollow" target="_blank"> KubeDB操作符</a>。</p><h2 id="79b3" class="na lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">了解操作员</h2><p id="2e39" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你们中的一些人可能不熟悉Kubernetes操作员，也不知道为什么我们需要一个操作员来安装一个数据库集群。所以让我们稍微关注一下这方面。Kubernetes操作员基本上由两部分组成:</p><ul class=""><li id="d3be" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">作为容器提供的一段代码，它持续监视Kubernetes API中的特定对象，并根据这种主动监视执行操作。它被称为<strong class="lb iu">定制控制器。</strong></li><li id="3b2a" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">受监控的自定义资源。自定义资源是非本机的Kubernetes对象。自定义资源模式在自定义资源定义(CRD)中定义，由用户作为YAML文件提供，并发送给Kubernetes API。用该模式创建的每个对象都进一步保存在Kubernetes etcd存储中。您可以将CRD比作OOP中的一个类，将自定义资源比作该类的一个实例。它扩展了现有的Kubernetes API。</li></ul><p id="77a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes操作员的工作是执行自动化操作，并像人类操作员一样与集群或集群外的系统进行交互。它不仅限于部署组件。它可以执行CRUD操作来响应Kubernetes事件，这些事件本质上是动态的。它利用事件数据作为工作流的输入。运营商的一个常见用例是在Kubernetes中自动部署软件解决方案。因此，在数据库的情况下，一旦Kubernetes API获取了相应的数据库资源，Kubernetes操作员就会安装数据库(集群或独立的)，通常以YAML清单的形式，将数据库的配置描述为定制资源。</p><p id="ef48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，记住数据库是作为<code class="fe ms mt mu mv b">StatefulSet</code>部署的。当您扩展<code class="fe ms mt mu mv b">StatefulSet</code>时，Kubernetes不会自动<em class="ng">扩展数据库集群。它只是用数据库映像部署新的容器。需要做一些额外的工作来配置它。它由Kubernetes操作员执行。当你缩小<code class="fe ms mt mu mv b">StatefulSet</code>的时候也是一样。</em></p><p id="0e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在MongoDB操作符的例子中，添加的CRD产生了一个种类为<code class="fe ms mt mu mv b">mongodbcommunity</code>的对象。定制资源封装了部署和维护MongoDB数据库所需的所有信息。首先，您需要安装操作符并创建自定义资源。这可以在Kubernetes集群的自动部署过程中实现，也可以在集群安装后手动实现。你可以在这个<a class="ae ky" href="https://github.com/vfiftyfive/mongodb-community-operator-manifests" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到所有需要的文件。我们将执行几个步骤来安装操作符:</p><ul class=""><li id="a4ae" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">安装CRD</li><li id="b354" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">创建操作员配置清单。可以参考<a class="ae ky" href="https://github.com/mongodb/mongodb-kubernetes-operator/blob/master/docs/install-upgrade.md" rel="noopener ugc nofollow" target="_blank"> MongoDB社区运营商</a>文档和例子。您还可以找到我们在<a class="ae ky" href="https://github.com/vfiftyfive/mongodb-community-operator-manifests.git" rel="noopener ugc nofollow" target="_blank"> git repo </a>中使用的配置。运营商配置清单是<code class="fe ms mt mu mv b">manager.yaml</code>。</li></ul><p id="e6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要首先配置操作符的范围。它定义了操作员监视哪些名称空间:安装操作员的<code class="fe ms mt mu mv b">Namespace</code>、特定的名称空间或所有名称空间。在我们的示例中，<code class="fe ms mt mu mv b">manager.yaml</code>文件具有以下配置:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="db1b" class="na lw it mv b gy nb nc l nd ne">env:<br/>- name: WATCH_NAMESPACE<br/>  value: "*"</span></pre><p id="2351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它告诉操作员监视MongoDB定制资源操作的所有名称空间。</p><ul class=""><li id="38c0" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">创建集群范围的角色和角色绑定。必须用您想要使用的名称空间的名称来修改<code class="fe ms mt mu mv b">ClusterRoleBinding</code>服务帐户名称空间(在下面的文本中以粗体显示)。它位于文件<code class="fe ms mt mu mv b">clusterwide/role_binding.yaml</code>中</li></ul><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="78d3" class="na lw it mv b gy nb nc l nd ne">kind: ClusterRoleBinding<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>metadata:<br/>  name: mongodb-kubernetes-operator<br/>subjects:<br/>- kind: ServiceAccount<br/>  namespace: <strong class="mv iu">mongo-operator</strong><br/>  name: mongodb-kubernetes-operator<br/>roleRef:<br/>  kind: ClusterRole<br/>  name: mongodb-kubernetes-operator<br/>  apiGroup: rbac.authorization.k8s.io</span></pre><ul class=""><li id="dfa8" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">对于您希望操作员观察的每个名称空间，您需要在该名称空间中部署一个<code class="fe ms mt mu mv b">Role</code>、<code class="fe ms mt mu mv b">RoleBinding</code>和<code class="fe ms mt mu mv b">ServiceAccount</code></li><li id="c583" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">最后一步是创建和部署数据库配置清单(定制资源)，这将在后面详述。</li></ul><h2 id="99c0" class="na lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">部署操作员</h2><p id="d184" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">执行以下命令来安装和配置操作员:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="61c5" class="na lw it mv b gy nb nc l nd ne">#Clone the git repository<br/>$ git clone <a class="ae ky" href="https://github.com/vfiftyfive/mongodb-community-operator-manifests" rel="noopener ugc nofollow" target="_blank">https://github.com/vfiftyfive/mongodb-community-operator-manifests</a> &amp;&amp; cd mongodb-community-operator-manifests<br/>Cloning into 'mongodb-community-operator-manifests'...<br/>remote: Enumerating objects: 17, done.<br/>remote: Counting objects: 100% (17/17), done.<br/>remote: Compressing objects: 100% (14/14), done.<br/>remote: Total 17 (delta 5), reused 15 (delta 3), pack-reused 0<br/>Receiving objects: 100% (17/17), done.<br/>Resolving deltas: 100% (5/5), done.</span><span id="efa4" class="na lw it mv b gy nf nc l nd ne">#Install the CRD<br/>$ kubectl apply -f mongo-crd.yaml</span><span id="b115" class="na lw it mv b gy nf nc l nd ne">#Deploy the clusterwide RBAC resources<br/>$ kubectl apply -f clusterwide/<br/>clusterrole.rbac.authorization.k8s.io/mongodb-kubernetes-operator created<br/>clusterrolebinding.rbac.authorization.k8s.io/mongodb-kubernetes-operator created</span><span id="6de2" class="na lw it mv b gy nf nc l nd ne">#Create a namespace for the operator<br/>$ kubectl create ns mongo-operator<br/>namespace/mongo-operator created</span><span id="b856" class="na lw it mv b gy nf nc l nd ne">#Deploy namespace RBAC resources in the operator namespace.<br/>$ kubectl apply -k rbac/ -n mongo-operator<br/>serviceaccount/mongodb-database created<br/>serviceaccount/mongodb-kubernetes-operator created<br/>role.rbac.authorization.k8s.io/mongodb-database created<br/>role.rbac.authorization.k8s.io/mongodb-kubernetes-operator created<br/>rolebinding.rbac.authorization.k8s.io/mongodb-database created<br/>rolebinding.rbac.authorization.k8s.io/mongodb-kubernetes-operator created</span><span id="5b9a" class="na lw it mv b gy nf nc l nd ne">#Deploy namespace RBAC resources in the default namespace (where the app will be deployed)<br/>$ kubectl apply -k rbac/ <br/>serviceaccount/mongodb-database created<br/>serviceaccount/mongodb-kubernetes-operator created<br/>role.rbac.authorization.k8s.io/mongodb-database created<br/>role.rbac.authorization.k8s.io/mongodb-kubernetes-operator created<br/>rolebinding.rbac.authorization.k8s.io/mongodb-database created<br/>rolebinding.rbac.authorization.k8s.io/mongodb-kubernetes-operator created</span><span id="04a7" class="na lw it mv b gy nf nc l nd ne">#Deploy the Operator<br/>$ k apply -f manager.yaml -n mongo-operator<br/>deployment.apps/mongodb-kubernetes-operator created</span><span id="9f3e" class="na lw it mv b gy nf nc l nd ne">#Check the Operator has correctly been deployed<br/>$ kubectl get po -n mongo-operator<br/>NAME                                           READY   STATUS ...<br/>mongodb-kubernetes-operator-6d46dd4b74-ztx9c   1/1     Running ...</span></pre><p id="9525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦操作员检测到Kubernetes API中添加了新的定制资源，就可以部署新的MongoDB数据库。</p><p id="3815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是安装分布式存储层Ondat(以前的StorageOS)。</p><h1 id="e09e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装Ondat</h1><p id="4139" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Ondat提供了一个数据网格，作为一个分布式持久存储层，提供Kubernetes中默认不包含的高级功能。这包括复制、加密、性能优化、智能卷放置等，所有这些都作为原生Kubernetes标签和注释的一部分进行管理。</p><p id="8ff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以通过一个<code class="fe ms mt mu mv b">kubectl</code>插件用一行代码部署(或者使用一个可用的舵图<a class="ae ky" href="https://github.com/ondat/charts" rel="noopener ugc nofollow" target="_blank">这里是</a>):</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="a0c9" class="na lw it mv b gy nb nc l nd ne">kubectl storageos install --include-etcd</span></pre><p id="e8ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是首先，让我们通过执行以下命令来安装插件:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0e25" class="na lw it mv b gy nb nc l nd ne">curl -sSLo kubectl-storageos.tar.gz \<br/>    https://github.com/storageos/kubectl-storageos/releases/download/v1.0.0/kubectl-storageos_1.0.0_linux_amd64.tar.gz \<br/>    &amp;&amp; tar -xf kubectl-storageos.tar.gz \<br/>    &amp;&amp; chmod +x kubectl-storageos \<br/>    &amp;&amp; sudo mv kubectl-storageos /usr/local/bin/ \<br/>    &amp;&amp; rm kubectl-storageos.tar.gz</span></pre><p id="dcdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为您的Kubernetes主机的内核模块有一些<a class="ae ky" href="https://docs.ondat.io/docs/prerequisites/systemconfiguration/" rel="noopener ugc nofollow" target="_blank">先决条件</a>，所以您应该首先运行预检检查，通过运行以下命令来查看您的集群是否兼容:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3c13" class="na lw it mv b gy nb nc l nd ne">kubectl storageos preflight</span></pre><p id="5223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(快速提示:如果你使用GKE，使用<em class="ng"> ubuntu_containerd </em>镜像，它已经包含了<em class="ng">Linux-modules-extra-x . y . z</em>包)</p><p id="3e9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将输出如下所示的综合报告。该屏幕抓图描述了一个在我们的3节点群集中没有NVMe驱动器的示例。如果您没有运行性能密集型工作负载，可以安全地忽略此警告。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/489950ca6d81ddd5e60ee381cde8d32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agnwQ5iAzb9gvQJACr3q5A.png"/></div></div></figure><p id="b2ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以使用带有install子命令的插件:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e5eb" class="na lw it mv b gy nb nc l nd ne">kubeclt storageos install --include-etcd</span></pre><p id="6765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令有许多选项。如果您考虑生产部署，您应该看一看它们并熟悉最佳实践。由于这不是本文的主题，我将在这里为您指出正确的方向<a class="ae ky" href="https://docs.ondat.io/docs/self-eval/" rel="noopener ugc nofollow" target="_blank"/>！</p><p id="6108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查部署是否完成，请运行以下命令，确保<code class="fe ms mt mu mv b">DaemonSet</code>已启动并正在运行:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="829c" class="na lw it mv b gy nb nc l nd ne">$ kubectl get pods -n storageos | grep node                                                                                                                                                 <br/>storageos-node-8chxx                     3/3     Running          <br/>storageos-node-gsdzt                     3/3     Running          <br/>storageos-node-sq2ds                     3/3     Running  </span></pre><p id="aa9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有容器都必须启动并运行。您还应该注意到一个名为“storageos”的新<code class="fe ms mt mu mv b">StorageClass</code>。但是请记住Kustomize将创建一个新的<code class="fe ms mt mu mv b">StorageClass</code>，所以我们不会使用它。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="f631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经部署和配置了Kustomize、MongoDB和Ondat。这已经很多了！在下一部分中，我们将安装和配置Skaffold，并构建管道来持续开发、部署和测试我们的应用程序。我们把最好的留到了最后，所以不要错过下一篇文章！</p></div></div>    
</body>
</html>