<html>
<head>
<title>How To Use Kubernetes To Run Your Cron Jobs Effectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Kubernetes有效地运行Cron作业</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-cron-jobs-659a9c6db0e?source=collection_archive---------6-----------------------#2021-03-24">https://betterprogramming.pub/kubernetes-cron-jobs-659a9c6db0e?source=collection_archive---------6-----------------------#2021-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4fd4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最佳配置crons的实践指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17156c994a082d34a1bd2f0e65d7fe99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceVn2-DoR_usvs8IREIWQg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@arni_gill?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Swag摄影</a>在<a class="ae ky" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e2cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes在运行cron作业以及其他web应用程序工作负载方面非常有效。Kubernetes cron作业是一种特殊的Kubernetes作业，它按基于时间的计划运行。在本文中，我们将关注如何在Kubernetes上运行优化配置的cron作业。</p><h1 id="3d9d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是Kubernetes？</h1><p id="34af" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Kubernetes有多种定义。我们将首先查看其中的几个，然后尝试简化它们。官方“什么是Kubernetes？”Kubernetes.io上的页面:</p><blockquote class="ms"><p id="a830" class="mt mu it bd mv mw mx my mz na nb lu dk translated">Kubernetes是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，有助于实现声明式配置和自动化</p></blockquote><p id="6ac4" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">它进一步补充说，“Kubernetes这个名字来源于希腊语，意思是舵手或领航员。谷歌在2014年开源了Kubernetes项目。”还提到了Google在大规模运行生产工作负载方面超过15年的经验。</p><p id="2626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes上的维基百科页面声明:</p><blockquote class="ms"><p id="c73a" class="mt mu it bd mv mw mx my mz na nb lu dk translated">Kubernetes(通常风格化为K8s)是一个开源的容器编排系统，用于自动化计算机应用程序部署、扩展和管理</p></blockquote><p id="4890" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">它还说，“它最初是由谷歌设计的，现在由云原生计算基金会维护。它旨在提供一个“跨主机集群自动部署、扩展和操作应用容器的平台。”"</p><h1 id="5d81" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Kubernetes是做什么的？</h1><p id="1106" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">好了，有了这些定义，让我们简化一下。如果我说这是部署web应用程序、cron作业等工作负载的容器时代，我不会错。在容器领域，Docker赢得了比赛，它是事实上的容器工具。</p><p id="ec67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这一点。我们可以从容器开始，在容器中运行一两个应用程序。这意味着，在任何给定的时间，我们将运行1-10个集装箱。随着时间的推移，我们喜欢这个想法和容器提供的其他优势，因此我们希望在容器中运行更多的工作负载/应用程序。这相当于有几十个容器在运行，可能是在生产中。</p><p id="9a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间越久，越多的app被容器化。此时，我们有数百个容器在运行。那么，我们如何衡量这些容器呢？我们如何让服务A与服务B对话？我们如何处理拥有数百个容器的数十个应用程序的部署和回滚？我们如何一致地有效管理这数百个容器的资源(CPU/RAM)和秘密？</p><p id="51a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上所有问题的答案是“容器编制器”2015年左右，Kubernetes、Docker Swarm、Apache Mesos之间出现了轻微的竞争。到2017年年中，Kubernetes轻松赢得了比赛，成为根据<a class="ae ky" href="https://trends.google.com/trends/explore?date=2015-01-01%202021-01-31&amp;q=kubernetes,docker%20swarm,apache%20mesos" rel="noopener ugc nofollow" target="_blank">谷歌趋势</a>广受欢迎的事实上的容器编排者，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/f4fafc3f640e845347bf905c10c49448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T6NMHoM7cN6dKZcsU6LIDg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes在2017年年中赢得了集装箱管弦乐比赛</p></figure><p id="2a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Kubernetes灵活、强大、超受欢迎；有些事情<a class="ae ky" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/#what-kubernetes-is-not" rel="noopener ugc nofollow" target="_blank"> Kubernetes不是</a>，最好也了解一下。如今，Kubernetes已经成为一个成熟的平台，拥有一个蓬勃发展的生态系统。</p><h1 id="7825" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">库伯内特克朗工作</h1><p id="4e4d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我是2016年在生产中使用Kubernetes的团队的一员。Kubernetes非常擅长管理长时间运行的工作负载，比如web服务器或队列消费者。在Kubernetes行话中，它们大致翻译为<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>和<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>工件。除了非常适合长时间运行的工作负载之外，Kubernetes在管理Cron作业方面也做得非常出色。</p><p id="5764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看一下Kubernetes的历史，Kubernetes Cron的工作被称为<code class="fe ni nj nk nl b">ScheduledJob</code>。在<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.5.md#action-required-before-upgrading" rel="noopener ugc nofollow" target="_blank">版本1.5 </a>中，它被重命名为Cron作业。在Kubernetes中，<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" rel="noopener ugc nofollow" target="_blank"> Cron作业</a>是一种特殊的<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank">作业</a>，它按照重复的时间表运行。Kubernetes Cron作业的频率以熟悉的<a class="ae ky" href="https://crontab.guru/" rel="noopener ugc nofollow" target="_blank"> Cron </a>格式编写。例如，cron格式中的<code class="fe ni nj nk nl b">0 4 * * *</code>表示每天早上4:00。如果你愿意，可以阅读更多关于<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax" rel="noopener ugc nofollow" target="_blank"> cron调度语法</a>的内容。</p><p id="16ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何知道cron作业是否错过了一个或多个计划？在它不知不觉地溜走之前，最好了解更多关于有效的<a class="ae ky" href="https://geshan.com.np/blog/2019/11/how-to-efficiently-monitor-crons-with-a-simple-bash-trick/" rel="noopener ugc nofollow" target="_blank"> cron作业监控</a>的信息。</p><h2 id="8305" class="nm lw it bd lx nn no dn mb np nq dp mf li nr ns mh lm nt nu mj lq nv nw ml nx bi translated">先决条件</h2><ul class=""><li id="a8a0" class="ny nz it lb b lc mn lf mo li oa lm ob lq oc lu od oe of og bi translated">你通常知道Kubernetes是如何工作的，如何将容器作为<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank"> pods </a>进行调度。</li><li id="8dfe" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">您知道Kubernetes以声明的方式管理对象和配置。</li><li id="821f" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">服务、部署和<a class="ae ky" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器</a>之间的区别</li><li id="ec65" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">你一般都知道<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口</a>在Kubernetes里是做什么用的。</li><li id="32fc" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">你知道常见的Kubernetes术语，如Node、Kubelet等。</li></ul><p id="579c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将研究一个简单的Kubernetes cron工作示例。</p><h2 id="c659" class="nm lw it bd lx nn no dn mb np nq dp mf li nr ns mh lm nt nu mj lq nv nw ml nx bi translated">Kubernetes cron job:简单的例子</h2><p id="6c2d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将在<a class="ae ky" href="https://kind.sigs.k8s.io/docs/user/quick-start/" rel="noopener ugc nofollow" target="_blank"> Kind </a>上尝试一个简单的Kubernetes cron工作示例。在撰写本文时，Kind版本0.9.0启动了版本1.19.1的Kubernetes集群。下面是我们简单的Kubernetes cron文件，它使用一个<code class="fe ni nj nk nl b">node:14-alpine</code>图像来打印当前日期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们简单地分析一下，而不是详细地配置Cronjob.yaml文件:</p><ol class=""><li id="e981" class="ny nz it lb b lc ld lf lg li oo lm op lq oq lu or oe of og bi translated">我们使用的是Kubernetes API的<code class="fe ni nj nk nl b">batch/v1beta1</code> API版本。</li><li id="addf" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">这是一种<code class="fe ni nj nk nl b">CronJob</code> Kubernetes资源/工作量。</li><li id="2d2e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">我们将cron作业命名为<code class="fe ni nj nk nl b">print-date</code>。</li><li id="f37b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">Kubernetes cron作业计划每五分钟执行一次— <code class="fe ni nj nk nl b">*/5 * * * *</code>。</li><li id="4b20" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">我们使用的是<code class="fe ni nj nk nl b">node:14-alpine</code>图片，默认从Docker hub获取。</li><li id="aa98" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated"><code class="fe ni nj nk nl b">IfNotPresent</code>图像拉取策略是默认策略。它使<a class="ae ky" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank"> kubelet </a>获取一个不存在的图像。</li><li id="8ce5" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">然后，我们传入<code class="fe ni nj nk nl b">-e</code>进行eval，传入<code class="fe ni nj nk nl b">console.log</code>以字符串形式打印当前日期。由于节点容器的命令是<code class="fe ni nj nk nl b">node</code>，这将打印当前日期和时间。</li><li id="19bd" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">容器将根据上述<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" rel="noopener ugc nofollow" target="_blank">重启策略</a>在出现故障时重启。</li></ol><p id="ee0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将这个cron作业安排在一个本地的Kubernetes集群上进行测试。在写这篇博文的时候，我使用的是0.9.0版本——它安装了Kubernetes 1 . 19 . 1版本。</p><p id="babc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将上面的文件保存为<code class="fe ni nj nk nl b">cronjob.yaml</code>，我们可以用下面的命令将它添加到Kubernetes:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="c8b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令成功运行后，我们将看到如下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查cron作业是否创建成功，我们可以执行以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="244a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切正常，它将打印出如下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="662b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">五分钟后，我们可以试试<code class="fe ni nj nk nl b">kubectl get po | grep print-date</code>。我们应该看到cron已经运行了一次，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ec3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看已经运行的cron作业的日志，我们应该执行<code class="fe ni nj nk nl b">kubectl logs print-date-1613818500-88ln6</code>，其中<code class="fe ni nj nk nl b">print-date-1613818500-88ln6</code>是pod名称。在您的情况下，这个名称会有所不同。名称显示后，我们应该会看到以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下下面的命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/24f4a9b7c236b0845d1be971ae121f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5qR8iRTi_Zz_0t1oe2D5g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes cron job:一个简单的例子—没有优化配置</p></figure><p id="6945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一部分中，我们将研究如何优化配置Kubernetes Cron作业。</p><h2 id="f279" class="nm lw it bd lx nn no dn mb np nq dp mf li nr ns mh lm nt nu mj lq nv nw ml nx bi translated">Kubernetes cron job是一个最佳的例子</h2><p id="dd33" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在上面这个简单的例子中，让我们仔细观察一些事情:</p><ol class=""><li id="582d" class="ny nz it lb b lc ld lf lg li oo lm op lq oq lu or oe of og bi translated">命令有错误怎么办？Kubernetes会多次尝试安排cron job pod吗？</li><li id="f07e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">我们如何清理已经完成工作的pod？</li><li id="34b7" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">如果我们的cron作业还没有完成——是时候运行下一个作业了，该怎么办？我们只想跳过下一次运行，因为当前作业尚未完成。</li><li id="91be" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">我们想暂时停止cron作业。</li><li id="dc9c" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">我们希望看到一些旧的cron作业运行的日志，即使它们已经失败或成功。</li></ol><p id="b43f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上问题以及更多问题的答案都在下面的cron作业配置中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8b5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析一些新添加的配置，以及它们的作用:</p><ol class=""><li id="4b88" class="ny nz it lb b lc ld lf lg li oo lm op lq oq lu or oe of og bi translated">在该定义中，<code class="fe ni nj nk nl b">backoffLimit</code>用于指定将作业标记为<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy" rel="noopener ugc nofollow" target="_blank">失败</a>之前的重试次数。例如，如果容器没有启动或命令有错误，我们指定它应该在回退之前重试五次(将作业标记为失败)。</li><li id="51fc" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">为了减轻Kubernetes的压力，我们可以在完成后指定TTL秒数，此时TTL控制器清理作业并以级联方式<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/#ttl-mechanism-for-finished-jobs" rel="noopener ugc nofollow" target="_blank">删除作业</a>。</li><li id="bbd7" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated"><code class="fe ni nj nk nl b">parallelism</code>和<code class="fe ni nj nk nl b">completions</code>默认为<code class="fe ni nj nk nl b">1</code>；它可以用于只有一个pod在<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/#controlling-parallelism" rel="noopener ugc nofollow" target="_blank">平行</a>运行。</li><li id="2121" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">如果您想跳过下一次运行，使用<code class="fe ni nj nk nl b">concurrencyPolicy</code>非常方便——如果当前的cron job pod仍然是活动的。将其设置为<code class="fe ni nj nk nl b">Forbid</code>可以启用此功能。如果您的作业要求在下一次运行时取消当前运行，那么它可以被设置为替换<a class="ae ky" href="https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs/#concurrency-policy" rel="noopener ugc nofollow" target="_blank">并发策略</a>。</li><li id="62b9" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu or oe of og bi translated">最后，我们设定了成功和失败的工作历史。我们这样做是为了在一定的限度内不清理那些pod，如果需要，我们可以检查日志。</li></ol><p id="b8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是重新应用新定义并检查我们添加的新配置的运行日志的屏幕截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/d3667ad577342414a68404b0e4526e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPbgnddhrMrWHzNPw-T6SQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes cron job是一个更好的例子—优化配置</p></figure><p id="580a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图中的新命令是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="87ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它获取作业并观察它是否有任何变化。正如您在截图中看到的，它在每秒运行作业<code class="fe ni nj nk nl b">print-date-1613820600</code>2-3秒时检测到了变化。</p><h2 id="b163" class="nm lw it bd lx nn no dn mb np nq dp mf li nr ns mh lm nt nu mj lq nv nw ml nx bi translated">即时运行Kubernetes cron jobs</h2><p id="9e37" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">专业提示:您可以使用如下命令强制运行Kubernetes Cron作业(在计划之外):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="6e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于测试cron作业来说非常方便，因为我们不需要等待预定的运行。</p><p id="dc74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要求Kubernetes创建一个名称为<code class="fe ni nj nk nl b">print-date-try01. </code>的作业，该名称必须是唯一的。如果您第二次运行它，请使用<code class="fe ni nj nk nl b">try02</code>。我们告诉Kubernetes从我们的cron作业<code class="fe ni nj nk nl b">cronjob/print-date</code>中创建作业。</p><p id="51ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到上面命令的一个例子，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/6afa874d04b560505e4b83cad035a6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeqcDooqNFr24v3iiDxLmw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是一个创建作业的演示程序，对于测试cron作业非常有用</p></figure><p id="000b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，计划每五分钟运行一次的cron作业在<code class="fe ni nj nk nl b">11:35:54</code>和<code class="fe ni nj nk nl b">11:36:35</code>运行，这超出了它的常规计划。这是可能的，因为我们根据需要强制运行cron作业，而不是等待调度。当测试计划每小时或每天运行的Kubernetes cron作业时，这个命令非常方便。</p><h1 id="fb40" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="fe59" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如我们所见，Kubernetes cron jobs非常有用。除了擅长处理长时间运行的工作负载之外，Kubernetes在执行作业和cron作业方面也做得非常出色。</p><p id="1727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些建议:优化配置您的Kubernetes cron作业，以便在Kubernetes集群上运行您期望的cron作业。</p><p id="c78f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使是现代的应用程序也有需要用Cron作业来完成的任务，Kubernetes cron作业可以用来完成这样的任务。</p></div></div>    
</body>
</html>