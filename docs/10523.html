<html>
<head>
<title>Exploring Automated Testing in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Swift中的自动化测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automated-testing-in-swift-2e98d37d692c?source=collection_archive---------10-----------------------#2022-01-12">https://betterprogramming.pub/automated-testing-in-swift-2e98d37d692c?source=collection_archive---------10-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8fe9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">测试金字塔的底部</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/da758e18101221672fa5918a76a8f579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Giww9-222J4IekqXuVFUQ.png"/></div></div></figure><blockquote class="kr ks kt"><p id="2109" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">应用程序的最小可测试部分被认为是一个单元。单元测试是自动检查一个单元是否正常运行。每个单元都应该仔细彻底地测试。</p></blockquote><p id="0aa3" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">这个定义的问题是“<em class="kw">最小可测试”部分。</em>最小的可测试部分是什么，我们如何保持它的小？</p><p id="25a0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">让我们从一些非常基本的单元测试例子开始。</p><h1 id="350b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">测试功能</h1><p id="cde7" class="pw-post-body-paragraph ku kv iq kx b ky mm jr la lb mn ju ld lr mo lg lh ls mp lk ll lt mq lo lp lq ij bi translated">假设您需要创建一个函数，将两个整数相加并返回它们的和。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="3657" class="mw lv iq ms b gy mx my l mz na"><strong class="ms ir">public</strong> <strong class="ms ir">func</strong> addInt(_ a: Int, _ b: Int) -&gt; Int {<br/>    a + b<br/>}</span></pre><p id="21f4" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">当然，我们添加了必要的单元测试。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="0fb5" class="mw lv iq ms b gy mx my l mz na"><strong class="ms ir">func</strong> testAddInt() {<br/>    XCTAssertEqual(addInt(10, 20), 30)<br/>    XCTAssertEqual(addInt(-10, 20), 10)<br/>    XCTAssertEqual(addInt(-10, -20), -30)<br/>}</span></pre><p id="4d3b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">测试够了吗？可惜没有。这些测试只检查快乐的路径。当使用的数字很小时，他们检查代码是否有效。如果这两个整数中有一个是<code class="fe nb nc nd ms b">Int.max</code>(系统支持的最大整数)会怎么样？让我们找出答案。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="fb9e" class="mw lv iq ms b gy mx my l mz na"><strong class="ms ir">func</strong> testAddInt_max() {<br/>    XCTAssertEqual(addInt(Int.max, 10), Int.max)<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/dd3f9160689896fe826d8bd9f08b5a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7rgAnWIP78Nn6VtN4WYJw.png"/></div></div></figure><p id="bb01" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">我们可以看到我们有一个溢出错误。看来我们需要改进我们的代码。</p><p id="623d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">我们决定当我们有溢出时，它应该抛出一个溢出异常。此外，我们必须扩展我们的单元测试来覆盖这个场景，以测试我们的函数是否能够正确处理最大值和最小值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d26b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">尝试:</p><ul class=""><li id="2296" class="nh ni iq kx b ky kz lb lc lr nj ls nk lt nl lq nm nn no np bi translated">使用单元测试来检查在实际应用中很难遇到的问题。</li><li id="892c" class="nh ni iq kx b ky nq lb nr lr ns ls nt lt nu lq nm nn no np bi translated">尽可能好地测试你的代码。</li></ul><h1 id="06cd" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">测试类</h1><p id="38fc" class="pw-post-body-paragraph ku kv iq kx b ky mm jr la lb mn ju ld lr mo lg lh ls mp lk ll lt mq lo lp lq ij bi translated">通常，您想要测试的代码不会只有函数。它将由保存一些数据的类组成。在这种情况下，我们将对<code class="fe nb nc nd ms b">internal</code>或<code class="fe nb nc nd ms b">public</code>函数进行单元测试，并检查那些依赖于我们给出的输入的函数的输出。</p><p id="f830" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">示例:我们有一个用<code class="fe nb nc nd ms b">pets</code>和<code class="fe nb nc nd ms b">persons</code>初始化的视图模型。<code class="fe nb nc nd ms b">MyViewModel</code>给了我们一个宠物名和它们主人的列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="37c3" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">为了对这样一个类进行单元测试，我们应该用一些样本数据创建一个视图模型，然后检查<code class="fe nb nc nd ms b">listData()</code>函数的输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="05d0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">我不鼓励使用<code class="fe nb nc nd ms b">setUp()</code>方法在<code class="fe nb nc nd ms b">MyViewModelTests</code>的一些属性中存储大量数据。一个原因是当所有单元测试类的运行完成时，<code class="fe nb nc nd ms b">MyViewModelTests</code>类将被移除。在此之前，这些类及其属性将保留在内存中。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="e684" class="mw lv iq ms b gy mx my l mz na"><strong class="ms ir">final</strong> <strong class="ms ir">class</strong> MyViewModelTests: XCTestCase {<br/>    <strong class="ms ir">var</strong> viewModel: MyViewModel? = <strong class="ms ir">nil</strong></span><span id="a809" class="mw lv iq ms b gy nv my l mz na"><strong class="ms ir">    override</strong> <strong class="ms ir">func</strong> setUp() {<br/>        <strong class="ms ir">super</strong>.setUp()<br/>        viewModel = MyViewModel(persons: samplePersons(), <br/>                                   pets: samplePets())<br/>}</span></pre><p id="32d6" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">另一个原因是<code class="fe nb nc nd ms b">viewModel</code>属性是可选的，您的测试需要处理这种可选性。</p><h1 id="2665" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">属国</h1><p id="f8a1" class="pw-post-body-paragraph ku kv iq kx b ky mm jr la lb mn ju ld lr mo lg lh ls mp lk ll lt mq lo lp lq ij bi translated">通常我们不会将所有需要的数据注入视图模型，但是视图模型会从数据源获取这些信息。这个数据源可以是数据库、REST端点或任何其他存储。</p><p id="0bdd" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在这种情况下，让我们定义一个非常简单的数据源。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5627" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">我们在视图模型中使用这个数据源</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1294" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">这段代码运行良好。但是如果不测试数据源，我们就无法测试它。这与我们对单元测试的定义相矛盾<em class="kw">“应用程序的最小可测试部分被认为是一个单元”</em>。这里我们只想测试视图模型。数据源将被单独测试。</p><p id="444a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">为此，我们需要对代码做以下两件事:</p><ul class=""><li id="7c17" class="nh ni iq kx b ky kz lb lc lr nj ls nk lt nl lq nm nn no np bi translated">为数据源添加接口(协议)</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ul class=""><li id="7184" class="nh ni iq kx b ky kz lb lc lr nj ls nk lt nl lq nm nn no np bi translated">将数据源注入视图模型</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a4d5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">我们在这里可以做的一个小调整是为数据源使用一个默认参数。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="3c99" class="mw lv iq ms b gy mx my l mz na">init(datasource: DatasourceInterface = Datasource())</span></pre><p id="44e2" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在单元测试中，我们应该创建我们自己的定制<code class="fe nb nc nd ms b">DataSourceMock</code>并将其注入到我们的视图模型中，然后测试它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="35ff" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">更强的依赖性</h1><p id="f426" class="pw-post-body-paragraph ku kv iq kx b ky mm jr la lb mn ju ld lr mo lg lh ls mp lk ll lt mq lo lp lq ij bi translated">好了，数据源的例子很简单。但是如果依赖是外部类或者系统类怎么办？让我们想象一下，我们使用<code class="fe nb nc nd ms b">UserDefaults</code>来存储我们的值，而不是我们自己的数据源。</p><p id="fae1" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在这种情况下，我们应该将<code class="fe nb nc nd ms b">UserDefaults</code>注入到我们的视图模型中，就像每一个其他依赖一样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a4ee" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在我们的单元测试中，我们现在可以注入我们的定制<code class="fe nb nc nd ms b">UserDefaults</code>并避免使用标准的<code class="fe nb nc nd ms b">UserDefaults</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b0cb" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">那些测试正确吗？是的，他们是！但是它们不是单元测试，因为它们不测试最小的单元。为了测试我们的视图模型，现在我们实际上也需要使用<code class="fe nb nc nd ms b">UserDefaults</code>。我们可以将这些新测试命名为集成测试，也可以将它们作为附加测试。</p><p id="addc" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">为了进行适当的单元测试，我们应该引入一个<code class="fe nb nc nd ms b">UserDataStoreInterface</code>。</p><p id="d55a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">可以通过扩展或使用包装器来符合这个接口。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="a00d" class="mw lv iq ms b gy mx my l mz na"><strong class="ms ir">protocol</strong> UserDataStoreInterface {<br/>    <strong class="ms ir">func</strong> data(forKey defaultName: String) -&gt; Data?<br/>}</span><span id="be93" class="mw lv iq ms b gy nv my l mz na"><strong class="ms ir">extension</strong> UserDefaults: UserDataStoreInterface {}</span></pre><p id="d57d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">现在，在我们的视图模型中，我们使用这个接口来代替<code class="fe nb nc nd ms b">UserDefaults</code>。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="3a14" class="mw lv iq ms b gy mx my l mz na"><strong class="ms ir">final</strong> <strong class="ms ir">class</strong> MyViewModel3 {<br/>    <strong class="ms ir">private</strong> <strong class="ms ir">let</strong> datasource: UserDataStoreInterface</span><span id="2a9c" class="mw lv iq ms b gy nv my l mz na"><strong class="ms ir">    init</strong>(datasource: UserDataStoreInterface) {<br/>        <strong class="ms ir">self</strong>.datasource = datasource<br/>    }<br/>...</span></pre><p id="8f12" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在我们的单元测试中，我们不再需要<code class="fe nb nc nd ms b">UserDefaults</code>的实例。我们只需要一个<code class="fe nb nc nd ms b">UserDataStoreInterfaceMock</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0a34" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">如果我们使用<code class="fe nb nc nd ms b">CoreData</code>或REST客户机作为数据源，那么这种方法的好处会大得多。</p><p id="7053" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">诀窍是将外部依赖隐藏在接口后面，这样我们就可以模拟这种依赖。</p><h1 id="7009" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">依赖太多</h1><p id="0e46" class="pw-post-body-paragraph ku kv iq kx b ky mm jr la lb mn ju ld lr mo lg lh ls mp lk ll lt mq lo lp lq ij bi translated">一个可能发生的问题是你的类可能有太多的依赖项。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1a7e" class="mw lv iq ms b gy mx my l mz na"><strong class="ms ir">init</strong>(datasource: UserDataStoreInterface,<br/>     restclient: RestClient,<br/>     database: Database,<br/>     someUseCase: UseCase1,<br/>     someUseCase2: UseCase2,<br/>     webSocketClient: WSClient) {<br/>    ...<br/>}</span></pre><p id="0cff" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">完全测试这样的类是一个小小的噩梦。我们需要模仿每一个依赖项，并存根我们使用的每一个函数。这样一个类的单元测试很容易失去控制。</p><p id="0180" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在这种情况下，我建议将一些逻辑迁移到其他类，并对它们进行单独的测试。记住有一条<a class="ae nw" href="https://realm.github.io/SwiftLint/function_body_length.html" rel="noopener ugc nofollow" target="_blank"> Lint规则</a>建议函数不要超过40行，而<a class="ae nw" href="https://realm.github.io/SwiftLint/file_length.html" rel="noopener ugc nofollow" target="_blank">文件不要超过400行。如果一个类有5个以上的依赖项，这些规则被破坏的可能性很高。</a></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="b5ee" class="lu lv iq bd lw lx oe lz ma mb of md me jw og jx mg jz oh ka mi kc oi kd mk ml bi translated">纪念</h1><p id="c0b7" class="pw-post-body-paragraph ku kv iq kx b ky mm jr la lb mn ju ld lr mo lg lh ls mp lk ll lt mq lo lp lq ij bi translated">单元测试有局限性。他们不会发现每个错误。他们不会发现集成错误。编写和维护测试需要纪律。</p><p id="27e5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">但是<strong class="kx ir"> </strong>单元测试允许代码被安全地重构。它们是单位及其行为的活文档。它们有助于创建更好的代码结构。它们允许测试边缘情况。并降低出现bug的可能性。</p><p id="225b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">单元测试只是自动化测试的一部分，但是单元测试是自动化测试最重要的部分之一。</p><p id="9e50" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">我听到有人说他们不写单元测试，因为他们没有时间或预算。如果你的项目有3个月的寿命，那么我可以理解。在所有其他情况下，进行单元测试实际上会节省您的时间。否则你会浪费时间去修复错误，相反，你可以投资于重构代码或开发新功能。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="9205" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">测试像发布者这样的异步东西可能更棘手一些。为了得到一些提示，请看一个更古老的故事:</p><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/testing-your-combine-publishers-8ccd6bd151b"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">如何测试您的联合收割机出版商</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">发布者测试变得简单</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">better编程. pub</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kp om"/></div></div></a></div></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="8707" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">完整的代码示例可在此处找到:</p><div class="oj ok gp gr ol om"><a href="https://github.com/agiokas/UnitTesting101" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">GitHub - agiokas/UnitTesting101:单元测试101示例代码</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa kp om"/></div></div></a></div><p id="c564" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">一如既往，编码快乐！！</p></div></div>    
</body>
</html>