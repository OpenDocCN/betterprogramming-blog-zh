<html>
<head>
<title>Stubbing HTTP Response by Using Apple-Authorised Man-in-the-Middle Attack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Apple授权的中间人攻击阻止HTTP响应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stubing-http-response-by-using-apple-authorised-man-in-the-middle-attack-e0159671c4dd?source=collection_archive---------6-----------------------#2020-10-16">https://betterprogramming.pub/stubing-http-response-by-using-apple-authorised-man-in-the-middle-attack-e0159671c4dd?source=collection_archive---------6-----------------------#2020-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="092f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">URLSession如何工作以及如何通过子类化URLProtocol来存根响应</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c837ab8a469eaf5fe7b5eacdee35714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wpMFxFOkTWF-kbf2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@patkay?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕特凯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS应用程序与网络互动频繁。它们从服务器读取或写入状态，并从远程获取数据、图像、音频和视频。为了保护和验证网络层，我们围绕它编写单元测试。可悲的是，如果我们编写依赖于网络的测试，它们将会很慢而且不稳定。公平地说，它们不是真正的单元测试，而是更多的集成测试。</p><p id="6cf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何在不安装任何第三方库的情况下，存根化网络请求和响应，并将单元测试的代码与网络隔离开来？在<code class="fe lv lw lx ly b">URLSession</code>配置中注册自己的<code class="fe lv lw lx ly b">URLProtocol</code>实例是关键:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f1ba" class="md me it ly b gy mf mg l mh mi">urlSessionConfiguration.protocolClasses = [StubURLProtocol.self]</span></pre><p id="ffc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面详细解释代码。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/cb8f8a29ca9b5fdf1658b2b2838dad16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4ZwjtN6nXkSjap3W"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">NOAA 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="39a3" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.URL加载系统的核心流程</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/d546a3e2da8caa455b7fcf11324e6b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AaIWn0_SSreyEnv13yS6JQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的URLSession默认流</p></figure><h2 id="046c" class="md me it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">URLSession</h2><p id="569b" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated"><code class="fe lv lw lx ly b">URLSession</code>起着iOS URL加载系统的核心作用。<code class="fe lv lw lx ly b">URLSession</code>的实例创建一个或多个<code class="fe lv lw lx ly b">URLSessionTask</code>的实例，这些实例可以是其子类的实例:</p><ul class=""><li id="b230" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe lv lw lx ly b">URLSessionDataTask</code>:获取数据并将其返回至您的应用程序</li><li id="cc18" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">URLsessionUploadTask</code>:上传数据和文件到遥控器</li><li id="d1cf" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">URLSessionDownloadTask</code>:从遥控器下载数据和文件</li><li id="6f8e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">URLSessionStreamTask</code>:通过使用排队和串行执行的TCP/IP连接，从远程设备读取和向远程设备写入</li><li id="5c62" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">URLSessionWebSocketTask</code>:使用TCP和TLS，以WebSocket成帧的形式，异步读写远程。</li></ul><h2 id="dbb6" class="md me it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">URL session配置</h2><p id="1389" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我们使用<code class="fe lv lw lx ly b">URLSessionConfiguration</code>来配置<code class="fe lv lw lx ly b">URLSession</code>的实例，它控制行为，比如如何使用缓存和cookies或者是否允许蜂窝网络上的连接。</p><p id="56ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">URLSession</code>实例只包含一个<code class="fe lv lw lx ly b">URLSessionConfiguration</code>实例，但是可以重复创建多个<code class="fe lv lw lx ly b">URLSessionTask</code>实例。为了实现不同的缓存或cookie策略，我们需要在不同的会话中使用不同的配置。</p><h2 id="de69" class="md me it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">完成处理程序</h2><p id="c6eb" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">当<code class="fe lv lw lx ly b">URLSessionTask</code>的实例得到结果时，它将服务器的响应、数据和可能的错误传递给<code class="fe lv lw lx ly b">Commpletion Handler</code>。我们验证错误参数，并检查那里的响应状态代码和数据。</p><p id="9485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当发送HTTP请求时，我们使用带有默认配置的默认实例来创建带有请求的数据任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/6665e8a49e830176285e87c9224bf10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nINfpfbgMB-x5jMi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@bdchu614?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布伦丹·丘奇</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4041" class="mr me it bd ms mt oq mv mw mx or mz na jz os ka nc kc ot kd ne kf ou kg ng nh bi translated">2.向存根注册自定义请求处理程序</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/4bee9a0b17e30856386f53156cc72cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abwX2O_rZLThojGLqZzvFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦注册URLProtocols后的URLSession流程</p></figure><p id="40a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管苹果将URL加载系统的底层复杂性隐藏在<code class="fe lv lw lx ly b">URLSession</code>之下，但仍然有钩子在需要时提供配置。当我们将<code class="fe lv lw lx ly b">URLProtocol</code>的子类注册到<code class="fe lv lw lx ly b">URLSession</code>实例的配置中时，它赋予我们拦截请求和响应的能力。</p><h2 id="e416" class="md me it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">URLProtocol</h2><p id="d289" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated"><code class="fe lv lw lx ly b">URLProtocol</code>是URL加载系统中最晦涩、最强大的部分。它是一个抽象类，有四个重要且强大的方法要实现:</p><ol class=""><li id="9a9a" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu ow of og oh bi translated"><code class="fe lv lw lx ly b">canInit(with:)</code></li></ol><p id="36d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">URLSession</code>检查已注册的协议，以确认在加载请求时是否可以处理该请求。已注册的协议以注册时的相反顺序被查阅。</p><p id="f066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个用<code class="fe lv lw lx ly b">canInit(with:)</code>函数响应<code class="fe lv lw lx ly b">true</code>的协议将处理请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="dd1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<code class="fe lv lw lx ly b">canonicalRequest(for:)</code></p><p id="5487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要，我们可以在这里更改请求。</p><p id="c371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由每个具体的协议实现来定义规范的含义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe lv lw lx ly b">startLoading()</code></p><p id="67d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是返回存根响应的最重要的方法。它有<code class="fe lv lw lx ly b">URLProtocolClient</code>的实例，用于与URL加载系统通信。</p><p id="5727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要在你的应用程序中实现<code class="fe lv lw lx ly b">URLProtocolClient</code>协议。相反，你的<code class="fe lv lw lx ly b">URLProtocol</code>子类在它自己的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlprotocol/1413722-client" rel="noopener ugc nofollow" target="_blank">client</a></code>属性上调用这个协议的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="3236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<code class="fe lv lw lx ly b">stopLoading()</code></p><p id="e032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当调用此方法时，协议实现应该结束加载请求的工作。这可能是对取消操作的响应，因此协议实现必须能够在加载过程中处理该调用。</p><p id="8607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法在<code class="fe lv lw lx ly b">URLProtocol</code>的子类中是必需的，但是不需要做任何事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/9644536342bbdbc674cd1afb6b8613f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bu1u4lQWJygatYA6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ben_neale?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本·尼尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="2ace" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.示例项目</h1><p id="164b" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">为了演示如何用一个易于扩展和测试的网络层实现这个流，我针对RESTful API服务构建了一个示例项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/749dcf55e3c99a3952a6b8c449a497ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5ZEegqjv9GCvENZ9m_prA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自杨梦的应用程序和单元测试的不同网络实例</p></figure><h2 id="c35e" class="md me it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">网络协议</h2><p id="c858" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">因为我们是围绕着阻止网络响应来构建项目的，所以我将从网络级别开始。</p><p id="75e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次我们想出一个新的对象，从协议开始是一个好主意。您将看到这样做允许您编写高度可测试、灵活和集中的代码。</p><p id="cc50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为网络编写一个协议定义，有以下三个目标:</p><ul class=""><li id="cda3" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">联网可以提供<code class="fe lv lw lx ly b">URLSession</code>的定制实例。</li><li id="ee99" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">网络接受端点的请求，用指定的实例<code class="fe lv lw lx ly b">URLSession</code>执行它，并在所需的全局调度队列中返回响应。</li><li id="8895" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">网络可以将数据解码成适当的模型。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="a1a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过实现<code class="fe lv lw lx ly b">Networking</code>协议的扩展，我们有了默认的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="73fb" class="md me it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">应用程序的默认联网</h2><p id="598d" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">现在，我们可以让<code class="fe lv lw lx ly b">DefaultNetworking</code>在应用程序中正常使用服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="dee7" class="md me it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">单元测试的模拟网络</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="65d8" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">我们从<code class="fe lv lw lx ly b">URLSessionConfiguration</code>中得到短暂的配置。</li><li id="ff10" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">然后我们用临时配置注册<code class="fe lv lw lx ly b">MockURLProtocol</code>。</li><li id="0489" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">我们为模拟网络生成自定义实例<code class="fe lv lw lx ly b">URLSession</code>。</li></ul><h2 id="8cd5" class="md me it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">MockURLProtocol采用URLProtocol</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="8a6c" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">我们采用<code class="fe lv lw lx ly b">URLProtocol</code>作为子类<code class="fe lv lw lx ly b">MockURLProtocol</code>。</li><li id="42ab" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">有两个属性，一个用于设置存根错误，另一个用于存根响应。</li><li id="6994" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">我们实现方法来处理请求并返回存根响应。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/cbdbaf36e3ddbc778d99fd3403df62a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kh0j6RZhdaR2ruB5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·托尔卡西奥在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="5745" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.具有存根响应的单元测试</h1><p id="a15f" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">哇哦，我们现在可以为我们的单元测试存根响应了！</p><p id="12ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，将示例响应作为JSON添加，并将编码的数据传递给请求处理程序。使用<code class="fe lv lw lx ly b">MockNetworking</code>发出服务请求，并享受存根响应！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/f833d13a8fb915a430204aa51b6dd426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5TdZoIxvfRufpMW9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@satyanto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hafidh Satyanto </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="a921" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="2657" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">这篇文章描述了我们如何通过用<code class="fe lv lw lx ly b">URLSession</code>配置注册<code class="fe lv lw lx ly b">URLProtocol</code>的子类来存根响应。<code class="fe lv lw lx ly b">URLProtocol</code>在这里起着关键作用。它的工作原理类似于苹果授权的中间人攻击。</p><p id="9b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在不改变请求加载方式的情况下，我们可以利用<code class="fe lv lw lx ly b">URLProtocol</code>挖掘很多潜力。</p><p id="80ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，请在评论中留下您可能有的任何问题。</p><p id="8c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面提到的所有代码都可以在这个<a class="ae ky" href="https://gist.github.com/ericleiyang/29af1a526d8668a51b8d69a0ae8d15ec" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。</p></div></div>    
</body>
</html>