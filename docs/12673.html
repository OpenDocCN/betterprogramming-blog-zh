<html>
<head>
<title>MySQL’s RedoLog and BinLog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL的RedoLog和BinLog</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mysqls-redolog-and-binlog-1a35bc052489?source=collection_archive---------6-----------------------#2022-06-21">https://betterprogramming.pub/mysqls-redolog-and-binlog-1a35bc052489?source=collection_archive---------6-----------------------#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2023" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">MySQL BinLog的详细信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/966550299d8c47b91fe6bcd18257b25c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y_UizBUHYxzCfD-E"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@workperch?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">工位</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="2f09" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">重做日志</strong></h1><p id="3a7c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们知道，当MySQL写数据时，它可能会追加数据或定位一个已经存在的数据进行修改。</p><p id="c69e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于从磁盘随机读取和写入，这很慢，无法满足高io操作的情况。</p><p id="83d1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了提高写效率，我们可以先写到内存，空闲时再写到磁盘。</p><p id="b975" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但这就产生了一个问题:内存中的数据不是持久的，所以如果停电，数据就会丢失？</p><p id="780f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了解决数据丢失问题，MySQL引入了重做日志来解决这个问题。</p><p id="b9d8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这被称为WAL(预写日志记录)，这是针对非内存数据库提高IO效率的一种常见做法。</p><p id="4d0c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这使得在发生崩溃时依靠日志记录来恢复数据成为可能，从而确保数据的持久性。</p><h1 id="331b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak"> <em class="ms">预写日志</em> </strong></h1><p id="0751" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一种高效的数据库日志记录算法。对于非内存数据库，磁盘I/O操作是数据库效率的主要瓶颈。</p><p id="1275" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在数据量相同的情况下，使用WAL日志记录的数据库系统在事务提交时的磁盘写操作只有传统回滚日志记录的一半左右，大大提高了数据库磁盘I/O操作的效率，从而提高了数据库性能。</p><p id="acc3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">沃尔玛的优势</strong></p><ul class=""><li id="241f" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm my mz na nb bi translated">读取和写入可以完全并发执行，而不会相互阻塞(但是写入仍然不是相互并发的)。</li><li id="4b19" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">WAL在大多数情况下性能更好(因为每次写入不需要写两个文件)。</li><li id="51c1" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">磁盘I/O行为更加可预测。</li><li id="6f40" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">使用更少的<code class="fe nh ni nj nk b">fsync()</code>操作，减少系统脆弱性问题。</li></ul><h2 id="5feb" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated"><strong class="ak">重做日志实现</strong></h2><p id="16e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们来看看MySQL到底是怎么做到的。</p><p id="6e93" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当需要更新记录时，InnoDB引擎首先写入记录<code class="fe nh ni nj nk b">redo log</code>并更新内存。在适当的时候，比如当磁盘空闲时，<code class="fe nh ni nj nk b">redo log</code>中的数据会被刷新到磁盘。</p><p id="8e5f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在InnoDB引擎中<code class="fe nh ni nj nk b">redo log</code>的大小是固定的，例如，它可以配置为一组四个文件，每个文件的大小为1GB，因此总共可以记录4GB的操作。</p><p id="c11e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nh ni nj nk b">write pos</code>是记录的当前位置，写入时移动，<code class="fe nh ni nj nk b">checkpoint</code>标记要擦除的当前位置，记录被擦除前更新到数据文件。</p><p id="8e10" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nh ni nj nk b">checkpoint</code>标记要擦除的当前位置，记录在被擦除前被更新到数据文件，擦除时再次向一个方向移动。</p><p id="5fb3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果write pos写完最后一个文件，它将移动到<code class="fe nh ni nj nk b">ib-log-file-0</code>并再次开始写。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/7bb60bc00161b134959b8d17ad4d7500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1_H87_2LL2PctRDY4P3pw.png"/></div></div></figure><p id="017b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果<code class="fe nh ni nj nk b">write pos</code>追上<code class="fe nh ni nj nk b">check point</code>，<code class="fe nh ni nj nk b">redo log</code>已满，那么你不能执行新的更新，你必须在<code class="fe nh ni nj nk b">check point</code>前进之前停止并擦除一些数据并将数据同步到磁盘。</p><h2 id="46d2" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">如何查看重做日志参数？</h2><p id="7d57" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">每个InnoDB存储引擎至少有一个重做日志文件组，每个文件组至少有两个重做日志文件，默认为<code class="fe nh ni nj nk b">ib-log-file-0</code>和<code class="fe nh ni nj nk b">ib-log-file-1</code>。</p><pre class="kj kk kl km gt ny nk nz oa aw ob bi"><span id="36a4" class="nl la it nk b gy oc od l oe of">show variables like '%innodb_log%';</span></pre><h2 id="40fa" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated"><strong class="ak"> Bin-Log </strong></h2><p id="86ef" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nh ni nj nk b">redo log</code>是特定于InnoDB引擎的，可以保证数据的安全，但是其他引擎是如何记录数据的呢？</p><p id="091d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在服务器级别，MySQL有自己的日志，那就是<code class="fe nh ni nj nk b">bin-log</code>(一个存档的日志)。你必须孤立地看待MySQL。MySQL =服务器+不同的数据存储引擎，不是一个整体。</p><p id="0c94" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Binlog记录对MySQL数据库表结构和表数据的所有更改的二进制日志，但不记录select和show查询。<code class="fe nh ni nj nk b">bin-log</code>日志记录为事件，包括语句消耗的时间。</p><p id="ec56" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">打开Binlog日志记录的两个最重要的场景如下:</p><ul class=""><li id="930a" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm my mz na nb bi translated">父子复制:在一级库中启用Binlog功能，使一级库可以将Binlog传递给二级库，二级库可以获取Binlog并实现数据恢复，达到主从数据一致性。</li><li id="5500" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">数据恢复:通过<code class="fe nh ni nj nk b">mysqlbinlog</code>等工具恢复数据。</li></ul><p id="2876" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Bin-log文件有三种记录方式:<code class="fe nh ni nj nk b">statement</code>、<code class="fe nh ni nj nk b">row</code>和<code class="fe nh ni nj nk b">mixed</code>，通常使用<code class="fe nh ni nj nk b">row</code>方式。</p><h2 id="43e6" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated"><strong class="ak"> <em class="ms">为什么有两个日志？</em> </strong></h2><p id="aac3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">MySQL一开始没有InnoDB引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有处理崩溃恢复数据的能力，而且<code class="fe nh ni nj nk b">bin-log</code>日志只能用于存档。</p><p id="667d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">InnoDB是后来作为插件加入的，所以它实现了自己的日志系统来保护数据和应对崩溃恢复。</p><h2 id="e9b8" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated"><strong class="ak"><em class="ms">bin日志和重做日志的区别。</em> </strong></h2><p id="30e6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这里，我总结了五个要点:</p><ul class=""><li id="6268" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm my mz na nb bi translated">内容是不同的:<code class="fe nh ni nj nk b">redo log</code>是物理日志，内容基于磁盘上的页面，<code class="fe nh ni nj nk b">bin-log</code>内容是二进制的，取决于binlog_format参数，可能基于SQL语句、数据本身或两者的混合。</li><li id="1132" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">不同级别:<code class="fe nh ni nj nk b">redo log</code>与InnoDB和引擎一起工作，<code class="fe nh ni nj nk b">bin-log</code>位于MySQL服务器级别，可用于所有引擎。</li><li id="6623" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">不同形式的磁盘存储:重做日志循环写入，<code class="fe nh ni nj nk b">bin-log</code>累积，因此可用于数据恢复或主从同步</li><li id="eb69" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">写入的时间是不同的:<code class="fe nh ni nj nk b">bin-log</code>通常在一个事务提交时写入，或者在N个事务提交一次时写入，<code class="fe nh ni nj nk b">redo log</code>在不同的时间写入，或者在每次一个事务提交时写入，或者由另一个线程事务写入，或者在磁盘刷新时每秒写入。(<strong class="lt iu">注</strong>:在<code class="fe nh ni nj nk b">redo log</code>中未提交的事务也可能被刷新到磁盘)</li><li id="5ff6" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">角色不同:重做日志用于崩溃恢复，保证MySQL宕机不影响持久性；<code class="fe nh ni nj nk b">bin-log</code>用于时间点恢复，确保服务器可以根据时间点恢复数据，此外<code class="fe nh ni nj nk b">bin-log</code>还用于主从复制。</li></ul><h2 id="32b0" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated"><strong class="ak"> <em class="ms">两阶段提交</em> </strong></h2><p id="e937" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为<code class="fe nh ni nj nk b">redo-log</code>在InnoDB层，而<code class="fe nh ni nj nk b">bin-log</code>在服务器层，这就引入了一个新问题。</p><p id="903b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果重做日志写入成功，并且<code class="fe nh ni nj nk b">bin-log</code>在写入磁盘之前崩溃，则事务尚未提交，因此写入<code class="fe nh ni nj nk b">redo-log</code>的新数据无效。</p><p id="a1f5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">重启数据库进行数据恢复会将<code class="fe nh ni nj nk b">redo-log</code>中的数据恢复到磁盘上，这会产生无效数据。</p><p id="ac6b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如您所知，在这种情况下，引入了两阶段提交。</p><p id="10de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第一阶段，<code class="fe nh ni nj nk b">redo-log</code>被写入并处于准备状态。服务器层保存<code class="fe nh ni nj nk b">bin-log</code>数据并放到磁盘后，事务同时提交<code class="fe nh ni nj nk b">redo-log</code>，使得<code class="fe nh ni nj nk b">redo-log</code>被提交，保证了<code class="fe nh ni nj nk b">redo-log</code>数据和<code class="fe nh ni nj nk b">bin-log</code>数据的一致性。</p><h1 id="9f6b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Update语句的执行</h1><p id="94e4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有了前面的知识，现在可以探究一下<code class="fe nh ni nj nk b">update</code>语句在MySQL中是如何执行的了。</p><p id="47c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们现在执行SQL : <code class="fe nh ni nj nk b">update table_test set a = a+1 where id = 2;</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/ef79721616c21139bf993f94dd51d790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGYm1hO7BIYNntb-lL5G-Q.png"/></div></div></figure><ul class=""><li id="7f7d" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm my mz na nb bi translated">首先，客户端通过连接器连接并确定权限。</li><li id="52a4" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">验证之后，SQL通过语法分析器进行词法和语法分析(AST ),如果是更新语句，MySQL将清空查询表<code class="fe nh ni nj nk b">table_test</code>的所有查询缓存。(如您所见，不建议打开查询缓存)</li><li id="1d4d" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">优化器优化经验证的SQL，计划匹配<code class="fe nh ni nj nk b">id</code>索引，并生成执行计划。</li><li id="1413" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">执行器得到最终的SQL，调用相应存储引擎的接口开始执行<code class="fe nh ni nj nk b">update</code> SQL。</li><li id="7829" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">InnoDB引擎打开一个事务，执行引擎首先从内存中查询是否存在带有<code class="fe nh ni nj nk b">id=2</code>的数据，如果与相应的带有<code class="fe nh ni nj nk b">field+1</code>的数据匹配，然后将其保存到内存中。如果它没有用<code class="fe nh ni nj nk b">id=2</code>查询数据，那么它将转到磁盘，查询将以页为单位将数据读入内存，然后更新并保存到内存中。</li><li id="0b34" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">InnoDB引擎然后将数据行保存到<code class="fe nh ni nj nk b">redo-log</code>，这是预先提交的，通知服务器的执行器它准备好提交事务。</li><li id="236d" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">执行器会生成相应的<code class="fe nh ni nj nk b">bin-log</code>并写入磁盘。</li><li id="ad45" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">提交事务，然后提交<code class="fe nh ni nj nk b">redo-log</code>。</li><li id="e15a" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">这是事务执行完成的地方。</li></ul></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="6c0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="oo">感谢您阅读本文。</em></p><p id="22b9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="oo">敬请期待更多。</em></p></div></div>    
</body>
</html>