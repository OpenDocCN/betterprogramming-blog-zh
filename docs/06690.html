<html>
<head>
<title>Gradle Dependency Management With BuildSrc and Kotlin DSL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BuildSrc和Kotlin DSL进行梯度依赖管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/gradle-dependency-management-with-buildsrc-and-kotlin-dsl-1de958eab166?source=collection_archive---------5-----------------------#2020-10-26">https://betterprogramming.pub/gradle-dependency-management-with-buildsrc-and-kotlin-dsl-1de958eab166?source=collection_archive---------5-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="39ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在多模块项目中实现依赖关系的好方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0dc5fd390785e99004eba17ae11962a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKNUGwUmBjukpnTrHCeGJA.png"/></div></div></figure><h1 id="d1d7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">从文章中摘录</h1><p id="4be4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">它主要关注于使用<code class="fe mi mj mk ml b">buildSrc</code>目录和Kotlin DSL脚本构建一个梯度依赖管理系统。您还将了解到这样做相对于使用传统Groovy代码的优势。</p><p id="8122" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">如果你喜欢看这个博客的视频，YouTube的视频会在文章的结尾嵌入。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="bfa5" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">问题</h1><p id="2464" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">众所周知，在快速增长的项目中维护依赖关系是一项单调乏味的工作。传统的Groovy脚本没有代码导航、自动完成、性能问题和运行时错误，这让情况变得更糟。</p><p id="77c9" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">最重要的是，绝大多数android开发人员在使用Groovy时不知道他们在写什么。在我职业生涯的早期，我甚至不知道在使用Groovy时做了什么。</p><p id="94f7" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">感谢Gradle团队和社区努力提供一个平稳和安全的构建过程。他们提出的最好的解决方案之一是使用带有Kotlin DSL脚本的<code class="fe mi mj mk ml b">buildSrc</code>目录。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="4338" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">解决办法</h1><p id="38b4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">库实现和定制任务不应该存在于构建脚本中。它们应该在单独的文件中声明，以便在构建脚本中使用。在这个实现的早期阶段，开发人员通常创建一个Gradle文件来声明所有的库，并在构建脚本中使用它们。</p><p id="b260" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">的确，这在一定程度上解决了问题。你可以在这篇<a class="ae nd" href="https://medium.com/@sgkantamani/next-level-of-dependencies-declaration-with-kotlin-dsl-scripits-48bfe1cb1f10" rel="noopener">文章</a>中读到。但是这种快速的解决方案没有解决像自动完成和代码导航这样的问题，从长远来看，这是一种不可靠的解决方案。在这次失败之后，<code class="fe mi mj mk ml b">buildSrc</code>似乎是一个有希望的解决方案。</p><blockquote class="ne nf ng"><p id="0109" class="lm ln nh lo b lp mm ju lr ls mn jx lu ni mo lx ly nj mp mb mc nk mq mf mg mh im bi translated">目录<code class="fe mi mj mk ml b">buildSrc</code>被视为<a class="ae nd" href="https://docs.gradle.org/current/userguide/composite_builds.html#composite_build_intro" rel="noopener ugc nofollow" target="_blank">包含的构建</a>。发现目录后，Gradle会自动编译和测试这段代码，并将其放入构建脚本的类路径中。多项目构建只能有一个<code class="fe mi mj mk ml b">buildSrc</code>目录，它必须位于根项目目录中。<code class="fe mi mj mk ml b">buildSrc</code>应该优先于<a class="ae nd" href="https://docs.gradle.org/current/userguide/plugins.html#sec:script_plugins" rel="noopener ugc nofollow" target="_blank">脚本插件</a>，因为它更容易维护、重构和测试代码。<br/> —格拉德团队</p></blockquote><p id="0a1f" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">使用<code class="fe mi mj mk ml b">buildSrc</code>和Kotlin DSL脚本不仅解决了构建脚本中的问题，还带来了增强的IDE支持、代码导航、编译时错误等等。最重要的是，我们不再需要使用Groovy了。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="7547" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">创建buildSrc目录</h1><p id="6ed6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们需要做的第一件事是创建一个buildSrc目录:</p><ul class=""><li id="7a3e" class="nl nm it lo b lp mm ls mn lv nn lz no md np mh nq nr ns nt bi translated">右键单击该项目。</li><li id="d39f" class="nl nm it lo b lp nu ls nv lv nw lz nx md ny mh nq nr ns nt bi translated">点击新建并选择目录。</li><li id="027c" class="nl nm it lo b lp nu ls nv lv nw lz nx md ny mh nq nr ns nt bi translated">现在命名为<code class="fe mi mj mk ml b">buildSrc</code>。</li></ul><p id="846c" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">如果您对如何创建目录还有任何疑问，请查看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/8317fa9d3f2353d812bf0a58fbd0ede7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rDhflrwxcwwr4mcefTrQEg.gif"/></div></div></figure><p id="ecb0" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">然后我们需要在<code class="fe mi mj mk ml b">buildSrc</code>目录下创建一个名为<code class="fe mi mj mk ml b">build.gradle.kts</code>的文件。在这个文件中，我们需要导入<code class="fe mi mj mk ml b">kotlin-dsl</code>插件和<code class="fe mi mj mk ml b">jcenter </code>库。说到语法，它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e069" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">一旦你完成了，按下gradle的“现在同步”按钮，因为Gradle认为这只是一个新目录中的普通文件。耶！现在您可以实现Kotlin Dsl脚本了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a8821ad51d3b8576eb903042564b3ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*L1zYKShhvKrrgTyn07S3aw.png"/></div></figure><p id="c20a" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">下一步是创建一个类似的目录结构，即src &gt; main &gt; java。一旦我们这样做了，它看起来如上图所示。</p><p id="39f4" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">现在，我们可以创建Kotlin文件来声明库、维护版本或实现定制任务。</p><p id="946e" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这里我们的目标是创建一个依赖管理系统，所以我们创建了一个名为<code class="fe mi mj mk ml b">Dependencies.kt</code>的Kotlin文件(您可以使用任何名称)。</p><p id="e8d4" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">一旦我们完成了这些，我们就可以用Kotlin代码声明库和版本了。这里我们使用对象来声明特定的类型，比如版本、AndroidX库等等。</p><p id="7c95" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">首先，我们需要创建一个versions对象，并以Kotlin风格声明所有库的版本。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="od oe gj gh gi of og bd b be z dk translated">对象来存储所有依赖项的版本</p></figure><p id="4ac1" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">一旦我们完成了这些，下一步就是为每个库类型创建单独的对象，比如Kotlinlibraries、AndroidXLibraries、UiLibraries等。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="od oe gj gh gi of og bd b be z dk translated">库声明</p></figure><p id="b966" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">当我们把所有的部分放在一起时，它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="cdde" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">最后一步是在项目、应用程序和模块级build.gradle文件中使用这些依赖对象。这很简单。我们需要使用特定的对象名和变量名。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="8b90" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这种方法看起来很简单，但是它提供了更多的优势，比如代码导航、自动完成、运行时错误等等。看下面的gif。除此之外，我们可以在项目的所有模块中使用它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/d75a4c4bb32986c6a2c75b752d2ff3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OrkYFsy3hMCiT02YORpSOg.gif"/></div></div><p class="od oe gj gh gi of og bd b be z dk translated">gradle文件中的自动完成、代码导航和编译时错误</p></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="ba64" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">我们可以做得更多</h1><p id="b722" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">到目前为止，我们已经实现了与依赖项相关的所有东西，但是我们当然可以在构建脚本中做更多的事情，比如替换<code class="fe mi mj mk ml b">defaultConfig</code>块。一般来说，它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="328d" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">正如我所说的，将常量从构建脚本中移走总是安全的。所以我们可以在<code class="fe mi mj mk ml b">buildSrc</code>下创建另一个Kotlin文件，或者在依赖文件中创建一个新对象。然后像min一样声明所有常量，编译SDK版本等等。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="591b" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">现在，我们可以在<code class="fe mi mj mk ml b">defaultConfig</code>块中使用这个对象。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="2284" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">假设您的项目有任何<code class="fe mi mj mk ml b">BuildConfig</code>级别的字符串或常量来维护敏感的键和东西。在这种情况下，您可以创建一个单独的文件并单独保存它们，而不是将构建脚本弄得一团糟。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="2c7a" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">奖金</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi ob l"/></div><p class="od oe gj gh gi of og bd b be z dk translated">视频格式</p></figure><p id="7d2f" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">要了解有关实现更好的依赖项管理和构建脚本的最佳实践的更多信息，请阅读以下文章:</p><ul class=""><li id="c287" class="nl nm it lo b lp mm ls mn lv nn lz no md np mh nq nr ns nt bi translated"><a class="ae nd" href="https://medium.com/@sgkantamani/next-level-of-dependencies-declaration-with-kotlin-dsl-scripits-48bfe1cb1f10" rel="noopener">“使用Kotlin DSL脚本的下一级依赖关系声明</a></li><li id="6f58" class="nl nm it lo b lp nu ls nv lv nw lz nx md ny mh nq nr ns nt bi translated"><a class="ae nd" href="https://medium.com/better-programming/exploring-kotlin-dsl-4ab67ed13062" rel="noopener">“探索kot Lin DSL”</a></li></ul><p id="7dc7" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">要了解更多关于Kotlin &amp; coroutines和Kotlin的其他高级特性，请阅读以下文章:</p><ul class=""><li id="e058" class="nl nm it lo b lp mm ls mn lv nn lz no md np mh nq nr ns nt bi translated"><a class="ae nd" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">“使用Kotlin进行高级编程</a>”</li><li id="a47d" class="nl nm it lo b lp nu ls nv lv nw lz nx md ny mh nq nr ns nt bi translated"><a class="ae nd" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">“使用Kotlin进行高级编程—第2部分</a>”</li><li id="7b2a" class="nl nm it lo b lp nu ls nv lv nw lz nx md ny mh nq nr ns nt bi translated"><a class="ae nd" href="https://medium.com/better-programming/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006" rel="noopener">“科特林协程，从基础到高级</a></li><li id="ee49" class="nl nm it lo b lp nu ls nv lv nw lz nx md ny mh nq nr ns nt bi translated"><a class="ae nd" href="https://medium.com/better-programming/how-to-use-kotlin-sealed-classes-for-state-management-c1cfb81abc6a" rel="noopener">“如何使用Kotlin密封类进行状态管理”</a></li><li id="bf8c" class="nl nm it lo b lp nu ls nv lv nw lz nx md ny mh nq nr ns nt bi translated"><a class="ae nd" href="https://medium.com/better-programming/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b" rel="noopener">“使用新Kotlin流异步加载数据</a></li><li id="361e" class="nl nm it lo b lp nu ls nv lv nw lz nx md ny mh nq nr ns nt bi translated"><a class="ae nd" href="https://medium.com/better-programming/why-and-how-to-use-kotlins-native-serialization-library-c88c0f14f93d" rel="noopener">“为什么以及如何使用Kotlin的原生序列化库</a>”</li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="ca18" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">目前就这些。希望你学到了有用的东西，感谢阅读。</p></div></div>    
</body>
</html>