# 如何不在 30 天内建立一个实时多人游戏

> 原文：<https://betterprogramming.pub/how-not-to-build-a-real-time-multiplayer-game-in-30-days-2bd6d1571040>

## 在下一次黑客马拉松中获得更多的技巧

![](img/e5e59ffd220b18d861e4fc824e231086.png)

由 gstudioimagen 在 [Freepik](http://www.freepik.com) 创建

不久前，我参加了 Itch.io 的[游戏 Off 2020](https://itch.io/jam/game-off-2020) ，这是一个年度游戏盛会，参与者在 11 月份根据某个主题开发一个游戏。今年的主题 Moonshot 催生了超过 500 款雄心勃勃、以太空为主题的游戏，你可以在这里查看。

10 月份一听说这个活动，我就把它告诉了我的哥哥和嫂子，我们决定组成一个团队。我们绝不是游戏开发人员，但是我们的个人技能很好地互补了。我的嫂子是一名艺术家，她将专注于为游戏创造资源。与此同时，我的哥哥，一个动画师变成了程序员，而我，一个程序员，将专注于开发游戏。

主题一宣布，我们立即开始头脑风暴，想出一个主意，本着 game jam 主题的精神，这个主意将是有趣的，雄心勃勃的，最好是以太空为主题的。

我们想出了一大堆，但真正让我们兴奋地点头同意的是**Bad as tronauts**。其前提如下:

> Bad Asstronauts 是一款快节奏的多人手机游戏，玩家乘坐武器化的宇宙飞船在宇宙中搜寻有价值的资源，并将其储藏在自己的星球上。与此同时，玩家还必须保护他们的藏物不被拾荒的对手发现。

最初，我为这篇文章选择的标题是“在 30 天内构建一个实时多人游戏”。鉴于我们仍在构建自己的项目，我想与你分享一些我们在这 30 天里学到的关于在时间限制下构建软件项目的经验。

# 理解项目的需求

在决定了我们想要构建什么样的游戏之后，我们问自己的下一个问题自然是使用哪些技术。由于我们正在构建一个多人游戏，这个决定必须在前端和后端各做一次。

没有什么特别的原因，我们决定尝试使用 [Flame](https://flame-engine.org/) ，一个极简的 2D 游戏引擎来构建前端的 Flutter。对于我们心目中的游戏来说，这似乎是一个不错的选择。然而，后端将被证明更加棘手。众所周知，在线多人游戏很难构建，我们想要实现的实时组件只会增加复杂性。

我们的第一个方法是尝试 Firebase，考虑到它在 Flutter 社区的受欢迎程度，它在游戏上的[看起来](https://firebase.google.com/games)的可行性，以及一个朋友的推荐。所以我们开始构建一个小型的概念验证来测试所有这些。

![](img/08e081ffe74f31b2c4919dae09054044.png)

使用 WebSockets 进行数据同步测试

# 不要忘记主要任务

可悲的是，本应是几天的任务却持续到了 11 月中旬。虽然让 Firebase 运行起来并不容易，但主要的时间消耗在其他事情上:分散注意力。

你在上面的 gif 中看到的花了我们几天的时间来实现。从这一点上，我们立即了解到 Firebase 的无服务器方法与[云功能](https://firebase.google.com/docs/functions/get-started)和 [Firestore](https://firebase.google.com/docs/firestore) (其两个云数据库选项之一)，虽然在许多场景中有用，但无法满足我们预想的游戏的实时要求。

太糟糕了，我们没有立即建立你在上面看到的东西，而是试图制作一个迷你游戏，让两个玩家竞争，看谁能在计时器超时前获得最多的点击量而不错过盒子。这包括实现完全不必要的功能，如计时器、分数和颜色，所有这些在实际发现 Firebase 是否可行时都没有用。

我们很快就过渡到了 WebSockets，但是花在那些不相关的功能上的时间已经没有了。

我们在这里的错误是忽略了主要目标，没有更快地问自己所有这些是如何帮助我们实现它的。所以，尽量做到一心一意，目标驱动。铃铛和哨子总是可以在以后添加的。

# 不要在研究上吝啬

这并不是说前端的事情进展顺利。与 Firebase 在后端为您做大量繁重工作的方式相同，使用游戏引擎可以通过提供许多开箱即用的工具让您立即投入工作:游戏循环、对象渲染、物理——不胜枚举。当然，前提是你使用这些工具。

虽然我们确实使用了 Flame 提供的许多工具，但我们最终还是自己实现了许多其他工具。不是因为 Flame 自己对它们的实现不充分，而是因为我们不知道它们的存在！

在我们急于开始的时候，我们匆匆度过了最重要的阶段——研究阶段。结果，我们从零开始构建了许多组件，而我们并不知道，它们只是一个`import`声明。

这方面的一个主要例子是操纵杆，Flame 有一个非常好的模块。相反，我们做了自己的，不要误会，这是很好的练习，但可能不是在紧张的时间表中最好的利用时间。

我们用一些其他组件又做了几次，很快就清楚了，当你重新发明轮子时，通常你最后得到的是一个[方形](https://exceptionnotfound.net/reinventing-the-square-wheel-the-daily-software-anti-pattern/)。

我们仓促的解决方案使得这个项目很难进行和扩展(如果你只做了几个星期，这真的说明了一些问题！).这促使我们后退一步，重做我们已经拥有的东西，但这一次尽可能多地使用游戏引擎提供的东西。

这一重建当然花费了一些时间来实现新的特性(大约几天)，但是一旦我们完成了它，我们就可以说我们正在以更快的速度前进。

这里要记住的是，现在即使是几分钟的研究也可以为你节省几个小时不必要的工作。

# 了解您的工具

与此相关的是，找到一个高效的工作流对于快速开发特性和原型是至关重要的。阻碍我们进展的一个主要因素是，我们需要在多个客户端上测试我们的代码，以确保网络功能按预期工作。

这需要我们启动多个 Android 模拟器，正如任何使用过它们的人都知道的那样，它们是内存饥渴的小动物，甚至会让像样的机器喘不过气来。

然而，由于缺乏更好的计划，我们忍受了——即使字符会出现在代码编辑器中，就好像我们是从另一个星球键入的。然而，有一个更好的方法。

与世界分享我的喜悦

作为一个跨平台的工具包，Flutter 允许应用程序从用于移动设备的相同代码基础上为网络而[构建。从本质上说，这对我们来说意味着我们可以完全绕过模拟器，直接从浏览器运行多个客户端，大大降低了内存成本。](https://flutter.dev/docs/get-started/web)

只是，我们碰巧在很久以后才有了这个重大发现，而且在大多数情况下，每当需要在多个客户机上运行测试时，我们都不得不忍受这种扼杀流量的状态。

现在，我不是说你需要熟悉你正在使用的每个工具的每个角落，但这可能是少数不满足而不是耐心是一种美德的情况之一。当你开始怀疑是否有更好的方法时，帮自己一个忙，检查一下。通常是有的，而且可能会有回报。

# 考虑分层方法

我们从一开始就做的事情之一是在给游戏添加新功能时采用分层方法。从这个意义上说，一个层只不过是一组功能，与下面层的功能相结合，构成了正在构建的任何东西的完整功能版本。

这样做的好处是，如果团队在任何时候发现无法在截止日期前完成当前图层的功能，它可以退回到之前的图层，并且仍然能够交付一个完整的工作项目。

例如，下面是我们在游戏开始时定义的层:

![](img/c7caabbb943dcc0e7ebe45ab45e83d85.png)

针对具有 7 层复杂性的不良资产的高级功能开发计划

这种偶然性背后的原因很简单。随着应用程序中功能数量的增加，复杂程度也在增加。如果任其发展，这种不断增加的复杂性可能会导致项目的发展失控，导致严重的延迟甚至取消。这就是所谓的“[特征蠕变](https://en.wikipedia.org/wiki/Feature_creep)”

在任何情况下，这都是我们希望从分层方法中得到的。然而，由于已经提到的各种原因，即使是第一层，即具有基础特征的那一层，也比允许的 30 天时限要多。

尽管如此，当正确应用并与这里提到的其他要点相结合时，这不应该降低它的功效。这就引出了我的最后一点。

# 不要贪多嚼不烂

如果目标从一开始就过于雄心勃勃，那么到目前为止提到的几点都不会有太大作用。我们都寻求超越自己，这是一个令人钦佩的品质，不应该被抛弃。然而，尽管我们的抱负可能是无限的，但支配我们追求这些抱负的资源——时间和精力却是无限的。

对于一个三人团队来说，开发任何游戏的经验都很有限，决定在 30 天内开发一个我们预想的规模和实时多人游戏功能的游戏，可能有点太难了。例如，一个更明智的策略是妥协，选择相对复杂的单人游戏或简单的多人游戏。

因此，在开始之前，对每个提议的想法做一点努力评估是确保开发过程顺利进行的关键。这将增加你在截止日期前交付你正在构建的任何东西的机会。

有了这个，继续建设！记住，完成比完美更好。