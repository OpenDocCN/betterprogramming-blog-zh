<html>
<head>
<title>Two Quick Examples That Show When to Use Concurrency in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两个简单的例子展示了在Go中何时使用并发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/two-quick-examples-that-show-when-to-use-concurrency-in-go-38920a9aa0e5?source=collection_archive---------6-----------------------#2022-09-30">https://betterprogramming.pub/two-quick-examples-that-show-when-to-use-concurrency-in-go-38920a9aa0e5?source=collection_archive---------6-----------------------#2022-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb90" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">并发编程快速回顾</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1d83f4da078586eeae0137ebb2aa0701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TxUC6nsr3nhDNoVY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@akin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿金·卡金纳</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并发性是编程中最常见和最重要的概念之一，目前已经变得越来越流行。这是一些编程语言自然支持的另一种资源(例如NodeJS、Go ),使其易于使用。并发性允许定义一组独立执行的任务(至少直到某个时刻)，这样它们就不会阻塞任何其他任务。</p><p id="e3e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过实现并发行为，程序可能会在性能、执行时间和资源利用方面表现出巨大的改进。</p><p id="bd9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，情况可能并不总是这样，正如我经常提到的，有些情况下，特定的技术并没有被设计来支持。我举了几个例子来说明并发性如何提高或降低程序的性能。这些例子是用Go编程语言构建的，Go编程语言本身支持并发性，但是希望它们易于理解，也适用于任何其他编程语言。</p><h1 id="fcc4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">示例#1:总和计算</h1><p id="8b5b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，让我向您介绍一个非常基本和简单的任务:将一个整数集合中的所有数字相加，计算出总数。这是一个很常见的任务，肯定可以用特定的数组库或类似的工具来解决。让我们首先使用无并发方法在Go中对其进行编码。这是我的版本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无并发的整数总和计算</p></figure><p id="617f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，对于它的并发版本，我使用一个工人池来容纳每个工人。一个worker代表一个将被并发运行的任务。这个程序期望的输入之一是<code class="fe mr ms mt mu b">workersNum</code>，它定义了将负责对原始集合的一个块求和的任务的数量。</p><p id="1ddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，如果<code class="fe mr ms mt mu b">workersNum=5</code>并且集合有十个整数，那么每个worker将对两个整数求和。还有一个额外的工作人员收集彼此的结果，并将它们相加得到总数。这种方法的代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用并发进行整数总和计算</p></figure><p id="e143" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为<code class="fe mr ms mt mu b">workersNum</code>尝试了不同的集合大小和不同的值。在收集了多个结果后，这些是我得到的平均值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/4985dfb96818f6a4905b085939ad6fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46Wgnn3rOzraKQbeFMbXEw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不同收集规模和工作人员数量的平均结果</p></figure><h1 id="3f9a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">例2:执行四个独立的任务</h1><p id="9718" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于这个例子，让我们假设我们有一个程序运行4个相互独立的任务。为了简单起见，假设任务是:将所有的数字相加，找到最大的数字，找到最小的数字并计算一组数字的平均值。使用无并发方法，我们将依次运行这些任务，一个接一个。这看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无并发情况下解决4个独立任务的代码</p></figure><p id="66cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，假设这些任务相互独立，我们可以利用并发性同时运行它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们可以同时运行这4个任务，假设它们之间互不依赖</p></figure><p id="8ae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这里我总是使用相同数量的工作线程，所以我只重复执行两个版本来收集足够的关于执行时间的数据。这些是我从每种方法的十次执行中得到的平均结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/6f7691d7aa23955a809a230964b87c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjTKhy_dj8G6FgO6ftK6qA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">每个版本10次执行的平均执行结果</p></figure><h1 id="1faf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="bae2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">从这些非常基本的实验中，我们可以得出一些关于并发使用的结论:</p><h2 id="3092" class="mx lt iq bd lu my mz dn ly na nb dp mc lf nc nd me lj ne nf mg ln ng nh mi ni bi translated">从实施例#1中</h2><p id="7e6d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于小型集合，单线程(无并发性)方法似乎比其他方法更快。这是因为每个工作者必须由编程语言来设置，这通常包括调用操作系统进程、分配内存以及同步它们中的每一个。</p><p id="0025" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个设置过程也消耗CPU时钟，由于要做的工作量很小，我们可以说它在设置上浪费的时间比运行任务本身要多。当集合的大小很大时，整个情况会发生变化，因为现在这样的集合是值得分块处理的。</p><p id="03bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们可以看到<code class="fe mr ms mt mu b">3</code>和<code class="fe mr ms mt mu b">5</code>似乎是<code class="fe mr ms mt mu b">numWorkers</code>更合理的值，因为使用它们，设置工作比使用<code class="fe mr ms mt mu b">10</code>花费的时间更少。</p><h2 id="c8e4" class="mx lt iq bd lu my mz dn ly na nb dp mc lf nc nd me lj ne nf mg ln ng nh mi ni bi translated">从实施例#2中</h2><p id="1cf5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">没什么好说的。假设所有的任务都是独立的，那么最好的方法就是同时运行它们。结果图不言自明:并发方法比单线程方法花费的时间少了将近50%。</p><p id="937d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试明智地使用并发。它作为一种非常现代和奇特的资源吸引了程序员的注意，但它可能并不适合您面临的所有情况。注意那些由许多可以独立运行的任务组成的任务，这些任务需要做大量的工作。对于依赖任务，您将会体验到使用并发性的局限性，而对于快速任务(比如对集合中的1000个数字求和)，使用并发性是没有意义的。</p><p id="15fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这篇文章对回顾一些并发概念以及何时使用这个强大的资源有足够的帮助！感谢您的阅读，并保持联系以获取更多信息！</p></div></div>    
</body>
</html>