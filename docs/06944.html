<html>
<head>
<title>Ktor in Server-Side Development — Databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端开发中的Ktor数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ktor-in-server-side-development-databases-b91a3bbe674f?source=collection_archive---------1-----------------------#2020-11-19">https://betterprogramming.pub/ktor-in-server-side-development-databases-b91a3bbe674f?source=collection_archive---------1-----------------------#2020-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bad6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Ktor的服务器端Kotlin</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5688ab441d598ff25e903360363e8cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxnuQSpAVkAK8gToFXEw-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="f1b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，您将学习如何在<a class="ae lu" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank"> Ktor </a>中使用路由实现数据库。之后，我们将在本地托管并测试它。然后，我们将使用Kotlin独有的特性(如扩展)优化代码，使其可扩展到大型项目。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e77b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Ktor是什么？</h1><p id="68ad" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">根据其官方网站<a class="ae lu" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank"/>，“Ktor是一个开源框架，使用强大的Kotlin编程语言在互联系统中构建异步服务器和客户端。”Ktor使用协程来执行异步操作，由<a class="ae lu" href="https://www.jetbrains.com/" rel="noopener ugc nofollow" target="_blank"> JetBrains </a>制作。</p><p id="7644" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用Ktor做的令人兴奋的事情之一是使用Kotlin编写web服务。如果你是Ktor新手，那么先看看<a class="ae lu" href="https://medium.com/better-programming/ktor-in-server-side-development-the-basics-81ce4bbba878" rel="noopener"> Ktor基础文章</a>。如果你想在移动平台上使用Ktor，它有一个Android专用的神器。你可以在这篇<a class="ae lu" href="https://medium.com/better-programming/how-to-use-ktor-in-your-android-app-a99f50cc9444" rel="noopener">文章</a>里了解一下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1066" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据库集成</h1><p id="ed39" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">首先，我们需要导入所有必要的依赖项。我们将使用<code class="fe mz na nb nc b">Exposed</code>来连接和执行H2内存数据库的SQL操作。我们需要在<code class="fe mz na nb nc b">build.gradle</code>中包含所需的依赖关系。转到<code class="fe mz na nb nc b">build.gradle</code>，在dependencies标签下添加以下几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c585" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模型和映射</h1><p id="08a6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">下一步是创建一个模型类——基本上是一个我们需要存储在数据库中的Kotlin数据类。在模型的包下创建一个名为<code class="fe mz na nb nc b">Posts</code>的新数据类。看一下数据类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="47f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后创建一个名为<code class="fe mz na nb nc b">dao</code>的新包，并创建一个名为<code class="fe mz na nb nc b">Posts.kt</code>的Kotlin文件，内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="89ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">Posts</code>是<code class="fe mz na nb nc b">Post</code>的映射对象。该对象将有三个字段:id(作为区分各行的主要字段)、title和description(每个字段都有文本限制)。该对象充当对象到表的关系映射。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="59d0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据访问层</h1><p id="435f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">这里我们不是直接访问数据库相关的操作，而是创建一个包含所有基本操作(CRUD操作)的接口。在<code class="fe mz na nb nc b">dao</code>包下新建一个文件，添加以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4b81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了一个包含所有函数的接口，可以用来执行CRUD操作。没有任何延迟，让我们通过创建<code class="fe mz na nb nc b">PostsDao</code>类在同一个文件中实现它们。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9100" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">PostsDao</code>期望<code class="fe mz na nb nc b">Database</code>实例作为参数。所有的数据库操作都需要在<code class="fe mz na nb nc b">Exposed</code>的事务中执行。因此，我们已经将所有查询语句与事务包装在一起。现在我们已经有了一个可以使用的全功能的DAO层。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="468a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用Ktor集成曝光</h1><p id="7bb7" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">最后，我们需要初始化Ktor应用程序中的<code class="fe mz na nb nc b">Exposed</code>T5。首先，我们需要通过传递H2内存数据库实例来创建<code class="fe mz na nb nc b">Dao</code>实例，然后调用<code class="fe mz na nb nc b">init()</code>函数。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="c331" class="nf md it bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">配置路线</h2><p id="3264" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在这一点上，我们拥有Dao和Ktor。剩下的事情就是创建不同的路由(GET、POST、PUT和DELETE)并调用它们各自的<code class="fe mz na nb nc b">dao</code>函数。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="5c2f" class="nr ns it la b lb lc le lf lh nt ll nu lp nv lt nw nx ny nz bi translated">GET:返回数据库中的所有帖子</li><li id="df5b" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">POST:接收<code class="fe mz na nb nc b">Posts</code> JSON并存储在数据库中</li><li id="fe4f" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">PUT:更新post记录。</li><li id="340c" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">删除:删除给定id的文章。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="71cf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代码优化</h1><p id="c467" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果你看到模块功能，路由块不适用于大型项目。最终，我们将在端点中添加更多的逻辑，这将导致无法维护的巨大路由块。</p><p id="7ef9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">克服这个问题的一个方法是利用Kotlin中扩展的功能来封装逻辑部分。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="79bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我喜欢科特林的原因。我们可以将代码分离出来，并充分利用它。现在让我们用之前创建的扩展替换所有端点的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="99ef" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试</h1><p id="645e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">一旦你完成了所有的步骤，我们必须测试我们创建的post REST API。首先，点击应用程序类中main函数旁边的run按钮。现在切换到终端面板，使用CURL命令测试服务。看看添加帖子的示例命令:</p><pre class="kj kk kl km gt of nc og oh aw oi bi"><span id="e5cd" class="nf md it nc b gy oj ok l ol om"><strong class="nc iu">curl</strong> --data "{/"title/":/"This is title string/",/"description/":/"This is decription string/"}" -H "Content-Type: application/json" --request POST <a class="ae lu" href="http://localhost:8080/addPost" rel="noopener ugc nofollow" target="_blank"><strong class="nc iu">http://localhost:8080/addPost</strong></a></span></pre><p id="4238" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读！</p></div></div>    
</body>
</html>