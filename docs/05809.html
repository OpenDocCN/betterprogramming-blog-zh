<html>
<head>
<title>Count Items in Python With the Help of Counter Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">借助计数器对象计算Python中的项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/count-items-in-python-with-the-help-of-counter-objects-c08d8d486e45?source=collection_archive---------5-----------------------#2020-08-07">https://betterprogramming.pub/count-items-in-python-with-the-help-of-counter-objects-c08d8d486e45?source=collection_archive---------5-----------------------#2020-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="915e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对数据容器中的对象进行计数的简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/924bf3615a48e3016814a4fa448daffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CJnsJ3Wz_C-1JOeL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@loic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Djim Loic </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="106a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">前提</h1><p id="7aed" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们在Python中处理数据容器(比如元组和列表)时，我们经常需要对特定的元素进行计数。一种常见的方法是使用<code class="fe mn mo mp mq b">count()</code>函数——指定要计数的元素，函数返回计数。</p><p id="77a8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">让我们来看看它的一些使用代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">count()函数</p></figure><p id="d07a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">正如您在上面看到的，我们使用了带有分数列表的<code class="fe mn mo mp mq b">count()</code>函数。</p><p id="539b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">需要注意的一点是:当函数中指定的元素没有包含在列表中时，我们将得到一个零计数，这是意料之中的。如果我们想计算所有元素的出现次数，我们必须迭代它们，如下面的代码片段所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计算所有元素</p></figure><p id="60e3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">上面有几件事值得强调:</p><ul class=""><li id="70b0" class="my mz it lt b lu mr lx ms ma na me nb mi nc mm nd ne nf ng bi translated">为了避免计算相同值的元素，我们使用<code class="fe mn mo mp mq b">set()</code>构造函数将这些iterables转换为set对象。这意味着删除了重复的元素for循环将只遍历不同的元素，以获得正确的累积计数。</li><li id="7fb6" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated"><code class="fe mn mo mp mq b">count()</code>函数不仅可以处理列表对象，还可以处理元组和字符串。更一般地说，<code class="fe mn mo mp mq b">count()</code>函数处理Python中的序列数据，包括字符串、列表、元组和字节。</li></ul><p id="f263" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如上所示，我们必须使用for循环来迭代元素，以检索每个单独元素的计数。有点繁琐。</p><p id="5a39" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">有没有另一个更好的方法来解决这个问题？如果你懂Python，你应该猜到答案是肯定的。<code class="fe mn mo mp mq b">Counter</code>类是专门为计算这些数据结构中的元素而设计的。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="df32" class="kz la it bd lb lc nt le lf lg nu li lj jz nv ka ll kc nw kd ln kf nx kg lp lq bi translated">计数器类-概述</h1><p id="9e85" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为Python标准库的一部分，可以通过<code class="fe mn mo mp mq b">collections</code>模块获得<code class="fe mn mo mp mq b">Counter</code>类。作为<code class="fe mn mo mp mq b">dict</code>类的子类，它提供了一些处理对象计数的高度专门化的方法。要创建计数器对象，只需将iterable设置为<code class="fe mn mo mp mq b">Counter</code>类实例构造函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计数器对象创建</p></figure><p id="2335" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">正如您在第七行看到的，一个<code class="fe mn mo mp mq b">Counter</code>对象看起来像一个包含一系列键值对的字典。具体来说，键是被计数的元素，而值是对应键的计数器。如果您想要检索单个项目的计数，您可以像使用字典一样进行操作。下面是一些简单的例子。值得注意的是，如果键不存在于<code class="fe mn mo mp mq b">Counter</code>对象中，计数将为零。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">访问单个项目</p></figure><p id="3a81" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">需要注意的一个关键点是，由于键值映射机制，只有可散列对象才能被<code class="fe mn mo mp mq b">Counter</code>对象跟踪。在Python中，不可变的对象，如字符串、整数和元组都是可散列的，而可变的对象，如列表、集合和字典是不可散列的。关于对象散列能力的详细讨论超出了本文的范围，如果您感兴趣，您可以在我的<a class="ae ky" href="https://medium.com/better-programming/3-essential-questions-about-hashable-in-python-33e981042bcb" rel="noopener">上一篇关于这个主题的文章</a>中找到更多信息。</p><p id="e810" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">下面的代码向您展示了一个简单的例子，当我们试图将<code class="fe mn mo mp mq b">Counter</code>与不可混淆的对象<em class="ny"> </em> <code class="fe mn mo mp mq b">lists</code>一起使用时。错误消息清楚地告诉我们Python不能为我们实例化一个<code class="fe mn mo mp mq b">Counter</code>对象，因为<code class="fe mn mo mp mq b">lists</code>在Python中是不可销毁的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不可洗柜台</p></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="f371" class="kz la it bd lb lc nt le lf lg nu li lj jz nv ka ll kc nw kd ln kf nx kg lp lq bi translated">确定最常见的项目</h1><p id="7e5f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通常，我们需要知道数据容器中频繁出现的项目(例如，列表和元组)是什么。在我们看到使用<code class="fe mn mo mp mq b">Counter</code>对象的解决方案之前，让我们看看如何使用一些繁琐的代码来实现这个功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非惯用的方式</p></figure><p id="3d8b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如上所示，我们首先需要使用list的<code class="fe mn mo mp mq b">count()</code>方法对列表中的每个唯一项进行计数，并将计数结果保存到字典中。接下来，我们必须使用内置的<code class="fe mn mo mp mq b">max()</code>函数，通过指定排序键来使用每个键-值对的值，从而对字典的条目进行排序。当然，这种方式可行，但不是惯用的方式，在这种情况下，我们应该考虑使用<code class="fe mn mo mp mq b">Counter</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最常见的项目</p></figure><p id="2098" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如上所示，您的第一印象应该是，与该功能的非惯用实现相比，代码有多简洁。这都是因为<code class="fe mn mo mp mq b">Counter</code>对象有一个方便的<code class="fe mn mo mp mq b">most_common()</code>方法，它可以快速获取我们需要的信息——最频繁出现的项目及其相关计数。实际上，为了给我们更多的灵活性，我们可以选择找出任意数量的最频繁出现的项目，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最常见的项目</p></figure><p id="dec9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">请注意，当您没有在<code class="fe mn mo mp mq b">most_common()</code>方法中指定任何数字时，所有的元素将作为一个列表按照计数的降序返回。这种降序非常有用，它允许我们检索计数最少的项目，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最不常用的项目</p></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="2910" class="nz la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">更新计数器对象</h2><p id="9e15" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">之前，我们看到<code class="fe mn mo mp mq b">Counter</code>对象用于计算列表中的元素。但是如果我们得到了另一个列表，并且想要更新原来的<code class="fe mn mo mp mq b">Counter</code>对象而不创建一个新的，该怎么办呢？</p><p id="466c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">一个可能的解决方案是利用一个<code class="fe mn mo mp mq b">Counter</code>对象，实现映射协议，这样我们就可以相应地更新每个键的值。值得注意的是，如果键不存在于原始的<code class="fe mn mo mp mq b">Counter</code>对象中，与内置的<code class="fe mn mo mp mq b">dict</code>数据类型不同，将不会引发<code class="fe mn mo mp mq b">KeyValue</code>异常，因为默认情况下，<code class="fe mn mo mp mq b">Counter</code>对象中缺少的键的值为<code class="fe mn mo mp mq b">0</code>，正如我们在访问单个项目时看到的那样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新计数器对象</p></figure><p id="0b22" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">有一种更优雅的方式来更新原始的<code class="fe mn mo mp mq b">Counter</code>对象——使用<code class="fe mn mo mp mq b">Counter</code>的<code class="fe mn mo mp mq b">update()</code>方法。不要将这个<code class="fe mn mo mp mq b">update()</code>方法与<code class="fe mn mo mp mq b"><em class="ny">dict’</em></code> s <code class="fe mn mo mp mq b">update()</code>方法混淆，后者更新匹配键的值。相反，<code class="fe mn mo mp mq b">Counter</code>的<code class="fe mn mo mp mq b">update()</code>方法将在内部生成项目的计数，并使用这些计数来更新原始的<code class="fe mn mo mp mq b">Counter</code>对象，如下面的代码片段所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">update()方法</p></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="4d0b" class="kz la it bd lb lc nt le lf lg nu li lj jz nv ka ll kc nw kd ln kf nx kg lp lq bi translated">数学运算</h1><p id="c222" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">Counter</code>类的名字是信息性的，告诉你它对我们很重要。正如我们已经看到的，我们可以用<code class="fe mn mo mp mq b">update()</code>方法更新计数。更广泛地说，当我们有多个<code class="fe mn mo mp mq b">Counter</code>对象时，我们可以对它们进行加法和减法运算。当我们添加<code class="fe mn mo mp mq b">Counter</code>对象时，元素的计数被合并。</p><p id="b218" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">下面的代码向您展示了这样的操作，这应该是不言自明的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计数器对象的添加</p></figure><p id="fd73" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">以类似的方式，我们可以使用减号运算符从另一个<code class="fe mn mo mp mq b">Counter</code>对象中减去一个<code class="fe mn mo mp mq b">Counter</code>对象，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计数器对象的减法</p></figure><p id="e6d3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在上面的代码中，需要注意的一点是，当我们使用减法运算符时，得到的<code class="fe mn mo mp mq b">Counter</code>对象将只包括那些具有正计数的键值对。这种行为不同于<code class="fe mn mo mp mq b">Counter</code>的方法<code class="fe mn mo mp mq b">subtract()</code>，后者也将包含负计数。另外，如前所述，当<code class="fe mn mo mp mq b">Counter</code>不包含元素时，默认情况下它们的计数为零。记住这两件事，让我们看看<code class="fe mn mo mp mq b">subtract()</code>方法如何处理<code class="fe mn mo mp mq b">Counter</code>对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">subtract()方法</p></figure><p id="48c7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">正如您所看到的，产生的<code class="fe mn mo mp mq b">Counter</code>对象包括几个负计数的元素。另一件要注意的事情是，<code class="fe mn mo mp mq b">subtract()</code>方法就地改变计数，这意味着<code class="fe mn mo mp mq b">subtract()</code>方法返回<code class="fe mn mo mp mq b">None</code>并改变原始<code class="fe mn mo mp mq b">Counter</code>对象的计数。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="0d6d" class="kz la it bd lb lc nt le lf lg nu li lj jz nv ka ll kc nw kd ln kf nx kg lp lq bi translated">类似集合的操作</h1><p id="ebb2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了数学运算的支持外，<code class="fe mn mo mp mq b">Counter</code>对象还有两个类似集合的运算:<code class="fe mn mo mp mq b">union</code>和<code class="fe mn mo mp mq b">intersection</code>。要创建两个<code class="fe mn mo mp mq b">Counter</code>对象的“联合”,只需使用OR运算符(即竖线)将它们连接起来。联合操作将通过使用产生的<code class="fe mn mo mp mq b">Counter</code>对象中每个匹配键的最大计数来执行。下面是一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计数器的联合</p></figure><p id="c6e8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">要创建两个<code class="fe mn mo mp mq b">Counter</code>对象的“交集”,只需使用AND运算符(即<code class="fe mn mo mp mq b">&amp;</code>符号)将它们连接起来。交集操作将通过使用产生的<code class="fe mn mo mp mq b">Counter</code>对象中每个匹配键的最小计数来执行。下面是一个简单的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计数器的交集</p></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="c0b8" class="kz la it bd lb lc nt le lf lg nu li lj jz nv ka ll kc nw kd ln kf nx kg lp lq bi translated">其他特色亮点</h1><p id="7a1c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在前面的章节中，我们了解到我们可以从iterables创建<code class="fe mn mo mp mq b">Counter</code>对象，包括元组、列表和字符串。如前所述，<code class="fe mn mo mp mq b">Counter</code>类是内置<code class="fe mn mo mp mq b">dict</code>类的子类，因此我们可以使用对<code class="fe mn mo mp mq b">dict</code>类可用的实例化方法。下面列出了一些例子，并附有解释性说明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建计数器</p></figure><p id="c328" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们已经看到<code class="fe mn mo mp mq b">Counter</code>对象的计数来自计数或数学运算。如果适用的话，我们可以直接设置特定元素的数量。此外，我们可以从<code class="fe mn mo mp mq b">Counter</code>对象中移除元素，就像从<code class="fe mn mo mp mq b">dict</code>对象中移除键值对一样。这些用法见下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操作计数器对象</p></figure><p id="1d87" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">Counter</code>对象的另一个有用的方法是<code class="fe mn mo mp mq b">elements()</code>方法，它创建一个所有项目的迭代器，每个项目都有与其计数匹配的期望出现次数。这种方法对于迭代已知数字的不同项特别方便。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">elements()方法</p></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="dfd5" class="kz la it bd lb lc nt le lf lg nu li lj jz nv ka ll kc nw kd ln kf nx kg lp lq bi translated">结论</h1><p id="8833" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们回顾了有趣的<code class="fe mn mo mp mq b">Counter</code>类，用于计算序列中可散列对象的数量，包括元组、列表和字符串。作为<code class="fe mn mo mp mq b">dict</code>数据类型的子类，我们可以从序列以及映射和关键字参数中创建<code class="fe mn mo mp mq b">Counter</code>对象，就像常规的<code class="fe mn mo mp mq b">dict</code>对象一样。<code class="fe mn mo mp mq b">Counter</code>对象是高度灵活的，因为您可以根据需要操纵这些元素的计数。您甚至可以更新、合并和相交<code class="fe mn mo mp mq b">Counter</code>对象。</p><p id="817e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">最有趣的是，它有<code class="fe mn mo mp mq b">most_common()</code>方法，允许我们用一行代码找出最频繁出现的项目。还可以利用<code class="fe mn mo mp mq b">most_common()</code>方法找出最不常用的项目，该方法按降序排列项目，允许我们检索最不常用项目的最后一个项目。</p><p id="ed02" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">感谢阅读。</p></div></div>    
</body>
</html>