<html>
<head>
<title>Running Netflix Conductor 3 in Docker Using Elasticsearch 7 and PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Elasticsearch 7和PostgreSQL在Docker中运行网飞导体3</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/running-netflix-conductor-3-in-docker-using-elasticsearch-7-and-postgresql-b415988dd74a?source=collection_archive---------4-----------------------#2022-03-16">https://betterprogramming.pub/running-netflix-conductor-3-in-docker-using-elasticsearch-7-and-postgresql-b415988dd74a?source=collection_archive---------4-----------------------#2022-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cf95" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">所有这些都包含在一个简单、可重复和可维护的过程中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e04e46203404c6f4928ef3078f2bfd33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*yAZChXS_ewJANjohH49hUw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">网飞指挥家GitHub资料库中的网飞指挥家徽标。</p></figure><h1 id="ca60" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">关于这篇文章</h1><p id="ae32" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">网飞导体的标准实现配置为使用Elasticsearch 6。本文涵盖了使用Elasticsearch 7和PostgreSQL需要进行的更改，并提供了几个脚本来自动构建和运行Conductor，包括在本地和在云架构中。</p><p id="4bc7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在撰写本文时，最新发布的网飞指挥版本是3.5.3。本文中的信息基于版本3.5.1，但是应该适用于(并且容易修改)最新版本。如果你遇到任何问题，请让我知道，我会尽力帮助你。另一个巨大的帮助来源是网飞指挥讨论委员会。</p><p id="9b5f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我在一台Windows 10机器上运行所有提供的代码，来自Git Bash，它包含在<a class="ae mn" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank"> Git for Windows </a>中。我们的云架构运行在CentOS上。</p><h1 id="ceeb" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是网飞指挥家？</h1><p id="6f09" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">网飞指挥是一个工作流程编排引擎，由网飞创建，用于“编排基于微服务的流程”(来源:<a class="ae mn" href="https://netflix.github.io/conductor/" rel="noopener ugc nofollow" target="_blank">网飞指挥文档</a>)。网飞指挥的完整功能列表位于<a class="ae mn" href="https://netflix.github.io/conductor/" rel="noopener ugc nofollow" target="_blank">这里</a>，但一些关键功能是:</p><ul class=""><li id="c3f1" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">工作流和任务定义以JSON格式实现。这允许版本控制和对定制工具的简单支持，以创建和管理工作流和任务。</li><li id="1f79" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">任务和工作者，即分别构成工作流和承载它们的微服务的构建块，是完全语言不可知的，这允许以最适合任务的语言来完成实现。Java、Python、.NET(不要脸插:<a class="ae mn" href="https://github.com/erikbrgr/supersimpleconductor" rel="noopener ugc nofollow" target="_blank">这个</a>是我开发的)，还有其他的。</li><li id="4b2b" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">数据库架构是可插拔的，这意味着我们可以选择我们想要用于Conductor的数据库。Conductor附带了许多现成的插件，支持Dynomite(也是网飞开发的)、MySQL和PostgreSQL。</li><li id="c475" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">网飞指挥配备了一个(可选)用户界面，允许洞察和控制工作流程，如(重新)开始，暂停，停止。</li><li id="2cc8" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">整个项目是开源的，并且正在被积极地开发和支持。</li></ul><p id="d524" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">简而言之，网飞指挥允许您自动化和管理由多个任务组成的流程(这些任务本身可能就是流程)，这些任务可能需要以可靠、一致和可扩展的方式按顺序执行。</p><p id="ccff" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我目前的项目中，我们使用网飞Conductor和PostgreSQL来运行预定的ETL过程、创建报告、下载和上传文件，以及进行监控和报警。我们还研究了如何使用Conductor来自动提供用户帐户和其他基础设施。</p><h1 id="6134" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">为Elasticsearch 7配置网飞导体</h1><p id="8f9e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如简介中所述，网飞导体的标准实现配置为使用Elasticsearch 6。对Elasticsearch 7的支持是内置的，但需要进行一些更改才能启用。GitHub上有<a class="ae mn" href="https://github.com/Netflix/conductor/blob/b4673608bec51c3880ce69fc854a01c38fa0f13e/es7-persistence/README.md" rel="noopener ugc nofollow" target="_blank">文档</a>可以进行这些更改，但它似乎并不完全完整。我需要我下面描述的改变来构建和运行Elasticsearch 7。</p><p id="b68c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在撰写本文时，Elasticsearch 7.17.1是Elasticsearch 7的最新版本。</p><p id="52d4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是所需更改的快速总结(所有文件引用都是相对于根文件夹的):</p><ul class=""><li id="83f1" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated"><code class="fe nc nd ne nf b">build.gradle</code> —将<code class="fe nc nd ne nf b">ext['elasticsearch.version'] = revElasticSearch6</code> <br/>改为<code class="fe nc nd ne nf b">ext['elasticsearch.version'] = revElasticSearch7</code></li><li id="9cbd" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><code class="fe nc nd ne nf b">settings.gradle</code> —移除线<code class="fe nc nd ne nf b">include 'es6-persistence'</code></li><li id="6bd3" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><code class="fe nc nd ne nf b">server/build.gradle</code> —将<code class="fe nc nd ne nf b">implementation project(':conductor-es6-persistence')</code> <br/>改为<code class="fe nc nd ne nf b">implementation project(':conductor-es7-persistence')</code></li><li id="2249" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><code class="fe nc nd ne nf b">server/src/main/resources/application.properties </code> —将<code class="fe nc nd ne nf b">conductor.elasticsearch.version=6</code> <br/>改为<code class="fe nc nd ne nf b">conductor.elasticsearch.version=7</code></li><li id="13e7" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><code class="fe nc nd ne nf b">docker/docker-compose.yaml </code> —将<code class="fe nc nd ne nf b">image: elasticsearch:6.8.15</code> <br/>改为<code class="fe nc nd ne nf b">image: docker.elastic.co/elasticsearch/elasticsearch:7.17.1</code></li><li id="2ae3" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><code class="fe nc nd ne nf b">test-harness/build.gradle </code> —将<code class="fe nc nd ne nf b">testImplementation project(‘:conductor-es6-persistence’)</code> <br/>改为<code class="fe nc nd ne nf b">testImplementation project(‘:conductor-es7-persistence’)</code></li><li id="91d0" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><code class="fe nc nd ne nf b">/testharness/src/test/java/com/netflix/conductor/test/integration/AbstractEndToEndTest.java </code> —将<code class="fe nc nd ne nf b">conductor.elasticsearch.version=6</code> <br/>改为<code class="fe nc nd ne nf b">conductor.elasticsearch.version=7</code></li></ul><p id="423d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">将<code class="fe nc nd ne nf b">DockerImageName.parse("docker.elastic.co/elasticsearch/elasticsearch-oss").withTag("6.8.12"));</code> <br/>改为<code class="fe nc nd ne nf b">DockerImageName.parse("docker.elastic.co/elasticsearch/elasticsearch").withTag("7.17.1"));</code></p><p id="2a5c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">应用这些更改的标准方式是创建一个Conductor存储库的分支，并从那里开始工作。</p><p id="43db" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，我发现复制整个存储库来更改少量文件是对资源的浪费，所以我采用了不同的方法。</p><p id="2099" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在构建时，我<code class="fe nc nd ne nf b">clone</code>了指挥库，然后应用几个<code class="fe nc nd ne nf b">patch</code>文件来进行我需要的更改。虽然这些步骤稍微增加了构建时间，但我觉得这是速度和保持我自己的库干净和可维护之间的一个很好的折衷。</p><p id="532f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是如何工作的:</p><ol class=""><li id="8397" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh ng mu mv mw bi translated">在您的项目目录中克隆Conductor repo。</li><li id="7ee5" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh ng mu mv mw bi translated">进行上述更改。</li><li id="a301" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh ng mu mv mw bi translated">在Conductor文件夹中，运行<code class="fe nc nd ne nf b">git diff &gt; v3.5.1-update-to-es7.patch</code>创建一个<code class="fe nc nd ne nf b">patch</code>文件。<code class="fe nc nd ne nf b">v3.5.1</code>是为了方便起见，表示这个补丁只对那个版本有效。</li><li id="3ed7" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh ng mu mv mw bi translated">将<code class="fe nc nd ne nf b">patch</code>文件复制到根目录，这样您就可以安全地删除Conductor repo，并在再次克隆该repo时应用这些更改。</li></ol><p id="3a73" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在构建之前，您还需要删除任何<code class="fe nc nd ne nf b">dependencies.lock</code>文件。这和运行<code class="fe nc nd ne nf b">rm -f **/dependencies.lock</code>一样简单。</p><p id="bcbe" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了自动删除<code class="fe nc nd ne nf b">lock</code>文件并应用补丁，我创建了<code class="fe nc nd ne nf b">01.get-conductor.sh</code>脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5f6e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你可以看到我实际上应用了更多的补丁。这些不需要与Elasticsearch 7一起运行。</p><p id="2b3b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">此时，您可以构建导体。我为此创建了<code class="fe nc nd ne nf b">02.build-conductor-server.sh</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="812f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在“整合”一节中，我将提供几个额外的脚本来进一步自动化克隆、修补和构建过程，包括如何使用环境变量来配置Elasticsearch。</p><h1 id="a4ad" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">为PostgreSQL配置网飞导体</h1><p id="ae3b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">针对PostgreSQL运行Conductor也在<a class="ae mn" href="https://github.com/Netflix/conductor/blob/v3.5.1/docker/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>中有所描述。运行<code class="fe nc nd ne nf b">docker-compose -f docker-compose.yaml -f docker-compose-postgres.yaml up</code>将为PostgreSQL启动一个额外的容器实例，并配置Conductor来使用它。</p><p id="0495" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是在我们的例子中，我们希望运行PostgreSQL的现有安装。除此之外，我们不希望在<code class="fe nc nd ne nf b">public</code>模式中创建指挥数据库对象，这是默认设置。</p><p id="4d36" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了实现这一点，我们需要改变<code class="fe nc nd ne nf b">config-postgres.properties</code>文件。这存在于<code class="fe nc nd ne nf b">conductor/docker/server/config</code>文件夹中。但是因为我们在每个版本上都有指挥回购，所以我们不能在那里改变它。</p><p id="caa1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">所以，我在我的项目根目录下创建了一个<code class="fe nc nd ne nf b">docker</code>文件夹，它将包含对<code class="fe nc nd ne nf b">conductor/docker</code>文件夹中文件的所有定制。在构建时，我只是复制这个文件夹的内容。</p><p id="c16d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe nc nd ne nf b">02.build-conductor-server.sh</code>脚本现在变成了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b191" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们的本地<code class="fe nc nd ne nf b">config-postgres.properties</code>文件只是原始文件的副本，修改了PostgreSQL部分，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="496b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">通过将<code class="fe nc nd ne nf b">currentSchema</code>添加到数据源URL，我们确保在指定的模式中创建了导体数据库对象。如果需要的话,<code class="fe nc nd ne nf b">applicationName</code>属性可以帮助我们调试数据库会话。</p><p id="028b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">除了它不工作。当我们仅使用这些更改运行Conductor时，<code class="fe nc nd ne nf b">currentSchema</code>属性被忽略，所有内容都在<code class="fe nc nd ne nf b">public</code>模式中创建。不酷。我对引起它的公共关系提出了一个错误。</p><p id="b710" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我将为您节省几个小时的搜索时间来查找原因，并给出“解决方案”包括引号，因为感觉更像黑客。但这很有效。</p><p id="8bb2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在文件<code class="fe nc nd ne nf b">postgres-persistence/src/main/java/com/netflix/conductor/postgres/config/PostgresConfiguration.java</code>中，用行<code class="fe nc nd ne nf b">.schemas("public")</code>配置了Flyway(它处理数据库迁移),这会导致任何更改默认模式的尝试都被忽略。删除此行可以解决问题。</p><p id="897a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我为此创建了<code class="fe nc nd ne nf b">v3.5.1-fix-currentSchema-override.patch</code>，并将其包含在<code class="fe nc nd ne nf b">01.get-conductor.sh</code>脚本中。</p><p id="a1e8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果您想知道那里的<code class="fe nc nd ne nf b">##</code>占位符，它们将被匹配环境变量的值所替换。我将在“整合”一节中讨论这个问题。与此同时，就用你的价值观来代替这些吧。</p><h1 id="61fb" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">配置工作流归档</h1><p id="47c7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">作为一个小而有用的奖励，我们通过配置工作流状态监听器，使已完成和已终止的工作流能够在60秒(默认)后归档。</p><p id="523f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">只需将<code class="fe nc nd ne nf b">conductor.workflow-status-listener.type=archive</code>添加到<code class="fe nc nd ne nf b">config-postgres.properties</code>文件中。</p><p id="5fea" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">无论如何，这将防止您的数据库被您永远不想再看到的工作流淹没。即使你这么做了，这些数据仍然会被存储在Elasticsearch中，并且可以随时访问。</p><h1 id="a23b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">把所有的放在一起</h1><p id="b6c2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了使上述内容在本地和我们的云环境中都能工作，我们想使用环境变量来配置Elasticsearch和PostgreSQL。为了做到这一点，我们求助于<code class="fe nc nd ne nf b">conductor/docker/server/bin</code>文件夹中的<code class="fe nc nd ne nf b">startup.sh</code>文件。我们将这个文件复制到本地的<code class="fe nc nd ne nf b">docker</code>文件夹中，这样我们可以做一些修改。</p><p id="f19e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们在<code class="fe nc nd ne nf b">if..fi</code>块后添加了以下几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3f83" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">还记得你之前看到的那些<code class="fe nc nd ne nf b">##</code>占位符吗？我们使用工具<code class="fe nc nd ne nf b">sed</code>将它们替换为匹配环境变量中配置的值。</p><p id="f6ba" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了在本地运行，我们将环境变量及其值添加到<code class="fe nc nd ne nf b">docker-compose.yaml</code>和<code class="fe nc nd ne nf b">docker-compose-postgres.yaml</code>文件中，并将其复制到本地的<code class="fe nc nd ne nf b">docker</code>文件夹中。例如，参见<code class="fe nc nd ne nf b">docker-compose-postgres.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="59cc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们使用神奇的<code class="fe nc nd ne nf b">host.docker.internal</code>值指向本地PostgreSQL实例，因为<code class="fe nc nd ne nf b">localhost</code>不能在Docker容器中工作。</p><p id="59b6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe nc nd ne nf b">02.build-conductor-server.sh</code>脚本也复制了<code class="fe nc nd ne nf b">startup.sh</code>。</p><p id="4012" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，只剩下几个脚本了。</p><p id="1bb9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe nc nd ne nf b">03.build-conductor-ui.sh</code>负责构建指挥UI图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c70f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们可以使用<code class="fe nc nd ne nf b">04.run-local.sh</code>运行Conductor，它实际上只做调用<code class="fe nc nd ne nf b">docker compose up</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="df77" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">或者，我们可以运行<code class="fe nc nd ne nf b">04.run-local-postgres.sh</code>来运行PostgreSQL数据库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="46fc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这就是了。使用上面的脚本，您应该能够在几分钟内构建并运行网飞指挥的本地实例。并且将脚本连接到您最喜欢的CI/CD工具也应该是完全可行的。</p><h1 id="a32a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">最后</h1><p id="5a28" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用Elasticsearch 7和PostgreSQL运行网飞指挥需要一些工作，但是通过使用<code class="fe nc nd ne nf b">git diff</code>和bash脚本的能力，我们可以使这个过程变得简单、可重复，并且在本地和云环境中都可用。</p><p id="08ed" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">以上所有源代码都可以在GitHub 的<a class="ae mn" href="https://github.com/erikbrgr/conductor-es7-postgres" rel="noopener ugc nofollow" target="_blank">上获得。</a></p><p id="ad08" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我希望这篇文章能帮助你使用Elasticsearch 7和PostgreSQL开始学习网飞指挥。</p><p id="2c76" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">编码快乐！</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="c87b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">本文中的所有代码片段都是使用<a class="ae mn" href="https://levelup.gitconnected.com/create-beautiful-embedded-code-without-the-hassle-of-creating-github-gists-fe6ce2fa0109" rel="noopener ugc nofollow" target="_blank"> gistbuilder </a>创建的，这是我专门为此编写的一个漂亮的小程序。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="afef" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果您觉得这篇文章有用，您可能会对我们如何在项目中安排工作流感兴趣。你很幸运，我也写了一篇关于这个的文章:</p><div class="nq nr gp gr ns nt"><a href="https://levelup.gitconnected.com/cron-docker-the-easiest-job-scheduler-youll-ever-create-e1753eb5ea44" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">Cron + Docker =你将创建的最简单的作业调度程序</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">最大功率和灵活性的两个组件。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ko nt"/></div></div></a></div></div></div>    
</body>
</html>