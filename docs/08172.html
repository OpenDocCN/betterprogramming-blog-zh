<html>
<head>
<title>8 Best Practices To Write Better Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更好的Python代码的8个最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-best-practices-to-write-better-python-code-c76b667173c7?source=collection_archive---------8-----------------------#2021-04-02">https://betterprogramming.pub/8-best-practices-to-write-better-python-code-c76b667173c7?source=collection_archive---------8-----------------------#2021-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写更好、更高效的Python代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f60d769bd66c6fbfad5456fac48cc33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mnsmnkqr-prpCQZ3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tateisimikito?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jukan Tateisi </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="516b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就语法而言，Python是一种非常容易和简单的编程语言。与其他编程语言相比，用Python编写代码非常简单。但是有一些最佳实践可以让你写出更好更高效的Python代码。</p><p id="5047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到Python脚本和开发时，编写高效的Python代码来节省时间和计算机内存就变得很有必要。</p><p id="4dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些最佳实践将帮助您在Python开发之旅中实现目标。我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9309" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.列表理解的使用</h1><p id="1069" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">List comprehension允许您在一行代码中基于现有列表的元素创建一个新列表。</p><p id="ca36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建一个新的列表时，列表理解通常比普通的循环和函数更加紧凑和快速。</p><p id="e2f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe mz na nb nc b">newlist = [ expression for <em class="nd">item</em> in <em class="nd">iterable</em> (if conditional) ]</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="433e" class="nk md it nc b gy nl nm l nn no">Output:</span><span id="aeba" class="nk md it nc b gy np nm l nn no">Even numbers are: [0, 2, 4, 6, 8]<br/>Squared numbers are: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="51b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.用f字符串格式化字符串</h1><p id="c71f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python 3.6中引入的<code class="fe mz na nb nc b">f-strings</code>是一种格式化字符串的新方法。与其他格式化字符串的方法相比，<code class="fe mz na nb nc b">f-strings</code>可读性更强，速度更快，并且不容易出错。</p><p id="dde3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b">f-strings</code>来格式化一个字符串是非常容易的。你必须在引号前以<code class="fe mz na nb nc b">f</code>或<code class="fe mz na nb nc b">F</code>开始一个字符串。在字符串内部，您必须在<code class="fe mz na nb nc b">{}</code>之间编写一个Python表达式，该表达式可以引用初始化的变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="0af4" class="nk md it nc b gy nl nm l nn no">Output:</span><span id="1cf3" class="nk md it nc b gy np nm l nn no">Hello World! My name is John and my age is 18</span></pre><p id="6608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，它们使用起来非常简单。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3cc0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.使用集合。计数器()</h1><p id="1803" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">Counter()</code>用于统计iterable中某项出现的频率。<code class="fe mz na nb nc b">Counter()</code>函数将列表、元组或字符串等可迭代对象作为输入，然后返回该可迭代对象中每一项的计数作为输出。</p><p id="a7c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe mz na nb nc b">Counter()</code>函数是dictionary类的子类。在这个函数的帮助下，我们可以在不实现字典代码的情况下，以更快的方式计算迭代器中元素的频率。</p><p id="8bdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe mz na nb nc b">Counter(iterable)</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="dfc9" class="nk md it nc b gy nl nm l nn no">Output:</span><span id="5e32" class="nk md it nc b gy np nm l nn no">Counter({'B': 5, 'A': 3, 'C': 2})<br/>Counter({'o': 4, ' ': 4, 'l': 3, 'H': 2, 'e': 2, 'w': 2, 'r': 2, 'd': 1, '!': 1, 'a': 1, 'y': 1, 'u': 1, '?': 1})</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f615" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.用Sorted()对复杂的可重复项进行排序</h1><p id="51e2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您需要对一些iterable进行排序，比如列表、元组或字典，您不需要自己实现任何排序算法。您可以使用内置函数<code class="fe mz na nb nc b">sorted()</code>以任何顺序(升序或降序)对任何iterable进行排序。</p><p id="1d24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回一个排序列表作为输出。</p><p id="7d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe mz na nb nc b">sorted(iterable, key=None, reverse=False)</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="ca78" class="nk md it nc b gy nl nm l nn no">Output:</span><span id="d2e6" class="nk md it nc b gy np nm l nn no">Sorted list: [2, 3, 6, 11, 15, 33, 64, 99]<br/>Sorted dictionary list: [{'name': 'Lisa', 'Age': 17}, {'name': 'Joy', 'Age': 19}, {'name': 'Jack', 'Age': 21}]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="693d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.在字典中使用get()方法</h1><p id="b563" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python字典中，<code class="fe mz na nb nc b">get()</code>方法用于检索具有指定键的项的值。</p><p id="5b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">get()</code>方法的优点是，如果带有指定键的值不存在，它不会抛出任何错误。相反，它返回默认值(<code class="fe mz na nb nc b">None</code>)或任何其他指定的默认值。</p><p id="dead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe mz na nb nc b">Dict.get(key, default=None)</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="7185" class="nk md it nc b gy nl nm l nn no">Output:</span><span id="1537" class="nk md it nc b gy np nm l nn no">Brand: Ford<br/>Type: Not Found</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="353a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.使用解包操作符合并字典</h1><p id="0f95" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以使用<code class="fe mz na nb nc b">(**)</code>操作符在一行中合并多个字典。我们需要用<code class="fe mz na nb nc b">(**)</code>操作符在<code class="fe mz na nb nc b">{}</code>中传递字典。</p><p id="8684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe mz na nb nc b">{**dict1, **dict2}</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="4776" class="nk md it nc b gy nl nm l nn no">Output:</span><span id="1ac2" class="nk md it nc b gy np nm l nn no">Merged dictionary: {'name': 'Joy', 'age': 25, 'city': 'New York'}</span></pre><p id="bbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样传多个字典:<code class="fe mz na nb nc b">{**dict1, **dict2, **dict3}</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="efdc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.使用enumerate()函数</h1><p id="f744" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当处理迭代器时，我们经常需要计算迭代次数。Python为我们提供了内置的<code class="fe mz na nb nc b">enumerate()</code>函数来简化这项任务。</p><p id="1692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe mz na nb nc b">enumerate()</code>函数同时从iterable中获取计数器和值，而不是自己创建和增加变量的计数。</p><p id="ac22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe mz na nb nc b">enumerate(iterable, start=0)</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="b11f" class="nk md it nc b gy nl nm l nn no">Output:</span><span id="4356" class="nk md it nc b gy np nm l nn no">0 apple<br/>1 orange<br/>2 banana<br/>[(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="307e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.用集合存储唯一值</h1><p id="7599" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您需要在迭代器中存储唯一元素时，可用的最佳选项是<code class="fe mz na nb nc b">Sets</code>。</p><p id="69f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Sets</code>用于存储唯一值。集合相对于其他迭代器的优势在于，集合平均可以在<em class="nd"> O(1) </em>中查找/插入/删除，因为它们是作为哈希表实现的。</p><p id="4acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe mz na nb nc b">set(iterator)</code></p><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="8b90" class="nk md it nc b gy nl nm l nn no">list1 = [1,2,2,3,3,3,4,4,5,5,5,6]<br/>my_set = set(list1)<br/>print(my_set)</span><span id="21b5" class="nk md it nc b gy np nm l nn no">Output:<br/>{1, 2, 3, 4, 5, 6}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee78" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="85da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文到此为止。我们已经讨论了八个最佳实践，您可以使用它们来节省时间，并使您的代码在Python中看起来更整洁。</p><p id="dcbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您将Python用于竞争性编程和开发目的，那么这些技巧对于更快地运行代码非常有用。</p><p id="75cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>