<html>
<head>
<title>Basic JavaScript Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本的JavaScript面试问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-interview-questions-the-basics-c28f81bafbed?source=collection_archive---------6-----------------------#2020-02-28">https://betterprogramming.pub/javascript-interview-questions-the-basics-c28f81bafbed?source=collection_archive---------6-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ad9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JS面试101</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5627cbebcdc2f9b7b5bc5aa068d174c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnarbbNH0gVEuExsjE1oRA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@plushdesignstudio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">毛绒设计工作室</a>在<a class="ae ky" href="https://unsplash.com/s/photos/question?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f28a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要想得到一份JavaScript开发人员的工作，不管是前端还是其他，我们需要搞定编码面试。</p><p id="ccc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看一些基本问题和它们的答案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b1b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">未定义和null有什么区别？</h1><p id="315c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">它们都表示一个不存在的值，但是我们必须显式地设置<code class="fe mz na nb nc b">null</code>。</p><p id="0657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe mz na nb nc b">undefined</code>是未声明变量、已设置值的数组位置以及未设置值的已声明变量的值。</p><p id="6f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，<code class="fe mz na nb nc b">null</code>拥有类型对象，而<code class="fe mz na nb nc b">undefined</code>拥有未定义的类型。他们都是虚伪的，他们都是原始的类型。</p><p id="c1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面将为我们带来<code class="fe mz na nb nc b">undefined</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="685d" class="nh md it nc b gy ni nj l nk nl">let x;<br/>let y = undefined;</span></pre><p id="c175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，没有赋值的数组位置也将是<code class="fe mz na nb nc b">undefined</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a9ca" class="nh md it nc b gy ni nj l nk nl">let arr = [];<br/>arr[1];</span></pre><p id="0035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">arr[1]</code>是上面的<code class="fe mz na nb nc b">undefined</code>。</p><p id="a15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阵列中的孔也是<code class="fe mz na nb nc b">undefined</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="efa4" class="nh md it nc b gy ni nj l nk nl">let arr = [,1];<br/>arr[0]</span></pre><p id="43eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当转换为布尔值时，它们都转换为<code class="fe mz na nb nc b">false</code>，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0fbb" class="nh md it nc b gy ni nj l nk nl">Boolean(undefined);<br/>Boolean(null);<br/>!!undefined;<br/>!!null;</span></pre><p id="eba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">null</code>与<code class="fe mz na nb nc b">==</code>运算符相比等于<code class="fe mz na nb nc b">undefined</code>，因为它们是假的。当我们用<code class="fe mz na nb nc b">===</code>运算符比较它们时，它们不相等，因为它们属于不同的类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ecc0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">&amp;&amp;运算符是做什么的？</h1><p id="cfa0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">&amp;&amp;</code>操作符是<em class="nm">和</em>操作符，它找到第一个falsy表达式并返回它。如果没有假表达式，则返回最后一个表达式。</p><p id="7530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4c82" class="nh md it nc b gy ni nj l nk nl">let foo = null &amp;&amp; undefined &amp;&amp; 'foo';</span></pre><p id="1f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe mz na nb nc b">null</code>和<code class="fe mz na nb nc b">undefined</code>为假，所以<code class="fe mz na nb nc b">foo</code>为<code class="fe mz na nb nc b">null</code>。</p><p id="fdd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2190" class="nh md it nc b gy ni nj l nk nl">let foo = true &amp;&amp; 'foo';</span></pre><p id="850c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将<code class="fe mz na nb nc b">'foo'</code>分配给<code class="fe mz na nb nc b">foo</code>。它进行短路评估，以防止不必要的检查。</p><p id="83f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是一个方便的快捷方式:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="dcbb" class="nh md it nc b gy ni nj l nk nl">if (condition){<br/>  doSomething();<br/>}</span></pre><p id="7a57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为上面的代码与:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0db6" class="nh md it nc b gy ni nj l nk nl">condition &amp;&amp; doSomething();</span></pre><p id="2e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为，如果<code class="fe mz na nb nc b">condition</code>是假的，那么<code class="fe mz na nb nc b">doSomething();</code>不会因为短路而运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4beb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">||运算符是做什么的？</h1><p id="e125" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">||</code>操作者为<em class="nm">或</em>操作者。它找到第一个the表达式并返回它。</p><p id="fb52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还使用短路来避免不必要的检查。因此，在缺省选择之前的变量为假的情况下，设置变量的缺省值是很方便的。</p><p id="c30a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="cf0a" class="nh md it nc b gy ni nj l nk nl">let foo = null || undefined || 'foo';</span></pre><p id="d6c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们用<code class="fe mz na nb nc b">'foo'</code>作为<code class="fe mz na nb nc b">foo</code>的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/e4700c42a56299d755758537a8002a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6--Fr2LqBw3J4XUU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Amy Hirschi 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="144f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">+运算符是做什么的？</h1><p id="b9c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">+</code>操作符有三层含义。</p><h2 id="3c18" class="nh md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">1.一元+</h2><p id="65d1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果把它放在一个表达式前面，它会试图把它转换成一个数字。将运算符放在表达式前面会使其成为一元运算符。</p><p id="ce0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想获得当前日期时间的UNIX时间戳，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="39b8" class="nh md it nc b gy ni nj l nk nl">+new Date();</span></pre><p id="4564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">+new Date(2020,1,1);</code>将回归<code class="fe mz na nb nc b">1580544000000</code>。</p><p id="0a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是一种将字符串转换成数字的快速方法。例如:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9f3f" class="nh md it nc b gy ni nj l nk nl">+'1'</span></pre><p id="8ad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回<code class="fe mz na nb nc b">1</code>。</p><p id="2104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，一元<code class="fe mz na nb nc b">+</code>操作符试图转换它后面的表达式。我们可以将表达式用括号括起来，转换成数字，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="798a" class="nh md it nc b gy ni nj l nk nl">+(1 + '1');</span></pre><p id="3d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe mz na nb nc b">11</code>，因为<code class="fe mz na nb nc b">1 + ‘1’</code>返回<code class="fe mz na nb nc b">'11'</code>。</p><p id="c91a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果表达式不能转换成数字，它将返回<code class="fe mz na nb nc b">NaN</code>。</p><h2 id="dd0c" class="nh md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">2.加法算子</h2><p id="287e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果<code class="fe mz na nb nc b">+</code>运算符介于两个数字之间，它会将这两个数字相加。</p><p id="0b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4b65" class="nh md it nc b gy ni nj l nk nl">1 + 2;</span></pre><p id="3438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们得到3。</p><p id="607e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="04ce" class="nh md it nc b gy ni nj l nk nl">let a = 1, b = 2;<br/>a + b;</span></pre><p id="ea5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也得到了3。</p><h2 id="a7ae" class="nh md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">3.并置算符</h2><p id="0b4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果表达式中的一个或多个操作数不是数字，它会尝试用不同的方式转换它。</p><p id="5b7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5656" class="nh md it nc b gy ni nj l nk nl">1 + '1'</span></pre><p id="2e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="eb0b" class="nh md it nc b gy ni nj l nk nl">'1' + 1</span></pre><p id="120a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe mz na nb nc b">'11'</code>。</p><p id="0fd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，如果我们有两个字符串作为操作数，那么<code class="fe mz na nb nc b">+</code>操作符将用于字符串连接:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b775" class="nh md it nc b gy ni nj l nk nl">'foo' + 'bar';</span></pre><p id="0446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回<code class="fe mz na nb nc b">“foobar”</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2cbb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><code class="fe mz na nb nc b">==</code>和<code class="fe mz na nb nc b">===</code>有什么区别？</h1><p id="63b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">==</code>和<code class="fe mz na nb nc b">===</code>的区别在于<code class="fe mz na nb nc b">==</code>只检查内容是否相等，而<code class="fe mz na nb nc b">===</code>检查内容和数据类型是否相等。</p><p id="221a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="dd99" class="nh md it nc b gy ni nj l nk nl">2 == '2'</span></pre><p id="2001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回<code class="fe mz na nb nc b">true</code>,因为它们的内容都是<code class="fe mz na nb nc b">2</code>。这是因为<code class="fe mz na nb nc b">==</code>确实属于强制类型。</p><p id="9871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于<code class="fe mz na nb nc b">==</code>操作符的类型强制规则的完整列表如下:</p><ol class=""><li id="1e19" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">如果<code class="fe mz na nb nc b">x</code>和<code class="fe mz na nb nc b">y</code>具有相同的值，则与<code class="fe mz na nb nc b">===</code>操作符进行比较。</li><li id="f509" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果<code class="fe mz na nb nc b">x</code>为<code class="fe mz na nb nc b">null</code>且<code class="fe mz na nb nc b">y</code>为<code class="fe mz na nb nc b">undefined</code>，则返回<code class="fe mz na nb nc b">true</code>。</li><li id="2d8e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果<code class="fe mz na nb nc b">x</code>为<code class="fe mz na nb nc b">undefined</code>且<code class="fe mz na nb nc b">y</code>为<code class="fe mz na nb nc b">null</code>，则返回<code class="fe mz na nb nc b">true</code>。</li><li id="4185" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果<code class="fe mz na nb nc b">x</code>的类型为<code class="fe mz na nb nc b">number</code>且<code class="fe mz na nb nc b">y</code>为字符串，则返回<code class="fe mz na nb nc b">x == +y</code>。</li><li id="413d" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果<code class="fe mz na nb nc b">x</code>是<code class="fe mz na nb nc b">string</code>类型且<code class="fe mz na nb nc b">y</code>是<code class="fe mz na nb nc b">number</code>类型，则返回<code class="fe mz na nb nc b">+x == y</code>。</li><li id="e17f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果<code class="fe mz na nb nc b">y</code>为<code class="fe mz na nb nc b">boolean</code>类型，则返回<code class="fe mz na nb nc b">+x == y</code>。</li><li id="9f91" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果<code class="fe mz na nb nc b">y</code>是一个<code class="fe mz na nb nc b">boolean</code>，返回<code class="fe mz na nb nc b">x == +y</code>。</li><li id="f059" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果<code class="fe mz na nb nc b">x</code>是一个<code class="fe mz na nb nc b">string</code>、<code class="fe mz na nb nc b">symbol</code>或<code class="fe mz na nb nc b">number</code>并且<code class="fe mz na nb nc b">y</code>是一个<code class="fe mz na nb nc b">object</code>，那么:</li></ol><ul class=""><li id="43d4" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu on of og oh bi translated">如果<code class="fe mz na nb nc b">y</code>是<code class="fe mz na nb nc b">String</code>实例，则返回<code class="fe mz na nb nc b">x == y.valueOf()</code>。</li><li id="cde9" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu on of og oh bi translated">如果<code class="fe mz na nb nc b">y</code>是一个<code class="fe mz na nb nc b">Number</code>实例，则返回<code class="fe mz na nb nc b">x == y.valueOf()</code>。</li><li id="0f69" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu on of og oh bi translated">如果<code class="fe mz na nb nc b">y</code>是任何其他类型的对象或值，则返回<code class="fe mz na nb nc b">x == y[Symbol.toPrimitive]()</code>。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="084f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="cfba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些都是最基本的问题。为了搞定一场JavaScript面试，这些是开始学习的问题。</p></div></div>    
</body>
</html>