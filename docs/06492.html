<html>
<head>
<title>3 Pitfalls in Golang I Wish I Had Known Earlier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang的3个陷阱我希望我能早点知道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-pitfalls-in-golang-i-wish-i-knew-3f208a8402a7?source=collection_archive---------0-----------------------#2020-10-07">https://betterprogramming.pub/3-pitfalls-in-golang-i-wish-i-knew-3f208a8402a7?source=collection_archive---------0-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7d8d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我从零开始学习围棋</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8069daf3253c0f85e0b42e03670840d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4cdJmkVsjOnFVFzG.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="ffef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">去年，我们在生产中开发了一个复杂的半实时系统。我们决定用<a class="ae lr" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>来写。我们在围棋方面几乎没有经验，所以你可以想象，这并不简单。</p><p id="05d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快进一年:该系统在生产中运行，并成为ClimaCell产品的主要支柱之一。</p><p id="1a04" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">精通意味着你有足够的经验知道你正在使用的平台的陷阱是什么，以及如何避免它们。</p><p id="5ca8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想描述我们在Golang的任务中遇到的三个陷阱，希望它能帮助你避免它们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b644" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">射程可变性</h1><p id="b190" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="45c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们有一个保存结构实例的通道。我们用<code class="fe my mz na nb b">range</code>操作符迭代通道。你认为这段代码的输出会是什么？</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="43d0" class="ng ma iq nb b gy nh ni l nj nk">6<br/>6<br/>6<br/>6<br/>6<br/>9<br/>9<br/>9<br/>9<br/>9</span></pre><p id="3b8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很奇怪，不是吗？我们期望看到数字1-9(当然不是有序的)。</p><p id="501d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们实际看到的是循环变量可变性的结果:</p><p id="4454" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在每一次迭代中，我们都要处理一个struct实例。结构是值类型——它们在每次迭代中被复制到<code class="fe my mz na nb b">for</code>迭代变量中。这里的关键词是<em class="nl">复制</em>。为了避免大量内存打印，我们在循环开始时创建一个单独的实例，并在每次迭代中复制数据，而不是在每次迭代中创建一个新的变量实例。</p><p id="dfaf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">闭包是等式的另一部分:go中的闭包(像在大多数语言中一样)保存闭包中对象的引用(不复制数据)，所以内部go例程引用迭代的对象，这意味着所有Go例程对同一个实例获得相同的引用。</p><h2 id="5c96" class="ng ma iq bd mb nm nn dn mf no np dp mj le nq nr ml li ns nt mn lm nu nv mp nw bi translated">解决方案</h2><p id="1cd4" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">首先，要意识到这种情况的发生。这不是小事，因为这是与其他语言完全不同的行为(C#中的<code class="fe my mz na nb b">for-each</code>, JS中的<code class="fe my mz na nb b">for-of</code>——在这些语言中，循环变量是不可变的)。</p><p id="63a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了避免这个陷阱，在循环范围内捕获变量，从而自己创建一个新的实例，然后按照自己的意愿使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c95b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们使用内部go例程的函数调用来捕获<code class="fe my mz na nb b">a</code>，有效地复制它。也可以显式复制:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="67eb" class="ng ma iq bd mb nm nn dn mf no np dp mj le nq nr ml li ns nt mn lm nu nv mp nw bi translated">笔记</h2><ul class=""><li id="ea67" class="nx ny iq kx b ky mr lb ms le nz li oa lm ob lq oc od oe of bi translated">对于大型数据集，注意捕获循环变量将创建大量的对象，每个对象都被保存，直到底层的go例程被执行。因此，如果对象包含几个字段，考虑只捕获执行内部例程所需的字段。</li><li id="2ed2" class="nx ny iq kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated"><code class="fe my mz na nb b">for-range</code>作为数组的附加表现形式。它还创建了一个索引循环变量。请注意，索引循环变量也是可变的，也就是说，要在go例程中使用它，可以像使用值循环变量一样捕获它。</li><li id="4d91" class="nx ny iq kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated">在当前的Go版本(1.15)中，我们看到的初始代码实际上会抛出一个错误，帮助我们避免这个问题，并强制我们捕获我们需要的数据。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c4ee" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">当心:=</h1><p id="10df" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">Golang有两个赋值操作符，<code class="fe my mz na nb b">=</code>和<code class="fe my mz na nb b">:=</code>:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="0632" class="ng ma iq nb b gy nh ni l nj nk">var num int<br/>num = 3<br/><br/>name := "yossi"</span></pre><p id="7fdb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe my mz na nb b">:=</code>非常有用，允许我们避免在赋值前声明变量。这实际上是当今许多类型化语言中的常见做法(比如C#中的<code class="fe my mz na nb b">var</code>)。它非常有用，并保持代码更干净(拙见)。</p><p id="d362" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管这很可爱，但是当与Golang、scope和多个返回值中的一些其他行为结合使用时，我们可能会遇到意想不到的行为。考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3e24" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们从某个地方读取一个字符串数组并打印出来:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="9c7a" class="ng ma iq nb b gy nh ni l nj nk">there<br/>are<br/>no<br/>strings<br/>on<br/>me</span></pre><p id="9960" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意<code class="fe my mz na nb b">:=</code>的用法:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="8c21" class="ng ma iq nb b gy nh ni l nj nk">data, err := getData()</span></pre><p id="8383" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，即使已经声明了<code class="fe my mz na nb b">data</code>,我们仍然可以使用<code class="fe my mz na nb b">:=</code>,因为<code class="fe my mz na nb b">err</code>不是——这是一种很好的简化方式，可以创建更简洁的代码。</p><p id="e33f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们稍微修改一下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0bae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你认为这段代码的结果会是什么？</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="ea11" class="ng ma iq nb b gy nh ni l nj nk">kill switch is off<br/>Data was fetched! 6</span></pre><p id="7290" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很奇怪，不是吗？因为关闭了kill开关，所以我们加载了数据——我们甚至打印了数据的长度。那么为什么代码不像以前那样打印出来呢？</p><p id="b7d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你猜对了——因为<code class="fe my mz na nb b">:=</code>！</p><p id="7870" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Golang中的作用域(像大多数现代语言一样)是用<code class="fe my mz na nb b">{}</code>定义的。这里，这个<code class="fe my mz na nb b">if</code>创建了一个新的作用域:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="a4db" class="ng ma iq nb b gy nh ni l nj nk">if killswitch == "" {<br/>	...		<br/>}</span></pre><p id="0bd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们使用了<code class="fe my mz na nb b">:=</code>，Go会把<code class="fe my mz na nb b">data</code>和<code class="fe my mz na nb b">err</code>都当作新变量！也就是说，<code class="fe my mz na nb b">if</code>子句中的<code class="fe my mz na nb b">data</code>实际上是一个新变量，当作用域关闭时，它被丢弃。</p><p id="be23" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在初始化流程中遇到过几次这样的行为——通常会公开某种包变量，完全按照这里的描述进行初始化，并带有一个kill开关，允许我们在生产中禁用某些行为。上面的实现将导致系统的无效状态。</p><h2 id="13ea" class="ng ma iq bd mb nm nn dn mf no np dp mj le nq nr ml li ns nt mn lm nu nv mp nw bi translated">解决方案</h2><p id="08f7" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">意识——我已经说过了吗？:)</p><p id="ab59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在某些情况下，如果没有使用<code class="fe my mz na nb b">if</code>子句中的内部变量，Go编译器会发出警告甚至错误，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4d96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以编译时要注意警告。</p><p id="4b65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管如此，有时我们确实在作用域内使用了变量，所以不会出现错误。</p><p id="a86b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论如何，最好的做法是尽量避免使用<code class="fe my mz na nb b">:=</code>简写，尤其是当它与多个返回值和错误处理相关时，并且在决定使用它时保持额外的注意力:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8caa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将导致以下结果:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="cf91" class="ng ma iq nb b gy nh ni l nj nk">kill switch is off<br/>Data was fetched! 6<br/>there<br/>are<br/>no<br/>strings<br/>on<br/>me</span></pre><p id="95ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记住，随着代码的发展，不同的人会修改它。以前不在不同范围内的代码将来可能会在不同范围内。当您修改现有代码时，尤其是将它转移到不同的范围时，请保持警惕。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="187c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">工人池。工人船长</h1><p id="4691" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5962" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和以前一样——我们在一个通道上有一个<code class="fe my mz na nb b">for-range</code>循环。假设<code class="fe my mz na nb b">process</code>函数包含一个我们需要运行的算法，并且不是很快。如果我们处理100，000个项目，上面的代码将运行几乎三个小时(在示例中，流程运行100毫秒)。所以，让我们这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="aeb7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们不是串行处理项目，而是为通道中的每个项目分派一个go例程。我们希望利用Go惊人的并发处理能力来帮助我们更快地处理数据:</p><p id="841e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理论上，这也适用于100K的物品，对吗？</p><p id="c73f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不幸的是，答案是“视情况而定”。</p><p id="45a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要理解为什么，我们需要理解当我们调度一个go例程时会发生什么。我不会深入研究它，因为它超出了本文的范围。简而言之，运行时创建一个包含所有与go例程相关的数据的对象，并存储它。当go例程的执行完成时，它被逐出。go routine对象的最小大小是2K，但是它可以达到1GB(在64位机器上)。</p><p id="b706" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，您可能已经知道我们要去哪里了——我们创建的go例程越多，我们创建的对象就越多，因此内存消耗也在增加。此外，go例程需要来自CPU的执行时间来进行实际执行，因此我们拥有的内核越少，这些对象在内存中等待执行的时间就越多。</p><p id="aa20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在低资源环境中(lambda函数，K8s pods有严格的限制)，CPU和内存都是有限的，即使在100K go例程中，代码示例也会对内存造成压力(同样，这取决于有多少内存可用于实例)。在我们的例子中，在具有128MB内存的云函数中，我们能够在崩溃之前处理大约100K个项目。</p><p id="ad47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，从应用程序的角度来看，我们需要的实际数据非常小——在本例中，是一个简单的int。大部分内存消耗是go例程本身。</p><h2 id="d129" class="ng ma iq bd mb nm nn dn mf no np dp mj le nq nr ml li ns nt mn lm nu nv mp nw bi translated">解决方案</h2><p id="76fc" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">工人池！</p><p id="1675" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">工人池允许我们管理我们拥有的go例程的数量，保持低内存消耗。让我们看一个工人池的相同例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9ff6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将工作池的数量限制为100个，并为每个工作池创建一个go例程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="33fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以把通道想象成一个队列，其中每个worker go例程都是队列的消费者。Go的通道允许多个go例程监听同一个通道，其中通道中的每个项目将被处理一次。</p><h2 id="1103" class="ng ma iq bd mb nm nn dn mf no np dp mj le nq nr ml li ns nt mn lm nu nv mp nw bi translated">好的一面</h2><p id="5de8" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们现在可以规划我们的环境，因为现在的内存印迹是可以预期和测量的:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="f970" class="ng ma iq nb b gy nh ni l nj nk">the size of the worker pool * expected size of a single go routine (min 2K)</span></pre><h2 id="5111" class="ng ma iq bd mb nm nn dn mf no np dp mj le nq nr ml li ns nt mn lm nu nv mp nw bi translated">不利方面</h2><p id="c3af" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">执行时间会增加。当我们限制内存使用时，我们以增加的执行时间为代价。为什么？以前，我们为每个项目分派一个go例程来处理——有效地为每个项目创建一个消费者。这给了我们几乎无限的规模和高并发性。实际上，这是不正确的，因为go例程的执行依赖于运行应用程序的内核的可用性。这意味着我们必须根据我们运行的平台来优化工作人员的数量，但是在高容量系统中这样做是有意义的。</p><h2 id="7723" class="ng ma iq bd mb nm nn dn mf no np dp mj le nq nr ml li ns nt mn lm nu nv mp nw bi translated">总结</h2><p id="eca2" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">工作池让我们对代码的执行有了更多的控制。它们为我们提供了可预测性，因此我们可以规划和优化我们的代码和平台，以扩展到高吞吐量和高数据量。</p><p id="3893" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在应用程序需要迭代数据集的情况下，我建议总是使用工作池——即使是很小的数据集。使用工人池，我们现在能够在云功能中处理数百万个项目，而不会接近平台允许的极限，从而为我们提供足够的扩展空间。</p><h2 id="0323" class="ng ma iq bd mb nm nn dn mf no np dp mj le nq nr ml li ns nt mn lm nu nv mp nw bi translated">笔记</h2><ul class=""><li id="b94f" class="nx ny iq kx b ky mr lb ms le nz li oa lm ob lq oc od oe of bi translated">工人的数量应该是可配置的(例如<code class="fe my mz na nb b">env</code>变量)，允许你在你运行的每个平台上玩这个数字并达到你想要的结果。</li><li id="4dc7" class="nx ny iq kx b ky og lb oh le oi li oj lm ok lq oc od oe of bi translated">将通道大小至少设置为池中的工作线程数。这将允许数据生产者填充队列，并防止工人在数据生成时空闲等待。也使它可配置。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cd7f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="a126" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">让我们成为更好的专业人士的是从错误中学习的能力。但是从别人那里学习也同样重要。</p><p id="b6d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你走到这一步——谢谢！</p><p id="afe9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">亲爱的读者，我希望我们在这里看到的能够帮助你，避免我们在Golang的旅程中所犯的错误。</p></div></div>    
</body>
</html>