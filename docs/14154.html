<html>
<head>
<title>How To Implement the Interpreter Design Pattern for Messy Data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中实现杂乱数据的解释器设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-the-interpreter-pattern-for-messy-data-in-python-594a54a74ebb?source=collection_archive---------6-----------------------#2022-11-11">https://betterprogramming.pub/how-to-implement-the-interpreter-pattern-for-messy-data-in-python-594a54a74ebb?source=collection_archive---------6-----------------------#2022-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="db24" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帮助您从数据中获取更多价值的深度指南</h2></div><p id="357e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文描述了如何实现解释器设计模式来读取杂乱的数据。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/5eac0a170113fa8c856e507fa0ab74dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBuZc7uWwbjjFF-GUzouyg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图一。公司coop工资的前25%</p></figure><p id="b86a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图1显示了滑铁卢大学学生报告的前25%公司的平均coop工资。在本文中，我将向您展示如何一步一步地得到这个图表。</p><h1 id="1b9e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">解释器模式可以阅读语法</h1><p id="cb45" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">通常用于评估“32 * 5 + 23”等数学文本。这种模式的用处在于它如何用一组相对简单的规则执行任意的操作组合。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mo"><img src="../Images/022aefd022f4f1ef263c43878d58627f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzrkMcQVv0TtP6-jPSu9KA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图二。解释器设计模式</p></figure><p id="a6b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释器设计模式如图2所示。它从维护上下文引用的客户端开始，例如，字符串“32 * 5 + 23”。</p><p id="5d6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设计模式的主体是<code class="fe mp mq mr ms b">AbstractExpression</code>，它声明这种类型的所有对象都应该有一个解释(上下文)功能。</p><p id="f79f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从<code class="fe mp mq mr ms b">AbstractExpression</code>继承/扩展的类有两种主要类型:</p><ul class=""><li id="dec0" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe mp mq mr ms b">TerminalExpression</code>，又名<code class="fe mp mq mr ms b">LiteralExpression</code></li><li id="33ab" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mp mq mr ms b">NonTerminalExpression</code>，其中可能包含对<code class="fe mp mq mr ms b">AbstractExpression</code> s的引用</li></ul><p id="c0e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的实现将在后面描述。</p><h2 id="54ac" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">为合作基金分析手工报告的薪资数据</h2><p id="6cb7" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">根据红迪网上一个针对滑铁卢大学学生的大讨论，我们的目标是根据报道的薪水对公司进行排名。</p><blockquote class="nt nu nv"><p id="df23" class="kf kg nw kh b ki kj jr kk kl km ju kn nx kp kq kr ny kt ku kv nz kx ky kz la ij bi translated">文末源代码！</p></blockquote><p id="59ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该数据包含2021年<a class="ae oa" href="https://www.reddit.com/r/uwaterloo/comments/n4dse2/waterlooworks_spring_2021_megathread/" rel="noopener ugc nofollow" target="_blank">春季</a>和2021年<a class="ae oa" href="https://www.reddit.com/r/uwaterloo/comments/pkgmxh/waterlooworks_fall_2021_megathread/" rel="noopener ugc nofollow" target="_blank">秋季</a>的报告工资。</p><p id="1872" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个数据示例:</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="bbea" class="of ls iq ms b be og oh l oi oj">1password: 25/h (1st coop), 32/hr (3rd coop), 42/hr (5th coop?)<br/>Accedo: 24/hr (3rd coop)<br/>⁠Achievers inc: 20-25/hr<br/>⁠ADP: less than 44/hr<br/>AGF: 18.50/hr<br/>Akuna Capital: 65 USD/hour + return flight + corporate housing<br/>Amazon: $7912/mo + 1875 USD/mo stipend + relocation(?)<br/>AMD: 27/hr<br/>American Express: 34.5/hr<br/>⁠Apple: (34/hr + 1300-1500 stipend/month) (37/hr + 1350 stipend for 3A term)<br/>Arctic Wolf: 20% above coop average, 23/hr (1st coop), 34/hr (4th coop)<br/>Athos: 5000 USD/mo<br/>Atolio: 34/hr (3rd coop), 38/hr (5th coop), 42/hr (6th coop)<br/>⁠Autodesk: 24-30/hr<br/>...</span></pre><p id="9b61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是使用了许多不同的格式。以下是其中的一些:</p><ul class=""><li id="8aea" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated">x/小时</li><li id="6e67" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">X/mo</li><li id="43a1" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">美元X/月</li><li id="54ee" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">x/小时(第一次合作)、Y/小时(第三次合作)、Z/小时(第五次合作)</li><li id="dba4" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">等等。</li></ul><h2 id="27a4" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">我们希望使用CAD/mo来比较薪资排名</h2><p id="b611" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">为了比较工资，我们需要使用相同的单位，在本例中，我们将每月的工资转换为加元(CAD)。</p><p id="0af7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用以下假设来简化问题:</p><ul class=""><li id="2acc" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated">我们取范围值的平均值(例如，20–25/小时→22.5/小时)</li><li id="716c" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">我们取不同合作期限工资的平均值(“34/小时(第三次合作)、38/小时(第五次合作)、42/小时(第六次合作)”→38/小时)</li><li id="e590" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">合作社平均收入为30.0加元/小时</li></ul><h2 id="da46" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">定义抽象表达式</h2><p id="c116" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">为了解决这个问题，我们首先将<code class="fe mp mq mr ms b">AbstractExpression</code>定义如下:</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="5fc9" class="of ls iq ms b be og oh l oi oj"># expressions.py<br/><br/>class AbstractExpression(object):<br/>    def __init__(self):<br/>        '''<br/>        Returns None.<br/><br/>        __init__: None -&gt; None<br/>        '''<br/>        pass<br/>    def interpret(self):<br/>        '''<br/>        Returns the value of the expression.<br/>        <br/>        interpret: AbstractExpression -&gt; float<br/>        '''<br/>        return 0<br/>    def __repr__(self):<br/>        '''<br/>        Returns the string representation of the evaluated.<br/>        <br/>        __repr__: AbstractExpression -&gt; str<br/>        '''<br/>        return str(self.interpret())</span></pre><p id="e2ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们让<code class="fe mp mq mr ms b">interpret()</code>成为一个返回浮点值的零参数函数。我们假设在创建对象时存储了必要的上下文。这在下一节中可以看到。</p><h2 id="b05e" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">TerminalExpression通常指的是一个计算出来的数字</h2><p id="4a6c" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们将其定义如下:</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="12fc" class="of ls iq ms b be og oh l oi oj"># expressions.py<br/><br/>class LiteralExpression(AbstractExpression):<br/>    def __init__(self, string):<br/>        '''<br/>        Returns None.<br/><br/>        __init__: str -&gt; None<br/>        '''<br/>        self.string = string<br/>    def interpret(self):<br/>        '''<br/>        Returns the value of the expression.<br/><br/>        interpret: LiteralExpression -&gt; float<br/>        '''<br/>        return float(self.string)<br/><br/># Example:<br/>LiteralExpression("32").interpret() # This returns the value 32</span></pre><h1 id="5b66" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">让我们定义一个AddExpression</h1><p id="0c5f" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">现在我们已经有了基本情况，<code class="fe mp mq mr ms b">LiteralExpression</code>，让我们为我们的解释语言添加一个简单的加法操作:</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="d1db" class="of ls iq ms b be og oh l oi oj"># expressions.py<br/><br/>class AddExpression(AbstractExpression):<br/>    def __init__(self, left, right):<br/>        '''<br/>        Returns None.<br/><br/>        __init__: AddExpression -&gt; None<br/>        '''<br/>        self.left = left<br/>        self.right = right<br/>    def interpret(self):<br/>        '''<br/>        Returns the value of the expression.<br/>        <br/>        interpret: AddExpression -&gt; float<br/>        '''<br/>        return self.left.interpret() + self.right.interpret()<br/><br/># Example:<br/>AddExpression(LiteralExpression("5"), LiteralExpression("6")) # Returns 11</span></pre><p id="623b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加操作需要创建两个<code class="fe mp mq mr ms b">AbstractExpression</code>对象。如果我们用两个<code class="fe mp mq mr ms b">LiteralExpression</code>来初始化<code class="fe mp mq mr ms b">5</code>和<code class="fe mp mq mr ms b">6</code>，那么我们从<code class="fe mp mq mr ms b">interpret()</code>得到的结果是11。</p><p id="10ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最棒的是，这两个输入对象不一定是<code class="fe mp mq mr ms b">LiteralExpression</code> s，它们可以是其他复合表达式，比如<code class="fe mp mq mr ms b">MultiplyExpression</code>或更多的<code class="fe mp mq mr ms b">AddExpression</code>。</p><h2 id="20db" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">现在我们需要一个减法表达式</h2><p id="b272" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">几乎与<code class="fe mp mq mr ms b">AddExpression</code>完全一样，但我们在<code class="fe mp mq mr ms b">interpret()</code>中执行减法。</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="949f" class="of ls iq ms b be og oh l oi oj"># expressions.py<br/><br/>class SubtractExpression(AbstractExpression):<br/>    def __init__(self, left, right):<br/>        '''<br/>        Returns None.<br/><br/>        __init__: AbstractExpression AbstractExpression -&gt; None<br/>        '''<br/>        self.left = left<br/>        self.right = right<br/>    def interpret(self):<br/>        '''<br/>        Returns the value of the expression.<br/><br/>        interpret: SubtractExpression -&gt; float<br/>        '''<br/>        return self.left.interpret() - self.right.interpret()</span></pre><h2 id="9002" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">我们还需要定义MultiplyExpression</h2><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="a46b" class="of ls iq ms b be og oh l oi oj"># expressions.py<br/><br/>class MultiplyExpression(AbstractExpression):<br/>    def __init__(self, left, right):<br/>        '''<br/>        Returns None.<br/><br/>        __init__: AbstractExpression AbstractExpression -&gt; None<br/>        '''<br/>        self.left = left<br/>        self.right = right<br/>    def interpret(self):<br/>        '''<br/>        Returns the value of the expression.<br/><br/>        interpret: MultiplyExpression -&gt; float<br/>        '''<br/>        return self.left.interpret() * self.right.interpret()</span></pre><p id="8e0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在我们的例子中，我们不需要除法表达式，但现在创建它应该是微不足道的。</p><h2 id="6458" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">我们还定义了一些其他的表达式</h2><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="5f72" class="of ls iq ms b be og oh l oi oj"># expressions.py<br/><br/>class PercentAboveExpression(AbstractExpression):<br/>    '''<br/>    X% above Y --&gt; (Y) * (1 + X)<br/>    '''<br/>    def __init__(self, left, right):<br/>        '''<br/>        Returns None.<br/><br/>        __init__: AbstractExpression AbstractExpression -&gt; None<br/>        '''<br/>        self.left = left<br/>        self.right = right<br/>    def interpret(self):<br/>        '''<br/>        Returns the value of the expression.<br/><br/>        interpret: PercentAboveExpression -&gt; float<br/>        '''<br/>        return (self.right.interpret()) * \<br/>            (1 + self.left.interpret() / 100.0)</span></pre><pre class="ok ob ms oc bn od oe bi"><span id="43a4" class="of ls iq ms b be og oh l oi oj"># expressions.py<br/><br/>class AverageExpression(AbstractExpression):<br/>    def __init__(self, array):<br/>        '''<br/>        Returns None.<br/><br/>        __init__: (list AbstractExpression) -&gt; None<br/>        '''<br/>        self.array = array<br/>    def interpret(self):<br/>        '''<br/>        Returns the value of the expression.<br/><br/>        interpret: AverageExpression -&gt; float<br/>        '''<br/>        sums = list(filter(<br/>            lambda x: x != 0, [x.interpret() for x in self.array]<br/>        ))<br/>        return sum(sums) / len(sums) if (len(sums) &gt; 0) else 0</span></pre><p id="7bff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们需要定义两个附加的表达式:</p><ul class=""><li id="6a0d" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe mp mq mr ms b">PercentAboveExpression</code>，计算文本，如“高于合作平均值20%”</li><li id="1f19" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mp mq mr ms b">AverageExpression</code>，计算“20–25/小时”和“34/小时(第三次合作)、38/小时(第五次合作)、42/小时(第六次合作)”的平均值</li></ul><h2 id="6b17" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">添加解析器</h2><p id="1c56" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">既然我们已经定义了<code class="fe mp mq mr ms b">AbstractExpression</code>及其实现，我们需要编写一个函数将输入字符串转换成<code class="fe mp mq mr ms b">Expression</code>对象。</p><p id="ebd7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们利用了问题的一些性质。也就是说，我们的目标是:</p><ol class=""><li id="3805" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la ol mz na nb bi translated">删除不必要的文本</li><li id="752d" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la ol mz na nb bi translated">将短语<code class="fe mp mq mr ms b">/year</code>、<code class="fe mp mq mr ms b">/yr</code>和<code class="fe mp mq mr ms b">/y</code>的变体转换为相同的值</li><li id="19b1" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la ol mz na nb bi translated">解释短语，将其转换成正确的表达方式</li></ol><p id="0b1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先在一个<code class="fe mp mq mr ms b">constants.py</code>文件中定义以下常量:</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="11d9" class="of ls iq ms b be og oh l oi oj"># contants.py<br/><br/>PER_HOUR = 1<br/><br/>PER_HR_TO_PER_MO = 40 * 4.34524     # 40 hrs a week, 4.34524 wks a month<br/>PER_MO_TO_PER_HR = (                # working hours in a month<br/>    1 / PER_HR_TO_PER_MO<br/>)             <br/><br/>PER_YEAR_TO_PER_HR = (              # working hours in a year<br/>    1 / (12 * PER_HR_TO_PER_MO)<br/>)    <br/>PER_WEEK_TO_PER_HR = 1 / 40         # working hours in a week<br/>STIPEND_TO_PER_HR = (               # 4-month co-op<br/>    1 / 4 / PER_HR_TO_PER_MO<br/>)       <br/><br/>COOP_AVERAGE = {<br/>    "2021": {<br/>        "F": "30.0",<br/>        "S": "30.0"<br/>    }<br/>}<br/><br/>CURRENCY_CONVERTER = {<br/>    "CAD": 1,<br/>    "USD": 1.26,<br/>    "¥": 0.01094<br/>}<br/><br/>INPUT_FOLDER = "inputs"<br/>OUTPUT_FOLDER = "outputs"</span></pre><p id="077e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们定义文本清理函数<code class="fe mp mq mr ms b">remove_articles(string)</code>和<code class="fe mp mq mr ms b">remove_symbols(string)</code></p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="d3b0" class="of ls iq ms b be og oh l oi oj"># helpers.py<br/><br/>def removeSymbols(string):<br/>    '''<br/>    Returns a string with all symbols removed.<br/>    <br/>    remove_symbols: Str -&gt; Str<br/>    '''<br/>    string = string.replace("$", "")<br/>    string = string.replace("\"", "")<br/>    string = string.replace("~", "")<br/>    return string</span></pre><p id="a4f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建一个名为<code class="fe mp mq mr ms b">convert_currency(string)</code>的函数来转换货币</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="0681" class="of ls iq ms b be og oh l oi oj"># helpers.py<br/><br/>def convert_currency(string):<br/>    '''<br/>    Returns a string with all currencies converted to CAD.<br/><br/>    convert_currency: Str -&gt; Str<br/>    '''<br/>    # For each key in CURRENCY_CONVERTER, replace with value<br/>    for key in CURRENCY_CONVERTER:<br/>        lowered_key = key.lower()<br/>        uppered_key = key.upper()<br/>        # Special case for yen<br/>        if lowered_key == "¥":<br/>            string = string.replace(<br/>                lowered_key, <br/>                f"{CURRENCY_CONVERTER[uppered_key]} * "<br/>            )<br/>        else:<br/>            string = string.replace(<br/>                lowered_key, <br/>                CURRENCY_CONVERTER[uppered_key]<br/>            )<br/>    return string</span></pre><p id="bf0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还定义了一个函数来将变量转换为公共值<code class="fe mp mq mr ms b">fix_variations(string)</code></p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="5160" class="of ls iq ms b be og oh l oi oj"># helpers.py<br/><br/>def fix_variations(string):    <br/>    '''<br/>    Returns a string with all variations such as <br/>    /year, /yr /y replaced with multiplications with numbers.<br/><br/>    fix_variations: Str -&gt; Str<br/>    '''<br/>    # /yr<br/>    string = string.replace("/year", f" * {PER_YEAR_TO_PER_HR}")<br/>    string = string.replace("/yr", f" * {PER_YEAR_TO_PER_HR}")<br/>    string = string.replace("/y", f" * {PER_YEAR_TO_PER_HR}")<br/>    string = string.replace("annual", f" * {PER_YEAR_TO_PER_HR}")<br/>    string = string.replace("/annum", f" * {PER_YEAR_TO_PER_HR}")<br/>    string = string.replace("/a", f" * {PER_YEAR_TO_PER_HR}")<br/><br/>    # If X/hr regex (convert to /mo)<br/>    string = string.replace("/hour", f" * {PER_HOUR}")<br/>    string = string.replace("/hr", f" * {PER_HOUR}")<br/>    string = string.replace("/h", f" * {PER_HOUR}")<br/><br/>    # Else if X/mo<br/>    string = string.replace("stipend/month", f" * {PER_MO_TO_PER_HR}")<br/>    string = string.replace("/month", f" * {PER_MO_TO_PER_HR}")<br/>    string = string.replace("/mo", f" * {PER_MO_TO_PER_HR}")<br/>    <br/>    # Else if X/week or X/wk<br/>    string = string.replace("/week", f" * {PER_WEEK_TO_PER_HR}")<br/>    string = string.replace("/wk", f" * {PER_WEEK_TO_PER_HR}")<br/>    string = string.replace("/w", f" * {PER_WEEK_TO_PER_HR}")<br/><br/>    # Else other cases<br/>    string = string.replace("relocation", f" * {STIPEND_TO_PER_HR}")<br/>    string = string.replace("stipend", f" * {STIPEND_TO_PER_HR}")<br/>    string = string.replace("signing bonus", f" * {STIPEND_TO_PER_HR}")<br/>    string = string.replace("bonus", f" * {STIPEND_TO_PER_HR}")<br/><br/>    string = string.replace("s", "")<br/><br/>    # Handle thousands<br/>    string = string.replace("k", " * 1000")<br/>    return string</span></pre><p id="66b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些辅助函数可以用正则表达式更简洁地完成，但为了便于阅读，它们是这样编码的。</p><p id="b715" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要一个函数来获取给定期限和年份的coop平均值。看起来是这样的:</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="2fa9" class="of ls iq ms b be og oh l oi oj"># helpers.py<br/><br/>def get_coop_average(term, year):<br/>    '''<br/>    Returns the average coop salary for a given term <br/>    and year as a float in CAD PER HOUR units.<br/><br/>    get_coop_average: Str Str -&gt; Float<br/>    '''<br/>    return COOP_AVERAGE[str(year)][str(term)]</span></pre><p id="ce37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以用它来创建递归函数<code class="fe mp mq mr ms b">parse_expression(string)</code></p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="67fc" class="of ls iq ms b be og oh l oi oj">#salary_parser.py<br/><br/>import re<br/>from expressions import AbstractExpression, AddExpression, \<br/>    SubtractExpression, PercentAboveExpression, AverageExpression, \<br/>    MultiplyExpression, LiteralExpression<br/>from helpers import remove_symbols<br/><br/>def parse_expression(string):<br/>    '''<br/>    Returns an AbstractExpression representing the given string.<br/>    <br/>    Requires:<br/>        - string is a valid salary expression<br/>        <br/>    parse_expression: Str -&gt; AbstractExpression<br/>    '''<br/>    string = string.strip()<br/>    # Remove symbols<br/>    string = remove_symbols(string)<br/><br/>    if (string == ""): return AbstractExpression() # FIXME<br/>    <br/>    # parse any parenthesis if any<br/>    result = re.search(r"(\(.*?\)|\(.*$)", string)<br/>    if (result):<br/>        resultString = result.string[result.start()+1:result.end()-1]<br/>        value = parse_expression(resultString).interpret()<br/>        string = string[:result.start()] + " or " + \<br/>            str(value) + " " + string[result.end():]<br/>        return parse_expression(string)<br/><br/>    result = re.search(r"(\[.*?\]|\[.*$)", string)<br/>    if (result):<br/>        string = string[:result.start()] + string[result.end():]<br/>        return parse_expression(string)<br/>    <br/>    if ("," in string or " or " in string):<br/>        return AverageExpression([<br/>            parse_expression(s) for s <br/>            in re.split(r",| or ", string)<br/>        ])<br/><br/>    if ("every add" in string): return AbstractExpression()<br/><br/>    if ("% above" in string):<br/>        parts = string.split("% above")<br/>        leftString = parts[0]<br/>        rightString = parts[1]<br/>        return PercentAboveExpression(<br/>            parse_expression(leftString), <br/>            parse_expression(rightString)<br/>        )<br/><br/>    if ("+" in string):<br/>        parts = string.split("+")<br/>        leftString = parts[0]<br/>        rightString = "+".join(parts[1:])<br/>        return AddExpression(<br/>            parse_expression(leftString), <br/>            parse_expression(rightString)<br/>        )<br/><br/>    if ("above" in string):<br/>        parts = string.split("above")<br/>        leftString = parts[0]<br/>        rightString = "above".join(parts[1:])<br/>        return AddExpression(<br/>            parse_expression(leftString), <br/>            parse_expression(rightString)<br/>        )<br/>    <br/>    if ("below" in string):<br/>        parts = string.split("below")<br/>        leftString = parts[0]<br/>        rightString = "below".join(parts[1:])<br/>        return SubtractExpression(<br/>            parse_expression(rightString), <br/>            parse_expression(leftString)<br/>        )<br/><br/>    if ("*" in string):<br/>        parts = string.split("*")<br/>        leftString = parts[0]<br/>        rightString = "*".join(parts[1:])<br/>        return MultiplyExpression(<br/>            parse_expression(leftString), <br/>            parse_expression(rightString)<br/>        )<br/>    <br/>    if ("to" in string):<br/>        parts = string.split("to")<br/>        leftString = parts[0]<br/>        rightString = "to".join(parts[1:])<br/>        return AverageExpression([<br/>            parse_expression(leftString), <br/>            parse_expression(rightString)<br/>        ])<br/><br/>    if (" " in string):<br/>        return AverageExpression([<br/>            parse_expression(s) for s <br/>            in string.split(" ")<br/>        ])<br/><br/>    if (string.replace('.','',1).isdigit()):<br/>        return LiteralExpression(string)<br/><br/>    return AbstractExpression()</span></pre><p id="b0a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mp mq mr ms b">parse_expession(string)</code>函数中的操作顺序对于确保乘法在计算结果时“首先”发生非常重要。</p><p id="1658" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们使用了如下关键字:</p><ul class=""><li id="d7a4" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe mp mq mr ms b">% above</code>创造出一个<code class="fe mp mq mr ms b">PercentAboveExpression</code></li><li id="f6cc" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mp mq mr ms b">+</code>创造出一个<code class="fe mp mq mr ms b">AddExpression</code></li><li id="75cb" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mp mq mr ms b">below</code>为一个<code class="fe mp mq mr ms b">SubtractExpression</code></li><li id="909f" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe mp mq mr ms b">*</code>为一个<code class="fe mp mq mr ms b">MultiplyExpression</code></li></ul><p id="b790" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数的返回值是一个表达式对象，我们可以<code class="fe mp mq mr ms b">interpret()</code>。</p><p id="9422" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，为了解析文本中的行，我们有如下所示的主代码:</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="7971" class="of ls iq ms b be og oh l oi oj"># main.py<br/><br/>import argparse<br/>import os<br/>import re<br/>import json<br/>import pandas as pd<br/>from constants import PER_HR_TO_PER_MO, INPUT_FOLDER, OUTPUT_FOLDER<br/>from helpers import get_coop_average, remove_articles, fix_variations<br/>from salary_parser import parse_expression<br/>from plotter import plot    <br/><br/>def main(filename, term, year):<br/>    '''<br/>    Returns None.<br/>    Reads the file in path and gets the average salary for<br/>    each company in the file for the given term and year.<br/>    The function then saves this data to a csv file.<br/>    Also saves a bar chart for the company salaries.<br/><br/>    Effects:<br/>        - Reads the file in path<br/>        - Writes to {OUTPUT_FOLDER}/output.csv and <br/>        {OUTPUT_FOLDER}/output_top_25_percent.csv<br/>        - Writes to {OUTPUT_FOLDER}/output.png and <br/>        {OUTPUT_FOLDER}/output_top_25_percent.png<br/><br/>    Requires:<br/>        - term is F, W, or S<br/><br/>    main: Str Str Str -&gt; None<br/>    '''<br/>    companies = {}<br/><br/>    path = os.path.join(INPUT_FOLDER, filename)<br/><br/>    # Ensure input folder is created<br/>    if not os.path.exists(INPUT_FOLDER):<br/>        os.makedirs(INPUT_FOLDER)<br/><br/>    # Perform the analysis<br/>    with open(path, 'r',  encoding="utf8") as f:<br/>        lines = f.readlines()<br/>        for line in lines:<br/>            if (len(line.strip()) == 0): continue<br/>            line_parts = line.split(": ")<br/>            company = line_parts[0]<br/>            # Word joiner character removal<br/>            company = company.replace("\u2060", "") <br/><br/>            salary_string = line_parts[1].replace("\n", "")<br/>            salary_string = re.sub(<br/>                r"(\d),(\d{3})",r"\g&lt;1&gt;\g&lt;2&gt;", <br/>                salary_string<br/>            )  <br/>            salary_string = salary_string.lower()    <br/>            salaries = []<br/>        <br/>            salary_string_part = salary_string<br/><br/>            salary_string_part = remove_articles(salary_string_part)<br/>            <br/>            salary_string_part = fix_variations(salary_string_part)<br/><br/>            salary_string_part.replace(<br/>                "coop average", <br/>                get_coop_average(term, year)<br/>            )<br/><br/>            salary = parse_expression(salary_string_part).interpret()<br/>            if (salary != 0): salaries.append(salary)<br/>            <br/>            average = (<br/>                sum(salaries) / len(salaries) \<br/>                if (len(salaries) &gt; 0) else 0<br/>            )<br/>            average = average * PER_HR_TO_PER_MO<br/><br/>            companies[company] = {"CAD/mo": average}<br/><br/>    pd.options.display.float_format = "{:,.0f}".format<br/><br/>    df = pd.read_json(<br/>        json.dumps(<br/>            companies, indent=4, sort_keys=True<br/>        ), <br/>        orient='index'<br/>    )<br/>    df = df.sort_values(by=['CAD/mo'], ascending=False)<br/>    df = df['CAD/mo'].apply(lambda x: int(x))<br/><br/>    # Ensure output folder is created<br/>    if not os.path.exists(OUTPUT_FOLDER):<br/>        os.makedirs(OUTPUT_FOLDER)<br/><br/>    # Save the results<br/>    output_path = os.path.join(OUTPUT_FOLDER, "output.csv")<br/>    df.to_csv(output_path, index_label="Company")<br/><br/>    output_path_top_25 = os.path.join(<br/>        OUTPUT_FOLDER, <br/>        "output_top_25_percent.csv"<br/>    )<br/>    df25 = df.head(int(df.count() * 0.25))<br/>    df25.to_csv(output_path_top_25, index_label="Company")<br/><br/>    # Plot the graph<br/>    plot(df, "output.png")<br/>    plot(df25, "output_top_25_percent.png")<br/><br/>if __name__ == '__main__':<br/>    parser = argparse.ArgumentParser()<br/>    parser.add_argument(<br/>        'filename', <br/>        type=str, <br/>        help="File name of input file from input folder"<br/>    )<br/>    parser.add_argument('term', type=str, help="Term (F/W/S)")<br/>    parser.add_argument('year', type=str, help="Year (e.g. 2021)")<br/>    args = parser.parse_args()<br/>    main(args.filename, args.term, args.year)</span></pre><p id="55ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们获得了每个公司每小时的平均值，将其转换为每月，然后将其存储在Pandas数据帧中。然后我们将数据框导出到两个CSV文件中，一个是<code class="fe mp mq mr ms b">output.csv</code>中排名公司的完整列表，另一个是<code class="fe mp mq mr ms b">output_top_25_percent.csv</code>中排名前25%的公司。</p><h2 id="a48c" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">现在来一个可视化！</h2><p id="ab28" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">最后，我们使用以下代码绘制一个可视化图形:</p><pre class="lc ld le lf gt ob ms oc bn od oe bi"><span id="7db6" class="of ls iq ms b be og oh l oi oj"># plotter.py<br/><br/>import os<br/>import pandas as pd<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>from constants import OUTPUT_FOLDER<br/><br/>def plot(df, output_filename):<br/>    '''<br/>    Returns None.<br/>    Plots the data in the dataframe df.<br/>    Saves the output to {OUTPUT_FOLDER}/{output_filename}<br/>    <br/>    Effects:<br/>        - Writes to {OUTPUT_FOLDER}/{output_filename}<br/>    <br/>    Requires: <br/>        - df is a dataframe with two columns: Company and CAD/mo<br/>        <br/>    plot: DataFrame Str -&gt; None<br/>    '''<br/>    print(df.reset_index())<br/>    # Plot the data<br/>    sns.set(style="whitegrid")<br/>    fig, ax = plt.subplots(figsize=(20, 0.25 * len(df)))<br/>    g = sns.barplot(<br/>        data=df.reset_index(), y="index", x="CAD/mo", <br/>        ax=ax, palette="blend:limegreen,dodgerblue"<br/>    )<br/>    g.set_title("Average Co-op Salaries")<br/>    g.set_xlabel("CAD/mo")<br/>    g.set_ylabel("Company")<br/><br/>    fig.tight_layout()<br/><br/>    path = os.path.join(OUTPUT_FOLDER, output_filename)<br/>    fig.savefig(path)</span></pre><h2 id="df00" class="nh ls iq bd lt ni nj dn lx nk nl dp mb ko nm nn md ks no np mf kw nq nr mh ns bi translated">在哪里可以找到更多的设计模式</h2><p id="9f1e" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这只是展示面向对象编程能力的众多设计模式之一。我还在另一篇文章中展示了如何实现<a class="ae oa" href="https://medium.com/swlh/how-to-implement-the-memento-design-pattern-for-reactjs-1eb6b76c39c0" rel="noopener"> Memento模式。如果你想学习更多关于设计模式的知识，我强烈推荐Erich Gamma等人(四人帮)的书<em class="nw">Design Patterns:Elements of Reusable Object-Oriented Software</em>。我甚至称之为编程的圣经。</a></p><h1 id="112a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">GitHub知识库</h1><p id="c543" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">请随意查看这里的源代码:<a class="ae oa" href="https://github.com/justinsj/interpreter-coop-salaries" rel="noopener ugc nofollow" target="_blank">https://github.com/justinsj/interpreter-coop-salaries</a></p><p id="f3e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这篇文章或者从中有所收获，请继续关注！</p><p id="ef7f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你也有任何建议，请在LinkedIn<a class="ae oa" href="https://www.linkedin.com/in/justin-sj/" rel="noopener ugc nofollow" target="_blank">上的评论或消息中告诉我！</a></p></div></div>    
</body>
</html>