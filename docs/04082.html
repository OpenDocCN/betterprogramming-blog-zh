<html>
<head>
<title>Save Data in Your Local Database Using the Room Persistence Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Room Persistence库将数据保存在本地数据库中</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/save-data-in-your-local-database-using-the-room-persistence-library-a9630c977234?source=collection_archive---------3-----------------------#2020-03-23">https://betterprogramming.pub/save-data-in-your-local-database-using-the-room-persistence-library-a9630c977234?source=collection_archive---------3-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0837" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">直接使用SQLite API的更好的替代方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d432f217f2955a92768c87e8bf8d737a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*KoNREm-uuyv4i5tp.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由<a class="ae ku" href="https://developer.android.com/training/data-storage/room" rel="noopener ugc nofollow" target="_blank"> Android开发者</a>提供。</p></figure><p id="6407" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过阅读本文，您将了解如何使用<a class="ae ku" href="https://developer.android.com/topic/libraries/architecture/room" rel="noopener ugc nofollow" target="_blank"> Room persistence库</a>在Android Studio中实现自己的本地数据库。这个库允许您执行创建、读取、更新和删除操作，就像您在SQLite API中执行操作一样，而且更简洁。我强烈建议使用Room而不是SQLite，原因如下:</p><ul class=""><li id="516d" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">Room在SQLite上提供了一个抽象层，允许流畅的数据库访问，同时利用SQLite的全部功能。</li><li id="e1ab" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">该库可帮助您在运行应用程序的设备上创建应用程序数据的缓存。这个缓存作为应用程序的唯一真实来源，允许用户查看应用程序中关键信息的一致副本，而不管用户是否有互联网连接。</li></ul><p id="79b7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">房间中有三个主要组件:</p><ul class=""><li id="e7e5" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">Database </code> —包含数据库容器，并作为应用程序持久关系数据底层连接的主要访问点。</li><li id="7059" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">Entity</code> —表示数据库中的一个表。</li><li id="7f13" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">DAO</code> —包含用于访问数据库的方法。</li></ul><p id="2740" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">继续下一节，开始安装必要的依赖项。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b9b1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设置</h1><p id="fec0" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">确保您已经安装了Android Studio并设置了必要的SDK。在这篇文章中，我将使用Java。如果您打算使用Kotlin，请查阅官方文档并进行相应的修改。在<code class="fe mf mg mh mi b">build.gradle (Module: app)</code>文件中，将以下代码添加到依赖项中。注意，有两个<code class="fe mf mg mh mi b">build.gradle</code>文件。第一个是<code class="fe mf mg mh mi b">Project</code>的刻度，第二个是<code class="fe mf mg mh mi b">Module</code>的刻度。</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="4ae4" class="nr mr it mi b gy ns nt l nu nv">dependencies {<br/>  def room_version = "2.2.5"<br/><br/>  implementation "androidx.room:room-runtime:$room_version"<br/>  annotationProcessor "androidx.room:room-compiler:$room_version" // For Kotlin use kapt instead of annotationProcessor<br/><br/>  // optional - Kotlin Extensions and Coroutines support for Room<br/>  implementation "androidx.room:room-ktx:$room_version"<br/><br/>  // optional - RxJava support for Room<br/>  implementation "androidx.room:room-rxjava2:$room_version"<br/><br/>  // optional - Guava support for Room, including Optional and ListenableFuture<br/>  implementation "androidx.room:room-guava:$room_version"<br/><br/>  // Test helpers<br/>  testImplementation "androidx.room:room-testing:$room_version"<br/>}</span></pre><p id="df48" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">记得同步gradle，以确保依赖关系已注册。转到下一节，开始创建必要的文件。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7523" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">履行</h1><h2 id="2db6" class="nr mr it bd ms nw nx dn mw ny nz dp na le oa ob nc li oc od ne lm oe of ng og bi translated">用户</h2><p id="ec59" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">首先，让我们创建一个名为<code class="fe mf mg mh mi b">User.java</code>的新Java文件。添加以下进口声明。<code class="fe mf mg mh mi b">Date</code>将用于在每次插入时生成时间戳。</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="43f1" class="nr mr it mi b gy ns nt l nu nv"><strong class="mi iu">import </strong>androidx.room.ColumnInfo;<br/><strong class="mi iu">import </strong>androidx.room.Entity;<br/><strong class="mi iu">import </strong>androidx.room.PrimaryKey;</span><span id="4796" class="nr mr it mi b gy oh nt l nu nv"><strong class="mi iu">import </strong>java.text.SimpleDateFormat;<br/><strong class="mi iu">import </strong>java.util.Date;</span></pre><p id="22aa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将创建一个非常简单的表，其中包含以下数据:</p><ul class=""><li id="7eac" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">UID</code> —数据的唯一id。用作主键，并在每次插入时自动递增。</li><li id="cc43" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">Name</code> —字符串列。你可以把它设置成你喜欢的任何东西。</li><li id="443f" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">Timestamp</code> —插入期间的完整时间戳。</li></ul><p id="5872" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在类内部，添加以下构造函数。构造函数是可选的，但是我创建它们是为了以后更容易实例化<code class="fe mf mg mh mi b">User</code>对象。即使您不打算使用默认值，也需要一个空的构造函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="0a35" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">添加以下变量:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="34d0" class="nr mr it mi b gy ns nt l nu nv">@PrimaryKey(autoGenerate = <strong class="mi iu">true</strong>)<br/><strong class="mi iu">public int uid</strong>;<br/><br/>@ColumnInfo(name = <strong class="mi iu">"timestamp"</strong>)<br/><strong class="mi iu">public long timestamp</strong>;<br/><br/>@ColumnInfo(name = <strong class="mi iu">"name"</strong>)<br/><strong class="mi iu">public String name</strong>;</span></pre><ul class=""><li id="d2eb" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">PrimaryKey</code> —这个装饰器将当前变量设置为表格的主键。</li><li id="222e" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">autoGenerate</code> —确定该值是否会在每次插入数据时自动递增。</li><li id="cb82" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">ColumnInfo</code> —将列的名称设置为另一个名称。默认情况下，它将使用变量名作为列名。</li></ul><p id="c35f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我添加了另外两个可选函数，用于调试目的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1545" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mf mg mh mi b">User.java</code>的完整代码如后的<a class="ae ku" href="https://gist.github.com/wfng92/1d27eefd3acaf6eeef9dc46226a04574" rel="noopener ugc nofollow" target="_blank">所示:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="ca16" class="nr mr it bd ms nw nx dn mw ny nz dp na le oa ob nc li oc od ne lm oe of ng og bi translated">用户岛</h2><p id="4d18" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">创建另一个名为<code class="fe mf mg mh mi b">UserDao.java</code>的文件。这包含访问数据库的用户访问对象。让我们从进口申报开始:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="3192" class="nr mr it mi b gy ns nt l nu nv"><strong class="mi iu">import </strong>java.util.List;<br/><br/><strong class="mi iu">import </strong>androidx.room.Dao;<br/><strong class="mi iu">import </strong>androidx.room.Delete;<br/><strong class="mi iu">import </strong>androidx.room.Insert;<br/><strong class="mi iu">import </strong>androidx.room.Query;</span></pre><p id="b229" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">将类更改为接口，并添加以下代码。我创建了更多的函数来:</p><ul class=""><li id="8397" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">从表中获取所有数据。</li><li id="39a4" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">根据UID从表中获取所有行。</li><li id="1037" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">将数据行插入表格。</li><li id="0d41" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">从表中删除一行。</li><li id="a24d" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">清除表格中的所有数据。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><ul class=""><li id="a72b" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">Query</code> —这个装饰器充当您打算在执行函数时运行的SQL查询。您可以在其中进行任何读/写查询，包括更新、插入和删除。如果您打算为条件语句传递参数，则必须在查询中在它前面添加一个冒号。</li><li id="950e" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">Delete</code> —一个用于从表中删除数据的装饰器。</li><li id="ffab" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><code class="fe mf mg mh mi b">Insert</code> —用于将数据插入表格的装饰器。</li></ul><p id="91c3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mf mg mh mi b">UserDao.java</code>的完整代码如后的<a class="ae ku" href="https://gist.github.com/wfng92/c1ee7f09bf8f37ab9f773a210040ad74" rel="noopener ugc nofollow" target="_blank">所示:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="f9a5" class="nr mr it bd ms nw nx dn mw ny nz dp na le oa ob nc li oc od ne lm oe of ng og bi translated">应用数据库</h2><p id="56d2" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">您需要创建一个数据库实例。建议使用单例模式，因为这个数据库实例是资源密集型的。创建一次，然后在整个应用程序中共享。创建一个名为<code class="fe mf mg mh mi b">AppDatabase.java</code>的新文件，并添加以下导入声明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="6f71" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使其成为扩展<code class="fe mf mg mh mi b">RoomDatabase</code>的抽象类:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="50fd" class="nr mr it mi b gy ns nt l nu nv">@Database(entities = {User.<strong class="mi iu">class</strong>}, version = 1)<br/><strong class="mi iu">public abstract class </strong>AppDatabase <strong class="mi iu">extends </strong>RoomDatabase {<br/><br/>}</span></pre><p id="14fb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">创建一个变量作为实例，并用您喜欢的线程数初始化<code class="fe mf mg mh mi b">ExecutorService</code>:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="0aea" class="nr mr it mi b gy ns nt l nu nv"><strong class="mi iu">private static volatile </strong>AppDatabase <em class="ok">INSTANCE</em>;<br/><strong class="mi iu">private static final int <em class="ok">NUMBER_OF_THREADS </em></strong>= 1;<br/><strong class="mi iu">static final </strong>ExecutorService <strong class="mi iu"><em class="ok">databaseWriteExecutor </em></strong>=<br/>        Executors.<em class="ok">newFixedThreadPool</em>(<strong class="mi iu"><em class="ok">NUMBER_OF_THREADS</em></strong>);</span></pre><p id="ddf6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">创建一个返回实例的静态函数。在函数内部，添加<code class="fe mf mg mh mi b">databaseBuilder</code>语句来初始化数据库。我将使用<code class="fe mf mg mh mi b">user_database</code>作为数据库的名称。请随意使用您喜欢的任何名称:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="ff2d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mf mg mh mi b">AppDatabase.java</code>的完整代码如后的<a class="ae ku" href="https://gist.github.com/wfng92/f43e62639d22570866c66a60d8d7448c" rel="noopener ugc nofollow" target="_blank">所示:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="239a" class="nr mr it bd ms nw nx dn mw ny nz dp na le oa ob nc li oc od ne lm oe of ng og bi translated">主要活动</h2><p id="a307" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">在<code class="fe mf mg mh mi b">MainActivity</code>类中，获取<code class="fe mf mg mh mi b">AppDatabase</code>的单例实例，并调用适当的函数。请注意，您必须在主线程之外完成它——类似于您如何使用<code class="fe mf mg mh mi b">Runnable</code>更新UI。在这种情况下，我将使用<code class="fe mf mg mh mi b">AsyncTask</code>助手。以下示例从表中选择所有数据，并将其存储在用户列表中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="fc53" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们再看一个如何插入数据的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="e2e5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">只需将所有更新UI的代码放入<code class="fe mf mg mh mi b">run</code>函数中，就万事大吉了。</p><p id="c241" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在最新的更新中，Android中的文档建议使用<code class="fe mf mg mh mi b">java.util.concurrent</code>来代替，因为<code class="fe mf mg mh mi b">AsyncTask</code>在API级别r中已被否决。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ol"><img src="../Images/ca6b445d1ec5564f166038ccea861a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WF8XsxnqK72RTjXFt2KPrA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片取自<a class="ae ku" href="https://developer.android.com/reference/android/os/AsyncTask" rel="noopener ugc nofollow" target="_blank">安卓</a></p></figure><p id="1993" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">记得我们上次其实已经声明了一个叫做<code class="fe mf mg mh mi b">databaseWriteExecutor</code>的<code class="fe mf mg mh mi b">ExecutorService</code>。我们可以用它来代替<code class="fe mf mg mh mi b">AsyncTask</code>。</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="ae2f" class="nr mr it mi b gy ns nt l nu nv">private static final int <em class="ok">NUMBER_OF_THREADS </em>= 1;<br/>static final ExecutorService <em class="ok">databaseWriteExecutor </em>=<br/>        Executors.<em class="ok">newFixedThreadPool</em>(<em class="ok">NUMBER_OF_THREADS</em>);</span></pre><p id="6d57" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">只需调用执行函数并传递一个可运行的对象</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="7088" class="nr mr it mi b gy ns nt l nu nv">AppDatabase.<em class="ok">databaseWriteExecutor</em>.execute(new Runnable() {<br/>    @Override<br/>    public void run() {<br/>        List&lt;User&gt; users = AppDatabase.<em class="ok">getDatabase</em>(getApplicationContext()).userDao().getAll();<br/>        for(User user : users) {<br/>            Log.<em class="ok">d</em>("User", u.getDebugString());<br/>        }<br/>    }<br/>});</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c565" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="23e6" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">让我们回顾一下今天所学的内容。我们首先简要介绍了房间持久性库。</p><p id="9207" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">之后，我们在<code class="fe mf mg mh mi b">build.gradle(Module: app)</code>文件的依赖项中编写了必要的代码。</p><p id="50b8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一旦gradle被同步，我们就开始实现三个类。<code class="fe mf mg mh mi b">User</code>类用于定义表格的结构。<code class="fe mf mg mh mi b">UserDao</code>包含与数据库交互的必要方法。<code class="fe mf mg mh mi b">AppDatabase</code>保存将在应用程序的其他部分调用的单例实例。</p><p id="f9f6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，我们通过将函数包装在<code class="fe mf mg mh mi b">AsyncTask</code>的<code class="fe mf mg mh mi b">Runnable</code>函数中来执行<code class="fe mf mg mh mi b">MainActivity</code>中的代码。</p><p id="355a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢阅读这篇文章。希望下一部能再见到你！</p></div></div>    
</body>
</html>