<html>
<head>
<title>You Don’t Have to Lose Optimization for Micro-Frontends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不必失去微前端的优化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/you-dont-have-to-lose-optimization-for-micro-frontends-60a63d5f94fe?source=collection_archive---------6-----------------------#2020-03-26">https://betterprogramming.pub/you-dont-have-to-lose-optimization-for-micro-frontends-60a63d5f94fe?source=collection_archive---------6-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1553" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种从manifest.json逐步加载分块微前端的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14cc2e3fe4fcdd353efc959dd3e48495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmRjHhWfKy-yMIjQQpDNlA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/photos/p-_RJY6hN3E" rel="noopener ugc nofollow" target="_blank">托马斯·威廉姆斯</a>在<a class="ae ky" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="cd2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在“<a class="ae ky" href="https://medium.com/better-programming/5-steps-to-turn-a-random-react-application-into-a-micro-frontend-946718c147e7" rel="noopener">将随机React应用程序转变为微前端的5个步骤</a>之后，一位读者问我们:</p><blockquote class="lv lw lx"><p id="5ac8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">在项目太大时，如果在加载时不拆分代码，那么它就变得难以扩展并且会对UX产生不好的影响。</p></blockquote><p id="6149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，这是一个有效的陈述。我们必须解决这个问题。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9ea6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">代码是如何工作的？</h1><p id="6d0a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在“<a class="ae ky" href="https://medium.com/better-programming/3-steps-to-turn-a-random-react-application-into-a-micro-frontend-container-a80e33b6a066" rel="noopener">将随机React应用程序转变为微前端容器的3个步骤</a>中，我们展示了微前端是如何工作的。微前端作为独立的应用程序运行。在捆绑阶段或运行时，这些应用程序被加载到微前端容器中。应用程序容器运行它们，就好像这些微前端是它自己的组件一样，并向用户提供无缝的工作流。</p><p id="43e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的基本示例中，有一个微前端应用程序和一个应用程序容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/23e8b78c480b25e9e6dc1d7af4391fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sj9MAnsiw5_Aymm3.png"/></div></div></figure><p id="4cdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这转化为下图，左边是一个微前端应用，右边是一个应用容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/50346e9d1d1b11aa8831b76bec07299b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_n3W8_-6Uz5vfeoUevqvTg.png"/></div></div></figure><p id="c939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让它工作，我们禁用了块优化，它将代码分割成小块，以便逐步加载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/d59fa3bfa05f880756fc7321c0c9cb28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IR8l2Wjy69jfXHMC.png"/></div></div></figure><p id="5162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们重新启用块优化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/92e9c776fb180a9be6b7f7313732eb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eX_b5vaGai4jJbBd.png"/></div></div></figure><p id="f70a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在怎么办？</p><p id="cb79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要修改<a class="ae ky" href="https://camjackson.net/" rel="noopener ugc nofollow" target="_blank"> Cam Jackson </a>的<code class="fe nk nl nm nn b"><a class="ae ky" href="https://github.com/micro-frontends-demo/container/blob/master/src/MicroFrontend.js" rel="noopener ugc nofollow" target="_blank">MicroFrontend.js</a></code>来处理块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="905f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第13到38行加载小块js文件。当所有的块都被加载后，它在第31行调用<code class="fe nk nl nm nn b">this.renderMicroFrontend()</code>。这就是微前端保持优化的方式。</p><p id="8239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以看到micro-frontend的三个分块文件被加载:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/4c6e5f81505b5e06e8af60dd2c8a2226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WA-rkNfEFwRRaeuuSi4UA.png"/></div></div></figure><p id="67e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们嵌入在应用程序容器的HTML文件中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/52f99b2067acaf6380de61b31776b042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7Rbaz33A7Ejzt4wKO-DbA.png"/></div></div></figure><h2 id="6db3" class="ns mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">钩子版本的MicroFrontend.js</h2><p id="c746" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">作为奖励，我们将MicroFrontend.js转换为使用Hook。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f02c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://gist.github.com/JenniferFuBook/0cd7d34548c76df1837988692880b54c#gistcomment-3350826" rel="noopener ugc nofollow" target="_blank">正如natansevero指出的</a>，对于任何使用该算法并且不想在<code class="fe nk nl nm nn b">&lt;head&gt;</code>标签上加载所有微前端JavaScript的人来说，你可以替换第33行到<code class="fe nk nl nm nn b">document.body.after(script)</code>的代码。工作正常:)</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="e1b2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">代码库</h1><p id="3798" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这个例子有两个代码库:</p><ul class=""><li id="b301" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><strong class="lb iu">app容器:</strong>三步转换后的应用容器位于<a class="ae ky" href="https://github.com/JenniferFuBook/app-container" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ul><pre class="kj kk kl km gt on nn oo op aw oq bi"><span id="6ac2" class="ns mk it nn b gy or os l ot ou">git clone --single-branch --branch chunkOptimization https://github.com/JenniferFuBook/app-container.git<br/>npm i<br/>npm start</span></pre><ul class=""><li id="8d75" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><strong class="lb iu">微前端app: </strong>五步转换的微前端应用位于<a class="ae ky" href="https://github.com/JenniferFuBook/micro-frontend" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ul><pre class="kj kk kl km gt on nn oo op aw oq bi"><span id="b70a" class="ns mk it nn b gy or os l ot ou">git clone --single-branch --branch chunkOptimization https://github.com/JenniferFuBook/micro-frontend.git<br/>npm i<br/>npm start</span></pre><blockquote class="lv lw lx"><p id="bc9f" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><em class="it">作为MicroFrontend.js的这个改进版本，在步骤1中可以不用</em> <code class="fe nk nl nm nn b"><em class="it">react-app-rewired</em></code> <em class="it">，步骤2可以完全跳过。5步减为3.5步。</em></p><p id="f14f" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><em class="it">这种节省在</em> chunkOptimization <em class="it">分支中被捕获。</em></p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="edb9" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">发射命令</h1><p id="f29c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">假设这两个存储库在您的<code class="fe nk nl nm nn b">home</code>目录中。在Bash配置文件中设置以下别名:</p><pre class="kj kk kl km gt on nn oo op aw oq bi"><span id="39af" class="ns mk it nn b gy or os l ot ou">alias runBoth='cd ~/app-container; concurrently "npm start --prefix ~/micro-frontend" "npm start"'</span></pre><p id="493c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">runBoth</code>使用<code class="fe nk nl nm nn b"><a class="ae ky" href="http://micro%20front-end/" rel="noopener ugc nofollow" target="_blank">concurrently</a></code>命令启动app容器和微前端app。对于这个工作分支，我们保留了微前端的优化。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="96a3" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="2abd" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">你不必为了微前端而失去优化。</p><p id="913a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这项工作的一部分是由乔纳森马贡献。</p><p id="5733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。</p><p id="ecec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个关于微前端的系列。以下是其他文章的列表:</p><ul class=""><li id="2463" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">"<a class="ae ky" href="https://medium.com/better-programming/5-steps-to-turn-a-random-react-application-into-a-micro-frontend-946718c147e7" rel="noopener">将随机React应用程序转变为微前端的5个步骤</a>"</li><li id="20b7" class="oe of it lb b lc ov lf ow li ox lm oy lq oz lu oj ok ol om bi translated">"<a class="ae ky" href="https://medium.com/better-programming/3-steps-to-turn-a-random-react-application-into-a-micro-frontend-container-a80e33b6a066" rel="noopener">将随机React应用程序转变为微前端容器的3个步骤</a>"</li><li id="52f7" class="oe of it lb b lc ov lf ow li ox lm oy lq oz lu oj ok ol om bi translated">"<a class="ae ky" href="https://medium.com/better-programming/build-your-own-micro-frontend-ecosystem-a05128c74f99" rel="noopener">打造自己的微前端生态系统</a>"</li><li id="d354" class="oe of it lb b lc ov lf ow li ox lm oy lq oz lu oj ok ol om bi translated">"<a class="ae ky" href="https://medium.com/better-programming/10-decision-points-for-micro-frontends-approach-4ebb4b59f40" rel="noopener">微前端方法的10个决策点</a>"</li><li id="5880" class="oe of it lb b lc ov lf ow li ox lm oy lq oz lu oj ok ol om bi translated">"<a class="ae ky" href="https://medium.com/better-programming/6-steps-to-create-a-multi-version-react-application-1c3e5b5df7e9" rel="noopener">创建多版本React应用程序的6个步骤</a>"</li><li id="de5f" class="oe of it lb b lc ov lf ow li ox lm oy lq oz lu oj ok ol om bi translated">"<a class="ae ky" href="https://medium.com/better-programming/micro-frontends-using-webpack-5-module-federation-3b97ffb22a0d" rel="noopener">使用Webpack 5模块联盟的微前端</a>"</li></ul></div></div>    
</body>
</html>